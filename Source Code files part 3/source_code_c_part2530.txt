MIDL_DEFINE_GUID(IID, DIID__IEdBoxEditorEvents,0x74AAD80C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_EdBoxEditor,0x74AAD80D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IGroupBoxEditor,0x74AAD80E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IGroupBoxEditorEvents,0x74AAD80F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_GroupBoxEditor,0x74AAD810,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IButtonEditor,0x74AAD811,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IButtonEditorEvents,0x74AAD812,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_ButtonEditor,0x74AAD813,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICheckEditor,0x74AAD814,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ICheckEditorEvents,0x74AAD815,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_CheckEditor,0x74AAD816,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IRadioBtnEditor,0x74AAD817,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IRadioBtnEditorEvents,0x74AAD818,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_RadioBtnEditor,0x74AAD819,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IHScrEditor,0x74AAD81A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IHScrEditorEvents,0x74AAD81B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_HScrEditor,0x74AAD81C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IVScrEditor,0x74AAD81D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IVScrEditorEvents,0x74AAD81E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_VScrEditor,0x74AAD81F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IProgressEditor,0x74AAD820,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IProgressEditorEvents,0x74AAD821,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_ProgressEditor,0x74AAD822,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ISpinEditor,0x74AAD823,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ISpinEditorEvents,0x74AAD824,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_SpinEditor,0x74AAD825,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ISliderEditor,0x74AAD826,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ISliderEditorEvents,0x74AAD827,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_SliderEditor,0x74AAD828,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IHotKeyEditor,0x74AAD829,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IHotKeyEditorEvents,0x74AAD82A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_HotKeyEditor,0x74AAD82B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IListEditor,0x74AAD82C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IListEditorEvents,0x74AAD82D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_ListEditor,0x74AAD82E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ITreeEditor,0x74AAD82F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ITreeEditorEvents,0x74AAD830,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_TreeEditor,0x74AAD831,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ITabEditor,0x74AAD832,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ITabEditorEvents,0x74AAD833,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_TabEditor,0x74AAD834,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IAniEditor,0x74AAD835,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IAniEditorEvents,0x74AAD836,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_AniEditor,0x74AAD837,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IRichEditor,0x74AAD838,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IRichEditorEvents,0x74AAD839,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_RichEditor,0x74AAD83A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IDTPEditor,0x74AAD83B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IDTPEditorEvents,0x74AAD83C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_DTPEditor,0x74AAD83D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICalEditor,0x74AAD83E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ICalEditorEvents,0x74AAD83F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_CalEditor,0x74AAD840,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IIPEditor,0x74AAD841,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IIPEditorEvents,0x74AAD842,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_IPEditor,0x74AAD843,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IComboExEditor,0x74AAD844,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IComboExEditorEvents,0x74AAD845,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_ComboExEditor,0x74AAD846,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICustomEditor,0x74AAD847,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ICustomEditorEvents,0x74AAD848,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_CustomEditor,0x74AAD849,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ILBEditor,0x74AAD84A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ILBEditorEvents,0x74AAD84B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_LBEditor,0x74AAD84C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IComboEditor,0x74AAD84D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IComboEditorEvents,0x74AAD84E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_ComboEditor,0x74AAD84F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ISysLinkEditor,0x74AAD890,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ISysLinkEditorEvents,0x74AAD891,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_SysLinkEditor,0x74AAD892,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICustomRes,0x74AAD850,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IHTMLRes,0x74AAD950,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ICustomResEvents,0x74AAD851,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_CustomRes,0x74AAD852,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IAccelRes,0x74AAD853,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IAccelResEvents,0x74AAD854,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_AccelRes,0x74AAD855,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IDlgRes,0x74AAD856,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IDlgResEvents,0x74AAD857,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_DlgRes,0x74AAD858,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IMenuRes,0x74AAD859,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IMenuResEvents,0x74AAD85A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_MenuRes,0x74AAD85B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IVerRes,0x74AAD85C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IVerResEvents,0x74AAD85D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_VerRes,0x74AAD85E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IBitmapRes,0x74AAD85F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IBitmapResEvents,0x74AAD860,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_BitmapRes,0x74AAD861,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICursRes,0x74AAD862,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ICursResEvents,0x74AAD863,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_CursRes,0x74AAD864,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IIconRes,0x74AAD865,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IIconResEvents,0x74AAD866,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_IconRes,0x74AAD867,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ITBRes,0x74AAD868,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ITBResEvents,0x74AAD869,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_TBRes,0x74AAD86A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IStrRes,0x74AAD86B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IStrResEvents,0x74AAD86C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_StrRes,0x74AAD86D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IFileFlags,0x74AAD86E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IVersionBlk,0x74AAD86F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IStrEd,0x74AAD870,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICTBEd,0x74AAD871,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IIconEd,0x74AAD872,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICustomEd,0x74AAD873,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICursorEd,0x74AAD874,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IBmpEd,0x74AAD875,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IAccelEd,0x74AAD876,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IMenuEd,0x74AAD877,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IPopMenu,0x74AAD878,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IRCNode,0x74AAD879,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IRCNodeNotLoaded,0x43177367,0xADEF,0x4330,0xB9,0xAF,0xE8,0x14,0xC5,0xC0,0x35,0xCA);


MIDL_DEFINE_GUID(IID, DIID__IFileFlagsEvents,0x74AAD87A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_FileFlags,0x74AAD87B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IVersionBlkEvents,0x74AAD87C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_VersionBlk,0x74AAD87D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IStrEdEvents,0x74AAD87E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_StrEd,0x74AAD87F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ICTBEdEvents,0x74AAD880,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_CTBEd,0x74AAD881,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IIconEdEvents,0x74AAD882,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_IconEd,0x74AAD883,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ICustomEdEvents,0x74AAD884,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_CustomEd,0x74AAD885,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__ICursorEdEvents,0x74AAD886,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_CursorEd,0x74AAD887,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IBmpEdEvents,0x74AAD888,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_BmpEd,0x74AAD889,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IAccelEdEvents,0x74AAD88A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_AccelEd,0x74AAD88B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IMenuEdEvents,0x74AAD88C,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_MenuEd,0x74AAD88D,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_RCNode,0x74AAD88E,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_PopMenu,0x74AAD88F,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IVCWin32Composition,0xE25A7327,0xDF6D,0x4077,0xA8,0x04,0x13,0x9A,0x5C,0x99,0xD1,0xF8);


MIDL_DEFINE_GUID(IID, IID_IVCWin32CompositionService,0xDD4F4910,0x031D,0x4806,0x86,0x86,0x6E,0xCB,0x52,0xFF,0x59,0x74);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\vcclsvw.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:36 2002
 */
/* Compiler settings for vcclsvw.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCClsVwPackage,0xCC2A8291,0xC75E,0x11d0,0xB5,0x80,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IClsVwInterface,0xCC2A8290,0xC75E,0x11d0,0xB5,0x80,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageNodes,0x3A7B81A0,0xC02A,0x11d0,0x8D,0x2A,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageNode,0xBE2833A0,0xC0B3,0x11d0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IWizardIntegers,0xBE2833A1,0xC0B3,0x11d0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IWizardStrings,0xBE2833A2,0xC0B3,0x11d0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ICollectionEvents,0xA11A3510,0xE60F,0x11d0,0xB5,0x92,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IWizardNode,0xFC3EDB88,0xC0B0,0x11D0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IWizardTransaction,0xFC3EDB8A,0xC0B0,0x11D0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IWizardEnum,0xFC3EDB8D,0xC0B0,0x11D0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IPrivLangItems,0x853D4DF8,0xC30D,0x11D0,0xB5,0x7D,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageItems,0x853D4E07,0xC30D,0x11D0,0xB5,0x7D,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IBscPersistentItem,0x71006EA3,0xC3F1,0x11D0,0xB5,0x7E,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IOleCollection,0x71006EA6,0xC3F1,0x11D0,0xB5,0x7E,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IVCEnum,0xCC4881C5,0xCED5,0x11D0,0xB5,0x86,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageClass,0xBBED9560,0xC995,0x11d0,0xB5,0x81,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageFunction,0xC7861D80,0xD4AD,0x11d0,0xB5,0x8A,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageVariable,0xC7861D81,0xD4AD,0x11d0,0xB5,0x8A,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageClassNode,0x7B794051,0xCEF7,0x11d0,0xB5,0x86,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageMap,0xD49DF1E0,0xDC55,0x11d0,0xB5,0x8C,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_ILanguageMapItem,0xD49DF1E1,0xDC55,0x11d0,0xB5,0x8C,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, IID_IClassProp,0x1B8C521A,0xF8BD,0x11D0,0xB5,0x9C,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, LIBID_VCClsVwLib,0x64BA8A63,0xA7CC,0x11D0,0xA4,0xEE,0x00,0xA0,0xC9,0x0A,0x63,0x33);


MIDL_DEFINE_GUID(CLSID, CLSID_CVCClsVwPackage,0xCC2A8295,0xC75E,0x11d0,0xB5,0x80,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_ClsVwInterface,0x32875B8E,0xC7EA,0x11D0,0xB5,0x80,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_LanguageNodes,0xBE2833A3,0xC0B3,0x11d0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_LanguageNode,0xBE2833A4,0xC0B3,0x11d0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_WizardStrings,0xBE2833A5,0xC0B3,0x11d0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_WizardIntegers,0xBE2833A6,0xC0B3,0x11d0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_WizardNode,0xFC3EDB87,0xC0B0,0x11D0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_WizardTransaction,0xFC3EDB8B,0xC0B0,0x11D0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_WizardEnum,0xFC3EDB8E,0xC0B0,0x11D0,0x8D,0x2B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_BscColl,0x853D4DF9,0xC30D,0x11D0,0xB5,0x7D,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_LanguageItems,0x853D4E08,0xC30D,0x11D0,0xB5,0x7D,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_PrivLangItems,0x7BD8E1F4,0xC37C,0x11D0,0xB5,0x7D,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_BscPersistentItem,0x71006EA4,0xC3F1,0x11D0,0xB5,0x7E,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_LanguageMapItem,0x82632362,0x2098,0x11D1,0xB4,0x47,0x00,0xA0,0xC9,0x15,0x07,0x0C);


MIDL_DEFINE_GUID(CLSID, CLSID_OleCollection,0x71006EA7,0xC3F1,0x11D0,0xB5,0x7E,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_LanguageClass,0xBBED9561,0xC995,0x11d0,0xB5,0x81,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_WizardClassNodeInterface,0xCC4881C3,0xCED5,0x11D0,0xB5,0x86,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_LanguageClassNode,0x7B794052,0xCEF7,0x11d0,0xB5,0x86,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_VCEnum,0xCC4881C6,0xCED5,0x11D0,0xB5,0x86,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_LanguageFunction,0xC7861D84,0xD4AD,0x11d0,0xB5,0x8A,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_LanguageVariable,0xC7861D85,0xD4AD,0x11d0,0xB5,0x8A,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_ClassProp,0x1B8C521B,0xF8BD,0x11D0,0xB5,0x9C,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(CLSID, CLSID_FolderInfo,0x236A9C19,0x076D,0x11D1,0xB5,0x9D,0x00,0xA0,0xC9,0x1B,0xC9,0x42);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\rescom.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:28 2002
 */
/* Compiler settings for rescom.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IResourceRoot,0x971DC6F0,0x20F2,0x11d2,0x99,0xC7,0x00,0xA0,0xC9,0x1B,0xC8,0xE5);


MIDL_DEFINE_GUID(IID, IID_IResourceProject,0x971DC6F1,0x20F2,0x11d2,0x99,0xC7,0x00,0xA0,0xC9,0x1B,0xC8,0xE5);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\vcpb2.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:22 2002
 */
/* Compiler settings for vcpb2.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_VCProjectEngineLibrary,0x9F367018,0x33C6,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, IID_VCCLCompilerTool,0x6B5125E9,0xAA7C,0x11D2,0x8D,0x0F,0x00,0xC0,0x4F,0x8E,0xEA,0x30);


MIDL_DEFINE_GUID(IID, IID_VCLinkerTool,0xBEE77B68,0xF846,0x11D2,0x8B,0x4E,0x00,0xC0,0x4F,0x79,0x56,0xC9);


MIDL_DEFINE_GUID(IID, IID_VCLibrarianTool,0xBEE77B6B,0xF846,0x11D2,0x8B,0x4E,0x00,0xC0,0x4F,0x79,0x56,0xC9);


MIDL_DEFINE_GUID(IID, IID_VCCustomBuildTool,0x0A35DA51,0xAAAD,0x11D2,0x8D,0x0F,0x00,0xC0,0x4F,0x8E,0xEA,0x30);


MIDL_DEFINE_GUID(IID, IID_VCMidlTool,0x0AC5B928,0xF78E,0x11D2,0x8B,0x4E,0x00,0xC0,0x4F,0x79,0x56,0xC9);


MIDL_DEFINE_GUID(IID, IID_VCResourceCompilerTool,0x9C22188A,0xF83A,0x11D2,0x8B,0x4E,0x00,0xC0,0x4F,0x79,0x56,0xC9);


MIDL_DEFINE_GUID(IID, IID_VCPreBuildEventTool,0x5FE8C14A,0x3BDA,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_VCPreLinkEventTool,0x5FE8C14D,0x3BDA,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_VCPostBuildEventTool,0x5FE8C150,0x3BDA,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_VCBscMakeTool,0xBEE77B72,0xF846,0x11D2,0x8B,0x4E,0x00,0xC0,0x4F,0x79,0x56,0xC9);


MIDL_DEFINE_GUID(IID, IID_VCNMakeTool,0x5AD57B85,0x609C,0x11d3,0x94,0x1F,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(IID, IID_VCWebServiceProxyGeneratorTool,0x0C9ED780,0x690D,0x4f0e,0x83,0x77,0x9A,0xED,0xF1,0x5C,0xF9,0xFA);


MIDL_DEFINE_GUID(IID, IID_VCWebDeploymentTool,0x3C8D096C,0x9043,0x4b0d,0xB8,0x89,0x19,0xD3,0x93,0x8B,0xB8,0xDA);


MIDL_DEFINE_GUID(IID, IID_XboxDeploymentTool,0x998D096C,0x9043,0x4b0d,0xB8,0x89,0x19,0xD3,0x93,0x8B,0xB8,0xDA);


MIDL_DEFINE_GUID(IID, IID_XboxImageTool,0x778D096C,0x9043,0x4b0d,0xB8,0x89,0x19,0xD3,0x93,0x8B,0xB8,0xDA);


MIDL_DEFINE_GUID(IID, IID_IVCProjectEngineEvents,0x66DC6C13,0xD282,0x11D2,0x8D,0x1A,0x00,0xC0,0x4F,0x8E,0xEA,0x30);


MIDL_DEFINE_GUID(IID, DIID__dispVCProjectEngineEvents,0x5F495F17,0x94D6,0x43d2,0xAF,0x66,0x49,0x0A,0xA1,0xE0,0x4A,0x79);


MIDL_DEFINE_GUID(IID, IID__VCProjectEngineEvents,0x5F495F18,0x94D6,0x43d2,0xAF,0x66,0x49,0x0A,0xA1,0xE0,0x4A,0x79);


MIDL_DEFINE_GUID(CLSID, CLSID_VCProjectEngineEvents,0x9B3BFEA2,0x2039,0x4702,0x9F,0x2F,0x0B,0x0E,0x86,0x69,0x15,0x4D);


MIDL_DEFINE_GUID(CLSID, CLSID_VCProjectEngineObject,0x9F367027,0x33C6,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\vcpbobjects.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:20 2002
 */
/* Compiler settings for vcpbobjects.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCCollection,0xA54AAE9A,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_VCPlatform,0xA54AAE90,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_VCDebugSettings,0xA54AAE87,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_VCProjectItem,0x33F3D4A0,0x6763,0x4b88,0xB8,0xC5,0x47,0x84,0x46,0xEF,0xB5,0x1E);


MIDL_DEFINE_GUID(IID, IID_VCProject,0x625C6494,0x2C7E,0x11D3,0x87,0xBF,0xA0,0x49,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_VCFile,0x625C6497,0x2C7E,0x11D3,0x87,0xBF,0xA0,0x49,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_VCFilter,0x625C649A,0x2C7E,0x11D3,0x87,0xBF,0xA0,0x49,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_VCConfiguration,0x625C649D,0x2C7E,0x11D3,0x87,0xBF,0xA0,0x49,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_VCStyleSheet,0xCC7AEBB9,0xA788,0x11d3,0xB9,0x9F,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_VCFileConfiguration,0xA54AAE8A,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_VCProjectEngine,0x9F367026,0x33C6,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\VCWiz.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:43 2002
 */
/* Compiler settings for VCWiz.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_VCWIZLib,0x22C6554E,0xE091,0x11D2,0x89,0xCB,0x00,0xC0,0x4F,0x72,0xDA,0xF2);


MIDL_DEFINE_GUID(IID, IID_IVCWizCtlUI,0xB5B21F1F,0xDBCD,0x11D2,0x89,0xCA,0x00,0xC0,0x4F,0x72,0xDA,0xF2);


MIDL_DEFINE_GUID(IID, IID_ICollection,0xEBD8BF28,0x8738,0x46cc,0xA0,0x62,0xFF,0xCA,0x25,0x6B,0x1A,0xF1);


MIDL_DEFINE_GUID(IID, IID_ITypeLibInfo,0x0DD431E6,0xF528,0x4c6d,0xAB,0x42,0x2E,0x2F,0xBD,0x9A,0x51,0x24);


MIDL_DEFINE_GUID(IID, IID__ITypeInfo,0xBBD362EB,0x1378,0x49ab,0x84,0xA4,0x8F,0x4D,0x2A,0x1F,0x31,0x98);


MIDL_DEFINE_GUID(IID, IID_IInterfaceInfo,0x2B001CCB,0x1B88,0x4F8F,0x8E,0xBF,0x14,0xF6,0x17,0x64,0xC1,0x33);


MIDL_DEFINE_GUID(IID, IID_IFuncInfo,0x5C6D01F5,0xBF80,0x4f49,0x8B,0x4D,0x15,0xCA,0xC3,0xB5,0x41,0xE9);


MIDL_DEFINE_GUID(IID, IID_IVarInfo,0xE9B22EAD,0xC474,0x4e60,0x81,0x43,0x62,0xBC,0x46,0x53,0x60,0x4D);


MIDL_DEFINE_GUID(IID, IID_IParamInfo,0x687668DA,0xA151,0x48a4,0xAB,0xCA,0x2D,0x2C,0xFF,0x51,0x25,0x52);


MIDL_DEFINE_GUID(IID, IID_IEnumInfo,0x687668DB,0xA151,0x48a4,0xAB,0xCA,0x2D,0x2C,0xFF,0x51,0x25,0x52);


MIDL_DEFINE_GUID(IID, IID_ICoclassInfo,0xFECFB215,0x8FB2,0x4188,0x93,0x9D,0xA1,0xF2,0xC9,0x77,0x29,0xD4);


MIDL_DEFINE_GUID(IID, IID_IControl,0xD29CD102,0xE6DD,0x42c0,0x92,0x4E,0xE8,0x61,0x77,0xBF,0x0F,0xF8);


MIDL_DEFINE_GUID(IID, DIID__IDispWizComboEvents,0x476424C0,0x1D05,0x40c4,0xA3,0x9E,0x55,0x94,0x25,0x8D,0xCC,0xD9);


MIDL_DEFINE_GUID(IID, IID_IWizCombo,0xB28AE255,0xA530,0x4EAC,0x8D,0x1F,0x44,0x3C,0xAF,0x5D,0x7F,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_TypeLibCollection,0x40C48F63,0x84B8,0x469a,0x9C,0xE4,0x87,0xD2,0x58,0x70,0x53,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_ControlCollection,0x08C69DEA,0x5383,0x477a,0xAE,0xB9,0x49,0xF5,0xA4,0x18,0x2F,0xE6);


MIDL_DEFINE_GUID(CLSID, CLSID_VsWizard,0xF2A8BD47,0xE150,0x11d2,0x89,0xCB,0x00,0xC0,0x4F,0x72,0xDA,0xF2);


MIDL_DEFINE_GUID(CLSID, CLSID_VCWizCtl,0xB5B21F1E,0xDBCD,0x11D2,0x89,0xCA,0x00,0xC0,0x4F,0x72,0xDA,0xF2);


MIDL_DEFINE_GUID(CLSID, CLSID_WizCombo,0xB4455841,0xB9A9,0x441C,0xB0,0x69,0xA7,0xB9,0x88,0x84,0xE2,0xFB);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\vcpberrcontext.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:19 2002
 */
/* Compiler settings for vcpberrcontext.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCBuildErrorContext,0xA8F1429B,0x1E96,0x11D3,0xB9,0x6D,0x00,0xC0,0x4F,0x68,0x5D,0x26);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\wizardbar.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:44 2002
 */
/* Compiler settings for wizardbar.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IObjectList,0x9B3A2FA8,0x5665,0x11d3,0xB9,0x7B,0x00,0xC0,0x4F,0x68,0x5D,0x8C);


MIDL_DEFINE_GUID(IID, IID_IWizBarInfo,0x9B3A2FA7,0x5665,0x11d3,0xB9,0x7B,0x00,0xC0,0x4F,0x68,0x5D,0x8C);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\xmlparser.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:46 2002
 */
/* Compiler settings for xmlparser.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_XMLPSR,0xd242361c,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeSource,0xd242361d,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLParser,0xd242361e,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(IID, IID_IXMLNodeFactory,0xd242361f,0x51a0,0x11d2,0x9c,0xaf,0x00,0x60,0xb0,0xec,0x3d,0x39);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser,0xf5078f19,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser26,0xf5078f20,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);


MIDL_DEFINE_GUID(CLSID, CLSID_XMLParser30,0xf5078f31,0xc551,0x11d3,0x89,0xb9,0x00,0x00,0xf8,0x1f,0xe2,0x21);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\vcprojcnvt2.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:41 2002
 */
/* Compiler settings for vcprojcnvt2.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCProjConvert,0x7D8AE8C4,0x3FD3,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, LIBID_VCPROJCNVTLib,0xD43DAED2,0x3FCF,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(CLSID, CLSID_VCProjConvert,0x7D8AE8C5,0x3FD3,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\vcprojectprivatetypelib.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:25 2002
 */
/* Compiler settings for vcprojectprivatetypelib.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_VCProjectEnginePrivateLibrary,0x9F367019,0x33C6,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, IID_IVCProjectConfigurationSettings,0x625C649D,0x2C7E,0x11D3,0x87,0xBF,0xA0,0x49,0x4C,0xC1,0x00,0x01);


MIDL_DEFINE_GUID(IID, IID_IVCGeneralMakefileSettings,0x625C649E,0x2C7E,0x11D3,0x87,0xBF,0xA0,0x49,0x4C,0xC1,0x00,0x01);


MIDL_DEFINE_GUID(IID, IID_IVCGeneralFileConfigurationSettings,0xA54AAE8A,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x01);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerOptimizationPage,0x3DC89BC3,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerPreProcessorPage,0x3DC89BC4,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerAdvancedPage,0x3DC89BC5,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerCodeGenPage,0x3DC89BC7,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerLanguagePage,0x3DC89BC8,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerPCHPage,0x3DC89BC9,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerOutputPage,0x3DC89BCA,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerBrowsePage,0x3DC89BCC,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCLCompilerGeneralPage,0x3DC89BCD,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCLinkerGeneralPage,0x3DC89BD0,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCLinkerInputPage,0x3DC89BD1,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCLinkerDebugPage,0x3DC89BD4,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCLinkerSystemPage,0x3DC89BD5,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCLinkerOptimizationPage,0x3DC89BD6,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCLinkerAdvancedPage,0x3DC89BD7,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCLinkerMIDLPage,0x3DC89BD9,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCLibrarianPage,0x3DC89BE0,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCCustomBuildPage,0x3DC89BE2,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCMidlGeneralPage,0x3DC89BF0,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCMidlOutputPage,0x3DC89BF2,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCMidlAdvancedPage,0x3DC89BF3,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCResourceCompilerPage,0x3DC89C00,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCPreBuildEventPage,0x3DC89C01,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCPreLinkEventPage,0x3DC89C02,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCPostBuildEventPage,0x3DC89C03,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCBscMakePage,0x3DC89C04,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCNMakePage,0x3DC89C05,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCWebServiceGeneralPage,0x89640493,0x0137,0x4ebe,0xBA,0xFF,0x76,0xCD,0xE1,0xA5,0xA9,0x12);


MIDL_DEFINE_GUID(IID, IID_IVCWebDeploymentGeneralPage,0x0CCB1756,0x6A5B,0x4c37,0xA4,0xAF,0x93,0x55,0x42,0x5B,0xFC,0xE7);


MIDL_DEFINE_GUID(IID, IID_IXboxDeploymentGeneralPage,0xFFCB1756,0x6A5B,0x4c37,0xA4,0xAF,0x93,0x55,0x42,0x5B,0xFC,0xE7);


MIDL_DEFINE_GUID(IID, IID_IXboxImageGeneralPage,0xFF089BD0,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IXboxImageCertificatePage,0xFF189BD0,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IXboxImageTitleInfoPage,0xFF289BD0,0x9037,0x4a77,0xBA,0x41,0x74,0x8E,0xB7,0x4C,0xEB,0x54);


MIDL_DEFINE_GUID(IID, IID_IVCMarshallableEventHandler,0x1C7E1635,0x1D63,0x449e,0xA2,0x78,0x5B,0xC8,0x89,0x88,0x74,0xC6);


MIDL_DEFINE_GUID(CLSID, CLSID_GeneralConfigSettingsPage,0xD41EC335,0x4924,0x11d3,0x94,0x19,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_GeneralFileConfigSettingsPage,0xD41EC335,0x4924,0x11d3,0x94,0x19,0x00,0xC0,0x4F,0x68,0xFB,0x63);


MIDL_DEFINE_GUID(CLSID, CLSID_RCGeneral,0x3FA5D1CF,0x397B,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_RCAdditionalOptions,0x3FA5D1D0,0x397B,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LibGeneral,0xC07EDD30,0x3989,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LibAdditionalOptions,0xC07EDD32,0x3989,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LinkGeneral,0x82FD6C80,0x3992,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LinkInput,0x82FD6C81,0x3992,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LinkDebug,0x82FD6C84,0x3992,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LinkSystem,0x82FD6C85,0x3992,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LinkOptimization,0x82FD6C86,0x3992,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LinkAdvanced,0x82FD6C87,0x3992,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LinkMIDL,0x82FD6C89,0x3992,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_LinkAdditionalOptions,0x82FD6C8A,0x3992,0x11d3,0x94,0x11,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_ClOptimization,0xD0237D6E,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClPreprocessor,0xD0237D6F,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClAdvanced,0xD0237D70,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClCodeGeneration,0xD0237D72,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClLanguage,0xD0237D73,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClPrecompiledHeaders,0xD0237D74,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClOutputFiles,0xD0237D75,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClBrowseInfo,0xD0237D77,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClGeneral,0xD0237D78,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_ClAdditionalOptions,0xD0237D79,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_MidlAdvanced,0xD0237D7A,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_MidlOutput,0xD0237D7D,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_MidlGeneral,0xD0237D7F,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_MidlAdditionalOptions,0xD0237D8A,0x1449,0x11D3,0x83,0x78,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_VCCustomGeneral,0x659554C0,0x3986,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(CLSID, CLSID_VCCustomCommandPage,0x93B8B4D3,0x67ED,0x4e3f,0xBF,0xE1,0x61,0xE8,0x81,0x01,0x83,0xBA);


MIDL_DEFINE_GUID(CLSID, CLSID_VCPreBldGeneral,0x659554C3,0x3986,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(CLSID, CLSID_VCPreLinkGeneral,0x659554C6,0x3986,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(CLSID, CLSID_VCPostBldGeneral,0x659554C9,0x3986,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(CLSID, CLSID_VCNMakeGeneral,0x5AD57B84,0x609C,0x11d3,0x94,0x1F,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_VCBSCGeneral,0x5783E3E6,0x3FAC,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(CLSID, CLSID_BSCAdditionalOptions,0x5783E3E6,0x3FAC,0x11D3,0xB9,0x77,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(CLSID, CLSID_WebUtilityGeneral,0xDA2940CD,0xC9DD,0x4812,0x93,0xA8,0x1D,0xA9,0x49,0x64,0x98,0x79);


MIDL_DEFINE_GUID(CLSID, CLSID_WebDeploymentGeneral,0x8C4053B8,0xCE89,0x4db7,0x8D,0xA4,0x7D,0xF0,0xA6,0x08,0xF5,0x5B);


MIDL_DEFINE_GUID(CLSID, CLSID_WebAdditionalOptions,0xDA2940CE,0xC9DD,0x4812,0x93,0xA8,0x1D,0xA9,0x49,0x64,0x98,0x79);


MIDL_DEFINE_GUID(CLSID, CLSID_XboxDeploymentGeneral,0x994053B8,0xCE89,0x4db7,0x8D,0xA4,0x7D,0xF0,0xA6,0x08,0xF5,0x5B);


MIDL_DEFINE_GUID(CLSID, CLSID_XboxImageGeneral,0x984053B8,0xCE89,0x4db7,0x8D,0xA4,0x7D,0xF0,0xA6,0x08,0xF5,0x5B);


MIDL_DEFINE_GUID(CLSID, CLSID_XboxImageCertificate,0x974053B8,0xCE89,0x4db7,0x8D,0xA4,0x7D,0xF0,0xA6,0x08,0xF5,0x5B);


MIDL_DEFINE_GUID(CLSID, CLSID_XboxImageTitleInfo,0x964053B8,0xCE89,0x4db7,0x8D,0xA4,0x7D,0xF0,0xA6,0x08,0xF5,0x5B);


MIDL_DEFINE_GUID(CLSID, CLSID_VCNodeFactory,0x55C92926,0x601B,0x40f6,0xAE,0xFD,0xBF,0x96,0xBE,0xAF,0x1A,0x1A);


MIDL_DEFINE_GUID(CLSID, CLSID__VCDebugSettings,0xA54AAE88,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_VCPlatformWin32,0xA54AAE91,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_VCPlatformWin64,0xA54AAE92,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_VCPlatformXbox,0xA54AAE93,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DebugSettingsPage,0x4481BEC6,0x4216,0x11d3,0x83,0x7B,0x00,0xC0,0x4F,0x79,0x69,0x61);


MIDL_DEFINE_GUID(IID, IID_IVCBuildActionList,0xA8F14291,0x1E96,0x11D3,0xB9,0x6D,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCBuildAction,0xA8F14294,0x1E96,0x11D3,0xB9,0x6D,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCBuildThread,0x497AAA18,0x2DA9,0x11D3,0xB9,0x6F,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCGenericConfiguration,0x497AAA1C,0x2DA9,0x11D3,0xB9,0x6F,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCBuildOutput,0x497AAA1F,0x2DA9,0x11D3,0xB9,0x6F,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCBuildStringCollection,0x51245D42,0x348B,0x11D3,0xB9,0x75,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCBuildOutputItems,0xA1ECFBAF,0x5CE0,0x11d3,0xB9,0x87,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCBuildOutputItem,0x8A31A36D,0x5EFB,0x11d3,0xB9,0x87,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCVendorToolFactory,0xB7A725A3,0xA298,0x4001,0x9D,0xD3,0xCB,0x99,0x58,0xAE,0x53,0x31);


MIDL_DEFINE_GUID(IID, IID_IVCCommandLine,0x189BB9AD,0x29C5,0x11D3,0xB9,0x6F,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCCommandLineList,0x189BB9B0,0x29C5,0x11D3,0xB9,0x6F,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCBuildEngine,0xA8F1428E,0x1E96,0x11D3,0xB9,0x6D,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCCollectionProvider,0x1F866E1C,0x396D,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, IID_IVCPlatformImpl,0x1F866E1C,0x396C,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, IID_IVCDebugSettingsImpl,0xF5DEB408,0x4130,0x11d3,0xB2,0x79,0x00,0x50,0x04,0x1D,0xB1,0x2A);


MIDL_DEFINE_GUID(IID, IID_IVCGlobals,0x33F3D4A0,0x6763,0x4b88,0xB8,0xC5,0x47,0x84,0x46,0xEF,0xB5,0x1D);


MIDL_DEFINE_GUID(IID, IID_IVCProjectImpl,0x1F866E14,0x396C,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, IID_IVCFileImpl,0x625C64A0,0x2C7E,0x11D3,0x87,0xBF,0xA0,0x49,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IVCFilterImpl,0x1F866E15,0x396C,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, IID_IVCConfigurationImpl,0x1F866E16,0x396C,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, IID_IVCStyleSheetImpl,0x799A8CEB,0xA789,0x11d3,0xB9,0x9F,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCFileConfigurationImpl,0x1F866E17,0x396C,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6);


MIDL_DEFINE_GUID(IID, IID_IVCBuildPackageInternal,0x8ABFB821,0x5120,0x11d3,0xB9,0x82,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCProjectEngineEventsImpl,0x4F88C4A6,0xF38C,0x11D2,0x8D,0x2B,0x00,0xC0,0x4F,0x8E,0xEA,0x30);


MIDL_DEFINE_GUID(IID, IID_IVCProjectEngineImpl,0x4F88C4A5,0xF38C,0x11D2,0x8D,0x2B,0x00,0xC0,0x4F,0x8E,0xEA,0x30);


MIDL_DEFINE_GUID(IID, IID_IVCPropertyContainer,0xA54AAE96,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IVCStagedPropertyContainer,0xA54AAE97,0x30C2,0x11D3,0x87,0xBF,0xA0,0x4A,0x4C,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IVCPropertyPageObject,0xA602E9DD,0x5EE9,0x402a,0x80,0x95,0xAE,0x7E,0x57,0x12,0xB6,0x87);


MIDL_DEFINE_GUID(IID, IID_IVCBuildableItem,0x5FE8C153,0x3BDA,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCExternalCookie,0xEB2E9E31,0x21B0,0x4243,0x9F,0xD0,0xDA,0xB4,0xD8,0x3B,0x63,0xD6);


MIDL_DEFINE_GUID(IID, IID_IVCSettingsPage,0xEB2E9E39,0x21B0,0x4243,0x9F,0xD0,0xDA,0xB4,0xD8,0x3B,0x63,0xD6);


MIDL_DEFINE_GUID(IID, IID_IVCToolImpl,0x5FE8C146,0x3BDA,0x11D3,0xB9,0x76,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCBuildEventToolInternal,0x4D80D0D9,0x51CB,0x11d3,0xB9,0x82,0x00,0xC0,0x4F,0x68,0x5D,0x26);


MIDL_DEFINE_GUID(IID, IID_IVCNodeFactory,0xF85354E3,0x7C5C,0x45f2,0xBE,0xAC,0xFE,0xAE,0x82,0x7B,0x26,0x71);


MIDL_DEFINE_GUID(IID, IID_IVCXMLFile,0xC3E92E87,0x00C7,0x45fb,0x8D,0x14,0xE1,0x38,0x26,0x15,0x7D,0xED);


MIDL_DEFINE_GUID(IID, IID_IVCBuildEngineImpl,0x784E3E24,0x2F27,0x11D3,0xB9,0x70,0x00,0xC0,0x4F,0x68,0x5D,0x26);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\dllapi.h ===
// dllapi.h
//

#ifndef __DLLAPI_H__
#define __DLLAPI_H__

#include <tchar.h>
#include <stdlib.h>
#include <windows.h>

// prototype struct for name->pfn mapping
struct MPSZPFN
{
	_TCHAR *szRoutine;
	FARPROC pfn;
};

#define DECLARE_DLLAPI(var, map, dll)	CDllApi var(#dll, g_mpszpfn##map)
#define BEGIN_MPSZPFN(var)				MPSZPFN g_mpszpfn##var[] = {
#define MPSZPFN_FCN(name)				{#name, 0},
#define END_MPSZPFN(var)				{0,0}};

class CDllApi
{
	CDllApi() { }				// private default ctor--have to use the real one below
	BOOL _fRoutinesOK;			// all routines loaded successfully
	UINT _cRoutines; 			// count of routines in list
	HINSTANCE _hInstance;		// handle to the dll
	MPSZPFN *_mpszpfn;			// mapping from name to pfn
	_TCHAR _szDll[_MAX_PATH];	// dll name

public:
	CDllApi(const _TCHAR *szDll, MPSZPFN *);
	~CDllApi();
	BOOL FLoaded() const { return _hInstance != 0; }
	BOOL FRoutinesLoaded () const { return _fRoutinesOK; }
	FARPROC operator() (UINT iRoutine) {return _mpszpfn[ iRoutine ].pfn; }
};

#endif	// __DLLAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\atlobj.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Dec 18 13:39:09 1998
 */
/* Compiler settings for atlobj.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __atlobj_h__
#define __atlobj_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISymbolMap_FWD_DEFINED__
#define __ISymbolMap_FWD_DEFINED__
typedef interface ISymbolMap ISymbolMap;
#endif 	/* __ISymbolMap_FWD_DEFINED__ */


#ifndef __IAtlInterfaceWizard_FWD_DEFINED__
#define __IAtlInterfaceWizard_FWD_DEFINED__
typedef interface IAtlInterfaceWizard IAtlInterfaceWizard;
#endif 	/* __IAtlInterfaceWizard_FWD_DEFINED__ */


#ifndef __IAtlObjWiz_FWD_DEFINED__
#define __IAtlObjWiz_FWD_DEFINED__
typedef interface IAtlObjWiz IAtlObjWiz;
#endif 	/* __IAtlObjWiz_FWD_DEFINED__ */


#ifndef __IObjWiz_FWD_DEFINED__
#define __IObjWiz_FWD_DEFINED__
typedef interface IObjWiz IObjWiz;
#endif 	/* __IObjWiz_FWD_DEFINED__ */


#ifndef __ISymbolMapDisp_FWD_DEFINED__
#define __ISymbolMapDisp_FWD_DEFINED__
typedef interface ISymbolMapDisp ISymbolMapDisp;
#endif 	/* __ISymbolMapDisp_FWD_DEFINED__ */


#ifndef __IOLEDBConsCode_FWD_DEFINED__
#define __IOLEDBConsCode_FWD_DEFINED__
typedef interface IOLEDBConsCode IOLEDBConsCode;
#endif 	/* __IOLEDBConsCode_FWD_DEFINED__ */


#ifndef __CtlComp_FWD_DEFINED__
#define __CtlComp_FWD_DEFINED__

#ifdef __cplusplus
typedef class CtlComp CtlComp;
#else
typedef struct CtlComp CtlComp;
#endif /* __cplusplus */

#endif 	/* __CtlComp_FWD_DEFINED__ */


#ifndef __CNames_FWD_DEFINED__
#define __CNames_FWD_DEFINED__

#ifdef __cplusplus
typedef class CNames CNames;
#else
typedef struct CNames CNames;
#endif /* __cplusplus */

#endif 	/* __CNames_FWD_DEFINED__ */


#ifndef __CObjDlg_FWD_DEFINED__
#define __CObjDlg_FWD_DEFINED__

#ifdef __cplusplus
typedef class CObjDlg CObjDlg;
#else
typedef struct CObjDlg CObjDlg;
#endif /* __cplusplus */

#endif 	/* __CObjDlg_FWD_DEFINED__ */


#ifndef __CCtlDlg_FWD_DEFINED__
#define __CCtlDlg_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCtlDlg CCtlDlg;
#else
typedef struct CCtlDlg CCtlDlg;
#endif /* __cplusplus */

#endif 	/* __CCtlDlg_FWD_DEFINED__ */


#ifndef __CStockProps_FWD_DEFINED__
#define __CStockProps_FWD_DEFINED__

#ifdef __cplusplus
typedef class CStockProps CStockProps;
#else
typedef struct CStockProps CStockProps;
#endif /* __cplusplus */

#endif 	/* __CStockProps_FWD_DEFINED__ */


#ifndef __CPropDlg_FWD_DEFINED__
#define __CPropDlg_FWD_DEFINED__

#ifdef __cplusplus
typedef class CPropDlg CPropDlg;
#else
typedef struct CPropDlg CPropDlg;
#endif /* __cplusplus */

#endif 	/* __CPropDlg_FWD_DEFINED__ */


#ifndef __CAddInDlg_FWD_DEFINED__
#define __CAddInDlg_FWD_DEFINED__

#ifdef __cplusplus
typedef class CAddInDlg CAddInDlg;
#else
typedef struct CAddInDlg CAddInDlg;
#endif /* __cplusplus */

#endif 	/* __CAddInDlg_FWD_DEFINED__ */


#ifndef __CViperDlg_FWD_DEFINED__
#define __CViperDlg_FWD_DEFINED__

#ifdef __cplusplus
typedef class CViperDlg CViperDlg;
#else
typedef struct CViperDlg CViperDlg;
#endif /* __cplusplus */

#endif 	/* __CViperDlg_FWD_DEFINED__ */


#ifndef __CCompRegDlg_FWD_DEFINED__
#define __CCompRegDlg_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCompRegDlg CCompRegDlg;
#else
typedef struct CCompRegDlg CCompRegDlg;
#endif /* __cplusplus */

#endif 	/* __CCompRegDlg_FWD_DEFINED__ */


#ifndef __CDenaliDlg_FWD_DEFINED__
#define __CDenaliDlg_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDenaliDlg CDenaliDlg;
#else
typedef struct CDenaliDlg CDenaliDlg;
#endif /* __cplusplus */

#endif 	/* __CDenaliDlg_FWD_DEFINED__ */


#ifndef __AtlInterfaceWizard_FWD_DEFINED__
#define __AtlInterfaceWizard_FWD_DEFINED__

#ifdef __cplusplus
typedef class AtlInterfaceWizard AtlInterfaceWizard;
#else
typedef struct AtlInterfaceWizard AtlInterfaceWizard;
#endif /* __cplusplus */

#endif 	/* __AtlInterfaceWizard_FWD_DEFINED__ */


#ifndef __ConsProp_FWD_DEFINED__
#define __ConsProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class ConsProp ConsProp;
#else
typedef struct ConsProp ConsProp;
#endif /* __cplusplus */

#endif 	/* __ConsProp_FWD_DEFINED__ */


#ifndef __ProvName_FWD_DEFINED__
#define __ProvName_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProvName ProvName;
#else
typedef struct ProvName ProvName;
#endif /* __cplusplus */

#endif 	/* __ProvName_FWD_DEFINED__ */


#ifndef __SnapInObj_FWD_DEFINED__
#define __SnapInObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class SnapInObj SnapInObj;
#else
typedef struct SnapInObj SnapInObj;
#endif /* __cplusplus */

#endif 	/* __SnapInObj_FWD_DEFINED__ */


#ifndef __CtlDlg2_FWD_DEFINED__
#define __CtlDlg2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CtlDlg2 CtlDlg2;
#else
typedef struct CtlDlg2 CtlDlg2;
#endif /* __cplusplus */

#endif 	/* __CtlDlg2_FWD_DEFINED__ */


#ifndef __Htmpage_FWD_DEFINED__
#define __Htmpage_FWD_DEFINED__

#ifdef __cplusplus
typedef class Htmpage Htmpage;
#else
typedef struct Htmpage Htmpage;
#endif /* __cplusplus */

#endif 	/* __Htmpage_FWD_DEFINED__ */


#ifndef __OLEDBConsCode_FWD_DEFINED__
#define __OLEDBConsCode_FWD_DEFINED__

#ifdef __cplusplus
typedef class OLEDBConsCode OLEDBConsCode;
#else
typedef struct OLEDBConsCode OLEDBConsCode;
#endif /* __cplusplus */

#endif 	/* __OLEDBConsCode_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ISymbolMap_INTERFACE_DEFINED__
#define __ISymbolMap_INTERFACE_DEFINED__

/* interface ISymbolMap */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISymbolMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C6D58201-1FA3-11D0-BF1E-0000E8D0D146")
    ISymbolMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCOLESTR strSymbol,
            /* [in] */ LPCOLESTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCOLESTR strSymbol,
            /* [retval][out] */ BSTR __RPC_FAR *pstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            const CLSID __RPC_FAR *pclsid,
            BOOL bEnableOK) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymbolMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISymbolMap __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISymbolMap __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISymbolMap __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            ISymbolMap __RPC_FAR * This,
            /* [in] */ LPCOLESTR strSymbol,
            /* [in] */ LPCOLESTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            ISymbolMap __RPC_FAR * This,
            /* [in] */ LPCOLESTR strSymbol,
            /* [retval][out] */ BSTR __RPC_FAR *pstrValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            ISymbolMap __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatus )( 
            ISymbolMap __RPC_FAR * This,
            const CLSID __RPC_FAR *pclsid,
            BOOL bEnableOK);
        
        END_INTERFACE
    } ISymbolMapVtbl;

    interface ISymbolMap
    {
        CONST_VTBL struct ISymbolMapVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymbolMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymbolMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymbolMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymbolMap_Set(This,strSymbol,strValue)	\
    (This)->lpVtbl -> Set(This,strSymbol,strValue)

#define ISymbolMap_Get(This,strSymbol,pstrValue)	\
    (This)->lpVtbl -> Get(This,strSymbol,pstrValue)

#define ISymbolMap_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define ISymbolMap_SetStatus(This,pclsid,bEnableOK)	\
    (This)->lpVtbl -> SetStatus(This,pclsid,bEnableOK)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymbolMap_Set_Proxy( 
    ISymbolMap __RPC_FAR * This,
    /* [in] */ LPCOLESTR strSymbol,
    /* [in] */ LPCOLESTR strValue);


void __RPC_STUB ISymbolMap_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymbolMap_Get_Proxy( 
    ISymbolMap __RPC_FAR * This,
    /* [in] */ LPCOLESTR strSymbol,
    /* [retval][out] */ BSTR __RPC_FAR *pstrValue);


void __RPC_STUB ISymbolMap_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymbolMap_Clear_Proxy( 
    ISymbolMap __RPC_FAR * This);


void __RPC_STUB ISymbolMap_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymbolMap_SetStatus_Proxy( 
    ISymbolMap __RPC_FAR * This,
    const CLSID __RPC_FAR *pclsid,
    BOOL bEnableOK);


void __RPC_STUB ISymbolMap_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymbolMap_INTERFACE_DEFINED__ */


#ifndef __IAtlInterfaceWizard_INTERFACE_DEFINED__
#define __IAtlInterfaceWizard_INTERFACE_DEFINED__

/* interface IAtlInterfaceWizard */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IAtlInterfaceWizard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E491292-0A94-11D1-AF5E-00C04FB99436")
    IAtlInterfaceWizard : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IAtlInterfaceWizardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAtlInterfaceWizard __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAtlInterfaceWizard __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAtlInterfaceWizard __RPC_FAR * This);
        
        END_INTERFACE
    } IAtlInterfaceWizardVtbl;

    interface IAtlInterfaceWizard
    {
        CONST_VTBL struct IAtlInterfaceWizardVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAtlInterfaceWizard_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAtlInterfaceWizard_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAtlInterfaceWizard_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAtlInterfaceWizard_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_atlobj_0095 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_atlobj_0095_0001
    {	atlDA_ODBC	= 0x1,
	atlDA_OLEDB	= 0x2
    }	atlDataAccessTypes;



extern RPC_IF_HANDLE __MIDL_itf_atlobj_0095_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_atlobj_0095_v0_0_s_ifspec;


#ifndef __ATLOBJLib_LIBRARY_DEFINED__
#define __ATLOBJLib_LIBRARY_DEFINED__

/* library ATLOBJLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ATLOBJLib;

#ifndef __IAtlObjWiz_INTERFACE_DEFINED__
#define __IAtlObjWiz_INTERFACE_DEFINED__

/* interface IAtlObjWiz */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAtlObjWiz;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50B42014-8C8A-11d1-B017-00C04FB99436")
    IAtlObjWiz : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ValidateSymbol( 
            BSTR symbol) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAtlObjWizVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAtlObjWiz __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAtlObjWiz __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAtlObjWiz __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateSymbol )( 
            IAtlObjWiz __RPC_FAR * This,
            BSTR symbol);
        
        END_INTERFACE
    } IAtlObjWizVtbl;

    interface IAtlObjWiz
    {
        CONST_VTBL struct IAtlObjWizVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAtlObjWiz_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAtlObjWiz_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAtlObjWiz_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAtlObjWiz_ValidateSymbol(This,symbol)	\
    (This)->lpVtbl -> ValidateSymbol(This,symbol)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IAtlObjWiz_ValidateSymbol_Proxy( 
    IAtlObjWiz __RPC_FAR * This,
    BSTR symbol);


void __RPC_STUB IAtlObjWiz_ValidateSymbol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAtlObjWiz_INTERFACE_DEFINED__ */


#ifndef __IObjWiz_INTERFACE_DEFINED__
#define __IObjWiz_INTERFACE_DEFINED__

/* interface IObjWiz */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObjWiz;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f16680a6-7852-11d2-81c3-00c04f797ab7")
    IObjWiz : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsValidClassSymbol( 
            BSTR symbol) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjWizVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjWiz __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjWiz __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjWiz __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsValidClassSymbol )( 
            IObjWiz __RPC_FAR * This,
            BSTR symbol);
        
        END_INTERFACE
    } IObjWizVtbl;

    interface IObjWiz
    {
        CONST_VTBL struct IObjWizVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjWiz_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjWiz_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjWiz_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjWiz_IsValidClassSymbol(This,symbol)	\
    (This)->lpVtbl -> IsValidClassSymbol(This,symbol)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObjWiz_IsValidClassSymbol_Proxy( 
    IObjWiz __RPC_FAR * This,
    BSTR symbol);


void __RPC_STUB IObjWiz_IsValidClassSymbol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjWiz_INTERFACE_DEFINED__ */


#ifndef __ISymbolMapDisp_INTERFACE_DEFINED__
#define __ISymbolMapDisp_INTERFACE_DEFINED__

/* interface ISymbolMapDisp */
/* [unique][helpstring][uuid][dual][object] */ 


EXTERN_C const IID IID_ISymbolMapDisp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("262CBA84-4105-11d1-AFB0-00C04FB99436")
    ISymbolMapDisp : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ BSTR strSymbol,
            /* [in] */ BSTR strValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR strSymbol,
            /* [retval][out] */ BSTR __RPC_FAR *pstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            VARIANT_BOOL bEnableOK) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymbolMapDispVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISymbolMapDisp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISymbolMapDisp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISymbolMapDisp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISymbolMapDisp __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISymbolMapDisp __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISymbolMapDisp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISymbolMapDisp __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            ISymbolMapDisp __RPC_FAR * This,
            /* [in] */ BSTR strSymbol,
            /* [in] */ BSTR strValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            ISymbolMapDisp __RPC_FAR * This,
            /* [in] */ BSTR strSymbol,
            /* [retval][out] */ BSTR __RPC_FAR *pstrValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            ISymbolMapDisp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatus )( 
            ISymbolMapDisp __RPC_FAR * This,
            VARIANT_BOOL bEnableOK);
        
        END_INTERFACE
    } ISymbolMapDispVtbl;

    interface ISymbolMapDisp
    {
        CONST_VTBL struct ISymbolMapDispVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymbolMapDisp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymbolMapDisp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymbolMapDisp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymbolMapDisp_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISymbolMapDisp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISymbolMapDisp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISymbolMapDisp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISymbolMapDisp_Set(This,strSymbol,strValue)	\
    (This)->lpVtbl -> Set(This,strSymbol,strValue)

#define ISymbolMapDisp_Get(This,strSymbol,pstrValue)	\
    (This)->lpVtbl -> Get(This,strSymbol,pstrValue)

#define ISymbolMapDisp_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define ISymbolMapDisp_SetStatus(This,bEnableOK)	\
    (This)->lpVtbl -> SetStatus(This,bEnableOK)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymbolMapDisp_Set_Proxy( 
    ISymbolMapDisp __RPC_FAR * This,
    /* [in] */ BSTR strSymbol,
    /* [in] */ BSTR strValue);


void __RPC_STUB ISymbolMapDisp_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymbolMapDisp_Get_Proxy( 
    ISymbolMapDisp __RPC_FAR * This,
    /* [in] */ BSTR strSymbol,
    /* [retval][out] */ BSTR __RPC_FAR *pstrValue);


void __RPC_STUB ISymbolMapDisp_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymbolMapDisp_Clear_Proxy( 
    ISymbolMapDisp __RPC_FAR * This);


void __RPC_STUB ISymbolMapDisp_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymbolMapDisp_SetStatus_Proxy( 
    ISymbolMapDisp __RPC_FAR * This,
    VARIANT_BOOL bEnableOK);


void __RPC_STUB ISymbolMapDisp_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymbolMapDisp_INTERFACE_DEFINED__ */


#ifndef __IOLEDBConsCode_INTERFACE_DEFINED__
#define __IOLEDBConsCode_INTERFACE_DEFINED__

/* interface IOLEDBConsCode */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IOLEDBConsCode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F6F76FF2-30A6-11D2-8345-00C04F797AAA")
    IOLEDBConsCode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PromptUser( 
            /* [in] */ HWND hParent,
            atlDataAccessTypes iDataAccessType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessSettings( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Code( 
            /* [out] */ BSTR __RPC_FAR *pCode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClassName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClassName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionString( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Command( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Command( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DataSource( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DataSource( 
            /* [in] */ IUnknown __RPC_FAR *newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Procedure( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Procedure( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Update( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Update( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Insert( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Insert( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Delete( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Delete( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ODBCSnapshot( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ODBCSnapshot( 
            /* [in] */ BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOLEDBConsCodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOLEDBConsCode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOLEDBConsCode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PromptUser )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ HWND hParent,
            atlDataAccessTypes iDataAccessType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessSettings )( 
            IOLEDBConsCode __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Code )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pCode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClassName )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ClassName )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionString )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionString )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Command )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Command )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DataSource )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DataSource )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *newVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Procedure )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Procedure )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Update )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Update )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Insert )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Insert )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Delete )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Delete )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ODBCSnapshot )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ODBCSnapshot )( 
            IOLEDBConsCode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        END_INTERFACE
    } IOLEDBConsCodeVtbl;

    interface IOLEDBConsCode
    {
        CONST_VTBL struct IOLEDBConsCodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOLEDBConsCode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOLEDBConsCode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IOLEDBConsCode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IOLEDBConsCode_PromptUser(This,hParent,iDataAccessType)	\
    (This)->lpVtbl -> PromptUser(This,hParent,iDataAccessType)

#define IOLEDBConsCode_ProcessSettings(This)	\
    (This)->lpVtbl -> ProcessSettings(This)

#define IOLEDBConsCode_get_Code(This,pCode)	\
    (This)->lpVtbl -> get_Code(This,pCode)

#define IOLEDBConsCode_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IOLEDBConsCode_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IOLEDBConsCode_get_ClassName(This,pVal)	\
    (This)->lpVtbl -> get_ClassName(This,pVal)

#define IOLEDBConsCode_put_ClassName(This,newVal)	\
    (This)->lpVtbl -> put_ClassName(This,newVal)

#define IOLEDBConsCode_get_ConnectionString(This,pVal)	\
    (This)->lpVtbl -> get_ConnectionString(This,pVal)

#define IOLEDBConsCode_put_ConnectionString(This,newVal)	\
    (This)->lpVtbl -> put_ConnectionString(This,newVal)

#define IOLEDBConsCode_get_Command(This,pVal)	\
    (This)->lpVtbl -> get_Command(This,pVal)

#define IOLEDBConsCode_put_Command(This,newVal)	\
    (This)->lpVtbl -> put_Command(This,newVal)

#define IOLEDBConsCode_get_DataSource(This,pVal)	\
    (This)->lpVtbl -> get_DataSource(This,pVal)

#define IOLEDBConsCode_put_DataSource(This,newVal)	\
    (This)->lpVtbl -> put_DataSource(This,newVal)

#define IOLEDBConsCode_get_Procedure(This,pVal)	\
    (This)->lpVtbl -> get_Procedure(This,pVal)

#define IOLEDBConsCode_put_Procedure(This,newVal)	\
    (This)->lpVtbl -> put_Procedure(This,newVal)

#define IOLEDBConsCode_get_Update(This,pVal)	\
    (This)->lpVtbl -> get_Update(This,pVal)

#define IOLEDBConsCode_put_Update(This,newVal)	\
    (This)->lpVtbl -> put_Update(This,newVal)

#define IOLEDBConsCode_get_Insert(This,pVal)	\
    (This)->lpVtbl -> get_Insert(This,pVal)

#define IOLEDBConsCode_put_Insert(This,newVal)	\
    (This)->lpVtbl -> put_Insert(This,newVal)

#define IOLEDBConsCode_get_Delete(This,pVal)	\
    (This)->lpVtbl -> get_Delete(This,pVal)

#define IOLEDBConsCode_put_Delete(This,newVal)	\
    (This)->lpVtbl -> put_Delete(This,newVal)

#define IOLEDBConsCode_get_ODBCSnapshot(This,pVal)	\
    (This)->lpVtbl -> get_ODBCSnapshot(This,pVal)

#define IOLEDBConsCode_put_ODBCSnapshot(This,newVal)	\
    (This)->lpVtbl -> put_ODBCSnapshot(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IOLEDBConsCode_PromptUser_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ HWND hParent,
    atlDataAccessTypes iDataAccessType);


void __RPC_STUB IOLEDBConsCode_PromptUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOLEDBConsCode_ProcessSettings_Proxy( 
    IOLEDBConsCode __RPC_FAR * This);


void __RPC_STUB IOLEDBConsCode_ProcessSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_Code_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pCode);


void __RPC_STUB IOLEDBConsCode_get_Code_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_Name_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_Name_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IOLEDBConsCode_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_ClassName_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_ClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_ClassName_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IOLEDBConsCode_put_ClassName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_ConnectionString_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_ConnectionString_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IOLEDBConsCode_put_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_Command_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_Command_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IOLEDBConsCode_put_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_DataSource_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_DataSource_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *newVal);


void __RPC_STUB IOLEDBConsCode_put_DataSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_Procedure_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_Procedure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_Procedure_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IOLEDBConsCode_put_Procedure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_Update_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_Update_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IOLEDBConsCode_put_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_Insert_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_Insert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_Insert_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IOLEDBConsCode_put_Insert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_Delete_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_Delete_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IOLEDBConsCode_put_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_get_ODBCSnapshot_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IOLEDBConsCode_get_ODBCSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IOLEDBConsCode_put_ODBCSnapshot_Proxy( 
    IOLEDBConsCode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IOLEDBConsCode_put_ODBCSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IOLEDBConsCode_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CtlComp;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc6990d-5f09-11d2-81a1-00c04f797ab7")
CtlComp;
#endif

EXTERN_C const CLSID CLSID_CNames;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc6990e-5f09-11d2-81a1-00c04f797ab7")
CNames;
#endif

EXTERN_C const CLSID CLSID_CObjDlg;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc6990f-5f09-11d2-81a1-00c04f797ab7")
CObjDlg;
#endif

EXTERN_C const CLSID CLSID_CCtlDlg;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69910-5f09-11d2-81a1-00c04f797ab7")
CCtlDlg;
#endif

EXTERN_C const CLSID CLSID_CStockProps;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69911-5f09-11d2-81a1-00c04f797ab7")
CStockProps;
#endif

EXTERN_C const CLSID CLSID_CPropDlg;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69912-5f09-11d2-81a1-00c04f797ab7")
CPropDlg;
#endif

EXTERN_C const CLSID CLSID_CAddInDlg;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69913-5f09-11d2-81a1-00c04f797ab7")
CAddInDlg;
#endif

EXTERN_C const CLSID CLSID_CViperDlg;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69914-5f09-11d2-81a1-00c04f797ab7")
CViperDlg;
#endif

EXTERN_C const CLSID CLSID_CCompRegDlg;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69915-5f09-11d2-81a1-00c04f797ab7")
CCompRegDlg;
#endif

EXTERN_C const CLSID CLSID_CDenaliDlg;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69916-5f09-11d2-81a1-00c04f797ab7")
CDenaliDlg;
#endif

EXTERN_C const CLSID CLSID_AtlInterfaceWizard;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69917-5f09-11d2-81a1-00c04f797ab7")
AtlInterfaceWizard;
#endif

EXTERN_C const CLSID CLSID_ConsProp;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69918-5f09-11d2-81a1-00c04f797ab7")
ConsProp;
#endif

EXTERN_C const CLSID CLSID_ProvName;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc69919-5f09-11d2-81a1-00c04f797ab7")
ProvName;
#endif

EXTERN_C const CLSID CLSID_SnapInObj;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc6991A-5f09-11d2-81a1-00c04f797ab7")
SnapInObj;
#endif

EXTERN_C const CLSID CLSID_CtlDlg2;

#ifdef __cplusplus

class DECLSPEC_UUID("7230C7C3-6454-11D1-AAD8-000000000000")
CtlDlg2;
#endif

EXTERN_C const CLSID CLSID_Htmpage;

#ifdef __cplusplus

class DECLSPEC_UUID("6bc6991B-5f09-11d2-81a1-00c04f797ab7")
Htmpage;
#endif

EXTERN_C const CLSID CLSID_OLEDBConsCode;

#ifdef __cplusplus

class DECLSPEC_UUID("F6F76FF3-30A6-11D2-8345-00C04F797AAA")
OLEDBConsCode;
#endif
#endif /* __ATLOBJLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\afxdllxx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXDLLX.H: Extra header for building an MFC Extension DLL
//
// This file is really a source file that you should include in the
// main source file of your DLL.  It must only be included once, and
// not multiple times (you will get linker errors if it is included
// multiple times).  If you do not use _AFXEXT, it is not required
// but you may want the feature it provides.
//
// Previous versions of 32-bit MFC did not require this file.  This version
// requires this file to support dynamic loading of extension DLLs.  In
// other words, if your application does LoadLibrary on any extension
// DLL (instead of binding to the DLL at link time), this file is
// required.

#ifndef VERSION_CHECK_ONLY
#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

// The following symbol used to force inclusion of this module for _AFXEXT
#if defined(_X86_) || defined(_MAC)
extern "C" { int _afxForceEXTDLL; }
#else
extern "C" { int __afxForceEXTDLL; }
#endif

/////////////////////////////////////////////////////////////////////////////
// RawDllMain that saves current app class list and factory list

extern "C" BOOL WINAPI ExtRawDllMain(HINSTANCE, DWORD dwReason, LPVOID);

// modification from original: below line commented out so package RawDllMain called
// extern "C" BOOL (WINAPI* _pRawDllMain)(HINSTANCE, DWORD, LPVOID) = &ExtRawDllMain;

extern "C"
BOOL WINAPI ExtRawDllMain(HINSTANCE, DWORD dwReason, LPVOID)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// save critical data pointers before running the constructors
		AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
		pModuleState->m_pClassInit = pModuleState->m_classList;
		pModuleState->m_pFactoryInit = pModuleState->m_factoryList;
		pModuleState->m_classList.m_pHead = NULL;
		pModuleState->m_factoryList.m_pHead = NULL;
	}
	return TRUE;    // ok
}

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif
#endif // !VERSION_CHECK_ONLY

/////////////////////////////////////////////////////////////////////////////
// Package version checking

#ifdef _M_IX86
#ifdef _DEBUG
#define PACKVFILENAME "i386\pkgverd.h"      // Generated at shell compile-time
#else
#define PACKVFILENAME "i386\pkgver.h"       // Generated at shell compile-time
#endif
#elif defined(_M_MRX000)
#ifdef _DEBUG
#define PACKVFILENAME "mips\pkgverd.h"
#else
#define PACKVFILENAME "mips\pkgver.h"
#endif
#elif defined(_M_PPC)
#ifdef _DEBUG
#define PACKVFILENAME "ppc\pkgverd.h"
#else
#define PACKVFILENAME "ppc\pkgver.h"
#endif
#elif defined(_M_ALPHA)
#ifdef _DEBUG
#define PACKVFILENAME "alpha\pkgverd.h"
#else
#define PACKVFILENAME "alpha\pkgver.h"
#endif
#else
#error Unsupported Platform
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\ipcits.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.45 */
/* at Thu Sep 12 18:04:33 1996
 */
/* Compiler settings for ipcits.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ipcits_h__
#define __ipcits_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IInternalTrackSelection_FWD_DEFINED__
#define __IInternalTrackSelection_FWD_DEFINED__
typedef interface IInternalTrackSelection IInternalTrackSelection;
#endif 	/* __IInternalTrackSelection_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Sep 12 18:04:33 1996
 * using MIDL 3.00.45
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//--------------------------------------------------------------------------


//----------------------------------------------------------------
// IInternalTrackSelection interface
//----------------------------------------------------------------
// {BBB459C0-FF27-11cf-A1E4-00AA00C09209}
DEFINE_GUID(IID_IInternalTrackSelection, 
0xbbb459c0, 0xff27, 0x11cf, 0xa1, 0xe4, 0x0, 0xaa, 0x0, 0xc0, 0x92, 0x9);


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IInternalTrackSelection_INTERFACE_DEFINED__
#define __IInternalTrackSelection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInternalTrackSelection
 * at Thu Sep 12 18:04:33 1996
 * using MIDL 3.00.45
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IInternalTrackSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInternalTrackSelection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsExternalSelectChange( 
            /* [out] */ VARIANT_BOOL __RPC_FAR *pbReturn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnInternalSelectChange( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInternalSelectList( 
            /* [out] */ CALPOLESTR __RPC_FAR *pcaStringsOut,
            /* [out] */ CADWORD __RPC_FAR *pcaCookiesOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternalTrackSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInternalTrackSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInternalTrackSelection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInternalTrackSelection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsExternalSelectChange )( 
            IInternalTrackSelection __RPC_FAR * This,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pbReturn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnInternalSelectChange )( 
            IInternalTrackSelection __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInternalSelectList )( 
            IInternalTrackSelection __RPC_FAR * This,
            /* [out] */ CALPOLESTR __RPC_FAR *pcaStringsOut,
            /* [out] */ CADWORD __RPC_FAR *pcaCookiesOut);
        
        END_INTERFACE
    } IInternalTrackSelectionVtbl;

    interface IInternalTrackSelection
    {
        CONST_VTBL struct IInternalTrackSelectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternalTrackSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternalTrackSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternalTrackSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternalTrackSelection_IsExternalSelectChange(This,pbReturn)	\
    (This)->lpVtbl -> IsExternalSelectChange(This,pbReturn)

#define IInternalTrackSelection_OnInternalSelectChange(This,dwCookie)	\
    (This)->lpVtbl -> OnInternalSelectChange(This,dwCookie)

#define IInternalTrackSelection_GetInternalSelectList(This,pcaStringsOut,pcaCookiesOut)	\
    (This)->lpVtbl -> GetInternalSelectList(This,pcaStringsOut,pcaCookiesOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternalTrackSelection_IsExternalSelectChange_Proxy( 
    IInternalTrackSelection __RPC_FAR * This,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pbReturn);


void __RPC_STUB IInternalTrackSelection_IsExternalSelectChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternalTrackSelection_OnInternalSelectChange_Proxy( 
    IInternalTrackSelection __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IInternalTrackSelection_OnInternalSelectChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternalTrackSelection_GetInternalSelectList_Proxy( 
    IInternalTrackSelection __RPC_FAR * This,
    /* [out] */ CALPOLESTR __RPC_FAR *pcaStringsOut,
    /* [out] */ CADWORD __RPC_FAR *pcaCookiesOut);


void __RPC_STUB IInternalTrackSelection_GetInternalSelectList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternalTrackSelection_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\checklis.h ===
/////////////////////////////////////////////////////////////////////////////
// Check listbox
//
// A CCheckList is a listbox with a checkbox to the left of each item.
// The user interface is exactly the same as a listbox with these
// exceptions:
//
//     * Left mouse button clicks (or double clicks) on the checkbox
//       part of an item toggle the check state.
//     * Pressing the spacebar when an item is selected will toggle
//       the check state of that item.
//     * For multi-sel listbox's, the spacebar will cycle through the
//       four state combinations (unselected-unchecked, selected-unchecked,
//       unselected-checked, selected-checked).
//
// These controls may be created explicitly with Create(), or existing
// listbox windows may be "subclassed" with SubclassDlgItem().
//
// When creating one of these (or specifying one in a dialog template)
// make sure the LBS_OWNERDRAWFIXED and LBS_HASSTRINGS styles are set.
//
// The class supports different sized fonts and will ensure that items
// are tall enough to contain both the box and the text.  The font may
// be changed dynamically.
//
// The default implementation uses the item data to store the state
// of the checkbox.  If the item data is needed for some other purpose,
// the SetCheck() and GetCheck() functions should be overrided to
// use an alternate storage location.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CHECKLIS_H__
#define __CHECKLIS_H__

#include "slob.h"
#ifndef SLOBAPI
#define SLOBAPI __declspec()
#endif

#define CLN_CHKCHANGE (20)
#define ON_CLN_CHKCHANGE(id, memberFxn) \
	{ WM_COMMAND, (WORD)CLN_CHKCHANGE, (WORD)id, (WORD)id, AfxSig_vv, \
		(AFX_PMSG)memberFxn },

class SLOBAPI CCheckList : public CListBox
{
// Construction
public:
	CCheckList();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
public:
	virtual BOOL IsTriState(int nItem) {return FALSE;}
	// nCheck -
	// 0 = unchecked
	// 1 = checked
	// 2 = undeterminate
	virtual void SetCheck(int nItem, int nCheck);
	virtual int GetCheck(int nItem);

// Operations
public:
	BOOL SubclassDlgItem(UINT nID, CWnd* pParent);

// Implementation
protected:
	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	void MeasureItem(LPMEASUREITEMSTRUCT lpmis);
	void InvalidateCheck(int nItem);
	void ResetItemHeight();

	virtual void ItemStringOut (CDC * pDC, const CString& strOut, const CRect& rect);
	
	int m_cyItem;	// Height of item including check box
	int m_cyText;	// Height of text only
	static CBitmap c_checkBitmap;
	static CSize c_checkSize;

	// Message map functions
protected:
	//{{AFX_MSG(CCheckList)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

	virtual void GetDisplayText(int index, CDC *pDC, const CRect&, CString& strOut);
};

/////////////////////////////////////////////////////////////////////////////
// CPropCheckList window - a check-list that can show/set property values

class SLOBAPI CPropCheckList : public CCheckList
{
public:
	virtual void OnPropChanged(UINT nIDProp);

	// add an association between item text and property to the list
	int AddItem(LPCTSTR szId, UINT nIDProp);

	// which CSlob do the properties in this list belong to?
	inline void SetSlob(CSlob* pSlob) {m_pSlob = pSlob;}

protected:
	// provide property processing
	virtual BOOL IsTriState(int);
	virtual void SetCheck(int, int);
	virtual int GetCheck(int);

private:
	CSlob * m_pSlob;
};


/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\hu_ctnr.h ===
//---------------------------------------------------------------------------
// Microsoft Visual InterDev
//
// Microsoft Confidential
// Copyright 1994 - 1997 Microsoft Corporation. All Rights Reserved.
//
// File: hu_ctnr.h
// Area: Namespace utilities
// Contents: CHierContainer class
//	Description: Derived from CHierNode class, it is a container
// 	(ie. non-leaf) element in a heirarchy.
//---------------------------------------------------------------------------

#ifndef __HU_CTNR_H__
#define __HU_CTNR_H__

#ifndef  __HU_NODE_H__
#include "hu_node.h"
#endif

#include "hu_archy.h"

//-----------------------------------------------------------------------------
// Name: CHierContainer
//
// Description:
//	Class for every object in a hierarchy that has children. Implements the
//	idea of a node that has children, relies on CHierNode to take care of
//	parent/sibling info.
//
//-----------------------------------------------------------------------------
class CHierContainer : 
	public CHierImpl<CHierContainer, CHierNode, Type_CHierContainer>
{
protected:
			 CHierContainer(void);


public: // CHierNode overrides
	virtual ~CHierContainer(void);
	virtual VSITEMID GetFirstChild(void);

public:
	HRESULT SetProperty(VSHPROPID propid, const VARIANT& var);
	// CHierNode virtual methods
	virtual BOOL		IsContainer(void) const;	// returns TRUE
	virtual BOOL		IsTypeOf(int nodeType) const;

	// CHierContainer virtual methods
	virtual HRESULT		Refresh(CVsHierarchy *pCVsHierarchy);
	virtual HRESULT		EnumerateChildren(void) = 0;
	virtual	UINT		GetKindOf(void) const;
	virtual HRESULT DisplayContextMenu(VARIANT *pvaIn);

	// Property functions
	virtual HRESULT		GetProperty(VSHPROPID propid, VARIANT* pvar);

	virtual CHierNode*	GetHeadEx(void);

	CHierNode* GetHead(void) const
	{
		return m_pHeadNode;
	}
	CHierNode* GetTail(void) const
	{
		return m_pTailNode;
	}
	long GetCount(void) const;	// return number of children

	CHierNode* GetPrevChildOf(const CHierNode* pCurrent) const;

	// Override to get custom add behavior suchas keeping the list sorted.
	// Default calls AddTail(). 
	virtual void Add(CHierNode *const pNode);

	void 	AddAfter(CHierNode* const pCurrNode, CHierNode* const pNewNode);
	void	AddHead(CHierNode *const pNode);
	void	AddTail(CHierNode *const pNode);
	virtual HRESULT Remove(CHierNode* pNode);
	virtual HRESULT Delete(CHierNode* pNode, CVsHierarchy *pCVsHierarchy);
	virtual void	DeleteAll(CVsHierarchy *pCVsHierarchy);

	// returns the node from child list who's GetCaption() == pszCaption
	CHierNode *GetNodeByCaption(LPCTSTR pszCaption);
	CHierNode *GetNodeByIndex(DWORD dwIndex);
	CHierNode *GetNodeByVariant(const VARIANT *pvar);

	virtual const CString& GetCaption(void) = 0;
	virtual const CString& GetFullPath(void) = 0;
	virtual void SetCaption(LPCSTR pszNewCaption) = 0;
	virtual void SetCaption(LPCWSTR pszNewCaption) = 0;
	virtual void SetCaption(const CString& strNewCaption) = 0;
	virtual	HRESULT			CleanUpBeforeDelete() = 0;


	void SetRevaluateChildren() { m_grfStateFlags &= ~ST_ChildrenEnumerated; }

	BOOL HaveChildrenBeenEvaluated(void) const
	{
		return (m_grfStateFlags & ST_ChildrenEnumerated);
	}
	BOOL IsExpanded(void) const
	{
		return (m_grfStateFlags & ST_IsExpanded);
	}

protected:
	void NotifyHierarchyOfAdd(CHierNode* pNodePrev, CHierNode* pNodeAdded)
	{
		if (HaveChildrenBeenEvaluated())
		{
			GetCVsHierarchy()->OnItemAdded(this, pNodePrev, pNodeAdded);
		}
	}

	BOOL m_fAutoExpand;
	DWORD		m_grfStateFlags;		// ChildrenEnumerated, IsExpanded, etc
	enum	// m_grfStateFlags
	{
		ST_ChildrenEnumerated = (1<<0),
		ST_IsExpanded = (1<<1),
		ST_FirstUserFlag = (1<<16)	// Derived classes are free to use these upper bits
	};

	CHierNode*	m_pHeadNode;
	CHierNode*	m_pTailNode;
};

#endif // __HU_CTNR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\dlgbase.h ===
///////////////////////////////////////////////////////////////////////////////
//	DLGBASE.H
//		Declarations for the sushi dialog base classes.
//
#ifndef __DLGBASE_H__
#define __DLGBASE_H__

#ifndef __PATH_H__
#include "path.h"
#endif

#include "stdfont.h"

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA
#ifndef SLOBAPI
#define SLOBAPI __declspec()
#endif

// Set standard fonts in dialog template
void SetStdFont(C3dDialogTemplate & dt);

// All Sushi dialog boxes should derive from this class...
//
class SLOBAPI C3dDialog : public CDialog
{
public:
	C3dDialog() {m_pLocInfo = NULL;};
	C3dDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL, CLocaleInfo  *pLocInfo = NULL);
	C3dDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL, CLocaleInfo  *pLocInfo = NULL);

	virtual INT_PTR DoModal();
	virtual BOOL Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	virtual BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);
	
	afx_msg void OnRobustOK();
	afx_msg LRESULT OnTestMenu(WPARAM wParam, LPARAM lParam);

	DECLARE_MESSAGE_MAP()

protected:
	CLocaleInfo  *m_pLocInfo;
};

extern BOOL FindAccel( LPCTSTR lpstr, MSG *pMsg );

class SLOBAPI C3dFileDialog : public CFileDialog
{
public:
	C3dFileDialog(BOOL bOpenFileDialog, // TRUE for Open, FALSE for SaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		UINT nHelpID = 0, UINT nExplorerDlg = (UINT)-1);
	~C3dFileDialog();

	LPCTSTR GetFilterExtension(int n);
	void UpdateType(LPCTSTR lpszExt = NULL);
	void ApplyDefaultExtension(void);
	void SetOkButtonText(UINT ids);

	virtual INT_PTR DoModal();

	afx_msg void OnRobustOK();
	afx_msg void OnNameKillFocus();
	afx_msg void OnFileListSelChange();
	afx_msg void OnScc();

	void UpdateMultiSelectOnNT(void);

	virtual void OnOK();
	virtual void OnCancel ();
	virtual BOOL OnFileNameOK();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnInitDialog();

	BOOL IsExplorer()
		{ return m_ofn.Flags & OFN_EXPLORER; }

	// essentially overrides for MFC's GetStartPosition and GetNextPathName,
	// but which help us deal with limitations on multiple-selection handling.
	POSITION GetFullFileStartPosition();
	CString GetNextFullFileName(POSITION pos);

	DECLARE_MESSAGE_MAP()

protected:
	CDir m_dirCurBefore;	// Current dir before dialog goes up
	CDir m_dirCurAfter;		// Current dir after dismissal

public:
	CStringArray* m_psaFileNames;
	UINT m_iddWin95;
	UINT m_iddWinNT;
	BOOL m_bMultiSelectOnNT;
	BOOL m_bSccEnabled;
};

extern void AppendFilterSuffix(CString& filter, OPENFILENAME& ofn,
	const CString& strFilterName, BOOL bSetDefExt = FALSE);

extern void AppendFilterSuffix(CString& filter, OPENFILENAME& ofn,
	UINT idFilter, BOOL bSetDefExt = FALSE);

extern BOOL AddRegistryFilters(CString& strFilter, int nDesiredType, OPENFILENAME& ofn);

extern void AddWildFilter(CString& strFilter, OPENFILENAME& ofn);

extern void SetFileFilters(CString& strFilter, OPENFILENAME& ofn, int nDesiredType, 
	UINT* rgidDefaults, int nDefaults, const TCHAR* szCommon = NULL);

#define FLT_OPEN			1	// The File Open dialog
#define FLT_PROJECTFILES	2	// The Project Files dialog
#define FLT_TEXTFILES		4	// The Find in Files dialog

#endif	// __DLGBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\fmtinfo.h ===
//	REVIEW(DavidGa):  This needs to be drastically simplified and moved
//                    into shlsrvc.h.

//								FMTINFO.H
//
//	Classes defined:
//
//		CFormatInfo
//		CFormatInfoArray
//
//	Structures defined:
//
//		FMT_ELEMENT
//		FMT_WINDOW
//		FMT_WINGROUP
//		LOGFONTSEARCH
//		AUTO_COLOR
//
///////////////////////////
//
//	This provides font and color support for packages.  The FMT_* structures can be used by
//	the packages to statically define the default values.  CFormatInfo manages a single
//	FMT_WINGROUP structure and all it points to.  CFormatInfoArray is used by the dialog to manage
//	the CFormatInfo instances supplied by the packages.
//
/////

class CFormatInfo;
class CFmtIterator;
class CFmtGroupIterator;
class CFmtWindowIterator;
class CFmtElementIterator;
class CFCDialogState;
class CFontColorDlg;	// Define in fcdialog.h

class CPackage;

#ifndef __FMTINFO_H__
#define __FMTINFO_H__

_TCHAR * NewString (const _TCHAR * sz);

#define RGB_BLACK		RGB(0x00, 0x00, 0x00)
#define RGB_WHITE		RGB(0xFF, 0xFF, 0xFF)
#define RGB_RED			RGB(0xFF, 0x00, 0x00)
#define RGB_GREEN		RGB(0x00, 0xFF, 0x00)
#define RGB_BLUE		RGB(0x00, 0x00, 0xFF)
#define RGB_YELLOW		RGB(0xFF, 0xFF, 0x00)
#define RGB_MAGENTA		RGB(0xFF, 0x00, 0xFF)
#define RGB_CYAN		RGB(0x00, 0xFF, 0xFF)
#define RGB_LIGHTGRAY	RGB(0xC0, 0xC0, 0xC0)
#define RGB_GRAY		RGB(0x80, 0x80, 0x80)
#define RGB_DARKRED		RGB(0x80, 0x00, 0x00)
#define RGB_DARKGREEN	RGB(0x00, 0x80, 0x00)
#define RGB_DARKBLUE	RGB(0x00, 0x00, 0x80)
#define RGB_LIGHTBROWN	RGB(0x80, 0x80, 0x00)
#define RGB_DARKMAGENTA	RGB(0x80, 0x00, 0x80)
#define RGB_DARKCYAN	RGB(0x00, 0x80, 0x80)

// IMPORTANT: These macros depend heavily on the order of things in colors.cpp.
//    1) The order of colors in window must be Source Text, Text Selection, Text Highlight.
#define AUTO_TEXT			{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT },	{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define AUTO_SELECTION		{ TRUE, FALSE, FALSE, TRUE, FALSE, 0 },					{ TRUE, FALSE, FALSE, TRUE, FALSE, 0 }
#define AUTO_HIGHLIGHT 		{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },	{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define AUTO_REF(n) 		{ TRUE, FALSE, FALSE, FALSE, FALSE, n }, 	{ TRUE, FALSE, FALSE, FALSE, FALSE, n }
#define AUTO_REF_SRC(n) 	{ TRUE, FALSE, TRUE, FALSE, FALSE, n }, 	{ TRUE, FALSE, TRUE, FALSE, FALSE, n }

#define BACKAUTO_TEXT			{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT },	{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define BACKAUTO_SELECTION		{ FALSE, FALSE, FALSE, TRUE, FALSE, 0 },					{ TRUE, FALSE, FALSE, TRUE, FALSE, 0 }
#define BACKAUTO_HIGHLIGHT 		{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },	{ TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define BACKAUTO_REF(n) 		{ FALSE, FALSE, FALSE, FALSE, FALSE, n }, 	{ TRUE, FALSE, FALSE, FALSE, FALSE, n }
#define BACKAUTO_REF_SRC(n) 	{ FALSE, FALSE, TRUE, FALSE, FALSE, n }, 	{ TRUE, FALSE, TRUE, FALSE, FALSE, n }

#define NOTAUTO_TEXT		{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT },	{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define NOTAUTO_SELECTION	{ FALSE, FALSE, FALSE, TRUE, FALSE, 0 },	{ FALSE, FALSE, FALSE, TRUE, FALSE, 0 }
#define NOTAUTO_HIGHLIGHT	{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },	{ FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define NOTAUTO_REF(n) 		{ FALSE, FALSE, FALSE, FALSE, FALSE, n }, 		{ FALSE, FALSE, FALSE, FALSE, FALSE, n }
#define NOTAUTO_REF_SRC(n) 	{ FALSE, FALSE, TRUE, FALSE, FALSE, n }, 		{ FALSE, FALSE, TRUE, FALSE, FALSE, n }


struct AUTO_COLOR
{
	WORD	bOn:1;		// Is auto color being used now?
	WORD	bSys:1;		// Get the color from the system(1) or from a window(0)?
	WORD	bSrc:1;		// If bSys == 0, use this window(0) or the Source Window(1)?
	WORD	bRev:1;		// If from this window, reverse fore/background(1)?
	WORD	bUpd:1;		// Used by UpdateAutoColors().
	WORD	index:5;	// Index into element list(bSys==0) or COLOR_* value (bSys==1).
};

// This structure is used to translate between a Windows LOGFONT
// structure and name/size/flags combination.
//
struct LOGFONTSEARCH
{
	LOGFONT		LogFont;
	TCHAR *		szFontFace;
	BYTE		nFontSize;
	BYTE		nCharSet;
	int			nPixPerInchY;
	BOOL		bMonospace:1;
	BOOL		bTrueType:1;
};


struct FMT_ELEMENT
{
	TCHAR *		szElement;
	COLORREF	rgbText;
	COLORREF	rgbBackground;
	AUTO_COLOR	autoFore;
	AUTO_COLOR	autoBack;
};

struct FMT_WINDOW
{
	TCHAR *			szWindow;
	TCHAR *			szRegEntry;
	BOOL			bChanged:1;
	BOOL			bMonospace:1;
	TCHAR *			szFontFace;
	UINT			nFontSize;
	PLOGFONT		pLogFont;
	int				nElements;
	FMT_ELEMENT *	rgElements;
};

struct FMT_WINGROUP
{
	int				nWindows;
	BOOL			bSingleGroup:1;	// If this is a singleton, do we show the group name?
	_TCHAR *		szName;		// Name of Windows group
	FMT_WINDOW *	rgWindows;
};


#define FMT_ELEMENTS(x)		(sizeof(x) / sizeof(FMT_ELEMENT))
#define FMT_WINDOWS(x)		(sizeof(x) / sizeof(FMT_WINDOW))

enum DialogState { PreDialog, SelAll, SelGroup, SelWindow, PostDialog };

//////////////////////////////////////////////////////////////////////////////
//																			//
//							class CFormatInfo								//
//																			//
//	This class handles one instance of FMT_WINGROUP data.					//
//																			//
//////////////////////////////////////////////////////////////////////////////


class CFormatInfo : public CObject
{
// Iterators are friends.
friend CFmtIterator;
friend CFmtGroupIterator;
friend CFmtWindowIterator;
friend CFmtElementIterator;
friend CFCDialogState;

DECLARE_DYNAMIC (CFormatInfo);

private:
	CPackage * 		m_pPackage;		// Package info belongs to
	FMT_WINGROUP *	m_pWinGroup;
	int				m_nWinGroups;
	CFormatInfo *	m_pFormatInfoFromPackage;

	// These are used by the Registry code
	//
	static _TCHAR	m_szRegKey[];
	static _TCHAR	m_szFontFace[];
	static _TCHAR	m_szFontSize[];
	static _TCHAR	m_szCharSet[];

	// This is useful to know
	//
	static int		m_nPixPerInchY;

	// These are useful tools

	void SetForeColor ( UINT iFmtInfo, UINT iGroup, UINT iElement, COLORREF rgb );
	void SetBackColor ( UINT iFmtInfo, UINT iGroup, UINT iElement, COLORREF rgb );

public:
	CFormatInfo ( CPackage * pPackage = NULL);
	~CFormatInfo ();

	void Clear ();	// Remove and free all data

	BOOL IsEmpty () const { return m_nWinGroups == 0; }

	void SaveToRegistry () const;
	void UpdateFromRegistry ();

	BOOL GetFormatInfo ( CPackage * pPackage = NULL);

	const CFormatInfo& operator= (const FMT_WINGROUP&);
	const CFormatInfo& operator= (const CFormatInfo&);
	const CFormatInfo& operator+= (const FMT_WINGROUP&);

	FMT_ELEMENT * GetElementList ( const _TCHAR * szWindow ) const;
	FMT_WINDOW *  GetWindow ( const _TCHAR * szWindow ) const;

	int GetWindowCount () const;

	void UpdateAutoColors (FMT_WINDOW * pWindow);
	void UpdateAllAutoColors ();

	void Update (const CFormatInfo& fmtInfo, int iWinGroup = -1, int iWindow = -1);

	void UpdateAllLogFonts ();

	static int GetLogFont (LOGFONTSEARCH * pSearchLogFont);
	static void UpdateLogFont (FMT_WINDOW * pWindow);

	// This is used as an EnumLogFont callack to get the LOGFONT struct for
	// a given set of name/size/flags.  LPARAM is a pointer to a
	// LOGFONTSEARCH.
	static int CALLBACK SearchCallBack(CONST ENUMLOGFONT *, CONST NEWTEXTMETRIC *, int, LPARAM);


	//
	// Support for Fonts and Colors dialog
	//
	BOOL Commit () const;
	BOOL IsDirty () const;

	void Clean ();
};


//////////////////////////////////////////////////////////////////////////////
//						class CFmtIterator									//
//						class CFmtGroupIterator								//
//						class CFmtWindowIterator							//
//						class CFmtElementIterator							//
//																			//
//	Iteration classes for CFormatInfo.										//
//																			//
//////////////////////////////////////////////////////////////////////////////

class CFmtIterator
{
protected:

	const CObArray&	m_rgFmtInfo;
	int		m_iFmtInfo;

public:
	CFmtIterator ( const CObArray& rgFmtInfo);

	CFormatInfo * Get ();
	CFormatInfo * Peek () const;

	inline void Inc ();

	inline UINT	GetIndex () const;
	inline void	Set (int iFmtInfo);
};

class CFmtGroupIterator : public CFmtIterator
{
protected:

	int	m_iGroup;

public:
	CFmtGroupIterator ( const CObArray& rgFmtInfo);

	FMT_WINGROUP * Get ();
	FMT_WINGROUP * Peek () const;

	inline void Inc ();

	void	SetLinear (UINT iGroupLinear);
	void	Set (FMT_WINGROUP * pWindow);
	inline void	Set (int iFmtInfo, int iWinGroup);
	FMT_WINGROUP *  GetLinear ();
	FMT_WINGROUP * PeekLinear ();
	
	inline UINT	GetIndex () const;
};

class CFmtWindowIterator : public CFmtGroupIterator
{
protected:

	int		m_iWindow;


public:
	CFmtWindowIterator ( const CObArray& rgFmtInfo);

	FMT_WINDOW * Get ();
	FMT_WINDOW * Peek () const;

	inline void Inc ();

	void	SetLinear (UINT iWinLinear);
	void	Set (FMT_WINDOW * pWindow);
	FMT_WINDOW * GetLinear ();
	FMT_WINDOW * PeekLinear ();

	inline UINT	GetIndex () const;
};

class CFmtElementIterator : public CFmtWindowIterator
{
protected:

	int		m_iElement;

public:
	CFmtElementIterator ( const CObArray& rgFmtInfo);

	FMT_ELEMENT * Get ();
	FMT_ELEMENT * Peek () const;

	inline void Inc ();
	inline void Dec ();	// HACK!

	void	SetLinear (UINT iElementLinear);
	FMT_ELEMENT * GetLinear ();
	FMT_ELEMENT * PeekLinear ();

	inline UINT	GetIndex () const;

};

inline UINT	CFmtIterator::GetIndex () const { return m_iFmtInfo; }
inline UINT	CFmtGroupIterator::GetIndex () const { return m_iGroup; }
inline UINT	CFmtWindowIterator::GetIndex () const { return m_iWindow; }
inline UINT	CFmtElementIterator::GetIndex () const { return m_iElement; }

inline void CFmtIterator::Inc () { m_iFmtInfo++; }
inline void CFmtGroupIterator::Inc () { m_iGroup++; }
inline void CFmtWindowIterator::Inc () { m_iWindow++; }
inline void CFmtElementIterator::Inc () { m_iElement++; }

inline void CFmtElementIterator::Dec () { m_iElement--; }

inline void	CFmtGroupIterator::Set (int iFmtInfo, int iWinGroup)
{
	m_iGroup = iWinGroup;
	CFmtIterator::Set (iFmtInfo);
}

inline void	CFmtIterator::Set (int iFmtInfo)
{
	m_iFmtInfo = iFmtInfo;
}

//////////////////////////////////////////////////////////////////////////////
//							class CElList									//
//																			//
// A list of unique element names.  Uniqueness is enforced.  Will also		//
// iterate a given name - i.e. will sequentially find all elements with		//
// the given name.															//
//																			//
//////////////////////////////////////////////////////////////////////////////

class CElList
{
	UINT		m_inc;	// Allocation increment
	CPtrArray	m_rgStrings;

	CString		m_strSearch;
public:
	CElList (UINT inc = 4);
	CElList::~CElList ();

	BOOL AddString (const CString& str);	// FALSE -> String was already there

	FMT_ELEMENT * GetFirst (_TCHAR * szName, CFmtElementIterator& it, int iFormat = -1, int iGroup = -1);
	FMT_ELEMENT * GetFirst (UINT iEl, CFmtElementIterator& it, int iFormat = -1, int iGroup = -1);
	FMT_ELEMENT * GetNext (CFmtElementIterator& it, int iFormat = -1, int iGroup = -1);

	void Fill (CListBox& lbox) const;
	void Clear ();

	BOOL IsForeColorTheSame (UINT iEl, CFmtElementIterator& it, int iFormat, int iGroup, COLORREF& rgb);
	BOOL IsBackColorTheSame (UINT iEl, CFmtElementIterator& it, int iFormat, int iGroup, COLORREF& rgb);

	inline int	GetSize () const;
};

inline int	CElList::GetSize () const
{
	return (int)m_rgStrings.GetSize ();
}
	
//////////////////////////////////////////////////////////////////////////////
//							class CWinList									//
//																			//
//	A list of FMT_WINDOW and FMT_WINGROUP.  Used for the list of windows	//
//	under "Category" in the Fonts dialogs.									//
//																			//
//////////////////////////////////////////////////////////////////////////////


class CWinList
{
	CPtrArray	m_rgGroups;
	CPtrArray	m_rgWindows;

public:
	CWinList (UINT inc = 4);
	~CWinList ();

	void Add (FMT_WINGROUP * pGroup);

	void Fill (CListBox& lbox) const;

	BOOL GetName (int index, CString& strName) const;
	BOOL GetPtr (int index, void * &p) const;

	int FirstWindowIndex () const;
};

//////////////////////////////////////////////////////////////////////////////
//							class FCDialogState								//
//																			//
//	This class acts as an intermediary between a CFontColorDlg and the		//
//	CFormatInfo objects underlying it.  It locates and manages the data		//
//	from the packages, it keeps track of the state of the dialog and		//
//  propogates changes to the underlying data.  It also propogates state	//
//	changes in one part of the dialog to the rest of the dialog.			//
//																			//
//////////////////////////////////////////////////////////////////////////////

class CFCDialogState
{
	DialogState		m_state;

	// As an intermediary, an instance of this class must have access
	// to the CFontColorDlg object that it is working with
	CFontColorDlg *	m_pDialog;

	CObArray		m_rgFmtInfo;

	// In the Group and All states, a list of unique element names from
	// the group(s) in question is maintained:
	CElList			m_elList;

	// This holds the list of windows and window groups that is shown
	// in the dialog
	CWinList		m_winList;
	UINT			m_iCurWin;

	// These describe the current Window/Element selection in terms of
	// CFormatInfo array element / Windows Group / Window / Element.
	// 
	UINT			m_nFmtInfoCur;
	UINT			m_nWinGroupCur;
	UINT			m_nWindowCur;
	UINT			m_nElementCur;

	// Enabled flags. Which parts of the dialog are enabled?

	BOOL	m_benFontName:1;
	BOOL	m_benFontSize:1;
	BOOL	m_benElements:1;
	BOOL	m_benForeColor:1;
	BOOL	m_benBackColor:1;

public:

	CFCDialogState ( CFontColorDlg * pDialog = NULL );
	~CFCDialogState ();

	// State retrievers
	inline operator DialogState () const;

	FMT_WINDOW * GetWinCur (BOOL bReturnNull = TRUE, BOOL bMustHaveFont = FALSE) const;

	COLORREF GetForeColor ();
	COLORREF GetBackColor ();
	PLOGFONT GetCurrentLogFont () const;

	// Talk a walk over 
	enum WW_ACTION { FontEquality, FontPitch };
	enum WW_RESULT { SameFont, FontsDiffer, NoFont, PitchFixed, PitchProportional, PitchMixed, NoWindows };
	WW_RESULT WindowWalk (WW_ACTION act) const;

	// State modifiers.
	void InitDialog ();
	void SetCurrentWindow (int iWindow);
	void SetCurrentElement  (int iElement);
	UINT GetCurrentElement () { return m_nElementCur;};

	void SetCurrentFont (const CString& strFontName, int size, BOOL bTrueType);
	void SetCurrentFontSize (int nFontSize);

	void SetForeColor ( COLORREF rgb );
	void SetBackColor ( COLORREF rgb );

	void RestoreDefaults ();

	void UpdateAllAutoColors ();

	// Other stuff
	void Commit();

	friend CFontColorDlg;

};

inline CFCDialogState::operator DialogState () const
{
	return m_state;
}



#endif  // __FMTINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\hu_node.h ===
//---------------------------------------------------------------------------
// Microsoft Visual InterDev
//
// Microsoft Confidential
// Copyright 1994 - 1997 Microsoft Corporation. All Rights Reserved.
//
// File: hu_node.h
// Area: IHierarchy Utilities implementation
//
// Contents:
//	CHierNode definitions
//---------------------------------------------------------------------------
#ifndef __HU_NODE_H__
#define __HU_NODE_H__

class CHierContainer;
class CVsHierarchy;
interface IVsUserContext;
enum  ICON_TYPE;


// IsTypeOf types	(Please reserve < 500 for these utilities)
// we use these instead of the runtime type information (RTTI) (-GR)
enum {
	 Type_CHierNode = 1
	,Type_CHierContainer = 2
	,Type_CHierNestedContainer = 3
	,Type_CVCNode = 4
	,Type_CVCFile = 5
	,Type_CVCBaseFolderNode = 6
	,Type_CVCFileGroup = 7
	,Type_CVCProjectNode = 8
};

// Define type starts for each package
#define Type_VCPkgStart	500		// Start of web pkg node type defines
// (WINSLOWF) #define Type_DtgPkgStart	1000	// Start of dtg pkg node type defines

//-----------------------------------------------------------------------------
// Name: CHierNode
//
// Description:
//	Base node class for every object in a hierarchy. Implements the idea of
//	a node that has a parent, but no children.
//
//---------------------------------------------------------------------------
class CHierNode :
	public CComObjectRootEx<CComSingleThreadModel>		// explict
	,public IOleCommandTarget						// derives from IUnknown
{
protected:

public:
	CHierNode(void);
	virtual ~CHierNode(void);
	// IsKindOf checking
	virtual UINT GetKindOf(void) const;
	BOOL IsKindOf(UINT hKind) const
	{ return (hKind == GetKindOf()); }

	virtual IDispatch*  GetIDispatch(void) {return NULL;}

	virtual BOOL		IsContainer(void) const;	// return FALSE

	// Override in each derived class to test for that class and if failure
	// call the base class. For conveience, it is recommended that you define
	// types of the form: Type_className. ie. for CHierNode the type is 
	// Type_CHierNode.
	// 
	virtual BOOL	 IsTypeOf(int nodeType) const;

	// return a CHierNode typecasted to a VSITEMID or VISTEMID_ROOT
	// Override in each derived class that can also be a VSITEMID_ROOT
	virtual VSITEMID GetVsItemID(void) const;

	// return the itemid of the first child or VSITEMID_NIL
	virtual VSITEMID GetFirstChild(void);

	// traverses to root node via parents
	// the root node is expected to return the associated CVsHierarchy
	virtual CVsHierarchy* GetCVsHierarchy(void) const;

	virtual HRESULT GetNestedHierarchy(REFIID riid, 
										void **ppVsHierarchy, 
										VSITEMID *pitemidNested);

	// Property functions
	virtual HRESULT GetProperty(VSHPROPID propid, VARIANT* pvar);
	virtual HRESULT SetProperty(VSHPROPID propid, const VARIANT& var);
	virtual HRESULT GetGuidProperty(VSHPROPID propid, GUID* pGuid);
	virtual HRESULT ProcessUIMsg(const MSG *pMsg);
	// REVIEW: This is only for debugging purposes
	virtual HRESULT DisplayContextMenu(VARIANT *pvaIn);

	virtual HRESULT GetEditLabel(BSTR *ppEditLabel); // VSHPROPID_EditLabel
	virtual HRESULT SetEditLabel(BSTR   pEditLabel); // VSHPROPID_EditLabel

	// all nodes which neeed to handle these functions should over-ride them
	virtual const GUID* PGuidGetType(void) const;
	virtual UINT GetIconIndex(ICON_TYPE);
	virtual HRESULT GetCanonicalName(BSTR* ppszName);
	virtual HRESULT DoDefaultAction();

	virtual const CString& GetCaption(void) = 0;
	virtual const CString& GetFullPath(void) = 0;
	virtual void SetCaption(LPCSTR pszNewCaption) = 0;
	virtual void SetCaption(LPCWSTR pszNewCaption) = 0;
	virtual void SetCaption(const CString& strNewCaption) = 0;
	virtual	HRESULT			CleanUpBeforeDelete() = 0;

	virtual HRESULT GetUserContext(IVsUserContext **ppUserCtx);

	// CHierNode Properties
	CHierContainer* GetParent(void) const
	{
		return m_pNodeParent;
	}
	void SetParent(CHierContainer *pNode)
	{
		m_pNodeParent = pNode;
	}
	CHierNode* GetNext(void) const
	{
		return m_pNodeNext;
	}
	void SetNext(CHierNode *pHierNode)
	{
		m_pNodeNext = pHierNode;
	}
	CHierNode* GetPrev(void) const;
	CHierNode* GetRootNode(void) const;

	// is the given node an ancestor of this node
	BOOL HasAncestor(const CHierNode *pNode) const;

// interface functionality support
public:
	STDMETHOD(get_Caption)(BSTR *pCaption);
	STDMETHOD(put_Caption)(LPCWSTR Caption);
	BOOL			m_fTransient;
	BOOL			m_fUntitled;
	
protected:
	CHierContainer* m_pNodeParent;
	CHierNode*  	m_pNodeNext;	// this node is a part of a singly-linked list
};

//---------------------------------------------------------------------------
// _TMyClass - the class that is deriving from CHierImpl class
// _TBase	 - the class that _TMyClass would derive from instead of CHierImpl
//---------------------------------------------------------------------------
template <class _TMyClass, class _TBase, int _TType>
class CHierImpl : public _TBase
{
public:
	BOOL IsTypeOf(int nodeType) const
	{
		if (_TType == nodeType)
			return TRUE;
		return _TBase::IsTypeOf(nodeType);
	}
	UINT GetKindOf(void) const
	{
		return _TType;
	}
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
template <class _TMyClass, class _TBase, int _TType, int _TType2, int _TRet2>
class CHierImpl2 : public _TBase
{
public:
	BOOL IsTypeOf(int nodeType) const
	{
		if (_TType == nodeType)
			return TRUE;
		if (_TType2 == nodeType)
			return _TRet2;
		return _TBase::IsTypeOf(nodeType);
	}
	UINT GetKindOf(void) const
	{
		return _TType;
	}
};

#endif	// __HU_NODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\hu_archy.h ===
//---------------------------------------------------------------------------
// Microsoft Visual InterDev
//
// Microsoft Confidential
// Copyright 1994 - 1997 Microsoft Corporation. All Rights Reserved.
//
// hu_archy.h: Definition of the CVsHierarchy class
//
//---------------------------------------------------------------------------

#ifndef __HU_ARCHY_H__
#define __HU_ARCHY_H__

#ifndef  __docobj_h__
#include <DOCOBJ.H>		// OLE interfaces
#endif

#include "vsshell.h"
#include "hu_node.h"

#ifndef  __OBJEXT_H
#include <objext.h>		// VB6 interfaces & guids
#endif

#include "vccoll.h"

interface IVsHierarchyEvents;

//typedef CSimpleArray<CHierNode *> HierNodeList;
typedef CVCTypedPtrList<CVCPtrList, CHierNode*> HierNodeList;

typedef enum ICON_TYPE
{
	ICON_Open,
	ICON_Closed,
	ICON_StateImage
} ICON_TYPE;

//---------------------------------------------------------------------------
// provides:
//		interface: IVsHierarchy
//		interface: IVsUIHiearchy
//		interface: IOleCommandTarget
//		interface: ISelectionContainer
//		interface: IPkgDropDataSource
//		interface: IPkgDropDataTarget
// consumes:
//		interface: ITrackSelectionEx
//---------------------------------------------------------------------------
class CVsHierarchy : 
	public IVsUIHierarchy,
	public IOleCommandTarget,
	public IVsHierarchyDropDataSource,
	public IVsHierarchyDropDataTarget,
	public IVsPersistHierarchyItem,
	public ISupportErrorInfo,
	public CComObjectRootEx<CComSingleThreadModel>		// explict
{
protected:
	virtual ~CVsHierarchy(void);
	virtual UINT GetIconIndex(CHierNode* pNode, ICON_TYPE icontype) = 0;

public:
	CVsHierarchy(void);

public:	// get/set property methods
	void SetRootNode(CHierContainer *pRootNode)
	{
		m_pRootNode = pRootNode;
	}
	CHierContainer* GetRootNode(void) const
	{
		return m_pRootNode;
	}
	IVsHierarchy* GetVsHierarchy(void) const
	{
		return static_cast<IVsHierarchy *>(const_cast<CVsHierarchy *>(this));
	}
	void SetImageList(HIMAGELIST hImageList)
	{
		m_hImageList = hImageList;
	}
	HIMAGELIST GetImageList(void) const
	{
		return m_hImageList;
	}
	BOOL IsZombie(void) const
	{
		return (m_pRootNode == NULL);
	}
	HRESULT GetSelectedNodes(HierNodeList& rgNodes) const;
	virtual HRESULT DisplayContextMenu(HierNodeList &rgSelection, VARIANT *pvaIn);

public:	// IVsHierarchyEvent propagation
	HRESULT OnItemAdded(CHierNode *pNodeParent, CHierNode *pNodePrev, CHierNode *pNodeAdded) const;
	HRESULT OnItemDeleted(CHierNode *pNode) const;
	HRESULT OnPropertyChanged(CHierNode *pNode, VSHPROPID propid, DWORD flags) const;
	HRESULT OnInvalidateItems(CHierNode *pNode) const;
	HRESULT	OnInvalidateIcon(HICON hIcon) const;

BEGIN_COM_MAP(CVsHierarchy)
	COM_INTERFACE_ENTRY(IVsHierarchy)		// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsUIHierarchy)		// derives from IVsHierarchy
	COM_INTERFACE_ENTRY(IOleCommandTarget)	// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsHierarchyDropDataSource)	// dervies from IUnknown
	COM_INTERFACE_ENTRY(IVsHierarchyDropDataTarget)	// dervies from IUnknown
	COM_INTERFACE_ENTRY(IVsPersistHierarchyItem) // derives from IUnknown
	COM_INTERFACE_ENTRY(ISupportErrorInfo)	// dervies from IUnknown
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVsHierarchy)

// IVsHierarchy
public:
	STDMETHOD(SetSite)(
            /* [in] */ IServiceProvider *pSP);
        
	STDMETHOD(GetSite)(
            /* [out] */ IServiceProvider **ppSP);
	
	STDMETHOD(QueryClose)(
			/* [out] */ BOOL *pfCanClose);
        
	STDMETHOD(Close)(void);
 
	STDMETHOD(GetGuidProperty)(
			/* [in] */ VSITEMID itemid,
			/* [in] */ VSHPROPID propid,
			/* [out] */ GUID *pguid);

	STDMETHOD(SetGuidProperty)(
			/* [in] */ VSITEMID itemid, 
			/* [in] */ VSHPROPID propid,
			/* [in] */ REFGUID guid);


	virtual HRESULT GetProperty(	// not in interface, helper routine
			/* [in] */ CHierNode *pNode,
            /* [in] */ VSHPROPID propid,
            /* [out] */ VARIANT *pvar);

	STDMETHOD(GetProperty)(
            /* [in] */ VSITEMID itemid,
            /* [in] */ VSHPROPID propid,
            /* [out] */ VARIANT *pvar);
        
	virtual HRESULT SetProperty(	// not in interface, helper routine
            /* [in] */ CHierNode *pNode,
            /* [in] */ VSHPROPID propid,
            /* [in] */ const VARIANT& var);

	STDMETHOD(SetProperty)(
            /* [in] */ VSITEMID itemid,
            /* [in] */ VSHPROPID propid,
            /* [in] */ VARIANT var);
        
	STDMETHOD(GetNestedHierarchy)(
            /* [in] */ VSITEMID itemid,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppHierarchyNested,
            /* [out] */ VSITEMID *pitemidNested);
        
	STDMETHOD(GetCanonicalName)(
            /* [in] */ VSITEMID itemid,
            /* [out] */ BSTR *ppszName);
        
	STDMETHOD(ParseCanonicalName)(
            /* [in] */ LPCOLESTR pszName,
            /* [out] */ VSITEMID *pitemid);
        
	STDMETHOD(GetAutomationObject)(
            /* [out] */ IDispatch **ppdisp);

	STDMETHOD(AdviseHierarchyEvents)(
			/* [in] */ IVsHierarchyEvents *pEventSink,
			/* [out] */ DWORD *pdwCookie);

	STDMETHOD(UnadviseHierarchyEvents)(
			/* [in] */ DWORD dwCookie);

	STDMETHOD(Unused0)(void);
	STDMETHOD(Unused1)(void);
    STDMETHOD(Unused2)(void);
    STDMETHOD(Unused3)(void);
    STDMETHOD(Unused4)(void);

// IVsUIHierarchy
public:
    STDMETHOD (QueryStatusCommand)( 
			/* [in] */        VSITEMID     itemid, 
			/* [in, unique] */ const GUID * pguidCmdGroup,
			/* [in] */        ULONG cCmds,
			/* [in, out, size_is(cCmds)] */ OLECMD prgCmds[],
			/* [in, out, unique] */ OLECMDTEXT *pCmdText);

	STDMETHOD(ExecCommand)( 
			/* [in] */        VSITEMID     itemid, 
			/* [in, unique] */ const GUID * pguidCmdGroup,
			/* [in] */       DWORD        nCmdID,
			/* [in] */        DWORD        nCmdexecopt,
			/* [in, unique] */ VARIANT *    pvaIn,
			/* [in, out, unique] */ VARIANT* pvaOut);

// IVsPersistHierarchyItem
public:
    STDMETHOD(IsItemDirty)( 
        /* [in] */ VSITEMID vsid,
        /* [in] */ IUnknown __RPC_FAR *punkDocData,
        /* [out] */ BOOL __RPC_FAR *pfDirty);
    
    STDMETHOD(SaveItem)( 
        /* [in] */ VSSAVEFLAGS dwSave,
        /* [in] */ LPCOLESTR lpstrMkDocument,
        /* [in] */ VSITEMID vsid,
        /* [in] */ IUnknown __RPC_FAR *punkDocData,
        /* [out] */ BOOL __RPC_FAR *pfCanceled);


// IVsHierarchyDropDataSource
public:
	STDMETHOD(GetDropInfo)( // make pure after everyone implements
            /* [out] */ DWORD *pdwOKEffects,
            /* [out] */ IDataObject **ppDataObject,
            /* [out] */ IDropSource **pDropSource);
        
	STDMETHOD(OnDropNotify)( 
            /* [in] */ BOOL fDropped,
            /* [in] */ DWORD dwEffects);

// IVsHierarchyDropDataTarget
public:
	STDMETHOD(DragEnter)(	// not in interface, helper routine
            /* [in] */ IDataObject *pDataObj);

	STDMETHOD(DragEnter)( 
            /* [in] */ IDataObject *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ VSITEMID itemid,
            /* [out] */ DWORD *pdwEffect);
        
	STDMETHOD(DragOver)(		// not in interface, helper routine
            /* [in] */ DWORD grfKeyState,
            /* [in] */ CHierNode *pNode,
            /* [out] */ DWORD *pdwEffect);

	STDMETHOD(DragOver)(
            /* [in] */ DWORD grfKeyState,
            /* [in] */ VSITEMID itemid,
            /* [out] */ DWORD *pdwEffect);
        
	STDMETHOD(DragLeave)(void);
        
	virtual HRESULT Drop(		// not in interface, helper routine
            /* [in] */ IDataObject *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ CHierNode *pNode,
            /* [out] */ DWORD *pdwEffect);

	STDMETHOD(Drop)(
            /* [in] */ IDataObject *pDataObj,
            /* [in] */ DWORD grfKeyState,
            /* [in] */ VSITEMID itemid,
            /* [out] */ DWORD *pdwEffect);


// IOleCommandTarget
public:
	STDMETHOD(QueryStatus)( 
            /* [unique][in] */ const GUID *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ OLECMD prgCmds[],
            /* [unique][out][in] */ OLECMDTEXT *pCmdText);
        
	STDMETHOD(Exec)( 
            /* [unique][in] */ const GUID *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ VARIANT *pvaIn,
            /* [unique][out][in] */ VARIANT *pvaOut);

// ISupportsErrorInfo
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

protected:	// protected methods
	HRESULT VSITEMID2Node(const VSITEMID itemid, CHierNode **ppNode) const;
	HRESULT VSITEMID2Node(const VSITEMID itemid, HierNodeList& rgNodeList) const;

	// Override to handle Query status in a particular way
	virtual HRESULT QueryStatusSelection(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText,
		HierNodeList &rgSelection,
		BOOL		 bIsHierCmd);		// TRUE if cmd originated via CVSUiHierarchy::ExecCommand
	
	// Override to handle Exec in a particular way
	virtual HRESULT ExecSelection(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut,
		HierNodeList &rgSelection,
		BOOL		 bIsHierCmd);		// TRUE if cmd originated via CVSUiHierarchy::ExecCommand
protected:	// protected variables
	HIMAGELIST m_hImageList;

	CHierContainer *m_pRootNode;

	static DWORD g_dwCookie;
	struct EventSink
	{		
		CComPtr<IVsHierarchyEvents> m_srpEventSink;
		DWORD m_dwCookie;
	};
	CSimpleArray<EventSink *> m_rgEventSinks;

	// Properties to support being a used as a nested hierarchy
	IUnknown *m_pParentHierarchy;
	VSITEMID m_dwParentHierarchyItemid;

	// cache this pointer to reduce QS
	IVsMonitorSelection *m_srpMonSel;

	IServiceProvider* m_srpServiceProvider;

	static BOOL	g_bStartedDrag;
};

#endif __HU_ARCHY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\ipcslob.h ===
/////////////////////////////////////////////////////////////////////////////
//	IPCSLOB.H
//		Defines classes which inherits from CSlob and also provides an
//		ITrackSelection interface to manage an ISelectionContainer object
//		This class works in conjunction with COlePropertyPageSite to allow
//		components that support IPropertyPage, ISelectionContainer to be 
//		used within the package framework

#ifndef __IPCSLOB_H__
#define __IPCSLOB_H__
#include "slob.h"
#include "objext.h"
#include "ipcits.h"
#include "oleref.h"

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA

class CIPCompSlob;
class COleTrackSelection;
class CIPCompDoc;
interface IPropertyPageUndoString;
interface IInternalTrackSelection;

// This GUID is defined in fm20uuid.lib, which we don't want to use because there
// do not exist RISC builds and the IDE needs to be built for some RISC platforms.
// Also see guids.cpp
DEFINE_GUID(IID_IElement,	0x3050f1ff, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

/////////////////////////////////////////////////////////////////////////////
//	COleTrackSelection

class COleTrackSelection : public CCmdTarget
{
public:
	DECLARE_DYNAMIC(COleTrackSelection)

public:
	COleTrackSelection(CIPCompSlob *pIpCompSlob);
	virtual ~COleTrackSelection();
	void Zombie() { m_pIpCompSlob = NULL; };

// Attributes
protected:
	// called when ITrackSelection::OnSelectChange is called
	HRESULT OnSelectionContainerChange(ISelectionContainer *pSelectionCntr);

	CIPCompSlob *m_pIpCompSlob;

// Interface Maps   
protected:
	// ITrackSelection
	BEGIN_INTERFACE_PART(TrackSelection, ITrackSelection)
		INIT_INTERFACE_PART(COleTrackSelection, TrackSelection)
		STDMETHOD(OnSelectChange)(ISelectionContainer *pSelectionCntr);
	END_INTERFACE_PART(TrackSelection)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//	CInternalTrackSelection

class CInternalTrackSelection : public CCmdTarget
{
public:
	DECLARE_DYNAMIC(CInternalTrackSelection)

public:
	CInternalTrackSelection(CIPCompSlob* pIpCompSlob);
	virtual ~CInternalTrackSelection();
	void Zombie() { m_pIpCompSlob = NULL; };

// Attributes
protected:
	HRESULT	IsExternalSelectChange(
				VARIANT_BOOL* pbReturn);
	HRESULT	OnInternalSelectChange(
				DWORD dwCookie);
	HRESULT	GetInternalSelectList(
				CALPOLESTR* pcaStringsOut,
				CADWORD* pcaCookiesOut);

	CIPCompSlob *m_pIpCompSlob;

// Interface Maps   
protected:
	// ITrackSelection
	BEGIN_INTERFACE_PART(InternalTrackSelection, IInternalTrackSelection)
		INIT_INTERFACE_PART(CInternalTrackSelection, InternalTrackSelection)
		STDMETHOD(IsExternalSelectChange)(VARIANT_BOOL* pbReturn);
		STDMETHOD(OnInternalSelectChange)(DWORD dwCookie);
		STDMETHOD(GetInternalSelectList)(CALPOLESTR* pcaStringsOut, CADWORD* pcaCookiesOut);
	END_INTERFACE_PART(InternalTrackSelection)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//	CIPCompSlob
//
class CIPCompSlob : public CSlob
{
public:
	DECLARE_DYNAMIC(CIPCompSlob)

	CIPCompSlob(CIPCompDoc *pDoc);
	virtual ~CIPCompSlob();

public:
	virtual BOOL Create();	// 2nd phase construction
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);
//	C3dPropertyPage* GetPropPage(UINT nPage);

	// called when ITrackSelection::OnSelectChange is called
	virtual HRESULT OnSelectionContainerChange(ISelectionContainer *pSelectionCntr);
	IUnknown *GetTrackSelection();

	virtual void BeginUndo(UINT nID);
	virtual BOOL SetUndoStringMgr(IPropertyPageUndoString *pPPUS);
	virtual void EndUndo(BOOL bAbort = FALSE);

	HRESULT	GetInternalTrackSelection(IInternalTrackSelection** ppITS);
	HRESULT	GetInternalSelectList(CALPOLESTR* pcaStringsOut, CADWORD* pcaCookiesOut);

	void	SetSelectChangeFlag(BOOL bFlag)
			{
				m_bSelectChange = bFlag;
			}
	BOOL	GetSelectChangeFlag()
			{
				return m_bSelectChange;
			}
	BOOL	ShowLevelCombo()
			{
				return m_bShowLevelCombo;
			}

	void	OnInternalSelectChange(IUnknown* pUnkInternalSelectChange);

// Attributes
protected:
	COleTrackSelection				 *m_pOleTrackSelection;
	COleRef<ITrackSelection>		  m_srpTrackSelection;
	COleRef<ISelectionContainer>	  m_srpSelectionCntr;
	CInternalTrackSelection*			m_pInternalTrackSelection;
	COleRef<IInternalTrackSelection>	m_srpInternalTrackSelection;

	// NOTE:
	// the following interface pointer is not addref'ed, so do not
	// release it at any time, this interface pointer is released
	// by the owner (CSheetWnd) when appropriate.
	// Also, that is the reason, this is not a smart ref
	IUnknown*	m_pUnkInternalSelectChange;	// for trident
	
	void	ReleaseCachedObjects();
	BOOL	IntersectElements(IUnknown* pUnk);
	BOOL	GetElementsIntoArray(IUnknown* pUnk, CPtrArray* pElementsArray);

private:
	CIPCompDoc*	m_pDoc;
	IUnknown*	m_pSingleObject;
	IUnknown**	m_rgpCachedObjects;
	ULONG		m_nCachedObjectCnt;
	BOOL		m_bSelectChange;		// true for external select change and
										// false for internal select change
	CPtrArray	m_ElementsArray;
	BOOL		m_bShowLevelCombo;
};

#endif	// __IPCSLOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\macimage.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    macimage.h

IMAGE_SYM_CLASS_FAR_EXTERNAL

Abstract:

    This is the include file that describes all mac-specific image info

Author:

    Bill Joyce (billjoy)  Oct 1992

Revision History:

--*/

#ifndef _VC_VER_INC
#include "vcver.h"
#endif

#ifndef _MACIMAGE_
#define _MACIMAGE_

#if defined _MSC_VER && _MSC_VER >= 800
#pragma pack(push, 2)
#else
#pragma pack(2)
#endif

#define IMAGE_FILE_MACHINE_M68K 0x268

// Macintosh relocation types
#define IMAGE_REL_M68K_DTOD16        0   // 16-bit data-to-data reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOC16        1   // 16-bit data-to-code reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOD32        2   // 32-bit data-to-data reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOC32        3   // 32-bit data-to-code reference (patch with offset of A5)
#define IMAGE_REL_M68K_DTOABSD32     4   // 32-bit data-to-code reference (patch with offset of A5 and add to DFIX)
#define IMAGE_REL_M68K_DTOABSC32     5   // 32-bit data-to-code reference (patch with offset of A5 and add to DFIX)
#define IMAGE_REL_M68K_CTOD16        6   // 16-bit code-to-data reference
#define IMAGE_REL_M68K_CTOC16        7   // 16-bit code-to-code reference
#define IMAGE_REL_M68K_CTOT16        8   // 16-bit code-to-thunk reference
#define IMAGE_REL_M68K_CTOD32        9   // 32-bit code-to-data reference
#define IMAGE_REL_M68K_CTOABSD32     10  // 32-bit code-to-absolute data reference
#define IMAGE_REL_M68K_CTOABSC32     11  // 32-bit code-to-absolute code reference
#define IMAGE_REL_M68K_CTOABST32     12  // 32-bit code-to-absolute thunk reference

#define IMAGE_REL_M68K_MACPROF32     19  // Profiler-specific relocation
#define IMAGE_REL_M68K_PCODETOC32    20  // 32-bit PCode-to-code reference
#define IMAGE_REL_M68K_CTOCS16       21  // 16-bit code space data-to-code reference
#define IMAGE_REL_M68K_CTOABSCS32    22  // 32-bit code space data-to-absolute code reference
#define IMAGE_REL_M68K_CV            23  // Direct 32-bit reference to the symbols virtual address, base not included

#define IMAGE_REL_M68K_DTOU16        25  // 16-bit data-to-unknown
#define IMAGE_REL_M68K_DTOU32        26  // 32-bit data-to-unknown
#define IMAGE_REL_M68K_DTOABSU32     27  // 32-bit data-to-unknown absolute
#define IMAGE_REL_M68K_CTOU16        28  // 16-bit code-to-unknown
#define IMAGE_REL_M68K_CTOABSU32     29  // 32-bit code-to-unknown absolute
#define IMAGE_REL_M68K_DIFF8         30  // Computed 8-bit difference between two symbols
#define IMAGE_REL_M68K_DIFF16        31  // Computed 16-bit difference between two symbols
#define IMAGE_REL_M68K_DIFF32        32  // Computed 32-bit difference between two symbols

#define IMAGE_REL_M68K_CSECTABLEB16       35  // Create a table with csnCODE byte-sized entries
#define IMAGE_REL_M68K_CSECTABLEW16       36  // Create a table with csnCODE word-sized entries
#define IMAGE_REL_M68K_CSECTABLEL16       37  // Create a table with csnCODE long-sized entries
#define IMAGE_REL_M68K_CSECTABLEBABS32    38  // Create a table with csnCODE byte-sized entries
#define IMAGE_REL_M68K_CSECTABLEWABS32    39  // Create a table with csnCODE word-sized entries
#define IMAGE_REL_M68K_CSECTABLELABS32    40  // Create a table with csnCODE long-sized entries
#define IMAGE_REL_M68K_DUPCON16           41  // Duplicate the contributor where this symbol is defined and put it in this PE section
#define IMAGE_REL_M68K_DUPCONABS32        42  // Duplicate the contributor where this symbol is defined and put it in this PE section

#define IMAGE_REL_M68K_PCODESN16          45  // Write the section number of the code where the fixup occurs
#define IMAGE_REL_M68K_PCODETOD24         46  // 24-bit code-to-data ref
#define IMAGE_REL_M68K_PCODETOT24         47  // 24-bit code-to-thunk ref
#define IMAGE_REL_M68K_PCODETOCS24        48  // 24-bit code-to-codespacedata ref
#define IMAGE_REL_M68K_PCODENEPE16        49  // 16-bit NEP elimination fixup
#define IMAGE_REL_M68K_PCODETONATIVE32    50  // 32-bit PCode-to-native reference

// MacProf constants
#define MACPROF_MAX_SECTIONS         2047  
#define MACPROF_CBITSINOFF             21
#define MACPROF_SN_MASK        0xFFE00000  // 11 bits for sn (up to 2047 sections)
#define MACPROF_OFF_MASK       0x001FFFFF  // 21 bits for offset (shifted right once to support sections up to 4 Meg)

// Data section header
typedef struct {
    unsigned long cbNearbss;   // size of near uninitialized data
    unsigned long cbNeardata;  // size of near initialized data
    unsigned long cbFarbss;    // size of near uninitialized data
    unsigned long cbFardata;   // size of near initialized data
} DATASECHDR;


// .resmap structure used by MRC to map resources to their type and ID
typedef struct {
    LONG typRes;                // resource type ("CODE", "DATA", etc)
    short iRes;                 // resource index
} RRM;                          // Raw to Resource Map

#define szsecRESMAP ".resmap"
#define szsecJTABLE ".jtable"
#define szsecDFIX   ".dfix"
#define szsecMSCV   ".mscv"
#define szsecSWAP   ".swap"
#define szsecFARBSS ".farbss"

#if 0 // These are defined in ntimage.h and are only included for reference.

#define IMAGE_SCN_TYPE_REGULAR               0x00000000  //
#define IMAGE_SCN_TYPE_DUMMY                 0x00000001  // Reserved.
#define IMAGE_SCN_TYPE_NO_LOAD               0x00000002  // Reserved.
#define IMAGE_SCN_TYPE_GROUPED               0x00000004  // Used for 16-bit offset code.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
#define IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
#define IMAGE_SCN_LNK_OVERLAY                0x00000400  // Section contains an overlay.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.

#endif // 0

#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.

// MAC section header flags
#define IMAGE_SCN_MEM_PROTECTED              0x00004000  
#define IMAGE_SCN_MEM_FARDATA                0x00008000  
#define IMAGE_SCN_MEM_SYSHEAP                0x00010000  
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000  
#define IMAGE_SCN_MEM_LOCKED                 0x00040000  
#define IMAGE_SCN_MEM_PRELOAD                0x00080000  

// MAC symbol class
// undefine for new win32 headers #define IMAGE_SYM_CLASS_FAR_EXTERNAL		 68
// Now defined in winnt.h

// Misc Symbol Types
// pcode flag currently used only for mac, but can be used easily by anyone
#define IMAGE_SYM_TYPE_PCODE            0x8000

// Data section masks
#define BSS_MASK      (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_FARDATA)
#define DATA_MASK     (IMAGE_SCN_CNT_INITIALIZED_DATA   | IMAGE_SCN_MEM_FARDATA)

#define NBSS          IMAGE_SCN_CNT_UNINITIALIZED_DATA 
#define NDATA         IMAGE_SCN_CNT_INITIALIZED_DATA   
#define FBSS          (IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_FARDATA)
#define FDATA         (IMAGE_SCN_CNT_INITIALIZED_DATA   | IMAGE_SCN_MEM_FARDATA)

#define BSS_OR_DATA_MASK (IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA)

// Mac Finder Information layout

// see pg. 9-37 of Inside Macintosh vol. 6
#define	FINDER_FLAG_INVISIBLE	0x40		// fd_Attr1
#define	FINDER_FLAG_SET			0x01		// fd_Attr1
#define FINDER_FLAG_BNDL		0x20		// ditto

#define FINDER_INFO_SIZE			32
typedef struct {
	unsigned char	fd_Type[4];
	unsigned char	fd_Creator[4];
	unsigned char	fd_Attr1;			// Bits 8-15
	unsigned char	fd_Attr2;			// Bits 0-7
	unsigned char	fd_Location[4];
	unsigned char	fd_FDWindow[2];
	unsigned char	fd_OtherStuff[16];
	} FINDERINFO, *PFINDERINFO;


// Apple-II (ProDOS) information.

// default values for newly discovered items
#define	PRODOS_TYPE_FILE	0x04	// corresponds to finder fdType 'TEXT'
#define PRODOS_TYPE_DIR		0x0F
#define PRODOS_AUX_DIR		0x02	// actually 0x0200

// some other finder fdType to prodos FileType mapping values
#define PRODOS_FILETYPE_PSYS	0xFF
#define PRODOS_FILETYPE_PS16	0xB3

#define PRODOS_INFO_SIZE			6
typedef struct
{
	unsigned char pd_FileType[2];
	unsigned char pd_AuxType[4];
} PRODOSINFO, *PPRODOSINFO;

// Directory Access Permissions
#define	DIR_ACCESS_SEARCH			0x01	// See Folders
#define	DIR_ACCESS_READ				0x02	// See Files
#define	DIR_ACCESS_WRITE			0x04	// Make Changes
#define	DIR_ACCESS_OWNER			0x80	// Only for user
											// if he has owner rights
typedef struct _AfpInfo {
	unsigned long		afpi_Signature;			// Signature
	long				afpi_Version;			// Version
	unsigned long		afpi_Id;				// AFP File or directory Id
	unsigned long		afpi_BackupTime;		// Backup time for the file/dir
										// (Volume backup time is stored
										// in the AFP_IdIndex stream)

	FINDERINFO	afpi_FinderInfo;		// Finder Info (32 bytes)
	PRODOSINFO  afpi_ProDosInfo;		// ProDos Info (6 bytes)

	unsigned short		afpi_Attributes;		// Attributes mask (maps ReadOnly)

	unsigned char		afpi_AccessOwner;		// Access mask (SFI vs. SFO)
	unsigned char		afpi_AccessGroup;		// Directories only
	unsigned char		afpi_AccessWorld;
	} AFPINFO, *PAFPINFO;

#define AFP_SERVER_SIGNATURE		(*(unsigned long *)"AFP")
#define	AFP_SERVER_VERSION			0x00010000
#define	BEGINNING_OF_TIME 			0x80000000

//
// Initialize a AFPINFO structure with default values
//
// VOID
// AfpInitAfpInfo(
//		IN	PAFPINFO	pAfpInfo,
//		IN	DWORD		AfpId OPTIONAL, // 0 if we don't yet know the AFP Id
//		IN	BOOLEAN		IsDir
// )
//
#define AfpInitAfpInfo(pAfpInfo,AfpId,IsDir)	\
	memset(pAfpInfo,0,sizeof(AFPINFO)); \
	(pAfpInfo)->afpi_Signature = AFP_SERVER_SIGNATURE; \
	(pAfpInfo)->afpi_Version = AFP_SERVER_VERSION; \
	(pAfpInfo)->afpi_BackupTime = BEGINNING_OF_TIME; \
	(pAfpInfo)->afpi_Id = AfpId; \
	(pAfpInfo)->afpi_Attributes = 0; \
	if (IsDir) \
	{ \
		(pAfpInfo)->afpi_AccessOwner = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_AccessGroup = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_AccessWorld = DIR_ACCESS_READ | DIR_ACCESS_SEARCH;	\
		(pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_DIR;\
		(pAfpInfo)->afpi_ProDosInfo.pd_AuxType[1] = PRODOS_AUX_DIR;\
	} \
	else \
	{ \
		(pAfpInfo)->afpi_ProDosInfo.pd_FileType[0] = PRODOS_TYPE_FILE; \
	}

#if defined _MSC_VER && _MSC_VER >= 800
#pragma pack(pop)
#else
#pragma pack()
#endif

#endif // _MACIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\ocdevo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.59 */
/* at Tue Nov 26 10:32:11 1996
 */
/* Compiler settings for ocdevo.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ocdevo_h__
#define __ocdevo_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPropertyPageUndoString_FWD_DEFINED__
#define __IPropertyPageUndoString_FWD_DEFINED__
typedef interface IPropertyPageUndoString IPropertyPageUndoString;
#endif 	/* __IPropertyPageUndoString_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_ocdevo_0000
 * at Tue Nov 26 10:32:11 1996
 * using MIDL 3.01.59
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//--------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
// IStudio Specific IBuilderWizardManager Component Categories
// 
// {21448B91-0788-11d0-8144-00A0C91BBEE3}
DEFINE_GUID(CATID_NewFileBuilder, 
0x21448b91, 0x788, 0x11d0, 0x81, 0x44, 0x0, 0xa0, 0xc9, 0x1b, 0xbe, 0xe3);
// {21448B92-0788-11d0-8144-00A0C91BBEE3}
DEFINE_GUID(CATID_NewWebProjectBuilder, 
0x21448b92, 0x788, 0x11d0, 0x81, 0x44, 0x0, 0xa0, 0xc9, 0x1b, 0xbe, 0xe3);
// {21448B93-0788-11d0-8144-00A0C91BBEE3}
DEFINE_GUID(CATID_SQLTextBuilder, 
0x21448b93, 0x788, 0x11d0, 0x81, 0x44, 0x0, 0xa0, 0xc9, 0x1b, 0xbe, 0xe3);
// {E7879321-A77E-11cf-A406-00AA00C00940}
DEFINE_GUID(SID_SIntrinsicBuilderWizardManager,
0xe7879321, 0xa77e, 0x11cf, 0xa4, 0x6, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);
// {73CEF3DD-AE85-11cf-A406-00AA00C00940}
DEFINE_GUID(CATID_HTMLDesignControl, 
0x73cef3dd, 0xae85, 0x11cf, 0xa4, 0x6, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);
///////////////////////////////////////////////////////////////////////////////
// IPropertyPageUndoString Interface
// 
// This interface is used by the daVinci component to provide it own
// Undo string for its property pages.  The shell, by default, provides
// a generic string for the undo record.  The interface allows the daVinci
// components to provide a more descriptive string for their undo transaction.
// {44AAE5F1-9FC6-11cf-A405-00AA00C00940}
DEFINE_GUID(IID_IPropertyPageUndoString,
0x44aae5f1, 0x9fc6, 0x11cf, 0xa4, 0x5, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);


extern RPC_IF_HANDLE __MIDL_itf_ocdevo_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ocdevo_0000_v0_0_s_ifspec;

#ifndef __IPropertyPageUndoString_INTERFACE_DEFINED__
#define __IPropertyPageUndoString_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertyPageUndoString
 * at Tue Nov 26 10:32:11 1996
 * using MIDL 3.01.59
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPropertyPageUndoString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("44AAE5F1-9FC6-11cf-A405-00AA00C00940")
    IPropertyPageUndoString : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUndoString( 
            /* [out] */ LPOLESTR __RPC_FAR *ppszUndo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyPageUndoStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyPageUndoString __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyPageUndoString __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyPageUndoString __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUndoString )( 
            IPropertyPageUndoString __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *ppszUndo);
        
        END_INTERFACE
    } IPropertyPageUndoStringVtbl;

    interface IPropertyPageUndoString
    {
        CONST_VTBL struct IPropertyPageUndoStringVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyPageUndoString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyPageUndoString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyPageUndoString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyPageUndoString_GetUndoString(This,ppszUndo)	\
    (This)->lpVtbl -> GetUndoString(This,ppszUndo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyPageUndoString_GetUndoString_Proxy( 
    IPropertyPageUndoString __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *ppszUndo);


void __RPC_STUB IPropertyPageUndoString_GetUndoString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyPageUndoString_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\main.h ===
/////////////////////////////////////////////////////////////////////////////
//      MAIN.H
//              Developer Studio main application header file.
//

#ifndef __MAIN_H__
#define __MAIN_H__

#ifndef __AFXWIN_H__
        #error include 'afxwin.h' before including this file for PCH
#endif

// The types of options dialogs...
enum OPTDLG_TYPE { options, customize };

// ANSI code page identifier (values for mbcodepage in CTheApp)
#define OEM_JAPAN                       932
#define OEM_PRC                         936
#define OEM_TAIWAN                      950
#define OEM_KOR_WANGSUNG        949
#define OEM_KOR_JOHAB           1361
#define OEM_US                          437

#include <afxtempl.h>
#include <profile.h>

#ifndef __IDS_H__
#include "vcids.h"
#endif

#ifndef __PATH_H__
#include "path.h"
#endif

#ifdef _DEBUG
#define _EXPORT_LAYOUT
#endif

#ifdef _SHIP
#pragma message("Using _SHIP switch")
#endif



#ifndef _SHIP
// Enable/Disable this if you want to build with the MTTF Dialog.
#define _MTTF
#pragma message("MTTF is turned ON.")

#pragma message("NOT Using _SHIP switch")
#endif

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

class CPartFrame;
class CPartTemplate;
class CPartDoc;
class CIPCompDoc;
class CTypedRecentFileList;

enum FORMAT_TYPE {TIME_ALL, TIME_NO_SECONDS, DATE_ALL};

////////////////////////////////////////////////////////////////////////////
// IME utility functions

void imeMoveConvertWin (HWND, int, int);
BOOL imeEnableIME (HWND, BOOL);
BOOL imeIsOpen();
BOOL imeIsEnabled();
BOOL imeIsActive();

///////////////////////////////////////////////////////////////////////////
// DBCS utility functions

BOOL IsJapaneseSystem();
BOOL IsSBKatakana( unsigned char c );
BOOL IsDBCSTrailByte( LPCSTR string, LPCSTR pch );

/////////////////////////////////////////////////////////////////////////////
// Interface to CTL3D32.DLL

#define WM_DLGSUBCLASS (WM_USER+3568)
/* WM_DLGSUBCLASS *(int FAR *)lParam return codes */
#define CTL3D_NOSUBCLASS        0
#define CTL3D_SUBCLASS          1

/////////////////////////////////////////////////////////////////////////////
// Random MFC helpers

inline void SetDlgCtrlID(HWND hWnd, int nID)
{
#ifdef _WIN32
        ::SetWindowLong(hWnd, GWL_ID, nID);
#else
        ::SetWindowWord(hWnd, GWW_ID, nID);
#endif
}

extern HINSTANCE GetResourceHandle();

/////////////////////////////////////////////////////////////////////////////
// Platform alignment

#if defined ( _MIPS_ ) || defined ( _X86_ ) || defined (_ALPHA_) || defined (_PPC_) || defined (_IA64_)
#define PACKSIZE        8
#define ALIGNMASK       (PACKSIZE - 1)
#else
    /* Deal with others as we get them */
#error "Must define PACKSIZE for this platform"
#endif

#define ALIGN(x)  ( ( (x) + ALIGNMASK ) & ( ~ALIGNMASK ) )

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#define AfxMessageBox DsMessageBox
extern int DsMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0);
extern int DsMessageBox(UINT nIDPrompt, UINT nType = MB_OK);
extern int DsMessageBox(UINT nIDPrompt, UINT nType, UINT nIDHelp);


// We used to pick these warnings up via various places from the SC++L headers. MFC (or something) no longer includes the
// SC++L headers, so we need these ourselves. In the next version, we should go back and remove these and fix the issues they relate to.
// martynl 12/06/96
// Copied from yvals.h
#pragma warning(4: 4018 4114 4146 4244 4245)
#pragma warning(4: 4663 4664 4665)
#pragma warning(disable: 4237 4284 4290 4514 4242)

#endif // __MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\msf.h ===
// msf.h: see "The Multistream File API" for more information

#ifndef __MSF__H
#define __MSF__H

#ifndef TRUE

#define TRUE	1
#define FALSE	0
typedef int BOOL;

#ifdef _DEBUG
#define verify(x)	assert(x)
#else
#define verify(x) (x)
#endif

#endif

typedef unsigned short	SN;		// stream number
typedef long			CB;	

#ifdef MSF_PAGE_SIZE
#define cbPg	MSF_PAGE_SIZE
#else
#define cbPg	4096
#endif

#ifndef cbNil
#define cbNil	((CB)-1)
#endif
#define snNil	((SN)-1)

#if defined(__cplusplus)
extern "C" {
#endif

// MSFOpen		-- open MSF; return MSF* or NULL if error.  Create a temp msf if 
//			   supplied name is null.
// MSFGetCbStream	-- return size of stream or -1 if stream does not exist
// MSFReadStream	-- read stream into pvBuf; return TRUE if successful
// MSFWriteStream	-- overwrite stream with pvBuf; return TRUE if successful
// MSFCommit		-- commit all pending changes; return TRUE if successful
// MSFPack		-- pack MSF on disk; return TRUE if successful
// MSFClose		-- close MSF; return TRUE if successful
// MSFCreateCopy	-- create a new MSF with the same contents.
#define MSF_EXPORT 

class MSF;
MSF_EXPORT MSF*	MSFOpen(const char *name, BOOL fWrite);
MSF_EXPORT CB	MSFGetCbStream(MSF* pmsf, SN sn);
MSF_EXPORT BOOL	MSFReadStream(MSF* pmsf, SN sn, void* pvBuf, long cbBuf);
MSF_EXPORT BOOL	MSFWriteStream(MSF* pmsf, SN sn, void* pvBuf, long cbBuf);
MSF_EXPORT BOOL	MSFCommit(MSF* pmsf);
MSF_EXPORT BOOL	MSFPack(MSF* pmsf);
MSF_EXPORT BOOL	MSFClose(MSF* pmsf);
MSF_EXPORT MSF*	MSFCreateCopy (MSF* pmsf,const char *pCopyName);
#if defined(__cplusplus)
};
#endif

#endif // __MSF__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\OsUtil.h ===
// This header provides useful, protected wrappers for some OS functions.  Note that it is up to the 
// user of this code to determine whether it needs to go for the Unicode or ANSI versions of these
// functions.  All that is done here is to provide buffer protection and verification of success for 
// these calls.

#pragma once

extern BOOL UtilGetTempFileNameW(LPCOLESTR szDir, LPCOLESTR szPre, CStringW& strFile);
extern BOOL UtilGetTempFileNameA(LPCSTR szDir, LPCSTR szPre, CStringA& strFile);
extern BOOL UtilGetModuleFileNameW(HMODULE hModule, CStringW& strFileName);
extern BOOL UtilGetTempPathW(CStringW& strBuf);
extern BOOL UtilGetTempPathA(CStringA& strBuf);
extern BOOL UtilGetModuleFileNameW(HMODULE hModule, CStringA& strFileName);
extern HRESULT VCGetEnvironmentVariableW(LPCOLESTR strVar, BSTR *pbstr);
extern HRESULT VCGetEnvironmentVariableA(LPCSTR strVar, BSTR *pbstr);

#ifdef _UNICODE
#define UtilGetTempFileName UtilGetTempFileNameW
#define UtilGetTempPath UtilGetTempPathW
#define UtilGetModuleFileName UtilGetModuleFileNameW
#define VCGetEnvironmentVariable VCGetEnvironmentVariableW
#else	// _UNICODE
#define UtilGetTempFileName UtilGetTempFileNameA
#define UtilGetTempPath UtilGetTempPathA
#define UtilGetModuleFileName UtilGetModuleFileNameA
#define VCGetEnvironmentVariable VCGetEnvironmentVariableA
#endif	// _UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\oleref.h ===
// compview.h : interface of the CComponentView class
//

#ifndef __OLEREF_H__
#define __OLEREF_H__

#ifdef _DEBUG
#define TRACEOLE(sz)            (if (afxTraceFlags & traceOle) \
								::AfxTrace(_T("%s"), _T(sz)))	
#else   // _DEBUG
#define TRACEOLE(sz)
#endif

void FreeOlePtr(void * pv);

// OleRelease - Decrement an arbitrary OLE interface (if its not NULL) and set it
//             to NULL (NOTE: The call to Release is made through a temporary pointer)
template <class TYPE> inline unsigned long OleRelease
(
TYPE&	rpunk
)
	{
	if (rpunk)
		{
		TYPE	punkTemp = rpunk;
		rpunk = NULL;
		return punkTemp->Release();
		}
	return 0;
	}
	
/*-----------------------------------------------------------------------------
Name:	COleRef

Description:
This class performs automatic reference count decrementing (users must ensure
that AddRef has already been called)on interface pointers.
-----------------------------------------------------------------------------*/
template <class TYPE> class COleRef					// Hungarian:	srp
{
public:
	COleRef();					// Interface is initialized with NULL
	COleRef(TYPE* punk);		// Passed interface is saved
	COleRef(IUnknown *pIUnknown, REFIID riid); // QueryInterface() for riid
	~COleRef();

	operator TYPE*() const;

	TYPE *	operator->() const;
	TYPE**	operator&();		// Asserts emptiness, use InOut for passing as an IN/OUT parameter
	TYPE*	operator=(TYPE* punk);

	TYPE*			Disown();		// Set internal pointer to NULL (w/o calling Release on the interface)
	TYPE**			InOut();		// Same as address-of operator, use instead when passing as in IN/OUT parameter
	const TYPE*&	Reference();	// Return a const reference
	ULONG			SRelease();		// Release the interface and set internal pointer to NULL
	HRESULT			AssignFromQI(IUnknown *pIUnknown, REFIID riid); // Do QI on pIUnknown for riid and assign to this
	BOOL			IsNull() const;

protected:
	TYPE*	m_punk;
	
private:
	// Dis-allow copy and assignment
	COleRef(const COleRef<TYPE>& srp);
	COleRef<TYPE>& operator=(const COleRef<TYPE>& srp);
};

/*-----------------------------------------------------------------------------
Name:	COleMalloc

Description:
This class automatically releases the memory allocated by the OLE IMalloc
interface.
-----------------------------------------------------------------------------*/
template <class TYPE> class COleMalloc	
{
public:
	COleMalloc(TYPE* pItem = NULL);
	~COleMalloc();

	operator TYPE*() const;

//	TYPE *	operator->() const;
	TYPE&	operator*() const;
	TYPE**	operator&();
	TYPE*	operator=(TYPE* pItem);

	void	Delete();					// Delete the memory and set internal pointer to NULL
	TYPE*	Disown();					// Set the internal pointer to NULL (w/o deleting the memory)

private:
	TYPE*	m_pItem;

	// Dis-allow copy and assignment
	COleMalloc(const COleMalloc<TYPE>& smp);
	COleMalloc<TYPE>& operator=(const COleMalloc<TYPE>& smp);
};


/*-----------------------------------------------------------------------------
Name:	COleStrPtr 

Description:
This class automatically releases the string allocated by the OLE memory allocator
on destruction.
-----------------------------------------------------------------------------*/
class COleStrPtr : public COleMalloc<WCHAR>	// Hungarian:	smsz
{
public:
	COleStrPtr(WCHAR * pItem = NULL) : COleMalloc<WCHAR>(pItem) { };

private:
	// Dis-allow copy and assignment
	COleStrPtr(const COleStrPtr& sstr);
	COleStrPtr& operator=(const COleStrPtr& sstr);
};


/*-----------------------------------------------------------------------------
Name:	COleRef::COleRef

Description:
Construct a COleRef by taking ownership of the passed interface (if any)
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleRef<TYPE>::COleRef()
 : m_punk(NULL)
	{
	return;
	}

template <class TYPE> inline COleRef<TYPE>::COleRef
(
TYPE*	punk		// IUnknown interface pointer to reference count
) :
m_punk(punk)
	{
	return;
	}

template <class TYPE> inline COleRef<TYPE>::COleRef
(
IUnknown *pIUnknown,
REFIID riid
) : m_punk(NULL)
{
	void *pvTemp = NULL;
	VSASSERT(pIUnknown != NULL, "Cannot initialize COleRef with NULL pointer!");
	HRESULT hr = pIUnknown->QueryInterface(riid, &pvTemp);
	if (SUCCEEDED(hr))
		m_punk = reinterpret_cast<TYPE *>(pvTemp);
}

/*-----------------------------------------------------------------------------
Name:	COleRef::~COleRef

Description:
Destroy a COleRef object by decrementing the reference count of the
saved interface.
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleRef<TYPE>::~COleRef()
	{
	OleRelease(m_punk);
	return;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::operator TYPE*

Description:
Convert a COleRef to a TYPE*
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleRef<TYPE>::operator TYPE*() const
	{
	return m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::operator->

Description:
Return interface pointer.
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleRef<TYPE>::operator->() const
	{
	VSASSERT(m_punk, "Cannot dereference COleRef containing NULL pointer!");
	return m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::operator&

Description:
Return the address of the pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE** COleRef<TYPE>::operator&()
	{
	VSASSERT(!m_punk, "Need to have uninitialized COleRef for & operator");
	return &m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::operator=

Description:
Assign a new interface
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleRef<TYPE>::operator=
(
TYPE*	punk
)
	{
	VSASSERT(!m_punk, "Need to have uninitialized COleRef for operator=");
	return (m_punk = punk);
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::Disown

Description:
Drop ownership of the interface (without calling Release)
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleRef<TYPE>::Disown()
	{
	TYPE*	punk = m_punk;
	m_punk = NULL;
	return punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::InOut

Description:
Return the address of the pointer (without asserting that it's empty)
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE** COleRef<TYPE>::InOut()
	{
	return &m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::Reference

Description:
Return a const reference to the pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline const TYPE*& COleRef<TYPE>::Reference()
	{
	VSASSERT(m_punk, "Need uninitialized COleRef for operator*&");
	return m_punk;
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::SRelease

Description:
Release the held resource and clear the internal pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline ULONG COleRef<TYPE>::SRelease()
	{
	return OleRelease(m_punk);
	}


/*-----------------------------------------------------------------------------
Name:	COleRef::AssignFromQI

Description:
Queries a passed in IUnknown * for a given interface and assigns it to this.
-----------------------------------------------------------------------------*/
template <class TYPE> inline HRESULT COleRef<TYPE>::AssignFromQI
(
IUnknown *pIUnknown,
REFIID riid
)
{
	void *pvTemp = NULL;
	HRESULT hr;

	VSASSERT(pIUnknown != NULL, "Cannot assign from NULL pointer");
	VSASSERT(m_punk == NULL, "Cannot assign to initialized COleRef");

	hr = pIUnknown->QueryInterface(riid, &pvTemp);
	if (SUCCEEDED(hr))
	{
		m_punk = reinterpret_cast<TYPE *>(pvTemp);
	}

	return hr;
}

/*-----------------------------------------------------------------------------
Name:	COleRef::IsNull

Description:
Returns TRUE if the COleRef does not reference an object currently.
-----------------------------------------------------------------------------*/
template <class TYPE> inline BOOL COleRef<TYPE>::IsNull() const
{
	return (m_punk == NULL);
}

/*-----------------------------------------------------------------------------
Name:	COleMalloc::COleMalloc

Description:
Construct a COleMalloc object by allocating on the heap an instance of the
associated object.
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleMalloc<TYPE>::COleMalloc
(
TYPE*	pItem
)	: m_pItem(pItem)
	{
	return;
	}

/*-----------------------------------------------------------------------------
Name:	COleMalloc::~COleMalloc

Description:
Construct a COleMalloc object by allocating on the heap an instance of the
associated object.
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleMalloc<TYPE>::~COleMalloc()
	{
	if (m_pItem != NULL)
		::FreeOlePtr(m_pItem);
	}
	

/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator TYPE*

Description:
Overload the "TYPE*" conversion operator so that instances of COleMalloc may
be treated exactly like instances of TYPE*.
-----------------------------------------------------------------------------*/
template <class TYPE> inline COleMalloc<TYPE>::operator TYPE*() const
	{
	return m_pItem;
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator*

Description:
Overload the "*" (indirection) operator so that instances of COleMalloc may
be used as real pointers.
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE& COleMalloc<TYPE>::operator*() const
	{
	VSASSERT(m_pItem, "Need initialized item for operator*");
	return *m_pItem;
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator&

Description:
Overload the "&" operator so that instances may be passed to functions
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE** COleMalloc<TYPE>::operator&()
	{
	VSASSERT(!m_pItem, "Need uninitialized item for operator&");
	return &m_pItem;
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::operator=

Description:
Overload the "=" operator to allow replacement of the pointer (the existing
pointer, if any, is deleted)
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleMalloc<TYPE>::operator=
(
TYPE*	pItem
)
	{
	VSASSERT(!m_pItem, "Need uninitialized item for operator=");
	return (m_pItem = pItem);
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::Delete

Description:
Free the held resource and clear the internal pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline void COleMalloc<TYPE>::Delete()
	{
	if (m_pItem)
		{
		::FreeOlePtr(m_pItem);
		m_pItem = NULL;
		}
	return;
	}


/*-----------------------------------------------------------------------------
Name:	COleMalloc::Disown

Description:
Drop ownership of the pointer
-----------------------------------------------------------------------------*/
template <class TYPE> inline TYPE* COleMalloc<TYPE>::Disown()
	{
	TYPE*	pItem = m_pItem;
	m_pItem = NULL;
	return pItem;
	}

/////////////////////////////////////////////////////////////////////////////
// random useful stuff

#define IMPLEMENT_METHOD_(rettype, base, derived, method, defargs, useargs)		\
	rettype base::X##derived::method defargs									\
	{																			\
		METHOD_PROLOGUE(base, derived)											\
		return pThis->External##method useargs;									\
	}

#define IMPLEMENT_ADDREF(base, derived)						\
	IMPLEMENT_METHOD_(ULONG, base, derived, AddRef, (), ())
#define IMPLEMENT_RELEASE(base, derived)					\
	IMPLEMENT_METHOD_(ULONG, base, derived, Release, (), ())
#define IMPLEMENT_QUERYINTERFACE(base, derived)				\
	IMPLEMENT_METHOD_(HRESULT, base, derived, QueryInterface,		\
									 (REFIID iid, void FAR* FAR* ppvObj), (&iid, ppvObj))


#endif //__OLEREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\path.h ===
//////////////////////////////////////////////////////////////////////
// PATH.H
//
// Definition of CPath and CDir objects.
//
// History
// =======
// Date         Who         What
// ----         ---         ----
// 07-May-93    mattg       Created
// 12-May-93    danw        Add operator = and GetDisplayName
// 20-May-93    mattg       Added CDir object
// 22-May-93    danw        Added ConstructObject and DestructObject
//                              for collections.
// 11-Jul-93    mattg       Added many new methods to CPath and CDir
//                          Also "TCHAR'ified"
// 20-Jul-93    danw        Added relativization functions.
//////////////////////////////////////////////////////////////////////

#ifndef __PATH_H__
#define __PATH_H__

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <sys\stat.h>
#endif

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA

size_t RemoveNewlines(_TCHAR *);


//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
    class CPath;
    class CDir;
//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CPath
class CPath : public CObject
{
    DECLARE_DYNAMIC(CPath)

    friend  class       CDir;

    friend  static VOID     ConstructElement(CPath *);
    friend  static VOID     DestructElement(CPath *);

protected:
    // Data
            CString     m_strCanon;
            int     m_ichLastSlash; // used to quickly extract only dir or filename
            BOOL        m_Flags;
            enum    PathFlags
                {
                    eIsActualCase = 1,
                    eWantsRelative = 2,
                };
                // Canonicalized representation of pathname.
            static CMapStringToString c_DirCaseMap;
public:
    // Constructors, destructors, initialization methods
    inline              CPath() { m_ichLastSlash = -1; m_Flags = 0;}
    inline              CPath(const CPath & path)
                             {
                                 m_strCanon = path.m_strCanon;
                                 m_ichLastSlash = path.m_ichLastSlash;
                                 m_Flags = path.m_Flags;
                             }
    virtual             ~CPath();

    inline  BOOL        GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
    inline  void        SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
            (bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

    inline  BOOL        IsInit() const { VSASSERT(this!=NULL, "CPath object not initialized"); return (m_ichLastSlash > 0); }

            BOOL        Create(const TCHAR *);
                // Initialize the object, given a filename.  The resulting
                // canonicalized filename will be relative to the current
                // directory.  For example, if the current directory is
                // C:\TEST and the argument is "FOO.C", the resulting
                // canonicalized filename will be "C:\TEST\FOO.C".  If the
                // argument is "..\FOO.C", the resulting canonicalized
                // filename will be "C:\FOO.C".

            BOOL        CreateFromDirAndFilename(const CDir &, const TCHAR *);
                // Initialize the object given a directory (CDir object) and
                // a filename.  This behaves exactly the same as the Create()
                // method, except that the Create() method canonicalizes the
                // filename relative to the CURRENT directory, whereas this
                // method canonicalizes the filename relative to the SPECIFIED
                // directory.

            BOOL        ContainsSpecialCharacters () const
                        {
                            return ::ScanPathForSpecialCharacters(m_strCanon);
                        }
                // Scan the pathname for special character.  We cache this
                // information.

    inline  CPath &     operator =(const CPath & path)
                        {
                            VSASSERT(path.IsInit(), "Path not initialized before use");
                            m_strCanon = path.m_strCanon;
                            m_ichLastSlash = path.m_ichLastSlash;
                            m_Flags = path.m_Flags;
                            return(*this);
                        }
                // Assignment operator.

    // Query methods
    inline  const TCHAR * GetFileName() const
                    {
                        VSASSERT(IsInit(), "Path not initialized before use");
                        VSASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'), "m_ichLastSlash not properly initialized");
                        return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
                    }

                // Return a pointer to the filename part of the canonicalized
                // pathname, i.e., the filename with no leading drive or path
                // information. Return whole string if no backslash (not init).
                //
                // Please do not write through this pointer, as it is pointing
                // to internal data!

            VOID        PostFixNumber();
                // Modifies the path by postfixing a number on the end of the path's
                // basename. If there is no number on the end of the path's basename
                // then the number 1 is postfixed. Otherwise if there already is a
                // number on the end of the path's basename then that number is
                // incremented by 1 and postfixed on the end of the basename (less the
                // original number).
                //
                // e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
            
            VOID        GetBaseNameString(CString &) const;
                // Creates a CString representing the base name of the fully
                // canonicalized pathname.  For example, the base name of
                // the pathname "C:\FOO\BAR.C" is "BAR".
                //
                // This method can't return a pointer to internal data like
                // some of the other methods since it would have to remove
                // the extension in order to do so.

            VOID        GetDisplayNameString(
                                        CString &,
                                        int cchMax = 16,
                                        BOOL bTakeAllAsDefault = FALSE
                                        ) const;
                // Creates a CString representing the name of the file
                // shortened to cchMax CHARACTERS (TCHARs, not bytes) or
                // less.  Only the actual characters are counted; the
                // terminating '\0' is not considered, so
                // CString::GetLength() on the result MAY return as much as
                // cchMax.  If cchMax is less than the length of the base
                // filename, the resulting CString will be empty, unless
                // bTakeAllAsDefault is TRUE, in which the base name is
                // copied in, regardless of length.
                //
                // As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
                // will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

        inline  const TCHAR * GetExtension() const
                    {
                        VSASSERT(IsInit(), "Path not initialized before use");
                        INT_PTR iDot = m_strCanon.ReverseFind(_T('.'));
                        if (iDot < m_ichLastSlash)
                            iDot = m_strCanon.GetLength();
                        const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
                        return retval;
                    }

                // Return a pointer to the extension part of the canonicalized
                // pathname.  Returns a pointer to the '.' character of the
                // extension.  If the filename doesn't have an extension,
                // the pointer returned will point to the terminating '\0'.
                //
                // Please do not write through this pointer, as it is pointing
                // to internal data!

    inline  const TCHAR * GetFullPath() const { return(m_strCanon); }
                // Return a pointer to the full (canonicalized) pathname.
                //
                // Please do not write through this pointer, as it is pointing
                // to internal data!
    inline  const TCHAR * GetFullPath(CString & strPath) const { return(strPath = m_strCanon); }

    inline  BOOL        IsActualCase() const { VSASSERT(this!=NULL, "Path not initialized before use"); return ((m_Flags & eIsActualCase)!=0); }
    void GetActualCase(BOOL bEntirePath = FALSE);
                // Adjusts the paths case to match the actual path and filename
                // on disk.
    void SetActualCase(LPCTSTR pszFileCase); 
                // Adjusts the paths case to match the actual path and filename
                // on disk, where pszFileCase already contains the correct case
                // for just the filename portion.
    static void ResetDirMap();

    inline              operator const TCHAR *() const { return(m_strCanon); }
                // Return the fully canonicalized filename as a (const TCHAR *).
                // Same thing as GetFullPath(), but more convenient in some
                // cases.
                //
                // Please do not write through this pointer, as it is pointing
                // to internal data!

    inline  BOOL        IsUNC() const { return(m_strCanon[0] == _T('\\')); }
                // Returns TRUE if the pathname is UNC (e.g.,
                // "\\server\share\file"), FALSE if not.

    inline BOOL IsEmpty() const { return (m_strCanon.IsEmpty()); }

    // Comparison methods

            int         operator ==(const CPath &) const;
                // Returns 1 if the two CPaths are identical, 0 if they are
                // different.

    inline  int         operator !=(const CPath & path) const { return(!(operator ==(path))); }
                // Returns 1 if the two CPaths are different, 0 if they are
                // identical.

    // Modification methods

            VOID        ChangeFileName(const TCHAR *);
                // Changes the file name to that specified by the
                // (const TCHAR *) argument.  The directory portion of the
                // pathname remains unchanged.  DO NOT pass in anything
                // other than a simple filename, i.e., do not pass in
                // anything with path modifiers.

            VOID        ChangeExtension(const TCHAR *);
                // Changes the extension of the pathname to be that specified
                // by the (const TCHAR *) argument.  The argument can either be
                // of the form ".EXT" or "EXT".  If the current pathname has
                // no extension, this is equivalent to adding the new extension.

            BOOL        GetRelativeName (const CDir&, CString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
                // Makes the path name relative to the supplied directory and
                // placed the result in strResult.  Function will only go
                // down from the supplied directy (no ..'s).  Returns TRUE if
                // relativization was successful, or FALSE if not (e.g. if
                // string doesn't start with ".\" or ..\ or at least \).
                //
                // Thus, if the base directory is c:\sushi\vcpp32:
                //
                //  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
                //  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
                //  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
                //  \\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

                // Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
                //
                // \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
                // \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

                // If bQuote is true, then quotes are put around the relative
                // file name. (Useful for writing the filename out to a file)

                // If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
                // and if the file is on the same drive we will ALWAYS
                // relativize it. Thus for the base dir c:\sushi\vcpp32
                //  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

            BOOL        CreateFromDirAndRelative (const CDir&, const TCHAR *);
                // THIS FUNCTION IS OBSOLETE.  New code should use
                // CreateFromDirAndFilename().  The only difference between
                // that function and this one is that this one will
                // automatically remove quotes from around the relative
                // path name (if present).


    // Miscellaneous methods
    inline  BOOL        IsReadOnlyOnDisk() const
                        {
                            HANDLE  h;

                            VSASSERT(IsInit(), "Path not initialized before use");
                            h = CreateFile(m_strCanon, GENERIC_WRITE,
                                FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL, NULL);

                            if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
                                return TRUE;

                            if (h != INVALID_HANDLE_VALUE)
                                CloseHandle(h);

                            return FALSE;
                        }
                // Returns TRUE if the filename represented by this object
                // is read-only on disk, FALSE if not.  NOT guaranteed to
                // work in all circumstances -- for example, will not return
                // TRUE for a file on a floppy drive that has been write-
                // protected.  I don't know of any way to get this information
                // from NT (GetFileAttributes doesn't work; GetVolumeInformation
                // doesn't work; _access just calls GetFileAttributes; etc.).
                // This method WILL correctly detect:
                //      - Files marked as read-only
                //      - Files on read-only network drives

    inline  BOOL        ExistsOnDisk() const
                        {
                            VSASSERT(IsInit(), "Path not initialized before use");
                            return(_taccess(m_strCanon, 00) != -1);
                        }
                // Returns TRUE if the filename represented by this object
                // exists on disk, FALSE if not.

    inline  BOOL        CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const
                        {
                            VSASSERT(IsInit(), "Path not initialized before use");
                            if (!fOverwriteOK && ExistsOnDisk())
                                return(FALSE);
                            int hFile = _tcreat(m_strCanon, _S_IREAD | _S_IWRITE);
                            BOOL fCreate = (hFile != -1);
                            if (fCreate)
                            {
                                _close(hFile);
                                _unlink(m_strCanon);
                            }
                            return(fCreate);
                        }
                // Returns TRUE if the filename represented by this object
                // can be created on disk, FALSE if not.

    inline  BOOL        DeleteFromDisk() const
                        {
                            VSASSERT(IsInit(), "Path not initialized before use");
#ifdef _WIN32
                            return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
                            return(remove(m_strCanon) != -1);
#endif
                        }
                // Removes the file represented by this object from the disk.

    BOOL GetFileTime(LPFILETIME lpftLastWrite);
    BOOL GetFileTime(CString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
    // Returns the last modified time, as either an FILETIME struct or a string
};

extern const CString AFX_DATA pthEmptyString;


//  File Name Utility Functions
//      These are redundant and could be replaced with use of CPath, but are
//      kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);

// Makes a file path look like in MRU.
CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
    LPCTSTR szDirectory = NULL);

BOOL FileExists(LPCTSTR szFilePath); //REVIEW(chriskoz): only res\src\rcio.cpp uses it

//////////////////////////////////////////////////////////////////////
// CDir
//
// The CDir object represents a file system directory on some disk.
//
// A CDir object can be created to represent the current directory,
// to represent the directory of a CPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CPath methods which use CDir objects.

class CDir : public CObject
{
    DECLARE_DYNAMIC(CDir)

    friend  class       CPath;

    friend  static VOID     ConstructElement(CDir *);
    friend  static VOID     DestructElement(CDir *);

protected:
            CString     m_strDir;
                // Directory name, including drive letter or
                // server/share.  Do NOT make any assumptions
                // about whether or not this ends in '\'!

            // Creates multi level directories just fine
            BOOL MakeDirectory(LPCTSTR lpszPathName) const;
public:
    // Constructors, destructors, initialization methods
    inline              CDir() {}
    inline              CDir(const CDir & dir) { m_strDir = dir.m_strDir; }
    virtual             ~CDir();

            BOOL        CreateFromCurrent();
                // Initialize from the current working directory.  This
                // may fail if the current working directory is unknown
                // or invalid.

            BOOL        CreateFromPath(const CPath &);
                // Initialize based on the directory of the specified
                // CPath object.  That is, if the CPath object represents
                // the file "C:\FOO\BAR\BLIX.C", the resulting directory
                // for this object will be "C:\FOO\BAR".  Returns FALSE
                // on failure.

            BOOL        CreateFromPath(const TCHAR *pszPath);
                // Initialize based on the directory of the specified
                // string.  That is, if the string contains the file name
                // "C:\FOO\BAR\BLIX.C", the generated directory for this
                // string will be "C:\FOO\BAR".  Returns FALSE on failure.

            inline BOOL     CreateFromString(const TCHAR * sz)
                    {
                        return  CreateFromStringEx(sz, FALSE);
                    }   
                // Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
                // do not use this method when another would suffice!

            BOOL        CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative);
                // Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
                // do not use this method when another would suffice!
                // same as CreateFromString with minor change. Not treating as bug fix to CFS
                // due to lateness in VC 4.0 project time

                // if fRootRelative true, treat dir ending with colon as relative not root dir 
                // (actual correct handling)


            BOOL        ContainsSpecialCharacters () const
                        {
                            return ::ScanPathForSpecialCharacters(m_strDir);
                        }
                // Scan the pathname for special character.  We cache this information.

    inline  CDir &      operator =(const CDir & dir)
                        {
                            m_strDir = dir.m_strDir;
                            return(*this);
                        }
                // Assignment operator.

    // Query methods

    inline              operator const TCHAR *() const { return(m_strDir); }
                // Return the directory name as a (const TCHAR *) string.

    inline int GetLength() const { return (int)m_strDir.GetLength(); }
          // Returns the length of the directory name

    // Miscellaneous methods

    BOOL    MakeCurrent() const;
                // Make this object the current working directory.  May fail
                // if the directory no longer exists (e.g., a floppy drive).

    inline  BOOL        ExistsOnDisk() const
                        {
                            // Tests if the directory exists.  We return FALSE
                            // if <m_strDir> exists but is not a directory
                            struct _stat statDir;
                            if (_stat(m_strDir, &statDir) == -1)
                                return FALSE;        // Not found.
                            else if (!(statDir.st_mode & _S_IFDIR))
                                return FALSE;        // Not a directory.
                            else
                                return TRUE;
                        }
                // Returns TRUE if the directory represented by this object
                // exists on disk, FALSE if not.

    inline  BOOL        CreateOnDisk() const { return MakeDirectory(m_strDir); }
                // Creates the directory on disk.  If this fails, returns
                // FALSE.  If the directory already existed on disk, returns
                // TRUE (i.e., that is not an error condition).

    inline  BOOL        RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
                // Removes the directory from the disk.  If this fails for
                // any reason (directory does not exist, directory is not
                // empty, etc.), returns FALSE.

            BOOL        IsRootDir() const;
                // Returns TRUE if the directory represented by this object
                // is a root directory (e.g., "C:\"), FALSE if not.  Note that
                // calling this method will NOT tell you whether or not the
                // string representation ends in '\', since "\\server\share"
                // is a root directory, and does not end in '\'.

    inline  BOOL        IsUNC() const { return(m_strDir[0] == _T('\\')); }
                // Returns TRUE if this is a UNC directory, FALSE if not.

            VOID        AppendSubdirName(const TCHAR *);
                // Adds a subdirectory name.  For example, if this object
                // currently represents "C:\FOO\BAR", and the argument is
                // "$AUTSAV$", the resulting object represents
                // "C:\FOO\BAR\$AUTSAV$".
                //
                // WARNING: This method does NO validation of the result --
                // it does not check for illegal characters, or for a
                // directory name that is too long.  In particular, don't
                // pass "DIR1/DIR2" as an argument, since no conversion
                // (of '/' to '\') will occur.

            VOID        RemoveLastSubdirName();
                // Removes the last component of the directory name.  For
                // example, if this object currently represents
                // "C:\FOO\BAR\$AUTSAV$", after this method it will
                // represent "C:\FOO\BAR".  If you try to call this method
                // when the object represents a root directory (e.g., "C:\"),
                // it will assert.

    // Comparison methods

            int         operator ==(const CDir &) const;
                // Returns 1 if the two CDirs are identical, 0 if they are
                // different.

    inline  int         operator !=(const CDir & dir) const { return(!(operator ==(dir))); }
                // Returns 1 if the two CDirs are different, 0 if they are
                // identical.
};

///////////////////////////////////////////////////////////////////////////////
//  CCurDir
//      This class is used to switch the current drive/directory during the
//      life of the object and to restore the previous dirve/directory upon
//      destruction.

class CCurDir : CDir
{
public:
    CCurDir(const char* szPath, BOOL bFile = FALSE);
    CCurDir(const CDir& dir);
    CCurDir();  // just saves the current directory and resets it
    ~CCurDir();

    CDir m_dir;
};


///////////////////////////////////////////////////////////////////////////////
//  CFileOpenReturn
//      This class represents the return value from the Common Dialogs
//      File.Open.  It handles both single and multiple select types.
//

class CFileOpenReturn : CObject
{
    BOOL        m_bSingle;
    BOOL        m_bBufferInUse;
    BOOL        m_bArrayHasChanged;

    INT_PTR     m_cbData;
    _TCHAR *    m_pchData;

    // Multiple Files
    CPtrArray   m_rgszNames;

public:
    CFileOpenReturn (const _TCHAR * szRawString = NULL);
    ~CFileOpenReturn ();

    inline BOOL IsSingle () const;
    inline BOOL IsDirty() const;
    inline BOOL BufferOverflow () const;
    //inline int  GetLength () const;

    // GetBuffer gives permission for something else to directly change the buffer
    // ReleaseBuffer signifies that the something else is done with it.
    _TCHAR * GetBuffer (int cbBufferNew);
    inline void ReleaseBuffer ();

    // allows the object to be re-initialized
    void ReInit (const _TCHAR * szRawString);

    // This supports the dynamic file extension update in OnFileNameOK().
    void ChangeExtension (int i, const CString& szExt);

    void CopyBuffer (_TCHAR * szTarget);

    // This is the function to use to get at the user's selections,
    // whether single or multiple.
    BOOL GetPathname (int i, CString& strPath) const;

private:
    void GenArrayFromBuffer ();
    void GenBufferFromArray ();
    void ClearNamesArray ();
    void SetBuffer (const _TCHAR * szRawString);    
};


inline BOOL CFileOpenReturn::IsSingle () const
{
    return m_bSingle;
}

inline BOOL CFileOpenReturn::IsDirty() const
{
    return m_bArrayHasChanged;
}

inline BOOL CFileOpenReturn::BufferOverflow () const
{
    return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//  Processes the raw string
//
///
inline void CFileOpenReturn::ReleaseBuffer ()
{
    m_bBufferInUse = FALSE;
    GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//  Smart case helpers.
//      These functions are used to do smart casing of paths and file extensions.

extern BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir = NULL );
extern LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension );

extern BOOL GetDisplayFile(CString &rFilename, CDC *pDC, int &cxPels); // truncates from left

/////////////////////////////////////////////////////////////////////////////
//  Path collections
//

class CPathList : public CObject
{

    DECLARE_DYNAMIC(CPathList)

protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        CPath* data;
    };
public:

// Construction
    CPathList(int nBlockSize=10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    CPath*& GetHead();
    CPath* GetHead() const;
    CPath*& GetTail();
    CPath* GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    CPath* RemoveHead();
    CPath* RemoveTail();

    // add before head or after tail
    POSITION AddHead(CPath* newElement);
    POSITION AddTail(CPath* newElement);

    // add another list of elements before head or after tail
    void AddHead(CPathList* pNewList);
    void AddTail(CPathList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    POSITION GetHeadPosition() const;
    POSITION GetTailPosition() const;
    CPath*& GetNext(POSITION& rPosition); // return *Position++
    CPath* GetNext(POSITION& rPosition) const; // return *Position++
    CPath*& GetPrev(POSITION& rPosition); // return *Position--
    CPath* GetPrev(POSITION& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    CPath*& GetAt(POSITION position);
    CPath* GetAt(POSITION position) const;
    void SetAt(POSITION pos, CPath* newElement);
    void RemoveAt(POSITION position);

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, CPath* newElement);
    POSITION InsertAfter(POSITION position, CPath* newElement);

    // helper functions (note: O(n) speed)
    POSITION Find(CPath* searchValue, POSITION startAfter = NULL) const;
                        // defaults to starting at the HEAD
                        // return NULL if not found
    POSITION FindIndex(int nIndex) const;
                        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CPathList();
#ifdef _DEBUG
    void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};


////////////////////////////////////////////////////////////////////////////
#ifndef _AFXCOLL_INLINE
#define _AFXCOLL_INLINE inline
#endif

_AFXCOLL_INLINE int CPathList::GetCount() const
    { return m_nCount; }
_AFXCOLL_INLINE BOOL CPathList::IsEmpty() const
    { return m_nCount == 0; }
_AFXCOLL_INLINE CPath*& CPathList::GetHead()
    { VSASSERT(m_pNodeHead != NULL, "Cannot do GetHead on empty list");
        return m_pNodeHead->data; }
_AFXCOLL_INLINE CPath* CPathList::GetHead() const
    { VSASSERT(m_pNodeHead != NULL, "Cannot do GetHead on empty list");
        return m_pNodeHead->data; }
_AFXCOLL_INLINE CPath*& CPathList::GetTail()
    { VSASSERT(m_pNodeTail != NULL, "Cannot do GetTail on empty list");
        return m_pNodeTail->data; }
_AFXCOLL_INLINE CPath* CPathList::GetTail() const
    { VSASSERT(m_pNodeTail != NULL, "Cannot do GetTail on empty list");
        return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CPathList::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CPathList::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CPath*& CPathList::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        VSASSERT(AfxIsValidAddress(pNode, sizeof(CNode)), "Bad parameter to GetNext");
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
_AFXCOLL_INLINE CPath* CPathList::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        VSASSERT(AfxIsValidAddress(pNode, sizeof(CNode)), "Bad parameter to GetNext");
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
_AFXCOLL_INLINE CPath*& CPathList::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        VSASSERT(AfxIsValidAddress(pNode, sizeof(CNode)), "Bad parameter to GetPrev");
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
_AFXCOLL_INLINE CPath* CPathList::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        VSASSERT(AfxIsValidAddress(pNode, sizeof(CNode)), "Bad parameter to GetPrev");
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
_AFXCOLL_INLINE CPath*& CPathList::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        VSASSERT(AfxIsValidAddress(pNode, sizeof(CNode)), "Bad parameter to GetAt");
        return pNode->data; }
_AFXCOLL_INLINE CPath* CPathList::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        VSASSERT(AfxIsValidAddress(pNode, sizeof(CNode)), "Bad parameter to GetAt");
        return pNode->data; }
_AFXCOLL_INLINE void CPathList::SetAt(POSITION pos, CPath* newElement)
    { CNode* pNode = (CNode*) pos;
        VSASSERT(AfxIsValidAddress(pNode, sizeof(CNode)), "Bad parameter to SetAt");
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////

//#undef AFX_DATA
//#define AFX_DATA NEAR

#endif // __PATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\msgboxes2.h ===
#ifndef __MSGBOXES2_H__
#define __MSGBOXES2_H__

#include <tchar.h>
#include <stdarg.h>	// for var args stuff.
#include "path2.h"

#ifndef MAX_SUBSTITUTION_BYTES
#define MAX_SUBSTITUTION_BYTES	1024
#endif

#ifndef _WIN32
#ifndef LPCTSTR
#define LPCTSTR LPCSTR
#endif
#ifndef LPTSTR
#define LPTSTR LPSTR
#endif
#endif

LPCTSTR VCMsgText(CVCString &strBuffer, const CVCPath &pathOffendingFile, LPCTSTR pszOperation);
LPCTSTR VVCMsgText(CVCString &strBuffer, const int idsMsgFormat, va_list VarArguments);
LPCTSTR VCMsgText(CVCString &strBuffer, const int idsMsgFormat, ...);
LPCTSTR VCMsgText(CVCString &strBuffer, const CVCPath &pathOffendingFile, const int idsFileOperation);

LPCTSTR VCSubstituteBytes(CVCString &strBuffer, LPCTSTR pszFormat, va_list VarArguments);

LPCOLESTR VCMsgTextW(CStringW &strBuffer, const CPathW &pathOffendingFile, LPCOLESTR pszOperation);
LPCOLESTR VVCMsgTextW(CStringW &strBuffer, const int idsMsgFormat, va_list VarArguments);
LPCOLESTR VCMsgTextW(CStringW &strBuffer, const int idsMsgFormat, ...);
LPCOLESTR VCMsgTextW(CStringW &strBuffer, const CPathW &pathOffendingFile, const int idsFileOperation);

LPCOLESTR VCSubstituteBytesW(CStringW &strBuffer, LPCOLESTR pszFormat, va_list VarArguments);

#include "msgboxes2.inl"

#endif	// __MSGBOXES2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\path2.h ===
//////////////////////////////////////////////////////////////////////
// PATH2.H
//
// Definition of CVCPath and CVCDir objects.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 07-May-93	mattg		Created
// 12-May-93	danw		Add operator = and GetDisplayName
// 20-May-93	mattg		Added CVCDir object
// 22-May-93	danw		Added ConstructObject and DestructObject
//								for collections.
// 11-Jul-93	mattg		Added many new methods to CVCPath and CVCDir
//							Also "TCHAR'ified"
// 20-Jul-93    danw        Added relativization functions.
//////////////////////////////////////////////////////////////////////

#ifndef __PATH2_H__
#define __PATH2_H__

#pragma once

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <sys\stat.h>
#endif

#include "plex.h"
#include <VCFileClasses.h>
#include <VCColl.h>
#include <VCMap.h>
#include <OsUtil.h>

size_t VCRemoveNewlines(_TCHAR *);
size_t VCRemoveNewlines(wchar_t *);
BOOL WINAPI IsUnicodeSystem();
BOOL IsURLW( LPCOLESTR );

// scan a string for specific characters, but ignore anything that is quoted
size_t __cdecl FindWithNoQuotes(const wchar_t * string, const wchar_t * control);

//////////////////////////////////////////////////////////////////////
// Classes defined in this file

class CVCPath;
class CVCDir;

//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL VCScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CVCPath
class CVCPath
{
	//DECLARE_DYNAMIC(CVCPath)

	friend	class		CVCDir;

	friend	static VOID		ConstructElement(CVCPath *);
	friend	static VOID		DestructElement(CVCPath *);

protected:
	// Data
	CVCString			m_strCanon;
	int					m_ichLastSlash;	// used to quickly extract only dir or filename
	BOOL				m_Flags;
	enum				PathFlags
						{
							eIsActualCase = 1,
							eWantsRelative = 2,
						};
		// Canonicalized representation of pathname.
	static CVCMapStringToString c_DirCaseMap;
public:
	// Constructors, destructors, initialization methods
	inline				CVCPath() { m_ichLastSlash = -1; m_Flags = 0;}
	inline				CVCPath(const CVCPath & path)
							 {
								 m_strCanon = path.m_strCanon;
								 m_ichLastSlash = path.m_ichLastSlash;
								 m_Flags = path.m_Flags;
							 }
	virtual				~CVCPath();

	inline	BOOL		GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
	inline	void		SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
			(bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

	inline	BOOL		IsInit() const { return (m_ichLastSlash > 0); }

	BOOL				Create(const TCHAR *);
		// Initialize the object, given a filename.  The resulting
		// canonicalized filename will be relative to the current
		// directory.  For example, if the current directory is
		// C:\TEST and the argument is "FOO.C", the resulting
		// canonicalized filename will be "C:\TEST\FOO.C".  If the
		// argument is "..\FOO.C", the resulting canonicalized
		// filename will be "C:\FOO.C".

	BOOL				CreateFromDirAndFilename(const CVCDir &, const TCHAR *);
		// Initialize the object given a directory (CVCDir object) and
		// a filename.  This behaves exactly the same as the Create()
		// method, except that the Create() method canonicalizes the
		// filename relative to the CURRENT directory, whereas this
		// method canonicalizes the filename relative to the SPECIFIED
		// directory.

	BOOL				CreateTemporaryName(const CVCDir &, BOOL fKeep = TRUE);
		// Initialize the object given a directory.  The resulting
		// object will represent a UNIQUE filename in that directory.
		// This is useful for creating temporary filenames.
		//
		// WARNING
		// -------
		// After this method returns, the filename represented by this
		// object will EXIST ON DISK as a zero length file.  This is
		// to prevent subsequent calls to this method from returning
		// the same filename (this method checks to make sure it
		// doesn't return the name of an existing file).  IT IS YOUR
		// RESPONSIBILITY to delete the file one way or another.
		//
		// If you don't want this behavior, pass FALSE for 'fKeep',
		// and the file will not exist on disk.  Be aware, though,
		// that if you do this, subsequent calls to this method may
		// return the same filename.

	BOOL				ContainsSpecialCharacters () const
						{
							return ::VCScanPathForSpecialCharacters(m_strCanon);
						}
		// Scan the pathname for special character.  We cache this
		// information.

	inline  CVCPath&	operator =(const CVCPath & path)
						{
							VSASSERT(path.IsInit(), "CVCPath must be initialized before use");
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
		// Assignment operator.

	// Query methods
	inline	const TCHAR * GetFileName() const
						{
							VSASSERT(IsInit(), "CVCPath must be initialized before use");
							VSASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'), "Last slash not where we expect it; buffer must have been manipulated directly");
							return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
						}

		// Return a pointer to the filename part of the canonicalized
		// pathname, i.e., the filename with no leading drive or path
		// information. Return whole string if no backslash (not init).
		//
		// Please do not write through this pointer, as it is pointing
		// to internal data!

		VOID			PostFixNumber();
			// Modifies the path by postfixing a number on the end of the path's
			// basename. If there is no number on the end of the path's basename
			// then the number 1 is postfixed. Otherwise if there already is a
			// number on the end of the path's basename then that number is
			// incremented by 1 and postfixed on the end of the basename (less the
			// original number).
			//
			// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
		
		VOID			GetBaseNameString(CVCString &) const;
			// Creates a CVCString representing the base name of the fully
			// canonicalized pathname.  For example, the base name of
			// the pathname "C:\FOO\BAR.C" is "BAR".
			//
			// This method can't return a pointer to internal data like
			// some of the other methods since it would have to remove
			// the extension in order to do so.

		VOID  			GetDisplayNameString(
									CVCString &,
									int cchMax = 16,
									BOOL bTakeAllAsDefault = FALSE
									) const;
			// Creates a CVCString representing the name of the file
			// shortened to cchMax CHARACTERS (TCHARs, not bytes) or
			// less.  Only the actual characters are counted; the
			// terminating '\0' is not considered, so
			// CVCString::GetLength() on the result MAY return as much as
			// cchMax.  If cchMax is less than the length of the base
			// filename, the resulting CVCString will be empty, unless
			// bTakeAllAsDefault is TRUE, in which the base name is
			// copied in, regardless of length.
			//
			// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
			// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		inline	const TCHAR * GetExtension() const
								{
									VSASSERT(IsInit(), "CVCPath must be initialized before use");
									INT_PTR iDot = m_strCanon.ReverseFind(_T('.'));
 									if (iDot < m_ichLastSlash)
										iDot = m_strCanon.GetLength();
									const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
 									return retval;
								}

			// Return a pointer to the extension part of the canonicalized
			// pathname.  Returns a pointer to the '.' character of the
			// extension.  If the filename doesn't have an extension,
			// the pointer returned will point to the terminating '\0'.
			//
			// Please do not write through this pointer, as it is pointing
			// to internal data!

	inline	const TCHAR * GetFullPath() const { return(m_strCanon); }
			// Return a pointer to the full (canonicalized) pathname.
			//
			// Please do not write through this pointer, as it is pointing
			// to internal data!
	inline	const TCHAR * GetFullPath(CVCString & strPath) const { return(strPath = m_strCanon); }

	inline	BOOL		IsActualCase() const { return ((m_Flags & eIsActualCase)!=0); }
	void				GetActualCase(BOOL bEntirePath = FALSE);
			// Adjusts the paths case to match the actual path and filename
			// on disk.
	void				SetActualCase(LPCTSTR pszFileCase); 
			// Adjusts the paths case to match the actual path and filename
			// on disk, where pszFileCase already contains the correct case
			// for just the filename portion.
	static void			ResetDirMap();

	inline				operator const TCHAR *() const { return(m_strCanon); }
			// Return the fully canonicalized filename as a (const TCHAR *).
			// Same thing as GetFullPath(), but more convenient in some
			// cases.
			//
			// Please do not write through this pointer, as it is pointing
			// to internal data!

	inline	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	inline BOOL			IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

	int					operator ==(const CVCPath &) const;
		// Returns 1 if the two CPaths are identical, 0 if they are
		// different.

	inline	int			operator !=(const CVCPath & path) const { return(!(operator ==(path))); }
		// Returns 1 if the two CPaths are different, 0 if they are
		// identical.

	// Modification methods

	VOID				ChangeFileName(const TCHAR *);
		// Changes the file name to that specified by the
		// (const TCHAR *) argument.  The directory portion of the
		// pathname remains unchanged.  DO NOT pass in anything
		// other than a simple filename, i.e., do not pass in
		// anything with path modifiers.

	VOID				ChangeExtension(const TCHAR *);
		// Changes the extension of the pathname to be that specified
		// by the (const TCHAR *) argument.  The argument can either be
		// of the form ".EXT" or "EXT".  If the current pathname has
		// no extension, this is equivalent to adding the new extension.

	BOOL 				GetRelativeName (const CVCDir&, CVCString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
		// Makes the path name relative to the supplied directory and
		// placed the result in strResult.  Function will only go
		// down from the supplied directy (no ..'s).  Returns TRUE if
		// relativization was successful, or FALSE if not (e.g. if
		// string doesn't start with ".\" or ..\ or at least \).
		//
		// Thus, if the base directory is c:\sushi\vcpp32:
		//
		//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
		//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
		//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
		//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

		// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
		//
		// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
		// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

		// If bQuote is true, then quotes are put around the relative
		// file name. (Useful for writing the filename out to a file)

		// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
		// and if the file is on the same drive we will ALWAYS
		// relativize it. Thus for the base dir c:\sushi\vcpp32
		//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

	BOOL			   CreateFromDirAndRelative (const CVCDir&, const TCHAR *);
		// THIS FUNCTION IS OBSOLETE.  New code should use
		// CreateFromDirAndFilename().  The only difference between
		// that function and this one is that this one will
		// automatically remove quotes from around the relative
		// path name (if present).


	// Miscellaneous methods
	inline	BOOL		IsReadOnlyOnDisk() const
						{
							HANDLE	h;

							VSASSERT(IsInit(), "CVCPath must be initialized before use");
							h = CreateFile(m_strCanon, GENERIC_WRITE,
								FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL, NULL);

							if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
								return TRUE;

							if (h != INVALID_HANDLE_VALUE)
								CloseHandle(h);

							return FALSE;
						}
		// Returns TRUE if the filename represented by this object
		// is read-only on disk, FALSE if not.  NOT guaranteed to
		// work in all circumstances -- for example, will not return
		// TRUE for a file on a floppy drive that has been write-
		// protected.  I don't know of any way to get this information
		// from NT (GetFileAttributes doesn't work; GetVolumeInformation
		// doesn't work; _access just calls GetFileAttributes; etc.).
		// This method WILL correctly detect:
		//		- Files marked as read-only
		//		- Files on read-only network drives

	inline	BOOL		ExistsOnDisk() const
						{
							VSASSERT(IsInit(), "CVCPath must be initialized before use");
							return(_taccess(m_strCanon, 00) != -1);
						}
		// Returns TRUE if the filename represented by this object
		// exists on disk, FALSE if not.

	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const;
		// Returns TRUE if the filename represented by this object
		// can be created on disk, FALSE if not.

	inline	BOOL		DeleteFromDisk() const
						{
							VSASSERT(IsInit(), "CVCPath must be initialized before use");
#ifdef _WIN32
							return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
							return(remove(m_strCanon) != -1);
#endif
						}
		// Removes the file represented by this object from the disk.

	BOOL				GetFileTime(LPFILETIME lpftLastWrite);
	BOOL				GetFileTime(CVCString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string
};
//	Creation and destruction functions used by CVCMapPathToPtr:

extern const CVCString /*AFX_DATA*/ pthEmptyString;

static inline VOID ConstructElement(CVCPath * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyString, sizeof(CVCString));
}

static inline VOID DestructElement(CVCPath * pOldData)
{
	pOldData->m_strCanon.Empty();
}


//	File Name Utility Functions
//		These are redundant and could be replaced with use of CVCPath, but are
//		kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CVCString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CVCString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CVCString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
// CVCString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);
CStringW GetRelativeName(LPCOLESTR szFilePath, LPCOLESTR szDirectory = NULL);

// Makes a file path look like in MRU.
CVCString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory = NULL);


//////////////////////////////////////////////////////////////////////
// CVCDir
//
// The CVCDir object represents a file system directory on some disk.
//
// A CVCDir object can be created to represent the current directory,
// to represent the directory of a CVCPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CVCDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CVCDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CVCPath methods which use CVCDir objects.

class CVCDir
{
	//DECLARE_DYNAMIC(CVCDir)

	friend	class		CVCPath;

	friend	static VOID		ConstructElement(CVCDir *);
	friend	static VOID		DestructElement(CVCDir *);

protected:
	CVCString			m_strDir;
		// Directory name, including drive letter or
		// server/share.  Do NOT make any assumptions
		// about whether or not this ends in '\'!

	// Creates multi level directories just fine
	BOOL				MakeDirectory(LPCTSTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CVCDir() {}
	inline				CVCDir(const CVCDir & dir) { m_strDir = dir.m_strDir; }
	virtual				~CVCDir();
	inline	BOOL		IsInit() { return !m_strDir.IsEmpty(); }

	BOOL				CreateFromCurrent();
		// Initialize from the current working directory.  This
		// may fail if the current working directory is unknown
		// or invalid.

	BOOL				CreateFromPath(const CVCPath &, BOOL bIsAlreadyDirectory = FALSE);
		// Initialize based on the directory of the specified
		// CVCPath object.  That is, if the CVCPath object represents
		// the file "C:\FOO\BAR\BLIX.C", the resulting directory
		// for this object will be "C:\FOO\BAR".  However, you can set bIsAlreadyDirectory
		// to TRUE and get the whole path.  For example, if the CVCPath object
		// represents "C:\FOO\BAR", the resulting directory will stay "C:\FOO\BAR"
		// Returns FALSE on failure.

	BOOL				CreateFromPath(const TCHAR *pszPath, BOOL bIsAlreadyDirectory = FALSE);
		// Initialize based on the directory of the specified
		// CVCPath object.  That is, if the CVCPath object represents
		// the file "C:\FOO\BAR\BLIX.C", the resulting directory
		// for this object will be "C:\FOO\BAR".  However, you can set bIsAlreadyDirectory
		// to TRUE and get the whole path.  For example, if the CVCPath object
		// represents "C:\FOO\BAR", the resulting directory will stay "C:\FOO\BAR"
		// Returns FALSE on failure.

	BOOL				CreateTemporaryName();
		// Initialize this object to represent a temporary directory
		// on disk (e.g., "C:\TMP").

	inline BOOL			CreateFromString(const TCHAR * sz, BOOL bIsAlreadyDirectory = FALSE)
						{
							return  CreateFromStringEx(sz, FALSE, bIsAlreadyDirectory);
						}	
		// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
		// do not use this method when another would suffice!

	BOOL				CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative, BOOL bIsAlreadyDirectory = FALSE);
		// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
		// do not use this method when another would suffice!
		// same as CreateFromString with minor change. Not treating as bug fix to CFS
		// due to lateness in VC 4.0 project time

		// if fRootRelative true, treat dir ending with colon as relative not root dir 
		// (actual correct handling)


	BOOL				ContainsSpecialCharacters () const
						{
							return ::VCScanPathForSpecialCharacters(m_strDir);
						}
	inline BOOL			IsEmpty() const { return (m_strDir.IsEmpty()); }

		// Scan the pathname for special character.  We cache this information.

	inline	CVCDir&		operator =(const CVCDir & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
		// Assignment operator.

	// Query methods

	inline				operator const TCHAR *() const { return(m_strDir); }
				// Return the directory name as a (const TCHAR *) string.

	inline int			GetLength() const { return (int) m_strDir.GetLength(); }
		// Returns the length of the directory name

	// Miscellaneous methods

	BOOL			MakeCurrent() const;
		// Make this object the current working directory.  May fail
		// if the directory no longer exists (e.g., a floppy drive).

	BOOL			ExistsOnDisk() const;
		// Returns TRUE if the directory represented by this object
		// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
		// Creates the directory on disk.  If this fails, returns
		// FALSE.  If the directory already existed on disk, returns
		// TRUE (i.e., that is not an error condition).

	inline	BOOL		RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
		// Removes the directory from the disk.  If this fails for
		// any reason (directory does not exist, directory is not
		// empty, etc.), returns FALSE.

	BOOL				IsRootDir() const;
		// Returns TRUE if the directory represented by this object
		// is a root directory (e.g., "C:\"), FALSE if not.  Note that
		// calling this method will NOT tell you whether or not the
		// string representation ends in '\', since "\\server\share"
		// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return(m_strDir[0] == _T('\\')); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

	VOID				AppendSubdirName(const TCHAR *);
		// Adds a subdirectory name.  For example, if this object
		// currently represents "C:\FOO\BAR", and the argument is
		// "$AUTSAV$", the resulting object represents
		// "C:\FOO\BAR\$AUTSAV$".
		//
		// WARNING: This method does NO validation of the result --
		// it does not check for illegal characters, or for a
		// directory name that is too long.  In particular, don't
		// pass "DIR1/DIR2" as an argument, since no conversion
		// (of '/' to '\') will occur.

	VOID				RemoveLastSubdirName();
		// Removes the last component of the directory name.  For
		// example, if this object currently represents
		// "C:\FOO\BAR\$AUTSAV$", after this method it will
		// represent "C:\FOO\BAR".  If you try to call this method
		// when the object represents a root directory (e.g., "C:\"),
		// it will assert.

	// Comparison methods

	int					operator ==(const CVCDir &) const;
		// Returns 1 if the two CVCDirs are identical, 0 if they are
		// different.

	inline	int			operator !=(const CVCDir & dir) const { return(!(operator ==(dir))); }
		// Returns 1 if the two CVCDirs are different, 0 if they are identical.
};

//	Creation and destruction functions used by CVCMapDirToPtr:

static inline VOID ConstructElement(CVCDir * pNewData)
{
	memcpy(&pNewData->m_strDir, &pthEmptyString, sizeof(CVCString));
}

static inline VOID DestructElement(CVCDir * pOldData)
{
	pOldData->m_strDir.Empty();
}

///////////////////////////////////////////////////////////////////////////////
//	CVCCurDir
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class CVCCurDir : CVCDir
{
public:
	CVCCurDir(const char* szPath, BOOL bFile = FALSE);
	CVCCurDir(const CVCDir& dir);
	CVCCurDir();	// just saves the current directory and resets it
	~CVCCurDir();

	CVCDir m_dir;
};

///////////////////////////////////////////////////////////////////////////////
//	CVCFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//

class CVCFileOpenReturn
{
	BOOL		m_bSingle;
	BOOL		m_bBufferInUse;
	BOOL		m_bArrayHasChanged;

	INT_PTR		m_cbData;
	_TCHAR * 	m_pchData;

	// Multiple Files
	CVCPtrArray	m_rgszNames;

public:
	CVCFileOpenReturn(const _TCHAR * szRawString = NULL);
	~CVCFileOpenReturn();

	inline BOOL IsSingle() const;
	inline BOOL IsDirty() const;
	inline BOOL BufferOverflow() const;
	//inline int  GetLength() const;

	// GetBuffer gives permission for something else to directly change the buffer
	// ReleaseBuffer signifies that the something else is done with it.
	_TCHAR * GetBuffer(int cbBufferNew);
	inline void ReleaseBuffer ();

	// allows the object to be re-initialized
	void ReInit(const _TCHAR * szRawString);

	// This supports the dynamic file extension update in OnFileNameOK().
	void ChangeExtension(int i, const CVCString& szExt);

	void CopyBuffer(_TCHAR * szTarget);

	// This is the function to use to get at the user's selections,
	// whether single or multiple.
	BOOL GetPathname(int i, CVCString& strPath) const;

private:
	void GenArrayFromBuffer();
	void GenBufferFromArray();
	void ClearNamesArray();
	void SetBuffer(const _TCHAR * szRawString);	
};


inline BOOL CVCFileOpenReturn::IsSingle() const
{
	return m_bSingle;
}

inline BOOL CVCFileOpenReturn::IsDirty() const
{
	return m_bArrayHasChanged;
}

inline BOOL CVCFileOpenReturn::BufferOverflow() const
{
	return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//	Processes the raw string
//
///
inline void CVCFileOpenReturn::ReleaseBuffer()
{
	m_bBufferInUse = FALSE;
	GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//	Smart case helpers.
//		These functions are used to do smart casing of paths and file extensions.

extern BOOL VCGetActualFileCase(CVCString& rFilename, LPCTSTR lpszDir = NULL);
extern LPCTSTR VCGetExtensionCase(LPCTSTR lpszFilename, LPCTSTR lpszExtension);

//extern BOOL VCGetDisplayFile(CVCString &rFilename, DC *pDC, int &cxPels); // truncates from left

///////////////////////////////////////////////////////////////////////////////
// Smart canonicalization helper
extern BOOL VCCanonicalizePathNameW(const wchar_t* szOriginalFile, CStringW& strFixedFile, int& nLastSlashLoc, BOOL bMustBeFile = TRUE);

/////////////////////////////////////////////////////////////////////////////
//	Path collections
//

class CVCPathList
{

	//DECLARE_DYNAMIC(CVCPathList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CVCPath* data;
	};
public:

// Construction
	CVCPathList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CVCPath*& GetHead();
	CVCPath* GetHead() const;
	CVCPath*& GetTail();
	CVCPath* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	CVCPath* RemoveHead();
	CVCPath* RemoveTail();

	// add before head or after tail
	VCPOSITION AddHead(CVCPath* newElement);
	VCPOSITION AddTail(CVCPath* newElement);

	// add another list of elements before head or after tail
	void AddHead(CVCPathList* pNewList);
	void AddTail(CVCPathList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	VCPOSITION GetHeadPosition() const;
	VCPOSITION GetTailPosition() const;
	CVCPath*& GetNext(VCPOSITION& rPosition); // return *Position++
	CVCPath* GetNext(VCPOSITION& rPosition) const; // return *Position++
	CVCPath*& GetPrev(VCPOSITION& rPosition); // return *Position--
	CVCPath* GetPrev(VCPOSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CVCPath*& GetAt(VCPOSITION position);
	CVCPath* GetAt(VCPOSITION position) const;
	void SetAt(VCPOSITION pos, CVCPath* newElement);
	void RemoveAt(VCPOSITION position);

	// inserting before or after a given position
	VCPOSITION InsertBefore(VCPOSITION position, CVCPath* newElement);
	VCPOSITION InsertAfter(VCPOSITION position, CVCPath* newElement);

	// helper functions (note: O(n) speed)
	VCPOSITION Find(CVCPath* searchValue, VCPOSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	VCPOSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CVCPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CVCPathList();
};


/////////////////////////////////////////////////////////////////////////////

class CVCDirList
{

	//DECLARE_DYNAMIC(CVCDirList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CVCDir* data;
	};
public:

// Construction
	CVCDirList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CVCDir*& GetHead();
	CVCDir* GetHead() const;
	CVCDir*& GetTail();
	CVCDir* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	CVCDir* RemoveHead();
	CVCDir* RemoveTail();

	// add before head or after tail
	VCPOSITION AddHead(CVCDir* newElement);
	VCPOSITION AddTail(CVCDir* newElement);

	// add another list of elements before head or after tail
	void AddHead(CVCDirList* pNewList);
	void AddTail(CVCDirList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	VCPOSITION GetHeadPosition() const;
	VCPOSITION GetTailPosition() const;
	CVCDir*& GetNext(VCPOSITION& rPosition); // return *Position++
	CVCDir* GetNext(VCPOSITION& rPosition) const; // return *Position++
	CVCDir*& GetPrev(VCPOSITION& rPosition); // return *Position--
	CVCDir* GetPrev(VCPOSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CVCDir*& GetAt(VCPOSITION position);
	CVCDir* GetAt(VCPOSITION position) const;
	void SetAt(VCPOSITION pos, CVCDir* newElement);
	void RemoveAt(VCPOSITION position);

	// inserting before or after a given position
	VCPOSITION InsertBefore(VCPOSITION position, CVCDir* newElement);
	VCPOSITION InsertAfter(VCPOSITION position, CVCDir* newElement);

	// helper functions (note: O(n) speed)
	VCPOSITION Find(CVCDir* searchValue, VCPOSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	VCPOSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

	// Cool functions to convert to and from a semi-colon separated string
	BOOL FromString(LPCTSTR lpszString, BOOL bCheckExist = FALSE); // Note: first does a remove all
	BOOL ToString(CVCString& str);

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CVCPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CVCDirList();
};


/////////////////////////////////////////////////////////////////////////////
class CVCMapPathToPtr	// replaces CVCMapPathToPtr
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CVCPath key;
		void* value;
	};
public:

// Construction
	CVCMapPathToPtr(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(const CVCPath& key, void*& rValue) const;

	//	Function returns position of an item.  This is useful if you're trying
	//	to save the address of an item, say for a listbox.  If you save the 
	//	return VCPOSITION, you can get the key back with GetNextAssoc.

	VCPOSITION LookupPos(const CVCPath& key) const
	{
		UINT nHash;
		return (VCPOSITION) GetAssocAt((CVCPath&) key, nHash);
	};

// Operations
	// Lookup and add if not there
	void*& operator[](const CVCPath& key);

	// add a new (key, value) pair
	void SetAt(CVCPath& key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(CVCPath& key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, CVCPath& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(CVCPath& key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(CVCPath&, UINT&) const;


public:
	~CVCMapPathToPtr();
};

/////////////////////////////////////////////////////////////////////////////

class CVCMapDirToPtr	// replaces CVCMapDirToPtr
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CVCDir key;
		void* value;
	};
public:

// Construction
	CVCMapDirToPtr(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(const CVCDir& key, void*& rValue) const;

	//	Function returns position of an item.  This is useful if you're trying
	//	to save the address of an item, say for a listbox.  If you save the 
	//	return VCPOSITION, you can get the key back with GetNextAssoc.
	VCPOSITION LookupPos(const CVCDir& key) const
	{
		UINT nHash;
		return (VCPOSITION) GetAssocAt((CVCDir&)key, nHash);
	};

// Operations
	// Lookup and add if not there
	void*& operator[](const CVCDir& key);

	// add a new (key, value) pair
	void SetAt(CVCDir& key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(CVCDir& key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, CVCDir& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(CVCDir& key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(CVCDir&, UINT&) const;

public:
	~CVCMapDirToPtr();
};

////////////////////////////////////////////////////////////////////////////

inline int CVCPathList::GetCount() const
	{ return m_nCount; }
inline BOOL CVCPathList::IsEmpty() const
	{ return m_nCount == 0; }
inline CVCPath*& CVCPathList::GetHead()
	{ VSASSERT(m_pNodeHead != NULL, "Calling GetHead on empty CVCPathList!");
		return m_pNodeHead->data; }
inline CVCPath* CVCPathList::GetHead() const
	{ VSASSERT(m_pNodeHead != NULL, "Calling GetHead on empty CVCPathList!");
		return m_pNodeHead->data; }
inline CVCPath*& CVCPathList::GetTail()
	{ VSASSERT(m_pNodeTail != NULL, "Calling GetTail on empty CVCPathList!");
		return m_pNodeTail->data; }
inline CVCPath* CVCPathList::GetTail() const
	{ VSASSERT(m_pNodeTail != NULL, "Calling GetTail on empty CVCPathList!");
		return m_pNodeTail->data; }
inline VCPOSITION CVCPathList::GetHeadPosition() const
	{ return (VCPOSITION) m_pNodeHead; }
inline VCPOSITION CVCPathList::GetTailPosition() const
	{ return (VCPOSITION) m_pNodeTail; }
inline CVCPath*& CVCPathList::GetNext(VCPOSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCPathList");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline CVCPath* CVCPathList::GetNext(VCPOSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCPathList");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline CVCPath*& CVCPathList::GetPrev(VCPOSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCPathList");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline CVCPath* CVCPathList::GetPrev(VCPOSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCPathList");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline CVCPath*& CVCPathList::GetAt(VCPOSITION position)
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCPathList");
		return pNode->data; }
inline CVCPath* CVCPathList::GetAt(VCPOSITION position) const
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCPathList");
		return pNode->data; }
inline void CVCPathList::SetAt(VCPOSITION pos, CVCPath* newElement)
	{ CNode* pNode = (CNode*) pos;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCPathList");
		pNode->data = newElement; }


////////////////////////////////////////////////////////////////////////////

inline int CVCDirList::GetCount() const
	{ return m_nCount; }
inline BOOL CVCDirList::IsEmpty() const
	{ return m_nCount == 0; }
inline CVCDir*& CVCDirList::GetHead()
	{ VSASSERT(m_pNodeHead != NULL, "Calling GetHead on empty CVCDirList!");
		return m_pNodeHead->data; }
inline CVCDir* CVCDirList::GetHead() const
	{ VSASSERT(m_pNodeHead != NULL, "Calling GetHead on empty CVCDirList!");
		return m_pNodeHead->data; }
inline CVCDir*& CVCDirList::GetTail()
	{ VSASSERT(m_pNodeTail != NULL, "Calling GetTail on empty CVCDirList!");
		return m_pNodeTail->data; }
inline CVCDir* CVCDirList::GetTail() const
	{ VSASSERT(m_pNodeTail != NULL, "Calling GetTail on empty CVCDirList!");
		return m_pNodeTail->data; }
inline VCPOSITION CVCDirList::GetHeadPosition() const
	{ return (VCPOSITION) m_pNodeHead; }
inline VCPOSITION CVCDirList::GetTailPosition() const
	{ return (VCPOSITION) m_pNodeTail; }
inline CVCDir*& CVCDirList::GetNext(VCPOSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCDirList");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline CVCDir* CVCDirList::GetNext(VCPOSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCDirList");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline CVCDir*& CVCDirList::GetPrev(VCPOSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCDirList");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline CVCDir* CVCDirList::GetPrev(VCPOSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCDirList");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline CVCDir*& CVCDirList::GetAt(VCPOSITION position)
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCDirList");
		return pNode->data; }
inline CVCDir* CVCDirList::GetAt(VCPOSITION position) const
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCDirList");
		return pNode->data; }
inline void CVCDirList::SetAt(VCPOSITION pos, CVCDir* newElement)
	{ CNode* pNode = (CNode*) pos;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node in CVCDirList");
		pNode->data = newElement; }


////////////////////////////////////////////////////////////////////////////

inline int CVCMapPathToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapPathToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapPathToPtr::SetAt(CVCPath& key, void* newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapPathToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : VCBEFORE_START_POSITION; }
inline UINT CVCMapPathToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }

////////////////////////////////////////////////////////////////////////////

inline int CVCMapDirToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapDirToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapDirToPtr::SetAt(CVCDir& key, void* newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapDirToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : VCBEFORE_START_POSITION; }
inline UINT CVCMapDirToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////

BOOL ScanPathForSpecialCharactersW (const wchar_t *pPath);
//////////////////////////////////////////////////////////////////////
// CPathW
class CPathW
{
	friend	class		CDirW;
	friend	static VOID		ConstructElement(CPathW *);
	friend	static VOID		DestructElement(CPathW *);

protected:
	// Data
	CStringW			m_strCanon;
	int					m_ichLastSlash;	// used to quickly extract only dir or filename
	BOOL				m_Flags;
	enum				PathFlags
						{
							eIsActualCase = 1,
							eWantsRelative = 2,
						};
	// Canonicalized representation of pathname.
	static CVCMapStringWToStringW c_DirCaseMap;

public:
	// Constructors, destructors, initialization methods
	CPathW()
	{
		m_ichLastSlash = -1;
		m_Flags = 0;
	}
	CPathW(const CPathW & path)
	{
		m_strCanon = path.m_strCanon;
		m_ichLastSlash = path.m_ichLastSlash;
		m_Flags = path.m_Flags;
	}
	virtual	~CPathW();

	BOOL GetAlwaysRelative() const
	{
		return ((m_Flags & eWantsRelative) != 0);
	}
	void SetAlwaysRelative(BOOL bWantsRel = TRUE)
	{
		m_Flags = (bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;
	}

	BOOL IsInit() const { return (m_ichLastSlash > 0); }

	BOOL Create(const wchar_t *);
		// Initialize the object, given a filename.  The resulting
		// canonicalized filename will be relative to the current
		// directory.  For example, if the current directory is
		// C:\TEST and the argument is "FOO.C", the resulting
		// canonicalized filename will be "C:\TEST\FOO.C".  If the
		// argument is "..\FOO.C", the resulting canonicalized
		// filename will be "C:\FOO.C".

	BOOL				CreateFromDirAndFilename(const CDirW &, const wchar_t *);
		// Initialize the object given a directory (CDirW object) and
		// a filename.  This behaves exactly the same as the Create()
		// method, except that the Create() method canonicalizes the
		// filename relative to the CURRENT directory, whereas this
		// method canonicalizes the filename relative to the SPECIFIED
		// directory.

	BOOL				CreateFromKnown(const wchar_t* szPath);
		// Initialize the object given a known, actual case name.
		// Warning: use this method only if you *KNOW* the file name is fully valid
		// AND the correct case

	BOOL				CreateTemporaryName(const CDirW &, BOOL fKeep = TRUE);
		// Initialize the object given a directory.  The resulting
		// object will represent a UNIQUE filename in that directory.
		// This is useful for creating temporary filenames.
		//
		// WARNING
		// -------
		// After this method returns, the filename represented by this
		// object will EXIST ON DISK as a zero length file.  This is
		// to prevent subsequent calls to this method from returning
		// the same filename (this method checks to make sure it
		// doesn't return the name of an existing file).  IT IS YOUR
		// RESPONSIBILITY to delete the file one way or another.
		//
		// If you don't want this behavior, pass FALSE for 'fKeep',
		// and the file will not exist on disk.  Be aware, though,
		// that if you do this, subsequent calls to this method may
		// return the same filename.

	BOOL				ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharactersW(m_strCanon);
						}
		// Scan the pathname for special character.  We cache this
		// information.

	 CPathW&	operator =(const CPathW & path)
						{
							VSASSERT(path.IsInit(), "CPathW must be initialized before use");
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
		// Assignment operator.

	// Query methods
	const wchar_t * GetFileName() const
						{
							VSASSERT(IsInit(), "CPathW must be initialized before use");
							VSASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'), "Last slash not where we expect it; buffer must have been manipulated directly");
							return ((const wchar_t *)m_strCanon + m_ichLastSlash + 1);
						}

		// Return a pointer to the filename part of the canonicalized
		// pathname, i.e., the filename with no leading drive or path
		// information. Return whole string if no backslash (not init).
		//
		// Please do not write through this pointer, as it is pointing
		// to internal data!

		VOID			PostFixNumber();
			// Modifies the path by postfixing a number on the end of the path's
			// basename. If there is no number on the end of the path's basename
			// then the number 1 is postfixed. Otherwise if there already is a
			// number on the end of the path's basename then that number is
			// incremented by 1 and postfixed on the end of the basename (less the
			// original number).
			//
			// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
		
		VOID			GetBaseNameString(CStringW &) const;
			// Creates a CStringW representing the base name of the fully
			// canonicalized pathname.  For example, the base name of
			// the pathname "C:\FOO\BAR.C" is "BAR".
			//
			// This method can't return a pointer to internal data like
			// some of the other methods since it would have to remove
			// the extension in order to do so.

		VOID  			GetDisplayNameString(
									CStringW &,
									int cchMax = 16,
									BOOL bTakeAllAsDefault = FALSE
									) const;
			// Creates a CStringW representing the name of the file
			// shortened to cchMax CHARACTERS (wchar_ts, not bytes) or
			// less.  Only the actual characters are counted; the
			// terminating '\0' is not considered, so
			// CStringW::GetLength() on the result MAY return as much as
			// cchMax.  If cchMax is less than the length of the base
			// filename, the resulting CStringW will be empty, unless
			// bTakeAllAsDefault is TRUE, in which the base name is
			// copied in, regardless of length.
			//
			// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
			// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		const wchar_t * GetExtension() const
								{
									VSASSERT(IsInit(), "CPathW must be initialized before use");
									INT_PTR iDot = m_strCanon.ReverseFind(_T('.'));
 									if (iDot < m_ichLastSlash)
										iDot = m_strCanon.GetLength();
									const wchar_t * retval = ((const wchar_t *)m_strCanon) + iDot;
 									return retval;
								}

			// Return a pointer to the extension part of the canonicalized
			// pathname.  Returns a pointer to the '.' character of the
			// extension.  If the filename doesn't have an extension,
			// the pointer returned will point to the terminating '\0'.
			//
			// Please do not write through this pointer, as it is pointing
			// to internal data!

	const wchar_t * GetFullPath() const { return(m_strCanon); }
			// Return a pointer to the full (canonicalized) pathname.
			//
			// Please do not write through this pointer, as it is pointing
			// to internal data!
	const wchar_t * GetFullPath(CStringW & strPath) const { return(strPath = m_strCanon); }

	BOOL		IsActualCase() const { return ((m_Flags & eIsActualCase)!=0); }
	void				GetActualCase(BOOL bEntirePath = FALSE);
			// Adjusts the paths case to match the actual path and filename
			// on disk.
	void				SetActualCase(LPCOLESTR pszFileCase);
			// Adjusts the paths case to match the actual path and filename
			// on disk, where pszFileCase already contains the correct case
			// for just the filename portion.
	static void			ResetDirMap();

				operator const wchar_t *() const { return(m_strCanon); }
			// Return the fully canonicalized filename as a (const wchar_t *).
			// Same thing as GetFullPath(), but more convenient in some
			// cases.
			//
			// Please do not write through this pointer, as it is pointing
			// to internal data!

	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	BOOL			IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

	int					operator ==(const CPathW &) const;
		// Returns 1 if the two CPaths are identical, 0 if they are
		// different.

	int			operator !=(const CPathW & path) const { return(!(operator ==(path))); }
		// Returns 1 if the two CPaths are different, 0 if they are
		// identical.

	// Modification methods

	VOID				ChangeFileName(const wchar_t *);
		// Changes the file name to that specified by the
		// (const wchar_t *) argument.  The directory portion of the
		// pathname remains unchanged.  DO NOT pass in anything
		// other than a simple filename, i.e., do not pass in
		// anything with path modifiers.

	VOID				ChangeExtension(const wchar_t *);
		// Changes the extension of the pathname to be that specified
		// by the (const wchar_t *) argument.  The argument can either be
		// of the form ".EXT" or "EXT".  If the current pathname has
		// no extension, this is equivalent to adding the new extension.

	BOOL 				GetRelativeName (const CDirW&, CStringW&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
		// Makes the path name relative to the supplied directory and
		// placed the result in strResult.  Function will only go
		// down from the supplied directy (no ..'s).  Returns TRUE if
		// relativization was successful, or FALSE if not (e.g. if
		// string doesn't start with ".\" or ..\ or at least \).
		//
		// Thus, if the base directory is c:\sushi\vcpp32:
		//
		//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
		//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
		//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
		//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

		// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
		//
		// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
		// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

		// If bQuote is true, then quotes are put around the relative
		// file name. (Useful for writing the filename out to a file)

		// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
		// and if the file is on the same drive we will ALWAYS
		// relativize it. Thus for the base dir c:\sushi\vcpp32
		//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

	BOOL			   CreateFromDirAndRelative (const CDirW&, const wchar_t *);
		// THIS FUNCTION IS OBSOLETE.  New code should use
		// CreateFromDirAndFilename().  The only difference between
		// that function and this one is that this one will
		// automatically remove quotes from around the relative
		// path name (if present).


	// Miscellaneous methods
	BOOL		IsReadOnlyOnDisk() const;
		// Returns TRUE if the filename represented by this object
		// is read-only on disk, FALSE if not.  NOT guaranteed to
		// work in all circumstances -- for example, will not return
		// TRUE for a file on a floppy drive that has been write-
		// protected.  I don't know of any way to get this information
		// from NT (GetFileAttributes doesn't work; GetVolumeInformation
		// doesn't work; _access just calls GetFileAttributes; etc.).
		// This method WILL correctly detect:
		//		- Files marked as read-only
		//		- Files on read-only network drives

	BOOL		ExistsOnDisk() const;
		// Returns TRUE if the filename represented by this object
		// exists on disk, FALSE if not.

	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const;
		// Returns TRUE if the filename represented by this object
		// can be created on disk, FALSE if not.

	BOOL		CreateOnDisk(BOOL bMakeNew = FALSE) const;
		// Returns TRUE if the filename represented by this object has been created on disk as a 
		// result of this call, FALSE if not.  If bMakeNew is true, then requires that the file 
		// not previously exist.

	BOOL		DeleteFromDisk() const;
		// Removes the file represented by this object from the disk.

	BOOL				GetFileTime(LPFILETIME lpftLastWrite);
	BOOL				GetFileTime(CStringW& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string

	static BOOL	IsReservedOSName(LPCOLESTR szName);
	
	void				GetClassicOSPath(CStringW& strPath);
		// gets the classic 8.3 format of the file path associated with this CPathW object
};


//////////////////////////////////////////////////////////////////////
// CDirW
//
// The CDirW object represents a file system directory on some disk.
//
// A CDirW object can be created to represent the current directory,
// to represent the directory of a CVCPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDirW object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDirW object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CVCPath methods which use CDirW objects.

class CDirW
{
	friend	class		CPathW;
	friend	static VOID		ConstructElement(CDirW *);
	friend	static VOID		DestructElement(CDirW *);

protected:
	CStringW			m_strDir;
		// Directory name, including drive letter or
		// server/share.  Do NOT make any assumptions
		// about whether or not this ends in '\'!

	// Creates multi level directories just fine
	BOOL				MakeDirectory(LPCOLESTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CDirW() {}
	inline				CDirW(const CDirW & dir) { m_strDir = dir.m_strDir; }
	virtual				~CDirW();
	inline	BOOL		IsInit() { return !m_strDir.IsEmpty(); }

	BOOL				CreateFromKnown(const wchar_t* szPath);
		// Initialize based on a known string.  WARNING: only use this method if you KNOW that what you're
		// passing in is valid!

	BOOL				CreateFromCurrent();
		// Initialize from the current working directory.  This
		// may fail if the current working directory is unknown
		// or invalid.

	BOOL				CreateFromPath(const CPathW &, BOOL bIsAlreadyDirectory = FALSE);
		// Initialize based on the directory of the specified
		// CPathW object.  That is, if the CPathW object represents
		// the file "C:\FOO\BAR\BLIX.C", the resulting directory
		// for this object will be "C:\FOO\BAR".  However, you can set bIsAlreadyDirectory
		// to TRUE and get the whole path.  For example, if the CPathW object
		// represents "C:\FOO\BAR", the resulting directory will stay "C:\FOO\BAR"
		// Returns FALSE on failure.

	BOOL				CreateFromPath(const wchar_t *pszPath, BOOL bIsAlreadyDirectory = FALSE, BOOL bMakeActualCase = FALSE);
		// Initialize based on the directory of the specified
		// CPathW object.  That is, if the CPathW object represents
		// the file "C:\FOO\BAR\BLIX.C", the resulting directory
		// for this object will be "C:\FOO\BAR".  However, you can set bIsAlreadyDirectory
		// to TRUE and get the whole path.  For example, if the CPathW object
		// represents "C:\FOO\BAR", the resulting directory will stay "C:\FOO\BAR"
		// Returns FALSE on failure.

	BOOL				CreateTemporaryName();
		// Initialize this object to represent a temporary directory
		// on disk (e.g., "C:\TMP").

	inline BOOL			CreateFromString(const wchar_t * sz, BOOL bIsAlreadyDirectory = FALSE)
						{
							return  CreateFromStringEx(sz, FALSE, bIsAlreadyDirectory);
						}	
		// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
		// do not use this method when another would suffice!

	BOOL				CreateFromStringEx(const wchar_t * sz, BOOL fRootRelative, BOOL bIsAlreadyDirectory = FALSE);
		// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
		// do not use this method when another would suffice!
		// same as CreateFromString with minor change. Not treating as bug fix to CFS
		// due to lateness in VC 4.0 project time

		// if fRootRelative true, treat dir ending with colon as relative not root dir 
		// (actual correct handling)


	BOOL				ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharactersW(m_strDir);
						}
	inline BOOL			IsEmpty() const { return (m_strDir.IsEmpty()); }

		// Scan the pathname for special character.  We cache this information.

	inline	CDirW&		operator =(const CDirW & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
		// Assignment operator.

	// Query methods

	inline				operator const wchar_t *() const { return(m_strDir); }
				// Return the directory name as a (const wchar_t *) string.

	inline int			GetLength() const { return (int)m_strDir.GetLength(); }
		// Returns the length of the directory name

	// Miscellaneous methods

	BOOL				MakeCurrent() const;
		// Make this object the current working directory.  May fail
		// if the directory no longer exists (e.g., a floppy drive).

	BOOL		ExistsOnDisk() const;
		// Returns TRUE if the directory represented by this object
		// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
		// Creates the directory on disk.  If this fails, returns
		// FALSE.  If the directory already existed on disk, returns
		// TRUE (i.e., that is not an error condition).

	BOOL		RemoveFromDisk() const;
		// Removes the directory from the disk.  If this fails for
		// any reason (directory does not exist, directory is not
		// empty, etc.), returns FALSE.

	BOOL				IsRootDir() const;
		// Returns TRUE if the directory represented by this object
		// is a root directory (e.g., "C:\"), FALSE if not.  Note that
		// calling this method will NOT tell you whether or not the
		// string representation ends in '\', since "\\server\share"
		// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return (m_strDir[0] == L'\\'); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

	VOID				AppendSubdirName(const wchar_t *);
		// Adds a subdirectory name.  For example, if this object
		// currently represents "C:\FOO\BAR", and the argument is
		// "$AUTSAV$", the resulting object represents
		// "C:\FOO\BAR\$AUTSAV$".
		//
		// WARNING: This method does NO validation of the result --
		// it does not check for illegal characters, or for a
		// directory name that is too long.  In particular, don't
		// pass "DIR1/DIR2" as an argument, since no conversion
		// (of '/' to '\') will occur.

	VOID				RemoveLastSubdirName();
		// Removes the last component of the directory name.  For
		// example, if this object currently represents
		// "C:\FOO\BAR\$AUTSAV$", after this method it will
		// represent "C:\FOO\BAR".  If you try to call this method
		// when the object represents a root directory (e.g., "C:\"),
		// it will assert.

	// Comparison methods

	int					operator ==(const CDirW &) const;
		// Returns 1 if the two CDirWs are identical, 0 if they are
		// different.

	inline	int			operator !=(const CDirW & dir) const { return(!(operator ==(dir))); }
		// Returns 1 if the two CDirWs are different, 0 if they are identical.
};

///////////////////////////////////////////////////////////////////////////////
//	CCurDirW
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class CCurDirW : CDirW
{
public:
	CCurDirW(const wchar_t* szPath, BOOL bFile = FALSE);
	CCurDirW(const CDirW& dir);
	CCurDirW();	// just saves the current directory and resets it
	~CCurDirW();

	CDirW m_dir;
};

/////////////////////////////////////////////////////////////////////////////
class CMapPathWToPtr	// replaces CMapPathToPtr
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CPathW key;
		void* value;
	};
public:

// Construction
	CMapPathWToPtr(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(const CPathW& key, void*& rValue) const;

	//	Function returns position of an item.  This is useful if you're trying
	//	to save the address of an item, say for a listbox.  If you save the 
	//	return VCPOSITION, you can get the key back with GetNextAssoc.

	VCPOSITION LookupPos(const CPathW& key) const
	{
		UINT nHash;
		return (VCPOSITION) GetAssocAt((CPathW&) key, nHash);
	};

// Operations
	// Lookup and add if not there
	void*& operator[](const CPathW& key);

	// add a new (key, value) pair
	void SetAt(CPathW& key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(CPathW& key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, CPathW& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(CPathW& key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(CPathW&, UINT&) const;


public:
	~CMapPathWToPtr();
};

//	Creation and destruction functions used by CMapPathWToPtr:
extern const CStringW pthEmptyStringW;

static inline VOID ConstructElement(CPathW * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyStringW, sizeof(CStringW));
}

static inline VOID DestructElement(CPathW * pOldData)
{
	pOldData->m_strCanon.Empty();
}

////////////////////////////////////////////////////////////////////////////

inline int CMapPathWToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL CMapPathWToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void CMapPathWToPtr::SetAt(CPathW& key, void* newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CMapPathWToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : VCBEFORE_START_POSITION; }
inline UINT CMapPathWToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }

#endif // __PATH2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\ppcimage.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ppcimage.h

Abstract:

    This is the include file that describes ppc-specific image info

Author:

    James Stulz (v-james)  July 1993

Revision History:

--*/

#ifndef _PPCIMAGE_
#define _PPCIMAGE_

#define IMAGE_FILE_MACHINE_MPPC_601         0x601   // PowerPC 601.
#define IMAGE_FILE_MPPC_DLL                 0x4000

//
// Power Macintosh relocation types
//

#define IMAGE_REL_MPPC_DESCREL              0x0000
#define IMAGE_REL_MPPC_LCALL                0x0001
#define IMAGE_REL_MPPC_DATAREL              0x0002
#define IMAGE_REL_MPPC_JMPADDR              0x0003
#define IMAGE_REL_MPPC_CREATEDESCRREL       0x0004
#define IMAGE_REL_MPPC_DATADESCRREL         0x0005
#define IMAGE_REL_MPPC_TOCREL               0x0006
#define IMAGE_REL_MPPC_SECTION              0x000A
#define IMAGE_REL_MPPC_SECREL               0x000B
#define IMAGE_REL_MPPC_ADDR24               0x000C // 26-bit address, shifted left 2 (branch absolute)
#define IMAGE_REL_MPPC_ADDR14               0x000D // 16-bit address, shifted left 2 (load doubleword)
#define IMAGE_REL_MPPC_REL24                0x000E // 26-bit PC-relative offset, shifted left 2 (branch relative)
#define IMAGE_REL_MPPC_REL14                0x000F // 16-bit PC-relative offset, shifted left 2 (br cond relative)
#define IMAGE_REL_MPPC_CV                   0x0013
#define IMAGE_REL_MPPC_TOCINDIRCALL         0x0022
#define IMAGE_REL_MPPC_TOCCALLREL           0x0025
#define IMAGE_REL_MPPC_PCODECALL            0x0028
#define IMAGE_REL_MPPC_PCODECALLTONATIVE    0x0029
#define IMAGE_REL_MPPC_PCODENEPE            0x002A

#endif // _PPCIMAGE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\msgboxes2.inl ===
inline LPCTSTR VVCMsgText(CVCString &strBuffer, const int idsMsgFormat, va_list VarArguments)
{
	CVCString strMsgFormat;
	BOOL bOK = strMsgFormat.LoadString(idsMsgFormat);
	VSASSERT(bOK, "Failed to load string!  Are the resources initialized properly?");
	return VCSubstituteBytes(strBuffer, strMsgFormat, VarArguments);
}

inline LPCTSTR VCMsgText(CVCString &strBuffer, const int idsMsgFormat, ...)
{ 
	CVCString strMsgFormat;
	BOOL bOK = strMsgFormat.LoadString(idsMsgFormat);
	VSASSERT(bOK, "Failed to load string!  Are the resources initialized properly?");
	va_list VarArguments;
	va_start(VarArguments, idsMsgFormat);
	return VCSubstituteBytes(strBuffer, strMsgFormat, VarArguments);
}

inline LPCTSTR VCMsgText(CVCString &strBuffer, const CVCPath &pathOffendingFile, const int idsFileOperation)
{
	CVCString strOperation;
	BOOL bOK = strOperation.LoadString(idsFileOperation);
	VSASSERT(bOK, "Failed to load string!  Are the resources initialized properly?");
	return VCMsgText(strBuffer, pathOffendingFile, strOperation);
}

inline LPCOLESTR VVCMsgTextW(CStringW &strBuffer, const int idsMsgFormat, va_list VarArguments)
{
	CStringW strMsgFormat;
	BOOL bOK = strMsgFormat.LoadString(idsMsgFormat);
	VSASSERT(bOK, "Failed to load string!  Are the resources initialized properly?");
	return VCSubstituteBytesW(strBuffer, strMsgFormat, VarArguments);
}

inline LPCOLESTR VCMsgTextW(CStringW &strBuffer, const int idsMsgFormat, ...)
{ 
	CStringW strMsgFormat;
	BOOL bOK = strMsgFormat.LoadString(idsMsgFormat);
	VSASSERT(bOK, "Failed to load string!  Are the resources initialized properly?");
	va_list VarArguments;
	va_start(VarArguments, idsMsgFormat);
	return VCSubstituteBytesW(strBuffer, strMsgFormat, VarArguments);
}

inline LPCOLESTR VCMsgTextW(CStringW &strBuffer, const CPathW &pathOffendingFile, const int idsFileOperation)
{
	CStringW strOperation;
	BOOL bOK = strOperation.LoadString(idsFileOperation);
	VSASSERT(bOK, "Failed to load string!  Are the resources initialized properly?");
	return VCMsgTextW(strBuffer, pathOffendingFile, strOperation);
}

/************************** DLL Exported Function ***************************\
 SubstituteBytes()

 Purpose:	To construct a display string given a CString buffer, a format
 			string, and a va_list of substitution variables.

 Returns:	Constant pointer to the constructed string.

 Notes:		This function should *not* be called directly.  It is used by the
 			inline versions of the MsgText() functions to construct message
 			box string.  See the header file for details.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline LPCTSTR VCSubstituteBytes(CVCString &strBuffer, LPCTSTR pszFormat, va_list VarArguments)
{
// Get some space in the buffer...

    int cchBuffer = lstrlen(pszFormat) + MAX_SUBSTITUTION_BYTES;
    LPTSTR pszBuffer = strBuffer.GetBuffer(cchBuffer);

// ...and fill it.

	wvsprintf(pszBuffer, pszFormat, VarArguments);
	strBuffer.ReleaseBuffer();

	return strBuffer;
}

inline LPCOLESTR VCSubstituteBytesW(CStringW &strBuffer, LPCOLESTR pszFormat, va_list VarArguments)
{
// Get some space in the buffer...

    int cchBuffer = (int)wcslen(pszFormat) + MAX_SUBSTITUTION_BYTES*sizeof(wchar_t);
    LPOLESTR pszBuffer = strBuffer.GetBuffer(cchBuffer);

// ...and fill it.

	wvnsprintfW(pszBuffer, cchBuffer-1, pszFormat, VarArguments); // this API is not wrapped, but does existon Win9x with ie5
	strBuffer.ReleaseBuffer();

	return strBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\plex.h ===
// (KPerry) This was the MFC collection stuff
// Now it has been purged of all other MFC influences and is a stand alone entity.

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __VCPLEX_H__
#define __VCPLEX_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef AFX_COLL_SEG
#pragma code_seg(AFX_COLL_SEG)
#endif

struct CVCPlex     // warning variable length structure
{
	CVCPlex* pNext;
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CVCPlex* PASCAL Create(CVCPlex*& head, UINT_PTR nMax, UINT_PTR cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

#ifdef AFX_COLL_SEG
#pragma code_seg()
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif //__AFXPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\prjids.h ===
// this file contains the definitions for the project model IDs

// This ID range is reserved for vendor tools.  If it isn't big enough, then either make room for more 
// vendor tool IDs in the range or find a way to chunk in more reserved IDs in the project engine code.
#define VCVENDORTOOL_MIN_DISPID	 					5000
#define VCVENDORTOOL_MAX_DISPID						7499

// Project Engine Object
#define VCPROJECTENGINE_MIN_DISPID					200
#define VCPROJECTENGINE_MAX_DISPID					299

// this range is for stuff that appears in the build options page
#define BUILDOPTIONS_MIN_DISPID						200
#define BUILDOPTIONS_MAX_DISPID						205

#define PROJENGID_BuildLogging						200
#define PROJENGID_BuildTiming						201
#define PROJENGID_RedirectedOutputFile				202
#define PROJENGID_Platforms							210
#define PROJENGID_Projects							211
#define PROJENGID_StyleSheets						212
#define PROJENGID_CreateProject						213
#define PROJENGID_LoadProject						214
#define PROJENGID_RemoveProject						215
#define PROJENGID_Initialize						216
#define PROJENGID_LoadStyleSheet					217
#define PROJENGID_RemoveStyleSheet					218
#define PROJENGID_CreateStyleSheet					219
#define PROJENGID_PerformanceLogging				220
#define PROJENGID_LoadVBScriptProject				221
#define PROJENGID_IsSystemInclude					222
#define PROJENGID_CPPExtensions						223
#define PROJENGID_Events							224
#define PROJENGID_Evaluate							225

// Project Engine Events
#define ENGEVENTID_ItemAdded						275
#define ENGEVENTID_ItemRemoved						276
#define ENGEVENTID_ItemRenamed						277
#define ENGEVENTID_ItemMoved						278
#define ENGEVENTID_ItemPropertyChange				279
#define ENGEVENTID_SccEvent							280
#define ENGEVENTID_ReportError						281
#define ENGEVENTID_ProjectBuildStarted				282
#define ENGEVENTID_ProjectBuildFinished				283

// Build Engine Object
#define IVCBUILDENGINE_MIN_DISPID					300
#define IVCBUILDENGINE_MAX_DISPID					399

#define BLDENGID_SpawnerActive						300
#define BLDENGID_CanSpawnBuild						301
#define BLDENGID_UserStoppedBuild					302
#define BLDENGID_HaveLogging						303
#define BLDENGID_LogTrace							304
#define BLDENGID_CurrentLogSection					305
#define BLDENGID_FormCommandLine					306
#define BLDENGID_FormBatchFile						307
#define BLDENGID_FormTempFile						308
#define BLDENGID_FormXMLCommand						309					
#define BLDENGID_ExecuteCommandLines				310
#define BLDENGID_IncrementErrorCount				311
#define BLDENGID_IncrementWarningCount				312
#define BLDENGID_ErrorCount							313
#define BLDENGID_WarningCount						314
#define BLDENGID_IncrementProjectErrorCount			315
#define BLDENGID_IncrementProjectWarningCount		316
#define BLDENGID_AddMissingEnvVar					317
#define BLDENGID_ClearPending						318
#define BLDENGID_AddToOutputDirs					319
#define BLDENGID_StopBuild							320
#define BLDENGID_ReuseLogFile						321

// VC File Object, see also VCProjectItem
#define VCFILE_MIN_DISPID							400
#define VCFILE_MAX_DISPID							499

#define VCFILEID_FileConfigurations					400
#define VCFILEID_FullPath							401
#define VCFILEID_RelativePath						402
#define VCFILEID_Name								403
#define VCFILEID_Remove								404
#define VCFILEID_FileCodeModel						405
#define VCFILEID_DeploymentContent					406
#define VCFILEID_Extension							407
#define VCFILEID_Move								408
#define VCFILEID_CanMove							409

// File Configuration Object
#define VCFILECONFIGURATION_MIN_DISPID				500
#define VCFILECONFIGURATION_MAX_DISPID				599

#define VCFCFGID_Tool								500
#define VCFCFGID_ExcludedFromBuild					501
#define VCFCFGID_File								502
#define VCFCFGID_MatchName							510
#define VCFCFGID_Parent								511
#define VCFCFGID_Name								512
#define VCFCFGID_Evaluate							513
#define VCFCFGID_VCProjectEngine					514

// Style Sheet Object
#define VCSTYLESHEET_MIN_DISPID						600
#define VCSTYLESHEET_MAX_DISPID						649

#define VCSTYLEID_Name								600
#define VCSTYLEID_Platform							601
#define VCSTYLEID_PlatformName						602
#define VCSTYLEID_MatchName							603
#define VCSTYLEID_StyleSheetName					604
#define VCSTYLEID_StyleSheetFile					605
#define VCSTYLEID_IsDirty							606
#define VCSTYLEID_Tools								607
#define VCSTYLEID_FileTools							608
#define VCSTYLEID_ToolSet							609
#define VCSTYLEID_StyleSheets						610

// Generic Item Object
#define VCPROJECTITEM_MIN_DISPID					675
#define VCPROJECTITEM_MAX_DISPID					699

#define VCITMID_MatchName							675
#define VCITMID_Project								676
#define VCITMID_Parent								677
#define VCITMID_ItemName							678
#define VCITMID_Kind								679
#define VCITMID_VCProjectEngine						680

// Configuration Object
#define VCCONFIGURATION_MIN_DISPID					700
#define VCCONFIGURATION_MAX_DISPID					799

#define VCCFGID_ConfigurationName					700
#define VCCFGID_Project								701
#define VCCFGID_OutputDirectory						702
#define VCCFGID_IntermediateDirectory				703
#define VCCFGID_DeleteExtensionsOnClean				704
#define VCCFGID_Name								705
#define VCCFGID_Platform							706
#define VCCFGID_Tools								707
#define VCCFGID_FileTools							708
#define VCCFGID_Evaluate							709
#define VCCFGID_VCProjectEngine						710

#define VCCFGID_PrimaryOutput						721
#define VCCFGID_ImportLibrary						722
#define VCCFGID_ProgramDatabase						723
#define VCCFGID_Delete								724
#define VCCFGID_Build								725
#define VCCFGID_Rebuild								726
#define VCCFGID_Clean								727
#define VCCFGID_DebugSettings						728
#define VCCFGID_MatchName							729
#define VCCFGID_GeneralSettings						730
#define VCCFGID_UpToDate							731
#define VCCFGID_ConfigurationType					732
#define VCCFGID_CopyTo								733
#define VCCFGID_AppliedStyleSheets					734
#define VCCFGID_BuildBrowserInformation				735
#define VCCFGID_UseOfMFC							736
#define VCCFGID_UseOfATL							737
#define VCCFGID_ATLMinimizesCRunTimeLibraryUsage	738
#define VCCFGID_CharacterSet						739
#define VCCFGID_ManagedExtensions					740	
#define VCCFGID_WholeProgramOptimization			741
#define VCCFGID_RegisterOutput						742
#define VCCFGID_StyleSheets							743
#define VCCFGID_IntrinsicAppliedStyleSheets			744		// virtual prop: list of intrinsic applied style sheets present
#define VCCFGID_AllOutputsDirty						745		// virtual prop; have we already dirtied the command line outputs for the build?
#define VCCFGID_PrimaryOutputDirty					746		// virtual prop; have we already dirtied the primary output (or def extension)?
#define VCCFGID_AnyOutputDirty						747		// virtual prop; has any tool at any level dirtied its output since the last build?
#define VCCFGID_AnyToolDirty						748		// virtual prop; has any tool at any level been dirtied since the last build?
#define VCCFGID_DirtyDuringBuild					749		// virtual prop; are we dirtying any tool at any level during a build?

// Project Object
#define VCPROJECT_MIN_DISPID						800
#define VCPROJECT_MAX_DISPID						899

#define VCPROJID_ProjectType						801
#define VCPROJID_ProjectDirectory					802
#define VCPROJID_AddFile							803
#define VCPROJID_CanAddFile							804
#define VCPROJID_AddConfiguration					805
#define VCPROJID_RemoveFile							806
#define VCPROJID_Files								807
#define VCPROJID_Configurations						808
#define VCPROJID_Save								809
#define VCPROJID_MoveInto							810
#define VCPROJID_AddPlatform						811
#define VCPROJID_RemovePlatform						812
#define VCPROJID_RemoveFilter						813
#define VCPROJID_AddFilter							814
#define VCPROJID_CanAddFilter						815
#define VCPROJID_ProjectFile						816
#define VCPROJID_DeleteConfiguration				817
#define VCPROJID_Filters							818
#define VCPROJID_IsDirty							819
#define VCPROJID_SaveProjectOptions					820
#define VCPROJID_LoadProjectOptions					821
#define VCPROJID_Platforms							822
#define VCPROJID_RemoveConfiguration				823
#define VCPROJID_FileFormat							824
#define VCPROJID_Items								825
#define VCPROJID_AddWebRef							826
#define VCPROJID_FileEncoding						827
#define VCPROJID_VCProjectEngine					828

#define VCPROJID_Name								840

#define VCPROJID_SccProjectName						850
#define VCPROJID_SccAuxPath							851
#define VCPROJID_SccLocalPath						852
#define VCPROJID_SccProvider						853

#define VCPROJID_Keyword							855

#define VCPROJID_Object								864
#define VCEXEPRJID_Object							865

#define VCPROJID_OwnerKey							866
#define VCPROJID_ProjectGUID							867

// C/C++ compiler (general)
// NOTE: If the range of dispids goes beyond VCCLCOMPILERTOOL_MAX_DISPID, keep it updated.
#define VCCLCOMPILERTOOL_MIN_DISPID					2000
#define VCCLCOMPILERTOOL_MAX_DISPID					2999

// C/C++ compiler, General
#define CLGENERAL_MIN_DISPID						2000	// MIN/MAX used for property page ranges
#define CLGENERAL_MAX_DISPID						2029

#define VCCLID_ToolName								2000
#define VCCLID_AdditionalOptions					2001
#define VCCLID_VCProjectEngine						2002

#define VCCLID_AdditionalIncludeDirectories			2010
#define VCCLID_AdditionalUsingDirectories			2011
#define VCCLID_DebugInformationFormat				2012
#define VCCLID_CompileAsManaged						2013
#define VCCLID_SuppressStartupBanner				2014
#define VCCLID_WarningLevel							2015
#define VCCLID_Detect64BitPortabilityProblems		2016
#define VCCLID_WarnAsError							2017
#define VCCLID_CompileOnly							2018

// C/C++ compiler, Optimization
#define CLOPTIMIZATION_MIN_DISPID					2030	// MIN/MAX used for property page ranges
#define CLOPTIMIZATION_MAX_DISPID					2059

#define VCCLID_Optimization							2030
#define VCCLID_GlobalOptimizations					2031
#define VCCLID_InlineFunctionExpansion				2032
#define VCCLID_EnableIntrinsicFunctions				2033
#define VCCLID_ImproveFloatingPointConsistency		2034
#define VCCLID_FavorSizeOrSpeed						2035
#define VCCLID_OmitFramePointers					2036
#define VCCLID_EnableFiberSafeOptimizations			2037
#define VCCLID_WholeProgramOptimization				2038	// not on the page; set via general cfg page
#define VCCLID_OptimizeForProcessor					2039
#define VCCLID_OptimizeForWindowsApplication		2040

// C/C++ compiler, Preprocessor
#define CLPREPROCESS_MIN_DISPID						2060	// MIN/MAX used for property page ranges
#define CLPREPROCESS_MAX_DISPID						2079

#define VCCLID_PreprocessorDefinitions				2060
#define VCCLID_IgnoreStandardIncludePath			2061
#define VCCLID_GeneratePreprocessedFile				2062
#define VCCLID_KeepComments							2063

// C/C++ Compiler, Advanced
#define CLADV_MIN_DISPID							2080	// MIN/MAX used for property page ranges
#define CLADV_MAX_DISPID							2109

#define VCCLID_CallingConvention					2080
#define VCCLID_CompileFileAs						2081
#define VCCLID_CompileAs							2082
#define VCCLID_DisableSpecificWarnings				2083
#define VCCLID_ForcedIncludeFiles					2084
#define VCCLID_ForcedUsingFiles						2085
#define VCCLID_ShowIncludes							2086
#define VCCLID_UndefinePreprocessorDefinitions		2087
#define VCCLID_UndefineAllPreprocessorDefinitions	2088

// C/C++ compiler, Code Generation
#define CLCODEGEN_MIN_DISPID						2120	// MIN/MAX used for property page ranges
#define CLCODEGEN_MAX_DISPID						2139

#define VCCLID_StringPooling						2120
#define VCCLID_MinimalRebuild						2121
#define VCCLID_ExceptionHandling					2122
#define VCCLID_SmallerTypeCheck						2123
#define VCCLID_BasicRuntimeChecks					2124
#define VCCLID_RuntimeLibrary						2125
#define VCCLID_StructMemberAlignment				2126
#define VCCLID_BufferSecurityCheck					2127
#define VCCLID_EnableFunctionLevelLinking			2128

// C/C++ compiler, Language
#define CLLANG_MIN_DISPID							2140	// MIN/MAX used for property page ranges
#define CLLANG_MAX_DISPID							2159

#define VCCLID_DisableLanguageExtensions			2140
#define VCCLID_DefaultCharIsUnsigned				2141
#define VCCLID_TreatWChar_tAsBuiltInType			2142
#define VCCLID_ForceConformanceInForLoopScope		2143
#define VCCLID_RuntimeTypeInfo						2144

// C/C++ compiler, Precompiled Headers
#define CLPCH_MIN_DISPID							2160	// MIN/MAX used for property page ranges
#define CLPCH_MAX_DISPID							2169

#define VCCLID_UsePrecompiledHeader					2161
#define VCCLID_PrecompiledHeaderThrough				2162
#define VCCLID_PrecompiledHeaderFile				2163

// C/C++ compiler, Output Files
#define CLOUTPUT_MIN_DISPID							2170	// MIN/MAX used for property page ranges
#define CLOUTPUT_MAX_DISPID							2179

#define VCCLID_ExpandAttributedSource				2170
#define VCCLID_AssemblerOutput						2171
#define VCCLID_AssemblerListingLocation				2172
#define VCCLID_ObjectFile							2173
#define VCCLID_ProgramDataBaseFileName				2174

// C/C++ compiler (general), Browse info helpers
#define CLBROWSE_MIN_DISPID							2180	// MIN/MAX used for property page ranges
#define CLBROWSE_MAX_DISPID							2189

#define VCCLID_BrowseInformation					2181
#define VCCLID_BrowseInformationFile				2182

// C/C++ compiler (general), Automation properties
#define VCCLID_ToolPath								2220
#define VCCLID_PropertyOption						2221
#define VCCLID_FullIncludePath						2222
#define VCCLID_CmdLineOptionsDirty					2223	// virtual prop; have we already dirtied the command line for this tool?
#define VCCLID_OutputsDirty							2224	// virtual prop; have we already dirtied the outputs for this tool?
#define VCCLID_ResolvedPdbName						2225	// virtual prop; keep this in sync with pdb file name


// Linker Tool
// NOTE: If the range of dispids goes beyond VCLINKERTOOL_MAX_DISPID, keep it updated.
#define VCLINKERTOOL_MIN_DISPID						3000
#define VCLINKERTOOL_MAX_DISPID						3299

// Linker Tool, General
#define LINKGENERAL_MIN_DISPID						3000	// MIN/MAX used for property page ranges
#define LINKGENERAL_MAX_DISPID						3019

#define VCLINKID_ToolName							3000
#define VCLINKID_AdditionalOptions					3001
#define VCLINKID_OutputFile							3002
#define VCLINKID_ShowProgress						3003
#define VCLINKID_Version							3004
#define VCLINKID_LinkIncremental					3005
#define VCLINKID_SuppressStartupBanner				3006
#define VCLINKID_IgnoreImportLibrary				3007
#define VCLINKID_RegisterOutput						3008
#define VCLINKID_AdditionalLibraryDirectories		3009

// Linker Tool, Input
#define LINKINPUT_MIN_DISPID						3020	// MIN/MAX used for property page ranges
#define LINKINPUT_MAX_DISPID						3039

#define VCLINKID_AdditionalDependencies				3020
#define VCLINKID_IgnoreAllDefaultLibraries			3021
#define VCLINKID_IgnoreDefaultLibraryNames			3022
#define VCLINKID_ModuleDefinitionFile				3023
#define VCLINKID_AddModuleNamesToAssembly			3024
#define VCLINKID_EmbedManagedResourceFile			3025
#define VCLINKID_ForceSymbolReferences				3026
#define VCLINKID_DelayLoadDLLs						3127
#define VCLINKID_LinkDLL							3028
#define VCLINKID_DependentInputs					3029	// virtual prop; additional inputs picked up via project dependencies

// Linker Tool, MIDL
#define LINKMIDL_MIN_DISPID							3040	// MIN/MAX used for property page ranges
#define LINKMIDL_MAX_DISPID							3049

#define VCLINKID_MidlCommandFile					3040
#define VCLINKID_IgnoreEmbeddedIDL					3041
#define VCLINKID_MergedIDLBaseFileName				3042
#define VCLINKID_TypeLibraryFile					3043
#define VCLINKID_TypeLibraryResourceID				3044

// Linker Tool, Debug
#define LINKDEBUG_MIN_DISPID						3050	// MIN/MAX used for property page ranges
#define LINKDEBUG_MAX_DISPID						3059

#define VCLINKID_GenerateDebugInformation			3050
#define VCLINKID_ProgramDatabaseFile				3051
#define VCLINKID_StripPrivateSymbols				3052
#define VCLINKID_GenerateMapFile					3053
#define VCLINKID_MapFileName						3054
#define VCLINKID_MapExports							3055
#define VCLINKID_MapLines							3056

// Linker Tool, System
#define LINKSYSTEM_MIN_DISPID						3065	// MIN/MAX used for property page ranges
#define LINKSYSTEM_MAX_DISPID						3079

#define VCLINKID_SubSystem							3065
#define VCLINKID_HeapReserveSize					3066
#define VCLINKID_HeapCommitSize						3067
#define VCLINKID_StackReserveSize					3068
#define VCLINKID_StackCommitSize					3069
#define VCLINKID_LargeAddressAware					3070
#define VCLINKID_TerminalServerAware				3071
#define VCLINKID_SwapRunFromCD						3072
#define VCLINKID_SwapRunFromNet						3073

// Linker Tool, Optimization
#define LINKOPTIMIZATION_MIN_DISPID					3080	// MIN/MAX used for property page ranges
#define LINKOPTIMIZATION_MAX_DISPID					3099

#define VCLINKID_OptimizeReferences					3080
#define VCLINKID_EnableCOMDATFolding				3081
#define VCLINKID_OptimizeForWindows98				3082
#define VCLINKID_FunctionOrder						3083
#define VCLINKID_LinkTimeCodeGeneration				3084	// not on the page; set via cfg general page

// Linker Tool, Advanced
#define LINKADVANCED_MIN_DISPID						3100	// MIN/MAX used for property page ranges
#define LINKADVANCED_MAX_DISPID						3129

#define VCLINKID_EntryPointSymbol					3100
#define VCLINKID_ResourceOnlyDLL					3101
#define VCLINKID_SetChecksum						3102
#define VCLINKID_BaseAddress						3103
#define VCLINKID_TurnOffAssemblyGeneration			3104
#define VCLINKID_SupportUnloadOfDelayLoadedDLL		3105
#define VCLINKID_ImportLibrary						3106
#define VCLINKID_MergeSections						3107
#define VCLINKID_TargetMachine						3108

// Linker Tool, Automation properties
#define VCLINKID_ToolPath							3120
#define VCLINKID_PropertyOption						3121
#define VCLINKID_VCProjectEngine					3122
#define VCLINKID_CmdLineOptionsDirty				3123	// virtual prop; have we already dirtied the command line for this tool?
#define VCLINKID_OutputsDirty						3124	// virtual prop; have we already dirtied the outputs for this tool?
#define VCLINKID_LinkerCommandLineGenerated			3125	// virtual prop; has this linker command line ever been generated (this IDE session?)

// Library Tool
// NOTE: If the range of dispids goes beyond VCLIBRARIANTOOL_MAX_DISPID, keep it updated.
#define VCLIBRARIANTOOL_MIN_DISPID					3300
#define VCLIBRARIANTOOL_MAX_DISPID					3499

// Library Tool, General
#define LIBGENERAL_MIN_DISPID						3300	// MIN/MAX used for property page ranges
#define LIBGENERAL_MAX_DISPID						3319

#define VCLIBID_ToolName							3300
#define VCLIBID_AdditionalOptions					3301
#define VCLIBID_OutputFile							3302
#define VCLIBID_AdditionalDependencies				3303
#define VCLIBID_AdditionalLibraryDirectories		3304
#define VCLIBID_SuppressStartupBanner				3305
#define VCLIBID_ModuleDefinitionFile				3306
#define VCLIBID_IgnoreAllDefaultLibraries			3307
#define VCLIBID_IgnoreDefaultLibraryNames			3308
#define VCLIBID_ExportNamedFunctions				3309
#define VCLIBID_ForceSymbolReferences				3310
#define VCLIBID_DependentInputs						3311	// virtual prop; additional inputs picked up via project dependencies

// Library Tool, Automation properties
#define VCLIBID_ToolPath							3340
#define VCLIBID_PropertyOption						3341
#define VCLIBID_VCProjectEngine						3342
#define VCLIBID_CmdLineOptionsDirty					3343	// virtual prop; have we already dirtied the command line for this tool?
#define VCLIBID_OutputsDirty						3344	// virtual prop; have we already dirtied the outputs for this tool?
#define VCLIBID_LibCommandLineGenerated				3345	// virtual prop; has this librarian command line ever been generated (this IDE session?)

// MIDL Tool
// NOTE: If the range of dispids goes beyond VCMIDLTOOL_MAX_DISPID, keep it updated.
#define VCMIDLTOOL_MIN_DISPID						3500
#define VCMIDLTOOL_MAX_DISPID						3899

// MIDL Tool, General
#define MIDLGENERAL_MIN_DISPID						3500	// MIN/MAX used for property page ranges
#define MIDLGENERAL_MAX_DISPID						3529

#define VCMIDLID_ToolName							3500
#define VCMIDLID_AdditionalOptions					3501
#define VCMIDLID_PreprocessorDefinitions			3502
#define VCMIDLID_AdditionalIncludeDirectories		3503
#define VCMIDLID_IgnoreStandardIncludePath			3504
#define VCMIDLID_MkTypLibCompatible					3505
#define VCMIDLID_WarningLevel						3506
#define VCMIDLID_WarnAsError						3507
#define VCMIDLID_SuppressStartupBanner				3508
#define VCMIDLID_DefaultCharType					3509
#define VCMIDLID_TargetEnvironment 					3510
#define VCMIDLID_GenerateStublessProxies			3511

// MIDL Tool, Output 
#define MIDLOUTPUT_MIN_DISPID						3530	// MIN/MAX used for property page ranges
#define MIDLOUTPUT_MAX_DISPID						3549

#define VCMIDLID_OutputDirectory					3530
#define VCMIDLID_HeaderFileName						3531
#define VCMIDLID_DLLDataFileName					3532
#define VCMIDLID_InterfaceIdentifierFileName		3533
#define VCMIDLID_ProxyFileName						3534
#define VCMIDLID_GenerateTypeLibrary				3535
#define VCMIDLID_TypeLibraryName					3536

// MIDL Tool, Advanced
#define MIDLADVANCED_MIN_DISPID						3550	// MIN/MAX used for property page ranges
#define MIDLADVANCED_MAX_DISPID						3589

#define VCMIDLID_EnableErrorChecks					3550
#define VCMIDLID_ErrorCheckAllocations				3551
#define VCMIDLID_ErrorCheckBounds					3552
#define VCMIDLID_ErrorCheckEnumRange				3553
#define VCMIDLID_ErrorCheckRefPointers				3554
#define VCMIDLID_ErrorCheckStubData					3555
#define VCMIDLID_ValidateParameters					3556
#define VCMIDLID_StructMemberAlignment				3557
#define VCMIDLID_RedirectOutputAndErrors			3558
#define VCMIDLID_CPreprocessOptions					3559
#define VCMIDLID_UndefinePreprocessorDefinitions	3560

// MIDL Tool, Automation properties
#define VCMIDLID_ToolPath							3570
#define VCMIDLID_PropertyOption						3571
#define VCMIDLID_FullIncludePath					3572
#define VCMIDLID_VCProjectEngine					3573
#define VCMIDLID_CmdLineOptionsDirty				3574	// virtual prop; have we already dirtied the command line for this tool?
#define VCMIDLID_OutputsDirty						3575	// virtual prop; have we already dirtied the outputs for this tool?

// Resource Compiler Tool
// NOTE: If the range of dispids goes beyond VCRCTOOL_MAX_DISPID, keep it updated.
#define VCRCTOOL_MIN_DISPID							3900
#define VCRCTOOL_MAX_DISPID							3999

// Resource Compiler Tool, General
#define VCRCID_ToolName								3900
#define VCRCID_AdditionalOptions					3901
#define VCRCID_PreprocessorDefinitions				3902
#define VCRCID_Culture								3903
#define VCRCID_AdditionalIncludeDirectories			3904
#define VCRCID_IgnoreStandardIncludePath			3905
#define VCRCID_ShowProgress							3906
#define VCRCID_ResourceOutputFileName				3907

// Resource Compiler Tool, Automation
#define VCRCID_ToolPath								3920
#define VCRCID_PropertyOption						3921
#define VCRCID_FullIncludePath						3922
#define VCRCID_VCProjectEngine						3923
#define VCRCID_CmdLineOptionsDirty					3924	// virtual prop; have we already dirtied the command line for this tool?
#define VCRCID_OutputsDirty							3925	// virtual prop; have we already dirtied the outputs for this tool?

// BSCMake Tool
// NOTE: If the range of dispids goes beyond VCBSCMAKETOOL_MAX_DISPID, keep it updated.
#define VCBSCMAKETOOL_MIN_DISPID					4000
#define VCBSCMAKETOOL_MAX_DISPID					4099

// BSCMake Tool, General
#define VCBSCID_ToolName							4000
#define VCBSCID_AdditionalOptions					4001
#define VCBSCID_SuppressStartupBanner				4002
#define VCBSCID_OutputFile							4003
#define VCBSCID_RunBSCMakeTool						4004	// not in UI

// BSCMake Tool, Automation
#define VCBSCID_ToolPath							4020
#define VCBSCID_PropertyOption						4021
#define VCBSCID_VCProjectEngine						4022
#define VCBSCID_CmdLineOptionsDirty					4023	// virtual prop; have we already dirtied the command line for this tool?
#define VCBSCID_OutputsDirty						4024	// virtual prop; have we already dirtied the outputs for this tool?

// Custom Build Tool
// NOTE: If the range of dispids goes beyond VCCUSTOMBUILDTOOL_MAX_DISPID, keep it updated.
// Note 2: Assuming that the range of IDs we need to watch ranges between that for the command line and that for the inputs.
// If that changes, update the implementation code in CreateInstance.
#define VCCUSTOMBUILDTOOL_MIN_DISPID				4100
#define VCCUSTOMBUILDTOOL_MAX_DISPID				4199

// these are for the project configuration level
#define VCCUSTID_ToolName							4101
#define VCCUSTID_CommandLine						4102
#define VCCUSTID_Description						4103
#define VCCUSTID_Outputs							4104
#define VCCUSTID_AdditionalDependencies				4105
#define VCCUSTID_ToolPath							4106
#define VCCUSTID_CmdLineOptionsDirty				4107	// virtual prop; have we already dirtied the command line for this tool?
#define VCCUSTID_OutputsDirty						4108	// virtual prop; have we already dirtied the outputs for this tool?
#define VCCUSTID_FileLevelOffset					  30	// storage offset for file level props; no helpstring
#define VCCUSTID_VCProjectEngine					4109

// these are for the file configuration level
// NOTE: these are 'phantom' IDs, i.e., they exist for storage *only*.  
// They MUST remain at constant offset from the project configuration level IDs
// Use the IDs for the project configuration level for help, etc.

// this range is for checking if a dispid is a file level custom build step
// ONLY (kludge so that we can get info on these dispids out of the typelib)
// if the layout of the custom build dispids changes THESE MUST ALSO CHANGE
#define VCFILECUSTOMBUILDTOOL_MIN_DISPID			VCCUSTID_ToolName + VCCUSTID_FileLevelOffset
#define VCFILECUSTOMBUILDTOOL_MAX_DISPID			VCCUSTID_OutputsDirty + VCCUSTID_FileLevelOffset

#define VCFCSTID_ToolName							VCCUSTID_ToolName + VCCUSTID_FileLevelOffset
#define VCFCSTID_CommandLine						VCCUSTID_CommandLine + VCCUSTID_FileLevelOffset
#define VCFCSTID_Description						VCCUSTID_Description + VCCUSTID_FileLevelOffset
#define VCFCSTID_Outputs							VCCUSTID_Outputs + VCCUSTID_FileLevelOffset
#define VCFCSTID_AdditionalDependencies				VCCUSTID_AdditionalDependencies + VCCUSTID_FileLevelOffset
#define VCFCSTID_ToolPath							VCCUSTID_ToolPath + VCCUSTID_FileLevelOffset
#define VCFCSTID_CmdLineOptionsDirty				VCCUSTID_CmdLineOptionsDirty + VCCUSTID_FileLevelOffset
#define VCFCSTID_OutputsDirty						VCCUSTID_OutputsDirty + VCCUSTID_FileLevelOffset

// Note about IDs: an implementation assumption is being made that the low ID to watch is that for the command line
// and the high ID to watch is that for excluded from build.  If this changes, you will need to modify the base
// template implementation for the tool so that dirties happen correctly

// Pre-Build Event Tool
// NOTE: If the range of dispids goes beyond VCPREBLDEVENTTOOL_MAX_DISPID, keep it updated.
#define VCPREBLDEVENTTOOL_MIN_DISPID				4200
#define VCPREBLDEVENTTOOL_MAX_DISPID				4249

// Pre-Build Event Tool
#define PREBLDID_ToolName							4200
#define PREBLDID_CommandLine						4201
#define PREBLDID_Description						4202
#define PREBLDID_ExcludedFromBuild					4203
#define PREBLDID_ToolPath							4204
#define PREBLDID_VCProjectEngine					4205
#define PREBLDID_CmdLineOptionsDirty				4206	// virtual prop; have we already dirtied the command line for this tool?

// Pre-Link Event Tool
// NOTE: If the range of dispids goes beyond VCPRELINKEVENTTOOL_MAX_DISPID, keep it updated.
#define VCPRELINKEVENTTOOL_MIN_DISPID				4250
#define VCPRELINKEVENTTOOL_MAX_DISPID				4299

// Pre-Link Event Tool
#define PRELINKID_ToolName							4250
#define PRELINKID_CommandLine						4251
#define PRELINKID_Description						4252
#define PRELINKID_ExcludedFromBuild					4253
#define PRELINKID_ToolPath							4254
#define PRELINKID_VCProjectEngine					4255
#define PRELINKID_CmdLineOptionsDirty				4256	// virtual prop; have we already dirtied the command line for this tool?

// Post-Build Event Tool
// NOTE: If the range of dispids goes beyond VCPOSTBLDEVENTTOOL_MAX_DISPID, keep it updated.
#define VCPOSTBLDEVENTTOOL_MIN_DISPID				4300
#define VCPOSTBLDEVENTTOOL_MAX_DISPID				4349

// Pre-Build Event Tool
#define POSTBLDID_ToolName							4300
#define POSTBLDID_CommandLine						4301
#define POSTBLDID_Description						4302
#define POSTBLDID_ExcludedFromBuild					4303
#define POSTBLDID_ToolPath							4304
#define POSTBLDID_VCProjectEngine					4305
#define POSTBLDID_CmdLineOptionsDirty				4306	// virtual prop; have we already dirtied the command line for this tool?

// NMake Tool
// NOTE: If the range of dispids goes beyond VCNMAKETOOL_MAX_DISPID, keep it updated.
#define VCNMAKETOOL_MIN_DISPID						4400
#define VCNMAKETOOL_MAX_DISPID						4499

// these are for the project configuration level
#define VCNMAKEID_ToolName							4401
#define VCNMAKEID_BuildCommandLine					4402
#define VCNMAKEID_ReBuildCommandLine				4403
#define VCNMAKEID_CleanCommandLine					4404
#define VCNMAKEID_Output							4405
#define VCNMAKEID_ToolPath							4406
#define VCNMAKEID_VCProjectEngine					4407
#define VCNMAKEID_CmdLineOptionsDirty				4408	// virtual prop; have we already dirtied the command line for this tool?
#define VCNMAKEID_OutputsDirty						4409	// virtual prop; have we already dirtied the outputs for this tool?


// Web Service Proxy Generator Tool
// NOTE: If the range of dispids goes beyond VCWEBTOOL_MAX_DISPID, keep it updated.
#define VCWEBTOOL_MIN_DISPID						4500
#define VCWEBTOOL_MAX_DISPID						4599	
#define VCWEBID_ToolName							4501
#define VCWEBID_Output								4502
#define VCWEBID_SuppressStartupBanner				4503
#define VCWEBID_GeneratedProxyLanguage				4504
#define VCWEBID_AdditionalOptions					4505
#define VCWEBID_URL									4506
#define VCWEBID_ToolPath							4507
#define VCWEBID_PropertyOption						4508
#define VCWEBID_VCProjectEngine						4509
#define VCWEBID_CmdLineOptionsDirty					4517	// virtual prop; have we already dirtied the command line for this tool?
#define VCWEBID_OutputsDirty						4518	// virtual prop; have we already dirtied the outputs for this tool?

// Web Deployment Tool
// NOTE: If the range of dispids goes beyond VCDPLYTOOL_MAX_DISPID, keep it updated.
#define VCDPLYTOOL_MIN_DISPID						4600
#define VCDPLYTOOL_MAX_DISPID						4699
#define VCDPLYID_ToolName							4600	
#define VCDPLYID_ExcludedFromBuild					4601	
#define VCDPLYID_RelativePath						4602	
#define VCDPLYID_AdditionalFiles					4603	
#define VCDPLYID_UnloadBeforeCopy					4604	
#define VCDPLYID_RegisterOutput						4605	
#define VCDPLYID_VirtualDirectoryName				4606	
#define VCDPLYID_ApplicationMappings				4607	
#define VCDPLYID_ApplicationProtection				4608	
#define VCDPLYID_ToolPath							4609	
#define VCDPLYID_PropertyOption						4610	
#define VCDPLYID_VCProjectEngine					4611	
#define VCDPLYID_CmdLineOptionsDirty				4612	// virtual prop; have we already dirtied the command line for this tool?	

// Xbox Deployment Tool
// NOTE: If the range of dispids goes beyond XBOXVCDPLYTOOL_MAX_DISPID, keep it updated.
#define XBOXVCDPLYTOOL_MIN_DISPID					4700
#define XBOXVCDPLYTOOL_MAX_DISPID					4799
#define XBOXDPLYID_ToolName							4700	
#define XBOXDPLYID_ExcludedFromBuild				4701	
#define XBOXDPLYID_RemotePath						4702	
#define XBOXDPLYID_AdditionalFiles					4703
// Gap...	
#define XBOXDPLYID_ToolPath							4709	
#define XBOXDPLYID_PropertyOption					4710	
#define XBOXDPLYID_VCProjectEngine					4711	
#define XBOXDPLYID_CmdLineOptionsDirty				4712	// virtual prop; have we already dirtied the command line for this tool?	

// Xbox Image Tool
// NOTE: If the range of dispids goes beyond XBOXVCDPLYTOOL_MAX_DISPID, keep it updated.
#define XBOXIMAGETOOL_MIN_DISPID					4800
#define XBOXIMAGETOOL_MAX_DISPID					4899

// Xbox Image Tool, General
#define XBOXIMAGEGENERAL_MIN_DISPID					4800	// MIN/MAX used for property page ranges
#define XBOXIMAGEGENERAL_MAX_DISPID					4824
#define XBOXIMAGEID_ToolName						4800	
#define XBOXIMAGEID_AdditionalOptions				4801	
#define XBOXIMAGEID_FileName						4802	
#define XBOXIMAGEID_XBEFlags						4803	
#define XBOXIMAGEID_StackSize						4804	
#define XBOXIMAGEID_IncludeDebugInfo				4805	
#define XBOXIMAGEID_LimitAvailableMemoryTo64MB		4806	

// Xbox Image Tool, Certificate
#define XBOXIMAGECERTIFICATE_MIN_DISPID				4825	// MIN/MAX used for property page ranges
#define XBOXIMAGECERTIFICATE_MAX_DISPID				4849
#define XBOXIMAGEID_TitleID							4825	
#define XBOXIMAGEID_XboxGameRegion					4826	
#define XBOXIMAGEID_XboxGameRating					4827	

// Xbox Image Tool, Title Info
#define XBOXIMAGETITLEINFO_MIN_DISPID				4850	// MIN/MAX used for property page ranges
#define XBOXIMAGETITLEINFO_MAX_DISPID				4874
#define XBOXIMAGEID_TitleInfo						4850	
#define XBOXIMAGEID_TitleName						4851	
#define XBOXIMAGEID_TitleImage						4852	
#define XBOXIMAGEID_SaveGameImage					4853	

// Xbox Image Tool, Automation properties
#define XBOXIMAGEID_ToolPath						4875
#define XBOXIMAGEID_PropertyOption					4899
#define XBOXIMAGEID_VCProjectEngine					4875
#define XBOXIMAGEID_CmdLineOptionsDirty				4876	// virtual prop; have we already dirtied the command line for this tool?
#define XBOXIMAGEID_OutputsDirty					4877	// virtual prop; have we already dirtied the outputs for this tool?
#define XBOXIMAGEID_ImageCommandLineGenerated		4878	// virtual prop; has this image command line ever been generated (this IDE session?)

// VC Build Platform Properties, File Node
#define VCFILENODID_Name							7510	
#define VCFILENODID_FullPath						7511
#define VCFILENODID_RelativePath					7512
#define VCFILENODID_DeploymentContent				7513
#define VCFILENODID_Object							7514
#define VCFILENODID_Extender						7515
#define VCFILENODID_ExtenderNames					7516
#define VCFILENODID_ExtenderCATID					7517

// VC Build Platform Properties, Folder Node
#define VCFOLDNODID_Name							7530	
#define VCFOLDNODID_Filter							7531
#define VCFOLDNODID_Object							7532
#define VCFOLDNODID_ParseFiles						7533
#define VCFOLDNODID_SourceControlFiles				7534
#define VCFOLDNODID_Extender						7535
#define VCFOLDNODID_ExtenderNames					7536
#define VCFOLDNODID_ExtenderCATID					7537
#define IDS_ADVANCEDCAT								7538

// VC Build Platform Properties, Folder Node
#define VCPRJNODID_Name								7550	
#define VCPRJNODID_ProjectFile						7551
#define VCPRJNODID_ProjectDependencies				7552
#define VCPRJNODID_Object							7553
#define VCPRJNODID_Extender							7554
#define VCPRJNODID_ExtenderNames					7555
#define VCPRJNODID_ExtenderCATID					7556

// DIANEME_TODO: dead ID placeholders -- starts at 8000

//VCPB Miscellaneous Tools 
//NOTE: if the range of dispids goes beyond VCPBINTERFACES_MAX_DISPID, keep it updated
#define VCPBINTERFACES_MIN_DISPID					12000
#define VCPBINTERFACES_MAX_DISPID					12200

//VCPB Collections
#define VCCOLLID__NewEnum							12000
#define VCCOLLID_Item								12001
#define VCCOLLID_Count								12002
#define VCCOLLID_VCProjectEngine					12003

//VCPB Platform
#define VCPLATFORM_MIN_DISPID						12010
#define VCPLATFORM_MAX_DISPID						12019

#define VCPLATID_ExecutableDirectories				12010
#define VCPLATID_IncludeDirectories					12011
#define VCPLATID_ReferenceDirectories				12012
#define VCPLATID_LibraryDirectories					12013
#define VCPLATID_SourceDirectories					12014
#define VCPLATID_Name								12015
#define VCPLATID_Tools								12016
#define VCPLATID_MatchName							12017
#define VCPLATID_VCProjectEngine					12018
#define VCPLATID_Evaluate							12019

//VCPB Debug Settings
#define VCDEBUG_MIN_DISPID							12020
#define VCDEBUG_MAX_DISPID							12039

#define VCDSID_Command								12020
#define VCDSID_WorkingDirectory						12021
#define VCDSID_CommandArguments						12022
#define VCDSID_DebuggerType							12023
#define VCDSID_Attach								12024
#define VCDSID_Remote								12025
#define	VCDSID_RemoteCommand						12026
#define	VCDSID_RemoteMachine						12027
#define VCDSID_HttpUrl								12028
#define VCDSID_PDBPath								12029
#define VCDSID_BaseCommand							12030		// this is a fake prop for storing the path to an exe project
#define VCDSID_SQLDebugging							12031
// Leave 12032-12039 for more debug settings

//VCPB Filter, see also VCProjectItem
#define VCFLTID_Filter								12041
#define VCFLTID_Name								12042
#define VCFLTID_CanonicalName                       12043
#define VCFLTID_UniqueIdentifier                    12044
#define VCFLTID_AddFilter							12045
#define VCFLTID_CanAddFilter						12046
#define VCFLTID_RemoveFilter                        12047
#define VCFLTID_AddFile								12048
#define VCFLTID_CanAddFile							12049
#define VCFLTID_RemoveFile							12050
#define VCFLTID_Delete								12051
#define VCFLTID_MatchName							12052
#define VCFLTID_Filters								12053
#define VCFLTID_Files								12054
#define VCFLTID_Items								12055
#define VCFLTID_ParseFiles							12056
#define VCFLTID_SourceControlFiles					12057
#define VCFLTID_AddWebRef							12058
#define VCFLTID_Move								12059
#define VCFLTID_CanMove								12060

//VCPB Debug Enums
#define	VCDSID_RemoteLocal							12070
#define	VCDSID_RemoteDCOM							12071
#define	VCDSID_RemoteTCPIP							12072
#define VCDSID_TypeNativeOnly						12073
#define VCDSID_TypeManagedOnly						12074
#define VCDSID_TypeMixed							12075
#define VCDSID_TypeAuto								12076
#define	VCDSID_Command_IExplore						12077
#define	VCDSID_Command_ATLTest						12078
#define	VCDSID_Command_RegSvr                       12079
#define VCDSID_Command_Browse                       12080
// Leave 12081-12099 for more debug enums


// TypeDef Enumerators
// NOTE: if the range of dispids goes beyond VCTDENUM_MAX_DISPID, keep it updated.
#define VCTDENUM_MIN_DISPID							13000
#define VCTDENUM_MAX_DISPID							14999

// C/C++ Compiler 
// typedef enum optimizeOption
#define VCTDENUM_optimizeDisabled					13000
#define VCTDENUM_optimizeMinSpace					13001
#define VCTDENUM_optimizeMaxSpeed					13002
#define VCTDENUM_optimizeFull						13003
#define VCTDENUM_optimizeCustom						13004

// typedef enum inlineExpansionOption
#define VCTDENUM_expandDisable						13010
#define VCTDENUM_expandOnlyInline					13011
#define VCTDENUM_expandAnySuitable					13012

// typedef enum favorSizeOrSpeedOption
#define VCTDENUM_favorNone							13015
#define VCTDENUM_favorSpeed							13016
#define VCTDENUM_favorSize							13017

// typedef enum preprocessOption
#define VCTDENUM_preprocessNo						13020
#define VCTDENUM_preprocessYes						13021
#define VCTDENUM_preprocessNoLineNumbers			13022

// typedef enum stringPoolOption
#define VCTDENUM_stringPoolNone						13025
#define VCTDENUM_stringPoolSet						13026
#define VCTDENUM_stringPoolReadOnly					13027

// typedef enum ptrMemberOption
#define VCTDENUM_ptrMemAny							13030
#define VCTDENUM_ptrMemGeneral						13031
#define VCTDENUM_ptrMemBestCase						13032
#define VCTDENUM_ptrMemMultiInherit					13033
#define VCTDENUM_ptrMemSingleInherit				13034

// typedef enum pchOption
#define VCTDENUM_pchNone							13040
#define VCTDENUM_pchCreateUsingSpecific				13041
#define VCTDENUM_pchGenerateAuto					13042
#define VCTDENUM_pchUseUsingSpecific				13043

// typedef enum asmListingOption
#define VCTDENUM_asmListingNone						13050
#define VCTDENUM_asmListingAssemblyOnly				13051
#define VCTDENUM_asmListingAsmMachineSrc			13052
#define VCTDENUM_asmListingAsmMachine				13053
#define VCTDENUM_asmListingAsmSrc					13054

// typedef enum debugOption
#define VCTDENUM_debugDisabled						13060
#define VCTDENUM_debugOldStyleInfo					13061
#define VCTDENUM_debugLineInfoOnly					13062
#define VCTDENUM_debugEnabled						13063
#define VCTDENUM_debugEditAndContinue				13064

// typedef enum browseInfoOption
#define VCTDENUM_brAllInfo							13070
#define VCTDENUM_brNoLocalSymbols					13071

// typedef enum CompileAsOptions
#define VCTDENUM_compileAsC							13075
#define VCTDENUM_compileAsCPlusPlus					13076

// typedef enum warningLevelOption
#define VCTDENUM_warningLevel_0						13080
#define VCTDENUM_warningLevel_1						13081
#define VCTDENUM_warningLevel_2						13082
#define VCTDENUM_warningLevel_3						13083
#define VCTDENUM_warningLevel_4						13084
#define VCTDENUM_warningLevel_All					13085

// typedef enum ProcessorOptimizeOption
#define VCTDENUM_procOptimizeBlended				13090
#define VCTDENUM_procOptimizePentium				13091
#define VCTDENUM_procOptimizePentiumProAndAbove		13092

// typedef enum callingConventionOption
#define VCTDENUM_callConventionCDecl				13095
#define VCTDENUM_callConventionFastCall				13096
#define VCTDENUM_callConventionStdCall				13097

// typedef enum compileAsManagedOptions
#define VCTDENUM_managedNone						13110
#define VCTDENUM_managedMetaData					13111
#define VCTDENUM_managedAssembly					13112

// typedef enum structMemberAlignOption
#define VCTDENUM_alignSingleByte					13115
#define VCTDENUM_alignTwoBytes						13116
#define VCTDENUM_alignFourBytes						13117
#define VCTDENUM_alignEightBytes					13118
#define VCTDENUM_alignSixteenBytes					13119

// typedef enum runtimeLibraryOption
#define VCTDENUM_rtMultiThreaded					13125
#define VCTDENUM_rtMultiThreadedDebug				13126
#define VCTDENUM_rtMultiThreadedDLL					13127
#define VCTDENUM_rtMultiThreadedDebugDLL			13128
#define VCTDENUM_rtSingleThreaded					13129
#define VCTDENUM_rtSingleThreadedDebug				13130

// typedef enum codeGenerationStyles
#define VCTDENUM_codeGenerationOptionNotSet			13135
#define VCTDENUM_codeGenerationManagedMSIL			13136
#define VCTDENUM_codeGenerationManagedNative		13137
#define VCTDENUM_codeGenerationUnmanagedNative		13138

// Linker  & Library Tools
// typedef enum subSystemOption
#define VCTDENUM_subSystemNotSet					13145
#define VCTDENUM_subSystemConsole					13146
#define VCTDENUM_subSystemWindows					13147

// typedef enum linkProgressOption
#define VCTDENUM_linkProgressNotSet					13150
#define VCTDENUM_linkProgressAll					13151
#define VCTDENUM_linkProgressLibs					13152

// typedef enum addressAwarenessType
#define VCTDENUM_addrAwareDefault					13155
#define VCTDENUM_addrAwareNoLarge					13156
#define VCTDENUM_addrAwareLarge						13157

// typedef optRefType
#define VCTDENUM_optNoReferences					13160
#define VCTDENUM_optReferences						13161

// typedef optWin98
#define VCTDENUM_optWin98No							13165
#define VCTDENUM_optWin98Yes						13166

// typedef optFoldingType
#define VCTDENUM_optNoFolding						13170
#define VCTDENUM_optFolding							13171

// typedef linkIncrementalType
#define VCTDENUM_linkIncrementalNo					13175
#define VCTDENUM_linkIncrementalYes					13176

// typedef termSvrAwarenessType
#define VCTDENUM_termSvrAwareNo						13180
#define VCTDENUM_termSvrAwareYes					13181

// typedef enum midlCharOption
#define VCTDENUM_midlCharUnsigned					13185
#define VCTDENUM_midlCharSigned						13186
#define VCTDENUM_midlCharAscii7						13187

// typedef enum midlStubStyleOption
#define VCTDENUM_midlStubNotSet						13190
#define VCTDENUM_midlStubMixedMode					13191
#define VCTDENUM_midlStubOldStyle					13192
#define VCTDENUM_midlStubStandard					13193
#define VCTDENUM_midlStubDeluxe						13194

// typedef enum midlErrorCheckOption
#define VCTDENUM_midlEnableCustom					13200
#define VCTDENUM_midlDisableAll						13201
#define VCTDENUM_midlEnableAll						13202

// typedef enum midlTargetEnvironment
#define VCTDENUM_midlTargetNotSet					13205
#define VCTDENUM_midlTargetWin32					13206
#define VCTDENUM_midlTargetWin64					13207

// typedef enum midlTypeLibFormat
#define VCTDENUM_midlTypeLibNone					13210
#define VCTDENUM_midlTypeLibNewFormat				13211
#define VCTDENUM_midlTypeLibOldFormat				13212

// typedef enum midlWarningLevelOption
#define VCTDENUM_midlWarningLevel_0					13215
#define VCTDENUM_midlWarningLevel_1					13216
#define VCTDENUM_midlWarningLevel_2					13217
#define VCTDENUM_midlWarningLevel_3					13218
#define VCTDENUM_midlWarningLevel_4					13219

// typedef enum midlStructMemberAlignOption
#define VCTDENUM_midlAlignNotSet					13225
#define VCTDENUM_midlAlignSingleByte				13226
#define VCTDENUM_midlAlignTwoBytes					13227
#define VCTDENUM_midlAlignFourBytes					13228
#define VCTDENUM_midlAlignEightBytes				13229

// Configurations
// typedef enum ConfigurationTypes
#define VCTDENUM_typeUnknown						13235
#define VCTDENUM_typeApplication					13236
#define VCTDENUM_typeDynamicLibrary					13237
#define VCTDENUM_typeStaticLibrary					13238
#define VCTDENUM_typeGeneric						13239

// typedef enum useOfMfc
#define VCTDENUM_useMfcStdWin						13245
#define VCTDENUM_useMfcStatic						13246
#define VCTDENUM_useMfcDynamic						13247

// typedef enum useOfATL
#define VCTDENUM_useATLNotSet						13250
#define VCTDENUM_useATLStatic						13251
#define VCTDENUM_useATLDynamic						13252

// typedef enum charSet
#define VCTDENUM_charSetNotSet						13255
#define VCTDENUM_charSetUnicode						13256
#define VCTDENUM_charSetMBCS						13257

// typedef toolSetType
#define VCTDENUM_toolSetUtility						13260
#define VCTDENUM_toolSetMakefile					13261
#define VCTDENUM_toolSetLinker						13262
#define VCTDENUM_toolSetLibrarian					13263
#define VCTDENUM_toolSetAll							13264

// Projects
// typedef enum ProjectitemTypes
#define VCTDENUM_typeFile							13270
#define VCTDENUM_typeFilter							13271
#define VCTDENUM_typeProject						13272

// Projects
// typedef enumBool 
#define VCTDENUM_No									13275
#define VCTDENUM_Yes								13276

// typedef eLogSectionTypes
#define VCTDENUM_eLogNoSection						13280
#define VCTDENUM_eLogNoNewLine						13281
#define VCTDENUM_eLogStartSection					13282
#define VCTDENUM_eLogHeader							13283
#define VCTDENUM_eLogEnvironment					13284
#define VCTDENUM_eLogCommand						13285
#define VCTDENUM_eLogOutput							13286
#define VCTDENUM_eLogResults						13287
#define VCTDENUM_eLogFooter							13288
#define VCTDENUM_eLogAll							13289

// typedef CMD
#define VCTDENUM_CMD_Canceled						13290
#define VCTDENUM_CMD_Complete						13291
#define VCTDENUM_CMD_Error							13292

// typedef genProxyLanguage
#define VCTDENUM_genProxyNative						13295
#define VCTDENUM_genProxyManaged					13296

// random BOOL properties that we need to have junk enums for for settings pages
#define VCTDENUM_Default								14500
#define VCTDENUM_None									14501
#define VCTDENUM_GlobalOptimizationsTrue				14502
#define VCTDENUM_EnableIntrinsicFunctionsTrue			14503
#define VCTDENUM_ImproveFloatingPointConsistencyTrue	14504
#define VCTDENUM_ImproveFloatingPointConsistencyFalse	14505
#define VCTDENUM_OmitFramePointersTrue					14506
#define VCTDENUM_EnableFiberSafeOptimizationsTrue		14507
#define VCTDENUM_UndefineAllPreprocessorDefinitionsTrue	14508
#define VCTDENUM_IgnoreStandardIncludePathTrue			14509
#define VCTDENUM_KeepCommentsTrue						14510
#define VCTDENUM_ShowIncludesTrue						14511
#define VCTDENUM_SmallerTypeCheckTrue					14512
#define VCTDENUM_BufferSecurityCheckTrue				14513
#define VCTDENUM_MinimalRebuildFalse					14514
#define VCTDENUM_MinimalRebuildTrue						14515
#define VCTDENUM_RTTITrue								14516
#define VCTDENUM_DisableLanguageExtensionsTrue			14519
#define VCTDENUM_DefaultCharIsUnsignedTrue				14520
#define VCTDENUM_TreatWChar_tAsBuiltInTypeTrue			14521
#define VCTDENUM_EnableFunctionLevelLinkingTrue			14522
#define VCTDENUM_UsePCHTrue								14523
#define VCTDENUM_ExpandAttributedSourceTrue				14524
#define VCTDENUM_WarnAsErrorTrue						14525
#define VCTDENUM_SuppressStartupBannerTrue				14526
#define VCTDENUM_SuppressStartupBannerUpTrue			14527
#define VCTDENUM_Detect64BitPortabilityProblemsTrue		14528
#define VCTDENUM_ForceConformanceInForLoopScopeTrue		14529
#define VCTDENUM_IgnoreAllDefaultLibrariesTrue			14530
#define VCTDENUM_ResourceOnlyDLLTrue					14531
#define VCTDENUM_SetChecksumTrue						14532
#define VCTDENUM_TurnOffAssemblyGenerationTrue			14533
#define VCTDENUM_SwapRunFromCDTrue						14534
#define VCTDENUM_SwapRunFromNetTrue						14535
#define VCTDENUM_GenerateDebugInformationTrue			14536
#define VCTDENUM_GenerateMapFileTrue					14537
#define VCTDENUM_MapExportsTrue							14538
#define VCTDENUM_MapLinesTrue							14539
#define VCTDENUM_SupportUnloadOfDelayLoadedDLLFalse		14540
#define VCTDENUM_SupportUnloadOfDelayLoadedDLLTrue		14541
#define VCTDENUM_IgnoreEmbeddedIDLTrue					14542
#define VCTDENUM_MkTyplibCompatibleTrue					14543
#define VCTDENUM_MidlIgnoreStandardIncludePathTrue		14544
#define VCTDENUM_ErrorCheckAllocationsTrue				14545
#define VCTDENUM_ErrorCheckBoundsTrue					14546
#define VCTDENUM_ErrorCheckEnumRangeTrue				14547
#define VCTDENUM_ErrorCheckRefPointersTrue				14548
#define VCTDENUM_ErrorCheckStubDataTrue					14549
#define VCTDENUM_ValidateParametersTrue					14550
#define VCTDENUM_ShowProgressTrue						14551
#define VCTDENUM_ExceptionHandlingTrue					14552
#define VCTDENUM_runtimeCheckStackFrame					14553
#define VCTDENUM_runtimeCheckUninitVariables			14554
#define VCTDENUM_runtimeCheckBasic						14555
#define VCTDENUM_StringPoolingTrue						14556
#define VCTDENUM_GenerateStublessProxiesTrue			14557
#define VCTDENUM_GenerateTypeLibraryFalse				14558
#define VCTDENUM_OptimizeForWindowsApplicationYes		14559
#define VCTDENUM_machineNotSet							14560
#define VCTDENUM_machineX86								14561
#define VCTDENUM_eAppProtectLow							14562
#define VCTDENUM_eAppProtectMedium						14563
#define VCTDENUM_eAppProtectHigh						14564

// XBox Image Game Rating enum
#define XBOXGAMERATINGENUM_eNone						14580
#define XBOXGAMERATINGENUM_eRP							14581
#define XBOXGAMERATINGENUM_eAO							14582
#define XBOXGAMERATINGENUM_eM							14583
#define XBOXGAMERATINGENUM_eT							14584
#define XBOXGAMERATINGENUM_eE							14585
#define XBOXGAMERATINGENUM_eKA							14586
#define XBOXGAMERATINGENUM_eEC							14587

// TypeLib Coclasses
//NOTE: if the range of dispids goes beyond VCPBLIBCLASS_MAX_DISPID, keep it updated
#define VCPBLIBCLASS_MIN_DISPID							15000
#define VCPBLIBCLASS_MAX_DISPID							15100

// VCPB General Classes
#define VCCollection_Class								15000
#define	VCProjectEngine_Class							15001
#define VCProject_Class									15002
#define VCFile_Class									15003
#define VCFilter_Class									15004
#define VCConfiguration_Class							15005
#define VCStyleSheet_Class								15006
#define VCDebugSettings_Class							15007
#define VCFileConfiguration_Class						15008
#define VCPropertyContainer_Class						15009
#define VCGeneralConfigSettings_Class					15010

// VCPB Resource Tool Classes
#define VCResourceCompilerBaseTool_Class				15020
#define RCGeneral_Class									15021

// VCPB Library Tool Classes
#define VCLibrarianBaseTool_Class						15030
#define LibGeneral_Class								15031
#define LibInputOutput_Class							15032

// VCPB Linker Tool Classes
#define VCLinkerBaseTool_Class							15040
#define LinkGeneral_Class								15041
#define LinkInput_Class									15042
#define LinkDebug_Class									15043
#define LinkSystem_Class								15044
#define LinkOptimization_Class							15045
#define LinkMIDL_Class									15046
#define LinkAdvanced_Class								15047

// VCPB Compiler Tool Classes
#define VCCLCompilerBaseTool_Class						15060
#define ClOptimization_Class							15061
#define ClPreprocessor_Class							15062
#define ClAdvanced_Class								15063
#define ClCodeGeneration_Class							15065
#define ClLanguage_Class								15066
#define ClPrecompiledHeaders_Class						15067
#define ClOutputFiles_Class								15068
#define ClBrowseInfo_Class								15070
#define ClGeneral_Class									15071

// VCPB MIDL Tool Classes
#define VCMidlBaseTool_Class							15090
#define MidlGeneral_Class								15091
#define MidlOutput_Class								15092
#define MidlAdvanced_Class								15093

// VCPB Build Tool Classes
#define VCBuildOutput_Class								15100
#define VCPreBuildEventBaseTool_Class					15101
#define VCPreLinkEventBaseTool_Class					15102
#define VCPostBuildEventBaseTool_Class					15103
#define VCCustomBuildBaseTool_Class						15104
#define VCCustomGeneral_Class							15105
#define VCPreBldGeneral_Class							15106
#define VCPreLinkGeneral_Class							15107
#define VCPostBldGeneral_Class							15108
#define VCBSCGeneral_Class								15109

#define VCNMakeGeneral_Class							15110

// PROJBLD Project Engine Classes
#define VCProjBuildEvents_Class							15120
#define VCFolderNodeProps_Class							15121
#define VCFileNodeProps_Class							15122
#define VCProjectNodeProps_Class						15123
#define BuildPackage_Class								15124

// XBox Deployment Classes
#define XboxDeploymentGeneral_Class						15140

// XBox Image Classes
#define XboxImageGeneral_Class							15150
#define XboxImageCertificate_Class						15151
#define XboxImageTitleInfo_Class						15152

#define VCID_Obsolete									15200
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\profile.h ===
// profile.h: useful routines for manipulating the registry

#pragma once

#include <vcstring.h>

#define MAX_REG_STR	4096

const char chKeySep = '\\';

LPCTSTR GetRegistryKeyName();
void SetAlternateKey(LPCSTR szAltKey);

CVCString GetRegString(LPCSTR szSection, LPCSTR szKey, LPCSTR szDefault = NULL);
CStringW GetRegString(LPCOLESTR szSection, LPCOLESTR szKey, LPCOLESTR szDefault = NULL);
void GetRegPath(LPCSTR szSection, LPCSTR szKey, CStringA& strPath, LPCTSTR szDefault = NULL, BOOL bDefaultToHKLM = TRUE);
void GetRegPath(LPCOLESTR szSection, LPCOLESTR szKey, CStringW& strPath, LPCOLESTR szDefault = NULL, BOOL bDefaultToHKLM = TRUE);
DWORD GetRegInt(LPCSTR szSection, LPCSTR szKey, DWORD dwDefault);
extern HGLOBAL GetRegData(LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobDefault);
IStream *GetRegIStream(LPCTSTR szSection, LPCTSTR szKey);

BOOL WriteRegString(LPCSTR szSection, LPCSTR szKey, LPCSTR szVal, BOOL bUserSpecific = TRUE);
BOOL WriteRegString(LPCOLESTR szSection, LPCOLESTR szKey, LPCOLESTR szVal, BOOL bUserSpecific = TRUE);
BOOL WriteRegPath(LPCSTR szSection, LPCSTR szKey, LPCSTR szVal, BOOL bUserSpecific = TRUE);
BOOL WriteRegPath(LPCOLESTR szSection, LPCOLESTR szKey, LPCOLESTR szVal, BOOL bUserSpecific = TRUE);
BOOL WriteRegInt(LPCSTR szSection, LPCSTR szKey, DWORD nValue, BOOL bUserSpecific = TRUE);
extern BOOL WriteRegData(LPCSTR szSection, LPCSTR szKey, HGLOBAL hglobValue);
BOOL WriteRegIStream(LPCTSTR szSection, LPCTSTR szKey, IStream *pIStream);

BOOL DeleteRegData(LPCSTR szSection, LPCSTR szKey);

HRESULT WriteRegPathW(LPCOLESTR szFile,LPCOLESTR szSection, LPCOLESTR szKey, LPCOLESTR szVal);
HRESULT WriteRegStringW(LPCOLESTR szSection, LPCOLESTR szKey, LPCOLESTR szVal, HKEY keyType = HKEY_CURRENT_USER);
HRESULT WriteRegIntW(LPCOLESTR szSection, LPCOLESTR szKey, DWORD nValue, HKEY keyType = HKEY_CURRENT_USER);
HRESULT WriteRegBoolW(LPCOLESTR szSection, LPCOLESTR szKey, VARIANT_BOOL nValue, HKEY keyType = HKEY_CURRENT_USER);

HRESULT GetRegPathW(LPCOLESTR szFile, LPCOLESTR szSection, LPCOLESTR szKey, BSTR *pbstrOut);
HRESULT GetRegStringW(LPCOLESTR szSection, LPCOLESTR szKey, BSTR *pbstrOut);
HRESULT GetRegIntW(LPCOLESTR szSection, LPCOLESTR szKey, DWORD *pdwOut);
HRESULT GetRegBoolW(LPCOLESTR szSection, LPCOLESTR szKey, VARIANT_BOOL *pdwOut);

HRESULT GetAppDataDirW(BSTR *pbstrAppData);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\register.h ===
//--------------------------------------------------------------------------
// Copyright (c) 1997,1998 Microsoft Corporation
//                     All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//--------------------------------------------------------------------------
//////////////////////////////////////////////
// Registration helper for packages
//
#pragma once
// The current user LCID
//
#define REGKEY_LANG_DESC	      "C/C++"
#define REGVALUE_NCB_CPP_EXTENSIONS "NCB Default C/C++ Extensions"
#define REGVALUE_NCB_IDL_EXTENSIONS "NCB Default IDL Extensions"

LCID GetUILocaleLCID(LPCTSTR szAltKey);
void UtilGetSatelliteDllName(CComBSTR& strSatDllDir, CComBSTR& strSatDllName, HINSTANCE hInstMain, LPCTSTR pszUIDllName, LPCTSTR pszAltKey);
void UtilGetSatelliteDllNameW(CComBSTR& strSatDllDir, CComBSTR& strSatDllName, HINSTANCE hInstMain, LPCOLESTR pszUIDllName, LPCOLESTR pszAltKey);

// PACKAGES
BOOL RegisterPackage(REFIID clsid, LPCTSTR szPackageName, 
					 LPCTSTR szAboutText, BOOL fPreload, LPCTSTR szAltKey);
BOOL RegisterPackageEx(REFIID clsid,
					 LPCTSTR pszPackageName, 
					 LPCTSTR pszAboutText,
					 LPCTSTR pszAltKey,
					 DWORD dwAutoCount,
					 LPCTSTR szAutomationNames[],
					 LPCTSTR pszSatDir,
					 LPCTSTR pszSatFile);
BOOL UnregisterPackage(REFIID clsid, LPCTSTR szAltKey);

// SERVICES
BOOL RegisterService(REFIID clsidService, REFIID clsidPackage, 
					 LPCTSTR szServiceName, LPCTSTR szAltKey);
BOOL UnregisterService(REFIID clsidService, LPCTSTR szAltKey);

// PROJECT TYPES
BOOL RegisterProjectType(REFIID clsidProject, REFIID clsidPackage,
						 LPCTSTR pszProjectKey,
						 LPCTSTR pszProjectItemKey,
						 LPCTSTR pszProjectName,
						 LPCTSTR pszProjectItemName,
						 DWORD	 dwProjectPriority,
						 DWORD	 dwItemPriority,
						 LPCTSTR pszDispFileExt,
						 LPCTSTR pszPossProjExt,
						 LPCTSTR pszTmplDir,
						 LPCTSTR pszNewFilesDir,
						 LPCTSTR pszItmTmplDir,
						 LPCTSTR pszDefProjExt,
						 REFGUID rguidPseudoFolder,
						 LPCTSTR szAltKey,
						 DWORD	 dwPkgID);

BOOL UnregisterProjectType(
						   
		REFIID clsidProject, 
		REFIID clsidPackage, 
		REFGUID rguidPseudoFolder,
		LPCTSTR szAltKey);

LONG CreateBaseKey(LPCTSTR szAltKey,
				   CRegKey *pKey,
				   HKEY hKeyParent = HKEY_LOCAL_MACHINE,
				   LPTSTR lpszClass = REG_NONE,
				   DWORD dwOptions = REG_OPTION_NON_VOLATILE,
				   REGSAM samDesired = KEY_READ | KEY_WRITE,
				   LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
				   LPDWORD lpdwDisposition = NULL);

struct EditorExt
{
	LPCTSTR szExt;
	ULONG lRanking;
};
// EDITORS
// To register editor extensions, pass in an array of EditorExt as follow:
// EditorExt pMyEditorExt[] = { {_T("cpp"), 50}, {_T("hxx"), 25}, {NULL,0}};
BOOL RegisterEditor(REFIID clsidEditor, REFIID clsidPackage,
						 LPCTSTR szEditorName, 
						 EditorExt pExtensions[],
						 LPCTSTR szAltKey);
BOOL UnregisterEditor(REFIID clsidEditor, LPCTSTR szAltKey);

// PERSISTENCE KEYS
BOOL RegisterPersistenceKey(LPCTSTR szKeyName, LPCTSTR szAltKey, REFIID clsid);
BOOL UnregisterPersistenceKey(LPCTSTR szKeyName, LPCTSTR szAltKey);

// COMMAND TABLE
BOOL RegisterCommandTable(REFIID clsid, LPCTSTR szCommandTableFilename,
						UINT nIDCommandTable,
						UINT nVersion,
						LPCTSTR szAltKey =NULL,
						BOOL fUsingSatellite = FALSE);

BOOL UnregisterCommandTable(REFIID clsid, LPCTSTR szAltKey =NULL);


// OUTPUT WINDOW
BOOL RegisterOutputWindow(REFIID guid,
                          LPCTSTR szOutputWindowNameName, 
                          BOOL fInitiallyVisible,
                          LPCTSTR szAltKey);

BOOL UnregisterOutputWindow(REFIID guid, LPCTSTR szAltKey);

// OPTIONS PAGES
BOOL RegisterOptionsPage( LPCTSTR szGroupName, 
						  LPCTSTR szPageName, 
						  CLSID guidPackage,
						  REFIID guidPage);
BOOL UnregisterOptionsPage(LPCTSTR szPageName, LPCTSTR szAltKey);


// LANGUAGE MANAGER
BOOL RegisterLanguageManager(REFIID guid,
							 REFIID guidPkg,
							 LPCTSTR pExtensions[],
							 LPCTSTR szAltKey);

BOOL UnregisterLanguageManager(LPCTSTR pExtensions[],
							 LPCTSTR szAltKey);

BOOL RegisterToolWindow
(
 REFIID guidToolWindow,
 REFIID clsidPackage,
 LPCTSTR szToolWindowName /* = NULL */,
 LPCTSTR szAltKey /* = NULL */
 );

BOOL UnregisterToolWindow
(
 REFIID guidToolWindow, 
 LPCTSTR szAltKey /* = NULL */
 );

//The splash screen and the about box will QI the package for IVsInstalledProduct
//(and IVsMicrosoftInstalledProduct) and get all the information it needs from there.
BOOL RegisterProduct(LPCTSTR szProdKeyName, REFIID clsidPackage, LPCTSTR szAltKey);

BOOL UnregisterProduct(LPCTSTR szProdKeyName,
					 LPCTSTR szAltKey);

BOOL RegisterLibMgr(REFIID clsid, LPCTSTR szLibMgrName, 
					 REFIID pkgid, LPCTSTR szAltKey);
BOOL UnregisterLibMgr(REFIID clsid, LPCTSTR pszAltKey);

BOOL RegisterAutomationExtender(BSTR bstrExtenderCATID, BSTR bstrExtenderName, REFCLSID clsidExtensionProvider, LPCTSTR pszAltKey);
BOOL UnregisterAutomationExtender(BSTR bstrExtenderCATID, BSTR bstrExtenderName, LPCTSTR pszAltKey);

BOOL RegisterExtensionlessFile(BSTR bstrExtensionlessFile, const GUID & sidLanguageService, BSTR bstrAltKey);

void UtilGetVCInstallFolder(CStringA& strDir, BOOL bAddTrailingSlash = TRUE);
void UtilGetVCInstallFolder(CStringW& strDir, BOOL bAddTrailingSlash = TRUE);
void UtilGetVSInstallFolder(CStringA& strDir, BOOL bAddTrailingSlash = TRUE);
void UtilGetVSInstallFolder(CStringW& strDir, BOOL bAddTrailingSlash = TRUE);
void UtilGetDevenvFolder(CStringA& strDir, BOOL bAddTrailingSlash = TRUE);
void UtilGetDevenvFolder(CStringW& strDir, BOOL bAddTrailingSlash = TRUE);
void UtilGetCommon7Folder(CStringA& strDir, BOOL bAddTrailingSlash = TRUE);
void UtilGetCommon7Folder(CStringW& strDir, BOOL bAddTrailingSlash = TRUE);

HRESULT GetRegRootStrings(LPCOLESTR pszRegistrationRoot, BSTR * pbstrRootBegin, BSTR * pbstrRootEnd);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\sheet.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHEET.H

#ifndef __SHEET_H__
#define __SHEET_H__

#include "slob.h"
#include "proppage.h"
#include "tabdlg.h"

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA

#define cxPageMargin 6
#define cyPageMargin 4
#define cxWndMargin 5
#define cyWndMargin 5

#define MAX_TEXTSIZE 255 // normal edit controls

#define	INITIAL_LEVELCOMBO_HEIGHT	26

/////////////////////////////////////////////////////////////////////////////
// CSheetSlob

class CSheetSlob : public CSlob
{
	DECLARE_DYNAMIC(CSheetSlob)
public:
	CSheetSlob();
	~CSheetSlob();

	void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD_PTR dwHint);
	void NukeInforms();
	void FlushInforms();
	inline BOOL HasInforms() { return !m_informList.IsEmpty(); }

	class CSheetWnd* m_pSheetWnd;
	CPtrList m_informList;
};

class CInformRecord
{
public:
	CInformRecord(CSlob*, UINT);

	CSlob*	m_pChangedSlob;
	UINT	m_idChange;
};

/////////////////////////////////////////////////////////////////////////////
//	CPropFrameToolBar
//		This is the minature toolbar with pushpin and help buttons

class CPropFrameToolBar : public CToolBar
{
public:
	enum {
		sizeButtonX = 21,
		sizeButtonY = 20,
		sizeImageX = 15,
		sizeImageY = 14,
	};

	CPropFrameToolBar();

	void SetSizes();

	BOOL IsPinned();
	void SetPushPin(BOOL bPushed = TRUE);
};

/////////////////////////////////////////////////////////////////////////////
//	CSheetWnd
// 		Implements the property frame, displaying C3dPropertyPage objects
//		in it's client area.

class CSheetWnd : public CMiniFrameWnd
{
public:
	static CObList s_listLoadedPages;
	static int s_cyBreakLine;	// y-coord of top of page

public:
	enum SELSTYLE { 					// selection state
		none,
		editor,
		multiple,
		blank,
        editorupdate                    // force an update even if sel same
	};

	enum {
		cxSize = 395,
		cySize = 157,
		xDefaultPos = 60,
		yDefaultPos = 470,
	};

// Construction
public:
	CSheetWnd();
	virtual ~CSheetWnd();

	BOOL Create(CWnd * pParentWnd);

public:
	void InitialUpdate(CPoint);
	void IdleUpdate();

	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	void CancelPage();
	BOOL IsInCancel() const { return m_bInCancel; }

	void SetActive(BOOL bActive);
	BOOL IsActive() const { return m_bActive; }

	BOOL Validate();
	BOOL ValidateRequest();
	BOOL IsValidating() const { return m_bValidating; }

	void ResetFocusSave() { m_iFocusSave = 0; }
	void SetDefaultPage();
	BOOL FlipToPage(int iStringID);
	BOOL FlipToPage(const CString& str);
	void IncrementPage(int nInc);
	void ClearPage();
	void SelectionChange(CSheetWnd::SELSTYLE, CSlob *, int nPage = -1);
	void CurrentSlobDestroyed();
	void SetPushPin(BOOL fPushed = TRUE);
	BOOL IsPinned();

	CWnd* SetEditFocus(UINT nProp);
	CWnd* GetControl(UINT nControlID);

	BOOL SaveFocus();
	BOOL RestoreFocus();
	void DrawFocusRect();
	
	BOOL UndoPendingValidate();

	void FlushUnusedPages();
	void RemovePageFromUse(C3dPropertyPage* pPage);
	inline void NukeInforms() { m_sheetSlob.NukeInforms(); }
	inline void FlushInforms() { m_sheetSlob.FlushInforms(); }
	inline BOOL HasInforms() { return m_sheetSlob.HasInforms(); }

	// Methods used during CSlob::SetupPropertyPages()
	int SetupPropertyPages(void);
	int AddPropertyPage(C3dPropertyPage* pPage, CSlob* pSlob);
	void SetCaption(LPCTSTR sz);
	BOOL InhibitExtraPages(BOOL bInhibit = TRUE);
	int StartNewPageSet(void);
	int MergePageSets(void);
	CSize CalcMaxPageSize(BOOL bNewPages = FALSE);

	// please use the method GetCurrentPage rather than
	// access the m_pCurPage data directly .. the latter
	// may not be valid at all times!
	inline C3dPropertyPage* GetCurrentPage() { IdleUpdate(); return m_pCurPage; }

	int GetLevelComboHeight();

	C3dPropertyPage* m_pCurPage;
	CSlobPage m_noPage;
	CSlobPage m_nullPage;
	CSlobPage m_multiPage;

	// For pages which want to expand beyond their minimum size, if some other page
	// has already forced the sheet to be larger.
	// Set in C3dPropertyPage::SetupPage() ... the page can look at the value during
	// C3dPropertyPage::InitializePage() and change its size if desired.
	CSize m_sizePageMax;

protected:
	BOOL m_bInCancel:1;
	BOOL m_bSheetChanged:1;
	BOOL m_bValidating:1;
	BOOL m_bValidateEnabled:1;

	// This bool is true whenever the property window is the active app
	// window (still true if the property window was active when the
	// app was deactivated), or false if some other app window (usually
	// an MDI child, or the main frame) is active (or was when the app
	// was deactivated).
	BOOL m_bActive:1;

//	BOOL m_bExtraPagesAdded:1;	// used by AddOnExtraPages()
	int m_refInhibitExtraPages;	// ref-counts InhibitExtraPages

	CObList m_listCurPages;	// current list of pages for m_pCurSlob
	CObList m_listNewPages;	// list of pages m_pNewSlob adds with AddPropertyPage
	int m_nFirstPageSet;	// used when merging pages in m_listNewPages

	CTabRow m_tabRow;
	CPropFrameToolBar m_toolBar;

	HWND m_hwndFocusSave;	// HWND of the last control w/ focus.
	int m_iFocusSave;	// ID of the last control w/ focus.
	int m_iActiveTab;

	CSlob *m_pCurSlob;	// The currently attached editor
	CSlob *m_pNewSlob;	// Editor to attach at next idle moment
	CSheetWnd::SELSTYLE m_selState;
	CSheetWnd::SELSTYLE m_newSelState;
	int m_nCurPage;
	int m_nNewPage;

	CSheetSlob m_sheetSlob;

	CString m_strDefaultPage;

	CComboBox	m_cbLevel;
	int			m_cyRowHeight;

// Message handling
protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT_PTR nTimerID);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnIsError(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnValidateReq(WPARAM wParam, LPARAM lParam);
	
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);

	afx_msg void OnSelPage();

	afx_msg void CmdOkPage();
	afx_msg void CmdCancelPage();
	afx_msg void CmdNextPage();
	afx_msg void CmdPrevPage();

	afx_msg void OnCmdPushPin();
	afx_msg void OnCmdHelp();

	afx_msg void OnSelChangeLevel();

	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
	
	DECLARE_MESSAGE_MAP()

	friend class CSheetSlob;
};

// Globals
extern CSheetWnd *g_PropSheet;
extern BOOL g_PropSheetVisible;

// Global helper functions

CSheetWnd* GetPropertyBrowser();
void SetPropertyBrowserSelection(CSlob* pSlob, int nPage = -1, 
	CSheetWnd::SELSTYLE style = CSheetWnd::editor); // select slob or NULL

/////////////////////////////////////////////////////////////////////////////

//#undef AFX_DATA
//#define AFX_DATA NEAR

#endif // __SHEET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\proppage.h ===
/////////////////////////////////////////////////////////////////////////////
//  PROPPAGE.H
//      Defines classes which can be used to display a property page
//      to view a CSlob's property map

#ifndef __PROPPAGE_H__
#define __PROPPAGE_H__

#include "dlgbase.h"

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA

class CSlob;
class CSheetWnd;

// CControlMap is a structure that maps control ids to property ids and
// control types.  An array of these is defined for each property dialog
// by using the macros below (DECLARE_PROP_CONTROL_MAP, BEGIN_PROP_CONTROL_MAP,
// END_CONTROL_MAP, etc.)

class CEnum;

struct CControlMap
{
    UINT m_nCtlID;      // dialog id for m_nCtlType == page
    UINT m_nLastCtlID;  // name string id for m_nCtlType == page

    UINT m_nProp;       // optional page help ID for m_nCtlType == page

    enum CTL_TYPE
    {
        null,
        check,
        list,
        checkList,
        comboList,
        comboText,
        autoComboList,
        edit,
        autoEdit,
        radio,
        page,
        editInt,        // FUTURE: some of these types could be removed,
        editNum,        // and achieved through flags.  But no hurry.
        thinText,
        thickText,
        icon,
        editStrCap,
        bitmap,
        listText,
        symbolCombo,
        pathText,
    } m_nCtlType;

    DWORD m_dwFlags;

    UINT_PTR m_nExtra;      // extra UINT, eg. used for offset in RADIO

//  union {
//      CEnum* m_pEnum; // for lists and combos
//  } u;
};

// flags for CControlMap::m_dwFlags:
enum
{
    CM_EXTRA_ENUM   = 0x001,    // m_nExtra is a CEnum*
    CM_EXTRA_LIMIT  = 0x002,    // m_nExtra is a limit value (UINT)
    CM_EXTRA_OFFSET = 0x003,    // m_nExtra is an offset
    CM_EXTRA_HELPID = 0x004,    // m_nExtra is a HelpID (of a page)
    CM_EXTRA_MASK   = 0x0ff,    // for (m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_*
    CM_NOAMBIGUOUS  = 0x100,    // disable control if value is ambiguous
    CM_NOMULTISEL   = 0x200,    // disable control for any multiple selection
};


// Include this inside a CSlobPage-derived class declaration.
#define DECLARE_PROP_CONTROL_MAP() \
    virtual CControlMap* GetControlMap(); \
    static CControlMap m_controlMap [];

// Include these with the implementation of a CSlobPage-derived class.
#define BEGIN_PROP_CONTROL_MAP(theClass, nDlgID, nNameID) \
    CControlMap* theClass::GetControlMap() \
        { return &m_controlMap[0]; } \
    CControlMap theClass::m_controlMap [] = { \
        { nDlgID, nNameID, 0, CControlMap::page, 0x0, NULL },

#define BEGIN_PROP_CONTROL_MAP_H(theClass, nDlgID, nNameID, nHelpID) \
    CControlMap* theClass::GetControlMap() \
        { return &m_controlMap[0]; } \
    CControlMap theClass::m_controlMap [] = { \
        { nDlgID, nNameID, 0, CControlMap::page, CM_EXTRA_HELPID, nHelpID },

#define END_PROP_CONTROL_MAP() { 0, 0, 0, CControlMap::null, 0x0, NULL } };


// These macros define CControlMap structures for inclusion between
// the BEGIN_PROP_CONTROL_MAP and END_CONTROL_MAP macros.
#define MAP_CHECK(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::check,      0x0,  NULL },
#define MAP_LIST(nCtlID, nProp, pEnum) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::list,       CM_EXTRA_ENUM, (UINT_PTR)&pEnum },
#define MAP_LIST_TEXT(nCtlID, nProp, pEnum) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::listText,   CM_EXTRA_ENUM, (UINT_PTR)&pEnum },
#define MAP_CHECK_LIST(nCtlID, pEnum) \
    { nCtlID,  nCtlID,  0,      CControlMap::checkList,  CM_EXTRA_ENUM, (UINT_PTR)&pEnum },
#define MAP_COMBO_LIST(nCtlID, nProp, pEnum) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::comboList,  CM_EXTRA_ENUM, (UINT_PTR)&pEnum },
#define MAP_COMBO_LIST_EX(nCtlID, nProp, theEnum) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::comboList,  CM_EXTRA_ENUM, (UINT_PTR)&(C##theEnum::GetObject()) },
#define MAP_COMBO_TEXT(nCtlID, nProp, pEnum) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::comboText,  CM_EXTRA_ENUM, (UINT_PTR)&pEnum },
#define MAP_AUTO_COMBO_LIST(nCtlID, nProp, pEnum) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::autoComboList, CM_EXTRA_ENUM, (UINT_PTR)&pEnum },
#define MAP_COMBO_TEXT_EX(nCtlID, nProp, theEnum) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::comboText,  CM_EXTRA_ENUM, (UINT_PTR)&(C##theEnum::GetObject()) },
#define MAP_AUTO_COMBO_LIST_EX(nCtlID, nProp, theEnum) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::autoComboList,  CM_EXTRA_ENUM, (UINT_PTR)&(C##theEnum::GetObject()) },
#define MAP_EDIT(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::edit,       0x0,  NULL },
#define MAP_EDIT_LIMIT(nCtlID, nProp, nLimit) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::edit,       CM_EXTRA_LIMIT, nLimit },
#define MAP_EDIT_INT(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::editInt,    0x0,  NULL },
#define MAP_EDIT_NUM(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::editNum,    0x0,  NULL },
#define MAP_AUTO_EDIT(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::autoEdit,   0x0,  NULL },
#define MAP_AUTO_EDIT_LIMIT(nCtlID, nProp, nLimit) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::autoEdit,   CM_EXTRA_LIMIT, nLimit },
#define MAP_RADIO(nFirstCtlID, nLastCtlID, nOffset, nProp) \
    { nFirstCtlID, nLastCtlID, nProp, CControlMap::radio,  CM_EXTRA_OFFSET, nOffset },
#define MAP_THIN_TEXT(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::thinText,   0x0,  NULL },
#define MAP_THICK_TEXT(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::thickText,  0x0,  NULL },
#define MAP_ICON(nCtlID) \
    { nCtlID,  nCtlID,  0,      CControlMap::icon,       0x0,  NULL },
#define MAP_EDIT_STRCAP(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::editStrCap, 0x0,  NULL },
#define MAP_BITMAP(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::bitmap,     CM_NOAMBIGUOUS,  NULL },
#define MAP_SYMBOL_COMBO(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::symbolCombo, 0x0, NULL },
#define MAP_PATH_TEXT(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::pathText,   0x0,  NULL },
#define MAP_EDIT_NOAMBIG(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::edit,       CM_NOAMBIGUOUS,  NULL },
#define MAP_EDIT_NOMULTISEL(nCtlID, nProp) \
    { nCtlID,  nCtlID,  nProp,  CControlMap::edit,       CM_NOMULTISEL,  NULL },

class C3dPropertyPage : public C3dDialog
{
    DECLARE_DYNAMIC(C3dPropertyPage)

public:
    C3dPropertyPage();

    virtual BOOL Create(UINT nIDSheet, CWnd* pWndOwner) = 0;

    virtual BOOL SetupPage(CSheetWnd* pSheetWnd, CSlob* pSlob);
    virtual void Activate(UINT nState, CSlob* pCurSlob);
    
    virtual void InitializePage();
    virtual void TermPage();
    virtual BOOL ShowPage(int nCmdShow);
    virtual void MovePage(const CRect& rect);

    virtual BOOL Validate() = 0;
    virtual BOOL UndoPendingValidate() = 0;

    virtual void OnActivate();
    virtual void OnDeactivate();
    virtual LRESULT OnPageHelp(WPARAM wParam, LPARAM lParam);

    virtual void GetPageName(CString& strName);
    virtual CSize GetPageSize();
    virtual BOOL IsPageActive() { return m_hWnd != NULL; }
    virtual BOOL IsPageDisabled() { return FALSE; }

    CSlob* GetSlob() { return m_pSlob; }

protected:
    CSlob* m_pSlob;
    CSheetWnd* m_pSheetWnd;

    friend class CSheetWnd;
    friend class CMultiSlob;
};

/////////////////////////////////////////////////////////////////////////////
//  COlePage property page

class COlePage : public C3dPropertyPage
{
    DECLARE_DYNAMIC(COlePage)

public:
    // Page caching.
    static CObList s_listPages;
    static LPUNKNOWN *s_pObjectCurrent;
    static LPUNKNOWN s_pSingleObject;
    static ULONG s_nObjectCurrent;
    static UINT s_nPagesCurrent;
    static LPCLSID s_lpClsID;
    static BOOL s_bPossibleUnusedServers;


//$UNDONE HACK HACK HACK get rid of this when the resource package changes its
// data bound control handling
    static BOOL s_fShowAllPage;
    static BOOL GetShowAllPage();
    static void SetShowAllPage(BOOL fSet);

    static UINT LoadPages(ULONG nUnkCnt, LPUNKNOWN *pprgUnk);
    static UINT LoadAllPageOnly(ULONG nUnkCnt, LPUNKNOWN *pprgUnk);
    static BOOL InPageCache(ULONG nUnkCnt, LPUNKNOWN *pprgUnk);
    static UINT AddAllPageToList(UINT nPagesCurrent, CAUUID *pcaGUID);
    static HRESULT DoPageIntersection(ISpecifyPropertyPages *pSPP, CAUUID *pcaGUID);
    static C3dPropertyPage* GetPropPage(UINT iPage);
    static C3dPropertyPage* GetPropPage(REFCLSID clsid);
    static void Cleanup();
    static void SetUnusedServers(BOOL fUnused = TRUE);

protected:
    COlePage(REFCLSID clsid);   // Use GetPropPage()
    ~COlePage();

public:
    BOOL IsUsable()
        { return m_lpPropPage != NULL; }

    virtual BOOL Create(UINT nIDSheet, CWnd* hWndOwner);
    virtual BOOL PreTranslateMessage(MSG* pMsg);

    virtual void InitializePage();
    virtual void TermPage();
    virtual BOOL ShowPage(int nCmdShow);
    virtual void MovePage(const CRect& rect);
    virtual BOOL DestroyWindow();

    virtual BOOL Validate();
    virtual BOOL UndoPendingValidate();

    virtual LRESULT OnPageHelp(WPARAM wParam, LPARAM lParam);

    virtual void GetPageName(CString& strName);
    virtual CSize GetPageSize();
    virtual BOOL IsPageActive() { return m_bActive; }

    void EditProperty(DISPID dispid);


// Attributes
protected:
    BOOL m_bActive:1;
    BOOL m_bVisible:1;
    BOOL m_bTranslatingAccel:1;

    CLSID m_clsid;
    CString m_strName;
    CSize m_size;

    LPPROPERTYPAGE m_lpPropPage;

// Interface Maps   
protected:
    // IPropertyPageSite
    BEGIN_INTERFACE_PART(PropertyPageSite, IPropertyPageSite)
        INIT_INTERFACE_PART(COlePage, PropertyPageSite)
        STDMETHOD(OnStatusChange)(DWORD);
        STDMETHOD(GetLocaleID)(LCID FAR*);
        STDMETHOD(GetPageContainer)(LPUNKNOWN FAR*);
        STDMETHOD(TranslateAccelerator)(LPMSG);
    END_INTERFACE_PART(PropertyPageSite)

    DECLARE_INTERFACE_MAP()
};

// CSlobPages are CDialogs that use the CSlob property mechanism to
// automaticly handle the dialog.

class CSlobPage : public C3dPropertyPage
{
public:
    DECLARE_PROP_CONTROL_MAP()
    DECLARE_DYNAMIC(CSlobPage)

public:
    CSlobPage();
    ~CSlobPage();

    virtual BOOL Create(UINT nIDSheet, CWnd* pWndOwner);
    virtual BOOL PreTranslateMessage(MSG* pMsg);

    virtual void InitializePage();
    virtual void InitPage();

    BOOL EnablePage(BOOL bEnable = TRUE);
    virtual BOOL IsPageDisabled() { return !m_bEnabled; }

    virtual BOOL Validate();
    virtual BOOL UndoPendingValidate();

    virtual LRESULT OnPageHelp(WPARAM wParam, LPARAM lParam)
            {
                return C3dPropertyPage::OnPageHelp(wParam, lParam);
            }

    virtual BOOL OnPropChange(UINT nProp);
    virtual void GetPageName(CString& strName);

    CControlMap* FindControl(UINT nCtlID);
    CControlMap* FindProp(UINT nProp);

    void GetGuid (GUID & guid) 
    {
        guid = m_guid;
    }
protected:
    GUID m_guid;

private:
    BOOL m_bDirty;
    UINT m_idDlg;
    UINT m_idCaption;
    CString m_strPageName;
    SIZE m_sizePage;
    CString m_strDocString;
    CString m_strHelpFile;
    DWORD m_dwHelpContext;
    LPPROPERTYPAGESITE m_pPageSite;

    LPDISPATCH* m_ppDisp;       // Array of IDispatch pointers, used to
                                // access the properties of each control

    LPDWORD m_pAdvisors;        // Array of connection tokens used by
                                // IConnecitonPoint::Advise/UnAdvise.

    BOOL m_bPropsChanged;       // IPropertyNotifySink::OnChanged has been
                                // called, but not acted upon yet.

    ULONG m_nObjects;           // Objects in m_ppDisp, m_ppDataObj, m_pAdvisors

    BOOL m_bInitializing;       // TRUE if the contents of the fields of
                                // the dialog box are being initialized

    int m_nControls;            // Number of fields on this property page

//  AFX_PPFIELDSTATUS* m_pStatus;   // Array containing information on
                                    // which fields are dirty

    CDWordArray m_IDArray;      // Array containing information on which
                                // controls to ignore when deciding if
                                // the apply button is to be enabled

    HGLOBAL m_hDialog;          // Handle of the dialog resource

#ifdef _DEBUG
protected:
    BOOL m_bNonStandardSize;
#endif

// LIST OF INTERFACE MAPS
public:
    // IPropertyPage2
    BEGIN_INTERFACE_PART(PropertyPage, IPropertyPage2)
        INIT_INTERFACE_PART(CSlobPage, PropertyPage)
        STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE);
        STDMETHOD(Activate)(HWND, LPCRECT, BOOL);
        STDMETHOD(Deactivate)();
        STDMETHOD(GetPageInfo)(LPPROPPAGEINFO);
        STDMETHOD(SetObjects)(ULONG, LPUNKNOWN*);
        STDMETHOD(Show)(UINT);
        STDMETHOD(Move)(LPCRECT);
        STDMETHOD(IsPageDirty)();
        STDMETHOD(Apply)();
        STDMETHOD(Help)(LPCOLESTR);
        STDMETHOD(TranslateAccelerator)(LPMSG);
        STDMETHOD(EditProperty)(DISPID);
    END_INTERFACE_PART(PropertyPage)

    // IPropertyNotifySink
    BEGIN_INTERFACE_PART(PropNotifySink, IPropertyNotifySink)
        INIT_INTERFACE_PART(CSlobPage, PropNotifySink)
        STDMETHOD(OnRequestEdit)(DISPID);
        STDMETHOD(OnChanged)(DISPID);
    END_INTERFACE_PART(PropNotifySink)

    DECLARE_INTERFACE_MAP()

protected:
    // m_nValidateID is set to the ID of a control that will need to be validated
    // by Validate() as soon as that control has been changed.  It will
    // be NULL if nothing needs to be validated.  This will mainly be
    // used by edits and combos that are normally validated when they
    // loose the focus.  Needs to be in here for the Escape accelerator.

    int m_nValidateID;

    BOOL m_bIgnoreChange:1;
    BOOL m_bEnabled:1;

protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    void LoadDlgTemplate (UINT nIDSheet);
    DECLARE_MESSAGE_MAP()
};

void StringEditorEditToProp(char* szBuf, int *len);
void StringEditorPropToEdit(CString& str);

/////////////////////////////////////////////////////////////////////////////
// List and Combo Box Enumerations...

// One entry in an enumeration
struct CEnumerator
{
    const char* szId;
    int val;
};

class CPropCheckList;

// An enumeration
class CEnum
{
public:
    virtual void FillListBox(CListBox* pWnd, BOOL bClear = TRUE, CSlob* = NULL);
    virtual void FillCheckList(CPropCheckList* pWnd, BOOL bClear = TRUE, CSlob* = NULL);
    virtual void FillComboBox(CComboBox* pWnd, BOOL bClear = TRUE, CSlob* = NULL);

    virtual BOOL ContainsVal(int val);
    virtual POSITION GetHeadPosition();
    virtual CEnumerator* GetNext(POSITION& pos);

    virtual CEnumerator* GetList()
        { VSASSERT(FALSE, "override of GetList required"); return(NULL); };

    virtual int GetCount ();
    virtual BOOL FindStringID (int val, CString & strID); 
    virtual HRESULT GetPredefinedStrings (CALPOLESTR* pCaStringsOut,CADWORD* pCaCookiesOut);
};


// this is a enum designed to store its strings in the string table

// One entry in a localized enumeration
struct CLocalizedEnumerator
{
    CLocalizedEnumerator( UINT aId, int aVal );
    ~CLocalizedEnumerator();
    CString szId;
    UINT id;
    int val;
};

// A localized enumeration
class CLocalizedEnum : public CEnum
{
public:
    CLocalizedEnum (){};

    virtual void FillListBox(CListBox* pWnd, BOOL bClear = TRUE, CSlob* = NULL);
    virtual void FillCheckList(CPropCheckList* pWnd, BOOL bClear = TRUE, CSlob* = NULL);
    virtual void FillComboBox(CComboBox* pWnd, BOOL bClear = TRUE, CSlob* = NULL);

    virtual BOOL ContainsVal(int val);
    virtual POSITION GetHeadPosition();
    virtual CLocalizedEnumerator* GetNextL(POSITION& pos);
    virtual CEnumerator* GetNext(POSITION& pos)
        { VSASSERT( FALSE, "You must use GetNextL()" ); return (NULL); };
    virtual CLocalizedEnumerator *GetListL()
        { VSASSERT( FALSE, "You must override GetListL" ); return (NULL); };
    virtual int GetCount ();
    virtual BOOL FindStringID (int val, CString & strID); 
    virtual HRESULT GetPredefinedStrings (CALPOLESTR* pCaStringsOut,CADWORD* pCaCookiesOut);
    virtual void GetOSDependantLangNeutral(CString & strLangNeutral);
};

// A sorted localized enumeration
class CLocalizedEnumEx : public CLocalizedEnum
{
public:
    CLocalizedEnumEx () : bUseVerLanguageName(TRUE), bIsSorted(FALSE) {};

    virtual void InitList();
    static int CompareEnumerator(const CLocalizedEnumerator * lhs, const CLocalizedEnumerator * rhs);

    //HACK - for language enumerations, we need to call VerLanguageName instead of using the contents of szId.
    unsigned bUseVerLanguageName    : 1;
    unsigned bIsSorted              : 1; 
};


// Helper macros for making enumerations
#define DECLARE_ENUM_LIST() \
    public: \
    virtual CEnumerator* GetList() \
                { return &c_list[0]; } \
    static CEnumerator c_list [];

// Define the enumerator identifiers and values in this table
#define BEGIN_ENUM_LIST(theClass) \
    CEnumerator theClass::c_list [] = {

#define END_ENUM_LIST() \
    { NULL, 0 } };

// Define a simple CEnum derived class
#define DEFINE_ENUM(theEnum) \
    class C##theEnum : public CEnum { DECLARE_ENUM_LIST() }; \
    C##theEnum NEAR theEnum; \
    BEGIN_ENUM_LIST(C##theEnum)

#define DECLARE_ENUM(theEnum) \
    class C##theEnum : public CEnum { DECLARE_ENUM_LIST() }; \
    extern C##theEnum NEAR theEnum;

// Helper macros for making localized enumerations
#define DECLARE_LOCALIZED_ENUM_LIST() \
    public: \
    virtual CLocalizedEnumerator* GetListL() \
                { return &c_list[0]; } \
    static CLocalizedEnumerator c_list [];

// Define the enumerator identifiers and values in this table
#define BEGIN_LOCALIZED_ENUM_LIST(theClass) \
    CLocalizedEnumerator theClass::c_list [] = {

// A localized enumeration entry
#define LOCALIZED_ENUM_ENTRY(id,val) \
    CLocalizedEnumerator( id, val ),

#define END_LOCALIZED_ENUM_LIST() \
    CLocalizedEnumerator( 0, 0 ) };

// Define a simple CLocalizedEnum derived class
#define DEFINE_LOCALIZED_ENUM(theEnum) \
    class C##theEnum : public CLocalizedEnum { DECLARE_LOCALIZED_ENUM_LIST() }; \
    C##theEnum NEAR theEnum; \
    BEGIN_LOCALIZED_ENUM_LIST(C##theEnum)

#define DECLARE_LOCALIZED_ENUM(theEnum) \
    class C##theEnum : public CLocalizedEnum { DECLARE_LOCALIZED_ENUM_LIST() }; \
    extern C##theEnum NEAR theEnum;

#define DEFINE_LOCALIZED_ENUM_EX(theEnum) \
    class C##theEnum : public CLocalizedEnum \
{ \
public: \
    static C##theEnum & GetObject() \
    { \
    static C##theEnum s_enum; \
    return s_enum; \
    }; \
    virtual CLocalizedEnumerator * GetListL() \
    { \
        static CLocalizedEnumerator c_list [] = { 
        

#define END_LOCALIZED_ENUM_EX() \
    CLocalizedEnumerator( 0, 0 ) }; \
    CLocalizedEnumerator* pEnum = c_list; \
    while (pEnum->id != 0) \
    { \
        BOOL bOK = pEnum->szId.LoadString(pEnum->id); \
        VSASSERT(bOK, "Failed to load string!  Are the resources initialized properly?"); \
        pEnum++; \
    } \
    return &c_list[0];  \
    } ; \
};

#define DEFINE_LOCALIZED_ENUM_EX2(theEnum) \
    class C##theEnum : public CLocalizedEnumEx \
{ \
public: \
    static C##theEnum & GetObject() \
    { \
    static C##theEnum s_enum; \
    return s_enum; \
    }; \
    virtual CLocalizedEnumerator * GetListL() \
    { \
        static CLocalizedEnumerator c_list [] = { 
        
#define END_LOCALIZED_ENUM_EX2() \
    CLocalizedEnumerator( 0, 0 ) }; \
    char sz [1024]; \
    CLocalizedEnumerator* pEnum = c_list; \
    if (bIsSorted) \
        return c_list; \
    bIsSorted = TRUE; \
    CString strLangNeutral; \
    GetOSDependantLangNeutral(strLangNeutral); \
    while (pEnum->id != 0) \
    { \
        VerLanguageName(pEnum->val, sz, 100); \
        if (strLangNeutral.Compare(sz)) \
        { \
            pEnum->szId.Empty(); \
            pEnum->szId = sz; \
        } \
        else \
        { \
            if (0 != pEnum->val && 2048 != pEnum->val) \
            { \
                CString str; \
                str.Format(IDS_LANG_ID, pEnum->szId); \
                pEnum->szId.Empty(); \
                pEnum->szId = str; \
            } \
            else \
            { \
                BOOL bOK = pEnum->szId.LoadString(pEnum->id); \
                VSASSERT(bOK, "Failed to load string!  Are the resources initialized properly?"); \
            } \
        } \
        pEnum++; \
    } \
    pEnum = c_list; \
    qsort(pEnum + 3, GetCount() - 3, sizeof(CLocalizedEnumerator), reinterpret_cast<int (__cdecl *)(const void *, const void *)>(CompareEnumerator)); \
    return &c_list[0];  \
    } ; \
};

/////////////////////////////////////////////////////////////////////////////
// Property Browser API

#define WM_USER_VALIDATEREQ (WM_USER + 3)

void SetPropertyBrowserVisible(BOOL bVisible); // show/hide and set visible state
void ShowPropertyBrowser(BOOL bShow = TRUE);   // show/hide (temporary)
BOOL IsPropertyBrowserVisible();               // visibility test
void PinPropertyBrowser(BOOL bPin = TRUE);     // toggles the pushpin when visible
BOOL IsPropertyBrowserPinned();                // pinned test
void ResetPropertyBrowserSelectionSlob(CSlob* pSlob);

void InvalidatePropertyBrowser();              // repaint property browser
void UpdatePropertyBrowser();                  // force page to reflect selection
BOOL ValidatePropertyBrowser();                // validate pending changes
void ActivatePropertyBrowser();                // activate and show
void DeactivatePropertyBrowser();              // return focus to the app
void CancelPropertyBrowser();                  // cancel changes
void ClosePropertyBrowser();                   // really just hides it and sets popping off
BOOL BeginPropertyBrowserEdit(UINT nProp,      // edit a specific property
    UINT nChar = 0, UINT nRepeat = 0, UINT nFlags = 0);
BOOL BeginPropertyGridEdit(UINT dispid,         // edit a specific property
    UINT nChar = 0, UINT nRepeat = 0, UINT nFlags = 0);

CWnd* GetPropertyBrowserControl(UINT nID);     // get a control on for the current object
C3dPropertyPage* GetNullPropertyPage();        // get null page (has ID controls)
C3dPropertyPage* GetCurrentPropertyPage();     // current propert page
void SetPropertyBrowserDefPage();              // make the currect page the default
BOOL IsPropertyBrowserInCancel();              // did the user just cancel
BOOL IsPropertyBrowserValidating();            // is the page being validated
BOOL FlipToPage (CString str);                 // flipping to another page

// Methods used during CSlob::SetupPropertyPages()
int AddPropertyPage(C3dPropertyPage* pPage, CSlob* pSlob);
void SetPropertyCaption(LPCTSTR sz);
BOOL AppendExtraPropertyPages(void);
BOOL InhibitExtraPropertyPages(BOOL bInhibit = TRUE);
int StartNewPropertyPageSet(void);
int MergePropertyPageSets(void);

//#undef AFX_DATA
//#define AFX_DATA NEAR

#endif // __PROPPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\shlmenu.h ===
/////////////////////////////////////////////////////////////////////////////
//      SHLMENU.H
//

#ifndef __SHLMENU_H__
#define __SHLMENU_H__

#ifndef NO_CMDBARS
#include <afxtempl.h>
#endif

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA

struct MTM
{
    UINT id;
	UINT idString;
	struct POPDESC* ppop;
};

#pragma warning(disable:4200)
struct POPDESC
{
	UINT strID;
	UINT cmdID;
	MTM rgmtm [0];
};
#pragma warning(default:4200)

#define POP_NIL									0
#define POP_IDS_NIL								0
#define POP_SEPARATOR							UINT(-1)

#define MENU_CONTEXT_POPUP(name)				&pop##name

// We distinguish two types of menus. Command menus are the proper customisable ones that
// go on the bar. POPUP menus are the context ones
#define BEGIN_POPUP_MENU(name)					static POPDESC pop##name = { 0, 0,
#define BEGIN_POPUP_MENU_(name, id)				static POPDESC pop##name = { id, 0, 
#define BEGIN_COMMAND_MENU_(name, idm)			static POPDESC pop##name = { 0, idm, 
#define END_POPUP_MENU()						POP_NIL, POP_IDS_NIL, NULL };

#define MENU_GROUP(idg)							idg, POP_IDS_NIL, NULL,
#define MENU_POPUP(idg, name)					idg, POP_IDS_NIL, &pop##name,
#define MENU_ITEM(idm)							idm, POP_IDS_NIL, NULL,
#define MENU_ITEM_(idm, ids)					idm, ids, NULL,
#define MENU_SEPARATOR()						POP_SEPARATOR, POP_IDS_NIL, NULL,

// Use MenuFileText to correctly generate path text for use in menus.
// Ampersands in filenames must be doubled.

void MenuFileText(CString& str);

/////////////////////////////////////////////////////////////////////////////
//      CContextPopupMenu
//              Support for context popup menus

void ShowContextPopupMenu(POPDESC* ppop, CPoint pt);

struct CTE;

class CContextPopupMenu : public CMenu
{
public:
	static  CContextPopupMenu* CreateNewSubPopup(CContextPopupMenu* pParent);

public:
	CContextPopupMenu();
	~CContextPopupMenu();

	void Create(POPDESC* ppop = NULL);

	void AddItem(UINT id, LPCTSTR lpszText = NULL);
	void AddSubMenu(CContextPopupMenu*, LPCTSTR lpszText);
	BOOL TrackPopup(UINT flags, int x, int y, CWnd* pOwner );
	BOOL LoadMenu(UINT nID);

	void SetPos(int nPopupPos); // must have been loaded from resource

private:
	int m_idgPrev;
	CObList* m_pListSubMenus;
	BOOL m_bPopup;    // using menu resource
	int m_nPopupPos; // position of current popup submenu in the menu resource
};

#ifndef NO_CMDBARS
// REVIEW(DaleRo): Sure would be nice not to have to expose all this to
//                 package partners.  We should review why this is necessary
//                 and try to support it in some other way.

class CBMenuPopup ;

/////////////////////////////////////////////////////////////////////////////
/*
   Each menu item consists of four fields.
      Button   |  Name  |  Accel    |  Arrow
      (fixed)     (var)    (var)       (fixed)
			  2 Pixels      1 char          2 Pixels 
	 c_iButtonTextGap               e_FieldGap.
			  
   The menuitem and the menu communcate the widths and rects for
   these fields using arrays of values index by these enums.

   e_FieldAll is the index for the rectangle that covers the whole menu item.
   e_FieldGap is the width of the gap in between these fields.

  30 May 96 - The word command bars do not put the accelerators at the end of
  the longest menu item. Like windows. Instead they find the size of the longest
  menu item and then right justify the accelerator onto that.

  To support this style of menu, I added the e_FieldNameAccel field. This field is
  used to determine maximum width of a menu item treating the Name and Accel as
  one unit.

  This field is only used inside of CBMenuPopup. CBMenuItem does not know or care about
  this field.

  To go back to the old way #define _FIELD_ALIGN_ACCEL_.

  _FIELD_ALIGN_ACCEL is NOT defined currently! If you define it change this comment
  or else!.
  
	I added the e_FieldText to hold the 

*/
   const int c_iFieldWidthUnknown = -1 ;
   const int c_iNumFields = 7 ;
   enum FieldTypes { e_FieldAll = 0 ,
		     e_FieldButton = 1,
		     e_FieldName = 2,
		     e_FieldAccel = 3,
		     e_FieldArrow = 4,
		     e_FieldGap = 5, // The Gap is used for returns from GetWidths.
					 e_FieldNameAccel = 6 
		     }  ;


/////////////////////////////////////////////////////////////////////////////
//      CBMenuItem

class CBMenuItem 
{
	friend class CMenuPopupProxy;
public:
	enum MenuItemType 
	{
		MIT_Unknown		= 0,
		MIT_Command		= 1,
		MIT_Separator	= 2,
		MIT_Popup		= 3
	};



	// Contruction
	CBMenuItem() ;
	virtual ~CBMenuItem() ;

	// Creation
	BOOL Create(CBMenuPopup* pMenuWnd, UINT nCmdID, CString strName) ;
	// Creation
	BOOL CreatePopup(CBMenuPopup* pMenuWnd, CBMenuPopup* pMenuPopup, CString strName) ;
	// Creation for a menu item whose menu is in the global menu table
	BOOL CreatePopup(CBMenuPopup* pMenuWnd, UINT nCmdID, CString strName);
	// Creation for a menu item whose type is determined by the global command table
	BOOL CreateDynamic(CBMenuPopup* pMenuWnd, UINT nCmdID, CString strName,	BOOL bShowGlyph, HBITMAP hbmCustom);
	BOOL CreateSeparator() ;

	// Attributes
	void Check(BOOL bChecked); 
	BOOL IsChecked() {return m_bChecked;}
	BOOL IsVisible() {return m_bVisible;};
	void SetVisible(BOOL bVisible) { m_bNeedToCalculateSizes=TRUE; m_bVisible=bVisible; };

	UINT Enable(BOOL bEnable) ;
	BOOL Show(BOOL bShow) ;
	// Updates the text (item + accel, separated by tab), and recalcs menu
	void SetText(LPCTSTR lpszText) ;
	// updates accelerator, and optionally recalcs menu     
	void SetAccelerator(LPCTSTR lpszAccel, BOOL bRecalc=TRUE) ;

   // Operation

   //
   // This is the old IMenuItem Interface
   //
   int GetItemType() {return m_iItemType;}
   CBMenuPopup* Expand(BOOL bExpand) ;
   void Select(BOOL bSelect) ;
   void Draw(CDC* pDC, CRect rectFields[c_iNumFields]); 
   void DrawSeparator(CDC* pdc, const CRect* pRect);
   // determines a possible hit, given a scroll offset
   BOOL HitTest(CPoint pt, int cyOffset);
   UINT Click() ;

   UINT GetCmdID() {return m_nCmdID;}
   CString GetName() {return m_strName;}
   CBMenuPopup* GetPopup() {return m_pMenuPopup ;}

   void Release() ;

   BOOL ModifyItem(	UINT nNewCmdID,
					LPCTSTR lpszNewItem, 
					CBMenuPopup* pNewPopup, 
					int iNewItemType);

   void Sync() ;

   void GetWidths(CDC* pdc, /*out*/ int** pRect) ;
   int GetHeight(CDC* pdc) ;
   
   BOOL GetDefault(void) { return m_bDefault; };
   void SetDefault(BOOL bDefault);

   //
   //
   //
   //Members
   //
   //
   //
   int m_iItemType ;
   CString m_strName ;
   CString m_strAccel ;

   UINT m_nCmdID ;
   CBMenuPopup* m_pMenuWnd;						// Window of the menu that contains this item

   unsigned int m_bSelected : 1;
   unsigned int m_bChecked : 1;
   unsigned int m_bGrayed : 1;
   unsigned int m_bVisible : 1;
   unsigned int m_bCustomGlyph : 1;                         // true if the HBITMAP inside this item is not the default and should be saved
   unsigned int m_bCustomText : 1;							// true if the text inside this item is not the default and should be saved
   unsigned int m_bTransient : 1;                                     // true if the item has been temporarily added
   unsigned int m_bDefault : 1;								// true if the item is drawn in bold (default)
   unsigned int m_bExpanded : 1;
   unsigned int m_bNeedToCalculateSizes : 1;
   unsigned int m_bUpdated : 1;
   unsigned int m_bTextModified : 1;						// TRUE if the text of this item has been modified since it came from the command table

	static CBitmap s_bmpCheckMark;
	static CSize s_sizeCheckMark ;
	static CSize s_sizeCmdGlyph;

	// Popup
	static CBitmap s_bmpArrow ;
	static CSize s_sizeArrow ;

	// removed cached sizes
	static void FlushSizeCache();
	// and recalculate them
	static void EnsureSizeCache();


   // Glyph
   HBITMAP m_hbmCmdGlyph ;
   HBITMAP m_hbmOriginalGlyph;      // contains the original command glyph if the glyph had to be scaled to fit 
								   // the current button size

   // Popup Members
   CBMenuPopup* m_pMenuPopup ;
   CTE *m_pCTE;                                         // we are caching a copy of this here for efficiency reasons

   // Fields
   int m_iHeight ;
   int m_iFieldWidths[c_iNumFields] ; // Caches the widths desired for each field.
   CRect m_rectFields[c_iNumFields] ; // Holds the rects for each field from the last Draw.

   // OnCommandUpdate Menu handlers can do all sorts of nasty things like
   // delete menu items. We need to be able to track such changes to keep the menu
   // code in sink.
   void Updated(BOOL bUpdated)
	{ m_bUpdated = bUpdated; }

   BOOL Updated()
	{ return m_bUpdated ; }

	void UpdateGlyph() ;

	BOOL IsTextModified(void) { return m_bTextModified; };								// TRUE if text was modified since creation/command table update
	void SetTextModified(BOOL bTextModified) { m_bTextModified=bTextModified; };

protected:
	// helper function during creation
	// bCustom is TRUE if the glyph is custom (and a candidate for saving and resetting)
	void SetGlyph(HBITMAP hbmSource, int nIndex, BOOL bMustCopy, BOOL bCustom);

	// Other Helpers
	void CalcSizes(CDC* pdc) ;
	void ParseOutAccelerator(CString strWhole) ;

};


/////////////////////////////////////////////////////////////////////////////
// CBMenuPopup window

class CForwardMouseMessage ;

class CBMenuPopup : public CWnd
{
	friend CBMenuItem ;
	friend class CMenuPopupProxy;

private:
	using CWnd::Create;

// Construction
public:
	CBMenuPopup();

// Attributes
public:
   static BOOL IsCBMenuCmdUI(CCmdUI* pCmdUI) ;

   enum {
      HT_MISSED = -1,
      HT_HITSELECTEDITEM = -2
   };
// Operations
public:
	// xOffset and yOffset are the extra ammounts to move the menu by if it is to overflow
	// the screen from its current position. This allows menus that are dropping from 
	// command bar buttons to not be placed over their command bar button martynl 05May96
   // Der - TrackDropDownMenu replaces TrackPopupMenu for drop down menus.

	static CTypedPtrList<CObList, CBMenuPopup *> s_listMenus;

	// the screen coordinates point where the last MouseMove was processed. We skip if we've processed a move 
	// very close to this before - stabilizes joint keyboard and mouse usage.
	static CPoint s_ptLastMove;

	static CFont *GetMenuFont(BOOL bDefault);

	UINT TrackDropDownMenu(int x, int y, 
							CWnd* pWnd, 
							LPCRECT lpRect = 0 , 
							CRect rectAvoid=CRect(0,0,0,0),
							CWnd* pWndMenuBar = NULL,			// Pointer to window to a window to forward the mouse/keys.
							BOOL bSelectFirstItem =FALSE,		// Select the first menu item. Required for menu keyboard ui.
							BOOL *pbBarFocus=NULL,				// OUT parameter, explains whether the calling bar should be re-focussed after the menu
							BOOL bReturnCmd=FALSE				// IN param. If true, menu should return command without posting
							);
	
   UINT TrackPopupMenu( UINT nFlags, int x, int y, 
			CWnd* pWnd, LPCRECT lpRect = NULL);
   
   // Internal Function...
   UINT TrackMenu( UINT nFlags, int x, int y, 
		   CWnd* pWnd, LPCRECT lpRect = 0 , CRect rectAvoid=CRect(0,0,0,0), BOOL bSelectFirstItem=FALSE);

   // possibly dubious way to handle the parenting issue with submenus. Temporary solution, hopefully.
   inline void SetParent(CWnd *pParent) { m_pParentWnd=pParent; };
   inline void SetAutoEnable(BOOL bAuto) { m_bAutoEnable=bAuto; };
   inline CWnd *GetParent() { return m_pParentWnd; };

   // DER! Add Reference Counting!
   void Release() {delete this;}

   // Array Access
   CBMenuItem* GetMenuItem(int index) ;
   void AddMenuItem(int index, CBMenuItem* pMenuItem) ;

   //
   // CMenu Simulation Functions
   //
   BOOL CreateMenu() ;
   BOOL CreatePopupMenu(CWnd* pParentWnd) ;
   BOOL DeleteMenu(UINT nPosition, UINT nFlags) ;
   void DeleteAll();
   BOOL AppendMenu(UINT nFlags, UINT nIDNewItem = 0, 
		   LPCTSTR lpszNewItem = NULL,
		   CBMenuPopup* pSubPopup = NULL);       
   int GetMenuString(UINT nIDItem, CString& rString, 
		     UINT nFlags) const;
   CBMenuPopup* GetSubMenu(int nPos) const;
   BOOL InsertMenu(UINT nPosition, UINT nFlgs, 
		   UINT nIDNewItem = 0, 
		   LPCTSTR lpszNewItem = NULL,
		   CBMenuPopup* pSubPopup = NULL, 
		   BOOL bTransient=FALSE);       
   // Note: MergeMenu empties pSection of items
   BOOL MergeMenu(UINT nPosition, UINT nFlags, CBMenuPopup* pSection);
   UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable) ;
   UINT ShowMenuItem(UINT nIDEnableItem, UINT nShow);

   BOOL ModifyMenu(UINT nPosition, UINT nFlags, 
		   UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL,
		   CBMenuPopup* pSubPopup = NULL);       
   void RemoveCommandReferences(UINT id);

   HGLOBAL GetData();
   BOOL SetData(HGLOBAL hglob);

   UINT GetMenuItemCount( ) const { return m_nMaxIndex ; } // Used by CTypedRecentFileList::UpdateMenu

	UINT GetMenuItemID(int nPos) ;
	BOOL ContainsMenu(int nCmdID);

	// Determine if the menu is a dropdown menu or not. This has been used by packages.
	BOOL IsDropDown() {return m_bDropDown;};

   // Used to for cbverb.cpp
   BOOL IsSubPopup() {return m_bSubPopup;} // Returns true if menu is a subpopup.

	// Proxy handlers
	// When it is visible, a menu has a proxy. Or when the proxy is manually allocated
	void AllocateProxy();
	void FreeProxy();
	CMenuPopupProxy* GetProxy();

   inline int GetCount() { return m_nMaxIndex; };

   // this is the 'full height' of the menu
   int GetHeight();
   // this is the height of the window containing the menu
   int GetWindowHeight(void);
   int GetWidth();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBMenuPopup)
	public:
	//}}AFX_VIRTUAL
protected:
	virtual BOOL Create(CWnd* pParentWnd, POINT pt, BOOL bSubPopup = FALSE, CRect* prectAvoid =NULL);
   //virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) ;
	virtual void PostNcDestroy() ;

   DECLARE_DYNAMIC(CBMenuPopup)

//
// Implementation
//
public:
	void Initialize();
	virtual ~CBMenuPopup();

	//
	// Keyboard UI
	//

	// Show Expanded
	// these act immediately
	void HideSubPopup() ;
	void ShowSubPopup(int nItem);
	void ScrollMenu(BOOL bForward, BOOL bEnd);
	// down one item
	void ScrollMenuDown();
	// up one item
	void ScrollMenuUp();
	// to first item at top
	void ScrollMenuTop();
	// to last item at bottom
	void ScrollMenuBottom();
	// make selected menu item scroll into view
	void EnsureSelectionScrolled();

	// these act after a timer fires
	void DeferHideSubPopup() ;
	void DeferShowSubPopup(int nItem);
	void DeferScrollMenuDown(BOOL bInitial);
	void DeferScrollMenuUp(BOOL bInitial);
	void EndDefer(void);
	void EndScrollDefer(void);
	// hittests the scrolling area and defers a scroll if appropriate. If bInitial is true, the delay is longer
	void DoScroll(CPoint pt, BOOL bInitial);

	// This synchronises the selection with the currently expanded item, and recurses upwards
	void SelectExpanded(void);

	// If TRUE is returned, the key should be passed to the menu bar
	BOOL ForwardRightKey() ;
	void ForwardUpKey() ;
	void ForwardDownKey() ;
	void ForwardHomeKey() ;
	void ForwardEndKey() ;
	UINT ForwardReturnKey() ;
	UINT ForwardCharKeyDown(TCHAR keychar, BOOL *bUseCmd);
	void KeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);

   //
   // Subpopup Navigation
   //

   CBMenuPopup* FindNextToLastChild();
   CBMenuPopup* FindLastChild();

	// This is returned from DoMouseMove. These constants can be added.
	enum {
		cMoveUnhandled=0,               // Message needs to be handled by parent
		cMoveHandled=1,                 // Message Does not need to be handled elsewhere
		cMoveSelectExpanded=2   // Message requires parent to select the expanded item
	};

	int DoMouseMove(UINT nFlags, CPoint pt); // returns a combination of the above flags
	UINT DoLButtonUp(UINT nFlags, CPoint point) ;
	BOOL DoLButtonDown(UINT nFlags, CPoint point) ;

	void InitMenuPopup() ;
	void MainFrameInitMenuPopup() ; // Copied from MainFrame.

	// Modal Support...
	BOOL ContinueModal();
	void DoModal(int x, int y) ;
	void Done(UINT nCmdID = NULL) ;
	void MessageLoop();

	// Find the menu item corresponding to the point.
	int HitTest(CPoint pt) ;
	// Determine if the point is in any menu or the menu bar.
	BOOL PtInMenus(CPoint pt) ;

	// Helpers
	void CalcMenuSize() ;
	void VerifyMenuSize(BOOL bAlways) ; // Checks if toolbar glyphs have changed. 
	int GetMenuIndexForCommand(UINT nCmdId) const;
	void InvalidateItem(int nIndex);
	CRect GetItemRect(int nIndex);
	void GetItemsRect(CRect *pRect);

	// finds the next visible item after the one specified
	int FindNextVisibleItem(int nIndex, BOOL bForward);

	void AdjustMenuSize(CBMenuItem* pItem) ;

	void SelectFirstItem();      // TrackDropDownMenu uses this function to
							// select the first menu item when moving with the keyboard.
	inline BOOL IsDirty() { return m_bDirty; };
	inline BOOL IsPainted() { return m_bPainted; };

	// Number of visible non-separators, or -1 if unknown, -2 during calculation
	int m_nVisibleItems;

   // The menu can be modified in OnCommandUpdate handlers. We need some extra
   // information to determine if we have been changed or not.
   void ChangedByOnUpdate(BOOL bChanged)	// The menu has changed.
	{m_bChanged = bChanged ;}
   
   BOOL ChangedByOnUpdate()						// Has the menu changed?
	{return m_bChanged ; }
   
   BOOL m_bChanged ;							// Variable.

	// returns true if this menu is participating in customization
	BOOL IsCustomizing(void);

	// Use this to hide any submenu which has this id, or indirectly contains this id
	void HideInvalidMenuDestination(UINT nId);

	// returns TRUE if this menu, or one of its submenu, contains the specified command id
	BOOL ContainsMenu(UINT nId);

	// Flushes all cached menu size information
	void FlushSizeCache();

	// Sets whether the menu wants to see its cancellation
	void SetPassBackCancel(BOOL bPassBack) { m_bPassBackCancel=bPassBack; };

	// Call when a click could not be a system double click part 1
	static void ClearSystemClick(void);
	// call to tell a menu about the first part of a system click
	static void SetSystemClick(int nTime, CPoint ptScreen);

	// called when colours have been changed
	static void SysColorChange(void);

//Members
protected:
	static BOOL s_bCreateTransients;		// When true, all menu items created get their m_bTransient flag set

   typedef CTypedPtrArray <CPtrArray, CBMenuItem*> CMenuItems;
   CMenuItems m_MenuItems ;
   int m_nExpandedMenuItem; // index of the item whose subpopup is expanded. Subpopups only
							// contract when the mouse moves over another subpopup item, or when the
							// menu is closed
   int m_nExpandDeferredItem; // item to which deferred expand timer refers
   int m_nSelectedMenuItem; // Index of selected item.
   int m_nMaxIndex ;            // The index of the first empty slot.
   BOOL m_bPainted;				// TRUE if the menu has been painted. Set false by create
   BOOL m_bBarFocus;            // True if focus should be returned to the bar
   BOOL m_bAutoEnable;			// TRUE if the menu item should be enabled even if no command handler can be found
   CSize m_sizeDesired;         // The height of all the items and the width of the widest
   BOOL m_bSelectFirstItem;		// TRUE if the first item of the menu needs to be selected

   CWnd* m_pWndMenuBar;         // The window which acts like a menubar to the popup menu.
							// The popup forwards mouse and keyboard messages to this
							// window. This window is in charge of closing the menu.
   BOOL m_bSubPopup ;
   CWnd* m_pParentWnd ;
   CBMenuPopup* m_pChildPopup ;
   CRect m_rectAvoid;		// Screen coords rect to avoid when placing menu

   // Modal
   BOOL m_bContinueModal ;

   // This is the ID of the currently active timer, or 0 if there isn't one. Used for
   // delaying appearance of subpopups
   int m_nCurrentTimer;

   UINT m_nPostCmdID ; // Command ID to send to m_pParentWnd;
   BOOL m_bReturnCmdID; // If true, TrackXXX returns the command id, rather than posting the message. TPM_RETURNCMD

   BOOL m_bControl;

   // Large Toolbars
   BOOL m_bLargeToolbar ;

   BOOL m_bDirty;				// true if this has been modified since it was saved.

   // Field Widths
   int m_iHeight;
   int m_iFieldWidths[c_iNumFields] ;

   class CMenuPopupProxy* m_pProxy;

	// Drop Down Support
	BOOL m_bDropDown ; // True if TrackDropDownMenu Called False otherwise.

	// The following pointer is used to forward mouse messages on when the user
	// clicks outside of the window.
	CForwardMouseMessage* m_pForwardMsg;
	// TRUE if cancellation in the menu bar should still be forwarded
	BOOL m_bPassBackCancel;

	// Menus now support scrolling. 
	BOOL m_bScrolling;							// TRUE if this menu is required to scroll
	BOOL m_bHasTopScroll;						// TRUE if the top scroll area is present
	BOOL m_bHasBottomScroll;					// TRUE if the bottom scrolling area is present
	int m_nTopIndex;							// index of the top visible menu item, after the scroll area
	int m_cyTopOffset;							// Coordinate offset of items.

	static BOOL s_bLastWasKey;					// TRUE if the last proper input the menu processed was keyboard
	static BOOL s_bSuppressedMouseMove;			// TRUE when a single mouse move is suppressed just after dropping the menu
	static CBitmap s_bmpScrollDown;				// syscolour loaded bitmap of the scroll down arrow
	static CBitmap s_bmpScrollUp;				// syscolour loaded bitmap of the scroll up arrow
	static CSize s_sizeScroll;					// size of the scroll arrows (assumed to be same)

	// System click handling
	// This is the last time the MDI system icon was clicked
	static int s_nLastSystemClick;
	static CPoint s_ptLastSystemClick;

	// Generated message map functions
protected:
	//{{AFX_MSG(CBMenuPopup)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnPaint();
	afx_msg int OnCreate( LPCREATESTRUCT lpCreateStruct );
	afx_msg void OnDestroy( );
    afx_msg LRESULT OnTestMenu(WPARAM wParam, LPARAM lParam);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnKillFocus(CWnd *);
	//}}AFX_MSG
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

#ifdef _DEBUG
public:
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
//      CBContextPopupMenu
//              Command bar version of CContextPopupMenu

class CBContextPopupMenu : public CBMenuPopup
{
private:
	using CBMenuPopup::Create;

public:
			CBContextPopupMenu();
			~CBContextPopupMenu();

	void    Create(POPDESC* ppop = NULL);

	BOOL AddItem(UINT id, LPCTSTR lpszText = NULL);
	void    AddSubMenu(CBContextPopupMenu*, LPCTSTR lpszText, UINT id = 0);
	UINT    TrackPopup(UINT flags, int x, int y, CWnd* pOwner );
	//BOOL  LoadMenu(UINT nID);
	//void  SetPos( int nPopupPos ); // must have been loaded from resource
	static  CBContextPopupMenu* CreateNewSubPopup(CBContextPopupMenu* pParent);

private:
	int             m_idgPrev;
	CObList*        m_pListSubMenus;
	BOOL    m_bPopup;    // using menu resource
	int             m_nPopupPos; // position of current popup submenu in the menu resource
};

extern void CBShowContextPopupMenu(POPDESC* ppop, CPoint pt, CWnd* pParent = NULL);

////////////////////////////////////////////////////////////////////////////////////
//
//OLD_MENU Backward compatibility menu mode support
// Grep for OLD_MENU.
// Menu is a namespace.
namespace Menu
{
void UseHMENU(BOOL bUseOldWindowsMenu) ;
BOOL IsInCmdBarMode() ;
BOOL IsShowingCmdBars() ;
void UpdateMode(BOOL bUpdateNow);
void UseOLE(BOOL bStart);
};

#endif // !NO_CMDBARS

//#undef AFX_DATA
//#define AFX_DATA NEAR

#endif // !__SHLMENU_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\shldocs.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLDOCS.H
//		Document and view base classes for packages.

#ifndef __SHLDOCS_H__
#define __SHLDOCS_H__

struct FINDREPLACEDISK;

class CSlob;

#include "path.h"
#include "slob.h"

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
//	Classes defined in this header file
//	class CMultiDocTemplate;
		class CPartTemplate;
//	class COleDocument;
		class CPartDoc;
//	class CView;
//		class CSlobWnd;
			class CPartView;
//	class CMDIChildWnd;
		class CPartFrame;

      
/////////////////////////////////////////////////////////////////////////////
//	CPartTemplate
//		Base doc template class for packages.

class CPartTemplate : public CMultiDocTemplate
{
	DECLARE_DYNAMIC(CPartTemplate)

public:
   // File New Tab Type Enumeration
   enum FileNewTabType
   { 
      newnone, 
      newfile, 
      newtemplate, 
      newproject, 
      newworkspace, 
      newother 
   };
   
// Constructors
public:
	CPartTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pViewClass, LPCTSTR szAutoType);
	~CPartTemplate();
	
	// setup for OLE containers
	void SetContainerInfo();
	
	REFCLSID GetTemplateClsid() { return m_clsid; }
	LPCTSTR GetTemplateAutomationType() { return m_strAutoType; }

	virtual Confidence MatchDocType(LPCTSTR pszPathName,
					CDocument*& rpDocMatch);

	// Save all the templates docs.  If bQuery is true, then ask
	// fisrt.  nFlags allows the filters
	BOOL SaveAll(BOOL bQuery = FALSE, UINT nFlags = 0);

	virtual CDocument* OpenDocumentFile(const TCHAR* pszPathName,
		BOOL bMakeVisible = TRUE);
	virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
		BOOL bMakeVisible = TRUE);
	virtual CFrameWnd* CreateNewFrame( CDocument* pDoc, CFrameWnd* pOther ); 
	virtual CView * CreateNewView (CDocument * pDoc, HWND hwndParent, int x, int y, int cx, int cy);
	virtual CDocument* OpenDocumentFile(const TCHAR* pszPathName,
		HWND hwndParent, int x, int y, int cx, int cy);

	// Override to validate path for file creation (called from File.New dialog)
	virtual BOOL CanCreateDocument(const TCHAR* pszPathName) { return(TRUE); }

   // GetTabType returns an enum that indicates which tab to go on.
   // default impl. returns newfile, iff GetDocString() returns valid string
   virtual FileNewTabType GetTabType();
	
// Attributes
public:
	enum FileNewTab { Files, Templates };
	FileNewTab	m_TabName;  // Tab name can be 'Files' or 'Templates', default is 'Files'

protected:
	CLSID		m_clsid;
	CString		m_strAutoType;
	UINT		m_nIconID;

	friend class CPartDoc;
};

#define FILTER_NONE        0x0000
#define FILTER_DEBUG       0x0001
#define FILTER_PROJECT     0x0002
#define FILTER_NON_PROJECT 0x0004
#define FILTER_NEW_FILE    0x0008
#define FILTER_PROJ_RC     0x0010
#define FILTER_DOCUMENT    0x0020

/////////////////////////////////////////////////////////////////////////////
//	CPartDoc
//		Base document class for packages.

class CPartDoc : public COleDocument
{
private:
	using COleDocument::OnSaveDocument;

public:
	CPartDoc();
	DECLARE_DYNCREATE(CPartDoc)

// Attributes
public:
	virtual BOOL IsReadOnly();
	virtual BOOL IsReadOnlyEx(BOOL bHandleError = TRUE);
	virtual void SetReadOnly(BOOL bReadOnly = TRUE);
	virtual BOOL IsReadOnlyOnDisk(void) const { return m_bReadOnlyOnDisk; }
	virtual void SetReadOnlyOnDisk(BOOL bReadOnlyOnDisk) { m_bReadOnlyOnDisk = bReadOnlyOnDisk; }
	
	void SetModifiedFlag(BOOL bModified = TRUE);
	virtual BOOL GetValidFilters(UINT** paIDS, UINT* pnInitial);

	virtual BOOL IsFiltered(UINT nFlags);
	virtual BOOL FDisplayTitle()	{return FALSE;}
	
// Operations
public:
	virtual void ActivateDoc();
	virtual BOOL AttemptCloseDoc();
	virtual BOOL SaveModified();

// Implementation
public:
	virtual ~CPartDoc();
	virtual BOOL DoSave(const TCHAR* pszPathName, BOOL bReplace = TRUE);
	virtual BOOL Replace(const TCHAR* pszPathName, UINT nSaveType = 0);
	virtual void Serialize(CArchive& ar);	// overridden for document i/o
	virtual CSlob* GetSlob();

#ifdef _DEBUG
	virtual	void AssertValid() const;
	virtual	void Dump(CDumpContext& dc) const;
#endif
public:
	// The shell needs to be able to do processing either before or after
	// a document is created, opened, saved, or closed. 
	// This is required mainly so the shell can fire Ole Automation events.
	// Therefore, packages should not override the MFC virtual functions
	// On*Document. Instead the packages should override the functions
	// *Document. 

	// Packages should not override any of the following functions!
	// I repeat don't override these functions!
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(const TCHAR* pszPathName);
	virtual BOOL OnSaveDocument(const TCHAR* pszPathName, UINT nSaveType = 0);
	// Call this to close the document. In its default implementation it will call PreCloseDocument and OnCloseDocument.
	virtual void OnCloseDocument();

protected:
	// Packages should override the following functions.
	virtual BOOL NewDocumentHook();
	virtual BOOL OpenDocumentHook(const TCHAR* pszPathName);
	virtual BOOL SaveDocumentHook(const TCHAR* pszPathName, UINT nSaveType = 0);
	virtual void CloseDocumentHook();
	
	// The following functions are called by the shell after the
	// shell calls the functions above which actually does the real work.
	// These functions main purpose in life is to fire automation events.
	// BTW, we can change them to virtuals at a later date if neccessary.
	BOOL PostNewDocument(BOOL bResult) ;
	BOOL PostOpenDocument(BOOL bResult) ;
	BOOL PostSaveDocument(BOOL bResult) ;
	virtual void PreCloseDocument(); 	// called before closure, while document is still valid

	// If derived classes need to bypass the shell's implementations and
	// get to MFC's implementation, they should call the following functions.
	BOOL ParentNewDocumentHook();
	BOOL ParentOpenDocumentHook(const TCHAR* pszPathName);
	BOOL ParentSaveDocumentHook(const TCHAR* pszPathName, UINT nSaveType = 0);
	void ParentCloseDocumentHook();

	virtual BOOL CanCloseFrame(CFrameWnd *pFrame);
	virtual void SetDocString(UINT nID) { m_nIDString = nID; }
	virtual LPCTSTR GetDefaultTitle()
					{ return m_strTitle; }

public:
	virtual BOOL GetDocString(CString& rString,
		enum CDocTemplate::DocStringIndex index) const;
	
	virtual LONG_PTR GetDocLong(int nVar);
	virtual LONG_PTR SetDocLong(int nVar, LONG_PTR lData);
	
protected:
	BOOL m_bReadOnly;
	BOOL m_bReadOnlyOnDisk;

	UINT m_nIDString;
	CPartTemplate* m_pProxyTemplate;

// DER - added afx_msg to following...
// Generated message map functions
protected:
	//{{AFX_MSG(CPartDoc)
	afx_msg void OnFileSaveAs();
	afx_msg void OnFileSave();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	static BOOL CanSaveAll();

private:
	static CPartDoc* s_pSavableDoc;
};

//	GetDocLong enum
//		The shell reserves values less than 1000 for GetDocLong.
//		Packages may define values >= 1000 to allow other packages
//		to set values within their documents.  Useful for doc
//		template proxying.

enum
{
	GDL_PROXYTEMPLATE						= 100,
	GDL_CMP_CANCLOSE_CALLBACK				= 1001
};


/////////////////////////////////////////////////////////////////////////////
//	CPartView view
//		View base class for package documents.
//		(For dockable windows, see below.)

class CPartView : public CSlobWnd
{
protected: // create from serialization only
	CPartView();
	DECLARE_DYNCREATE(CPartView)

// Attributes
public:
	CPartDoc* GetDocument();
	virtual CPartTemplate* GetDocTemplate();

    virtual CSlob* GetSelection() { return NULL; }
    virtual CSlob* GetEditSlob() { return NULL; }

	virtual BOOL IsDependent() { return FALSE; }
	virtual BYTE* GetInitData() { return NULL; }

	virtual DWORD GetHelpID() { return 0; }
	virtual BOOL GetHelpWord(CString& strHelp) { return FALSE; }
	virtual	BOOL SetDialogPos(BOOL fFirstTime, HWND hDlg);

	virtual void OnNewPalette()
		{ }

	virtual int GetAssociatedFiles(CStringArray & saFiles, BOOL bSelected = TRUE);

#ifndef NO_VBA
	virtual LPDISPATCH GetSelectionObject(LPDISPATCH pdisp = NULL);
#endif	// NO_VBA

// Operations
public:
	virtual ~CPartView();
	
	virtual BOOL CanClose();

	virtual void OnLoadWorkspace(); // called when loaded from workspace
	virtual void OnFindNext(BOOL* pbSuccess = NULL); // called for a find

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);
//TODO
//    virtual void RecalculateIME();

	// Find and Replace operations:
	// These should be overriden by the view.
	// FirstSearch means that this search will be the first
	// in a (possible) subsequent serie of searches. The view should
	// remember where it started so that it can stop searching when
	// all the document has been searched.
	// Return value: TRUE if the string is found,
	//      FALSE if the string is not found, or if SearchStyle is
	//		"ContinueSearch" and all the document has been searched once.
	virtual BOOL FindString(FINDREPLACEDISK *pfr);

	// MarkAll: marks all occurrences of the search string (for instance, 
	// the source editor puts a bookmark on each line)
	virtual BOOL MarkAll(FINDREPLACEDISK *pfr);
		
	// ReplaceString: If bReplaceAll is TRUE, the view should do that.
	// Otherwise, if the selection equals szFind, replace the text,
	// then call FindNext or FindPrev.
	virtual BOOL ReplaceString(FINDREPLACEDISK *pfr, BOOL bReplaceAll);

	// GetFindSelectionRect: Returns the rect (in screen coords) of the selection, 
	// so that the find dialog can move out of the way.
	virtual BOOL GetFindSelectionRect(CRect* prc);

	// GetFindString: Provides the string used to initialize the Find What field.
	// This is used in Edit.Find, Edit.Replace
	virtual BOOL GetFindString(CString& rstr);

	// GetFindReplaceFlags: Allows the view to disable find, replace, regular expressions, etc.
	virtual BOOL GetFindReplaceFlags(DWORD *pdwFlagsFind, DWORD *pdwFlagsReplace);

	// GetSelectionInterface: get the view's guid, and an interface for 
	// selection and state information.
	// REVIEW(davidga): I don't like the name.  How about GetStateInfoInterface
	// Note: bobz this will AddRef the piUnk
	virtual BOOL GetSelectionInterface(GUID* pguid, IUnknown** ppiUnk);

	// (bobz) for cases where we just want to identify the editor
	virtual BOOL GetEditorID(GUID* pguid)
	{
		IUnknown* piUnk = NULL;
		BOOL fRet = GetSelectionInterface(pguid, &piUnk);
		if (fRet)
		{
			VSASSERT(piUnk != NULL, "Selection interface is NULL!");
			if (piUnk != NULL)	// overkill but defensive - bobz
				piUnk->Release();
		}
		return fRet;
	}

//TODO
//protected:
//	CPacket* m_pPacket;

// Generated message map functions
protected:
	//{{AFX_MSG(CPartView)
	afx_msg void OnEditFind();
	afx_msg void OnEditFindPrev();
	afx_msg void OnEditFindNext();
	afx_msg void OnToggleFindCase();
	afx_msg void OnToggleFindRE(void);
	afx_msg void OnToggleFindWord(void);
	afx_msg void OnToggleSearchAllDocs(void);
	afx_msg void OnUpdateFindReplace(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToggleMatchCase(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToggleMatchWord(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToggleSearchAllDocs(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToggleMatchRegEx(CCmdUI* pCmdUI);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPartTemplate;

	friend class CPartFrame;

protected:
	// Find helper function
	BOOL DoFind();
};

#ifndef _DEBUG	// debug version in partvw.cpp
inline CPartDoc* CPartView::GetDocument()
   { return (CPartDoc*) m_pDocument; }
#endif

// FindInString: This function will use the FINDREPLACEDISK 
// variable to figure out if it should be using Reg Expressions, Case
// sensitivity and whole word matching, and to know what to search for.
BOOL FindInString(FINDREPLACEDISK *pfr, const TCHAR *szBuf,
	BOOL backwardsSearch,
	/* in/out */ const char **pszStart, /* out */ ULONG *pcbSize);

/////////////////////////////////////////////////////////////////////////////
//	CPartFrame
//		MDI child frame base class for packages.

struct WORKSPACE_INFO
{
	CPartFrame* pWnd;
	BYTE* pInitData;
	BYTE* pCurData;
};



class CPartFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CPartFrame)

private:
	using CMDIChildWnd::OnUpdateFrameMenu;

// Static workspace variables.
public:
	static BOOL s_bLockFrame;

	static void LockFrame(BOOL bLock);
	static void LockFrame(HWND hwndAfter);
	static void SetInitData(BYTE* pData);

// Construction
public:
	CPartFrame();
	virtual ~CPartFrame() ;	

// Attributes.
public:
	HWND m_hwndView;
	virtual void ActivateFrame(int nCmdShow = -1);
	virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd, 
		HMENU hMenuAlt);

	virtual BOOL IsDependent();
	virtual BYTE* GetInitData();
	virtual CString GetWorkspaceMoniker(BOOL bRelative);
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual void OnNewPalette();

	// Closes this window
	void CloseFrame() ;

// Message handlers	
protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	//{{AFX_MSG(CPartFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd*, CWnd*);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg LRESULT  OnEnterSizeMove(WPARAM, LPARAM);
	afx_msg LRESULT OnExitSizeMove(WPARAM, LPARAM);
	afx_msg void OnMenuSelect( UINT nItemID, UINT nFlags, HMENU hSysMenu );
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// c_bFirstCtrlTab, MDINextWindow, PreTranslateMessage, and 
	// OnSysCommand are used to customize the way Ctrl+Tab switches 
	// between document windows.  The 'new' way works more like Alt+Tab 
	// in that alternative uses cause the top-most two windows to toggle 
	// positions, but continuous usage (without releasing the Ctrl key) 
	// cycles between all document windows.
	//
	// If bLinear is true, then it works like a normal next window command. This is what the window menu versions do,
	// and what would be useful for automation, etc.
	//
public:
	void MDINextWindow(BOOL bNext, BOOL bLinear=FALSE);

protected:
	static HWND s_hwndAfter;

	// DocObject support
	// We need these to group the activation process
	static BOOL s_bInActivation;
	static BOOL s_bInDocObjClose;

public:
	static CPartFrame *s_pLastActiveFrame;
};

// Helper for GetWindow cycling of MDI.
extern BOOL IsValidMDICycleMember(CWnd* pWnd);
// Helper function that Activates an ExistingDoc
extern CPartDoc* ActivateExistingDoc(LPCTSTR lpszFileName,	CDocTemplate* pTemplate);

//#undef AFX_DATA
//#define AFX_DATA NEAR

#endif // __SHLDOCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\shlsrvc.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLSRVC.H
//		Various services provided by the shell.

#ifndef __SHLSRVC_H__
#define __SHLSRVC_H__

#ifndef __DLGBASE_H__
#include "dlgbase.h"
#endif

#ifndef __SHLBAR_H__
#include "shlbar.h"
#endif

#ifndef __AFXCMN_H__
#include "afxcmn.h"
#endif

//////////////////////////////////////////////////////////////////////////
// Header files which need to be merged with shlsrvc.h

#include "fmtinfo.h"

//////////////////////////////////////////////////////////////////////////

class CPartView;

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

//////////////////////////////////////////////////////////////////////////
// Status Bar API

void ShowStatusBar(BOOL bShow = TRUE);
BOOL IsStatusBarVisible();
BOOL IsStatusBarIndicator(UINT nID);
int  GetStatusBarHeight();
void InvalidateStatusBar(BOOL bErase = FALSE);
void ClearStatusBarSize();
void ClearStatusBarPosition();
void ClearStatusBarPositionAndSize();
void ResetStatusBar();
void SetStatusBarPosition(const CPoint& pos);
void SetStatusBarSize(const CSize& size);
void SetStatusBarPositionAndSize(const CRect& rect);
void SetStatusBarZoom(int zoom);
void SetStatusBarLineColumn(int line, int column, BOOL fForce = FALSE);
void SetStatusBarOffsetExtent(long lOffset, long lExtent);
void SetStatusBarOverStrike(BOOL bOverStrike);
void StatusBeginPercentDone(const char* szPrompt);
void StatusEndPercentDone();
void StatusPercentDone(int percentDone);
void StatusOnIdle();

/////////////////////////////////////////////////////////////////////////////
// CSushiBarInfo
//

typedef struct tagSTATINFO
{
	UINT nID;
	int nGroup;
	int nBitmap;
} STATINFO;

class CSushiBarInfo : public CObject
{
public:
	CSushiBarInfo(const UINT FAR* pIndicators = NULL, int cIndicators = 0,
	              STATINFO FAR* pBitmaps = NULL, int cBitmaps = 0);

	const UINT FAR* m_pIndicators;
	int m_cIndicators;

	STATINFO FAR* m_pBitmaps;
	int m_cBitmaps;
};

///////////////////////////////////////////////////////////////////////////////
//	Find  and replace

#define FDS_WHOLEWORD	0x00000001
#define FDS_MATCHCASE	0x00000002
#define FDS_REGEXP		0x00000004
#define FDS_MARKALL		0x00000008
#define FDS_SEARCHALL	0x00000010

#define LIMIT_FIND_COMBO_TEXT 250	// Magic number based on line length limit.

//Find/Replace : Type of pick list
typedef enum { reZibo, reUnix, reBrief, reEpsilon } reSyntax;

extern reSyntax g_reCurrentSyntax;

//Find/Replace : Structure Definition (saved on disk)
struct patType;

// TODO(CFlaat): split the cursed FINDREPLACEDISK structure into two parts, one for global
//    find options and another to represent options for an individual find operation

struct FINDREPLACEDISK
{
	patType *pat;					// Compiled regular expression
	BOOL regExpr;					//Regular expression

	void DisposeOfPattern(void);
	BOOL CompileRegEx(reSyntax syntax);

	BOOL matchCase;					//Match Upper/Lower case
	BOOL bWasLineMatch;  // whether the last regex search was a BOL or EOL match
	BOOL wholeWord;
	BOOL goUp;						// Search direction
	BOOL loop;						// Loop when reaches the end (equivalent to NOT search all open documents)
	BOOL startFromCursor;			// start from cursor or from the beginning
									// (or from the end if going backwards)

	char findWhat[LIMIT_FIND_COMBO_TEXT + 1];		//Input string
	char replaceWith[LIMIT_FIND_COMBO_TEXT + 1];	//Output string
	int nbReplaced;							//Actual number of replacements

	//Construction
	FINDREPLACEDISK();
	~FINDREPLACEDISK();
};

extern FINDREPLACEDISK AFX_DATA findReplace;

// GetRegExprSyntax: Allow a package to determine the default syntax
//  for regular expression searches in response to user input.
//  Valid syntaxes are: reUnix, reBrief, reEpsilon
reSyntax GetRegExprSyntax(void);

/*
	GetCurrentRegexHintTable

	This function returns an array of regex hint->string mappings for
	the current editor emulation.  In the future we should use a safer
	means for doing this.
*/
LPCTSTR *GetCurrentRegexHintTable(void);

#ifdef NOTDEF
//use src\common\inc\regexp.h instead
typedef char flagType;
// RECompile: regular expression compiler. Returns a compiled expression
// that must be freed by the caller. The returned expression can
// then be used as an argument to RESearch or you can set the 'pat'
// member of a FINDREPLACEDISK struct that is passed to FindInString(...)
patType *RECompile(char *szRegExpr, flagType fCase, reSyntax);

// RESEarch: performs a Regular expression search
BOOL RESearch(
	LPCTSTR line,
	ULONG *ichStart,	// byte index into line
	ULONG *xEnd,
	patType *pat,		// pointer to reg expression
	LPCTSTR szString,
	/* out */ BOOL *pbLineMatch);
char			 RETranslate (struct patType *,char *,char *);
int			 RETranslateLength (struct patType *,char *);
#endif //NOTDEF

/////////////////////////////////////////////////////////////////////////////
//
// Text pattern recognition routines
//

// don't hittest
#define NO_HITTEST ULONG_MAX

/////////////////////////////////////////////////////////////////////////////
//	Goto
//		The following two class definitions provide goto support, generally
//		available to all packages.

class CGoToItem;
class CGotoDialog;

enum GOTO_TYPE {goGoTo, goNext, goPrevious};
#define dwItemDataInvalid ((DWORD)(-1))

// CGoToDialog dialog

class CGoToDialog : public C3dDialog
{
	DECLARE_DYNAMIC(CGoToDialog)

public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	// Construction
	CGoToDialog(UINT idHelp, LPCTSTR szItemInit, CWnd* pParent = NULL);   // constructor
    ~CGoToDialog();
	
	// call this from CPackage:AddGoToItems for each item to add (editor-
	// specific items should be added even if the right kind of editor 
	// is not currently added.
	void AddItem(CGoToItem *pItemNew);

	// call this from the CGoToItem callbacks to change the style of buttons
	// being used. (This must be called from CGoToItem::OnSelectWhat at the very least!)
	enum BUTTON_STYLE { bsGoTo, bsNextPrev };
	void SetButtonStyle (BUTTON_STYLE buttonstyle);

	// call this from the CGoToItem callbacks to change the style of selection control
	// being used. (This must be called from CGoToItem::OnSelectWhat at the very least!)
	enum CONTROL_STYLE { csUninit = -1, csEdit, csDropList, csDropCombo, csNone };
	void SetControlStyle (CONTROL_STYLE controlstyle);
	 
	// call this to change the selection prompt. (This must be called from 
	// CGoToItem::OnSelectWhat at the very least!)
	void SetPrompt (const TCHAR * szPrompt);
	 
	// call this to change the helper text. If not called from 
	// CGoToItem::OnSelectWhat it will be blank by default.
	void SetHelperText (const TCHAR * szHelperText);

	// call this to enable or disable dialog controls depending on whether the item
	// can be active besed on the active editor. This is called internally after
	// CGoToItem::CanGoViewActive is called. Ignored if pGoToItem is not the current
	// selection in the Go To What list.
	void SetItemEnabled(CGoToItem *pGoToItem, BOOL fEnabledItem);

	// call this to empty the selection list when csDropList or csDropCombo are used.
	void EmptyList ();

	// call this to add a string to the selection list
	void AddString (const TCHAR * szSelect, DWORD dwItemData = 0);

	// call this to lock/unlock the selection list when csDropList or csDropCombo are used.
	// while the control is being filled.
	void LockList (BOOL fLock = TRUE);

	// call this to get the dialog id of the "selection control" in the rara
	// case when the List and Select functions are not adequate
	// pcs will be set to the control style of the control, since it can be
	// either and edit control . a combo or a list box. Use GetDlgItem to 
	// get a pointer to the selection control.
	int IdCtlSelection (CONTROL_STYLE *pcs);

	// call one of these to initialize the current selection control
	void Select (const TCHAR * szSelect);
	void Select (int iSelect);

	// call this when a CGoToItem::OnSelectChange needs to change the button state
	// OR the msk values into grfButton to set the state of one or more buttons
	#define mskButtonGoToNext	(0x0001)
	#define mskButtonPrevious	(0x0002)
	#define mskButtonClose		(0x0004)
	#define mskButtonHelp		(0x0008)

	void EnableButton (WORD grfButton, BOOL fEnable = TRUE);

// Dialog Data
	//{{AFX_DATA(CGoToDialog)
	enum { IDD = IDD_GOTODIALOG };
	CComboBox	m_gotoCombo;
	CStatic	m_helpText;
	CStatic	m_gotoCaption;
	CListBox	m_gotoWhat;
	CListBox	m_gotoList;
	CEdit	m_gotoEdit;
	//}}AFX_DATA

public:
	CPartView* m_pActiveView;  // reset when gotowhat selection changes and after OnGoTo

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGoToDialog)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	CToolTipCtrl m_tooltip;

//	void OnOK( void );
	void OnCancel( void );	

// Implementation
public:
	virtual void PostNcDestroy();
	virtual BOOL OnHelpInfo(HELPINFO* pInfo); 

public:
	// static member!
	static CGoToDialog * c_pGotodialog; // used to prevent multiple instances of modeless dialog
	static CGoToDialog * PGoToDialogCur();   // returns c_pGotodialog
	BOOL m_fInInitDialog;  // true only while initdialog processing. Some items behave differently in that case
	CToggleBitmapButton	m_btnPushPin;  // subclassed via Autoload call
	void GotoCtlSel();

private:
	CWnd * m_pctlSelection;  // pointer to current edit, list or combo used to select destination
	CONTROL_STYLE m_csSelection;
	CGoToItem * m_pGoToItemCur;
	BUTTON_STYLE m_bsCur;
	CString m_strItemInit;  // item string to select in goto what list at startup
	// cLock... is a sentinal so the modeless dialog can reset up itself when you click away from the dialog
	// but do not reselect when the dialog loses focus for errors/asserts etc
	int m_cLockSelectAtActivate; // counter (for nesting). If non-zero, do not reselect when dialog is activated.
	int m_cBusyNoClose; // counter (for nesting). If non-zero, disallow closing dialog since goto operation still in progress.
	BOOL m_fFirstMoveMsg;
	BOOL m_fForcePinForHelp;

private:
	void GetSelectData(CString &strData, 
			DWORD *pdwItemData, 
			int *pidSelect,
			BOOL *pfSelInList,
			BOOL fComboSelChanged); 

	void OnOKPrevious(GOTO_TYPE go); 
	BOOL DoInitDialog(void);
	void DoSelchangeGoToWhat(); 

protected:
	// Generated message map functions
	//{{AFX_MSG(CGoToDialog)
	afx_msg void OnSelchangeGoToList();
	afx_msg void OnSelchangeGoToWhat();
	afx_msg void OnSelchangeGoToCombo();
	afx_msg void OnPrevious();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeGoToEdit();
	afx_msg void OnEditchangeGoToCombo();
	afx_msg void OnActivate(UINT nState, CWnd *pWndOther, BOOL bMinimized);
	afx_msg void OnMove(int cx, int cy);
	afx_msg void OnGotoGotoAndNext();
	afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// CGoToItem
//  subclassed in each package that adds an entry to the Go To What listbox
//  in a CGoToDialog dialog

class CGoToItem 
{
public:
	CGoToItem(CGoToDialog * pDlg);

	// ***Initialization. These functions are used to initialize the Go To 
	// dialog. THey will be called when the dialog is invoked but may
	// actually be called at any time.

	// REQUIRED: Return the string to show in the Go To What listbox

	virtual const TCHAR * GetItemString() = 0;

	// ***Callbacks. These functions are called as the user manipulates the Go To
	// dialog or active editor view

	// Called when the item is selected in the Go To What listbox,
	// and at CGoToDialog startup and reactivation.
	// CGoToDialog will call CanGoViewActive after returning from this
	// call, so let it handle situational enabling/disabling

	// Note that this function needs to be able to tolerate a NULL m_pDlg->m_pActiveView
	// or one of the incorrect type. It should set what it can and leave other controls empty.

	// Do not put up error messages or dialogs during this function, as it can be called when focus
	// is changing. If you need to check a state that might bring up such a message it would be better
	// to enable the goto button and check at CanGoTo or OnGoTo rather than doing it here

	virtual void OnSelectWhat();

	// Called when the active editor changes. A FALSE return indicates that the
	// item should not be enabled in the dialog for this editor, TRUE indicates
	// that the item may be active in this editor view.

	virtual BOOL CanGoViewActive(CPartView* pActiveView);

	// Called when the selection control changes (either the user changed
	// the text in the edit control or they selected something from the
	// drop list). For csEdit style selection controls, the fSelInList
	// and dwItemData parameters should be ignored (FALSE/-1 will always 
	// be passed here).
	// fSelInList will be true if there is an item selected in the list 
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the 
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	// generally used for simple test like handling empty strings

	virtual void OnSelectChange	(const TCHAR * szSelect, 
								BOOL fSelInList,
								DWORD dwItemData);

	// Override this to indicate whether or not a go to operation can be
	// attempted. Done when an action button is hit.
	// For goNext and goPrevious operations, the szSelect 
	// and dwItemData items are not used.
	// For goGoTo operations, they describe the string and optional
	// user-data selected in the Go To dialog.
	// fSelInList will be true if there is an item selected in the list 
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the 
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	// pDlg and idDlgItemError are used to return focus to in case of error

	virtual BOOL CanGoTo(int idDlgItemError, 
						GOTO_TYPE go, 
						const TCHAR * szSelect, 
						BOOL fSelInList,
						DWORD dwItemData);


	// Override this to handle a go to operation. For goNext and goPrevious
	// operations, the szSelect and iSelList, and dwItemData items are not used. For goGoTo
	// operations, they describe the string and optional listbox user-data
	// selected in the Go To dialog, and the list selection, if any.
	// fSelInList will be true if there is an item selected in the list 
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the 
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	virtual void OnGoTo(GOTO_TYPE go,
						const TCHAR * szSelect,
						BOOL fSelInList,
						DWORD dwItemData);

public:
	CGoToDialog *m_pDlg; // set during construction
};

void DoGoToDialog(int iddHelp, LPCTSTR szItemInit);

/////////////////////////////////////////////////////////////////////////////
//	Dockable Windows support

#define IDTB_PACKAGE_BASE		(0x7500)
#define IDTB_CUSTOM_BASE        (0x7800)	// No base IDs greater than this!
/////////////////////////////////////////////////////////////////////////////

#define IS_STATE_DEBUG(x)		(x & 1)

//	Styles.

#define INIT_VISIBLE	   0x00000001L	// Make visible when registered.
#define INIT_CANHORZ 	   0x00000002L	// Can reside in horizontal dock.
#define INIT_CANVERT	   0x00000004L	// Can reside in vertical dock.
#define INIT_POSITION	   0x00000008L	// No floating position given.
#define INIT_ASKAVAILABLE  0x00000010L	// Hide/show on idle depending on availability.
#define INIT_AVAILABLE	   0x00000020L	// Internal use only for layout.
#define INIT_MDI		   0x00000040L	// MDI window.
#define INIT_DESKPLACE	   0x00000080L  // We have MDI window placement info.
#define INIT_DOCKPLACE	   0x00000100L  // We have CDockWnd placement info.
#define INIT_DOCKSERIAL    0x00000200L	// We have absolute CDockWnd placement info.
#define INIT_LASTAVAILABLE 0x00000400L	// Used for AskAvailable stretchy windows.
#define INIT_NODESTROY     0x00000800L  // Don't destroy window on Hide (dtEdit windows only).
#define INIT_STRETCHSIZE   0x00001000L	// Init struct has a size for stretching.
#define INIT_TRANSPOSE_SIZE 0x00002000L	// When docking use vertical size for horizontal dock.
#define INIT_REMOVE			0x00008000L	// To remove old workers from layout.
#define INIT_HOST			0x00010000L  // True if the window is the host of an embedded window (internal)

#define DWS_STRETCHY       0x00000001L	// Stretch to fit in dock.
#define DWS_SIZABLE		   0x00000002L	// Snap sizing when in palette.
#define DWS_8SIZABLE	   0x00000004L	// Snap sizing with corners.
#define DWS_MENUBAR        0x00000008L  // Stretches in top dock, wraps as needed, repels invaders

//	Messages.

// Window messages.  Handle for enhanced functionality.  You must register this
// yourself in your dll.  To do so, copy the following definitions.
//		UINT DWM_GETDATA = RegisterWindowMessage("DockGetWindowData");
//		UINT DWM_GETMOVESIZE = RegisterWindowMessage("DockWndMoveSize");
//		UINT DWM_GETTRACKSIZE = RegisterWindowMessage("DockWndTrackSize");
//		UINT DWM_ENABLECHILD = RegisterWindowMessage("DockEnableChild");
//		UINT DWM_SHOWWINDOW = RegisterWindowMessage("DockShowWindow");
//		UINT DWM_CLOSE = RegisterWindowMessage("DockWndClose");

extern UINT DWM_GETDATA;		// Sent to the window to get initialization data.
extern UINT DWM_GETMOVESIZE;	// Allows window to change size on dock position.
extern UINT DWM_GETTRACKSIZE;	// Allows window to control snap sizing.
extern UINT DWM_ENABLECHILD;	// Disable children for toolbar customizing.
extern UINT DWM_SHOWWINDOW;		// Notification of visibility state change.

// Datatypes.

enum DOCKPOS
{
    dpNil,
    dpTop,		// Top through Hide must be in order.
    dpBottom,
    dpLeft,
    dpRight,
    dpHide,
	dpMDI,
    dpCurrent,
	dpHorzInit,
	dpVertInit,
	dpEmbedded
};

#define dpFirst 1	// These refer to Top through Hide.
#define dpCount 5

enum DOCKTYPE
{
	dtNil,
	dtHwnd,
	dtWindow,
	dtToolbar,
	dtBorder,
	dtEdit,
	// a toolbar embedded in another window
	dtEmbeddedToolbar,
};

enum UPDATE_SHOW {
	updNow,
	updNoRecalc,
	updDelay
};

enum MAX_STATE {
	stateMaximize,
	stateRestore,
	stateDisabled,
};

#define _MAX_DOCK_CAPTION 63

#pragma pack(2)
struct DOCKINIT {
	UINT nIDWnd;
	UINT nIDPackage;
	UINT nIDPacket;
	char szCaption[_MAX_DOCK_CAPTION + 1];
	DWORD fInit;	// Initialization flags.
	DOCKTYPE dt;
    DOCKPOS dpInit, dpPrev;

    RECT rectFloat;		// Accessed only if !INIT_POSITION
	SIZE sizeStretch;	// Accessed only if INIT_STRETCHSIZE
};

struct TOOLBARINIT {
	UINT nIDWnd;        // full (MAKEDOCKID) docked window id - including package id and window id
	int nIDCount;
};
#pragma pack()

// Function prototypes.

HGLOBAL DkInfoData(UINT nInfoCount, DOCKINIT FAR* lpInfoArray);
HGLOBAL DkToolbarData(const TOOLBARINIT* ptbi, const UINT FAR* lpIDArray);
BOOL DkRegisterWnd(HWND hwnd, DOCKINIT* pDockInit);
BOOL DkRegisterToolbar(DOCKINIT* pdi, TOOLBARINIT* ptbi, UINT FAR* lpIDArray);
#ifdef NOTDEF
BOOL DkPreHandleMessage(HWND hwnd, UINT message,
	UINT wParam, LPARAM lParam, LRESULT* lResult);
#endif
#define MAKEDOCKID(pkg, id) MAKELONG(id, pkg)

DOCKPOS DkWGetDock(UINT nID);
void DkWShowWindow(UINT nID, BOOL bShow);
void DkWToggleMDIState(UINT nID);
void DkWMoveWindow(UINT nID, DOCKPOS dp, LPCRECT lpRect);
void DkWGetTitle(UINT nID, CString& str);
void DkWSetTitle(UINT nID, const CString& str);
void DkWRemove(UINT nID);
// call this to embed a bar in a docking window
HWND DkWEmbed(UINT nID, HWND hwndHost);
// Once the embedding host is created, it should call this to complete the association
void DkWAssociate(UINT nID, UINT nIDHost);
MAX_STATE DkWGetMaxState(UINT nID);
void DkWMaximizeRestore(UINT nID);

void DkWMapDockingCmd(UINT nID, UINT nCmd);
void DkWHandleDockingCmd(UINT nCmd, BOOL bToggle, CCmdUI* pCmdUI = NULL);

void DkRecalcBorders(CWnd* pWnd);

int DkGetDockState();
void DkSetDockState(int nState, int nMask = 1);
void DkShowManager(BOOL bShow, UPDATE_SHOW update = updNow);
BOOL DkDocObjectMode(BOOL bShow);
void DkUpdateAvailableWnds(BOOL bUpdateNow = FALSE);
void DkLockWorker(BOOL bLock);

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __SHLSRVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\shlbar.h ===
/////////////////////////////////////////////////////////////////////////////
//      SHLBAR.H
//              All shell toolbar related classes.  For customizable docking
//              toolbars use the mechanism provided by the Dock API.

#ifndef __SHLBAR_H__
#define __SHLBAR_H__

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
//      COldToolBar
//              Toolbar class from MFC 3.0 before they switched to system toolbars.
//              We continue to draw our own toolbars.

// Warning, these structures are currently still shared with the res package toolbars.
#ifndef _AFX_TBBUTTON_DEFINED
struct AFX_TBBUTTON
{
	UINT nID;        // Command ID that this button sends
	UINT nStyle;    // TBBS_ styles
	int iImage;     // index into mondo bitmap of this button's picture
						// or size of this spacer
};
#define _AFX_TBBUTTON_DEFINED
#endif

#ifndef _ORIENTATION_DEFINED
enum ORIENTATION {
	orNil,
	orHorz,
	orVert };
#define _ORIENTATION_DEFINED
#endif

// ORIENTATION has been promoted from CCustomBar to CToolbar, so that GetItemRect can take an orientation
// parameter. This allows GetItemRect to depend on orientation directly, rather than through hacks, as
// previously. For CToolBars, ORIENTATION should always be orHorz

class COldToolBar : public CControlBar
{
	DECLARE_DYNAMIC(COldToolBar)

private:
	using CControlBar::Create;

// Construction
public:
	COldToolBar();
	BOOL Create(CWnd* pParentWnd,
			DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP,
			UINT nID = AFX_IDW_TOOLBAR);

	void SetSizes(SIZE sizeButton, SIZE sizeImage);
				// button size should be bigger than image
	void SetHeight(int cyHeight);
				// call after SetSizes, height overrides bitmap size
	void SetDefaultSizes();
				// sets the sizes to their default UISG values
				// does not cause any redrawing
	static CSize GetDefaultBitmapSize();
				// returns the size of a standard toolbar bitmap
	static CSize GetDefaultButtonSize();
				// returns the size of a standard toolbar button
	BOOL LoadBitmap(LPCTSTR lpszResourceName);
	BOOL LoadBitmap(UINT nIDResource);
	BOOL SetButtons(const UINT* lpIDArray, int nIDCount);
				// lpIDArray can be NULL to allocate empty buttons

// Attributes
public: // standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	// this is provided for compatability with other clients. In subclasses it is overridden privately
	// and never implemented, to avoid problems
	inline void GetItemRect(int nIndex, LPRECT lpRect) const { GetItemRect(nIndex, lpRect, GetOrient()); };
	virtual void GetItemRect(int nIndex, LPRECT lpRect, ORIENTATION or) const;
	virtual ORIENTATION GetOrient() const;
	UINT GetButtonStyle(int nIndex) const;  //REVIEW: doc
	void SetButtonStyle(int nIndex, UINT nStyle);   //REVIEW: doc

public:
	// for changing button info
	void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const;
	void SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage);

// Implementation
public:
	virtual ~COldToolBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// update the text of a button
	virtual void UpdateText(int nIndex, LPCTSTR newText) {};

	// get the image well
	HBITMAP GetImageWell(void) { return m_hbmImageWell; };

	// cmdui needs to know this
	int GetCaptureIndex(void) { return m_iButtonCapture; };
	// kills extrusion, capture, etc
	void CancelMode(void) { OnCancelMode(); };

protected:
	AFX_TBBUTTON* _GetButtonPtr(int nIndex) const;
	void InvalidateButton(int nIndex);
	virtual void UpdateButton(int nIndex);
	void CreateMask(int iImage, CPoint offset, 
		BOOL bHilite, BOOL bHiliteShadow);

	// for custom drawing
	struct DrawState
	{
		HBITMAP hbmMono;
		HBITMAP hbmMonoOld;
		HBITMAP hbmOldGlyphs;
	};
	BOOL PrepareDrawButton(DrawState& ds);
	BOOL DrawButton(CDC* pDC, int x, int y, int iImage, UINT nStyle, BOOL bOutlineOnly=FALSE, CRect *pImageBounds=NULL);
#ifdef _MAC
	BOOL DrawMonoButton(CDC* pDC, int x, int y, int dx, int dy,
		int iImage, UINT nStyle);
#endif
	void EndDrawButton(DrawState& ds);

protected:
	CSize m_sizeButton;         // size of button
	CSize m_sizeImage;          // size of glyph
	int m_cxSharedBorder;       // shared x border between buttons
	int m_cySharedBorder;       // shared y border between buttons
	HBITMAP m_hbmImageWell;     // glyphs only
	int m_iButtonCapture;       // index of button with capture (-1 => none)
	HRSRC m_hRsrcImageWell;     // handle to loaded resource for image well
	HINSTANCE m_hInstImageWell; // instance handle to load image well from

#ifdef _MAC
	// Macintosh toolbars need per-toolbar DCs in order to
	// work correctly in multiple-monitor environments

	HDC m_hDCGlyphs;            // per-toolbar DC for glyph images
	HDC m_hDCMono;              // per-toolbar DC for mono glyph masks
#else
public:
	static HDC s_hDCGlyphs;     // shared DC for glyph images
	static HDC s_hDCMono;		// shared DC for mono glyph masks
protected:
#endif

	virtual void DoPaint(CDC* pDC);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual int HitTest(CPoint point, BOOL bCheckWindow=TRUE) const;
	virtual int OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	// called when the button has been pressed; the graphic will be drawn in the pressed
	// state. Return TRUE to un-press the button, or FALSE to leave it pressed
	virtual BOOL OnButtonPressed(int iButton);
	// called when the system has detected the potential to apply the extruded style to a button
	// buttons which don't support this style should return FALSE
	virtual BOOL ShouldExtrude(int iButton);

	//{{AFX_MSG(COldToolBar)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

// define CToolBar to COldToolBar for convenience
#define CToolBar COldToolBar

#ifndef _DEBUG
inline AFX_TBBUTTON* CToolBar::_GetButtonPtr(int nIndex) const
{       return ((AFX_TBBUTTON*)m_pData) + nIndex; }
#endif

class COldToolCmdUI : public CCmdUI        // class private to this file !
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
};

#define CToolCmdUI COldToolCmdUI

/////////////////////////////////////////////////////////////////////////////
//      C3dBitmapButton
//              Bitmap button for use in dialog bars.  Correctly returns focus,
//              and uses fewer bitmaps than MFC bitmap buttons.

class C3dBitmapButton : public CBitmapButton
{
public:
	C3dBitmapButton();

	BOOL AutoLoad(UINT nID, CWnd* pParent,
		BOOL bToggle = FALSE, LPCRECT lpRect = NULL);

protected:
	BOOL m_bToggle;

protected:
	BOOL DrawBitmaps(BOOL bToggle, LPCRECT lpRect);
	virtual HBITMAP CreateButtonBitmap(UINT nStyle,  LPCRECT lpRect,
		CBitmap* pbmGlyph = NULL, LPCTSTR lpszText = NULL);

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);

	afx_msg void OnLButtonUp(UINT nFlags, CPoint);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint);
	afx_msg void OnSysColorChange();

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
//      C3dToggleBitmapButton

class CToggleBitmapButton: public C3dBitmapButton
{
    DECLARE_MESSAGE_MAP()

protected:
	BOOL    m_fDown;

public:
	CToggleBitmapButton();
	BOOL    IsButtonDown()  { return m_fDown; }
	void    SetChecked(BOOL);

	afx_msg void OnLButtonUp(UINT nFlags, CPoint);
};

/////////////////////////////////////////////////////////////////////////////
//      C3dDialogBar
//              All Dev Studio dialog bars should derive from this class.
//              It can be used in MDI, modeless floating, as well as dockable
//              windows.

enum DOCKPOS;

class C3dDialogBar : public CDialogBar
{
private:
	using CDialogBar::Create;

public:
	C3dDialogBar();

	BOOL Create(CWnd* pParentWnd, LPCTSTR lpszTemplateName,
			UINT nStyle, UINT nID);
	BOOL Create(CWnd* pParentWnd, UINT nIDTemplate,
			UINT nStyle, UINT nID);
			
	BOOL CreateIndirect(const void *lpDialogTemplate, CWnd* pParentWnd,
			UINT nStyle, UINT nID);

	virtual BOOL PreTranslateSysKey(MSG* pMsg);
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

    //{{AFX_MSG(C3dDialogBar)
    afx_msg UINT OnNcHitTest(CPoint pt);
	//}}AFX_MSG

    DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(C3dDialogBar)

public:
	void SetDockableID(UINT nID);
	void RecalcBarLayout(DOCKPOS dp, BOOL bForceCenter = FALSE);

	void VertCenterControls(int cySize = 0);

protected:
	UINT m_nDockableID;
};

inline BOOL C3dDialogBar::Create(CWnd* pParentWnd, UINT nIDTemplate,
	UINT nStyle, UINT nID)
{       return Create(pParentWnd, MAKEINTRESOURCE(nIDTemplate), nStyle, nID); }
inline void C3dDialogBar::SetDockableID(UINT nID)
{       m_nDockableID = nID; }

/////////////////////////////////////////////////////////////////////////////
//      Toolbar controls for use in customizable dockable toolbars
//              Controls correctly call DkPreHandleMessage.

// Class declarations
class CDockEdit ;       // Dockable Edit control.
class CDockCombo ;      // Dockable Combo box.
class CToolbarCombo ;   // Combo box used as part of the toolbar.
class CDockComboEdit ;          // Used internally only.


class CDockEdit : public CEdit
{
private:
	using CEdit::Create;

public:
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
};

class CDockComboEdit : public CWnd
{
	// Construction
public:
	CDockComboEdit(BOOL fDockable = TRUE);

protected:
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
	BOOL m_fDockable; // set false to use in a dialog
};

class CDockCombo : public CComboBox
{
private:
	using CComboBox::Create;

// Construction
public:
	CDockCombo(BOOL fDockable = TRUE) {} 

    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID) {return FALSE;}

	virtual CWnd* SubclassEdit() {return NULL;}
    
protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam) {return S_FALSE;}
	virtual void PostNcDestroy() {}
	
protected:
	CWnd* m_pChildEdit;
	BOOL m_fDockable;       // set false to use in a dialog
};

class CToolbarCombo : public CDockCombo 
{
// Generated message map functions
protected:
	//{{AFX_MSG( CToolbarCombo )
	afx_msg UINT OnNcHitTest(CPoint point);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

#include "shlbar.h"

class CToolbarEditCombo;

HWND CreateToolbarEditCombo(CToolbarEditCombo *pCombo, DWORD dwStyle, RECT* lpRect, HWND hwndParent, UINT nID);

class CToolbarEditCombo : public CToolbarCombo
{
private:
	using CToolbarCombo::Create;

// Construction.
public:
	CToolbarEditCombo();
	~CToolbarEditCombo();

	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pWnd, UINT nID);

	virtual CWnd* SubclassEdit();
	virtual void PostNcDestroy();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

public:
	DECLARE_DYNAMIC(CToolbarEditCombo);

public:
	virtual void UpdateView()=0;
	virtual void OnEditSetFocus(void)=0;
	virtual void OnEditKillFocus(void)=0;
	virtual BOOL OnEditHelp(void)=0;

    DECLARE_MESSAGE_MAP()

// Attributes.
protected:
	UINT m_nId; // Help ID
};

class CToolbarEditComboEdit : public CWnd
{
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

public:
	DECLARE_DYNAMIC(CToolbarEditComboEdit);
};

BOOL DrawButtonGlyph(CDC* pDC,
					 int x, int y,
					 CPoint ptOffset,
					 int iImage,
					 UINT nStyle,
					 const SIZE& sizeButton,
					 const SIZE& sizeImage,
					 HDC hdcGlyphs,
					 HDC hdcMono);

//#undef AFX_DATA
//#define AFX_DATA NEAR

#endif  // !__SHLBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\slob.h ===
#pragma once

#include <oleipc.h>
#include <atlcom.h>
class CSlobDragger;
class CSlobWnd;
class CSlobSequence;
class CPropBag;
class C3dPropertyPage;

class CPath;

// Slobs (Selection Objects) provide a basis for CEditor and CSelection
// that includes a standard property access mechanism with change
// notifications.
//
// Using this standard property mechanism, editors are isolated from
// the user interface of the property sheet.
//
// By making CSelection derive from CSlob and having it mirror the
// properties of all selected objects as well as broadcast any property
// changes it receives to all of the selected objects, handling setting
// properties on multiple selections becomes much easier.


// Special property identifiers
//
#define P_BEGIN_MAP                  0  // Pseudo-prop for marking the start of a map
#define P_END_MAP                    1   // Pseudo-prop for marking the end of a map
#define P_Container                  2   // Container property supported by all slobs
#define P_ID                         3
#define P_Value                      4
#define P_QuoteName                  5

#define P_Title                      6
#define P_FileName                   7
#define P_FileDisplay                8

#define P_CurrentSlob                9
#define P_PoppingProperties         10
#define P_CurrentSlobRect           11

// Properties for workspace window folder slobs
#define P_IsExpanded                32
#define P_IsExpandable              33
#define P_IsInvisibleNode           34
#define P_IsDisabled                35
#define P_HasGlyphTipText           36
#define P_BoldWorkspaceText         37
#define P_ProjWinTitle              38
#define P_ProxyContainer            39
#define P_SccStatus                 40
#define P_PanePriorityIndex         41
#define P_PaneIsIndependent         42
#define P_SortPaneRootNodes         43
#define P_FileSaveCallBack          44
#define P_PaneHelpIdentifier        45
#define P_IPkgProject               46

// Properties for Designer Objects
#define P_Filter                        50
#define P_IsTeamFolder                  51
#define P_IsGrouped                     52
#define P_IsLeftMostRoot                53
#define P_DisableDragDropParentScan     54
#define P_DisableExpandWholeBranch      55
#define P_DisablePersistExpansionState  56

// Standard Slob Notifications
#define SN_DESTROY                   0   // Dependancy has been destroyed
#define SN_ALL                       1   // All properties of dependancy (may) have changed
#define SN_CONTENT                  64   // The CSlob content has changed
#define SN_ADD                      65   // A CSlob was added to the content list
#define SN_REMOVE                   66   // A CSlob was removed from the content list

// Actions
#define A_PostSel                  100
#define A_PreSel                   101

// Commands and Verbs
#define C_COMMAND                  126
#define V_VERB                     127

#define P_MinPackage               128  // Minimum safe package property ID.

enum PROP_TYPE {null, action, integer, booln, longint, number, string, slob, rect, point, verb, command};

// Property Descriptor
struct PRD
{
    UINT nProp;
    const void* pbOffset;
    // Note correspondence with CUndoSlob
    enum PROP_TYPE { null, action, integer, booln, longint, number, string, 
        slob, rect, point, verb, command } nType;
    LPCTSTR szName;
};


#define BEGIN_SLOBPROP_MAP(thisClass, parentClass) \
    PRD AFX_EXT_DATADEF thisClass::m_rgprd [] = { \
        { P_BEGIN_MAP, &parentClass::m_rgprd[0], PRD::null, #thisClass },

#define END_SLOBPROP_MAP() \
    { P_END_MAP, NULL, PRD::null, NULL } };

#define ACTION_PROP(name, memberFxn) \
    { P_##name, &((theClass*)0)->memberFxn, PRD::action, #name },

#define BOOL_PROP(name) \
    { P_##name, &((theClass*)0)->m_b##name, PRD::booln, #name },

#define FAKE_BOOL_PROP(name) \
    { P_##name, NULL, PRD::booln, #name },

#define INT_PROP(name) \
    { P_##name, &((theClass*)0)->m_n##name, PRD::integer, #name },

#define FAKE_INT_PROP(name) \
    { P_##name, NULL, PRD::integer, #name },

#define LONG_PROP(name) \
    { P_##name, &((theClass*)0)->m_l##name, PRD::longint, #name },

#define FAKE_LONG_PROP(name) \
    { P_##name, NULL, PRD::longint, #name },

#define DBL_PROP(name) \
    { P_##name, &((theClass*)0)->m_num##name, PRD::number, #name },

#define STR_PROP(name) \
    { P_##name, &((theClass*)0)->m_str##name, PRD::string, #name },

#define FAKE_STR_PROP(name) \
    { P_##name, NULL, PRD::string, #name },

#define RECT_PROP(name) \
    { P_##name, &((theClass*)0)->m_rc##name, PRD::rect, #name },

#define POINT_PROP(name) \
    { P_##name, &((theClass*)0)->m_pt##name, PRD::point, #name },

#define FAKE_POINT_PROP(name) \
    { P_##name, NULL, PRD::point, #name },

#define SLOB_PROP(name) \
    { P_##name, &((theClass*)0)->m_p##name, PRD::slob, #name },

#define VERB_PROP(verbID) \
    { V_VERB, (const void*)(0x0000ffff & verbID), PRD::verb, _T("Verb") },

#define COMMAND_PROP(cmdID) \
    { C_COMMAND, (const void*)(0x0000ffff & cmdID), PRD::command, _T("Command") },

#define DECLARE_SLOBPROP_MAP() \
    public: \
        static PRD AFX_DATA m_rgprd []; \
        virtual const PRD FAR* GetPropMap() const \
        { return &m_rgprd[0]; }


// Get*Prop return type
//  In a multiple-selection, a lower code has precedence over a higher code.
//
enum GPT
{
    avoid = -1,     // Like invisible, but is overriding in multiple selections
    invalid = 0,    // Not a known property or disabled
    ambiguous,      // Multiple selection with different values
    valid,          // Value is correct
    invisible,      // Hide this property's UI on prop pages
};

//
//  Schema version for slob implemenetation.  Used in IMPLEMENT_SERIAL:
#define SLOB_SCHEMA_VERSION 1

//  Find a propery in a propery map:
const PRD* PrdFindProp(const PRD* propMap, UINT idProp);

enum SORT_TYPE { no_sort, alpha_sort, override_sort };

// act_insert_into_undo_slob: when the undo mechanism records the
// post-action selection it will only remember those slobs who return
// TRUE for this action type.

enum ACTION_TYPE { act_delete, act_cut, act_copy, act_paste, act_drag, act_drop, act_insert_into_undo_slob, act_rename, act_move };

#define S_ON_COMMAND(n, f) case (n): (f)(); return TRUE;
#define S_ON_UPDATE_COMMAND_UI(n, f) case (n): (f)(pCmdUI); return TRUE;

// Object of _many_ uses
//
class CSlob : public CObject
{
    DECLARE_SERIAL(CSlob)

public:
    CSlob();

    virtual ~CSlob();

    // Return a container-less, symbol-less, clone of 'this'
    virtual CSlob* Clone();

    // Copy properties only for 'this', doesn't copy properties
    // of contained slobs, both map and bag properties are copied
    virtual void CopyProps(CSlob *);

    // Clone an existing property bag into 'this' property bag
    virtual void ClonePropBag(CPropBag * pBag, int nBag = -1, BOOL fEmpty = TRUE);

    // Standard MFC serialization:
    virtual void Serialize(CArchive& ar);

    void SerializePropMap (CArchive& ar);
    virtual BOOL SerializePropMapFilter (int nIdProp) {return TRUE;}

    // Dependant Management
    void AddDependant(CSlob* newDependant);
    void RemoveDependant(CSlob* oldDepentant);
    virtual void InformDependants(UINT idChange, DWORD_PTR dwHint = 0);

    // Container Access
    inline CSlob* GetContainer() const
            { return m_pContainer; }
    CSlob *GetRootContainer();

    // Move 'this' into pNewContainer.
    inline BOOL MoveInto(CSlob* pNewContainer)
            { return SetSlobProp(P_Container, pNewContainer); }
    
    // Command enabling
    virtual BOOL CanAct(ACTION_TYPE action) { return TRUE; }
    // NYI: A final chance to refuse before the action
    virtual BOOL PreAct(ACTION_TYPE action) { return TRUE; }

#ifdef _DEBUG
    // Intentionally changed from BOOL to void returning functions to cause
    // compile errors in any code that still uses these.  You need to override
    // CanAct instead.

    virtual void CanDelete() {}
    virtual void CanCut() {}
    virtual void CanCopy() {}
    virtual void CanPaste() {}
    virtual void CanDrag() {}
#endif

    // Content Access (only valid for compound slobs!)
    virtual CObList* GetContentList();
    virtual POSITION GetHeadPosition()
    {
        CObList* p = GetContentList();
        VSASSERT(p != NULL, "No content list for slob!  Slob probably not a compound slob and somehow thinks it is");
        return p->GetHeadPosition();
    }
    virtual CSlob* GetAt(POSITION pos)
    {
        CObList* p = GetContentList();
        VSASSERT(p != NULL, "No content list for slob!  Slob probably not a compound slob and somehow thinks it is");
        return (CSlob*)p->GetAt(pos);
    }
    virtual CSlob* GetNext(POSITION& pos)
    {
        CObList* p = GetContentList();
        VSASSERT(p != NULL, "No content list for slob!  Slob probably not a compound slob and somehow thinks it is");
        return (CSlob*)p->GetNext(pos);
    }
    virtual CSlob* GetPrevious(POSITION& pos)
    {
        CObList* p = GetContentList();
        VSASSERT(p != NULL, "No content list for slob!  Slob probably not a compound slob and somehow thinks it is");
        return (CSlob*)p->GetPrev(pos);
    }

    virtual void PrepareAddList(class CMultiSlob* pAddList, BOOL fPasting);

    virtual void Add(CSlob* pSlob);
    virtual void Remove(CSlob* pSlob);

    virtual BOOL CanAdd(CSlob* pAddSlob);
    virtual BOOL CanRemove(CSlob* pRemoveSlob);

#ifdef SLOB_REFERENCING
    // routines for creating a 'short-cut' to a slob
    // REVIEW: [patbr] the default 'reference' to a slob is just the slob itself
    virtual void CanReference() { return TRUE; }
    virtual CSlob *Reference()                  // create a 'short-cut' to the slob
        { return(this); }
    virtual void RefSerialize(CArchive& ar)     // serialize the 'reference'
        { Serialize(ar); }
#endif

    // Notification Callback
    virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD_PTR dwHint);

    // Property Management
    virtual BOOL SetDoubleProp(UINT idProp, double val);
    virtual BOOL SetIntProp(UINT idProp, int val);
    virtual BOOL SetLongProp(UINT idProp, long val);
    virtual BOOL SetStrProp(UINT idProp, const CString& val);
    virtual BOOL SetSlobProp(UINT idProp, CSlob* val);
    virtual BOOL SetRectProp(UINT idProp, const CRect& val);
    virtual BOOL SetPointProp(UINT idProp, const CPoint& val);
    virtual GPT GetDoubleProp(UINT idProp, double& val);
    virtual GPT GetIntProp(UINT idProp, int& val);
    virtual GPT GetLongProp(UINT idProp, long& val);
    virtual GPT GetStrProp(UINT idProp, CString& val);
    virtual GPT GetSlobProp(UINT idProp, CSlob*& val);
    virtual GPT GetRectProp(UINT idProp, CRect& val);
    virtual GPT GetPointProp(UINT idProp, CPoint& val);

    // Property Bag Management
    virtual int GetPropBagCount() const;
    virtual CPropBag* GetPropBag(int nBag = -1);

    // Custom undo support hooks
    virtual void UndoAction(CSlobSequence* pSeq, UINT idAction);
    virtual void DeleteUndoAction(CSlobSequence* pSeq, UINT idAction);
    virtual void BeginUndo(UINT nID);
    virtual void EndUndo(BOOL bAbort = FALSE);

    // Return window viewing this slob if any
    virtual CSlobWnd* GetSlobWnd() const;

    // Property Window Interface...
    virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

    // Drag and Drop
    static  CSlob*  DropTargetFromPoint (CPoint screenPoint);
    virtual int GetCursorIndex();

#define DDC_SINGLE      0
#define DDC_COPY_SINGLE 1
#define DDC_MULTI       2
#define DDC_COPY_MULTI  3

    virtual HCURSOR GetCursor(int ddcCursorStyle);

    virtual void PrepareDrop(class CDragNDrop* pInfo);

    virtual CSlobDragger* CreateDragger(CSlob *pDragObject, CPoint screenPoint);
    virtual void DoDrop(CSlob* pSlob, CSlobDragger* pDragger);
    virtual void DoDrag(CSlob* pSlob, CSlobDragger* pDragger, CPoint screenPoint);

#ifdef _DEBUG
public:
    virtual void AssertValid() const;
    virtual void GetSlobName(CString& strName) const;
#endif

    //  Get filename associated with this slob, if any:
    virtual const CPath *GetFilePath () const { return NULL; } 
    virtual int GetAssociatedFiles(CStringArray &);
    
    // Property browser hookup
    //
    virtual BOOL GetSelectedIDispatch(UINT * piCount, IUnknown *** prgpIDispatch) { return FALSE;}

protected:

    // CSlob data size is currently 16 bytes.

    // WARNING!!  Think twice before adding data to CSlob.  We use many,
    // many, many of these in the product.

    CSlob* m_pContainer;

    // NOTE:  Because of 4 byte alignment we have 3 unused bytes here,
    // that we might want to use in the future, perhaps we could add
    // a style word...

    // Dependencies optimized for the 99% case, 2 or fewer dependants.
    // We keep 2 dependencies on the CSlob, and if nDep gets bigger than 2,
    // then all dependencies are moved into a CObList, and assign it
    // to m_aDep[0].

    BYTE m_cDep;
    CObject* m_aDep[2];

public:     // properties

    DECLARE_SLOBPROP_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CProjSlob -- root project slob class 
// REVIEW(scotg)  if you move any functions from CSlob into this class,  you
// will need to verify that ALL classes that inherit from CProjSlob that provide
// and implementation of the function you just moved, call the correct base class
// member function.  Since a large number of classes already inherited from CSlob
// before we introduced CProjSlob, these classes call CSlob member functions when 
// looking for their base class implementation and not CProjSlob.  Only the member
// functions moved into CProjSlob have had their base class calls change to 
// call CProjSlob implementations and not CSlob implementations.

class CProjSlob : public CSlob
{
    DECLARE_DYNAMIC(CProjSlob)

public:
    CProjSlob();
    virtual ~CProjSlob();


    // allow slobs to override text displayed when mouse pauses on glyph.
    // only called if P_HasGlyphTipText property is set for the slob.
    virtual void GetGlyphTipText(CString &strTip);

    // routines related to visually sorting the slob's contents
    // REVIEW: [patbr] are default behaviors here appropriate?
    virtual SORT_TYPE GetSortType()             // get type of sorting slob desires on contents
        { return(alpha_sort); }
    virtual int CompareSlob(CSlob *pCmpSlob);   // returns -1, 0, 1 for <, ==, >

    // Cmds that can be handled by this slob
    virtual void GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
        AFX_CMDHANDLERINFO* pHandlerInfo) { return FALSE; } // Override to handle commands

    // Standard Display routine
    virtual BOOL DrawGlyph(CDC* pDC, LPCRECT lpRect);

    virtual HRESULT GetService(REFGUID guidService, REFIID riid, void ** ppvObj)
        { *ppvObj = NULL; return E_NOTIMPL;}

};


/////////////////////////////////////////////////////////////////////////////
// CMultiSlob -- selection manager

class CMultiSlob : public CSlob
{
    DECLARE_DYNCREATE(CMultiSlob)

public:
    CMultiSlob();
    virtual ~CMultiSlob();

// Selection manipulation

    void Single(CSlob*, BOOL bSolo = FALSE);  // replace selection
    virtual void Clear(); // clear selection, remove all items
    virtual void Add(CSlob* pSlob, BOOL updatePropGrid = TRUE);
    virtual void Remove(CSlob* pSlob);
    virtual void EnsureValidSelection();
    
// Select information

    BOOL IsSelected(CSlob* pSlob) const;
    BOOL IsOnlySelected(CSlob* pSlob) const;
    BOOL IsDominantSelected(CSlob* pSlob) const;
    CSlob* GetDominant() const;
    
// Slob Overrides
    
    virtual CObList* GetContentList();
    virtual CSlobWnd* GetSlobWnd() const;
    virtual int GetCursorIndex();
    virtual HCURSOR GetCursor(int ddcCursorStyle);
    virtual BOOL CanAdd(CSlob* pAddSlob);
    virtual BOOL CanAct(ACTION_TYPE action);
    virtual BOOL PreAct(ACTION_TYPE action);
    virtual BOOL Delete(BOOL bClip = FALSE, CSlob** ppNextSlob = NULL);
    virtual void UndoAction(CSlobSequence* pSeq, UINT idAction);
    virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD_PTR dwHint);

    virtual BOOL SetDoubleProp(UINT idProp, double val);
    virtual BOOL SetIntProp(UINT idProp, int val);
    virtual BOOL SetLongProp(UINT idProp, long val);
    virtual BOOL SetStrProp(UINT idProp, const CString& val);
    virtual BOOL SetSlobProp(UINT idProp, CSlob* val);
    virtual BOOL SetRectProp(UINT idProp, const CRect& val);
    virtual BOOL SetPointProp(UINT idProp, const CPoint& val);
    
    virtual GPT GetDoubleProp(UINT idProp, double& valReturn);
    virtual GPT GetIntProp(UINT idProp, int& valReturn);
    virtual GPT GetLongProp(UINT idProp, long& val);
    virtual GPT GetStrProp(UINT idProp, CString& valReturn);
    virtual GPT GetSlobProp(UINT idProp, CSlob*& val);
    virtual GPT GetRectProp(UINT idProp, CRect& val);
    virtual GPT GetPointProp(UINT idProp, CPoint& val);

    // Property Window Interface...
    virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

    CSlobWnd* m_pSlobWnd;// the owner of this selection
    CObList m_objects;  // list of selected objects
    BOOL m_bSolo:1; // can the selected obj be part of a multiple selection?
    BOOL m_bAllowEmpty:1; // the this selection be empty?
    BOOL m_bAllowMultipleContainers:1; // can selection cross containers?
};


/////////////////////////////////////////////////////////////////////////////
// CSlobDragger -- base class for objects used to drag slobs around

class CSlobDragger : public CObject
{
public:
    virtual void Show(BOOL bShow = TRUE) = 0;
    void Hide()
        { Show(FALSE); }
    virtual CRect GetRect() = 0;
    virtual void Move(const CRect& newRect, BOOL bForceShow = FALSE) = 0;
};

class CSlobDraggerEx : public CSlobDragger
{
public:
    virtual void AddItem(CSlob* pSlob) = 0;
};

// Initiate a drag of "dragSlob" with the mouse at "downPoint".  This will 
// use a default CDragNDrop object to handle the operation.  For a custom 
// handler, use the other version of this function (e.g. VRes must use a 
// CResDragNDrop object).
void BeginDragDrop(CPoint downPoint, CSlob* dragSlob);

// Initiate a drag using a custom CDragNDrop class.
void BeginDragDrop(CDragNDrop* pInfo);

// Cancel any pending drag operation.
void CancelDragDrop();

// Returns TRUE if a drag operation is in progress, FALSE otherwise.
BOOL IsDragDropInProgress();


////////////////////////////////////////////////////////////////////////////
// CDragNDrop

class CDragNDrop
{

public:
    CDragNDrop(CPoint downPoint, CSlob *dragSlob);
    virtual ~CDragNDrop();

    virtual void OnLButtonUp(UINT nFlags, CPoint point);
    virtual void OnRButtonUp(UINT nFlags, CPoint point);
    virtual void OnMouseMove(UINT nFlags, CPoint point);
    virtual void AbortDrop();
    virtual void IdleUpdate();
    virtual void FixupSelections(CMultiSlob* pSource, CMultiSlob* pDest);
    virtual void ChangeCursor();
    virtual BOOL IsCopy();
    virtual void Drop(UINT nFlags, CPoint point);
    virtual void SetIgnoreMouseMoves(BOOL bIgnore) { m_bIgnoreMoves = bIgnore; }

    CSlob* m_dragSlob; // the slob being dragged
    CSlobDragger* m_dragInfo; // used to gather information about the drag and drop
    CSlob* m_target; // the last potential drop target
    WORD m_wLastKeyState; // last state of keys (DD_CTRL / DD_SHIFT)

    CPoint m_downPoint;
    CPoint m_lastPoint;

    UINT    m_flags;
    CPoint  m_point;

    BOOL    m_bIgnoreMoves;

    // User's selection in right-button drop popup menu.  NotSet if this
    // hasn't been used.
    enum DragMoveCopy { dragNotSet, dragMove, dragCopy, dragCancel } m_MoveCopy;
};

// Flags for the m_wLastKeyState member of CDragNDrop
#define DD_CTRL     0x0001
#define DD_SHIFT    0x0002


// Initiate a drag of "dragSlob" with the mouse at "downPoint".  This will 
// use a default CDragNDrop object to handle the operation.  For a custom 
// handler, use the other version of this function (e.g. VRes must use a 
// CResDragNDrop object).
void BeginDragDrop(CPoint downPoint, CSlob* dragSlob);

// Initiate a drag using a custom CDragNDrop class.
void BeginDragDrop(CDragNDrop* pInfo);

// Cancel any pending drag operation.
void CancelDragDrop();

// Returns TRUE if a drag operation is in progress, FALSE otherwise.
BOOL IsDragDropInProgress();


/////////////////////////////////////////////////////////////////////////////
//  Properties

class CProp
{
public:
    static void DeleteCProp (CProp *pPRop);
    PROP_TYPE m_nType;
};

class CIntProp : public CProp
{
public:
    CIntProp(int val = 0)
        { m_nVal = val; m_nType = integer; }

    int m_nVal;
};

class CBoolProp : public CProp
{
public:
    CBoolProp(int val = FALSE)
        { m_bVal = val; m_nType = booln; }

    int m_bVal;
};

class CNumberProp : public CProp
{
public:
    CNumberProp(double val = 0.)
        { m_numVal = val; m_nType = number; }

    double m_numVal;
};

class CStringProp : public CProp
{
public:
    CStringProp(const char* szVal = "")
        { m_strVal = szVal; m_nType = string; }

    CString m_strVal;
};

inline void CProp::DeleteCProp (CProp *pPRop)
{
    switch (pPRop->m_nType)
    {
        case integer:
            delete ( (CIntProp *) pPRop );
            break;
        case booln:
            delete ( (CBoolProp *) pPRop );
            break;
        case number:
            delete ( (CNumberProp *) pPRop );
            break;
        case string:
            delete ( (CStringProp *) pPRop );
            break;
        default:
            VSASSERT(FALSE, "Invalid pPRop->m_nType");              
    }
}

class CPropBag
{
    friend class CSlob;

public:
    CPropBag () : m_props(11) {};       // Use small block size.
    CPropBag (UINT nHash) : m_props(11) {m_props.InitHashTable(nHash, FALSE);}
    ~CPropBag () {Empty();}

    // Enumerate props -- same as CMapWordToPtr's methods
    __inline POSITION GetStartPosition() const
        {return m_props.GetStartPosition();}

    __inline void GetNextAssoc(POSITION & pos, UINT & nPropID, CProp * & pProp) const
        {nPropID = (UINT)0; m_props.GetNextAssoc(pos, (WORD &)nPropID, (void * &)pProp);}

    __inline int GetPropCount () const
        {return (int)m_props.GetCount();}

    // Setting of prop values.
    void SetIntProp(CSlob* pSlob, UINT nPropID, int val);
    void SetStrProp(CSlob* pSlob, UINT nPropID, CString & str);

    // TODO: add SetProp functions for other types...
    __inline CProp * FindProp(UINT nPropID) const
        {
            CProp * pProp;
            if (m_props.IsEmpty())
                return NULL;
            return m_props.Lookup((WORD)nPropID, (void*&)pProp) ? pProp : (CProp *)NULL;
        }
    __inline void AddProp(UINT nPropID, CProp* pProp)
        {m_props[(WORD)nPropID] = pProp;}
    void RemoveProp(UINT nPropID);
    void RemovePropAndInform(UINT nPropID, CSlob * pSlob);

    void Empty();
    void Clone(CSlob * pSlob, CPropBag * pBag, BOOL fEmpty = TRUE);

    // Serialize the props in this bag.  If the slob pointer is provided
    // the slob's serialize SerializePropMapFilter filter is used:
    void Serialize(CArchive & ar, CSlob *pFilterSlob = NULL);

protected:
    CMapWordToPtr m_props;
};

__inline void CPropBag::RemovePropAndInform(UINT nPropID, CSlob * pSlob)
{
    CProp * pProp;
    if (m_props.Lookup((WORD)nPropID, (void*&)pProp))
    {
        CProp::DeleteCProp(pProp);
        m_props.RemoveKey((WORD)nPropID);
        pSlob->InformDependants(nPropID);
    }
}

__inline void CPropBag::RemoveProp(UINT nPropID)
{
    // only do removal if we find it
    // N.B. we don't VERIFY this op. 'cos it is more efficient
    // for clients of this class to call
    //
    //  pBag->RemoveProp(idProp);
    //
    // rather than
    //
    //  if (pBag->FindProp(idProp))
    //      pBag->RemoveProp(idProp));
    //
    // , for the case where the client doesn't care about the prop
    // value, in order to prevent the VERIFY() firing
    CProp * pProp;
    if (m_props.Lookup((WORD)nPropID, (void*&)pProp))
    {
        CProp::DeleteCProp(pProp);
        m_props.RemoveKey((WORD)nPropID);
    }
}


/////////////////////////////////////////////////////////////////////////////
// CClipboardSlob

class CClipboardSlob : public CSlob
{
    DECLARE_DYNAMIC(CClipboardSlob)

public:
    CClipboardSlob();
    ~CClipboardSlob();

    void Copy(CSlob *pCopySlob);
    void Paste(CSlob *pDestSlob, CMultiSlob* pSelection = NULL, BOOL bClearSelection = TRUE);
    void ClearContents();
    
    BOOL CanAct(ACTION_TYPE action);
    
    virtual CObList* GetContentList()
        { return &m_objects; }

    CObList m_objects;
};

extern CClipboardSlob AFX_DATA theClipboardSlob;


/////////////////////////////////////////////////////////////////////////////
//  Undo slob
//      REVIEW:  This is much more than really needs to be exposed to the
//               package developer.  Using Find in Files, I found only
//               some 12 simple global functions necessary to support our
//               current usage.

class CUndoStack;           // A stack of undo/redo-able actions
// CByteArray
    class CSlobSequence;    // A sequence of changes for one action
class CUndoRecord;          // One change in a sequence
    class CIntUndoRecord;
    class CLongUndoRecord;
    class CDoubleUndoRecord;
    class CRectUndoRecord;
    class CPointUndoRecord;
    class CSlobUndoRecord;
// CSlob
    class CUndoSlob;        // The master undo/redo controller

#define DEFAULT_UNDO_LEVELS 100

#pragma pack(2)

class CUndoRecord
{
public:
    WORD m_op;
    WORD m_nPropID;
    CSlob* m_pSlob;
    CPropBag* m_pBag;
};

class CIntUndoRecord : public CUndoRecord
{
public:
    int m_nOldVal;
};

class CLongUndoRecord : public CUndoRecord
{
public:
    long m_nOldVal;
};

class CDoubleUndoRecord : public CUndoRecord
{
public:
    double m_numOldVal;
};

class CRectUndoRecord : public CUndoRecord
{
public:
    CRect m_rectOldVal;
};

class CPointUndoRecord : public CUndoRecord
{
public:
    CPoint m_ptOldVal;
};

class CSlobUndoRecord : public CUndoRecord
{
public:
    const CSlob* m_pOldVal;
};

#pragma pack()

///////////////////////////////////////////////////////////////////////////
//  CUndoStack
//      maintains a list of CSlobSequences, one for each action
//      that may be undone or redone.  Each CSlobWnd gets one of these.

class CUndoStack
{
public:
    CUndoStack();
    ~CUndoStack();
    
private:
    void Truncate(); // chop seqs off at m_nMaxLevels in the undo part
    void Flush(); // delete seqs and objects
    void FlushRedo(); // delete redo seqs
    
    CObList m_seqs; // CSlobSequence's for actions
    CObList m_objects; // CSlob's that have been deleted
    int m_nRedoSeqs; // how many seqs at head are for redo?
    int m_nSavePosition; // position where we did a save
    int m_nMaxLevels; // how many levels are allowed?
    
    friend class CUndoSlob;
    friend class CSlobWnd;
};

// A CSlobSequence holds the codes for one undo or redo operation.
//
class CSlobSequence : public CByteArray
{
#ifdef _DEBUG
private:
    using CByteArray::Dump;
#endif  // _DEBUG

public:
    CSlobSequence();
    ~CSlobSequence();
    
    void Retrieve(BYTE* rgb, int cb);
    void RetrieveStr(CString& str);
    inline void RetrieveRecord(CUndoRecord& rec)
            { Retrieve((BYTE*)&rec, sizeof (CUndoRecord)); }
    inline void RetrieveByte(BYTE& b)
            { Retrieve(&b, 1); }
    inline void RetrieveWord(WORD& w)
            { Retrieve((BYTE*)&w, 2); }
    inline void RetrieveInt(int& n)
            { Retrieve((BYTE*)&n, sizeof (int)); }
    inline void RetrieveLong(long& n)
            { Retrieve((BYTE*)&n, sizeof (long)); }
    inline void RetrieveNum(double& num)
            { Retrieve((BYTE*)&num, sizeof (double)); }
    inline void RetrievePtr(CSlob*& ptr)
            { Retrieve((BYTE*)&ptr, sizeof (CSlob*)); }
    inline void RetrievePtr(CPropBag*& ptr)
            { Retrieve((BYTE*)&ptr, sizeof (CPropBag*)); }
    inline void RetrieveRect(CRect& rc)
            { Retrieve((BYTE*)&rc, sizeof (rc)); }
    inline void RetrievePoint(CPoint& pt)
            { Retrieve((BYTE*)&pt, sizeof (pt)); }
    
    void Cleanup();
    BOOL IsUseful(CSlob*&, int&);
    void Apply();
    
#ifdef _DEBUG
    void Dump();
#endif
    
    int m_nCursor;
    CString m_strDescription;
    long m_nSerial;
};


/////////////////////////////////////////////////////////////////////////////
//  CUndoSlob

class CUndoSlob : public CSlob
{
    DECLARE_DYNAMIC(CUndoSlob)

private:
    using CSlob::BeginUndo;
#ifdef _DEBUG
    using CSlob::Dump;
#endif

public:
    CUndoSlob();
    ~CUndoSlob();

    void RegisterUIManager (IOleInPlaceComponentUIManager * pUIManager);
// User Interface control

    BOOL CanUndo(CSlobWnd * pSlobWnd) const;
    BOOL CanRedo(CSlobWnd * pSlobWnd) const;
            
    void GetUndoString(CSlobWnd * pSlobWnd, CString& strUndo, int nLevel = 0);
    void GetRedoString(CSlobWnd * pSlobWnd, CString& strRedo, int nLevel = 0);

    void DoUndo(CSlobWnd* pSlobWnd); // perform an undo command
    void DoRedo(CSlobWnd* pSlobWnd); // perform a redo command
    
    void GetUndoList (CSlobWnd * pSlobWnd, CStringList & slUndo);
    void GetRedoList (CSlobWnd * pSlobWnd, CStringList & slRedo);

    void SetMaxLevels(int nLevels);
    int GetMaxLevels() const;

    void Flush(CSlobWnd * pWnd); // empty the current undo and redo stacks
    void FlushLast(); // prevent action merging

    inline BOOL InUndoRedo() const
            { return m_bPerformingUndoRedo; }
            
// Recording Control

    void BeginUndo(const char* szCmd, CSlobWnd* pSlobWnd = NULL, BOOL bResetCursor = TRUE);
    void BeginUndo(UINT nID, CSlobWnd* pSlobWnd, BOOL bResetCursor = TRUE);
    void BeginUndo(UINT nID) { BeginUndo(nID, NULL); }
    void EndUndo(BOOL bAbort = FALSE);

    inline BOOL IsRecording()
        { return m_nRecording != 0 && m_nPauseLevel == 0; }

    inline void Pause()
        { m_nPauseLevel += 1; }
        
    inline void Resume()
        { VSASSERT(m_nPauseLevel > 0, "Pause level already back to zero; bad refcount somewhere"); m_nPauseLevel -= 1; }
    
    // This is used to link undo operations in two separate stacks
    // together (only in drag&drop for now)...
    inline void Link()
            { m_nSerial -= 1; }

// Property change recorders

    void OnSetIntProp(CSlob* pChangedSlob, UINT nPropID, UINT nOldVal, CPropBag* pBag = NULL);
    void OnSetLongProp(CSlob* pChangedSlob, UINT nPropID, long nOldVal, CPropBag* pBag = NULL);
    void OnSetDoubleProp(CSlob* pChangedSlob, UINT nPropID, double numOldVal, CPropBag* pBag = NULL);
    void OnSetStrProp(CSlob* pChangedSlob, UINT nPropID, const CString* pStrOldVal, CPropBag* pBag = NULL);
    void OnSetSlobProp(CSlob* pChangedSlob, UINT nPropID, const CSlob* pOldSlob, CPropBag* pBag = NULL);
    void OnSetRectProp(CSlob* pChangedSlob, UINT nPropID, const CRect& rcOldVal, CPropBag* pBag = NULL);
    void OnSetPointProp(CSlob* pChangedSlob, UINT nPropID, const CPoint& rcOldVal, CPropBag* pBag = NULL);
    void OnAddProp(CSlob* pSlob, CPropBag* pBag, UINT nPropID);
    void OnRemoveIntProp(CSlob* pSlob, CPropBag* pBag, UINT nPropID, int nOldVal);
    
// Selection change recorders...

    void OnMultiRemove(CMultiSlob* pMultiSlob, CSlob* pRemoveSlob);
    void InsertSel(UINT nAction, CMultiSlob* pSel, CObList* pItems = NULL);
    void OnPreSel(CMultiSlob* pSel);
    void OnPostSel(CMultiSlob* pSel);
    

// Really low-level recording stuff

    enum {
        // Note correspondence with PRD
        opStart,
        opEnd,
        opAction,
        opIntProp,
        opLongProp,
        opBoolProp,
        opDoubleProp,
        opStrProp,
        opSlobProp,
        opRectProp,
        opPointProp
    };

    UINT Insert(const void* rgb, int cb);
    UINT InsertStr(const char* sz, int nStrLen);
    inline UINT InsertByte(BYTE b)
            { return Insert(&b, 1); }
    inline UINT InsertInt(int n)
            { return Insert((BYTE*)&n, sizeof (int)); }
    inline UINT InsertLong(long n)
            { return Insert((BYTE*)&n, sizeof (long)); }
    inline UINT InsertNum(double num)
            { return Insert((BYTE*)&num, sizeof (double)); }
    inline UINT InsertPtr(const void* ptr)
            { if (ptr != NULL)
                {
                    VSASSERT(((CObject*)ptr)->IsKindOf(RUNTIME_CLASS(CSlob)), "Not a slob!");
                    ((CSlob*)ptr)->AddDependant(this);
                }
            return Insert((BYTE*)&ptr, sizeof (CSlob*)); }
    inline UINT InsertRect(const CRect& rc)
            { return Insert((BYTE*)&rc, sizeof (CRect)); }
    inline UINT InsertPoint(const CPoint& pt)
            { return Insert((BYTE*)&pt, sizeof (CPoint)); }
    inline UINT InsertRecord(const CUndoRecord* pRec)
            { return Insert((BYTE*)pRec, sizeof (CUndoRecord)); }
    void SetSavePosition(CSlobWnd *pwndSlob);
    BOOL FAtSavePosition(CSlobWnd *pwndSlob);


// CSlob overrides
    CObList* GetContentList();
    
#ifdef _DEBUG
    void Dump(CSlobWnd * pWnd);
#endif

private:
    void Truncate();
    BOOL DoUndoRedo(CSlobWnd* pSlobWnd);
    void OnChangeUndoStack ()   ;
    int m_nRecording; // BeginUndo() nesting count
    int m_nPauseLevel; // Pause() nesting count
    
    // These ?Last* variables are used to coalesce consecutive changes
    // to the same property...
    CSlob* m_pLastSlob;
    int m_nLastPropID;
    
    // Properties...
    int m_nMaxLevels;

    CSlobSequence* m_pCurSeq;
    CUndoStack* m_pStack;
    CSlobWnd * m_pSlobWnd;

    BOOL m_bPerformingUndoRedo;
    
    CMultiSlob* m_pSel;
    
    long m_nSerial;
    CSlob* m_pDragDropObject;
    
    BOOL m_bFlushAtEnd;

    IOleInPlaceComponentUIManager * m_pUIManager;
    friend class CSlobSequence;
    friend class CUndoStack;
};

extern CUndoSlob AFX_DATA theUndoSlob;

//helper classes to combine undo actions when we know how
//many actions there will be, but not their lifetimes
class CCombineUndoObjectsHelper : public CComObjectRoot
{
public:
    BEGIN_COM_MAP(CCombineUndoObjectsHelper)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CCombineUndoObjectsHelper);

    CCombineUndoObjectsHelper();
    ~CCombineUndoObjectsHelper();

    void Init(UINT iMsg, CSlobWnd * pSlobWnd, int iDispID);

    int m_iDispID;
};

class CCombineUndoObjects
{
public:
    CCombineUndoObjects(UINT iMsg, CSlobWnd * pSlobWnd, int iDispID, int iCount);
    CCombineUndoObjects(CSlobWnd * pSlobWnd, int iFlush);
    ~CCombineUndoObjects();

    static int FLUSH;
protected:
    CSlobWnd  * m_pSlobWnd;
};

/////////////////////////////////////////////////////////////////////////////
//  CSlobWnd
//      Base class for CPartView the package view base class.

class CSlobWnd : public CView
{
    DECLARE_DYNAMIC(CSlobWnd)
    
private:
    static CObList NEAR c_slobWnds;

protected:
    CComObject<CCombineUndoObjectsHelper> * m_pCombineUndo;

public:
    static POSITION GetHeadSlobWndPosition();
    static CSlobWnd* GetNextSlobWnd(POSITION& pos);
        
public:
    CSlobWnd();
    ~CSlobWnd();
    
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual void OnDraw(CDC* pDC);
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    virtual void PostNcDestroy();

    afx_msg void OnDestroy();
    afx_msg void OnRButtonUp(UINT nFlags, CPoint point);

    // property sheet for this CSlob window commands
    afx_msg void CmdShowProp();
    afx_msg void CmdIDProp();
    afx_msg void CmdGeneralPage();  // accel. for General prop page
    afx_msg void CmdStylesPage();   // accel. for Styles prop page

    virtual CSlob* GetSelection() = 0;
    virtual CSlob* GetEditSlob() = 0;

    virtual void ShowContextPopupMenu(CPoint pt);
    
    virtual CSlob* DropTargetFromPoint(const POINT& point);

    inline BOOL IsIconic()
    {
        CWnd * pParent = GetParent();
        return pParent ? pParent->IsIconic() : FALSE;
    }

    // Selection Manipulation
    void Select(CSlob* pSlob, BOOL bAdd = FALSE, BOOL updatePropGrid = TRUE);
    void Deselect(CSlob* pSlob);
    
    virtual void OnSelChange();
    
    virtual void ObscureSprites(BOOL bObscure = TRUE);
    virtual void ShowSprites(BOOL bShow = TRUE);
    void HideSprites()
            { ShowSprites(FALSE); }

    virtual void EnsureValidSelection() { }
    virtual void EnableUpdates(BOOL bEnable) { }

    // Selection Information
    BOOL IsSelected(CSlob* pSlob);
    BOOL IsOnlySelected(CSlob* pSlob);
    BOOL IsDominantSelected(CSlob* pSlob);

    // Undo/Redo Buffer Management
    virtual BOOL EnableUndo();  // Return TRUE if undo/redo handling is
                                // enabled, FALSE if not.  Default implementation
                                // returns TRUE, so only override if you want to
                                // return FALSE and *DISABLE* undo/redo.
    void BeginUndo(const char* szAction);
    void BeginUndo(UINT nID);
    void EndUndo(BOOL bAbort = FALSE);
    void FlushUndo();
    
    BOOL CanUndo();
    BOOL CanRedo();

    virtual void DoUndo();
    virtual void DoRedo();
    
    LRESULT OnGetRedoString(WPARAM, LPARAM);
    LRESULT OnGetUndoString(WPARAM, LPARAM);
    
    DECLARE_MESSAGE_MAP()

private:
    CUndoStack* m_pUndoStack;
    
    friend class CUndoSlob;
    friend class CCombineUndoObjects;
};

CSlobWnd* GetActiveSlobWnd();
void ActivateSlobWnd(CSlobWnd* pWnd);
HRESULT PrepareSafeArrayVariant(CStringList & sl, VARIANT *pvtNames);

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\stdfont.h ===
// stdfont.h
#ifndef __STDFONT_H__
#define __STDFONT_H__
// This class is for pre-loading and munging dialog tempalates.
// For now, it is only used to change the font of a dialog...
//
#include <afxpriv.h>
#include "uilocale.h"
#include <atlbase.h>

extern const LPCTSTR g_pszUIDllName;

class CLocaleInfo
{
public:
	CLocaleInfo();
	CLocaleInfo(HINSTANCE hInst, IServiceProvider *pServiceProvider);
	~CLocaleInfo();

	void SetSite(IServiceProvider *pServiceProvider) {m_pServiceProvider = pServiceProvider;};
	void SetMainInst(HINSTANCE hInst) {m_hInstMain = hInst;};
	
	void Close();

	HINSTANCE GetUIHostLib(); // returns NULL if can't find.
	BOOL LoadDialog(LPCTSTR lpDialogTemplateID, DLGTEMPLATE** ppDlgTmplt);
	BOOL GetDialogFont(UIDLGLOGFONT *pLogFont);
	HRESULT ExternalQueryService(REFGUID rsid, REFIID iid, void **ppvObj);

protected:
	void Init();

	HINSTANCE m_hInstMain;
	CComPtr<IUIHostLocale> m_pUIHostLocale;
	CComPtr<IUIHostLocale2> m_pUIHostLocale2;
	HINSTANCE m_hInst;
	CComPtr<IServiceProvider> m_pServiceProvider;
};

class C3dDialogTemplate : public CDialogTemplate
{
public:
	C3dDialogTemplate(const DLGTEMPLATE* pTemplate = NULL, CLocaleInfo  *pLocInfo = NULL);
	C3dDialogTemplate(HGLOBAL hGlobal, CLocaleInfo  *pLocInfo = NULL);
	BOOL Load(LPCTSTR lpDialogTemplateID);
	~C3dDialogTemplate();

	void SetStdFont();
	BOOL SetLogFont(UIDLGLOGFONT & logFont);
	HGLOBAL GetTemplate() const { return m_hTemplate; }
protected:
	void Init(CLocaleInfo  *pLocInfo, const DLGTEMPLATE* pTemplate = NULL, BOOL fFullInit = TRUE);
	CLocaleInfo *m_pLocInfo;
	const DLGTEMPLATE* m_pTemplate;
};

// Switch to enable on-the-fly dialog font changing...
#define MUNGE_DLG_FONTS

// Set standard fonts in dialog template
void SetStdFont(C3dDialogTemplate & dt);

/////////////////////////////////////////////////////////////////////////////
// Standard font handling

enum FontType
{
	font_Normal,			// MS Sans Serif 8, MS SVbN 10, System 10
	font_Bold,
	font_Italic,
		
	font_Small,				// Small Fonts (-9), Terminal (-9), Terminal (-9)
	font_SmallBold,
	font_SmallItalic,
		
	font_Fixed,				// Courier (14), FixedSys (14), FixedSys (14)
	font_FixedBold,
	font_FixedItalic,
	
	font_Large,             // MS Sans Serif 14. MS Sans Serif 14, MS Sans Serif 14,
	font_LargeBold,
	font_LargeItalic,

	font_count				// Not a font, just provides a count
};

CFont* GetStdFont(const int iType);

// NOTE: The LOGFONT returned by this is temporary
const LOGFONT* GetStdLogfont(const int iType, CDC *pDC = NULL);
void GetStdFontInfo(int iType, CString& strFace, int& ptSize);

////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\tabdlg.h ===
////////////////////////////////////////////////////////////////////////////
// CDlgTab -- one page of a tabbed dialog

#pragma once
#include "dlgbase.h"

class CTabbedDialog;	// A tabbed "dialog" (really a modal popup window)

class CDlgTab : public C3dDialog
{
protected:
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CDlgTab)
	
// Construction
public:
	CDlgTab(UINT nIDTemplate, UINT nIDCaption);
	CDlgTab(LPCSTR lpszTemplateName, UINT nIDCaption);

	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

protected:
// Implementation
	CDlgTab();
	virtual UINT GetHelpID() { return m_nIDHelp; }

	// always call this to enable or disable a button in a dialog tab
	// it will ensure that the default button is passed correctly to the 
	// appropriate button in the parent dialog.  martynl 15Mar96
	virtual BOOL EnableButton(CWnd *button, BOOL bEnable);

public:
	virtual BOOL ValidateTab();

	virtual void CommitTab();
	virtual void CancelTab();
	virtual LRESULT OnCommandHelp(WPARAM, LPARAM lParam) {return S_OK;}

protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

#ifdef _DEBUG	
	void EndDialog(int nEndID);
#endif

	CString m_strCaption;

	friend class CTabbedDialog;

private:
	// Derived classes should use CommitTab() and CancelTab()
	virtual void OnOK();
	virtual void OnCancel();

// Attributes
public:
	int m_nOrder;
};

extern BOOL IsTabNextFocus(CDialog* pDlg, UINT nCmd);

////////////////////////////////////////////////////////////////////////////
// CTabs -- implementation for a generic row of tabs along the top of dialog

class CTabRecord : public CObject
{
public:
	CTabRecord(const char* szCaption, int nWidth, int nOrder, DWORD dw);

	CString	m_strCaption;
	CRect	m_rect;
	int 	m_nWidth;
	BOOL	m_bClipped;
	int     m_nOrder;
	DWORD	m_dw;
};

class CTabRow : public CObject
{
public:
	enum {
		SCROLL_LEFT = -5,		// all the SCROLL_ items must be less
		SCROLL_RIGHT = -6,		// than -1 to avoid ID conflict
		SCROLL_NULL = -7,

		cxScrollSize = 31,		// size of the scroll button bitmap
		cyScrollSize = 17,
		cxScrollMargin = 10,	// blank margin between scroll buttons and tabs

		cxSelectedTab = 2,		// amount to inflate the selected tab
		cySelectedTab = 2,
		cxTabTextMargin = 10,	// extra width for a tab past text width
		cyTabTextMargin = 3,	// extra height for a tab past text height

		TIMER_ID = 15,
		TIMER_DELAY = 500
	};

	// Construction
	CTabRow();
	~CTabRow();

	void	ResetContent();
	void	AddTab(CString& szCaption, CDC* pDC, int nOrder, DWORD dw = 0);
	void	SetPos(CRect rect);		// set position of tab row within window
	int 	DesiredHeight(CDC* pDC);	// how much space does tab row need?
	void	SetParent(CWnd* pWndOwner)
	    		{ m_pWndOwner = pWndOwner; }

	// Operations
	int		SetActiveTab(int nTab);
	int		SetActiveTab(const CString& str);
	int 	GetActiveTab()
	    		{ return m_curTab; }

	void	PutFocus(BOOL bTabsHaveFocus);
	BOOL	HasFocus()
	    		{ return m_bHasFocus; }

	void	Scroll(int nDirection);
	void	ScrollIntoView(int nTab);

	// Drawing stuff
	void	Draw(CDC* pDC);
	void	DrawFocusRect(CDC* pDC);
	void	DrawPageRect(CDC* pDC, const CRect& rectPage);
	void	InvalidateTab(int nTab, BOOL bInflate = TRUE);
	CRect	GetRect() const
				{ return m_rowRect; }

	// Mouse stuff
	int 	TabFromPoint(CPoint pt);
	void	OnMouseMove(CPoint pt);
	void	OnLButtonUp(CPoint pt);
	void	OnTimer();
	void	Capture(int nDirection);
	BOOL	HasCapture()
	    		{ return m_nScrollState != SCROLL_NULL; }

	// Misc
	DWORD	GetTabDWord(int nTab)
				{ return GetTab(nTab)->m_dw; }
	LPCTSTR GetTabString(int nTab)
				{ return GetTab(nTab)->m_strCaption; }
	int 	MaxTab()
	    		{ return (int)m_tabs.GetSize() - 1; }

private:
	void	DrawTab(CDC* pDC, int nTab, BOOL bCurTab);
	void	DrawScrollers(CDC* pDC);

	BOOL	CanScroll();
	void	SetFirstTab(int nTab);
	CTabRecord*	GetTab(int nTab)
				{ return (CTabRecord*)m_tabs[nTab]; }
	BOOL	IsTabVisible(int nTab, BOOL bPartials = TRUE);

	// Member variables
	CRect	m_rowRect;		// location of entire tab row within owning window
	CRect	m_scrollRect;	// location of scroll buttons
	int 	m_curTab;		// index of current selected tab
	int 	m_firstTab;		// index of leftmost visible tab
	BOOL	m_bHasFocus;	// whether tab row has the focus
	int 	m_nScrollState;	// shows whether left or right scroll btn is down
	BOOL	m_bScrollPause;	// if we have capture, has the mouse wandered off btn?

	CWnd*	m_pWndOwner;	// pointer to owning window (used for InvalidateRect)
	CObArray	m_tabs;		// list of CTabRecords, in order
};


////////////////////////////////////////////////////////////////////////////
// CTabbedDialog -- a tabbed "dialog" (really a popup-window)
class CLastTabMap : public CMapWordToOb
{
	public:
		~CLastTabMap();
		__inline void RememberTab(WORD wCaptionID, CString & strCaption)
		{
			CString * pStr; if (!Lookup(wCaptionID, (CObject *&)pStr))	pStr = new CString;
			*pStr = strCaption; SetAt(wCaptionID, (CObject *&)pStr);
		}
		__inline BOOL LookupTab(WORD wCaptionID, CString & strCaption)
		{
			CString * pStr; if (!Lookup(wCaptionID, (CObject *&)pStr))	return FALSE;
			strCaption = *pStr; return TRUE;
		}
};

class CTabbedDialog : public CWnd
{
// Construction
public:
	enum COMMIT_MODEL { commitOnOk, commitOnTheFly };
	enum FC { FC_THIS, FC_NEXT, FC_PREVIOUS, FC_FIRST };
	enum DLGPOSITION { POS_APPCENTER, POS_AVOIDBARS };

	CTabbedDialog(UINT nIDCaption, CWnd* pParentWnd = NULL,
			UINT iSelectTab = -1, COMMIT_MODEL = commitOnOk, DLGPOSITION pos=POS_APPCENTER);
	
	// Modeless operation
	BOOL Create();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// Modal operation
	int DoModal();
	void EndDialog(int nEndID);


// Operations
public:
	virtual void OnOK();
	virtual void OnCancel();
	virtual void OnHelp();

	virtual void OnSelectTab(int nTab) {};

	void AddTab(CDlgTab* pDlgTab);
	// may return failure (FALSE) if the tabs cannot be
	// cleared (most likely because the current one
	// failed the validation check)
	BOOL ClearAllTabs();
	// nTab == -1 will de-select the current tab
	// and not re-select any other
	void SelectTab(int nTab, BOOL bGoToControl = FALSE);
	void SelectTab(const CString& strCaption, BOOL bGoToControl = FALSE);
	void SelectNextTab();
	void SelectPreviousTab();
	int FindTab(const CString& rstrCaption);
	int GetTabCount() const
		{ return (int)m_tabs.GetSize(); }
	void SetCaption( const char *szCaption )
		{ m_strCaption = szCaption; }
	int GetCurrentTab() const
		{ return m_nTabCur; }

	// PreTranslate processing
	BOOL MessageStolenByTabbedDialog(MSG* pMsg);
	void HandleTab(BOOL bShift, BOOL bControl);
	BOOL HandleAcceleratorKey(char ch);
	BOOL HandleTabRowKey(char ch);
	BOOL IsDone() { return m_nID != -1; }	// HACK:  This is to fix ClassWiz bug 14201

// Implementation
protected:
	CDlgTab* GetTab(int nTab) {return 0 <= nTab && nTab < GetTabCount() ? (CDlgTab*)m_tabs[nTab] : (CDlgTab *)NULL;}
	void DrawFocusRect();
	BOOL ActivateTab(int nTab, BOOL bGoToControl);
	void BuildTabItemList(CObList& list, CMapWordToOb& map, CWnd* pWndCur = NULL);
	CWnd* FindControl(CWnd* pWndGoal, CObList& list, FC fc = FC_NEXT);
	void SetFocusToControl(CWnd* pControl, CObList* list = NULL, BOOL bSetSel = TRUE);


	// Sizing
	CPoint GetDlgTabPos();
	virtual void GetTabSize(CRect& rect);
	virtual void GetMargins(CRect& rect);

	// Buttons
	BOOL IsButton(HWND hWnd);
	virtual void CreateButtons();
	virtual void GetButtonExtent(CSize& size);
	virtual void MoveButtons(int nLeft, int nCenter);
	virtual CButton* GetButtonFromIndex(int index);
	void SetDefButtonIndex(int index);

	enum {
		cyBottomMargin = 6,	// plus button height, of course
		duButtonWidth = 45,
		duButtonHeight = 14,
		duBetweenButtons = 6
	};

	CSize m_buttonSize;
	int   m_cxBetweenButtons;

	CObArray m_tabs;	// array of CDlgTab pointers
	int m_nTabCur;  	// which is the current tab
	//CWnd* m_pFocusWnd; // focus when we lost activation
	HWND m_hFocusWnd;	// focus when we lost activation
	CWnd* m_pParentWnd; // owner of the tabbed dialog
	int m_nID;      	// ID passed to EndDialog and returned from DoModal
	CString m_strCaption; // caption of the pseudo-dialog
	UINT nCaptionID;
	static CLastTabMap m_DialogMap;	// Used to remember the last used page in all tabbed dialogs
	COMMIT_MODEL	m_commitModel;
	DLGPOSITION m_position;

	CTabRow	m_tabRow;		// entire row of tabs at top of dialog

	CButton m_btnOk;
	CButton m_btnCancel;
	CButton m_btnHelp;
 	int m_iDefBtnIndex;

	// Generated message map functions
	//{{AFX_MSG(CTabbedDialog)
	afx_msg void OnPaint();
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT_PTR nTimerID);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnClose();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CTabbedDialog);
};

#define cxTabMargin		6	// margins between non-client and outlines
#define cyTabMargin		6	//                  ''
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCAtlExtensions.h ===
#pragma once

#include <VCAssert.h>

template<typename T, typename Element>
class CComCollectionIterator
{
private :

	CComPtr<T> m_spT;

public :

	CComCollectionIterator(T * pT) : m_spT(pT)
	{
	}

	CComCollectionIterator(const CComPtr<T> & pT) : m_spT(pT)
	{
	}

	UINT Count(void)
	{
		FAILED_THROW(E_UNEXPECTED, m_spT);

		HRESULT hr(S_OK);
		LONG lCount(0);

		FAILED_THROW_HR(m_spT->get_Count(&lCount));

		return lCount;
	}

	Element operator [] (UINT iIndex)
	{
		FAILED_THROW(E_UNEXPECTED, m_spT);

		CComVariant vIndex;

		vIndex.vt = VT_I4;
		vIndex.lVal = iIndex + 1; // iIndex is zero based

		HRESULT hr(S_OK); 

		Element aElement(Element());

		FAILED_THROW_HR(m_spT->Item(vIndex, &aElement));

		return aElement;
	}
};

template 
<
	typename T,
	typename ISecondaryA = IUnknown,
	typename ISecondaryB = IUnknown,
	typename ISecondaryC = IUnknown,
	typename ISecondaryD = IUnknown,
	typename ISecondaryE = IUnknown,
	typename ISecondaryF = IUnknown,
	typename ISecondaryG = IUnknown,
	typename ISecondaryH = IUnknown,
	typename ISecondaryI = IUnknown
>
class CComMQIPtr : public CComQIPtr<T>
{
private :

	CComPtr<ISecondaryA> m_spSecondaryA;
	CComPtr<ISecondaryB> m_spSecondaryB;
	CComPtr<ISecondaryC> m_spSecondaryC;
	CComPtr<ISecondaryD> m_spSecondaryD;
	CComPtr<ISecondaryE> m_spSecondaryE;
	CComPtr<ISecondaryF> m_spSecondaryF;
	CComPtr<ISecondaryG> m_spSecondaryG;
	CComPtr<ISecondaryH> m_spSecondaryH;
	CComPtr<ISecondaryI> m_spSecondaryI;

	HRESULT QueryInterfaceSecondaryAll(void)
	{
		FAILED_RETURN(E_NOINTERFACE, p);

		if (m_spSecondaryA)
		{
			return S_OK;
		}

		HRESULT hr(S_OK);

		do
		{
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryA));
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryB));
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryC));
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryD));
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryE));
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryF));
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryG));
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryH));
			FAILED_ASSERT_BREAK_HR(QueryInterface(&m_spSecondaryI));
		}
		while (false);

		if (FAILED(hr))
		{
			Release();
			m_spSecondaryA.Release();
			m_spSecondaryB.Release();
			m_spSecondaryC.Release();
			m_spSecondaryD.Release();
			m_spSecondaryE.Release();
			m_spSecondaryF.Release();
			m_spSecondaryG.Release();
			m_spSecondaryH.Release();
			m_spSecondaryI.Release();
		}

		return hr;
	}

protected :

	IUnknown ** GetPredefined(const IID & riid)
	{
		// If this fails, you failed to call QueryInterfaceAll()
		//

		FAILED_ASSERT_RETURN(NULL, p);
		
		if (__uuidof(ISecondaryA) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryA);
		}
		else if (__uuidof(ISecondaryB) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryB);
		}
		else if (__uuidof(ISecondaryC) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryC);
		}
		else if (__uuidof(ISecondaryD) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryD);
		}
		else if (__uuidof(ISecondaryE) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryE);
		}
		else if (__uuidof(ISecondaryF) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryF);
		}
		else if (__uuidof(ISecondaryG) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryG);
		}
		else if (__uuidof(ISecondaryH) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryH);
		}
		else if (__uuidof(ISecondaryI) == riid)
		{
			return reinterpret_cast<IUnknown **>(&m_spSecondaryI);
		}
		else
		{
			return NULL;
		}
	}

public :

	CComMQIPtr() throw()
	{
	}
	CComMQIPtr(T* lp) throw() : CComQIPtr<T>(lp)
	{
		QueryInterfaceSecondaryAll();
	}
	CComMQIPtr(const CComMQIPtr<T, ISecondaryA, ISecondaryB, ISecondaryC, ISecondaryD, ISecondaryE, ISecondaryF, ISecondaryG, ISecondaryH, ISecondaryI>& lp) throw() : CComQIPtr<T>(lp.p)
	{
		QueryInterfaceSecondaryAll();
	}
	CComMQIPtr(IUnknown* lp) throw()
	{
		if (lp != NULL)
		{
			lp->QueryInterface(__uuidof(T), (void **)&p);
			QueryInterfaceSecondaryAll();
		}
	}
	T* operator=(T* lp) throw()
	{
		AtlComPtrAssign((IUnknown**)&p, lp);
		QueryInterfaceSecondaryAll();
		return p;
	}
	T* operator=(const CComMQIPtr<T, ISecondaryA, ISecondaryB, ISecondaryC, ISecondaryD, ISecondaryE, ISecondaryF, ISecondaryG, ISecondaryH, ISecondaryI>& lp) throw()
	{
		AtlComPtrAssign((IUnknown**)&p, lp.p);
		QueryInterfaceSecondaryAll();
		return p;
	}
	T* operator=(IUnknown* lp) throw()
	{
		AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(T));
		QueryInterfaceSecondaryAll();
		return p;
	}

	HRESULT QueryInterfaceAll(void)
	{
		return QueryInterfaceSecondaryAll();
	}

	// Predefined Accessors.  Add your own at will.  Yes, these will AV if you use them incorrectly...
	//
	// 

	CComPtr<IDispatch> & IDispatch(void)
	{
		return *reinterpret_cast<CComPtr<::IDispatch> *>(GetPredefined(__uuidof(::IDispatch)));
	}
};

#define SERVICE_ENTRY_INTERFACE(i) \
		if (InlineIsEqualGUID(guidService, __uuidof(i))) \
			return QueryService(reinterpret_cast<i **>(ppvObject));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\utilctrl.h ===
/////////////////////////////////////////////////////////////////////////////
//  UTILCTRL.H
//      Utility control extensions for use in packages:
//
//      -Grid control
//      -Tree control
//      -Check listbox
//      -Icon listbox
//      -Menu button
//      -Tabbed scrollbar

#ifndef __UTILCTRL_H__
#define __UTILCTRL_H__

#ifndef __DLGBASE_H__
#include "dlgbase.h"
#endif

#ifndef __SHLMENU_H__
#include "shlmenu.h"
#endif

#ifndef __SHLBAR_H__
#include "shlbar.h"
#endif

#ifndef __UTIL_H__
#include "util.h"
#endif

class CSlob;
class CPartFrame;

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA

////////////////////////////////////////////////////////////////////////////
// Grid Classes

class CGridElement;
    class CGridCell;
    class CGridRow;
        class CGridControlRow;
//CWnd
    class CGridWnd;
        class CGridControlWnd;

#define ID_GRD_NEW                      0x4ed0
#define ID_GRD_DELETE                   0x4ed1
#define ID_GRD_MOVEUP                   0x4ed2
#define ID_GRD_MOVEDOWN                 0x4ed3


/////////////////////////////////////////////////////////////////////////////
//  CGridToolBar
//      This is the grid's toolbar 

class CGridToolBar : public CToolBar
{
public:
    enum {
        sizeButtonX = 22,
        sizeButtonY = 20,
        sizeImageX = 14,
        sizeImageY = 12,
    };

    CGridToolBar();
    void SetSizes();
};


/////////////////////////////////////////////////////////////////////////////
//  CStaticVCenter
//      This is a static control that draws text (single line) vertically centered

class CStaticVCenter : public CStatic
{
public:
    afx_msg void OnPaint();
    afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpParams);
    afx_msg void OnNcPaint();

    DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CGridElement -- common base class for things in grids

class CGridElement
{
public:
    virtual ~CGridElement();
    
    void SetCapture();
    void ReleaseCapture();

    void Invalidate(BOOL bErase = FALSE, BOOL bInflate = FALSE);
    
    virtual CGridWnd* GetGrid() const = 0;
    virtual void Draw(CDC* pDC, const CRect& rect) = 0;
    virtual void GetRect(CRect& rect) = 0;
    virtual void ResetSize(CDC* pDC);
    virtual void OnSelect(BOOL bSelected);
    
    virtual CGridElement* ElementFromPoint(const CPoint& point);

    virtual BOOL OnLButtonDown(UINT nFlags, CPoint point);
    virtual BOOL OnLButtonDblClk(UINT nFlags, CPoint point);
    virtual BOOL OnLButtonUp(UINT nFlags, CPoint point);
    virtual BOOL OnMouseMove(UINT nFlags, CPoint point);
    
    virtual void OnActivate(BOOL bActivate, int nColumn);
    virtual void OnControlNotify(UINT nControlID, UINT nNotification);
    virtual CGridRow* GetRow() const;

    BOOL m_bIsCell;
    BOOL m_bWasSelected;
};

/////////////////////////////////////////////////////////////////////////////
// CGridRow -- a row in a grid

class CGridRow : public CGridElement
{
public:
    CGridRow(CGridWnd* pGrid);
    ~CGridRow();
    
    CGridWnd* GetGrid() const
        { return m_pGrid; }
    
    int GetRowHeight() const
        { return m_cyHeight; }

    virtual void GetRect(CRect& rowRect);
    virtual int Compare(const CGridRow* pCompareRow) const;
    
    virtual CSize GetCellSize(CDC* pDC, int nColumn) const;
    
    virtual void Draw(CDC* pDC, const CRect& rect);
    virtual void DrawCell(CDC* pDC, const CRect& rect, int nColumn) = 0;
    
protected:  
    CGridWnd* m_pGrid;
    int m_cyHeight;
    
    friend class CGridWnd;
};

/////////////////////////////////////////////////////////////////////////////
// CGridCell -- once cell in the grid; often sub-classed

class CGridCell : public CGridElement
{
public:
    CGridCell();
    
    virtual void Draw(CDC* pDC, const CRect& cellRect);
    
    virtual CGridRow* GetRow() const;
    
    CGridWnd* GetGrid() const
        { return m_pRow->GetGrid(); }
    
    int GetColumnIndex() const
        { return m_nColumn; }
    
    void Invalidate(BOOL bErase = FALSE);
    void GetRect(CRect& cellRect);
    CSize GetSize() const
        { return m_size; }
    
    virtual void SetText(const TCHAR* szText);
    virtual void ResetSize(CDC* pDC);
    
    CSize m_size;
    CString m_str;
    CGridRow* m_pRow;
    int m_nColumn;
    UINT m_dt; // DrawText() format
};

/////////////////////////////////////////////////////////////////////////////
// CGridControlRow -- a row that supports edit and combo controls

enum GRID_CONTROL_TYPE { none, edit, editCombo, listCombo };

class CGridControlRow : public CGridRow
{
public:
    CGridControlRow(CGridWnd* pGrid);
    ~CGridControlRow();
    
    BOOL CreateControl(GRID_CONTROL_TYPE controlType, int nColumn, DWORD dwStyle = 0);

    // Override to create specialized controls.
    virtual CEdit*  NewEdit( );
    virtual CComboBox* NewCombo( ); 
    virtual void AdjustControlRect ( GRID_CONTROL_TYPE, int nColumn, CRect& textRect);
        
    void GetColumnRect(int nColumn, CRect& rect);
    
    virtual void OnChangeColumnText(int nColumn, const char* szNewText);
    virtual BOOL OnAccept(CWnd* pControlWnd);

    virtual void GetColumnText(int nColumn, CString& str) = 0;
    virtual void AdjustForMargins(CRect& rect, int nColumn);
    virtual int GetNextControlColumn(int nColumn);
    virtual int GetPrevControlColumn(int nColumn);
    virtual void DrawCell(CDC* pDC, const CRect& cellRect, int nColumn);
    virtual void AddListItems(int nColumn, CComboBox* pComboBox);

// Implementation
    void OnControlNotify(UINT nControlID, UINT nNotification);
};

#define cxDefaultGridCellMargin 8
#define cyDefaultGridCellMargin 2

/////////////////////////////////////////////////////////////////////////////
// CGridCellRow -- a row of cells in a grid; rarely sub-classed

class CGridCellRow : public CGridRow
{
public:
    CGridCellRow(CGridWnd* pGrid);
    ~CGridCellRow();
    
    CGridCell* GetCell(int nColumn) const
        { return (CGridCell*)m_cells[nColumn]; }
    
    CSize GetCellSize(int nColumn) const
        { return GetCell(nColumn)->GetSize(); }
    
    virtual void ResetSize(CDC* pDC);
    
    virtual int Compare(const CGridRow* pCompareRow) const;
    
    virtual BOOL CreateCells();
    virtual CGridElement* ElementFromPoint(const CPoint& point);
    virtual void DrawCell(CDC* pDC, const CRect& rect, int nColumn);

protected:  
    CPtrArray m_cells;
};


////////////////////////////////////////////////////////////////////////////
// CGridCaptionCell -- special row at the top of a grid; rarely subclassed

class CGridCaptionCell : public CGridCell
{
public:
    CGridCaptionCell(BOOL bDisplay);
    
    virtual void Draw(CDC* pDC, const CRect& cellRect);

    virtual BOOL OnLButtonDown(UINT nFlags, CPoint point);
    virtual BOOL OnLButtonDblClk(UINT nFlags, CPoint point);
    virtual BOOL OnLButtonUp(UINT nFlags, CPoint point);
    virtual BOOL OnMouseMove(UINT nFlags, CPoint point);
    virtual void ResetSize(CDC* pDC);

    void InvertResizeTracker(CDC* pDC = NULL);
    void SizeFromTracker();

    enum HitZone
    {
        none,
        resizeLeft,
        select,
        resizeRight
    };
    
    HitZone GetHitZone(const CPoint& point);
    
    HitZone m_trackZone; // are we tracking the mouse? why?
    BOOL m_bPressed : 1; // does the caption have that "depressed" look?
    BOOL m_bFixedWidth : 1; // is this column fixed width.
    int m_xSizeTracker; // where is the resize tracking line?
};


////////////////////////////////////////////////////////////////////////////
// CGridCaption -- special row at the top of a grid; rarely subclassed

class CGridCaption : public CGridCellRow
{
public:
    CGridCaption(CGridWnd* pGrid, BOOL bDisplay = TRUE);
    
    void GetRect(CRect& rowRect);
    
    int GetColumnWidth(int nColumn) const
        { return GetCell(nColumn)->m_size.cx; }

    // If column is fixed width, resizing using the mouse is disallowed.
    BOOL IsColumnFixedWidth(int nColumn) const
        { return ((CGridCaptionCell *)GetCell(nColumn))->m_bFixedWidth; }

    void SetColumnFixedWidth(int nColumn, BOOL bFixed = TRUE)
        { ((CGridCaptionCell *)GetCell(nColumn))->m_bFixedWidth = !!bFixed; }
        
    virtual void ResetSize(CDC* pDC);
    BOOL m_bDisplay;
};


/////////////////////////////////////////////////////////////////////////////
// CGridWnd window

// ReplaceControl toolbar flags. T
// You may OR these
#define GRIDWND_TB_NOTOOLBAR    (0)
#define GRIDWND_TB_NEW      (0x0001) // New  button
#define GRIDWND_TB_DELETE   (0x0002) // Delete button
#define GRIDWND_TB_MOVE     (0x0004) // Move Buttons

#define GRIDWND_TB_NEWDEL   (GRIDWND_TB_NEW | GRIDWND_TB_DELETE) // New and Delete buttons
#define GRIDWND_TB_ALL      (GRIDWND_TB_NEW | GRIDWND_TB_DELETE | GRIDWND_TB_MOVE) // New. Delete, Moveup, MoveDown

class CGridWnd : public CWnd
{
    DECLARE_DYNAMIC(CGridWnd)
// Construction
public:
    CGridWnd(int nColumns, BOOL bDisplayCaption = TRUE );
    ~CGridWnd();
    
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
    BOOL CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
    BOOL ReplaceControl(CWnd* pWnd, UINT nIDTemp, UINT nIDGrid, 
        DWORD dwStyle = WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP, 
        DWORD dwExStyle = WS_EX_CLIENTEDGE,
        DWORD dwTBStyle = GRIDWND_TB_NOTOOLBAR,
        BOOL bRemovePlaceholder = TRUE);
    

// Attributes
public:
    int GetRowCount() const
        { return (int)m_rows.GetCount() - 1; }
    
    int GetColumnCount() const
        { return m_nColumnCount; }
        
    int GetColumnWidth(int nColumn) const
        { return GetCaptionRow()->GetColumnWidth(nColumn); }

    CFont* GetFont () const 
    {   return m_pFont; }

    CFont* GetCaptionFont() const  
    { return m_pCaptionFont ; }
    
    COLORREF GetWindowTextColor() const
    { return (m_bSysDefaultColors) ? GetSysColor(COLOR_WINDOWTEXT) : m_colorWindowText; }

    COLORREF GetWindowColor() const
    { return (m_bSysDefaultColors) ? GetSysColor(COLOR_WINDOW) : m_colorWindow; }
    
    COLORREF GetHighlightColor() const
    { return (m_bSysDefaultColors) ? GetSysColor(COLOR_HIGHLIGHT) : m_colorHighlight; }
    
    COLORREF GetHighlightTextColor() const
    { return (m_bSysDefaultColors) ? GetSysColor(COLOR_HIGHLIGHTTEXT) : m_colorHighlightText; }
            
    int ColumnFromX(int x);

// Operations
public:
    void SetColumnCaption(int nColumn, const char* szCaption);
    void SetColumnWidth(int nColumn, int cxWidth);
    void InvalidateColumn(int nColumn, BOOL bErase = FALSE);
    virtual void SortColumn(int nColumn, BOOL bReverse = FALSE);
    void ReSort();
    void SizeColumnToFit(int nColumn);
    CGridElement* ElementFromPoint(const CPoint& point);
    CGridCellRow* AddCellRow();
    virtual void AddRow(CGridRow* pRow, BOOL bRedraw = TRUE );
    virtual void RemoveRow(CGridRow* pRow, BOOL bRedraw = TRUE );
    void SetFont(CFont * pFont, BOOL bRedraw = TRUE );
    void SetCaptionFont( CFont * pFont, BOOL bRedraw = TRUE );
    void SetColor(COLORREF colorText, COLORREF colorBk, COLORREF colorHighlight,
                    COLORREF colorHighlightText); 
    void EnableMultiSelect( BOOL fEnable = TRUE );
    void EnableAutoSort( BOOL bEnable = TRUE );
    void EnableSort(BOOL bEnable = TRUE);

// Overridables
    virtual BOOL BeginDrag(UINT nFlags, const CPoint& point); // return FALSE to drag select, TRUE for D&D
    virtual void DoDragDrop(CPoint point);
    virtual BOOL ProcessKeyboard(MSG* pMsg, BOOL bPreTrans = FALSE);
    virtual void AdjustDropRow(CGridRow* &rpDropRow);
    
// Implementation
public:
    BOOL SubclassDlgItem(UINT nID, CWnd* pParent);
    
    void ResetSize();
    void ResetScrollBars();

// Row access...
    POSITION GetHeadRowPosition() const;
    
    CGridRow* GetNextRow(POSITION& pos) const
        { return (CGridRow*)m_rows.GetNext(pos); }
    
    CGridRow* GetPrevRow(POSITION& pos) const
        { return (CGridRow*)m_rows.GetPrev(pos); }
    
    CGridRow* GetRowAt(POSITION pos) const
        { return (CGridRow*)m_rows.GetAt(pos); }
        
    CGridCellRow* GetCellRowAt(POSITION pos) const
        { VSASSERT(m_bHasCells, "Gotta have cells to get one!"); return (CGridCellRow*)m_rows.GetAt(pos); }
        
    CGridRow* GetRow(int nRow) const
        { return  nRow == -1 ? NULL : (CGridRow*)m_rows.GetAt(m_rows.FindIndex(nRow + 1)); }
    
    CGridCaption* GetCaptionRow() const
        { return (CGridCaption*)m_rows.GetHead(); }
    
// Selection iteration
    POSITION GetHeadSelPosition() const
        { return m_selection.GetHeadPosition(); }
    
    CGridElement* GetNextSel(POSITION& pos) const
        { return (CGridElement*)m_selection.GetNext(pos); }

        
    virtual void VScroll(int cyScroll);
    
    void ClearSelection();
    void ShowSelection(BOOL bShow = TRUE);
    void Select(CGridElement* pElement, BOOL bAdd = FALSE);
    void Deselect(CGridElement* pElement);
    void SelectBetween(CGridElement* pElement1, CGridElement* pElement2);
    void InvalidateSelection(CGridElement* pElement = NULL);
    BOOL IsSelected(CGridElement* pElement) const
        { return m_selection.Find(pElement) != NULL; }
    BOOL LooksSelected(CGridElement* pElement) const
        { return m_bShowSelection && IsSelected(pElement); };
    BOOL IsPrimary(CGridElement* pElement) const
        { return !m_selection.IsEmpty() && m_selection.GetHead() == pElement; }
        
    void ScrollIntoView(CGridRow* pRow);
    
    void SetActiveElement(CGridElement* pElement, int nColumn = -1);
    virtual BOOL CloseActiveElement();

    void AdjustTopVisible();
    
    CPtrList m_rows;
    int m_nColumnCount;
    
    POSITION m_posTopVisibleRow; // first visible row
    int m_cyScroll; // number of pixels of first row scrolled off top
    
    CGridElement* m_pCaptureElement;
    
    POSITION m_posCurRow;
    int m_nCurColumn;
    CPtrList m_selection;
    CGridElement* m_pActiveElement;
    BOOL m_bShowSelection;
    
    int m_nSortColumn;
    BOOL m_bReverseSort;
    
    BOOL m_bHasCells;
    
    CFont* m_pFont ;  // Font to display normal text.
    CFont* m_pCaptionFont ; 

    // Color handling.
    COLORREF m_colorWindowText;
    COLORREF m_colorWindow;
    COLORREF m_colorHighlightText;
    COLORREF m_colorHighlight;
    BOOL     m_bSysDefaultColors;

    BOOL m_bDragSelecting;
    CGridElement* m_pFirstSelect; // where the mouse went down for a drag-select
    CGridElement* m_pLastSelect;
    CGridRow* m_pDropRow;
    CRect m_rcDropInvalidate;
    BOOL m_bEnableEllipse;
    CButton m_Ellipse;

    BOOL m_fMultiSelect;    // TRUE if grid should support multiselect
    BOOL m_bAutoSort:1;         // TRUE if grid should resort after accepting an entry
    BOOL m_bShowContextPopup:1;
    BOOL m_bShowProperties:1;
    BOOL m_bDestruct:1; // TRUE while in the dtor
    BOOL m_bSort:1;     // TRUE if the grid should support any kind of sorting. 
    BOOL m_bEnableDragRow:1;
    BOOL m_bDragRow:1;
    BOOL m_bBtnDownValid:1; // turned off by killfocus during lbuttondown processing

    BOOL m_bParentIsDialog;

    int m_cxSelectMargin;
    static CPoint c_LastClick;

private:
    CStaticVCenter  m_cstatVCenter; // for subclassing toolbar label drawing
    CGridToolBar* m_pToolBar;
    
public: 
    CStaticVCenter* GetPwndGridLabel()  { return &m_cstatVCenter; }
    CGridToolBar*   GetToolBar()    { return m_pToolBar; }

protected:
    void MoveDown(BOOL bShift, BOOL bControl);
    void MoveUp(BOOL bShift, BOOL bControl);

    // Message map functions
    //{{AFX_MSG(CGridWnd)
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnPaint();
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnTimer(UINT_PTR nIDEvent);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnEnable(BOOL bEnable);
    afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CGridControlWnd

class CGridControlWnd : public CGridWnd
{
    DECLARE_DYNAMIC(CGridControlWnd)
public:
    CGridControlWnd(int nColumns, BOOL bDisplayCaption = TRUE);
    ~CGridControlWnd();
    
    GRID_CONTROL_TYPE m_controlType;
    CWnd* m_pControlWnd;
    int m_nControlColumn;

    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual BOOL ProcessKeyboard(MSG* pMsg, BOOL bPreTrans = FALSE);
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    virtual void CGridControlWnd::CancelDrag(void);

    // Control handling
    virtual void ActivatePrevControl();
    virtual void ActivateNextControl();
    virtual void CancelControl();
    virtual BOOL AcceptControl(BOOL bDeactivate = TRUE);
    virtual BOOL CloseActiveElement();
    virtual BOOL FGridToolBarCmd(UINT nID, int nCode);


    virtual BOOL OnCmdMsg( UINT nID, int nCode, void *pExtra, AFX_CMDHANDLERINFO *pHandlerInfo );


protected:
    afx_msg void OnGridNew();           //  New button pressed 
    afx_msg void OnGridDelete();        //  Delete button pressed 
    afx_msg void OnGridMoveUp();        //  Move Up button pressed 
    afx_msg void OnGridMoveDown();      //  Move Down button pressed 
    afx_msg void OnDestroy();

    // Message map functions
protected:
    //{{AFX_MSG(CGridWnd)
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnCut();
    afx_msg void OnCopy();
    afx_msg void OnPaste();
    afx_msg void OnClear();
    afx_msg void OnUndo();
    void OnUpdateCut(CCmdUI *pCmdUI);
    void OnUpdateCopy(CCmdUI *pCmdUI);
    void OnUpdatePaste(CCmdUI *pCmdUI);
    void OnUpdateClear(CCmdUI *pCmdUI);
    void OnUpdateUndo(CCmdUI *pCmdUI);
    void OnUpdateRedo(CCmdUI *pCmdUI);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#define GLN_SELCHANGE (4)
#define ON_SELCHANGE(id, memberFxn) \
    { WM_COMMAND, (WORD)GLN_SELCHANGE, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

#define GLN_ELLIPSE (5)
#define ON_ELLIPSE(id, memberFxn) \
    { WM_COMMAND, (WORD)GLN_ELLIPSE, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

#define GLN_SETFOCUS (6)
#define ON_SETFOCUS(id, memberFxn) \
    { WM_COMMAND, (WORD)GLN_SETFOCUS, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

#define GLN_KILLFOCUS (7)
#define ON_KILLFOCUS(id, memberFxn) \
    { WM_COMMAND, (WORD)GLN_KILLFOCUS, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

#define GLN_ADDSTRING (8)
#define ON_ADDSTRING(id, memberFxn) \
    { WM_COMMAND, (WORD)GLN_ADDSTRING, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

#define GLN_DELETESTRING (9)
#define ON_DELETESTRING(id, memberFxn) \
    { WM_COMMAND, (WORD)GLN_DELETESTRING, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

#define GLN_ACTIVATE_CTL (10)
#define ON_ACTIVATE_CTL(id, memberFxn) \
    { WM_COMMAND, (WORD)GLN_ACTIVATE_CTL, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

#define GLN_ACCEPT_CTL (11)
#define ON_ACCEPT_CTL(id, memberFxn) \
    { WM_COMMAND, (WORD)GLN_ACCEPT_CTL, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

/////////////////////////////////////////////////////////////////////////////
//  Tree control
/////////////////////////////////////////////////////////////////////////////
// Values for CNode::m_nFlags
// CNode -- one entry in a CTreeCtl

// Specify packing becuase this gets used accross DLL's:
// REVIEW64(MikhailA): should it be 8 for IA64?
#pragma pack(4)
class CNode
{
public:
    CNode(DWORD_PTR dwData);
    virtual ~CNode();
    
    virtual CFont* GetFont() const;
    virtual int GetGlyphWidth();
    virtual int GetGlyphHeight();

    CNode* m_pParent;
    int m_nLevels;
    DWORD_PTR m_dwData;
    WORD m_nFlags;
    TCHAR* m_szText;
    int  m_nWidth;
    static int m_nGlyphWidth;
};
#pragma pack()

#define TF_LASTLEVELENTRY       0x0001
#define TF_HASCHILDREN          0x0002
#define TF_EXPANDED             0x0004
#define TF_DISABLED             0x0008
#define TF_EXPANDABLE           0x0020
#define TF_NOT_EXPANDABLE       0x0040
#define TF_DIRTY_CONTENT        0x0080
#define TF_DIRTY_ITEM           0x0010
#define TF_DROPTARGET           0x0100
#define TF_DRAGSOURCE           0x0200
#define TF_CHILD_SORT_ALPHA     0x0400
#define TF_CHILD_SORT_OVERRIDE  0x0800
#define TF_CHILD_SORT_NONE      0x1000

#define LIST_ALPHA_SEARCH_DELAY (1)


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTreeListBox item

class CTreeListBox : public CListBox
{
    DECLARE_DYNCREATE(CTreeListBox)

    CTreeListBox();

private:
    int ItemFromPoint(const CPoint& point);

    class CTreeCtl* m_pTree;
    BOOL m_bGotMouseDown : 1;
    BOOL m_bDeferedDeselection : 1;
    BOOL m_bStdMouse : 1;
    int m_nDeferedItem;
    int m_nLastItem;

    static int iSlobPixels;
    static CPoint mouseDownPt;
    static CPoint m_mouseDownScreenPt;

    friend class CTreeCtl;

protected:
    virtual BOOL    PreTranslateMessage(MSG *pMsg);

    // Generated message map functions
protected:
    //{{AFX_MSG(CTreeListBox)
    afx_msg void OnLButtonDown(UINT, CPoint);
    afx_msg void OnLButtonUp(UINT, CPoint);
    afx_msg void OnLButtonDblClk(UINT, CPoint);
    afx_msg void OnRButtonUp(UINT, CPoint);
    afx_msg void OnRButtonDown(UINT, CPoint);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt);
    afx_msg void OnMouseMove(UINT, CPoint);
    afx_msg void OnChar(UINT nChar, UINT nRepCount, UINT nFlags);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTreeCtl window

class CTreeCtl : public CWnd
{
    DECLARE_DYNCREATE(CTreeCtl)
    DECLARE_MESSAGE_MAP()

// Construction
public:
    CTreeCtl(BOOL bIsMultiSelection = FALSE, BOOL bKeepSelectionRect = FALSE);
    
    BOOL PreCreateWindow(CREATESTRUCT& cs);

// Attributes
public:
    virtual void SetContextHelpID(DWORD dwContextHelpId);

protected:
    BOOL m_bIsMultiSelection : 1;   // Allow multiple selections;
    BOOL m_bKeepSelectionRect : 1;  // keep the selecton rect when not focus
    BOOL m_bEnableDragDrop : 1;
    BOOL m_bShowContextPopup : 1;
    BOOL m_bShowProperties : 1;
    BOOL m_bSortRootNodes : 1;      // are root nodes to be sorted alphabetically?
    BOOL m_bVertLineAction : 1;     // is action taken when vertical line clicked on?
    BOOL m_bPopupClippedText : 1;   // pop up full node text when clicked on?

    CTreeListBox *m_pListBox;   // our only child

    CFont * m_pFont;

    CSize m_sizeM;              // size of an "M" in the current font
                                // used to determine horiz/vert tree bar dimensions

    int m_cyNode;               // height of one node in the list
    int m_cxExtent;             // approximate width of the whole list
    int m_cxOffset;             // horizontal offset for paints (used when a widget
                                // scrollbar is used for a horizontal scroll bar)
    
    int m_EnableUpdates;        // Reference count of update holding;

    CString m_strSearch;        // typomatic search string
    time_t  m_timeLastKey;      // time since last typomatic key stroke

    int m_nLastParentIndex;     // used for cacheing next insertion point in unsorted tree portions
    int m_nNextInsertIndex;     // used for cacheing next insertion point in unsorted tree portions

// Operations
public:
    // expansion/contraction

    // override this method so that containment can be determined
    virtual BOOL NodeIsExpandable(CNode *);
    
    // *must* override this method so that the text of a node can be
    // determined through means other than the passed 'sz' arg to InsertNode
    // N.B. generally this is for the a node that was set dirty
    virtual void GetNodeTitle(CNode *, CString &);

    // This can be overriden if you want to display text different to that
    // specified as the 'sz' text. Unlike GetNodeTitle this method does
    // NOT alter the 'sz' text of the node.
    virtual void GetDisplayText(CNode *, CString &);

    // expand/collapse a node (referenced by index)
    void Expand(int nIndex = -1, BOOL bWholeBranch = FALSE);
    void Collapse(int nIndex = -1);
    void Refresh(int nIndex = -1);
    void RefreshAllRoots();

    // expand all nodes (full-expansion)
    void ExpandAll();

    // is a particular node expanded?
    // override this if you want to determine expandedness another way.
    virtual BOOL IsExpanded(int nIndex = -1);
    
    // does a particular node have children?
    // override this if you want to determine child presence another way.
    virtual BOOL HasChildren(int nIndex = -1);

    // get/set the node dwData (referenced by index)
    DWORD_PTR GetData(int nIndex = -1);
    void SetData(int nIndex, DWORD_PTR dwData);

    // get/set the current selection
    int GetCurSel() { return m_pListBox->GetCurSel(); }
    void SetCurSel(int nIndex) { m_pListBox->SetCurSel(nIndex); }
    virtual void KeySetSel(int nIndex, BOOL bClearSearchBuffer = TRUE);

    // get/set the current selection if multi-select is on
    int GetCount() { return m_pListBox->GetCount(); }
    int GetSelCount() { return m_pListBox->GetSelCount(); }
    int GetSelItems(int nMaxItems, LPINT rgItems) { return m_pListBox->GetSelItems(nMaxItems, rgItems); }
    int SetSel(int nIndex, BOOL bSelect = TRUE) { return m_pListBox->SetSel(nIndex, bSelect); }
    void SelectAll()
        { SetSel(-1, TRUE); }

    // our tree-control node modification functions
    int FindNode(DWORD_PTR dwData);
    int FindNode(const TCHAR * szText, DWORD_PTR & dwData, BOOL fMatchCase = FALSE);
    int InsertNode(int iParentNode, const char* szName, DWORD_PTR dwData);
    void DirtyNode(int iNode, WORD, BOOL bInvalItem = TRUE);    // where the 2nd arg. is TF_DIRTY_???
    void ClearNode(int iNode, WORD, BOOL bInvalItem = TRUE);    // where the 2nd arg. is TF_DIRTY_???
    void RemoveNode(int iNode, BOOL bUpdateSel = TRUE);

    virtual void RecalcHorizontalExtent();
    void ClearSearchBuffer();
    
    int ItemFromPoint(const CPoint& point)
        { return m_pListBox->ItemFromPoint(point); }

    int GetItemRect(int nItem, LPRECT lpRect)
        { return m_pListBox->GetItemRect(nItem, lpRect); }

    virtual void CreateListBox()
        { m_pListBox = new CTreeListBox; }

    virtual CListBox* GetListBox()
        { return m_pListBox; }
        
    int GetItemHeight() const
        { return m_cyNode; }
        
    int GetHorzExtent() const
        { return m_cxExtent; }
        
    void SetHorzExtent(int nExtent)
        { m_cxExtent = nExtent; }
        
    int GetHorzOffset() const
        { return m_cxOffset; }

    void SetHorzOffset(int nOffset)
        { m_cxOffset = nOffset; }

    CSize GetSizeM() const
        { return m_sizeM; }

    BOOL PopsUpClippedText()
        { return m_bPopupClippedText; }

    enum HIT_ZONE { left, vertline, expand, glyph, text, right };
    
    HIT_ZONE HitTest(int nItem, int x);
    
    // override these methods to support your own actions for the user input

    virtual void DoOpenItem(int nIndex);            // called on click on +/- glyphs
    virtual void OnOpen(int nIndex);                // called on Enter key or double-click
    virtual void OnSelect(int nIndex);              // called on selection change

    virtual BOOL OnKeyDown(UINT nChar);             // called on any Keydown msg
    virtual BOOL OnChar(UINT nChar);                    // called on any Char msg

    // specific key handlers
    void OnPrimary();
    void OnExpand();
    void OnExpandBranch();
    void OnExpandAll();
    void OnCollapse();
    
    virtual void OnRightButtonUp(UINT, CPoint);     // called on right mouse button up
    virtual void OnRightButtonDown(UINT, CPoint);   // called on right mouse button down
    virtual void OnContextMenu(CWnd* pWnd, CPoint pt);
    
// Implementation
public:
    virtual ~CTreeCtl();
    void FreeAllTreeData();
    
    virtual BOOL PreTranslateMessage(MSG* pMsg);

    virtual BOOL InsertLevel(CNode* pNode, int nIndex, BOOL bExpandAll = FALSE);
    virtual void DrawNodeGlyph(CDC* pDC, CNode* pNode, BOOL bHighlight, CPoint pt);
    
    BOOL InsertNode(CNode* pParentNode, int iParentNode, const char* szName,
                    DWORD_PTR dwData, CNode*& rpNodeRet, int& riNodeRet, BOOL bUseNodeRet = FALSE);
    virtual void Collapse(CNode* pNode, int nIndex);
    void Refresh(CNode* pNode, int nIndex);
    CNode* GetNode(int nIndex = -1);
    void ResetSizes(CDC* pDC);
    void InvalSelection();
    void InvalItem(int nItem);

    int  GetMaxItemExent () { return m_cxExtent; };

    // For save/loading expanded state:
    BYTE* GetInitData();
    void SizeViewToTree(CPartFrame *pFrame);

    void HoldUpdates ();
    void EnableUpdates ();

    virtual int CompareData(const CNode* pNode1, const CNode* pNode2);
    int CompareNodes(const CNode* pNode1, const CNode* pNode2);

    virtual CNode* CreateNode(DWORD_PTR dwData);
    virtual void DeleteNode(CNode* pNode);

    virtual void BeginDragDrop();

    // Generated message map functions

protected:
    //{{AFX_MSG(CTreeCtl)
    afx_msg int OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex);
    afx_msg void OnDestroy();
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnPaint();
    afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
    afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    //}}AFX_MSG
    afx_msg void OnLbDblClk();
    afx_msg void OnLbSelChange();
    afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetFont(WPARAM wParam, LPARAM lParam);
    
    static CImageWell c_imageWell;
    static int c_cyBorder;      // SM_CYBORDER
    static int c_cyBorderX2;    // SM_CYBORDER * 2
    
    friend class CTreeListBox;
};

#define IDCW_TREELISTBOX    1 // child id for listbox
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Check listbox
//
// A CCheckList is a listbox with a checkbox to the left of each item.
// The user interface is exactly the same as a listbox with these
// exceptions:
//
//     * Left mouse button clicks (or double clicks) on the checkbox
//       part of an item toggle the check state.
//     * Pressing the spacebar when an item is selected will toggle
//       the check state of that item.
//     * For multi-sel listbox's, the spacebar will cycle through the
//       four state combinations (unselected-unchecked, selected-unchecked,
//       unselected-checked, selected-checked).
//
// These controls may be created explicitly with Create(), or existing
// listbox windows may be "subclassed" with SubclassDlgItem().
//
// When creating one of these (or specifying one in a dialog template)
// make sure the LBS_OWNERDRAWFIXED and LBS_HASSTRINGS styles are set.
//
// The class supports different sized fonts and will ensure that items
// are tall enough to contain both the box and the text.  The font may
// be changed dynamically.
//
// The default implementation uses the item data to store the state
// of the checkbox.  If the item data is needed for some other purpose,
// the SetCheck() and GetCheck() functions should be overrided to
// use an alternate storage location.

#define CLN_CHKCHANGE (20)
#define ON_CLN_CHKCHANGE(id, memberFxn) \
    { WM_COMMAND, (WORD)CLN_CHKCHANGE, (WORD)id, (WORD)id, AfxSig_vv, \
        (AFX_PMSG)memberFxn },

class CCheckList : public CListBox
{
// Construction
public:
    CCheckList();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
public:
    virtual BOOL IsTriState(int nItem) {return FALSE;}
    // nCheck -
    // 0 = unchecked
    // 1 = checked
    // 2 = undeterminate
    virtual void SetCheck(int nItem, int nCheck);
    virtual int GetCheck(int nItem);

// Operations
public:
    BOOL SubclassDlgItem(UINT nID, CWnd* pParent);

// Implementation
protected:
    void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    void MeasureItem(LPMEASUREITEMSTRUCT lpmis);
    void InvalidateCheck(int nItem);
    void ResetItemHeight();

    virtual void ItemStringOut (CDC * pDC, const CString& strOut, const CRect& rect);
    
    int m_cyItem;   // Height of item including check box
    int m_cyText;   // Height of text only
    static CBitmap c_checkBitmap;
    static CSize c_checkSize;

    // Message map functions
protected:
    //{{AFX_MSG(CCheckList)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    //}}AFX_MSG
    LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

    virtual void GetDisplayText(int index, CDC *pDC, const CRect&, CString& strOut);
};


/////////////////////////////////////////////////////////////////////////////
// CPropCheckList window - a check-list that can show/set property values

class CPropCheckList : public CCheckList
{
public:
    virtual void OnPropChanged(UINT nIDProp);

    // add an association between item text and property to the list
    int AddItem(const char* szId, UINT nIDProp);

    // which CSlob do the properties in this list belong to?
    inline void SetSlob(CSlob* pSlob) {m_pSlob = pSlob;}

protected:
    // provide property processing
    virtual BOOL IsTriState(int);
    virtual void SetCheck(int, int);
    virtual int GetCheck(int);

private:
    CSlob * m_pSlob;
};

//#undef AFX_DATA
//#define AFX_DATA NEAR

#endif  // __UTILCTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCCodeModelsInternal.h ===
#pragma once

#include <vccodemodels.h>

#include "VCDesignerObjectInternal.h"
#include <textmgr.h>
#include <vsshell.h>
#include <vcbudefs.h>
#include <bscext.h>
#include <ncparex.h>


// HRESULTs
//

#define S_CM_ZOMBIE					0x4CE00001

#define E_CM_NCB_UNAVAILABLE		0x8CE00001
#define E_CM_ZOMBIE					0x8CE00002
#define E_CM_GLOBAL_IINST			0x8CE00003
#define E_CM_UNRESOLVABLE_BASE		0x8CE00004
#define E_CM_UNDONE					0x8CE00005
#define E_CM_UNDONE_MCxx			0x8CE00006
#define E_CM_UNDONE_FORMS			0x8CE00007
#define E_CM_UNDONE_LAME			0x8CE00008
#define E_CM_UNDONE_POSTPONABLE		0x8CE00009
#define E_CM_POSTPONED				0x8CE0000A
#define E_CM_FILE_NOT_IN_PROJECT	0x8CE0000B
#define E_CM_INTRINSIC_NAME			0x8CE00011
#define E_CM_INVALID_IDENTIFIER		0x8CE00012
#define E_CM_READONLY				0x8CE00013
#define E_CM_NOT_READY				0x8CE00014


// VC Code Models Internal.h
//


// Things the users must never, never see...
//
// Therefore, it is OKAY to use inheritance.
//

enum vsCMPosition
{
	vsCMPositionInvalid = -1,
	vsCMPositionDeclaration = 0, // Declaration, including specifiers not including attribute block
	vsCMPositionDefinition = 1, // Definition, including specifiers not including attribute block
	vsCMPositionFullDefinition = 2, // Entire definition, from beginning of attributes to semi-colon.
	vsCMPositionAttributeBlock = 3,
	vsCMPositionDefinitionFullBody = 4, // From before open curly to afer end curly
	vsCMPositionDefinitionBody = 5, // From after open curly to before end curly
	vsCMPositionDeclarationName = 6,
	vsCMPositionDefinitionName = 7
};


// VCCMLocation
//

typedef DWORD VCCMLocationFlags;

const VCCMLocationFlags vccmLocationModule			(0x01);
const VCCMLocationFlags vccmLocationStartLine		(0x02);
const VCCMLocationFlags vccmLocationStartColumn		(0x04);
const VCCMLocationFlags vccmLocationEndLine			(0x08);
const VCCMLocationFlags vccmLocationEndColumn		(0x10);
const VCCMLocationFlags vccmLocationIVsTextLines	(0x20);
const VCCMLocationFlags vccmLocationStart			(vccmLocationModule | vccmLocationStartLine | vccmLocationStartColumn);
const VCCMLocationFlags vccmLocationEnd				(vccmLocationModule | vccmLocationEndLine | vccmLocationEndColumn);
const VCCMLocationFlags vccmLocationNCB				(vccmLocationModule | vccmLocationStartLine | vccmLocationEndLine);
const VCCMLocationFlags vccmLocationAll				(vccmLocationModule | vccmLocationStart | vccmLocationEnd | vccmLocationIVsTextLines);

enum vcCMRelativePosition
{
	vcCMRelativePositionUndetermined,
	vcCMRelativePositionOnly,
	vcCMRelativePositionOnlyNoBoundary,
	vcCMRelativePositionFirst,
	vcCMRelativePositionLast,
	vcCMRelativePositionInterior
};

class CVCCMLocation
{
public :

	VCCMLocationFlags m_vccmLocationFlags;
	vcCMRelativePosition m_RelativePosition;

	CComBSTR bstrModule;
	LONG dwStartLine;
	LONG dwStartColumn;
	LONG dwEndLine;
	LONG dwEndColumn;
	CComPtr<IVsTextLines> spIVsTextLines;

	CVCCMLocation(VCCMLocationFlags vccmLocationFlags = vccmLocationAll)
	: m_vccmLocationFlags(vccmLocationFlags), 
	  m_RelativePosition(vcCMRelativePositionUndetermined),
	  dwStartLine(-1), 
	  dwStartColumn(-1), 
	  dwEndLine(-1), 
	  dwEndColumn(-1)
	{
	}

	CVCCMLocation(const CVCCMLocation & rSource)
	: m_vccmLocationFlags(rSource.m_vccmLocationFlags), 
	  m_RelativePosition(rSource.m_RelativePosition),
	  bstrModule(rSource.bstrModule),
	  dwStartLine(rSource.dwStartLine), 
	  dwStartColumn(rSource.dwStartColumn), 
	  dwEndLine(rSource.dwEndLine), 
	  dwEndColumn(rSource.dwEndColumn),
	  spIVsTextLines(rSource.spIVsTextLines)
	{
	}

	CVCCMLocation & operator = (const CVCCMLocation & rSource)
	{
		m_vccmLocationFlags = rSource.m_vccmLocationFlags; 
		m_RelativePosition = rSource.m_RelativePosition;
		bstrModule = rSource.bstrModule;
		dwStartLine = rSource.dwStartLine; 
		dwStartColumn = rSource.dwStartColumn; 
		dwEndLine = rSource.dwEndLine; 
		dwEndColumn = rSource.dwEndColumn;
		spIVsTextLines = rSource.spIVsTextLines;

		return *this;
	}

	// This resets all the internal values
	void Reset(void)
	{
		bstrModule.Empty();
		spIVsTextLines.Release();
		dwStartColumn = -1;
		dwStartLine = -1;
		dwEndColumn = -1;
		dwEndLine = -1;
		m_RelativePosition = vcCMRelativePositionUndetermined;
	}

	bool ExactLocationRequested(void)
	{ 
		return 0 != (m_vccmLocationFlags & (vccmLocationStartColumn | vccmLocationEndColumn));
	}

	bool IVsTextLinesRequested(void)
	{
		return 0 != (m_vccmLocationFlags & vccmLocationIVsTextLines);
	}

	bool operator == (const CVCCMLocation & vccmlOther)
	{
		if (!bstrModule || !vccmlOther.bstrModule)
		{
			return false;
		}
		else if (_wcsicmp(bstrModule, vccmlOther.bstrModule))
		{
			return false;
		}
		else if (dwStartLine != vccmlOther.dwStartLine ||
			dwStartColumn != vccmlOther.dwStartColumn ||
			dwEndLine != vccmlOther.dwEndLine ||
			dwEndColumn != vccmlOther.dwEndColumn)
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	bool Contains(const CVCCMLocation & vccmlOther)
	{
		// REVIEW : For now, "Contains" means "Contains the start of"
		//

		if (!bstrModule || !vccmlOther.bstrModule)
		{
			return false;
		} 
		if (_wcsicmp(bstrModule, vccmlOther.bstrModule))
		{
			return false;
		}
		if (-1 == dwStartLine || -1 == dwEndLine || 
			-1 == dwStartColumn || -1 == dwEndColumn || 
			-1 == vccmlOther.dwStartLine || -1 == vccmlOther.dwEndLine ||
			-1 == vccmlOther.dwStartColumn || -1 == vccmlOther.dwEndColumn)
		{
			return false;
		}
		
		if (vccmlOther.dwStartLine < dwStartLine || vccmlOther.dwStartLine > dwEndLine)
		{
			return false;
		}
		else if (vccmlOther.dwStartLine == dwStartLine)
		{
			return vccmlOther.dwStartColumn >= dwStartColumn;
		}
		else if (vccmlOther.dwStartLine == dwEndLine)
		{
			return vccmlOther.dwStartColumn <= dwEndColumn;
		}
		else
		{
			return true;
		}
	}
};

[
	uuid(29BF7879-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCCodeElementI : public VCDesignElementI
{
public :

	virtual HRESULT STDMETHODCALLTYPE Remove(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE IsInSolution(BOOL * pbIsInSolution) =0;
	virtual HRESULT STDMETHODCALLTYPE get_PrimaryCollection(CodeElements ** ppCodeElements) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetLocation(const vsCMPart Part, const vsCMWhere Where, 
		CVCCMLocation &	vccmLocation) = 0;
	virtual HRESULT STDMETHODCALLTYPE NavigateTo(const vsCMWhere Where, const vsCMPart Part = vsCMPartName) = 0;
};


[
	uuid(BFEE2CBD-0725-4d2c-B6D9-DC57086DAA59),
]
class ATL_NO_VTABLE VCNcbElementI : public VCCodeElementI
{
public :

	virtual HRESULT STDMETHODCALLTYPE GetBSC(BscEx ** ppBscEx) = 0;
	virtual HRESULT STDMETHODCALLTYPE get_usage(UsageType * pusage) = 0;
};


[
	uuid(C0D88760-94AC-463b-B3C9-45D657129B30),
]
class ATL_NO_VTABLE VCIinstElementI : public VCNcbElementI
{
public :

	virtual HRESULT STDMETHODCALLTYPE put_IINST(IINST iinst) = 0;
	virtual HRESULT STDMETHODCALLTYPE get_IINST(IINST * piinst) = 0;
	virtual HRESULT STDMETHODCALLTYPE get_UnnamedName(BSTR * pbstrUnnamedName) = 0;
};


[
	uuid(29BF787A-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCCodeAttributeI : public VCIinstElementI
{
public :

	virtual HRESULT STDMETHODCALLTYPE get_IndexInGrammar(LONG * pnIndex) = 0;
};


[
	uuid(29BF789A-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCFileCodeModelI : public VCIinstElementI
{
public :

	STDMETHOD(put_IMOD)(IMOD imod) = 0;
	STDMETHOD(get_IMOD)(IMOD * pimod) = 0;
};


[
	uuid(29BF787E-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCCodeParameterI : public VCNcbElementI
{
public :

	virtual HRESULT STDMETHODCALLTYPE put_Index(LONG nIndex) = 0;
};


// IVCCodeElementCollectionDO_Internal
//

[
	uuid(29BF787F-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCCodeElementsI : public VCDesignElementsI
{
public :

	virtual HRESULT STDMETHODCALLTYPE put_ElementKind(vsCMElement Kind) = 0;
	virtual HRESULT STDMETHODCALLTYPE get_ElementKind(vsCMElement * pKind) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetFilter(BSTR bstrFilter) = 0;
	virtual HRESULT STDMETHODCALLTYPE Sort(vsCMSort vscmSort) = 0;
};

[
	uuid(29BF789B-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCIinstElementsI : public VCCodeElementsI
{
public :

	virtual HRESULT STDMETHODCALLTYPE LinkOrCreate(IINST iinst) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddCreate(IINST iinst) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddLink(IINST iinst, LPDISPATCH pDisp) = 0;
};

[
	uuid(2857E25D-05A0-4db2-8571-D759DEB5B815),
]
class ATL_NO_VTABLE VCFileElementsI : public VCIinstElementsI
{
public :

	virtual HRESULT STDMETHODCALLTYPE put_IMOD(IMOD imod) = 0;
};

// The VC Code Element Service.
//

[
	uuid(29BF7880-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCCodeModelService : public IUnknown
{
public :

	// Process UpdateItems & add events to the event queue
	//

	virtual HRESULT STDMETHODCALLTYPE FileUpdate(UpdateItem * pUpdates, ULONG cUpdates) = 0;
	
	// Flushes the event queue
	//

	virtual HRESULT STDMETHODCALLTYPE FireEvents(void) = 0;

	// Given an IINST, gives back the CodeElement that represents it.
	//

	virtual HRESULT STDMETHODCALLTYPE LookupIINST(IINST iinst, IDispatch ** ppIDispatch) = 0;

	// Given an IINST, gives back the CodeElement that represents it.
	//

	virtual HRESULT STDMETHODCALLTYPE IsReady(BOOL * pbReady) = 0;

	// Create a blank VC Code Model Object
	//

	virtual HRESULT STDMETHODCALLTYPE CreateCodeModel(VCCodeModel ** ppCodeModel) = 0;

	// Create a blank VC Full Code Model Object
	//

	virtual HRESULT STDMETHODCALLTYPE CreateFullCodeModel(VCCodeModel ** ppFullCodeModel) = 0;

	// Create a blank VC File Code Model Object
	//

	virtual HRESULT STDMETHODCALLTYPE CreateFileCodeModel(BSTR bstrFileName, VCFileCodeModel ** ppVCFileCodeModel) = 0;

	virtual HRESULT STDMETHODCALLTYPE OnBufferChanged(IVsTextLines * pTextLines) = 0;
};

#define SID_SVCCodeModelService __uuidof(VCCodeModelService)

[
	uuid(29BF7882-FE8C-11d2-AAE9-00C04F72DB55)
]
class ATL_NO_VTABLE VCCodeTypeI : public VCIinstElementI
{
public :
	virtual HRESULT STDMETHODCALLTYPE AddMemberFunction
	(
		vsCMAccess Access, LPCWSTR wstrName, LPCWSTR bstrProtoHeader, LPCWSTR bstrProto,
		LPCWSTR bstrFunctionBody, LPCWSTR bstrImplFileName, vsCMAddPosition AddPosition, IDispatch** ppDispatch
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE ValidateMember
	(
		BSTR bstrName, vsCMElement AddedKind, BSTR bstrType, VARIANT_BOOL* pbValid
	) = 0;

	virtual HRESULT STDMETHODCALLTYPE ReplaceChildMethodNames
	(
		UINT level,
		BSTR bstrOldName,
		BSTR bstrName
	) = 0;
};


[
	uuid(29BF7883-FE8C-11d2-AAE9-00C04F72DB55)
]
class ATL_NO_VTABLE VCCodeTypeRefI : public VCDesignElementI
{
public :

	virtual HRESULT STDMETHODCALLTYPE put_CodeModel(VCCodeModel * pVCCodeModel) = 0;
	virtual HRESULT STDMETHODCALLTYPE put_TypeString(BSTR bstrType) = 0;
};

[
	uuid(29BF787D-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCCodeModelI : public VCIinstElementI
{
public :

	// UNDONE : Remove Me, perhaps
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCAssert.h ===
#pragma once

// VCASSERT_*
//

#define VCASSERT(expression) VSASSERT(expression, #expression)

//SetErrorInfo
//
inline HRESULT VCSetErrorInfo(DWORD ResID, HRESULT hResult)
{
#if 0
	va_list args; va_start(args, hResult);
	CComBSTR bstrText;
	CStringW strText;

	if(bstrText.LoadString(_pModule->GetResourceInstance(), ResID))
	{
		strText.Format(bstrText, args);
		return AtlReportError(GUID_NULL, strText, IID_NULL, hResult);
	}
	return hResult;
#else
	return AtlReportError(GUID_NULL, ResID, IID_NULL, hResult, _pModule->GetResourceInstance());
#endif
}

inline HRESULT VCSetErrorInfo(DWORD ResID, LPCWSTR wstrName, HRESULT hResult, const IID & riid)
{
	CComBSTR bstrText;
	CStringW strText;

	if(bstrText.LoadString(_pModule->GetResourceInstance(), ResID))
	{
		strText.Format(bstrText, wstrName);
		return AtlReportError(GUID_NULL, strText, riid, hResult);
	}
	return hResult;
}
inline HRESULT VCSetErrorInfo(DWORD ResID, LPCWSTR wstrName, LPCWSTR wstrName2, HRESULT hResult, const IID & riid)
{
	CComBSTR bstrText;
	CStringW strText;

	if(bstrText.LoadString(_pModule->GetResourceInstance(), ResID))
	{
		strText.Format(bstrText, wstrName, wstrName2);
		return AtlReportError(GUID_NULL, strText, riid, hResult);
	}
	return hResult;
}
inline HRESULT VCSetErrorInfo(DWORD ResID, LPCWSTR wstrName, LPCWSTR wstrName2, LPCWSTR wstrName3, HRESULT hResult, const IID & riid)
{
	CComBSTR bstrText;
	CStringW strText;

	if(bstrText.LoadString(_pModule->GetResourceInstance(), ResID))
	{
		strText.Format(bstrText, wstrName, wstrName2, wstrName3);
		return AtlReportError(GUID_NULL, strText, riid, hResult);
	}
	return hResult;
}

inline HRESULT VCSetErrorInfo(DWORD ResID, LPCWSTR wstrName, HRESULT hResult)
{
	return VCSetErrorInfo(ResID, wstrName, hResult, IID_NULL);
}

// FAILED_*
//

// Just to be able to set a breakpoint and stop if something
// fails
//

inline bool VCFailedBreakpoint(void)
{
	static bool bBreakOnFailure(false);
	return bBreakOnFailure;
}

template<typename TResult>
bool VCFailed(TResult tr)
{
	if (TRUE == !tr)
	{
		return true;
	}
	else
	{
		return false;
	}
}

inline bool VCFailed(HRESULT hr)
{
	if (FAILED(hr))
	{
		return true;
	}
	else
	{
		return false;
	}
}

inline bool VCFailedStrict(HRESULT hr)
{
	if (S_OK != hr)
	{
		return true;
	}
	else
	{
		return false;
	}
}

class CVCUSetErrorInfo
{
public :

	const UINT m_nID;
	const UINT m_cpwsz;
	const WCHAR * m_rgpwsz[3]; // For now, just handle up to three optional strings for Format().

	CVCUSetErrorInfo(UINT nID, const WCHAR * pwszA = NULL, const WCHAR * pwszB = NULL, const WCHAR * pwszC = NULL) 
		: m_nID(nID), m_cpwsz((pwszA ? 1 : 0) + (pwszB ? 1 : 0) + (pwszC ? 1 : 0))
	{
		m_rgpwsz[0] = pwszA;
		m_rgpwsz[1] = pwszB;
		m_rgpwsz[2] = pwszC;
	}
};

template<typename TResult>
bool VCFailedSEI(TResult tr, const CVCUSetErrorInfo & sei)
{
	if (VCFailed(tr))
	{
		HRESULT hrSEI(S_OK);

		CStringW wstrMessageRaw;
		CStringW wstrMessage;

		hrSEI = wstrMessageRaw.LoadString(sei.m_nID);
		VCASSERT(SUCCEEDED(hrSEI));

		switch (sei.m_cpwsz)
		{
		case 0 :
			wstrMessage = wstrMessageRaw;
			break;
		case 1 :
			wstrMessage.Format(wstrMessageRaw, sei.m_rgpwsz[0]);
			break;
		case 2 :
			wstrMessage.Format(wstrMessageRaw, sei.m_rgpwsz[0], sei.m_rgpwsz[1]);
			break;
		case 3 :
			wstrMessage.Format(wstrMessageRaw, sei.m_rgpwsz[0], sei.m_rgpwsz[1], sei.m_rgpwsz[2]);
			break;
		default :
			VSFAIL(L"Need to add more space in CVCUSetErrorInfo");
			break;
		}

		hrSEI = AtlReportError(CLSID_NULL, wstrMessage, GUID_NULL, E_FAIL);
		VCASSERT(E_FAIL == hrSEI);

		return true;
	}

	return false;
}

inline bool VCFailedSEI(HRESULT hr, const CVCUSetErrorInfo & sei)
{
	if (VCFailed(hr))
	{
		HRESULT hrSEI(S_OK);

		CStringW wstrMessageRaw;
		CStringW wstrMessage;

		hrSEI = wstrMessageRaw.LoadString(sei.m_nID);
		VCASSERT(SUCCEEDED(hrSEI));

		switch (sei.m_cpwsz)
		{
		case 0 :
			wstrMessage = wstrMessageRaw;
			break;
		case 1 :
			wstrMessage.Format(wstrMessageRaw, sei.m_rgpwsz[0]);
			break;
		case 2 :
			wstrMessage.Format(wstrMessageRaw, sei.m_rgpwsz[0], sei.m_rgpwsz[1]);
			break;
		case 3 :
			wstrMessage.Format(wstrMessageRaw, sei.m_rgpwsz[0], sei.m_rgpwsz[1], sei.m_rgpwsz[2]);
			break;
		default :
			VSFAIL(L"Need to add more space in CVCUSetErrorInfo");
			break;
		}

		hrSEI = AtlReportError(CLSID_NULL, wstrMessage, GUID_NULL, hr);
		VCASSERT(hr == hrSEI);

		return true;
	}

	return false;
}

#define FAILED_RETURN_HR(expression) \
\
do \
{ \
	if (VCFailed(hr = (expression))) \
	{ \
		if (VCFailedBreakpoint()) \
		{ \
			VSFAIL(#expression); \
		} \
		\
		return hr; \
	} \
} while (false)

#define FAILED_STRICT_RETURN_HR(expression) \
\
do \
{ \
	if (VCFailedStrict(hr = (expression))) \
	{ \
		if (VCFailedBreakpoint()) \
		{ \
			VSFAIL(#expression); \
		} \
		\
		return hr; \
	} \
} while (false)

#define FAILED_SEI_RETURN_HR(argv, expression) \
\
do \
{ \
	if (VCFailed(hr = (expression))) \
	{ \
		VCFailedSEI(hr, CVCUSetErrorInfo##argv); \
		\
		if (VCFailedBreakpoint()) \
		{ \
			VSFAIL(#expression); \
		} \
		\
		return hr; \
	} \
} while (false)

#define FAILED_ASSERT_RETURN_HR(expression) \
\
do \
{ \
	if (VCFailed(hr = (expression))) \
	{ \
		VSFAIL(#expression); \
		return hr; \
	} \
} while (false)

#define FAILED_SEI_ASSERT_RETURN_HR(argv, expression) \
\
do \
{ \
	if (VCFailed(hr = (expression))) \
	{ \
		VCFailedSEI(hr, CVCUSetErrorInfo##argv); \
		VSFAIL(#expression); \
		return hr; \
	} \
} while (false)

#define FAILED_RETURN(return_expression, expression) \
\
do \
{ \
	if (VCFailed(expression)) \
	{ \
		if (VCFailedBreakpoint()) \
		{ \
			VSFAIL(#expression); \
		} \
		\
		return return_expression; \
	} \
} while (false)

#define FAILED_SEI_RETURN(argv, return_expression, expression) \
\
do \
{ \
	if (VCFailed(expression)) \
	{ \
		VCFailedSEI(E_FAIL, CVCUSetErrorInfo##argv); \
		\
		if (VCFailedBreakpoint()) \
		{ \
			VSFAIL(#expression); \
		} \
		\
		return return_expression; \
	} \
} while (false)

#define FAILED_ASSERT_RETURN(return_expression, expression) FAILED_ASSERTMESSAGE_RETURN(return_expression, expression, #expression)

#define FAILED_ASSERTMESSAGE_RETURN(return_expression, expression, message) \
\
do \
{ \
	if (VCFailed(expression)) \
	{ \
		VSFAIL(message); \
		return return_expression; \
	} \
} while (false)

#define FAILED_ASSERT_EXIT(expression) FAILED_ASSERTMESSAGE_EXIT(expression, #expression)

#define FAILED_ASSERTMESSAGE_EXIT(expression, message) \
\
do \
{ \
	if (VCFailed(expression)) \
	{ \
		VSFAIL(message); \
		return; \
	} \
} while (false)

#define FAILED_SEI_ASSERT_RETURN(argv, return_expression, expression) \
\
do \
{ \
	if (VCFailed(expression)) \
	{ \
		VCFailedSEI(E_FAIL, CVCUSetErrorInfo##argv); \
		VSFAIL(#expression); \
		return return_expression; \
	} \
} while (false)

#define FAILED_BREAK_HR(expression) \
\
if (VCFailed(hr = (expression))) \
{ \
	if (VCFailedBreakpoint()) \
	{ \
		VSFAIL(#expression); \
	} \
	\
	break; \
} \
else \
{ \
}


#define FAILED_SEI_BREAK(argv, break_expression, expression) \
\
if (VCFailed(expression)) \
{ \
	VCFailedSEI(E_FAIL, CVCUSetErrorInfo##argv); \
	\
	if (VCFailedBreakpoint()) \
	{ \
		VSFAIL(#expression); \
	} \
	\
	break_expression; \
	break; \
} \
else \
{ \
}

#define FAILED_SEI_BREAK_HR(argv, expression) \
\
if (VCFailed(hr = (expression))) \
{ \
	VCFailedSEI(hr, CVCUSetErrorInfo##argv); \
	\
	if (VCFailedBreakpoint()) \
	{ \
		VSFAIL(#expression); \
	} \
	\
	break; \
} \
else \
{ \
}

#define FAILED_ASSERT_BREAK_HR(expression) \
\
if (VCFailed(hr = (expression))) \
{ \
	VSFAIL(#expression); \
	break; \
} \
else \
{ \
}

#define FAILED_BREAK(break_expression, expression) \
\
if (VCFailed(expression)) \
{ \
	if (VCFailedBreakpoint()) \
	{ \
		VSFAIL(#expression); \
	} \
	\
	break_expression; \
	break; \
} \
else \
{ \
}

#define FAILED_ASSERT_BREAK(break_expression, expression) \
\
if (VCFailed(expression)) \
{ \
	VSFAIL(#expression); \
	break_expression; \
	break; \
} \
else \
{ \
}

#define FAILED_THROW_HR(expression) \
\
do \
{ \
	if (VCFailed(hr = (expression))) \
	{ \
		if (VCFailedBreakpoint()) \
		{ \
			VSFAIL(#expression); \
		} \
		\
		throw hr; \
	} \
} while (false)

#define FAILED_ASSERT_THROW_HR(expression) \
\
do \
{ \
	if (VCFailed(hr = (expression))) \
	{ \
		VSFAIL(#expression); \
		throw hr; \
	} \
} while (false)

#define FAILED_THROW(throw_expression, expression) \
\
do \
{ \
	if (VCFailed(expression)) \
	{ \
		if (VCFailedBreakpoint()) \
		{ \
			VSFAIL(#expression); \
		} \
		\
		throw throw_expression; \
	} \
} while (false)

#define FAILED_ASSERT_THROW(throw_expression, expression) \
\
do \
{ \
	if (VCFailed(expression)) \
	{ \
		VSFAIL(#expression); \
		throw throw_expression; \
	} \
} while (false)


// VALIDATE_* (E_INVALIDARG)
//

template<typename T>
bool ValidateReadPointer(T * pT, const char * pszName)
{
	if (IsBadReadPtr(pT, sizeof(T)))
	{
		#if defined(_DEBUG)
		CString strMessage;
		strMessage.Format(_T("'%s' is not a valid read pointer"), pszName);
		VSFAIL(strMessage);
		#endif
		return false; 
	}

	return true;
}

template<typename T>
bool ValidateWritePointer(T * pT, const char * pszName)
{
	if (IsBadWritePtr(pT, sizeof(T)))
	{
		#if defined(_DEBUG)
		CString strMessage;
		strMessage.Format(_T("'%s' is not a valid write pointer"), pszName);
		VSFAIL(strMessage);
		#endif
		return false; 
	}

	return true;
}

// REVIEW : Should ValidateAndClear return HRESULT?
template<typename T>
bool ValidateAndClear(T * pT, const char * pszName)
{
	FAILED_RETURN(false, ValidateWritePointer(pT, pszName));
	*pT = T();
	return true;
}

inline bool ValidateAndClear(VARIANT_BOOL * pT, const char * pszName)
{
	FAILED_RETURN(false, ValidateWritePointer(pT, pszName));
	*pT = VARIANT_FALSE;
	return true;
}

inline bool ValidateAndClear(VARIANT * pT, const char * pszName)
{
	FAILED_RETURN(false, ValidateWritePointer(pT, pszName));
	VariantInit(pT);
	return true;
}

inline bool ValidateAndClear(BSTR * pT, const char * pszName)
{
	FAILED_RETURN(false, ValidateWritePointer(pT, pszName));
	*pT = NULL;
	return true;
}

inline bool ValidateRange(INT nValue, INT nMinimum, INT nMaximum, const char * pszName)
{
	#if defined(_DEBUG)

	bool bInRange(nValue <= nMaximum && nValue >= nMinimum);

	if (!bInRange)
	{
		CString strMessage;
		strMessage.Format(_T("'%s' is out of range, must be between %d and %d."), pszName, nMinimum, nMaximum);
		VSFAIL(strMessage);
	}

	#endif

	return nValue <= nMaximum && nValue >= nMinimum;
}


#define VALIDATE_ARGUMENT(expression) FAILED_ASSERT_RETURN(E_INVALIDARG, (expression))
#define VALIDATE_ARGUMENTMESSAGE(expression, message) FAILED_ASSERTMESSAGE_RETURN(E_INVALIDARG, (expression), (message))
#define VALIDATE_MEMBER(expression) FAILED_ASSERT_RETURN(E_FAIL, (expression))
#define VALIDATE_MEMBERMESSAGE(expression, message) FAILED_ASSERTMESSAGE_RETURN(E_FAIL, (expression), (message))
// UNDONE : Rename VALIDATE_AND_CLEAR to VALIDATE_AND_CLEAR_POINTER
#define VALIDATE_AND_CLEAR(p) VALIDATE_AND_CLEAR_POINTER(p)
#define VALIDATE_AND_CLEAR_POINTER(p) FAILED_ASSERT_RETURN(E_INVALIDARG, ValidateAndClear(p, #p))
#define VALIDATE_READ_POINTER(return_expression, expression) FAILED_ASSERT_RETURN(return_expression, ValidateReadPointer(expression, #expression))
#define VALIDATE_READ_POINTER_HR(expression) VALIDATE_READ_POINTER(E_POINTER, expression)
#define VALIDATE_WRITE_POINTER(return_expression, expression) FAILED_ASSERT_RETURN(return_expression, ValidateWritePointer(expression, #expression))
#define VALIDATE_WRITE_POINTER_HR(expression) VALIDATE_WRITE_POINTER(E_POINTER, expression)
#define VALIDATE_RANGE_HR(expression, minimum, maximum) VALIDATE_ARGUMENT(ValidateRange(expression, minimum, maximum, #expression))

// CHECK_*
//

#define CHECK_STATE_RETURN(state) FAILED_RETURN(E_UNEXPECTED, (state))
#define CHECK_STATE_ASSERT_RETURN(state) FAILED_ASSERT_RETURN(E_UNEXPECTED, (state))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\util.h ===
/////////////////////////////////////////////////////////////////////////////
//	UTIL.H
//		Mostly GDI and file utilities.

#ifndef __UTIL_H__
#define __UTIL_H__

#include "msf.h"
#include "stdfont.h"
#include "slob.h"

#ifndef __UTIL2_H__
// MBS <-> WCS conversion with truncation
#define _wcstombsz(lpszDest, lpszSrc, nMaxBytes) \
	wcstombs(lpszDest, lpszSrc, nMaxBytes), lpszDest[nMaxBytes-1] = 0
#endif	// __UTIL2_H__

//#undef AFX_DATA
//#define AFX_DATA AFX_EXT_DATA
/////////////////////////////////////////////////////////////////////////////
//	CLockDC
//		A CDC which handles locking and unlocking of updates to its window.
//		Used during drag loops.

class CLockDC : public CDC
{
public:
	CLockDC(CWnd* pWnd);
	~CLockDC();

protected:
	BOOL m_bLock;
	HWND m_hWnd;
};

/////////////////////////////////////////////////////////////////////////////
//	CImageWell
//		class provides a convenient way to handle "tiled" bitmaps.

class CImageWell
{
public:
	CImageWell();
	CImageWell(UINT nBitmapID, CSize imageSize);
	~CImageWell();
	void SetBitmap (CBitmap *pBitmap, CSize imageSize);
	
	BOOL Open();
	BOOL IsOpen() { return m_dc.m_hDC != NULL; }
	void Close();
	BOOL Load(UINT nBitmapID, CSize imageSize);
	BOOL LoadSysColor(UINT nBitmapID, CSize imageSize);
	BOOL Attach(HBITMAP hBitmap, CSize imageSize);
	HBITMAP Detach();
	void Unload();
	
	BOOL CalculateMask();
	
	BOOL DrawImage(CDC* pDestDC, CPoint destPoint, UINT nImage, 
		DWORD rop = 0); // rop==0 means image is drawn through a mask

	BOOL DrawImage(CDC* pDestDC, CPoint destPoint, UINT nImage, CSize sizeOverride,
		DWORD rop = 0); // rop==0 means image is drawn through a mask

	BOOL DrawMask(CDC* pDestDC, CPoint destPoint, UINT nImage, DWORD rop = NOTSRCCOPY);

	void GetImageSize(CSize& csImage)
	{
		csImage = m_imageSize;
	}
	
protected:
		
	CSize m_imageSize;
	
	// We use either this pointer or our member bitmap:
	CBitmap *m_pbitmap;

	UINT m_nBitmapID;
	CBitmap m_bitmap;
	
	CDC m_dc;
	CBitmap m_mask;
	CDC m_maskDC;
};

// hard-coded colors to be used instead of COLOR_BTNFACE, _BTNTEXT, etc.
//  - these are for access via MyGetSysColor() - and GetSysBrush()
#define CMP_COLOR_HILITE    21  // RGB(255, 255, 255)
#define CMP_COLOR_LTGRAY    22  // RGB(192, 192, 192) - instead of BtnFace
#define CMP_COLOR_DKGRAY    23  // RGB(128, 128, 128)
#define CMP_COLOR_BLACK     24  // RGB(0, 0, 0) - instead of frame

// - these are for when all you need is a RGB value)
#define CMP_RGB_HILITE      RGB(255, 255, 255)
#define CMP_RGB_LTGRAY      RGB(192, 192, 192)  // instead of BtnFace
#define CMP_RGB_DKGRAY      RGB(128, 128, 128)
#define CMP_RGB_BLACK       RGB(0, 0, 0)        // instead of frame

extern CBrush* GetSysBrush(UINT nSysColor);
extern void ResetSysBrushes();
extern CPen* GetSysPen(UINT nSysColor);
extern COLORREF MyGetSysColor(UINT nSysColor);

#define DSx		0x00660046L		// BitBlt ROPs
#define DSna	0x00220326L

// Paint this button "out," closer to the user.
#ifndef TBBS_EXTRUDED
#define TBBS_EXTRUDED 0x100
#endif

extern void DrawSplitter(CDC *pdc, CRect rect, BOOL bVert);
// Creates a push-button style bitmap
extern HBITMAP CreateButtonBitmap(CWnd* pWnd, UINT nStyle,  LPCRECT lpRect,
	CBitmap* pbmGlyph = NULL, LPCTSTR lpszText = NULL, BOOL bAddArrow = FALSE);
// creates a command bar style bitmap
extern HBITMAP CreateBarBitmap(CWnd* pWnd, UINT nStyle,  LPCRECT lpRect, CSize sizeButton, CSize sizeImage);

extern void ForceRectOnScreen(CRect& rect);
extern void ForceRectBelowTop(CRect& rect);

// For single pixel borders that are not actually window borders.
// Window borders should use system calculated border dimensions.
//
#define CX_BORDER 1
#define CY_BORDER 1
#define CY_TOOLBAR 28	// Toolbar height without borders.

extern BOOL PollForMouseChange(CPoint& pt, BOOL bYield, BOOL& bCancel, BOOL bAllowPaint=FALSE);
extern void FlushKeys();

typedef enum
{
	unknown_platform	= 0,	// Not yet used -- error condition!
	win32x86			= 1,
	win16x86			= 2,
	mac68k				= 3,
	macppc				= 4,
	win32mips			= 5,
	win32alpha			= 6,
	win32ppc			= 7,
    unsupported         = 8,
    generic             = 9,
    vistest             = 10,
	win64merced			= 20,
	win64alpha			= 21,
	xbox				= 30,
} uniq_platform;

extern UINT GetExePlatform(LPCTSTR szExeName);

#include <mmsystem.h>
extern BOOL PlayDevSound(UINT idsEvent, DWORD dwFlags = SND_ASYNC | SND_NODEFAULT);
extern BOOL PlayDevSound(const char* szEvent, DWORD dwFlags = SND_ASYNC | SND_NODEFAULT);
extern BOOL RegisterDevSoundEvent(UINT idsEventName, UINT idsFriendlyName);
extern BOOL RegisterDevSoundEvent(const char* szEventName, const char* szFriendlyName);

BOOL InEmergencyState();

// TRUE if a CCmdui is any kind of context menu
extern BOOL IsContextMenu(CCmdUI* pCmdUI);
extern BOOL IsMenu(CCmdUI* pCmdUI);
// Enable the menu if it has any visible items
extern void UpdateMenuCommand(CCmdUI* pCmdUI);

#ifdef _DEBUG
BOOL GetLogUndoFlag();
#endif

///////////////////////////////////////////////////////////////////////////////
//	CFileSaver
//		This is a little helper class for writing things to temporary files
//		and giving them the correct name after the save suceeds.

class CFileSaver
{
public:
	CFileSaver(const TCHAR* szFileName); // setup and create temp names
	~CFileSaver();                      // make sure temp files are gone
	BOOL CanSave() const;				// checks for R/O
	BOOL MakeWriteable() const;			// forces status of file to NOT R/O
	const TCHAR* GetSafeName() const     // return name of file to create
		{ return m_strTempName; }
	const TCHAR* GetRealName() const		// return name of final file
		{ return m_strName; }
	BOOL Finish();                      // rename new file as original

private:
	CString m_strName;
	CString m_strBackupName;
	CString m_strTempName;
	
	static const TCHAR BASED_CODE c_szAps [];
};

/////////////////////////////////////////////////////////////////////////////
//	CInitFile
class CInitFile : public CMemFile
{
	DECLARE_DYNAMIC(CInitFile)

private:
	using CMemFile::Open;

public:
	enum INIT_DATATYPE { dataNil, dataReg, dataResource, dataStorage, dataMSF };

// Constructors
public:
	CInitFile();
	~CInitFile();
	
// Operations
public:
	BOOL Open(LPCSTR szSection, LPCSTR szKey, UINT nOpenFlags,
		INIT_DATATYPE type = dataReg);
	BOOL Open(LPSTORAGE pStorage, CString strStream, UINT nOpenFlags);
	BOOL Open(MSF *pmsf, WORD sn, UINT nOpenFlags);

	void SetBuffer(HGLOBAL hglobMem, UINT nCountBytes = -1,
		INIT_DATATYPE type = dataReg);
	HGLOBAL GetInitData();

	virtual void Close();	  // throw (CFileException);
	virtual void Abort();

protected:
	BOOL LoadFromSource();
	BOOL WriteToDest();

// Attributes
protected:
	BOOL m_bWrite;
	INIT_DATATYPE m_type;

	MSF *m_pmsf;
	WORD m_sn;

	LPCSTR m_lpszSection;
	LPCSTR m_lpszKey;

	HGLOBAL m_hglobUserMem;

	CString  m_strStream;
	LPSTREAM m_lpStream;

#ifdef _DEBUG
	virtual void AssertValid() const;
#endif
};
///////////////////////////////////////////////////////////////////////////////
//	CStateSaver

#define szWorkspaceSection _T("Workspace")
#define chMonikerSep _T('\n')

class CStateSaver
{
public:
	CStateSaver(BOOL bSaving);
	~CStateSaver();

	BOOL OpenMSF(LPCTSTR szFilePath, BOOL bForceWriteable);
	BOOL OpenStorage(LPCTSTR szFilePath);
	BOOL OpenStream(CInitFile& fileInit, CString strStream);
	void CloseStorage();
	BOOL Finish();

    const TCHAR * GetFileName() const { return (const TCHAR *)m_strFileName; }

	BOOL IsStoring() const { return m_bSaving; }
	BOOL IsLoading() const { return !m_bSaving; }
	BOOL IsFileBased() const { return (m_lpStorage != NULL || m_pMSF != NULL); }
	BOOL OpenFile(CInitFile& fileInit, SN nStream, LPCSTR szSection, LPCSTR szKey);

// Attributes
protected:
	BOOL m_bSaving;
	CFileSaver* m_pSaver;
    CString m_strFileName;
	LPSTORAGE m_lpStorage;

	MSF *m_pMSF;
};

/////////////////////////////////////////////////////////////////////////////
//	COLEStorage

class COLEStorage : public CObject
{
// Construction
public:
	COLEStorage(BOOL bReadOnly = TRUE);
	~COLEStorage();

// Attributes
public:
	LPCTSTR GetName();

// Operations
public:
	void Open(LPCTSTR lpszPath);
	void Create(LPCTSTR lpszPath);

// Sub-storage & stream operations
public:
	void OpenStream(LPCTSTR lpszName, COleStreamFile* pStream);
	void CreateStream(LPCTSTR lpszName, COleStreamFile* pStream);

	void OpenStorage(LPCTSTR lpszName, COLEStorage* pStorage);
	void CreateStorage(LPCTSTR lpszName, COLEStorage* pStorage);

// Implementation
protected:
	void* m_pStorage;
	DWORD m_grfMode;
};


/////////////////////////////////////////////////////////////////////////////
//	CDefProvidedNode
//		this node type is added to the list of default node provider package
//		nodes which the project window asks for if there is no user-preference
//		information	for the project which is being opened/created.
//	REVIEW(PatBr):  This should be turned into an interface, and moved
//					into prjapi.h along with the package workspace interface.

typedef BOOL (CALLBACK *FILESAVECALLBACK)();

class CDefProvidedNode : public CObject
{
public:
	CDefProvidedNode() {}
	virtual ~CDefProvidedNode() {}

	enum SORT_TYPE { content_sort, alpha_sort };

	// packages must subclass the CDefProvidedNode class
	// in order to have meaningful node types. they should provide:

	// whether the default node should reside on its
	// own pane in the project window, and...
	virtual BOOL HasOwnPane() { return(TRUE); }

	// ...if the node has its own pane, whether the pane is 
	// workspace-independent (e.g., the HelpView pane is), and...
	virtual BOOL IsPaneIndependent() { return(FALSE); }

	// .. the type of sorting desired on the top-level nodes in the pane, and...
	virtual SORT_TYPE GetSortType() { return(alpha_sort); }

	// .. the help identifier used when user asks for help with this pane active...
	virtual UINT GetHelpID() { return((UINT)-1); }

	// ...a string to use as the name for the pane, and...
	virtual const TCHAR *GetPaneName() = 0;

	// ...a function which can be called to create the node,
	// which returns a pointer to a slob which will then be
	// inserted into the pane (this can be a CMultiSlob if the
	// node provider wants to insert more than one root node), and...
	virtual CSlob *CreateNode() = 0;

	// ...a function which returns the priority index of the pane.
	// currently: Classes=100, Resources=300, Build=500, Help=700, and...
	virtual int GetPriorityIndex() = 0;

	// ...a function which returns (if appropriate) a file-save callback
	// which the project window can use for command routing/enabling, and...
	virtual FILESAVECALLBACK GetFileSaveCallback() { return(NULL); }

	// ... a function to initialize the glyph bitmap for the pane.  the
	// bitmap should contain three bitmaps (12x12, 9x9, 4x4) in a 36x12
	// bitmap which can be used to initialize a CImageWell.  The three
	// different sizes are for varying sizes of scrollbars (16x16 on
	// WindowsNT but user-defined (default:13x13) on Windows'95).
	// caller of this function will perform DeleteObject() on HBITMAP.
	virtual HBITMAP GetPaneGlyph() = 0;

	//ugly hack.  The node is the only workspace-related thing that the 
	//res package seems to subclass.  So when we're initing the workspace 
	//window, the only way to know if we're dealing with ResourceView 
	//(which we don't want to expand for performance reasons), is to
	//ask the node.  So the res pkg overrides this to return FALSE.
	//All other packages should not need to override this.
	virtual	BOOL ShouldExpand() { return TRUE; }

};

// convert the windows ansi code page to the iso code page
// used by the htmx and htm packages for the code page
// meta data html tag
BOOL AnsiCodePageToIsoCodePage(/*[in]*/ LPCTSTR szAnsi, /*[out]*/ CString *pstrIso);

/////////////////////////////////////////////////////////////////////////////

void SetActiveView(HWND hwnd);

/////////////////////////////////////////////////////////////////////////////
//      Global dimensions
namespace MSDevShell
{
typedef struct tagSCREEN_METRIC
{
    int cxBorder, cyBorder;
    int cxFrame, cyFrame;
    int cxToolBorder, cyToolBorder;
	int cxToolCaption, cyToolCaption;
	int cxToolCapBorder, cyToolCapBorder;
	int cxToolCapGap, cyToolCapGap;			// gap between tool caption buttons
	int cxToolCapButton, cyToolCapButton;
    int nSplitter;
} SCREEN_METRIC;

extern SCREEN_METRIC g_mt;

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

struct GLOBAL_DATA
{
	// system metrics
	int cxBorder2, cyBorder2;

	// device metrics for screen
	int cxPixelsPerInch, cyPixelsPerInch;

	// button glyph sizes
	CSize csSmallButtonGlyph;
	CSize csLargeButtonGlyph;
	// button enclosure sizes
	CSize csSmallButton;
	CSize csLargeButton;

	// small icon size (includes caption bar)
	CSize csSmallIcon;
	// right end of caption bar button sizes
	CSize csCaptionButton;
	// gap between restore button and close button (horz and vertical orientations)
	int cxPreCloseGap;
	int cyPreCloseGap;
	int cxPostCloseGap;
	int cyPostCloseGap;
	int cxPreMinimizeGap;
	int cyPreMinimizeGap;

	int tmDoubleClick;
	int cxDoubleClick;
	int cyDoubleClick;

	// solid brushes with convenient gray colors and system colors
	HBRUSH hbrLtGray, hbrDkGray;
	HBRUSH hbrBtnHilite, hbrBtnFace, hbrBtnShadow;
	HBRUSH hbrWindowFrame;
	HPEN hpenBtnHilite, hpenBtnShadow, hpenBtnText;

	// color values of system colors used for CToolBar
	COLORREF clrBtnFace, clrBtnShadow, clr3dDkShadow, clrBtnHilite;
	COLORREF clrBtnText, clrGrayText, clrWindowFrame, clrMenu;

	// special GDI objects allocated on demand
	HFONT   hStatusFont;
	HFONT   hToolTipsFont;
	HFONT   hButtonVerticalFont;
	HFONT	hButtonVerticalFontLarge;

	// auxiliary toolbar bitmaps
	HBITMAP hbmMenuArrow;
	HBITMAP hbmMenuArrowDisabled;
	HBITMAP hbmMenuArrowVertical;
	HBITMAP hbmMenuArrowVerticalDisabled;

	// other system information
	UINT    nWinVer;			// Major.Minor version numbers
	BOOL	bWin32s;			// TRUE if Win32s (or Windows 95)
	BOOL    bWin4;				// TRUE if Windows 4.0
	BOOL    bNotWin4;			// TRUE if not Windows 4.0
	BOOL    bSmCaption;			// TRUE if WS_EX_SMCAPTION is supported
	BOOL	bWin31; 			// TRUE if actually Win32s on Windows 3.1
	int		nMenuShowDelay;		// delay for menus in milliseconds (SPI_MENUSHOWDELAY)

// Implementation
	GLOBAL_DATA();
	~GLOBAL_DATA();
	void UpdateSysColors();
	void UpdateSysMetrics();

	// MenuTextOut -
	// This function does all of the text drawing for CmdBar menus and buttons.
	// Its advantage over ExtTextOut is that it draws shadowed disabled text and
	// it underlines characters after the & character. The reason that we
	// ExtTextOut instead of DrawText is that buttons in vertically dock toolbars
	// require a vertical font which DrawText doesn't support.

	enum eMenuTextOut
	{
		// This are bit flags.
		e_mtoLeftAlign = 1,		// Align with the left edge
		e_mtoCenterAlign = 2,		// Center horizontally.
		e_mtoRightAlign = 4,
		e_mtoVertical = 8,			// Set if text is vertical for docking toolbars
		e_mtoDisabled = 16			// Set if the text is gray.
	};


	void MenuTextOut(CDC* pDC, 
					 const CRect* pRect,	// Bounding rectangle
					 const CString& text, 
					 UINT eFlags = e_mtoLeftAlign) ;


	// this routine is used to draw the 'embossed' disabled text used in menus and
	// buttons under Win95 and NT4. Windows doesn't export a routine that does this,
	// and there are several special cases to be accounted for, including mono monitors
	// the case when the menu and 3d colours are different, and handling for NT3.51.

	// This routine draws using the currently selected font at the point specified, using 
	// TA_TOP | TA_CENTRE
	
	// martynl 2ndApr96

//	void DrawDisabledText(CDC *pDC, CPoint ptPos, const CString &text, 
//						  eDrawDisabledTextFlags eFlags = e_Default,
//						  const CRect* pRect = NULL );
	// DER - 7 Jun 96 Revamped for menus
	// Now uses TA_TOP | TA_LEFT
	void DisabledTextOut(	CDC *pDC, 
							const CRect* pRect,
							const CString &text,
							UINT eFlags) ;


	// Draws text using ExtTextOut, but will underline strings with accelerators.
	// Used by DrawDisabledText which requires ExtTextOut for vertical text.
//	BOOL UnderlineTextOut(CDC* pdc, int x, int y, BOOL bVertical, 
//						  LPCTSTR str) ;//const CString& str);

	void UnderlineTextOut(CDC* pdc, 
						   const CRect* pRect,
						   LPCTSTR str, 
						   UINT eFlags) ;

	// Find the size of the text not counting the accelerator characters.
	CSize GetTextExtentNoAmpersands(CDC* pdc, const CString& str ) const;
	static TCHAR ExtractAccelerator(LPCTSTR item);
	static int StripAmpersands(TCHAR* pstart, int len);

	// duplicates the given bitmap (segment)
	static HBITMAP DuplicateBitmap(CWnd *pWnd, HBITMAP hbmBitmap, CSize size=CSize(0,0), CPoint offset=CPoint(0,0));
	// scales one bitmap into another
	static BOOL ScaleBitmap(CWnd *pWnd, HBITMAP dest, CSize destSize, CPoint destOffset, const HBITMAP src, CSize srcSize);
	// use when the dc is already prepared
	static BOOL ScaleBitmap(HDC hdcDest, CSize destSize, CPoint destOffset, const HBITMAP src, CSize srcSize);
	// pastes a clipboard glyph into an image well
	static void PasteGlyph(CWnd *pWnd, HBITMAP hbmWell, int nIndex, CSize sizeImage);

	// accessor functions for load-on-demand items
	HFONT GetButtonFont(BOOL bLarge);
	HFONT GetButtonVerticalFont(BOOL bLarge);

	static HBITMAP LoadSysColorBitmap(UINT id);
	HBITMAP GetMenuArrow(void);
	HBITMAP GetMenuArrowDisabled(void);
	HBITMAP GetMenuArrowVertical(void);
	HBITMAP GetMenuArrowVerticalDisabled(void);

	// gets the bold/nonbold menu font pointer
	CFont *GetMenuFont(BOOL bDefault);
	CFont *GetMenuVerticalFont();
	int GetMenuTextHeight(void);
	int GetMenuVerticalHeight(void);
	BOOL GetLargeMenuButtons(void);
	// flushes the menu fonts during update
	void FlushMenuFonts(void);

	// Bitmap and DIB utility functions
	static WORD GLOBAL_DATA::DibNumColors(VOID FAR * pv); // Pointer to the bitmap info header structure
	static WORD GLOBAL_DATA::PaletteSize(VOID FAR * pv);  // Pointer to the bitmap info header structure
	static HANDLE GLOBAL_DATA::SaveSysColorBitmap(HBITMAP hbmSrc);
	static HANDLE GLOBAL_DATA::CreateLogicalDib(	HBITMAP hbm,        // DDB to copy
											WORD biBits,        // New DIB: bit count: 8, 4, or 0
											HPALETTE hpal);      // New DIB: palette
	static HBITMAP GLOBAL_DATA::LoadSysColorBitmap(LPBITMAPINFOHEADER lpBitmap);

private:
	CFont *	pFontMenuText;				// font used to draw menu items. In dire emergencies, this might be a ptr to font_normal
	BOOL    bDeleteMenuText;
	CFont *	pFontMenuVertical;				// font used to draw vertical menu bars. In dire emergencies, this might be a ptr to something else
	BOOL    bDeleteMenuVertical;
	CFont *	pFontMenuBold;				// font used to draw bold menu items. In dire emergencies, this might be a ptr to font_large
	BOOL    bDeleteMenuBold;
	int		nMenuTextHeight;			// height of pFontMenuText
	int		nMenuVerticalHeight;		// height of pFontMenuVertical
	BOOL	bLargeMenuButtons;			// toolbar buttons in menus are large 

};

extern GLOBAL_DATA globalData;
} // Namespace Shell

//#undef AFX_DATA
//#define AFX_DATA NEAR

#endif  // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\vccoll.inl ===
// (KPerry) This was the MFC collection stuff
// Now it has been purged of all other MFC influences and is a stand alone entity.

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for VCCOLL.H

#if _MSC_VER > 1000
#pragma once
#endif



////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCByteArray::GetSize() const
	{ return m_nSize; }
inline INT_PTR CVCByteArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CVCByteArray::RemoveAll()
	{ SetSize(0); }
inline BYTE CVCByteArray::GetAt(INT_PTR nIndex) const
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline void CVCByteArray::SetAt(INT_PTR nIndex, BYTE newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline BYTE& CVCByteArray::ElementAt(INT_PTR nIndex)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline const BYTE* CVCByteArray::GetData() const
	{ return (const BYTE*)m_pData; }
inline BYTE* CVCByteArray::GetData()
	{ return (BYTE*)m_pData; }
inline INT_PTR CVCByteArray::Add(BYTE newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline BYTE CVCByteArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
inline BYTE& CVCByteArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCWordArray::GetSize() const
	{ return m_nSize; }
inline INT_PTR CVCWordArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CVCWordArray::RemoveAll()
	{ SetSize(0); }
inline WORD CVCWordArray::GetAt(INT_PTR nIndex) const
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline void CVCWordArray::SetAt(INT_PTR nIndex, WORD newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline WORD& CVCWordArray::ElementAt(INT_PTR nIndex)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline const WORD* CVCWordArray::GetData() const
	{ return (const WORD*)m_pData; }
inline WORD* CVCWordArray::GetData()
	{ return (WORD*)m_pData; }
inline INT_PTR CVCWordArray::Add(WORD newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline WORD CVCWordArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
inline WORD& CVCWordArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCDWordArray::GetSize() const
	{ return m_nSize; }
inline INT_PTR CVCDWordArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CVCDWordArray::RemoveAll()
	{ SetSize(0); }
inline DWORD CVCDWordArray::GetAt(INT_PTR nIndex) const
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline void CVCDWordArray::SetAt(INT_PTR nIndex, DWORD newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline DWORD& CVCDWordArray::ElementAt(INT_PTR nIndex)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline const DWORD* CVCDWordArray::GetData() const
	{ return (const DWORD*)m_pData; }
inline DWORD* CVCDWordArray::GetData()
	{ return (DWORD*)m_pData; }
inline INT_PTR CVCDWordArray::Add(DWORD newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline DWORD CVCDWordArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
inline DWORD& CVCDWordArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCUIntArray::GetSize() const
	{ return m_nSize; }
inline INT_PTR CVCUIntArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CVCUIntArray::RemoveAll()
	{ SetSize(0); }
inline UINT CVCUIntArray::GetAt(INT_PTR nIndex) const
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline void CVCUIntArray::SetAt(INT_PTR nIndex, UINT newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline UINT& CVCUIntArray::ElementAt(INT_PTR nIndex)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline const UINT* CVCUIntArray::GetData() const
	{ return (const UINT*)m_pData; }
inline UINT* CVCUIntArray::GetData()
	{ return (UINT*)m_pData; }
inline INT_PTR CVCUIntArray::Add(UINT newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline UINT CVCUIntArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
inline UINT& CVCUIntArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCPtrArray::GetSize() const
	{ return m_nSize; }
inline INT_PTR CVCPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CVCPtrArray::RemoveAll()
	{ SetSize(0); }
inline void* CVCPtrArray::GetAt(INT_PTR nIndex) const
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline void CVCPtrArray::SetAt(INT_PTR nIndex, void* newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline void*& CVCPtrArray::ElementAt(INT_PTR nIndex)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline const void** CVCPtrArray::GetData() const
	{ return (const void**)m_pData; }
inline void** CVCPtrArray::GetData()
	{ return (void**)m_pData; }
inline INT_PTR CVCPtrArray::Add(void* newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline void* CVCPtrArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
inline void*& CVCPtrArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCPtrList::GetCount() const
	{ return m_nCount; }
inline BOOL CVCPtrList::IsEmpty() const
	{ return m_nCount == 0; }
inline void*& CVCPtrList::GetHead()
	{ VSASSERT(m_pNodeHead != NULL, "GetHead called on empty CVCPtrList!");
		return m_pNodeHead->data; }
inline void* CVCPtrList::GetHead() const
	{ VSASSERT(m_pNodeHead != NULL, "GetHead called on empty CVCPtrList!");
		return m_pNodeHead->data; }
inline void*& CVCPtrList::GetTail()
	{ VSASSERT(m_pNodeTail != NULL, "GetTail called on empty CVCPtrList!");
		return m_pNodeTail->data; }
inline void* CVCPtrList::GetTail() const
	{ VSASSERT(m_pNodeTail != NULL, "GetTail called on empty CVCPtrList!");
		return m_pNodeTail->data; }
inline VCPOSITION CVCPtrList::GetHeadPosition() const
	{ return (VCPOSITION) m_pNodeHead; }
inline VCPOSITION CVCPtrList::GetTailPosition() const
	{ return (VCPOSITION) m_pNodeTail; }
inline void*& CVCPtrList::GetNext(VCPOSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline void* CVCPtrList::GetNext(VCPOSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline void*& CVCPtrList::GetPrev(VCPOSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline void* CVCPtrList::GetPrev(VCPOSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline void*& CVCPtrList::GetAt(VCPOSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
inline void* CVCPtrList::GetAt(VCPOSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
inline void CVCPtrList::SetAt(VCPOSITION pos, void* newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCMapWordToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapWordToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapWordToPtr::SetAt(WORD key, void* newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapWordToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_VCPOSITION; }
inline UINT CVCMapWordToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCMapDWordToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapDWordToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapDWordToPtr::SetAt(DWORD key, void* newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapDWordToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_VCPOSITION; }
inline DWORD CVCMapDWordToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCMapPtrToWord::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapPtrToWord::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapPtrToWord::SetAt(void* key, WORD newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapPtrToWord::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_VCPOSITION; }
inline UINT CVCMapPtrToWord::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCMapPtrToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapPtrToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapPtrToPtr::SetAt(void* key, void* newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapPtrToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_VCPOSITION; }
inline UINT CVCMapPtrToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVCList<TYPE, ARG_TYPE> inline and out of line functions

template<class TYPE, class ARG_TYPE>
inline INT_PTR CVCList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CVCList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CVCList<TYPE, ARG_TYPE>::GetHead()
	{ VSASSERT(m_pNodeHead != NULL, "GetHead called on empty CVCList<>!");
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CVCList<TYPE, ARG_TYPE>::GetHead() const
	{ VSASSERT(m_pNodeHead != NULL, "GetHead called on empty CVCList<>!");
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CVCList<TYPE, ARG_TYPE>::GetTail()
	{ VSASSERT(m_pNodeTail != NULL, "GetTail called on empty CVCList<>!");
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CVCList<TYPE, ARG_TYPE>::GetTail() const
	{ VSASSERT(m_pNodeTail != NULL, "GetTail called on empty CVCList<>!");
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline VCPOSITION CVCList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (VCPOSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline VCPOSITION CVCList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (VCPOSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CVCList<TYPE, ARG_TYPE>::GetNext(VCPOSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CVCList<TYPE, ARG_TYPE>::GetNext(VCPOSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CVCList<TYPE, ARG_TYPE>::GetPrev(VCPOSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CVCList<TYPE, ARG_TYPE>::GetPrev(VCPOSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CVCList<TYPE, ARG_TYPE>::GetAt(VCPOSITION position)
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CVCList<TYPE, ARG_TYPE>::GetAt(VCPOSITION position) const
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CVCList<TYPE, ARG_TYPE>::SetAt(VCPOSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CVCList<TYPE, ARG_TYPE>::CVCList(INT_PTR nBlockSize)
{
	VSASSERT(nBlockSize > 0, "Must initialize with positive block size");

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CVCList<TYPE, ARG_TYPE>::RemoveAll()
{
	VSASSERT(this, "Bad this pointer!");

	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		VCDestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CVCList<TYPE, ARG_TYPE>::~CVCList()
{
	RemoveAll();
	VSASSERT(m_nCount == 0, "Elements still in list after RemoveAll!!");
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CVCPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CVCPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CVCPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CVCList<TYPE, ARG_TYPE>::CNode*
CVCList<TYPE, ARG_TYPE>::NewNode(CVCList::CNode* pPrev, CVCList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CVCPlex* pNewBlock = CVCPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	VSASSERT(m_pNodeFree != NULL, "we must have something on the free list");

	CVCList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	VSASSERT(m_nCount > 0, "make sure we don't overflow");

	VCConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CVCList<TYPE, ARG_TYPE>::FreeNode(CVCList::CNode* pNode)
{
	VCDestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	VSASSERT(m_nCount >= 0, "make sure we don't underflow"); 

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
VCPOSITION CVCList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	VSASSERT(this, "Bad this pointer!");

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (VCPOSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
VCPOSITION CVCList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	VSASSERT(this, "Bad this pointer!");

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (VCPOSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CVCList<TYPE, ARG_TYPE>::AddHead(CVCList* pNewList)
{
	VSASSERT(this, "Bad this pointer!");
	VSASSERT(pNewList != NULL, "Cannot add NULL list!");

	// add a list of same elements to head (maintain order)
	VCPOSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CVCList<TYPE, ARG_TYPE>::AddTail(CVCList* pNewList)
{
	VSASSERT(this, "Bad this pointer!");
	VSASSERT(pNewList != NULL, "Cannot add NULL list!");

	// add a list of same elements
	VCPOSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CVCList<TYPE, ARG_TYPE>::RemoveHead()
{
	VSASSERT(this, "Bad this pointer!");
	VSASSERT(m_pNodeHead != NULL, "don't call RemoveHead on empty list !!!");
	VSASSERT(VCIsValidAddress(m_pNodeHead, sizeof(CNode)), "Invalid node head!");

	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CVCList<TYPE, ARG_TYPE>::RemoveTail()
{
	VSASSERT(this, "Bad this pointer!");
	VSASSERT(m_pNodeTail != NULL, "don't call RemoveTail on empty list !!!");
	VSASSERTE(VCIsValidAddress(m_pNodeTail, sizeof(CNode)), "Invalid node tail!");

	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
VCPOSITION CVCList<TYPE, ARG_TYPE>::InsertBefore(VCPOSITION position, ARG_TYPE newElement)
{
	VSASSERT(this, "Bad this pointer!");

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		VSASSERT(VCIsValidAddress(pOldNode->pPrev, sizeof(CNode)), "Bad node in list!");
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		VSASSERT(pOldNode == m_pNodeHead, "Better be working with node at the head of the list!");
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (VCPOSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
VCPOSITION CVCList<TYPE, ARG_TYPE>::InsertAfter(VCPOSITION position, ARG_TYPE newElement)
{
	VSASSERT(this, "Bad this pointer!");

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	VSASSERT(VCIsValidAddress(pOldNode, sizeof(CNode)), "Bad node in list!");
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		VSASSERT(VCIsValidAddress(pOldNode->pNext, sizeof(CNode)), "Bad node in list!");
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		VSASSERT(pOldNode == m_pNodeTail, "Better be working with node at the end of the list!");
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (VCPOSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CVCList<TYPE, ARG_TYPE>::RemoveAt(VCPOSITION position)
{
	VSASSERT(this, "Bad this pointer!");

	CNode* pOldNode = (CNode*) position;
	VSASSERT(VCIsValidAddress(pOldNode, sizeof(CNode)), "Bad node in list!");

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		VSASSERT(VCIsValidAddress(pOldNode->pPrev, sizeof(CNode)), "Bad node in list!");
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		VSASSERT(VCIsValidAddress(pOldNode->pNext, sizeof(CNode)), "Bad node in list!");
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
VCPOSITION CVCList<TYPE, ARG_TYPE>::FindIndex(INT_PTR nIndex) const
{
	VSASSERT(this, "Bad this pointer!");

	if (nIndex >= m_nCount || nIndex < 0)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		pNode = pNode->pNext;
	}
	return (VCPOSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
VCPOSITION CVCList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, VCPOSITION startAfter) const
{
	VSASSERT(this, "Bad this pointer!");

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (VCPOSITION)pNode;
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CVCTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CVCTypedPtrList : public BASE_CLASS
{
public:
// Construction
	CVCTypedPtrList(INT_PTR nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// add before head or after tail
	VCPOSITION AddHead(TYPE newElement)
		{ return BASE_CLASS::AddHead(newElement); }
	VCPOSITION AddTail(TYPE newElement)
		{ return BASE_CLASS::AddTail(newElement); }

	// add another list of elements before head or after tail
	void AddHead(CVCTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddHead(pNewList); }
	void AddTail(CVCTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddTail(pNewList); }

	// iteration
	TYPE& GetNext(VCPOSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(VCPOSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(VCPOSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(VCPOSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(VCPOSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(VCPOSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
	void SetAt(VCPOSITION pos, TYPE newElement)
		{ BASE_CLASS::SetAt(pos, newElement); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\vccoll.h ===
// (KPerry) This was the MFC collection stuff
// Now it has been purged of all other MFC influences and is a stand alone entity.

#pragma once
#include "plex.h"

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

	// Arrays
	class CVCByteArray;           // array of BYTE
	class CVCWordArray;           // array of WORD
	class CVCDWordArray;          // array of DWORD
	class CVCUIntArray;           // array of UINT
	class CVCPtrArray;            // array of void*
	// template CVCTypedPtrArray

	// Lists
	class CVCPtrList;             // list of void*

	// Maps (aka Dictionaries)
	class CVCMapWordToPtr;        // map from WORD to void*
	class CVCMapDWordToPtr;		  // map from DWORD to void*
	class CVCMapPtrToWord;        // map from void* to WORD
	class CVCMapPtrToPtr;         // map from void* to void*


typedef void *VCPOSITION;
#define BEFORE_START_VCPOSITION ((VCPOSITION)-1L)

// VCIsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const.
BOOL __stdcall VCIsValidAddress(const void* lp, SIZE_T nBytes, BOOL bReadWrite = TRUE);
// VCIsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const.
BOOL inline __stdcall VCIsValidAddress(const void* lp, SIZE_T nBytes,
	BOOL bReadWrite /* = TRUE */)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

#ifndef VCVERIFY
#ifdef _DEBUG
#define VCVERIFY(x) _ASSERTE(x)
#else
#define VCVERIFY(x) (void)(x)
#endif	// _DEBUG
#endif	// VCVERIFY

////////////////////////////////////////////////////////////////////////////

class CVCByteArray
{

public:

// Construction
	CVCByteArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	BYTE GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, BYTE newElement);

	BYTE& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const BYTE* GetData() const;
	BYTE* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, BYTE newElement);

	INT_PTR Add(BYTE newElement);

	INT_PTR Append(const CVCByteArray& src);
	void Copy(const CVCByteArray& src);

	// overloaded operator helpers
	BYTE operator[](INT_PTR nIndex) const;
	BYTE& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, BYTE newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CVCByteArray* pNewArray);

// Implementation
protected:
	BYTE* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CVCByteArray();

protected:
	// local typedefs for class templates
	typedef BYTE BASE_TYPE;
	typedef BYTE BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CVCWordArray
{

public:

// Construction
	CVCWordArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	WORD GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, WORD newElement);

	WORD& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const WORD* GetData() const;
	WORD* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, WORD newElement);

	INT_PTR Add(WORD newElement);

	INT_PTR Append(const CVCWordArray& src);
	void Copy(const CVCWordArray& src);

	// overloaded operator helpers
	WORD operator[](INT_PTR nIndex) const;
	WORD& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, WORD newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CVCWordArray* pNewArray);

// Implementation
protected:
	WORD* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CVCWordArray();


protected:
	// local typedefs for class templates
	typedef WORD BASE_TYPE;
	typedef WORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CVCDWordArray
{

public:

// Construction
	CVCDWordArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	DWORD GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, DWORD newElement);

	DWORD& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const DWORD* GetData() const;
	DWORD* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, DWORD newElement);

	INT_PTR Add(DWORD newElement);

	INT_PTR Append(const CVCDWordArray& src);
	void Copy(const CVCDWordArray& src);

	// overloaded operator helpers
	DWORD operator[](INT_PTR nIndex) const;
	DWORD& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, DWORD newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CVCDWordArray* pNewArray);

// Implementation
protected:
	DWORD* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CVCDWordArray();


protected:
	// local typedefs for class templates
	typedef DWORD BASE_TYPE;
	typedef DWORD BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CVCUIntArray
{

public:

// Construction
	CVCUIntArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	UINT GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, UINT newElement);

	UINT& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const UINT* GetData() const;
	UINT* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, UINT newElement);

	INT_PTR Add(UINT newElement);

	INT_PTR Append(const CVCUIntArray& src);
	void Copy(const CVCUIntArray& src);

	// overloaded operator helpers
	UINT operator[](INT_PTR nIndex) const;
	UINT& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, UINT newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CVCUIntArray* pNewArray);

// Implementation
protected:
	UINT* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CVCUIntArray();

protected:
	// local typedefs for class templates
	typedef UINT BASE_TYPE;
	typedef UINT BASE_ARG_TYPE;
};


////////////////////////////////////////////////////////////////////////////

class CVCPtrArray
{

public:

// Construction
	CVCPtrArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, void* newElement);

	void*& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const void** GetData() const;
	void** GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, void* newElement);

	INT_PTR Add(void* newElement);

	INT_PTR Append(const CVCPtrArray& src);
	void Copy(const CVCPtrArray& src);

	// overloaded operator helpers
	void* operator[](INT_PTR nIndex) const;
	void*& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, void* newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CVCPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount


public:
	~CVCPtrArray();

protected:
	// local typedefs for class templates
	typedef void* BASE_TYPE;
	typedef void* BASE_ARG_TYPE;
};



/////////////////////////////////////////////////////////////////////////////

class CVCPtrList
{


protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		void* data;
	};
public:

// Construction
	CVCPtrList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	void*& GetHead();
	void* GetHead() const;
	void*& GetTail();
	void* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	void* RemoveHead();
	void* RemoveTail();

	// add before head or after tail
	VCPOSITION AddHead(void* newElement);
	VCPOSITION AddTail(void* newElement);


	// add another list of elements before head or after tail
	void AddHead(CVCPtrList* pNewList);
	void AddTail(CVCPtrList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	VCPOSITION GetHeadPosition() const;
	VCPOSITION GetTailPosition() const;
	void*& GetNext(VCPOSITION& rPosition); // return *VCPOSITION++
	void* GetNext(VCPOSITION& rPosition) const; // return *VCPOSITION++
	void*& GetPrev(VCPOSITION& rPosition); // return *VCPOSITION--
	void* GetPrev(VCPOSITION& rPosition) const; // return *VCPOSITION--

	// getting/modifying an element at a given VCPOSITION
	void*& GetAt(VCPOSITION pos);
	void* GetAt(VCPOSITION pos) const;
	void SetAt(VCPOSITION pos, void* newElement);

	void RemoveAt(VCPOSITION pos);

	// inserting before or after a given VCPOSITION
	VCPOSITION InsertBefore(VCPOSITION pos, void* newElement);
	VCPOSITION InsertAfter(VCPOSITION pos, void* newElement);


	// helper functions (note: O(n) speed)
	VCPOSITION Find(void* searchValue, VCPOSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	VCPOSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CVCPtrList();
	// local typedefs for class templates
	typedef void* BASE_TYPE;
	typedef void* BASE_ARG_TYPE;
};




/////////////////////////////////////////////////////////////////////////////

class CVCMapWordToPtr
{

protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;

		WORD key;
		void* value;
	};

public:

// Construction
	CVCMapWordToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(WORD key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](WORD key);

	// add a new (key, value) pair
	void SetAt(WORD key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(WORD key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, WORD& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(WORD key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(WORD, UINT&, UINT&) const;

public:
	~CVCMapWordToPtr();

protected:
	// local typedefs for CTypedPtrMap class template
	typedef WORD BASE_KEY;
	typedef WORD BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};



/////////////////////////////////////////////////////////////////////////////

class CVCMapDWordToPtr
{

protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;

		DWORD key;
		void* value;
	};

public:

// Construction
	CVCMapDWordToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(DWORD key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](DWORD key);

	// add a new (key, value) pair
	void SetAt(DWORD key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(DWORD key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, DWORD& rKey, void*& rValue) const;

	// advanced features for derived classes
	DWORD GetHashTableSize() const;
	void InitHashTable(DWORD hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	DWORD HashKey(DWORD key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	DWORD m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(DWORD, DWORD&, DWORD&) const;

public:
	~CVCMapDWordToPtr();

protected:
	// local typedefs for CTypedPtrMap class template
	typedef DWORD BASE_KEY;
	typedef DWORD BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CVCMapPtrToWord 
{

protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;

		void* key;
		WORD value;
	};

public:

// Construction
	CVCMapPtrToWord(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(void* key, WORD& rValue) const;

// Operations
	// Lookup and add if not there
	WORD& operator[](void* key);

	// add a new (key, value) pair
	void SetAt(void* key, WORD newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(void* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, void*& rKey, WORD& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(void* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(void*, UINT&, UINT&) const;

public:
	~CVCMapPtrToWord();


protected:
	// local typedefs for CTypedPtrMap class template
	typedef void* BASE_KEY;
	typedef void* BASE_ARG_KEY;
	typedef WORD BASE_VALUE;
	typedef WORD BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CVCMapPtrToPtr 
{

protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;

		void* key;
		void* value;
	};

public:

// Construction
	CVCMapPtrToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(void* key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](void* key);

	// add a new (key, value) pair
	void SetAt(void* key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(void* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, void*& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(void* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(void*, UINT&, UINT&) const;

public:
	~CVCMapPtrToPtr();

	void* GetValueAt(void* key) const;


protected:
	// local typedefs for CTypedPtrMap class template
	typedef void* BASE_KEY;
	typedef void* BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};



/////////////////////////////////////////////////////////////////////////////
// CVCList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CVCList 
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CVCList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	VCPOSITION AddHead(ARG_TYPE newElement);
	VCPOSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CVCList* pNewList);
	void AddTail(CVCList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	VCPOSITION GetHeadPosition() const;
	VCPOSITION GetTailPosition() const;
	TYPE& GetNext(VCPOSITION& rPosition); // return *Position++
	TYPE GetNext(VCPOSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(VCPOSITION& rPosition); // return *Position--
	TYPE GetPrev(VCPOSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(VCPOSITION position);
	TYPE GetAt(VCPOSITION position) const;
	void SetAt(VCPOSITION pos, ARG_TYPE newElement);
	void RemoveAt(VCPOSITION position);

	// inserting before or after a given position
	VCPOSITION InsertBefore(VCPOSITION position, ARG_TYPE newElement);
	VCPOSITION InsertAfter(VCPOSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	VCPOSITION Find(ARG_TYPE searchValue, VCPOSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	VCPOSITION FindIndex(INT_PTR nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CVCList();
};


/////////////////////////////////////////////////////////////////////////////
// CVCTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CVCTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(INT_PTR nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(INT_PTR nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(INT_PTR nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, TYPE newElement)
	   { BASE_CLASS::SetAtGrow(nIndex, newElement); }
	INT_PTR Add(TYPE newElement)
	   { return BASE_CLASS::Add(newElement); }
	INT_PTR Append(const CVCTypedPtrArray<BASE_CLASS, TYPE>& src)
	   { return BASE_CLASS::Append(src); }
	void Copy(const CVCTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, TYPE newElement, INT_PTR nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(INT_PTR nStartIndex, CVCTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
	   { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](INT_PTR nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](INT_PTR nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#include <vccoll.inl>

#ifdef _VC_REDEF__ASSERTE
	#pragma pop_macro("_ASSERTE")
	#undef _VC_REDEF__ASSERTE
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCCollectionDE.h ===
#pragma once

#include "Resource.h"

// VCCollectionDE.h
//


//
// C++ collection implementation for a collection of any IDispatch *
//

enum vcDEPopulate
{
	vcDEPopulateInvalid = -1,
	vcDEPopulatePopulate = 0,
	vcDEPopulateQuery = 1
};


template <class T>
class _CopyVariantInterface
{
public :

	static HRESULT copy(VARIANT * pvDestination, T ** ppIUnknown)
	{
		pvDestination->vt = VT_DISPATCH;
		(*ppIUnknown)->QueryInterface(__uuidof(IDispatch), 
			reinterpret_cast<void **>(&pvDestination->pdispVal));
		return S_OK;
	}
	
	static void init(T ** ppIUnknown) 
	{ 
	}

	static void destroy(VARIANT * pvDestroy) 
	{ 
		VariantClear(pvDestroy); 
	}
};


template<typename TInterfaces, typename Element>
class ATL_NO_VTABLE CVCCollectionDE : public CVCRootDE<TInterfaces>
{
public :

	typedef CSimpleArray<CComPtr<Element> > _ArrayType;

private :

	_ArrayType m_vectorElements;

protected :

	CComPtr<VCDesignElementI> m_spParent;

	CVCCollectionDE(void)
	{
	}

	~CVCCollectionDE(void)
	{
		RemoveAll();
	}

public :

	DECLARE_NOT_AGGREGATABLE(CVCCollectionDE)
	DECLARE_VCDESIGNELEMENT(0)

	BEGIN_COM_MAP(CVCCollectionDE)
		COM_INTERFACE_ENTRY(VCDesignElements)
		COM_INTERFACE_ENTRY(VCDesignElementsI)
		COM_INTERFACE_ENTRY_CHAIN(CVCRootDE<TInterfaces>)
	END_COM_MAP()

	CComPtr<VCDesignElementI> & GetParent(void) 
	{ 
		return m_spParent; 
	}

	_ArrayType & GetElements(void) 
	{ 
		return m_vectorElements; 
	}

	// Ensures that the collection has been populated 
	//

	virtual HRESULT Populate(
		const vcDEPopulate vcdePopulate = vcDEPopulatePopulate)
	{
		// Default is to assume the collection has been populated
		//

		if (m_vectorElements.GetSize())
		{
			return S_OK;
		}
		else
		{
			// Populated, but empty
			//

			return S_FALSE;
		}
	}

	STDMETHOD(get_Parent)(IDispatch ** ppParent)
	{
		VALIDATE_WRITE_POINTER_HR(ppParent);

		HRESULT hr(S_OK);
		FAILED_RETURN_HR(m_spParent.QueryInterface(ppParent));
		return hr;
	}

	STDMETHOD(get_Descendants)(IDispatch ** ppDescendants)
	{
		VALIDATE_WRITE_POINTER_HR(ppDescendants);

		HRESULT hr(S_OK);
		FAILED_RETURN_HR(QueryInterface(__uuidof(IDispatch), 
			reinterpret_cast<void **>(ppDescendants)));
		return hr;
	}

	STDMETHOD(put_Parent)(IDispatch * pParent)
	{
		VALIDATE_READ_POINTER_HR(pParent);
		CHECK_STATE_RETURN(!m_spParent);

		return pParent->QueryInterface(__uuidof(VCDesignElementI), 
			reinterpret_cast<void **>(&m_spParent));
	}

	// REVIEW : Perhaps we do not need to make a copy of elements for _NewEnum
	//

	STDMETHOD(_NewEnum)(IUnknown ** ppEnum)
	{
		VALIDATE_WRITE_POINTER_HR(ppEnum);

		HRESULT hr(S_OK);
		FAILED_RETURN_HR(Populate());

		// Create the Enumerator object.
		//

		typedef CComEnum<IEnumVARIANT, &__uuidof(IEnumVARIANT), 
			VARIANT, _Copy<VARIANT> > CEnumType;
		CComObject<CEnumType> (*pEnumType)(NULL);
		FAILED_RETURN_HR(CComObject<CEnumType>::CreateInstance(&pEnumType));

		UINT cElements(m_vectorElements.GetSize());
		VARIANT (*rgvElements)(NULL);

		// Allocate one extra to handle the zero elements case
		//

		FAILED_RETURN(E_OUTOFMEMORY, rgvElements = new VARIANT[cElements + 1]);

		for (UINT iElement = 0; iElement < cElements; iElement++)
		{
			VariantInit(&rgvElements[iElement]);
			rgvElements[iElement].vt = VT_DISPATCH;
			rgvElements[iElement].pdispVal = NULL;
			m_vectorElements[iElement].QueryInterface(&rgvElements[iElement].pdispVal);
		}

		if (FAILED(hr = pEnumType->Init(&rgvElements[0], &rgvElements[cElements], 
			GetUnknown(), AtlFlagTakeOwnership)))
		{
			delete pEnumType;
			return hr;
		}

		FAILED_RETURN_HR(pEnumType->QueryInterface(__uuidof(IUnknown), 
			reinterpret_cast<void **>(ppEnum)));

		return hr;
	}

	STDMETHOD(Item)(VARIANT vItem, IDispatch ** ppItem)
	{
		VALIDATE_WRITE_POINTER_HR(ppItem);

		HRESULT hr(S_OK);

		switch (vItem.vt)
		{
		case VT_EMPTY :
			return E_INVALIDARG;
		case VT_BSTR :
			if (S_OK != (hr = Find(vItem.bstrVal, ppItem)))
			{
				return E_INVALIDARG;
			}
			else
			{
				return hr;
			}
		case VT_BSTR | VT_BYREF :
			if (S_OK != (hr = Find(*vItem.pbstrVal, ppItem)))
			{
				return E_INVALIDARG;
			}
			else
			{
				return hr;
			}
		case VT_VARIANT | VT_BYREF :
			return Item(*vItem.pvarVal, ppItem);
		}

		CComVariant vLongIndex;
		FAILED_RETURN_HR(VariantChangeType(&vLongIndex, &vItem, 0, VT_I4));
		FAILED_RETURN_HR(Populate());

		// Adjust for 1 based collection
		//

		vLongIndex.lVal--;

		if (vLongIndex.lVal < 0 || vLongIndex.lVal >= m_vectorElements.GetSize())
		{
			return E_INVALIDARG;
		}

		return m_vectorElements[vLongIndex.lVal].QueryInterface(ppItem);
	}

	STDMETHODIMP Item(VARIANT index, Element ** lppcReturn)
	{
		HRESULT hr(S_OK);
		CComPtr<IDispatch> spItem;
		FAILED_RETURN_HR(Item(index, &spItem));
		return spItem.QueryInterface(lppcReturn);
	}

	STDMETHOD(get_Count)(long * plCount)
	{
		VALIDATE_WRITE_POINTER_HR(plCount);

		HRESULT hr(S_OK);
		FAILED_RETURN_HR(Populate());

		*plCount = m_vectorElements.GetSize();

		return hr;
	}

	STDMETHOD(Find)(BSTR bstrName, IDispatch **	ppFound)
	{
		VALIDATE_AND_CLEAR(ppFound);

		HRESULT hr(S_OK);
		FAILED_RETURN_HR(Populate());

		UINT cElements(m_vectorElements.GetSize());

		for (UINT iElement = 0; iElement < cElements; iElement++)
		{
			CComBSTR bstrElementName;
			CComPtr<VCDesignElement> spElement;

            FAILED_ASSERT_RETURN_HR(m_vectorElements[iElement].QueryInterface(&spElement));
            bool bMatch(false);

    		VARIANT_BOOL bIsCaseSensitive(VARIANT_FALSE);
			FAILED_RETURN_HR(spElement->get_Name(&bstrElementName));
			FAILED_RETURN_HR(spElement->get_IsCaseSensitive(&bIsCaseSensitive));

			if (!bstrElementName.Length())
			{  
				bMatch = (!bstrName || !bstrName[0]);
			}
			else
			{
				if (VARIANT_TRUE == bIsCaseSensitive)
				{
					bMatch = !wcscmp(bstrElementName, bstrName);
				}
				else
				{
					bMatch = !_wcsicmp(bstrElementName, bstrName);
				}
			}

			if (bMatch)
			{
				FAILED_ASSERT_RETURN_HR(spElement.QueryInterface(ppFound));

				return S_OK;
			}
		}

		// Name was not found in the collection
		//

		return S_FALSE;
	}

	STDMETHOD(IsEmpty)(BOOL * pbIsEmpty)
	{
		VALIDATE_WRITE_POINTER_HR(pbIsEmpty);

		HRESULT hr(S_OK);

		hr = Populate(vcDEPopulateQuery); 

		*pbIsEmpty = S_FALSE == hr;

		return hr;
	}

	STDMETHOD(AddItem)(IDispatch * pAdd)
	{
		VALIDATE_READ_POINTER_HR(pAdd);

		HRESULT hr(S_OK);
		CComPtr<Element> spAdd;
		FAILED_RETURN_HR(pAdd->QueryInterface(__uuidof(Element),
			reinterpret_cast<void **>(&spAdd)));

		m_vectorElements.Add(spAdd);

		return hr;
	}

	STDMETHOD(RemoveIndex)(LONG iRemove)
	{
		VALIDATE_RANGE_HR(iRemove, 1, m_vectorElements.GetSize());

		m_vectorElements.RemoveAt(iRemove - 1);
		return S_OK;
	}

	STDMETHOD(RemoveItem)(IDispatch * pRemove)
	{
		VALIDATE_READ_POINTER_HR(pRemove);

		HRESULT hr(S_OK);
		CComPtr<Element> spRemove;
		FAILED_RETURN_HR(pRemove->QueryInterface(__uuidof(Element), 
			reinterpret_cast<void **>(&spRemove)));

		m_vectorElements.Remove(spRemove);
		return hr;
	}

	STDMETHOD(RemoveAll)(void)
	{
		m_vectorElements.RemoveAll();
		return S_OK;
	}
};


// Passthroughs
//

class ATL_NO_VTABLE IVCCollectionDEPT : 
	public VCDesignElement,
	public CVCIDispatchImplDE<VCDesignElements>,
	public VCDesignElementsI
{ 
};

// CVCDesignElements
//

typedef CVCCollectionDE<IVCCollectionDEPT, VCDesignElement> CVCDesignElements;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCDesignerObjectInternal.h ===
#pragma once

// VCDesignerObjectInternal.h
//

// Things the users must never, never see...
//
// Therefore, it is OKAY to use inheritance (yes, even virtual inheritance!)
//

[
	uuid(29BF7883-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCDesignElementI : public IUnknown
{
public :

	virtual HRESULT STDMETHODCALLTYPE put_Parent(IDispatch * pIDispatch) = 0;
	virtual HRESULT STDMETHODCALLTYPE put_Name(BSTR bstrName) = 0;
	virtual HRESULT STDMETHODCALLTYPE get_Name(BSTR * pbstrName) = 0;
	virtual HRESULT STDMETHODCALLTYPE get_Descendants(IDispatch ** ppIDispatch) = 0;
};


// VCDesignElementsI
//
// DE that is a collection of any IDispatch Based objects
//

[
	uuid(29BF7886-FE8C-11d2-AAE9-00C04F72DB55),
]
class ATL_NO_VTABLE VCDesignElementsI : public VCDesignElementI
{
public :

	virtual HRESULT STDMETHODCALLTYPE IsEmpty(BOOL * pbIsEmpty) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddItem(IDispatch * pIDispatch) = 0;
	virtual HRESULT STDMETHODCALLTYPE RemoveIndex(long lIndex) = 0;
	virtual HRESULT STDMETHODCALLTYPE RemoveItem(IDispatch * pIDispatch) = 0;
	virtual HRESULT STDMETHODCALLTYPE RemoveAll(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE Find(BSTR bstrName, IDispatch ** ppDispatch) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\vccolls.h ===
// (KPerry) This was the MFC collection stuff
// Now it has been purged of all other MFC influences and is a stand alone entity.

#ifndef __VCCOLLS_H__
#define __VCCOLLS_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include "vcstring.h"
#include "vccoll.h"


/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

	// Special String variants
	class CVCStringArray;         // array ofCVCStrings
	class CVCStringList;          // list of CVCStrings
	class CVCMapStringToPtr;      // map from CVCString to void*
	class CVCMapStringToString;   // map from CVCString to CVCString

	class CVCStringWArray;         // array ofCStringWs
	class CVCStringWList;          // list of CStringWs
	class CVCMapStringWToPtr;     // map from CStringW to void*
	class CVCMapStringWToStringW;	// map from CStringW to CStringW

/////////////////////////////////////////////////////////////////////////////
// Other implementation helpers

#define VCBEFORE_START_POSITION ((VCPOSITION)-1L)

////////////////////////////////////////////////////////////////////////////

class CVCStringArray
{

public:

// Construction
	CVCStringArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CVCString GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, LPCTSTR newElement);

	void SetAt(INT_PTR nIndex, const CVCString& newElement);

	CVCString& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const CVCString* GetData() const;
	CVCString* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, LPCTSTR newElement);

	void SetAtGrow(INT_PTR nIndex, const CVCString& newElement);

	INT_PTR Add(LPCTSTR newElement);

	INT_PTR Add(const CVCString& newElement);

	INT_PTR Append(const CVCStringArray& src);
	void Copy(const CVCStringArray& src);

	// overloaded operator helpers
	CVCString operator[](INT_PTR nIndex) const;
	CVCString& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, LPCTSTR newElement, INT_PTR nCount = 1);

	void InsertAt(INT_PTR nIndex, const CVCString& newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CVCStringArray* pNewArray);

// Implementation
protected:
	CVCString* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount

	void InsertEmpty(INT_PTR nIndex, INT_PTR nCount);


public:
	~CVCStringArray();


protected:
	// local typedefs for class templates
	typedef CVCString BASE_TYPE;
	typedef LPCTSTR BASE_ARG_TYPE;
};


/////////////////////////////////////////////////////////////////////////////

class CVCStringList
{


protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CVCString data;
	};
public:

// Construction
	CVCStringList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CVCString& GetHead();
	CVCString GetHead() const;
	CVCString& GetTail();
	CVCString GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CVCString RemoveHead();
	CVCString RemoveTail();

	// add before head or after tail
	VCPOSITION AddHead(LPCTSTR newElement);
	VCPOSITION AddTail(LPCTSTR newElement);

	VCPOSITION AddHead(const CVCString& newElement);
	VCPOSITION AddTail(const CVCString& newElement);


	// add another list of elements before head or after tail
	void AddHead(CVCStringList* pNewList);
	void AddTail(CVCStringList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	VCPOSITION GetHeadPosition() const;
	VCPOSITION GetTailPosition() const;
	CVCString& GetNext(VCPOSITION& rPosition); // return *VCPOSITION++
	CVCString GetNext(VCPOSITION& rPosition) const; // return *VCPOSITION++
	CVCString& GetPrev(VCPOSITION& rPosition); // return *VCPOSITION--
	CVCString GetPrev(VCPOSITION& rPosition) const; // return *VCPOSITION--

	// getting/modifying an element at a given VCPOSITION
	CVCString& GetAt(VCPOSITION VCPOSITION);
	CVCString GetAt(VCPOSITION VCPOSITION) const;
	void SetAt(VCPOSITION pos, LPCTSTR newElement);

	void SetAt(VCPOSITION pos, const CVCString& newElement);

	void RemoveAt(VCPOSITION VCPOSITION);

	// inserting before or after a given VCPOSITION
	VCPOSITION InsertBefore(VCPOSITION VCPOSITION, LPCTSTR newElement);
	VCPOSITION InsertAfter(VCPOSITION VCPOSITION, LPCTSTR newElement);

	VCPOSITION InsertBefore(VCPOSITION VCPOSITION, const CVCString& newElement);
	VCPOSITION InsertAfter(VCPOSITION VCPOSITION, const CVCString& newElement);


	// helper functions (note: O(n) speed)
	VCPOSITION Find(LPCTSTR searchValue, VCPOSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	VCPOSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CVCStringList();

	// local typedefs for class templates
	typedef CVCString BASE_TYPE;
	typedef LPCTSTR BASE_ARG_TYPE;
};



/////////////////////////////////////////////////////////////////////////////

class CVCMapStringToPtr
{

protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CVCString key;
		void* value;
	};

public:

// Construction
	CVCMapStringToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCTSTR key, void*& rValue) const;
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	void*& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, CVCString& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCTSTR, UINT&, UINT&) const;

public:
	~CVCMapStringToPtr();

protected:
	// local typedefs for CTypedPtrMap class template
	typedef CVCString BASE_KEY;
	typedef LPCTSTR BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};



/////////////////////////////////////////////////////////////////////////////

class CVCMapStringToString
{

protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CVCString key;
		CVCString value;
	};

public:

// Construction
	CVCMapStringToString(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCTSTR key, CVCString& rValue) const;
	BOOL LookupKey(LPCTSTR key, LPCTSTR& rKey) const;

// Operations
	// Lookup and add if not there
	CVCString& operator[](LPCTSTR key);

	// add a new (key, value) pair
	void SetAt(LPCTSTR key, LPCTSTR newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCTSTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, CVCString& rKey, CVCString& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCTSTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCTSTR, UINT&, UINT&) const;

public:
	~CVCMapStringToString();


protected:
	// local typedefs for CTypedPtrMap class template
	typedef CVCString BASE_KEY;
	typedef LPCTSTR BASE_ARG_KEY;
	typedef CVCString BASE_VALUE;
	typedef LPCTSTR BASE_ARG_VALUE;
};

/////////////////////////////////////////////////////////////////////////////

class CVCMapStringWToStringW
{

protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CStringW key;
		CStringW value;
	};

public:

// Construction
	CVCMapStringWToStringW(INT_PTR nBlockSize = 10, UINT nHashSize = 17);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCOLESTR key, CStringW& rValue) const;
	BOOL LookupKey(LPCOLESTR key, LPCOLESTR& rKey) const;

// Operations
	// Lookup and add if not there
	CStringW& operator[](LPCOLESTR key);

	// add a new (key, value) pair
	void SetAt(LPCOLESTR key, LPCOLESTR newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCOLESTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, CStringW& rKey, CStringW& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCOLESTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCOLESTR, UINT&, UINT&) const;

public:
	~CVCMapStringWToStringW();


protected:
	// local typedefs for CTypedPtrMap class template
	typedef CStringW BASE_KEY;
	typedef LPCOLESTR BASE_ARG_KEY;
	typedef CStringW BASE_VALUE;
	typedef LPCOLESTR BASE_ARG_VALUE;
};

/////////////////////////////////////////////////////////////////////////////

class CVCStringWArray
{

public:

// Construction
	CVCStringWArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CStringW GetAt(INT_PTR nIndex) const;
	void SetAt(INT_PTR nIndex, LPCOLESTR newElement);

	void SetAt(INT_PTR nIndex, const CStringW& newElement);

	CStringW& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const CStringW* GetData() const;
	CStringW* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, LPCOLESTR newElement);

	void SetAtGrow(INT_PTR nIndex, const CStringW& newElement);

	INT_PTR Add(LPCOLESTR newElement);

	INT_PTR Add(const CStringW& newElement);

	INT_PTR Append(const CVCStringWArray& src);
	void Copy(const CVCStringWArray& src);

	// overloaded operator helpers
	CStringW operator[](INT_PTR nIndex) const;
	CStringW& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, LPCOLESTR newElement, INT_PTR nCount = 1);

	void InsertAt(INT_PTR nIndex, const CStringW& newElement, INT_PTR nCount = 1);

	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CVCStringWArray* pNewArray);

// Implementation
protected:
	CStringW* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount

	void InsertEmpty(INT_PTR nIndex, INT_PTR nCount);


public:
	~CVCStringWArray();


protected:
	// local typedefs for class templates
	typedef CStringW BASE_TYPE;
	typedef LPCOLESTR BASE_ARG_TYPE;
};

/////////////////////////////////////////////////////////////////////////////

class CVCMapStringWToPtr
{

protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CStringW key;
		void* value;
	};

public:

// Construction
	CVCMapStringWToPtr(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(LPCOLESTR key, void*& rValue) const;
	BOOL LookupKey(LPCOLESTR key, LPCOLESTR& rKey) const;

// Operations
	// Lookup and add if not there
	void*& operator[](LPCOLESTR key);

	// add a new (key, value) pair
	void SetAt(LPCOLESTR key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(LPCOLESTR key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, CStringW& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(LPCOLESTR key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(LPCOLESTR, UINT&, UINT&) const;

public:
	~CVCMapStringWToPtr();

protected:
	// local typedefs for CTypedPtrMap class template
	typedef CStringW BASE_KEY;
	typedef LPCOLESTR BASE_ARG_KEY;
	typedef void* BASE_VALUE;
	typedef void* BASE_ARG_VALUE;
};


/////////////////////////////////////////////////////////////////////////////

class CVCStringWList
{


protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CStringW data;
	};
public:

// Construction
	CVCStringWList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CStringW& GetHead();
	CStringW GetHead() const;
	CStringW& GetTail();
	CStringW GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CStringW RemoveHead();
	CStringW RemoveTail();

	// add before head or after tail
	VCPOSITION AddHead(LPCOLESTR newElement);
	VCPOSITION AddTail(LPCOLESTR newElement);

	VCPOSITION AddHead(const CStringW& newElement);
	VCPOSITION AddTail(const CStringW& newElement);


	// add another list of elements before head or after tail
	void AddHead(CVCStringWList* pNewList);
	void AddTail(CVCStringWList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	VCPOSITION GetHeadPosition() const;
	VCPOSITION GetTailPosition() const;
	CStringW& GetNext(VCPOSITION& rPosition); // return *VCPOSITION++
	CStringW GetNext(VCPOSITION& rPosition) const; // return *VCPOSITION++
	CStringW& GetPrev(VCPOSITION& rPosition); // return *VCPOSITION--
	CStringW GetPrev(VCPOSITION& rPosition) const; // return *VCPOSITION--

	// getting/modifying an element at a given VCPOSITION
	CStringW& GetAt(VCPOSITION VCPOSITION);
	CStringW GetAt(VCPOSITION VCPOSITION) const;
	void SetAt(VCPOSITION pos, LPCOLESTR newElement);

	void SetAt(VCPOSITION pos, const CStringW& newElement);

	void RemoveAt(VCPOSITION VCPOSITION);

	// inserting before or after a given VCPOSITION
	VCPOSITION InsertBefore(VCPOSITION VCPOSITION, LPCOLESTR newElement);
	VCPOSITION InsertAfter(VCPOSITION VCPOSITION, LPCOLESTR newElement);

	VCPOSITION InsertBefore(VCPOSITION VCPOSITION, const CStringW& newElement);
	VCPOSITION InsertAfter(VCPOSITION VCPOSITION, const CStringW& newElement);


	// helper functions (note: O(n) speed)
	VCPOSITION Find(LPCOLESTR searchValue, VCPOSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	VCPOSITION FindIndex(INT_PTR nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CVCPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CVCStringWList();

	// local typedefs for class templates
	typedef CStringW BASE_TYPE;
	typedef LPCOLESTR BASE_ARG_TYPE;
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#include <vccolls.inl>

#endif //!__VCCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\vccolls.inl ===
// (KPerry) This was the MFC collection stuff
// Now it has been purged of all other MFC influences and is a stand alone entity.

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for VCCOLLS.H

#if _MSC_VER > 1000
#pragma once
#endif


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCStringArray::GetSize() const
	{ return m_nSize; }
inline INT_PTR CVCStringArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CVCStringArray::RemoveAll()
	{ SetSize(0); }
inline CVCString CVCStringArray::GetAt(INT_PTR nIndex) const
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline void CVCStringArray::SetAt(INT_PTR nIndex, LPCTSTR newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline void CVCStringArray::SetAt(INT_PTR nIndex, const CVCString& newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline CVCString& CVCStringArray::ElementAt(INT_PTR nIndex)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline const CVCString* CVCStringArray::GetData() const
	{ return (const CVCString*)m_pData; }
inline CVCString* CVCStringArray::GetData()
	{ return (CVCString*)m_pData; }
inline INT_PTR CVCStringArray::Add(LPCTSTR newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline INT_PTR CVCStringArray::Add(const CVCString& newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline CVCString CVCStringArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
inline CVCString& CVCStringArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCStringList::GetCount() const
	{ return m_nCount; }
inline BOOL CVCStringList::IsEmpty() const
	{ return m_nCount == 0; }
inline CVCString& CVCStringList::GetHead()
	{ VSASSERT(m_pNodeHead != NULL, "GetHead called on empty CVCStringList!");
		return m_pNodeHead->data; }
inline CVCString CVCStringList::GetHead() const
	{ VSASSERT(m_pNodeHead != NULL, "GetHead called on empty CVCStringList!");
		return m_pNodeHead->data; }
inline CVCString& CVCStringList::GetTail()
	{ VSASSERT(m_pNodeTail != NULL, "GetTail called on empty CVCStringList!");
		return m_pNodeTail->data; }
inline CVCString CVCStringList::GetTail() const
	{ VSASSERT(m_pNodeTail != NULL, "GetTail called on empty CVCStringList!");
		return m_pNodeTail->data; }
inline VCPOSITION CVCStringList::GetHeadPosition() const
	{ return (VCPOSITION) m_pNodeHead; }
inline VCPOSITION CVCStringList::GetTailPosition() const
	{ return (VCPOSITION) m_pNodeTail; }
inline CVCString& CVCStringList::GetNext(VCPOSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline CVCString CVCStringList::GetNext(VCPOSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline CVCString& CVCStringList::GetPrev(VCPOSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline CVCString CVCStringList::GetPrev(VCPOSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline CVCString& CVCStringList::GetAt(VCPOSITION position)
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		return pNode->data; }
inline CVCString CVCStringList::GetAt(VCPOSITION position) const
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		return pNode->data; }
inline void CVCStringList::SetAt(VCPOSITION pos, LPCTSTR newElement)
	{ CNode* pNode = (CNode*) pos;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		pNode->data = newElement; }

inline void CVCStringList::SetAt(VCPOSITION pos, const CVCString& newElement)
	{ CNode* pNode = (CNode*) pos;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		pNode->data = newElement; }


////////////////////////////////////////////////////////////////////////////
inline INT_PTR CVCMapStringToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapStringToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapStringToPtr::SetAt(LPCTSTR key, void* newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapStringToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : VCBEFORE_START_POSITION; }
inline UINT CVCMapStringToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
inline INT_PTR CVCMapStringToString::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapStringToString::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapStringToString::SetAt(LPCTSTR key, LPCTSTR newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapStringToString::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : VCBEFORE_START_POSITION; }
inline UINT CVCMapStringToString::GetHashTableSize() const
	{ return m_nHashTableSize; }

////////////////////////////////////////////////////////////////////////////
inline INT_PTR CVCMapStringWToStringW::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapStringWToStringW::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapStringWToStringW::SetAt(LPCOLESTR key, LPCOLESTR newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapStringWToStringW::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : VCBEFORE_START_POSITION; }
inline UINT CVCMapStringWToStringW::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCStringWArray::GetSize() const
	{ return m_nSize; }
inline INT_PTR CVCStringWArray::GetUpperBound() const
	{ return m_nSize-1; }
inline void CVCStringWArray::RemoveAll()
	{ SetSize(0); }
inline CStringW CVCStringWArray::GetAt(INT_PTR nIndex) const
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline void CVCStringWArray::SetAt(INT_PTR nIndex, LPCOLESTR newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline void CVCStringWArray::SetAt(INT_PTR nIndex, const CStringW& newElement)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		m_pData[nIndex] = newElement; }

inline CStringW& CVCStringWArray::ElementAt(INT_PTR nIndex)
	{ VSASSERT(nIndex >= 0 && nIndex < m_nSize, "Index out of range!");
		return m_pData[nIndex]; }
inline const CStringW* CVCStringWArray::GetData() const
	{ return (const CStringW*)m_pData; }
inline CStringW* CVCStringWArray::GetData()
	{ return (CStringW*)m_pData; }
inline INT_PTR CVCStringWArray::Add(LPCOLESTR newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline INT_PTR CVCStringWArray::Add(const CStringW& newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }

inline CStringW CVCStringWArray::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
inline CStringW& CVCStringWArray::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
inline INT_PTR CVCMapStringWToPtr::GetCount() const
	{ return m_nCount; }
inline BOOL CVCMapStringWToPtr::IsEmpty() const
	{ return m_nCount == 0; }
inline void CVCMapStringWToPtr::SetAt(LPCOLESTR key, void* newValue)
	{ (*this)[key] = newValue; }
inline VCPOSITION CVCMapStringWToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : VCBEFORE_START_POSITION; }
inline UINT CVCMapStringWToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }

////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

inline INT_PTR CVCStringWList::GetCount() const
	{ return m_nCount; }
inline BOOL CVCStringWList::IsEmpty() const
	{ return m_nCount == 0; }
inline CStringW& CVCStringWList::GetHead()
	{ VSASSERT(m_pNodeHead != NULL, "GetHead called on empty CVCStringWList!");
		return m_pNodeHead->data; }
inline CStringW CVCStringWList::GetHead() const
	{ VSASSERT(m_pNodeHead != NULL, "GetHead called on empty CVCStringWList!");
		return m_pNodeHead->data; }
inline CStringW& CVCStringWList::GetTail()
	{ VSASSERT(m_pNodeTail != NULL, "GetTail called on empty CVCStringWList!");
		return m_pNodeTail->data; }
inline CStringW CVCStringWList::GetTail() const
	{ VSASSERT(m_pNodeTail != NULL, "GetTail called on empty CVCStringWList!");
		return m_pNodeTail->data; }
inline VCPOSITION CVCStringWList::GetHeadPosition() const
	{ return (VCPOSITION) m_pNodeHead; }
inline VCPOSITION CVCStringWList::GetTailPosition() const
	{ return (VCPOSITION) m_pNodeTail; }
inline CStringW& CVCStringWList::GetNext(VCPOSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline CStringW CVCStringWList::GetNext(VCPOSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pNext;
		return pNode->data; }
inline CStringW& CVCStringWList::GetPrev(VCPOSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline CStringW CVCStringWList::GetPrev(VCPOSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		rPosition = (VCPOSITION) pNode->pPrev;
		return pNode->data; }
inline CStringW& CVCStringWList::GetAt(VCPOSITION position)
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		return pNode->data; }
inline CStringW CVCStringWList::GetAt(VCPOSITION position) const
	{ CNode* pNode = (CNode*) position;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		return pNode->data; }
inline void CVCStringWList::SetAt(VCPOSITION pos, LPCOLESTR newElement)
	{ CNode* pNode = (CNode*) pos;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		pNode->data = newElement; }

inline void CVCStringWList::SetAt(VCPOSITION pos, const CStringW& newElement)
	{ CNode* pNode = (CNode*) pos;
		VSASSERT(VCIsValidAddress(pNode, sizeof(CNode)), "Bad node found in list!");
		pNode->data = newElement; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCNcbUtilities.h ===
#pragma once

template<typename T>
class CNCBArray
{
private :

	BscEx * m_pBscEx;
	T * m_rgT;

public :

	CNCBArray(BscEx * pBscEx) : m_pBscEx(pBscEx), m_rgT(NULL) { }
	~CNCBArray(void) { m_pBscEx->disposeArray(m_rgT); }

	operator T * (void) { return m_rgT; }
	T ** operator & (void) { VCASSERT(!m_rgT); return &m_rgT; }
	T & operator [] (INT iIndex) { VCASSERT(m_rgT); return m_rgT[iIndex]; }
	T & operator [] (UINT iIndex) { VCASSERT(m_rgT); return m_rgT[iIndex]; }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCFileClasses.h ===
// (DianeMe) This was the MFC file manipulation stuff
// Now it has been purged of all other MFC influences and is a stand alone entity.
// NOTE: exceptions are no longer thrown on various errors...

#pragma once

#include <time.h>
#include <vcstring.h>
#include <vctimeclasses.h>

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CVCVCFile;
class CVCStdioFile;
class CVCMemFile;
class CVCSharedFile;

struct CVCFileStatus;                   // file status information

/////////////////////////////////////////////////////////////////////////////
// File - raw unbuffered disk file I/O

class CVCFile
{
public:
// Flag values
	enum OpenFlags {
		modeRead =          0x0000,
		modeWrite =         0x0001,
		modeReadWrite =     0x0002,
		shareCompat =       0x0000,
		shareExclusive =    0x0010,
		shareDenyWrite =    0x0020,
		shareDenyRead =     0x0030,
		shareDenyNone =     0x0040,
		modeNoInherit =     0x0080,
		modeCreate =        0x1000,
		modeNoTruncate =    0x2000,
		typeText =          0x4000, // typeText and typeBinary are used in
		typeBinary =   (int)0x8000 // derived classes only
		};

	enum Attribute {
		normal =    0x00,
		readOnly =  0x01,
		hidden =    0x02,
		system =    0x04,
		volume =    0x08,
		directory = 0x10,
		archive =   0x20
		};

	enum SeekPosition { begin = 0x0, current = 0x1, end = 0x2 };

	static const HANDLE hFileNull; // INVALID_HANDLE_VALUE

// Constructors
	CVCFile();

// Attributes
	HANDLE m_hFile;
	operator HANDLE() const { return m_hFile; } 

	virtual ULONGLONG GetPosition() const;
	BOOL GetStatus(CVCFileStatus& rStatus) const;
	virtual CVCString GetFileName() const;
	virtual CVCString GetFileTitle() const;
	virtual CVCString GetFilePath() const;
	virtual void SetFilePath(LPCTSTR lpszNewName) { m_strFileName = lpszNewName; }

// Operations
	virtual BOOL Open(LPCSTR lpszFileName, UINT nOpenFlags, DWORD dwAttribs = FILE_ATTRIBUTE_NORMAL);

	static void PASCAL Rename(LPCTSTR lpszOldName, LPCTSTR lpszNewName);
	static void PASCAL Remove(LPCTSTR lpszFileName);
	static BOOL PASCAL GetStatus(LPCTSTR lpszFileName, CVCFileStatus& rStatus);
	static void PASCAL SetStatus(LPCTSTR lpszFileName, const CVCFileStatus& status);

	ULONGLONG SeekToEnd() { return Seek(0, CVCFile::end); }
	void SeekToBegin() { Seek(0, CVCFile::begin); }

// Overridables
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual ULONGLONG GetLength() const;

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual BOOL Write(const void* lpBuf, UINT nCount);

	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Implementation
public:
	virtual ~CVCFile();
	enum BufferCommand { bufferRead, bufferWrite, bufferCommit, bufferCheck };
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

protected:
	BOOL m_bCloseOnDelete;
	CVCString m_strFileName;
};

/////////////////////////////////////////////////////////////////////////////
// STDIO file implementation

class CVCStdioFile : public CVCFile
{
public:
// Constructors
	CVCStdioFile();
	CVCStdioFile(FILE* pOpenStream);
	CVCStdioFile(LPCSTR lpszFileName, UINT nOpenFlags);

// Attributes
	FILE* m_pStream;    // stdio FILE
						// m_hFile from base class is _fileno(m_pStream)

// Operations
	// reading and writing strings
	virtual BOOL WriteString(LPCSTR lpsz);
	virtual LPTSTR ReadString(LPTSTR lpsz, UINT nMax);
	virtual BOOL ReadString(CVCString& rString);

// Implementation
public:
	virtual ~CVCStdioFile();
	virtual ULONGLONG GetPosition() const;
   virtual ULONGLONG GetLength() const;
	virtual BOOL Open(LPCSTR lpszFileName, UINT nOpenFlags, DWORD dwAttribs = FILE_ATTRIBUTE_NORMAL);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual BOOL Write(const void* lpBuf, UINT nCount);
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

	// Unsupported APIs
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Memory based file implementation

class CVCMemFile : public CVCFile
{
public:
// Constructors
	CVCMemFile(SIZE_T nGrowBytes = 1024);
	CVCMemFile(BYTE* lpBuffer, SIZE_T nBufferSize, SIZE_T nGrowBytes = 0);

// Operations
	void Attach(BYTE* lpBuffer, SIZE_T nBufferSize, SIZE_T nGrowBytes = 0);
	BYTE* Detach();

// Advanced Overridables
protected:
	virtual BYTE* Alloc(SIZE_T nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, SIZE_T nBytes);
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, SIZE_T nBytes);
	virtual void Free(BYTE* lpMem);
	virtual void GrowFile(SIZE_T dwNewLen);

// Implementation
protected:
	SIZE_T m_nGrowBytes;
	SIZE_T m_nPosition;
	SIZE_T m_nBufferSize;
	SIZE_T m_nFileSize;
	BYTE* m_lpBuffer;
	BOOL m_bAutoDelete;

public:
	virtual ~CVCMemFile();
	virtual ULONGLONG GetPosition() const;
	BOOL GetStatus(CVCFileStatus& rStatus) const;
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual BOOL Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual SIZE_T GetBufferPtr(UINT nCommand, SIZE_T nCount = 0, void** ppBufStart = NULL, void** ppBufMax = NULL);
	virtual ULONGLONG GetLength() const;

	// Unsupported APIs
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
class CVCSharedFile : public CVCMemFile
{
public:
// Constructors
	CVCSharedFile(UINT nAllocFlags = GMEM_DDESHARE|GMEM_MOVEABLE,
		UINT nGrowBytes = 4096);

// Attributes
	HGLOBAL Detach();
	void SetHandle(HGLOBAL hGlobalMemory, BOOL bAllowGrow = TRUE);

// Implementation
public:
	virtual ~CVCSharedFile();

protected:
	virtual BYTE* Alloc(DWORD nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, DWORD nBytes);
	virtual void Free(BYTE* lpMem);

	UINT m_nAllocFlags;
	HGLOBAL m_hGlobalMemory;
	BOOL m_bAllowGrow;
};

/////////////////////////////////////////////////////////////////////////////
// File status

struct CVCFileStatus
{
	CVCTime m_ctime;          // creation date/time of file
	CVCTime m_mtime;          // last modification date/time of file
	CVCTime m_atime;          // last access date/time of file
	ULONGLONG m_size;            // logical size of file in bytes
	BYTE m_attribute;       // logical OR of CVCFile::Attribute enum values
	BYTE _m_padding;        // pad the structure to a WORD
	TCHAR m_szFullName[_MAX_PATH]; // absolute path name
};

extern BOOL VCFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
extern void VCGetRoot(LPCTSTR lpszPath, CVCString& strRoot);
extern UINT VCGetFileName(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);
extern UINT VCGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);
extern void __cdecl VCTimeToFileTime(const CVCTime& time, LPFILETIME pFileTime);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\vcnode.h ===
// VCNode.h: interface for the CVCNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VCNODE_H__1FAE18F3_9021_11D0_8D12_00A0C91BC942__INCLUDED_)
#define AFX_VCNODE_H__1FAE18F3_9021_11D0_8D12_00A0C91BC942__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "hu_ctnr.h"

#include <bldtypes.h>
class CProjItem;	// defined in pkgs\projbld\src\projitem.h
class CProject;		// defined in pkgs\projbld\src\project.h
class CVCDataDescriptor;

enum enumEnableStates 
{
	eEnableSupported = 0,
	eEnableSupportedAndEnabled = 1,
	eEnableInvisible = -1,
	eEnableNotSupported = -2,
	eEnableLatchedAndEnabled = -3,
	eEnableEnabled = -4,
	eEnableLatched = -5
};

class CVCNode : public CHierContainer
{
public:

DECLARE_NOT_AGGREGATABLE(CVCNode)


	enum enumKnownGuidList { eGuidUninitialized, eGuidVCCmdId, eGuidVSStd97 };

	UINT GetIconIndex();
					CVCNode(LPCTSTR pszName);
					CVCNode(void);
	virtual			~CVCNode(void);

	// Command Routing
	STDMETHOD(QueryStatus)(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut);

	virtual HRESULT QueryStatusAtIndex(enumKnownGuidList eGuid, const GUID* pguidCmdGroup, OLECMD prgCmds[],
		OLECMDTEXT *pCmdText, ULONG nIndex);
	virtual HRESULT ProcessUIMsg(const MSG *pMsg);
	// REVIEW: This is only for debugging purposes
	virtual HRESULT DisplayContextMenu();
	virtual const GUID* PGuidGetType(void) const { return NULL; }
	virtual HRESULT	EnumerateChildren() { return S_OK; }
	virtual void OnOpenSettingsDialog();
	virtual HRESULT		GetProperty(VSHPROPID propid, VARIANT* pvar);
	virtual BOOL		IsContainer(void) const;	// returns FALSE
	virtual	UINT		GetKindOf(void) const;

	// CHierNode Properties
	HRESULT GetDisplayCaption(BSTR* pbstrCaption);
	virtual HRESULT GetDisplayCaption(CString& strCaption);

	HRESULT ShowContextMenu(UINT imxMenuID, IOleCommandTarget *pOleCommandTarget  = NULL);

	static DWORD TranslateEnableState(enumEnableStates eState);
	// CHierNode Properties

	STDMETHOD(get_Caption)(BSTR *pCaption) const;
	STDMETHOD(put_Caption)(LPCWSTR Caption);
	CString& GetFullName(CString& str) { str = m_strFullPath; return m_strFullPath;}

	BOOL IsExpanded(void) const
	{
		return (m_grfStateFlags & ST_IsExpanded);
	}

	CProjItem*		m_pProjItem;
	BOOL			m_fAutoExpand;
	DWORD			m_grfStateFlags;		// ChildrenEnumerated, IsExpanded, etc
	enum	// m_grfStateFlags
	{
		ST_ChildrenEnumerated = (1<<0),
		ST_IsExpanded = (1<<1),
		ST_FirstUserFlag = (1<<16)	// Derived classes are free to use these upper bits
	};

public:
	CProject* GetCProject();
	void SetCProject(CProject* pProject) { m_pProjItem = (CProjItem*)pProject; }
	HPROJECT GetHProject() { return (HPROJECT) m_pProjItem; }
	CProjItem* GetCProjItem() { return m_pProjItem; }


	CString			m_strCaption;	// this node's name
    CString			m_strFullPath;

	virtual const CString& GetCaption(void) { return m_strCaption; }
	virtual void SetCaption(LPCSTR pszNewCaption) {	// ansi method	
											m_strCaption = pszNewCaption; }
	virtual void SetCaption(LPCWSTR pszNewCaption) {	// unicode method
												m_strCaption = pszNewCaption; }
	virtual void SetCaption(const CString& strNewCaption);
	virtual const CString& GetFullPath(void) { return m_strFullPath; }

};

#endif // !defined(AFX_VCNODE_H__1FAE18F3_9021_11D0_8D12_00A0C91BC942__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCTextBuffer.h ===
#pragma once

#include <VCAssert.h>

// CVCTextBufferLock
//

class CVCTextBufferLock
{
private :

	CComPtr<IVsTextBuffer> m_spIVsTextBuffer;
	BufferLockFlags m_blf;
	bool m_bLocked;

public :

	CVCTextBufferLock(IVsTextBuffer * pIVsTextBuffer, BufferLockFlags blf = BLF_READ) 

	: m_spIVsTextBuffer(pIVsTextBuffer), 
	  m_blf(blf),
	  m_bLocked(false)

	{
		HRESULT hr(S_OK);

		if (SUCCEEDED(hr = m_spIVsTextBuffer->LockBufferEx(blf)))
		{
			m_bLocked = true;
		}

		VCASSERT(SUCCEEDED(hr));
	}

	~CVCTextBufferLock(void)
	{
		if (m_bLocked)
		{
			HRESULT hr(S_OK);
			hr = m_spIVsTextBuffer->UnlockBufferEx(m_blf);
			VCASSERT(SUCCEEDED(hr));
		}
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\vcmap.inl ===
#ifndef AFX_INLINE
#define AFX_INLINE inline
#endif

#ifdef new
#pragma push_macro("new")
#undef new
#define _REDEF_NEW
#endif

#ifndef _INC_NEW
	#include <new.h>
#endif

template<class TYPE>
AFX_INLINE void VCConstructElements(TYPE* pElements, int nCount)
{
	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
AFX_INLINE void VCDestructElements(TYPE* pElements, int nCount)
{
	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE, class ARG_TYPE>
BOOL CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
AFX_INLINE UINT HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return ((UINT)key) >> 4;
}


/////////////////////////////////////////////////////////////////////////////
// CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE int CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE BOOL CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE void CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE VCPOSITION CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE UINT CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CVCMap(int nBlockSize)
{
	VSASSERT(nBlockSize > 0, "Block size must be positive!");

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	VSASSERT(m_nCount == 0, "Already initialized!");
	VSASSERT(nHashSize > 0, "Hash size must be positive!");

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				VCDestructElements<VALUE>(&pAssoc->value, 1);
				VCDestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CVCMap()
{
	RemoveAll();
	VSASSERT(m_nCount == 0, "Failed to remove all elements from map in destruction!");
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CVCPlex* newBlock = CVCPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CVCMap::CAssoc));
		// chain them into free list
		CVCMap::CAssoc* pAssoc = (CVCMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	VSASSERT(m_pFreeList != NULL, "Out of memory!");  // we must have something

	CVCMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	VSASSERT(m_nCount > 0, "make sure we don't overflow");
	VCConstructElements<KEY>(&pAssoc->key, 1);
	VCConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CVCMap::CAssoc* pAssoc)
{
	VCDestructElements<VALUE>(&pAssoc->value, 1);
	VCDestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	VSASSERT(m_nCount >= 0, "make sure we don't underflow");

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey<ARG_KEY>(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHashValue;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(VCPOSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	VSASSERT(m_pHashTable != NULL, "never call GetNextAssoc on empty map");

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	VSASSERT(pAssocRet != NULL, "Bad input parameter");

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		VSASSERT(pAssocRet != NULL, "must find something in GetNextAssoc"); 
	}

	// find next association
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (VCPOSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
	VSASSERT(m_nHashTableSize > 0, "Hash table size must be positive");
	VSASSERT(m_nCount == 0 || m_pHashTable != NULL, "Non-empty map must have hash table");
		// non-empty map should have hash table
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCMap.h ===
// (WINSLOWF) This was the MFC CMap stuff
// Now it has been purged of all other MFC influences and is a stand alone entity.
// NOTE: exceptions are no longer thrown on various errors...

#pragma once
#include "plex.h"

#define BEFORE_START_POSITION ((VCPOSITION)-1L)

/////////////////////////////////////////////////////////////////////////////
// CVCMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CVCMap
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CVCMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	VCPOSITION GetStartPosition() const;
	void GetNextAssoc(VCPOSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CVCPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&, UINT&) const;

public:
	~CVCMap();
//WINSLOWF	void Serialize(CArchive&);
#ifdef _DEBUG
//WINSLOWF	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#include "vcmap.inl"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\vcstring.h ===
//////////////////////////////////////////////////////////////////////////////////////////////
// vcstring.h: CString-like class that can be used in both MFC and ATL projects (CString
// is one or the other, but not allowed to be both...)

#pragma once

#if _MSC_VER < 1300

// NOTE: this class looks more or less identical to StrTraitATL except that it is OK to 
// use it in mixed MFC/ATL projects
class StrVCTraitATL : public ChTraitsOS<TCHAR>
{
public:
	static HINSTANCE GetResourceHandle()
	{
		return _pModule->GetResourceInstance();
	}

	static void ThrowMemoryException()
	{
		CSTRING_ASSERT(FALSE);
	}

	static void ThrowResourceException()
	{
		CSTRING_ASSERT(FALSE);
	}

	static CStringData* GetMemory(int nLen)
	{
		// nLen is in XCHARs
		CStringData* pData;

		int nTotal = sizeof(CStringData) + (nLen+1)*sizeof(TCHAR);
		pData = (CStringData*) malloc(nTotal);
		pData->nAllocLength = nLen;
		return pData;
	}

	static void ReleaseMemory(CStringData* pVoid)
	{
		free(pVoid);
	}
		
	static void Trace(const char* pstr)
	{
		OutputDebugStringA(pstr);
	}

	static void Trace(const char* pstr, unsigned int n)
	{
		char szBuffer[512];
		wsprintfA(szBuffer, pstr, n);
		OutputDebugStringA(szBuffer);
	}

	static int LoadStringImpl(HINSTANCE hRes, UINT nID,	TCHAR* lpszBuf, UINT nMaxBuf)
	{
		CSTRING_ASSERT(CStringIsValidAddress(lpszBuf, nMaxBuf));
#ifdef _DEBUG
		// LoadString without annoying warning from the Debug kernel if the
		//  segment containing the string is not present
		if (::FindResource(hRes, MAKEINTRESOURCE((nID>>4)+1),
			RT_STRING) == NULL)
		{
			lpszBuf[0] = '\0';
			return 0; // not found
		}
#endif //_DEBUG
		int nLen = LoadWindowsString(hRes, nID, lpszBuf, nMaxBuf);
		if (nLen == 0)
			lpszBuf[0] = '\0';
		return nLen;
	}
};

typedef CStringT<TCHAR, StrVCTraitATL> CVCString;

#else  // _MSC_VER < 1300

#include <atlstr.h>

//#ifdef _ATL_CSTRING_NO_STRMGRTRAITS
typedef ATL::CAtlString CVCString;
//#else
//typedef CStringT< TCHAR, StrTraitATL< TCHAR > > CVCString;
//#endif

#endif  // _MSC_VER < 1300
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCRootDE.h ===
#pragma once

#include "VCCodeModels.h"
#include "VCDesignerObjectInternal.h"
#include "VSTypeInfo.h"

// MACROs
//

#define DECLARE_VCDESIGNELEMENT(nDefaultIconID) \
	\
	STDMETHOD(get_Picture)(IDispatch **	ppIDispatch) \
	{ \
		PICTDESC pictureDescription = { sizeof(PICTDESC), PICTYPE_ICON }; \
		pictureDescription.icon.hicon = static_cast<HICON>(LoadImage( \
			_Module.GetResourceInstance(), MAKEINTRESOURCE(nDefaultIconID), \
			IMAGE_ICON, 16, 16, LR_SHARED)); \
		return OleCreatePictureIndirect(&pictureDescription, __uuidof(IDispatch), \
				FALSE, reinterpret_cast<void **>(ppIDispatch)); \
	} \

// CVCRootDE
//
// Default implementation of a designe time element.
//
// Examples : Workspaces, Files, Configurations, Resources, CodeElements, etc.
//
// If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
//

// CVCRootDE
//

template<typename TInterfaces>
class ATL_NO_VTABLE CVCRootDE : 

	public CComObjectRootEx<CComSingleThreadModel>,
	public TInterfaces,
	public IVsPerPropertyBrowsing,
	public ISupportErrorInfo

{
public :

	BEGIN_COM_MAP(CVCRootDE)
		COM_INTERFACE_ENTRY2(IDispatch, _D)
		COM_INTERFACE_ENTRY(VCDesignElement)
		COM_INTERFACE_ENTRY(VCDesignElementI)
		COM_INTERFACE_ENTRY(ISupportErrorInfo)
		COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
		COM_INTERFACE_ENTRY_CHAIN(_D)
	END_COM_MAP()

	// IDispatch
	//
	// All interfaces must defer to a single, common IDispatch implementation...
	//

	STDMETHOD(GetTypeInfoCount)(UINT * pctinfo) { return _D::GetTypeInfoCount(pctinfo); }
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo ** ppTInfo) { return _D::GetTypeInfo(iTInfo, lcid, ppTInfo); }
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId) { return _D::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId); }
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pDispParams, VARIANT * pVarResult, EXCEPINFO * pExcepInfo, UINT * puArgErr) { return _D::Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr); }

	// IVsPerPropertyBrowsing
	//

	STDMETHOD(HideProperty)(DISPID dispid, BOOL* pfHide)
		{ return S_FALSE; }
	STDMETHOD(DisplayChildProperties)(DISPID dispid, BOOL* pfDisplay) 
		{ return S_FALSE; }
	STDMETHOD(GetLocalizedPropertyInfo)(DISPID dispid, LCID lcid, BSTR* pbstrName, BSTR* pbstrDesc)
		{
			CComPtr<ITypeInfo> pTypeInfo;
			HRESULT hr = GetTypeInfo(0, lcid, &pTypeInfo);
			CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
			if( FAILED(hr) || (pTypeInfo2 == NULL) )
				return E_FAIL;

			CComBSTR bstrDoc;
			hr = pTypeInfo2->GetDocumentation2(dispid, lcid, &bstrDoc, NULL, NULL);
			if( FAILED(hr) || (bstrDoc.m_str == NULL) )
				return E_FAIL;


			if( pbstrName != NULL )
			{
				return E_NOTIMPL;
			}

			if (pbstrDesc != NULL)
				*pbstrDesc = bstrDoc.Detach();
			return S_OK;
		}

	STDMETHOD(HasDefaultValue)(DISPID dispid, BOOL* fDefault)
		{ return S_FALSE; }
	STDMETHOD(IsPropertyReadOnly)(DISPID dispid, BOOL* fReadOnly)
		{ return S_FALSE; }
   	STDMETHOD(GetClassName)(BSTR* )
		{ return E_NOTIMPL; }
    STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* )
		{ return E_NOTIMPL; }
    STDMETHOD(ResetPropertyValue)(DISPID )
		{ return E_NOTIMPL; }

	// ISupportErrorInfo
	//

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{ 
		return (InlineIsEqualGUID(riid,__uuidof(_DI))) ? S_OK : S_FALSE;
	}

	// VCDesignElement
	//

	STDMETHOD(get_DTE)(DTE ** ppDTE) 
	{ 
		VALIDATE_AND_CLEAR(ppDTE);
		return CVCUtilityLibrary::QueryService(reinterpret_cast<_DTE **>(ppDTE)); 
	}

	STDMETHOD(get_Name)(BSTR * pbstrName)
	{
		return S_FALSE;
	}

	STDMETHOD(get_DisplayName)(BSTR * pbstrDisplayName)
	{
		return get_Name(pbstrDisplayName);
	}

	STDMETHOD(get_IsCaseSensitive)(VARIANT_BOOL * pbIsCaseSensitive)
	{
		VALIDATE_WRITE_POINTER_HR(pbIsCaseSensitive);

		*pbIsCaseSensitive = VARIANT_FALSE;

		return S_OK;
	}

	STDMETHOD(get_Parent)(IDispatch ** ppParent)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(get_IsZombie)(VARIANT_BOOL * pbIsZombie)
	{
		VALIDATE_AND_CLEAR(pbIsZombie);
		*pbIsZombie = VARIANT_FALSE;
		return S_OK;
	}

	STDMETHOD(get_IsReadOnly)(VARIANT_BOOL * pbIsReadOnly)
	{
		VALIDATE_AND_CLEAR(pbIsReadOnly);
		*pbIsReadOnly = VARIANT_FALSE;
		return S_OK;
	}

	STDMETHOD(IsSelf)(IDispatch * pOther, VARIANT_BOOL * pbIsSelf)
	{
		VALIDATE_AND_CLEAR_POINTER(pbIsSelf);

		HRESULT hr(S_OK);
		CComPtr<IUnknown> spThis;
		CComPtr<IUnknown> spUnknown;

		FAILED_RETURN_HR(QueryInterface(__uuidof(IUnknown), reinterpret_cast<void **>(&spThis)));
		FAILED_RETURN_HR(pOther->QueryInterface(__uuidof(IUnknown), reinterpret_cast<void **>(&spUnknown)));

		*pbIsSelf = (spThis == spUnknown ? VARIANT_TRUE : VARIANT_FALSE);

		return S_OK;
	}

	// Internal
	//

	STDMETHOD(put_Parent)(IDispatch * pIDispatch)
	{
		VSFAIL("Derived class must implement put_Parent");
		return E_UNEXPECTED;
	}

	STDMETHOD(put_Name)(BSTR bstrName)
	{
		VSFAIL("Derived class must implement put_Name");
		return E_UNEXPECTED;
	}

	STDMETHOD(get_Descendants)(IDispatch ** ppDescendants)
	{
		VSFAIL("Derived class must implement get_Descendants");
		return E_UNEXPECTED;
	}
};

template <class T, const IID* piid = &__uuidof(T), const GUID* plibid = &CAtlModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE CVCIDispatchImpl : public IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>
{
public :

	typedef CVCIDispatchImpl _D;
	typedef T _DI;

	BEGIN_COM_MAP(CVCIDispatchImpl)
		COM_INTERFACE_ENTRY(IDispatch)
	END_COM_MAP()
};

template <class T, const IID* piid = &__uuidof(T), const GUID* plibid = &LIBID_VCCodeModelLibrary, 
WORD wMajor = 1 /* For CVsTypeInfoHolder, this is TYPELIB Resource ID, NOT Version! */,
WORD wMinor = 0, class tihclass = CVsTypeInfoHolder>
class ATL_NO_VTABLE CVCIDispatchImplDE : public CVCIDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>
{
};

// Passthroughs
//

class ATL_NO_VTABLE IVCRootDEPT : 
	public CVCIDispatchImplDE<VCDesignElement>, 
	public VCDesignElementI
{ 
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VsRootCE.h ===
#pragma once

#include <ShellVer.h>

// CVsRootCE
//

#define DECLARE_VSCODEELEMENT(Kind, nDefaultIconID, wszExtenderCATID) \
	\
	DECLARE_VCDESIGNELEMENT(nDefaultIconID) \
	\
	virtual vsCMElement GetKind(void) { return Kind; } \
	STDMETHOD(get_Kind)(vsCMElement * pKind) \
	{ \
		VALIDATE_AND_CLEAR(pKind); \
		*pKind = Kind; \
		return S_OK; \
	} \
	\
	STDMETHOD(get_ExtenderCATID)(BSTR * pbstrExtenderCATID) \
	{ \
		VALIDATE_AND_CLEAR(pbstrExtenderCATID); \
		*pbstrExtenderCATID = CComBSTR(wszExtenderCATID).Detach(); \
		FAILED_RETURN(E_OUTOFMEMORY, *pbstrExtenderCATID); \
		return S_OK; \
	}

template<typename TInterfaces>
class ATL_NO_VTABLE CVsRootCE : public CVCRootDE<TInterfaces>
{
public :

	BEGIN_COM_MAP(CVsRootCE)
		COM_INTERFACE_ENTRY(CodeElement)
		COM_INTERFACE_ENTRY_CHAIN(CVCRootDE<TInterfaces>)
	END_COM_MAP()

	virtual vsCMElement GetKind(void) { return vsCMElementOther; }

	// CodeElement (VS)
	//

	STDMETHOD(get_Kind)(vsCMElement * pCodeEltKind);
	STDMETHOD(get_ExtenderNames)(VARIANT * pvExtenderNames); 
	STDMETHOD(get_Extender)(BSTR bstrExtenderName, IDispatch ** ppExtender); 
	STDMETHOD(get_ExtenderCATID)(BSTR * pbstrExtenderCATID)
		{ VSFAIL(L"Derived class must use DECLARE_VSCODEELEMENT!"); return E_UNEXPECTED; }
	STDMETHOD(get_InfoLocation)(vsCMInfoLocation *pInfoLocation); 
	STDMETHOD(get_IsCodeType)(VARIANT_BOOL *pIsCodeType);
};

template <class T, const IID* piid = &__uuidof(T), 
	const GUID* plibid = &LIBID_EnvDTE, WORD wMajor = DTE_LIB_VERSION_MAJ,
WORD wMinor = DTE_LIB_VERSION_MIN, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE CVCIDispatchImplDTE : public CVCIDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>
{
};

template<typename TInterfaces>
STDMETHODIMP CVsRootCE<TInterfaces>::get_ExtenderNames(VARIANT * pvExtenderNames) 
{ 
	VALIDATE_ARGUMENT(pvExtenderNames);

	HRESULT hr(S_OK);
	CComBSTR bstrCATID;
	CComPtr<ObjectExtenders> spExtensionManager;
	CComPtr<IDispatch> spThis;

	FAILED_RETURN_HR(get_ExtenderCATID(&bstrCATID));
	FAILED_RETURN(E_OUTOFMEMORY, bstrCATID);
	FAILED_RETURN_HR(CVCUtilityLibrary::QueryService(&spExtensionManager));
	FAILED_RETURN_HR(GetUnknown()->QueryInterface(__uuidof(IDispatch), reinterpret_cast<void **>(&spThis)));
	FAILED_RETURN_HR(spExtensionManager->GetExtenderNames(bstrCATID, spThis, pvExtenderNames));

	return hr;
}

template<typename TInterfaces>
STDMETHODIMP CVsRootCE<TInterfaces>::get_Extender(BSTR bstrExtenderName, IDispatch ** ppExtender) 
{ 
	VALIDATE_ARGUMENT(bstrExtenderName);
	VALIDATE_AND_CLEAR(ppExtender);

	HRESULT hr(S_OK);
	CComBSTR bstrCATID;
	CComPtr<ObjectExtenders> spExtensionManager;
	CComPtr<IDispatch> spThis;

	FAILED_RETURN_HR(get_ExtenderCATID(&bstrCATID));
	FAILED_RETURN(E_OUTOFMEMORY, bstrCATID);
	FAILED_RETURN_HR(CVCUtilityLibrary::QueryService(&spExtensionManager));
	FAILED_RETURN_HR(GetUnknown()->QueryInterface(__uuidof(IDispatch), reinterpret_cast<void **>(&spThis)));
	FAILED_RETURN(S_FALSE, spExtensionManager->GetExtender(bstrCATID, bstrExtenderName, spThis, ppExtender));

	return hr; 
}

template<typename TInterfaces>
STDMETHODIMP CVsRootCE<TInterfaces>::get_InfoLocation(vsCMInfoLocation *pInfoLocation) 
{ 
	VALIDATE_AND_CLEAR(pInfoLocation);
	*pInfoLocation = vsCMInfoLocationNone;
	return S_OK;
}

template<typename TInterfaces>
STDMETHODIMP CVsRootCE<TInterfaces>::get_IsCodeType(VARIANT_BOOL * pbIsCodeType) 
{ 
	VALIDATE_AND_CLEAR(pbIsCodeType);
	*pbIsCodeType = VARIANT_FALSE;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\acapi.h ===
// File: acapi.h
// This file defines the interfaces used by auto complete

#ifndef __ACAPI_H__
#define __ACAPI_H__

__interface IVsTextBuffer;
__interface IVsCompletionSet;
__interface IVsTipWindow;
__interface IVsMethodData;

//ignore this, it's just so things will compile
typedef enum _TextSelMode
{
    SM_STREAM,
    SM_BOX
} TextSelMode;

#define MAX_VISIBLE 10

////////////////////////////////////////////////////////////////////////////
// CompletionStatusFlags enum
////////////////////////////////////////////////////////////////////////////
typedef enum _CompletionStatusFlags
{
    // UCS_* flags are passed to IVsTextView::UpdateCompletionStatus
    UCS_NAMESCHANGED        = 0x0001,       // Names or name count has changed
    UCS_EXTENTCHANGED       = 0x0002,       // Extent changed
    UCS_FLAGSCHANGED        = 0x0004,       // Flags have changed...
	UCS_COMPLETEWORD		= 0x0008,		// Attempt word completion

    // CSF_* flags are returned from ICompletionSet::GetFlags
    CSF_CUSTOMMATCHING      = 0x0004,       // Use ICompletionSet::GetBestMatch() to manage selection
    CSF_CUSTOMCOMMIT        = 0x0008,       // Use ICompletionSet::OnCommit() to commit completions
    CSF_HAVEDESCRIPTIONS    = 0x0010,       // ICompletionSet::GetDescriptionText will provide text for at least some of the entries
    CSF_INITIALEXTENTKNOWN  = 0x0020,        // Use ICompletionSet::GetInitialExtent to determine initial word extent
	CSF_NOCASEMATCHING      = 0x0040,
	CSF_NOCASEUNIQUENESS    = 0x0080,

    // GBM_* flags are returned from IVsCompletionSet::GetBestMatch
    GBM_SELECT              = 0x0001,       // The returned index should be selected
    GBM_UNIQUE              = 0x0002        // The returned index is the only appropriate match

} UpdateCompletionFlags;

/////////////////////////////////////////////////////////////////////////
// TipWindowFlags enum
/////////////////////////////////////////////////////////////////////////
typedef enum _TipWindowFlags
{
    UTW_CONTEXTCHANGED      = 0x0001,       // Context stream is different
    UTW_CONTENTCHANGED      = 0x0002,       // Data displayed in window has changed (size will be re-queried)
    UTW_DISMISS             = 0x0004,       // Tip window should be dismissed
	UTW_ANGLEBRACKET		= 0x0008		// angle bracket
} TipWindowFlags;

////////////////////////////////////////////////////////////////////////////
// TipPosPreference enum
////////////////////////////////////////////////////////////////////////////
typedef enum _TipPosPreference
{
    TPP_ABOVE,
    TPP_BELOW,
    TPP_LEFT,
    TPP_RIGHT,
    TPP_DOCKED      // Current NYI -- defaults to TPP_ABOVE
} TipPosPreference;

////////////////////////////////////////////////////////////////////////////
// TIPSIZEDATA structure
////////////////////////////////////////////////////////////////////////////
typedef struct _tipsizedata
{
    SIZE                size;
    TipPosPreference    dwPosition;
} TIPSIZEDATA;


#undef INTERFACE
#define INTERFACE	IVsTextView

//This is the view interface used in the new shell.  By implementing a small portion of it
//in the old shell, we can allow the auto complete back end to use the same view interface
//in both the old and new shells, thus minimizing the work needed to move it forward into
//the new shell. 
DECLARE_INTERFACE_(IVsTextView, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    //IVsTextView methods
    STDMETHOD       (Initialize)(IVsTextBuffer *pBuffer, HWND hwndParent, DWORD InitFlags) PURE;
    STDMETHOD       (CloseView)() PURE;
    STDMETHOD       (GetCaretPos)(long *piLine, long *piColumn) PURE;
    STDMETHOD       (SetCaretPos)(long iLine, long iColumn) PURE;
    STDMETHOD       (GetSelection)(long *piAnchorLine, long *piAnchorCol, long *piEndLine, long *piEndCol) PURE;
    STDMETHOD       (SetSelection)(long iAnchorLine, long iAnchorCol, long iEndLine, long iEndCol) PURE;
    STDMETHOD_(TextSelMode, GetSelectionMode)() PURE;
    STDMETHOD       (SetSelectionMode)(TextSelMode iSelMode) PURE;
    STDMETHOD       (ClearSelection)(BOOL fMoveToAnchor) PURE;
    STDMETHOD       (CenterLines)(long iLine, long iCount) PURE;
    STDMETHOD       (GetSelectedText)(BSTR *bstrText) PURE;
    STDMETHOD       (GetSelectionDataObject)(IDataObject **ppIDataObject) PURE;
    STDMETHOD       (GetTextStream)(long iTopLine, long iTopCol, long iBottomLine, long iBottomCol, BSTR *pbstrText) PURE;
    STDMETHOD       (GetBuffer)(IVsTextBuffer **ppBuffer) PURE;
    STDMETHOD       (SetBuffer)(IVsTextBuffer *pBuffer) PURE;
    STDMETHOD_(HWND, GetWindowHandle)()  PURE;
    STDMETHOD       (GetScrollInfo)(long iBar, long *piFirst, long *piLast, long *piVisible, long *piTop) PURE;
    STDMETHOD       (SetScrollPosition)(long iBar, long iPos) PURE;
    STDMETHOD       (AddCommandFilter)(IOleCommandTarget *pNewCmdTarg, IOleCommandTarget **ppNextCmdTarg) PURE;
    STDMETHOD       (RemoveCommandFilter)(IOleCommandTarget *pCmdTarg) PURE;
    STDMETHOD       (UpdateCompletionStatus)(IVsCompletionSet *pCompSet, DWORD dwFlags) PURE;
    STDMETHOD       (UpdateTipWindow)(IVsTipWindow *pTipWnd, DWORD dwFlags) PURE;
    STDMETHOD       (GetWordExtent)(long iLine, long iCol, DWORD dwFlags, long *piStartCol, long *piLength) PURE;
    STDMETHOD       (RestrictViewRange)(long iMinLine, long iMaxLine) PURE;
    STDMETHOD       (BeginCompoundEdit)(const WCHAR *pszDescription) PURE;
    STDMETHOD       (EndCompoundEdit)() PURE;
    STDMETHOD       (AbortCompoundEdit)() PURE;
    STDMETHOD       (ReplaceTextOnLine)(long iLine, long iStartCol, long iCharsToReplace, const WCHAR *pszNewText, long iNewLen) PURE;
    STDMETHOD       (GetLineAndColumn)(long iPos, long *piLine, long *piCol) PURE;
    STDMETHOD       (GetNearestPosition)(long iLine, long iCol, long *piPos, long *piVirtualSpaces) PURE;
};

#undef INTERFACE
#define INTERFACE	IVsCompletionSet

DECLARE_INTERFACE_(IVsCompletionSet, IUnknown){
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    // ICompletionSet methods
    // Flags indicating specific behaviors of this completion set (CSF_* above)
    STDMETHOD_(DWORD,GetFlags)() PURE;

    // Get the number of available completions (assert > 1?)
    STDMETHOD_(long, GetCount)() PURE;
    
    // Get the text of a completion, as it is to be displayed in the list.
    // The pointer returned should be maintained by the completion set
    // object, and remain valid until final release, or until updated
    // through IVsTextView::UpdateCompletionStatus
	STDMETHOD       (GetDisplayText)(long iIndex, const WCHAR** ppszText, long *piGlyph) PURE;
    
    // Get the list of images (glyphs) supported by this completion set.
    // UNDONE:  Define HIMAGELIST so we don't have to cast...
	STDMETHOD       (GetImageList)(HANDLE *phImageList) PURE;
    
    // Return text describing the indicated item
	STDMETHOD       (GetDescriptionText)(long iIndex, BSTR *pbstrDescription) PURE;
    
	// Get the initial extent of the word to be completed.  *piLen can be
	// set to zero, but an anchor coordinate (line, col) must be provided.
	STDMETHOD       (GetInitialExtent)(long *piLine, long *piCol, long *piLen) PURE;
    
    // Determine the index of the closest matching completion, given
    // what has been typed so far.  Note that this is only called if
    // CSF_CUSTOMMATCHING is set in this completion set's flags.  If
    // *pdwFlags is set to contain one of the GBM_* flags
    // The default matching in the view uses case sensitive comparison.
	STDMETHOD       (GetBestMatch)(const WCHAR *pszSoFar, long iLength, long *piIndex, DWORD *pdwFlags) PURE;
    
    // Commit a completion.  S_FALSE return causes 'ding', and commit
    // character is NOT inserted.  S_OK return with *pbstrCompleteWord == pszSoFar
    // will match the default behavior if fSelected is FALSE.  If fSelected
    // is TRUE, the default behavior is to replace pszSoFar in the editor
    // with the text returned by GetDisplayText.  This is only called
    // if this completion set's flags include CSF_CUSTOMCOMMIT.
	STDMETHOD       (OnCommit)(const WCHAR *pszSoFar, long iIndex, BOOL fSelected, WCHAR cCommit, BSTR *pbstrCompleteWord)  PURE;
    
    // Called by the view when the completion set is no longer needed.
    // Note that if a language filter wants to force a dismiss of a completion
    // set, it calls IVsTextView::UpdateCompletionStatus with pCompSet == NULL;
    // if the view has a completion set pointer cached, it calls Dismiss()
    // on it and then releases it (and also removes the UI, etc).
	STDMETHOD_(void, Dismiss)() PURE;

};

#undef INTERFACE
#define INTERFACE	IVsTipWindow

DECLARE_INTERFACE_(IVsTipWindow, IUnknown){
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IVsTipWindow
    // Return the context stream (the position and length of text in the
    // buffer that should not be obscured by the tip window, but to which
    // the content of the tip is related).
    STDMETHOD   (GetContextStream)(long *piPos, long *piLength) PURE;

    // Get the size preferences for this tip window.  Note that implementations
    // should be written to handle cases where the size preference they
    // return here are not what they are given for real estate in which to
    // display content.  (i.e., it may not be possible to provide the
    // tip window in the requested size).  prcCtxBounds represents the bounding
    // rectangle of the tip's context should the implementation be interested.
    // (This rectangle is provided in screen coordinates).
    STDMETHOD   (GetSizePreferences)(BOOL fAngleBracket, const RECT *prcCtxBounds, TIPSIZEDATA *pSizeData) PURE;

    // Paint the tip window.
    STDMETHOD   (Paint)(HDC hdc, const RECT *prcPaint) PURE;

	// The window is being dismissed by the view.
    STDMETHOD_(void, Dismiss)() PURE;

    // Event handler for the tip window
    STDMETHOD_(LRESULT, WndProc) (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam) PURE;
};

/////////////////////////////////////////////////////////////////////////
// MethodTextType enum
/////////////////////////////////////////////////////////////////////////
typedef enum _MethodTextType
{
    // Note that GetMethodText can return NULL for any of these types except NAME.
    // Any that it does not will be displayed.  Format is as follows:
    //  [TYPEPREFIX] [NAME] ( <parms> ) [TYPEPOSTFIX]
    //       [DESCRIPTION]
    MTT_TYPEPREFIX,             // return type if prefixed, ala Java/C++ ("long foo()")
    MTT_TYPEPOSTFIX,            // return type if postfixed, ala Basic ("foo() as long") (text must include "as" keyword)
    MTT_NAME,                   // Method name
    MTT_DESCRIPTION             // Description of method (gets its own line)
} MethodTextType;

/////////////////////////////////////////////////////////////////////////
// ParameterTextType enum
/////////////////////////////////////////////////////////////////////////
typedef enum _ParameterTextType
{
    // Note that GetParameterText can return NULL for any except DECLARATION, and NAME if DESCRIPTION is non-NULL.
    PTT_DECLARATION,            // full decl as it appears in signature (i.e. "long x", or "x as long")
    PTT_NAME,                   // parameter name only (i.e. "x")
    PTT_DESCRIPTION             // description (gets its own line, and is prefixed with NAME: (bolded))
} ParameterTextType;

#undef INTERFACE
#define INTERFACE	IVsMethodTipWindow

DECLARE_INTERFACE_(IVsMethodTipWindow, IVsTipWindow){
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IVsTipWindow methods
    STDMETHOD   (GetContextStream)(long *piPos, long *piLength) PURE;
    STDMETHOD   (GetSizePreferences)(BOOL fAngleBracket, const RECT *prcCtxBounds, TIPSIZEDATA *pSizeData) PURE;
    STDMETHOD   (Paint)(HDC hdc, const RECT *prcPaint) PURE;
    STDMETHOD_(void, Dismiss)() PURE;
    STDMETHOD_(LRESULT, WndProc) (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam) PURE;

    // IVsMethodTipWindow methods
    STDMETHOD   (SetMethodData)(IVsMethodData *pData) PURE;
};

#undef INTERFACE
#define INTERFACE	IVsMethodData

DECLARE_INTERFACE_(IVsMethodData, IUnknown){
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    //IVsMethodData methods
    STDMETHOD_(long,    GetOverloadCount)() PURE;
    STDMETHOD_(PCWSTR,  GetMethodText)(long iMethod, MethodTextType type) PURE;
    STDMETHOD_(long,    GetParameterCount)(long iMethod) PURE;
    STDMETHOD_(PCWSTR,  GetParameterText)(long iMethod, long iParm, ParameterTextType type) PURE;
    STDMETHOD_(long,    GetCurrentParameter)(long iMethod) PURE;
    STDMETHOD (			GetContextStream)(long *piPos, long *piLength) PURE;
    STDMETHOD_(void,    OnDismiss)() PURE;
	STDMETHOD_(long,    GetCurMethod) (void) PURE;
    STDMETHOD_(void,    UpdateView) (void) PURE;
    STDMETHOD_(long,    NextMethod) (void) PURE;
    STDMETHOD_(long,    PrevMethod) (void) PURE;
};

#undef INTERFACE
#define INTERFACE	IVsTextViewFilter

DECLARE_INTERFACE_(IVsTextViewFilter, IUnknown){
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    //IVsTextViewFilter methods
    
    // Word extent calculation
    STDMETHOD (GetWordExtent) (long iPos, DWORD dwFlags, long *piStart, long *piLength) PURE;
    // Data-tip support.  piPos and piLength are in/out -- they indicate the
    // selected characters (*piLength will be one if no selection) on the way
    // in, and indicate the bounding context of the tip on the way out.
    STDMETHOD (GetDataTipText) (long *piPos, long *piLength, BSTR *bstrText) PURE;

    //this method is only in the old shell, to take the place of the command routing
    //through the language filters that happens in the new shell.  This gets called after
    //EVERY command in the shell, so you'd better find a quick way of knowing whether
    //anything that you care about has changed.  I'm passing in the WndMsg params so
    //you can figure out what happened if you need to know that
    STDMETHOD (OnChangeEditorStatus)(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult) PURE;
};

#endif //ifndef __ACAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VsTypeInfo.h ===
//--------------------------------------------------------------------------
// Microsoft Visual Basic
//
// Copyright (c) 2000 Microsoft Corporation 
// All rights reserved
//
// VSTypeInfo.h
//
// Modified version of CComTypeInfoHolder that loads the typelib from the 
// HMODULE instead of from the registry. This allows the typelib of the interface 
// implemented by the class using this class, to not be registered.
// The index of the type library resource to load is passed
// in by the classes that use this class instead of the major ver they would 
// have otherwise passed to IDispatchImpl. ( Major ver is no longer needed 
// since the type lib is not loaded from the registry.)
//---------------------------------------------------------------------------
#ifndef __VSTYPEINFO_H__
#define __VSTYPEINFO_H__

class CVsTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wTypeLibRes;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
	};
	stringdispid* m_pMap;
	int m_nCount;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
	HRESULT GetTI(LCID lcid);
	HRESULT EnsureTI(LCID lcid)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		return hr;
	}

	// This function is called by the module on exit
	// It is registered through _pModule->AddTermFunc()
	static void __stdcall Cleanup(DWORD_PTR dw)
	{
		CVsTypeInfoHolder* p = (CVsTypeInfoHolder*) dw;
		if (p->m_pInfo != NULL)
			p->m_pInfo->Release();
		p->m_pInfo = NULL;
		delete [] p->m_pMap;
		p->m_pMap = NULL;
	}

	HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
	{
		HRESULT hRes = E_POINTER;
		if (pptinfo != NULL)
			hRes = GetTI(lcid, pptinfo);
		return hRes;
	}
	HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
		{
			for (int i=0; i<(int)cNames; i++)
			{
				int n = (int)ocslen(rgszNames[i]);
				for (int j=m_nCount-1; j>=0; j--)
				{
					if ((n == m_pMap[j].nLen) &&
						(memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
					{
						rgdispid[i] = m_pMap[j].id;
						break;
					}
				}
				if (j < 0)
				{
					hRes = m_pInfo->GetIDsOfNames(rgszNames + i, 1, &rgdispid[i]);
					if (FAILED(hRes))
						break;
				}
			}
		}
		return hRes;
	}

	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		return hRes;
	}
	HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
	{
		TYPEATTR* pta;
		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
		if (SUCCEEDED(hr))
		{
			m_nCount = pta->cFuncs;
			m_pMap = m_nCount == 0 ? 0 : new stringdispid[m_nCount];
			for (int i=0; i<m_nCount; i++)
			{
				FUNCDESC* pfd;
				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))
				{
					CComBSTR bstrName;
					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))
					{
						m_pMap[i].bstr.Attach(bstrName.Detach());
						m_pMap[i].nLen = SysStringLen(m_pMap[i].bstr);
						m_pMap[i].id = pfd->memid;
					}
					pTypeInfo->ReleaseFuncDesc(pfd);
				}
			}
			pTypeInfo->ReleaseTypeAttr(pta);
		}
		return S_OK;
	}
};


inline HRESULT CVsTypeInfoHolder::GetTI(LCID lcid)
{
	//If this assert occurs then most likely didn't initialize properly
	ATLASSERT(m_plibid != NULL && m_pguid != NULL);
	ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

	if (m_pInfo != NULL)
		return S_OK;
	EnterCriticalSection(&_pModule->m_csTypeInfoHolder);
	HRESULT hRes = E_FAIL;
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;

        // Changed only this block of code from the original CComTypeInfoHolder to load from HMODULE 
        // instead of the registry.
        wchar_t szTypeLibRes[21];
		CStringW strModuleFileName;
        wchar_t* szModuleFileName = strModuleFileName.GetBuffer(_MAX_PATH+1);
		if (szModuleFileName == NULL)
			return E_FAIL;

        HINSTANCE hInst = _pModule->GetModuleInstance();
        DWORD dwSize = GetModuleFileNameW(hInst, szModuleFileName, _MAX_PATH);
		if (dwSize >= _MAX_PATH)
		{
			strModuleFileName.ReleaseBuffer();
			szModuleFileName = strModuleFileName.GetBuffer(dwSize + 1);
			dwSize = GetModuleFileNameW(hInst, szModuleFileName, dwSize+1);
		}
		strModuleFileName.ReleaseBuffer();
		if (dwSize)
		{
			CStringW strTypeLibRes = strModuleFileName;
			// don't bother appending \1, as that's the default and just causes the 
			// system to have to look for two different files unnecessarily
			if( m_wTypeLibRes != 1 )
			{
				strTypeLibRes += L"\\";
				_itow(m_wTypeLibRes, szTypeLibRes, 10);
				strTypeLibRes += szTypeLibRes;
			}
	        hRes = LoadTypeLib(strTypeLibRes, &pTypeLib);
		}
        
		if (SUCCEEDED(hRes))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
			if (SUCCEEDED(hRes))
			{
				CComPtr<ITypeInfo> spInfo(spTypeInfo);
				CComPtr<ITypeInfo2> spTypeInfo2;
				if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
					spInfo = spTypeInfo2;

				LoadNameCache(spInfo);
				m_pInfo = spInfo.Detach();
			}
			pTypeLib->Release();
		}
        else
            ATLASSERT(FALSE);

	}
	LeaveCriticalSection(&_pModule->m_csTypeInfoHolder);
	_pModule->AddTermFunc(Cleanup, (DWORD_PTR)this);
	return hRes;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\VCUtilities.h ===
#pragma once

struct IVsSolutionBuildManager;
struct IVsStatusbar;
struct VCProjectEngine;
struct IVCTextEdit;
struct ILocalRegistry;
struct IUIHostLocale;
struct IVsInvisibleEditorManager;
struct IVsRegisterProjectTypes;
struct IVsRegisterEditors;
struct IAttributeGrammar;
struct IVsObjectManager;
struct IVsMonitorSelection;
struct IVsFileChangeEx;

class VCCodeModelService;

namespace VxDTE
{
	struct _DTE;
	struct ObjectExtenders;
}

using namespace VxDTE;

class CVCUtilityLibrary
{
private :

	static CComPtr<IServiceProvider> sm_spServiceProvider;

public :
 
	static void SafeExitProcess(void);

	static HRESULT SetSite(IServiceProvider * pIServiceProvider);

	// Non-cached QS
	//

	template<typename IService>	static HRESULT QueryService(const GUID & rguidService, IService ** ppIService)
	{
		FAILED_ASSERT_RETURN(E_UNEXPECTED, sm_spServiceProvider);
		return sm_spServiceProvider->QueryService(rguidService, __uuidof(IService), reinterpret_cast<void **>(ppIService));
	}

	template<typename IService>	static HRESULT QueryService(IService ** ppIService)
	{
		FAILED_ASSERT_RETURN(E_UNEXPECTED, sm_spServiceProvider);
		return sm_spServiceProvider->QueryService(GUID_NULL, __uuidof(IService), reinterpret_cast<void **>(ppIService));
	}

	// Cached QS
	//

	template<typename IService>	static HRESULT CachedQueryService(

		const GUID &		rsidService, 
		const IID *			piidService,
		CComPtr<IService> &	spIServiceCache, 
		IService **			ppIService)

	{
		HRESULT hr(S_OK);

		if (!spIServiceCache)
		{
			FAILED_ASSERT_RETURN(E_UNEXPECTED, sm_spServiceProvider);
			FAILED_ASSERT_RETURN_HR(sm_spServiceProvider->QueryService(
				rsidService, *piidService, reinterpret_cast<void**>(&spIServiceCache)));
		}

		return spIServiceCache.CopyTo(ppIService);
	}

	static HRESULT QueryService(VCProjectEngine ** ppVCProjectEngine);
	static HRESULT QueryService(IVsUIShellOpenDocument ** ppIVsUIShellOpenDocument);
	static HRESULT QueryService(IVsSolution ** ppIVsSolution);
	static HRESULT QueryService(IVsRunningDocumentTable ** ppIVsRunningDocumentTable);
	static HRESULT QueryService(IVsLinkedUndoTransactionManager ** ppIVsLinkedUndoTransactionManager);
	static HRESULT QueryService(ILocalRegistry ** ppILocalRegistry);
	static HRESULT QueryService(IVsShell ** ppIVsShell);
	static HRESULT QueryService(IVsUIShell ** ppIVsUIShell);
	static HRESULT QueryService(_DTE ** pp_DTE);
	static HRESULT QueryService(IUIHostLocale ** ppIUIHostLocale);
	static HRESULT QueryService(IVsTextManager ** ppIVsTextManager);
	static HRESULT QueryService(IVCTextEdit ** ppIVCTextEdit);
	static HRESULT QueryService(IVsSolutionBuildManager ** ppIVsSolutionBuildManager);
	static HRESULT QueryService(IVsInvisibleEditorManager ** ppIVsInvisibleEditorManager);
	static HRESULT QueryService(ObjectExtenders ** ppObjectExtenders);
	static HRESULT QueryService(VCCodeModelService ** ppVCCodeModelService);
	static HRESULT QueryService(IAttributeGrammar ** ppIAttributeGrammar);
	static HRESULT QueryService(IVsStatusbar ** ppIVsStatusbar);
	static HRESULT QueryService(IVsRegisterProjectTypes ** ppIVsRegisterProjectTypes);
	static HRESULT QueryService(IVsRegisterEditors ** ppIVsRegisterEditors);
	static HRESULT QueryService(IVsObjectManager ** ppIVsObjectManager);
	static HRESULT QueryService(IVsMonitorSelection ** ppIVsMonitorSelection);
	static HRESULT QueryService(IVsFileChangeEx ** ppIVsFileChangeEx);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\awiface.h ===
//
// CAppWizIFace
//
// AppWizard Interface to New/Insert Project dialog
//
// [davbr]
//

#ifndef _INCLUDE_APPWIZIFACE_H
#define _INCLUDE_APPWIZIFACE_H

// Size of m_pnPlatforms array in build system's CPromptDlg.  This represents the
//  maximum number of platforms we can display at once.
#define MAX_PLATFORMS 8

#include "utilctrl.h"
#include "projbld2.h"
#include <bldtypes.h>

enum {APPWIZTERMTYPE_CANCEL, APPWIZTERMTYPE_EMPTYPROJ, APPWIZTERMTYPE_APPWIZPROJ, APPWIZTERMTYPE_RERUNPROMPTDLG};

class CProjTypeList;

class CAppWizIFace
{
public:

	// Each time the new/insert project dialog pops up, call this before
	//  calling any of the other APIs.
	virtual void InitAppWiz(HWND hWnd, IServiceProvider *pSp);

	IServiceProvider *m_pSp ;
#if 0
	IBuildWizardX *m_pBldWizX ;
	IBuildPlatformsX *m_pBldPlatsX;
#endif

	void ReleasePtrs(void)
	{
#if 0
		if (m_pBldPlatsX)
		{
			m_pBldPlatsX->Release() ;
			m_pBldPlatsX = NULL ;
		}

		if (m_pBldWizX)
		{
			m_pBldWizX->Release() ;
			m_pBldWizX = NULL ;
		}
#endif

		if (m_pSp)
		{
			m_pSp->Release() ;
			m_pSp = NULL ;
		}
	}

	CAppWizIFace() 
	{ 
		m_pSp = NULL; 
#if 0
		m_pBldPlatsX = NULL ;
		m_pBldWizX = NULL ;
#endif
	}

	~CAppWizIFace() 
	{ 
		ReleasePtrs();
	}

	// This takes the projtype list box, and fills it with the standard appwiz
	//  project types.  Returns number of appwiz types.

	virtual int AddAppWizProjectTypesAtTop(CListBox* pList);
	virtual int AddAppWizProjectTypesAtTop(CProjTypeList* pList);

	// This takes the projtype list box, and fills it with any custom appwiz's it finds.
	//  It returns whether number of custom AppWizards
	virtual int AddCustomAppWizProjectTypesAtBottom(CListBox* pList);
	virtual int AddCustomAppWizProjectTypesAtBottom(CProjTypeList* pList);

	// Fills the platforms checklist with platforms supported by the indicated
	//  custom AppWizard
	virtual void FillPlatformsListFromCustomAppWizType
		(LPCTSTR szExtName, CCheckList* pChklstPlatforms);
	virtual void FillPlatformsListFromCustomAppWizType
		(LPCTSTR szExtName, CStringArray* pChklstPlatforms);

	// Fills the platforms checklist with platforms supported by the indicated
	//  AppWizard type (its index into the project type combo box).
	virtual void FillPlatformsListFromAppWizType
		(int nProjType, CCheckList* pChklstPlatforms);
	virtual void FillPlatformsListFromAppWizType
		(int nProjType, CStringArray* pChklstPlatforms);

	// After the user clicks "Create" with an appwiz type selected, but before
	//  you call RunAppWizSteps, call this and make sure it returns TRUE.  Otherwise,
	//  don't dismiss new/insert project.
	virtual BOOL CanRunAppWizSteps(LPCTSTR szProj, LPCTSTR szProjDir, LPCTSTR szExtName);

	// This runs the wizard.  It returns one of the APPWIZTERMTYPE_ values.
	// TODO: These values are currently defined in ide\include\appwzshd.h.  They
	//  need to moved here after the build system starts using this interface and
	//  no longer uses appwzshd.h.
	virtual int RunAppWizSteps();

	// If RunAppWizSteps was successful, the caller should create & pass a new HBUILDER if
	//  a new workspace is being created, otherwise the current HBUILDER if this is
	//  from insert project.  This function takes the HBUILDER and adds the AppWizard
	//  targets.
	virtual void AddAppWizTargets(HBUILDER hBld);

	virtual BOOL GetAppWizDialog( CString &strDialog );

	// Call this so AppWizard deallocates stuff.  If you run appwiz steps, call after
	//  AddAppWizTargets.  Otherwise, call after the new/insert project dialog is
	//  dismissed.
	virtual void ExitAppWiz();
};	


#define GETAPPWIZIFACE  (MAKEINTRESOURCE(1))
typedef CAppWizIFace* (WINAPI* PGETAPPWIZIFACE)();

extern CAppWizIFace g_AppWizIFace;

#endif // _INCLUDE_APPWIZIFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\acguid.h ===
// File: acguid.h
// This file defines the guids necessary for auto complete.

DEFINE_GUID(IID_IVsCompletionSet, 
            0x14309FF0,0xBBEC,0x11d0,0xA8,0xD7,0x00,0xA0,0xC9,0x21,0xA4,0xD2);


DEFINE_GUID(IID_IVsTipWindow,
            0x14309FF1,0xBBEC,0x11d0,0xA8,0xD7,0x00,0xA0,0xC9,0x21,0xA4,0xD2);


DEFINE_GUID(IID_IVsMethodTipWindow, 
            0x261A5570,0xC649,0x11d0,0xA8,0xDF,0x00,0xA0,0xC9,0x21,0xA4,0xD2);


DEFINE_GUID(IID_IVsMethodData,
            0x261A5571,0xC649,0x11d0,0xA8,0xDF,0x00,0xA0,0xC9,0x21,0xA4,0xD2);


DEFINE_GUID(IID_IVsTextView,
            0xB5E23370,0xC309,0x11d0,0xA8,0xDB,0x00,0xA0,0xC9,0x21,0xA4,0xD2);

DEFINE_GUID(IID_IVsTextViewFilter, 
            0xdee4dd21, 0x9031, 0x11d0, 0xa8, 0xac, 0x00, 0xa0, 0xc9, 0x21, 0xa4, 0xd2);

// {D0C970E0-DEE2-11d1-A5A5-00A0C91F381B}
DEFINE_GUID(IID_IVcCodeSense, 
			0xd0c970e0, 0xdee2, 0x11d1, 0xa5, 0xa5, 0x0, 0xa0, 0xc9, 0x1f, 0x38, 0x1b);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\include\vctimeclasses.h ===
// (DianeMe) This was the MFC time manipulation stuff
// Now it has been purged of all other MFC influences and is a stand alone entity.
// NOTE: exceptions are no longer thrown on various errors...

#pragma once

#include <time.h>
#include <vcstring.h>

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

class CVCTime;                          // absolute time/date
class CVCTimeSpan;

#ifndef _countof
// determine number of elements in an array (not bytes)
#define _countof(array) (sizeof(array)/sizeof(array[0]))
#endif

/////////////////////////////////////////////////////////////////////////////

class CVCTimeSpan
{
public:

// Constructors
	CVCTimeSpan() {}
	CVCTimeSpan(__time64_t time) { m_timeSpan = time; }
	CVCTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
 	{ m_timeSpan = nSecs + 60* (nMins + 60* (nHours + __int64(24) * lDays)); }

	CVCTimeSpan(const CVCTimeSpan& timeSpanSrc)	{ m_timeSpan = timeSpanSrc.m_timeSpan; }
	const CVCTimeSpan& operator=(const CVCTimeSpan& timeSpanSrc)
	{ m_timeSpan = timeSpanSrc.m_timeSpan; return *this; }

// Attributes
	// extract parts
	LONG GetDays() const	{ _ASSERT(m_timeSpan <= UINT_MAX); return (LONG) (m_timeSpan / (24*3600L)); }
	LONG GetTotalHours() const	{ _ASSERT(m_timeSpan <= UINT_MAX); return (LONG) (m_timeSpan/3600); }
	int GetHours() const	{ return (int)(GetTotalHours() - GetDays()*24); }
	LONG GetTotalMinutes() const	{ _ASSERT(m_timeSpan <= UINT_MAX); return (LONG) (m_timeSpan/60); }
	int GetMinutes() const	{ return (int)(GetTotalMinutes() - GetTotalHours()*60); }
	LONG GetTotalSeconds() const	{ _ASSERT(m_timeSpan <= UINT_MAX); return (LONG) m_timeSpan; }
	int GetSeconds() const	{ return (int)(GetTotalSeconds() - GetTotalMinutes()*60); }

	__int64 GetDays64() const	{ return m_timeSpan / (24*3600L); }
	__int64 GetTotalHours64() const	{ return m_timeSpan/3600; }
	__int64 GetHours64() const	{ return (GetTotalHours64() - GetDays64()*24); }
	__int64 GetTotalMinutes64() const	{ return m_timeSpan/60; }
	__int64 GetMinutes64() const	{ return (GetTotalMinutes64() - GetTotalHours64()*60); }
	__int64 GetTotalSeconds64() const	{ return m_timeSpan; }
	__int64 GetSeconds64() const	{ return (int)(GetTotalSeconds64() - GetTotalMinutes64()*60); }

// Operations
	// time math
	CVCTimeSpan operator-(CVCTimeSpan timeSpan) const	{ return CVCTimeSpan(m_timeSpan - timeSpan.m_timeSpan); }
	CVCTimeSpan operator+(CVCTimeSpan timeSpan) const	{ return CVCTimeSpan(m_timeSpan + timeSpan.m_timeSpan); }
	const CVCTimeSpan& operator+=(CVCTimeSpan timeSpan)	{ m_timeSpan += timeSpan.m_timeSpan; return *this; }
	const CVCTimeSpan& operator-=(CVCTimeSpan timeSpan)	{ m_timeSpan -= timeSpan.m_timeSpan; return *this; }
	BOOL operator==(CVCTimeSpan timeSpan) const	{ return m_timeSpan == timeSpan.m_timeSpan; }
	BOOL operator!=(CVCTimeSpan timeSpan) const	{ return m_timeSpan != timeSpan.m_timeSpan; }
	BOOL operator<(CVCTimeSpan timeSpan) const	{ return m_timeSpan < timeSpan.m_timeSpan; }
	BOOL operator>(CVCTimeSpan timeSpan) const	{ return m_timeSpan > timeSpan.m_timeSpan; }
	BOOL operator<=(CVCTimeSpan timeSpan) const	{ return m_timeSpan <= timeSpan.m_timeSpan; }
	BOOL operator>=(CVCTimeSpan timeSpan) const	{ return m_timeSpan >= timeSpan.m_timeSpan; }

#ifdef _UNICODE
	// for compatibility with MFC 3.x
	CVCString Format(LPCSTR pFormat) const;
#endif
	CVCString Format(LPCTSTR pFormat) const;
	CVCString Format(UINT nID) const;

private:
	__time64_t m_timeSpan;
	friend class CVCTime;
};

class CVCTime
{
public:

// Constructors
	static CVCTime PASCAL GetCurrentTime();

	CVCTime() {}
	CVCTime(__time64_t time64)	{ m_time = time64; }
	CVCTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec,
		int nDST = -1);
	CVCTime(WORD wDosDate, WORD wDosTime, int nDST = -1);
	CVCTime(const CVCTime& timeSrc)	{ m_time = timeSrc.m_time; }

	CVCTime(const SYSTEMTIME& sysTime, int nDST = -1);
	CVCTime(const FILETIME& fileTime, int nDST = -1);
	const CVCTime& operator=(const CVCTime& timeSrc) { m_time = timeSrc.m_time; return *this; }

// Attributes
	struct tm* GetGmtTm(struct tm* ptm = NULL) const;
	struct tm* GetLocalTm(struct tm* ptm = NULL) const;
	BOOL GetAsSystemTime(SYSTEMTIME& timeDest) const;

	time_t GetTime() const 	{ _ASSERT(m_time <= UINT_MAX); return time_t(m_time); }
	__time64_t GetTime64() const 	{ return m_time; }
	int GetYear() const 	{ return (GetLocalTm(NULL)->tm_year) + 1900; }
	int GetMonth() const	{ return GetLocalTm(NULL)->tm_mon + 1; }       // month of year (1 = Jan)
	int GetDay() const	{ return GetLocalTm(NULL)->tm_mday; }         // day of month
	int GetHour() const	{ return GetLocalTm(NULL)->tm_hour; }
	int GetMinute() const 	{ return GetLocalTm(NULL)->tm_min; }
	int GetSecond() const	{ return GetLocalTm(NULL)->tm_sec; }
	int GetDayOfWeek() const	{ return GetLocalTm(NULL)->tm_wday + 1; }   // 1=Sun, 2=Mon, ..., 7=Sat

// Operations
	// time math
	CVCTimeSpan operator-(CVCTime time) const	{ return CVCTimeSpan(m_time - time.m_time); }
	CVCTime operator-(CVCTimeSpan timeSpan) const	{ return CVCTime(m_time - timeSpan.m_timeSpan); }
	CVCTime operator+(CVCTimeSpan timeSpan) const	{ return CVCTime(m_time + timeSpan.m_timeSpan); }
	const CVCTime& operator+=(CVCTimeSpan timeSpan)	{ m_time += timeSpan.m_timeSpan; return *this; }
	const CVCTime& operator-=(CVCTimeSpan timeSpan)	{ m_time -= timeSpan.m_timeSpan; return *this; }
	BOOL operator==(CVCTime time) const	{ return m_time == time.m_time; }
	BOOL operator!=(CVCTime time) const	{ return m_time != time.m_time; }
	BOOL operator<(CVCTime time) const	{ return m_time < time.m_time; }
	BOOL operator>(CVCTime time) const	{ return m_time > time.m_time; }
	BOOL operator<=(CVCTime time) const	{ return m_time <= time.m_time; }
	BOOL operator>=(CVCTime time) const	{ return m_time >= time.m_time; }

	// formatting using "C" strftime
	CVCString Format(LPCTSTR pFormat) const;
	CVCString FormatGmt(LPCTSTR pFormat) const;
	CVCString Format(UINT nFormatID) const;
	CVCString FormatGmt(UINT nFormatID) const;

#ifdef _UNICODE
	// for compatibility with MFC 3.x
	CVCString Format(LPCSTR pFormat) const;
	CVCString FormatGmt(LPCSTR pFormat) const;
#endif

private:
	__time64_t m_time;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\bineguid.h ===
// {25834150-CD7E-11d0-92DF-00A0C9138C45}
DEFINE_GUID(GUID_BinEdit, 
0x25834150, 0xcd7e, 0x11d0, 0x92, 0xdf, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x45);

// Interface ID for Binary editor property
// {D04EE540-E73E-11d0-994E-00A0C91BC8E5}
DEFINE_GUID(CLSID_BinaryFilePropertyPage, 
0xd04ee540, 0xe73e, 0x11d0, 0x99, 0x4e, 0x0, 0xa0, 0xc9, 0x1b, 0xc8, 0xe5);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\bldmarshal.h ===
#pragma once

// this handy, dandy template helps keep track of marshalling for you

template <class PrimaryIface>
class CBldMarshaller
{
public:
	CBldMarshaller() : m_pStream(NULL) {}
	~CBldMarshaller()
	{
		Clear();
	}
	HRESULT Init(PrimaryIface* pClass)
	{
		Clear();	// in case of reuse
		m_spClass = pClass;
		if (pClass == NULL || m_spClass == NULL)
			return E_UNEXPECTED;
		return AtlMarshalPtrInProc((IUnknown *)pClass, __uuidof(PrimaryIface), &m_pStream);
	}
	HRESULT Clear()
	{
		HRESULT hr = S_OK;
		if (m_pStream != NULL)
			hr = AtlFreeMarshalStream(m_pStream);
		m_pStream = NULL;
		m_spClass.Release();
		return hr;
	}
	HRESULT UnmarshalPtr(PrimaryIface** ppClass)
	{
		if (ppClass == NULL)
			return E_POINTER;
		*ppClass = NULL;
		return AtlUnmarshalPtr(m_pStream, __uuidof(PrimaryIface), (IUnknown **)ppClass);
	}
	BOOL IsInit()
	{
		return (m_pStream != NULL);
	}
	HRESULT GetPtr(PrimaryIface** ppClass)	// call this only inproc
	{
		return m_spClass.CopyTo(ppClass);
	}
		

protected:
	IStream* m_pStream;
	CComPtr<PrimaryIface> m_spClass;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\bldtypes.h ===
#ifndef __BLDTYPES_H__
#define __BLDTYPES_H__
interface IBuildProject;		// Defined in pkgs\include\auto\bldauto.h, used in // IBuildWizard::GetAutoProject.
interface IPkgProject;

#define HPROJECT DWORD_PTR
#define HCONFIGURATION DWORD_PTR
#define HFILESET DWORD_PTR
#define HBLDFILE DWORD_PTR
#define HPROJDEP DWORD_PTR
#define HFOLDER DWORD_PTR

#define ACTIVE_BUILDER	(HPROJECT)NULL
#define ACTIVE_PROJECT	(HPROJECT)NULL
#define ACTIVE_TARGET	(HCONFIGURATION)NULL
#define ACTIVE_CONFIG	(HCONFIGURATION)NULL
#define ACTIVE_FILESET	(HFILESET)NULL

#define NO_BUILDER		(HPROJECT)NULL
#define NO_PROJECT		(HPROJECT)NULL
#define NO_TARGET		(HCONFIGURATION)NULL
#define NO_CONFIG		(HCONFIGURATION)NULL
#define NO_FILESET		(HFILESET)NULL
#define NO_FILE			(HBLDFILE)NULL
#define NO_PROJDEP		(HPROJDEP)NULL
#define NO_FOLDER		(HFOLDER)NULL

#define HBUILDER HPROJECT
#define HBLDTARGET HCONFIGURATION
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\clvwapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	CLVWAPI.H
//		ClassView package interface declarations.

#ifndef __CLVWAPI_H__
#define __CLVWAPI_H__

#include <atlbase.h>
#include "ncparex.h"  // for IINST mostly

class IWorkspaceDO_Internal;	// defined in do.idl

__interface IObjectGallery;		// #include <galapi.h> if actually need to work with this
__interface IClassView;
__interface IClassProvider;
__interface IClassProviderFactory;

// char flags
#define CHAR_UNKNOWN			0x0001
#define	CHAR_COMMA				0x0002
#define CHAR_DOT				0x0004
#define CHAR_ARROW				0x0008
#define	CHAR_COLONCOLON			0x0010
#define	CHAR_OPENPAREN			0x0020
#define CHAR_CLOSEPAREN			0x0040
#define	CHAR_CRLF				0x0080
#define CHAR_CARETMOVE			0x0100
#define	CHAR_DELETED			0x0200
#define CHAR_LEFTANGLE			0x0400
#define CHAR_RIGHTANGLE			0x0800
#define CHAR_TYPE_INFO			0x1000
#define CHAR_ATTRIBUTE			0x2000

// command flags
#define CMD_NONE				0x0000
#define	CMD_TYPE_INFO			0x1000
#define CMD_PARAMETER_INFO		0x2000
#define CMD_COMPLETE_WORD		0x4000
#define CMD_AUTO_COMPLETE		0x8000
#define CMD_TYPE_INFO_DATATIP   0x0100  // VC7 treats hover as a data tip
#define CMD_PARAMETER_INFO_REINVOKE 0x0200  // for nested function calls

// comment location flags
#define COMMENTS_NONE           0x0000
#define COMMENTS_INDECLARATION  0x0001
#define COMMENTS_INDEFINITION   0x0002

typedef IClassView* LPCLASSVIEW;

struct LINE_COLUMN_POS {
	ULONG  m_iLine;
	ULONG  m_iIndex;
};

struct STATE_INFO {
	CComBSTR			m_bstrClass;
	CComBSTR			m_bstrCurClass;
	CComBSTR			m_bstrIdentifier;
	CComBSTR			m_bstrFileName;
	CComBSTR			m_bstrAttrArgument;
	CComBSTR			m_bstrAttrArgVal;
	ULONG				m_flagsCur;
	ULONG				m_flagsCmd;
	ULONG				m_iStreamIndexAtCursor; // document location
	ULONG				m_iCaretIndex; // This is within the buffer
	ULONG				m_iFECaretIndex; // This is within the buffer
	ULONG				m_iAnchorIndex;	// This is within the buffer
	ULONG				m_iAnchorPosition;
	ULONG				m_iFuncStart;
	LINE_COLUMN_POS 	m_Anchor; 
	LINE_COLUMN_POS		m_StartOfIdentifier;
	LINE_COLUMN_POS		m_StartOfParameters;
	LINE_COLUMN_POS		m_CurrentCursor;
	IINST				m_iinstCurClass;
	int					m_iCurParameter;
	ULONG				m_cbCurEditBuffer;
	ULONG				m_cbMaxEditBuffer;	
	BOOL				m_fInUse;
	BOOL				m_fForced;
	BOOL				m_fRecheck;
	WCHAR				*m_pwchUnicodeEditBuffer;	// WIDE version of m_pchEditBuffer
	BOOL				m_fComPlus;
	BOOL				m_fPassInlineClassParentIinst;
};


/////////////////////////////////////////////////////////////////////////////
// IClassView
class CVCCMLocation;
#undef  INTERFACE
#define INTERFACE IClassView
DECLARE_INTERFACE_(IClassView, IUnknown)
{
	// IClassView methods

	STDMETHOD(GetCurrentSelInfo)(char **psz, BYTE *ptyp, USHORT *patr) PURE;
	STDMETHOD(GetCurrentConfiguration)(BSTR* pbstrConfig) PURE;
	STDMETHOD(RegisterProviderFactory)(IClassProviderFactory* pClassProviderFactory) PURE;

	// AutoComplete methods
	STDMETHOD(IdleInitializeAutoCompletionManager)(INT count) PURE;
	STDMETHOD(DoAutoComplete) (ULONG cmdFlags, ULONG charFlags, LPCTSTR szIdentifier, 
		ULONG ichInsert, ULONG ilineInsert, ULONG ichRealInsert, ULONG ilineRealInsert, BOOL fJingle) PURE;
	STDMETHOD(OnChangeInTextEditor) (ULONG charFlags, LPCTSTR pszString, ULONG ichInsert, ULONG ilineInsert) PURE;
	STDMETHOD(CanShowQuickInfo) (BOOL *pfShow) PURE;
	STDMETHOD(RetrieveACInfo) (int *iBufferIndex, STATE_INFO **ppsi, BscEx** ppBscEx) PURE;
	STDMETHOD(OnTextViewDestroy) () PURE;
	STDMETHOD(GetCommentForIinst) (IINST iinst, BSTR *pbstrComment) PURE;
	STDMETHOD(GetCommentLocationForIinst)(IINST iinst, INT* pnCommentLoc, 
		CVCCMLocation *pvccmLocation, BOOL* pbEolComment) PURE;
	STDMETHOD(UpdateCurrentLocationInfo)(LPVOID pVoid, LPCTSTR szFileName, LONG iline, ULONG ich, BOOL fSyncClassView) PURE;

};

/////////////////////////////////////////////////////////////////////////////
// IClassProviderFactory

#undef  INTERFACE
#define INTERFACE IClassProviderFactory
DECLARE_INTERFACE_(IClassProviderFactory, IUnknown)
{
	STDMETHOD(GetClassProvider)(THIS_ VOID *pvBsc, IINST iinst,
		IClassProvider** ppClassProvider) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IClassProvider

#undef  INTERFACE
#define INTERFACE IClassProvider
DECLARE_INTERFACE_(IClassProvider, IUnknown)
{
	STDMETHOD(GetInterfaceInfo)(THIS_ IINST iisnt, UINT iInterface,
		LPCTSTR* pszInterfaceName) PURE;
	STDMETHOD(GetMemberInfo)(THIS_ IINST iinst, LPCTSTR* pszInterfaceName) PURE;
	STDMETHOD(CreateMember)(THIS_ LPCTSTR szMember, UINT ichClassName, UINT nAccess,
		LPCTSTR szInterfaceName, IObjectGallery* pObjectGallery) PURE;
	STDMETHOD(UpdateClass)() PURE;
};


#endif	// __CLVWAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\clvwguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	CLVWGUID.H
//		ClassView package interface ids.

// Interface ID for Class View
DEFINE_GUID(IID_IClassView, 
	0xee099ce0, 0x9c05, 0x11ce, 0xbb, 0x53, 0x0, 0xaa, 0x0, 0x3d, 0xa7, 0xad);

DEFINE_GUID(IID_IClassProvider, 
	0xca4423c0, 0x2fd0, 0x11cf, 0x81, 0xf2, 0x0, 0xaa, 0x0, 0x6c, 0x1d, 0x8);

DEFINE_GUID(IID_IClassProviderFactory, 
	0xddcf7f20, 0x2fd0, 0x11cf, 0x81, 0xf2, 0x0, 0xaa, 0x0, 0x6c, 0x1d, 0x8);

// {30FD2621-21AC-11d2-B4EA-00A0C915070C}
DEFINE_GUID(IID_ICodeManager, 
	0x30fd2621, 0x21ac, 0x11d2, 0xb4, 0xea, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// {D26C1B61-1833-11d2-B4E1-00A0C915070C}
DEFINE_GUID(IID_IWizardService, 
	0xd26c1b61, 0x1833, 0x11d2, 0xb4, 0xe1, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// {FA426E3A-FFF1-11d1-B4D7-00A0C915070C}
DEFINE_GUID(IID_IDOStrings, 
0xfa426e3a, 0xfff1, 0x11d1, 0xb4, 0xd7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

DEFINE_GUID(IID_IWizardBar, 
0x1909ad40, 0x5fce, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);

DEFINE_GUID(IID_IWizBarClntLang, 
0xcc552ba2, 0xa29e, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);

DEFINE_GUID(IID_IWizBarClntEditor, 
0xcc552ba1, 0xa29e, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);

// guid for collection of wiz bar client editor interfaces
DEFINE_GUID(IID_IWizBarClntEditors, 
0x42d8fdc0, 0xb946, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);

// guid for provider of wiz bar client language interface
DEFINE_GUID(IID_IWizBarClntLangProvider, 
0x92a40220, 0xde47, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\bldguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	BLDGUID.H
//		Build package interface ids.
// {3284355B-AA45-11d2-835C-00C04F796961}
DEFINE_GUID(GUID_ProjGeneralOptions, 
	0x3284355b, 0xaa45, 0x11d2, 0x83, 0x5c, 0x0, 0xc0, 0x4f, 0x79, 0x69, 0x61);

// {3284355C-AA45-11d2-835C-00C04F796961}
DEFINE_GUID(GUID_ProjDirectories, 
0x3284355c, 0xaa45, 0x11d2, 0x83, 0x5c, 0x0, 0xc0, 0x4f, 0x79, 0x69, 0x61);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\commapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	COMMAPI.H
//		Common package interfaces
//
//  Interfaces that may be implemented by more than one package
//   should be declared here.  For example, ICommandProvider is
//   an interface that any package who provides dynamic (transient) commands
//   determined at run-time should implement.

#ifndef __COMMAPI_H__
#define __COMMAPI_H__


/////////////////////////////////////////////////////////////////////////////
// ICommandProvider interface
// A package who provides dynamic (transient) commands (commands not determined
//  until run-time) must implement this interface and return it
//  in response to a call to CPackage::GetCommandProvider.

// DevAut1 is an example of a package which implements this, since it
//  provides commands from macros & Add-Ins, which are unknown until run-time

#undef  INTERFACE
#define INTERFACE ICommandProvider

DECLARE_INTERFACE_(ICommandProvider, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ICommandProvider methods

	// This is called when the shell is persisting the command bars into the
	//  registry, and gives the package a chance to save custom information
	//  alongside the command bar button.
	// This function returns the size of the extra information that needs
	//  to be saved to uniquely identify this command id. If pData is
	//  non-NULL, then the information should be placed into pData,
	//  and pData can be assumed to be large enough to accommodate all the data.
	// The shell calls this function once to ascertain the size of memory block
	//  required, and then again with a memory block of the correct (or larger) size.
	// If the package does not want to save special information for this command
	//  (because it is not transient, for example), then it can return 0, and
	//  the shell will do the default saving of the toolbar.
	STDMETHOD_(WORD, SaveCommand)(WORD nId, LPVOID pData) PURE;

	// Given a block of data previously returned by SaveCommand, this function
	//  converts the block of data to a command id which is valid for this
	//  session of Developer Studio.
	// The shell will be smart enough to know not to call this function for
	//  those commands which the ICommandProvider-implementation did not provide
	//  extra info via SaveCommand.
	STDMETHOD_(WORD, LoadCommand)(LPVOID pData, DWORD dwSize) PURE;

	// This function returns the glyph index and bitmap for a given id and
	//  large/small state.  The shell may call this for commands which the
	//  ICommandProvider-implementation did not provide extra info via
	//  SaveCommand.  For example, if the user right clicks on a command bar,
	//  the shell needs to know if it should enable the menu item to reset
	//  the glyph to the default--thus, it will call this to see if the package
	//  has a default glyph to provide.
	// If the package does not have a default glyph to provide, it may return
	//  NULL, and the shell will deal with it in a mature fashion.
	STDMETHOD_(HBITMAP, GetBitmap)(WORD nId, BOOL bLarge, LPDWORD pnGlyph) PURE;
};

#endif //__COMMAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\clwzguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	CLWZGUID.H
//		Class Wizard package interface ids.

// Interface ID for ClassWizard {1AA05AA9-42AE-11d2-8AF1-00C04F7956C9}
DEFINE_GUID(IID_IClassWizard, 
	0x1aa05aa9, 0x42ae, 0x11d2, 0x8a, 0xf1, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for IChangeClasses {E3B38FE2-F9DF-11CF-9916-00AA006C28B3}
DEFINE_GUID(IID_IChangeClasses, 
	0xe3b38fe2, 0xf9df, 0x11cf, 0x99, 0x16, 0x0, 0xaa, 0x0, 0x6c, 0x28, 0xb3);

// Interface ID for ICreateClasses2 {6FF07122-02BD-11D0-A900-00A0C915070C}
DEFINE_GUID(IID_ICreateClasses2, 
0x6ff07122, 0x2bd, 0x11d0, 0xa9, 0x0, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\codemgrapi.h ===
#ifndef _CODEMGRAPI_
#define _CODEMGRAPI_

// This file contains the interfaces that make up the Code Manager.  The Code Manager is
// intended to act as a support layer for code manipulation for DOs.  Those elements that 
// are shared between the Wizard Model and the DO support style of code manager are in
// mgrsharedapi.h

#include <sharedmgrapi.h>

// Conventions:
//    Passing NULL in the HPROJECT parameter will result in the selected project being used.  
//       The selected project is the one seen by the code manager -- this is the active project 
//       unless otherwise set by someone calling into the code manager.
//    If you see a method with the same name in two interfaces, it takes the same 
//       parameters and performs the same action.  (Some methods in ICodeMgrSupport_Internal 
//       take slightly different parameters, but that interface isn't intended for clients 
//       of the code manager to use.)
//  Parameter explanations:
//    iinst - the IINST for the thing being changed
//    instParent - the IINST for the object's parent (ex: class IINST when modifying an 
//       attribute)
//    iinstClass - the IINST for a class or class-like object (ex: class IINST when 
//       modifying a base class)
//    iinstObject - the IINST for the function/enum/whatever-makes-sense-here when 
//       modifying a parameter
//    nWhichPart - which part to modify.  typically, dxWizDefinition, dxWizDeclaration, or 
//       both (could also eventually include dxWizMemberDefinitions for classes later).
//    nCommentOrDeletePart - OR in the flag(s) you want hard deletes for (instead of 
//       getting it commented out).  Pass 0 if you want all affected parts commented out.
//    nFileType - the type of file desired.  Supported flags: dxWizDefinition, 
//       dxWizDeclaration, dxWizMemberDefinitions, dxWizMemberDeclarations.  Can be OR'ed 
//       together when the returned value is a collection.
//    nHintType - placement hints for various methods.  Flags can be OR'ed together.  
//       Frequently (but not always) accompanied by nHintName that can provide further info 
//       for one of the specified hint types.  Legal values here vary by the method taking
//       this parameter.
//    nHintName - placement hint help for various methods.  Provides extra information 
//       needed by some hint types
//    nPathType - type of path. Legal values: dxWizFilePathDontCare, dxWizFilePathAbsolute,
//       dxWizFilePathRelative, dxWizFilePathSimple
//    nMemberKind - type of object.  Examples: dxWizClass, dxWizFunction.  Not to be 
//       confused with the object's type (like "int")
//    nParseLanguage - language to use.  Legal values: dxWizIDL (also covers ODL) and 
//       dxWizCPP
//    nParseType - type of parsing to do.  dxWizName causes keywords (like 'afx_msg' or 
//       'virtual') to be stripped out.  Default is to strip out both keywords and default 
//       parameter values.

interface ICodeManager;		// entry point to the code manager support layer for DOs
interface ICodeMgrBscItems;	// collection of IBscPersistentItem objects.  Used when a
							// collection of IINSTs needs to be returned from the code 
							// manager to a DO

// Transaction management
interface IDOTransaction;			// basic transaction
interface IDOTransaction_Internal;	// transaction with all the goodies to do code modification
interface ITransMgrResourceHelper;	// 'temporary' stand-in for transacted resource DOs
interface ITransMgrProjHelper;		// allows transacted addition of files to project
interface IDOTransactionParticipant;// 'smart' participant in transaction (like the text editor, etc.)

// Text editor services
interface ICodeMgrTextEditor;		// the text editor the code manager uses
interface ICodeMgrTextEditorCommand; // an individual command for the text editor
interface ICodeMgrLexer;				// the lexer that goes with a particular text file/language

// parser language to use (values for nParseLanguage)
#define dxWizCPP                0x01		// C/C++
#define dxWizIDL                0x02        // IDL/ODL
#define dxWizAllLanguages       0xFF		// all languages

/////////////////////////////////////////////////////////////////////////////
// ICodeManager
//   This is the primary interface on the transaction manager backend.
//

#undef  INTERFACE
#define INTERFACE ICodeManager
DECLARE_INTERFACE_(ICodeManager, IUnknown)
{
	// general services
	STDMETHOD(GetHelper)(REFIID riidInterface, IUnknown** ppvInterface) PURE;
	STDMETHOD(GetCodeManagerLocation)(BSTR* pbstrCodeMgrLoc) PURE;	// location of code templates
	STDMETHOD(GotoTextEditorLocation)(BSTR bstrFilename, ULONG uLineNumber, ULONG uColumnNumber) PURE;
	STDMETHOD(GotoAnsiTextEditorLocation)(LPCTSTR lpszFilename, ULONG uLineNumber, ULONG uColumnNumber) PURE;
		// Goto(Ansi)TextEditorLocation opens the specified file to the specified location in the text editor
		// uColumnNumber = -1 means highlight the entire line
	STDMETHOD(GotoFileClassMember)(BSTR bstrFilename, BSTR bstrClassName, BSTR bstrMemberName) PURE;
	STDMETHOD(GotoAnsiFileClassMember)(LPCTSTR lpszFilename, LPCTSTR lpszClassName, LPCTSTR lpszMemberName) PURE;
		// GetTextEditor()'s bForceOpen needs to be TRUE in order to get global undo to work on the file,
		// so you are best off setting it to the same value as bWriteable unless you specifically KNOW
		// you don't want undo to work on the file (such as the .clw file).  bForceOpen is pretty much
		// ignored for files that you are NOT opening for write.
	STDMETHOD(GetTextEditor)(BOOL bWriteable, BOOL bForceOpen, BSTR bstrFilename, 
		ICodeMgrTextEditor** ppvTextEditor) PURE;
	STDMETHOD(get_LexerForLanguage)(short nParseLanguage, ICodeMgrLexer** ppvLexer) PURE;

	// project services
	STDMETHOD(get_ProjectName)(HPROJECT hProject, BSTR* pbstrProjName) PURE;
	STDMETHOD(get_SelectedProject)(HPROJECT* phProject) PURE;
	STDMETHOD(put_SelectedProject)(HPROJECT hProject) PURE;
	STDMETHOD(IsObjectInProject)(HPROJECT hProject, long nObjectType, short nParseLanguage, BSTR bstrObjectName, 
		long* pnActualType) PURE;
	STDMETHOD(get_ProjectUseOfMFC)(HPROJECT hProject, UseOfMFC* pUseOfMFC) PURE;
	STDMETHOD(get_ProjectIncludePath)(HPROJECT hProject, BSTR bstrTool, IDOStrings** ppvIncludePath) PURE;

	// services for specific objects
		// GotoDialogEditorLocation allows you to open the dialog editor given either the dialog ID
		// or the dialog class IINST
	STDMETHOD(GotoDialogEditorLocation)(HPROJECT hProject, IINST iinstClass, BSTR bstrDialogID) PURE;
	STDMETHOD(get_FileName)(IINST iinst, long nFileType, short nPathType, BSTR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(IINST iinst, long nFileType, short nPathType, IDOStrings** ppvFiles) PURE;
	STDMETHOD(GetDerivedClasses)(short nParseLanguage, HPROJECT hProject, BSTR bstrBaseClass, 
		BOOL bImmediateOnly, ICodeMgrBscItems** ppvClasses) PURE;
		// GetInclude: nFileType of dxWizProjectInclude gives you back the project include  
		// file (bstrClassName ignored).  nFileType of dxWizFileInclude is currently 
		// unimplemented.  All other values of nFileType will result in an attempt to find 
		// the header file where bstrClassName is defined.  If it is defined in an 
		// implementation file, we don't return any filename.
	STDMETHOD(GetInclude)(HPROJECT hProject, long nFileType, BSTR bstrClassName, BOOL bMakeRelative,  
		BSTR bstrRelativeWhere, BSTR* pbstrIncludeFile) PURE;
	STDMETHOD(BreakUpParameter)(IINST iinstParent, BSTR bstrFullParam, BOOL bDoErrorChecks,
		BSTR* pbstrParamType, BSTR* pbstParamName, BSTR* pbstrParamDefault, 
		BSTR* pbstrParamComments, BSTR* pbstrParamAttribs) PURE;

	// ActiveX associations
	//		Usage: 
	//			iinstToAssoc = the IINST you're trying to get the matching elements for
	//			nAssociationMajorType = the basic type of association you are trying to do
	//				dxActiveXMatch - want the elements that match via ActiveX association
	//				dxActiveXNone - (use only with GetAssociatedFunctions) want the elements
	//					that do NOT match any ActiveX association
	//			nAssociationMinorType = the type of object you want back for this association
	//				dxWizClass (use with IDL/ODL IINST) to get a collection of classes
	//				dxWizInterface (use with C++ IINST) to get a collection of interfaces/dispinterfaces
	//				dxWizCoclass (use with C++ IINST) to get a collection of coclasses
	//				dxWizLibrary (IINST optional) to get the library name or file
	//			nPresentHow = how you want the information presented (GetAssociationName only)
	//				dxWizName - want the name of the associated element
	//				dxWizFilePath* - want the name of the file the associated element is in
	//	For example, to determine what classes implement a particular interface, you would call
	//		GetAssociations(hProject, iinstIface, dxWizActiveXMatch, dxWizClass, &ppvAssoc)
	//		where hProject is the project your IINST is in (pass dxWizSelectedProject for 
	//		selected project), iinstIFace is the IINST of the interface, and ppvAssoc is the 
	//		ICodeMgrBscItems* object you want back.
	//	To determine what interfaces a particular class implements, you would call
	//		GetAssociations(hProject, iinstClass, dxWizActiveXMatch, dxWizInterface, &ppvAssoc)
	//		where the parameters mean the same thing as in the first example except that iinstClass
	//		is the IINST for the C++ class.
	STDMETHOD(HasAssociations)(HPROJECT hProject, IINST iinstToAssoc, long nAssociationMajorType, 
		long nAssociationMinorType, BOOL* pbHasAssoc) PURE;
	STDMETHOD(GetAssociations)(HPROJECT hProject, IINST iinstToAssoc, long nAssociationMajorType, 
		long nAssociationMinorType, ICodeMgrBscItems** ppvBscItems) PURE;
	STDMETHOD(GetAssociation)(HPROJECT hProject, IINST iinstToAssoc, long nAssociationMajorType, 
		long nAssociationMinorType, BSTR bstrNameToAssocTo, IBscPersistentItem** ppvBscItem, 
		long* pnType, BSTR* pbstrAttributes) PURE;
	STDMETHOD(GetAssociationName)(HPROJECT hProject, IINST iinstToAssoc, long nAssociationMajorType, 
		long nAssociationMinorType, long nPresentHow, long nAssociatedHow, BSTR* pbstrName) PURE;
	STDMETHOD(GetAssociatedFunctions)(IINST iinstClass, IINST iinstIFace, long nAssociationMajorType,
		ICodeMgrBscItems** ppvFunctions) PURE;
	STDMETHOD(IsAssociatedFunction)(IINST iinstFunction, IINST iinstIFace, long nAssociationMajorType) PURE;

	// transaction support services (don't require transaction to use)
	// for GetSingleNamedMember and GetMultipleNamedMembers, nParseLanguage and hProject are only an issue
	// if iinstParent is IINST_GLOBALS, otherwise they are ignored.
	STDMETHOD(GetSingleNamedMember)(IINST iinstParent, short nParseLanguage, HPROJECT hProject, long nMemberKind, 
		BSTR bstrMemberName, IINST* piiMember) PURE;
	STDMETHOD(GetMultipleNamedMembers)(IINST iinstParent, short nParseLanguage, HPROJECT hProject, long nMemberKind, 
		BSTR bstrMemberName, ICodeMgrBscItems** ppvItems) PURE;
	STDMETHOD(GetMemberConflicts)(IINST iinstClass, long nMemberKind, BSTR bstrMember, IINST* piinstMember) PURE;
	STDMETHOD(CreateFunctionStubBody)(IINST iinstClass, VARTYPE vt, BSTR* pbstrReturn) PURE;
	STDMETHOD(GetAutomationStyle)(IINST iinst, memberAutomationStyles* pmemAutoStyle) PURE;
	STDMETHOD(CreateTemplateDictionary)(IDOTemplateDictionary** ppvDictionary) PURE;
		// ParseName currently accepts two different types of items for parsing:
		//	dxWizName - pull out any keywords (like virtual, afx_msg, etc.)
		//	default - comment out any default settings
	STDMETHOD(ParseName)(short nParseLanguage, long nParseType, BSTR bstrParseString, BSTR* pbstrResponse) PURE;
	STDMETHOD(MakeRelative)(HPROJECT hProject, BSTR bstrOrigPath, BSTR bstrRelativeWhat, 
		BSTR* pbstrRelativePath) PURE;
		// FindGlobalInsertLocation is intended for finding nice, big insert locations like 
		// for some arbitrary text you want to place somewhere or for inserting something 
		// like an interface into an IDL file.  Hints for FindGlobalInsertLocation: 
		//	- dxWizFileInsertIface (just below the 'lowest' existing interface or just above the 'library' 
		//		statement)
		//	- dxWizFileInsertDispIface (just below the 'lowest' existing dispinterface or just below the
		//		'library' statement)
		//	- dxWizFileInsertCoclass (just below the 'lowest' existing coclass or just above the end of 
		//		the library block)
		//	- dxWizHintCodeStart (just below any leading #include directives), 
		//	- dxWizStart (just below any header wrapper)
		//	- default (at 'end' which is inside header wrappers if applicable)
		// the passed in default line and column will be used iff we can't figure out anything better
		//		based on the hint.  A line number of (ULONG)-1 means end of file.
		// pbstrTab is an optional parameter and is used to obtain the tab level at the line you
		//		want to insert at
	STDMETHOD(FindGlobalInsertLocation)(BSTR bstrFilename, long nHintType, ULONG nDefaultLine, 
		ULONG nDefaultColumn, ULONG* pnActualLine, ULONG* pnActualColumn, BSTR* pbstrTab) PURE;
		// FindScopedInsertLocation is intended for finding a spot to stick a member item, like 
		// a function into a class.  These same flags (by definition) are in effect for 
		// bInParentDefn = TRUE means we're looking for insertion point in parent definition,
		//	otherwise, we're looking for insertion point in parent implementation
		// C++ Hints:	
		//	nHintType			nHintName
		//	dxWizHintFileName	name of file to insert in
		//	dxWizClassWiz		name of ClassWiz block
		//	default				NULL		picks up access correct access block to use
		//	dxWizEnd	- OR with other flags to get the END of whatever block it is the element is 
		//					going to be placed at
		// WARNING: using FindScopedInsertLocation will NOT result in the appropriate access specifier
		//	being guaranteed to be in place if you then use a straight InsertText at that line to add
		//	your element.
		// IDL/ODL Hints:
		//	nHintType			nHintName
		//	dxWizHintLineNumber	line number to insert at
		//	dxWizFunction		add before or after the specified function
		//	dxWizVariable		add before or after the specified variable
		//	default				attribute name	- place the new element before or after the element with 
		//											the specified attribute (lets us put things in id order)
		//	dxWizEnd	- OR with other flags to specify you want to add after that spot (absence means add before)
		// pbstrTab is an optional parameter and is used to obtain the tab level at the line you
		//		want to insert at
	STDMETHOD(FindScopedInsertLocation)(IINST iinst, long nMemberKind, short nAccessType, BOOL bInParentDefn, 
		long nHintType, BSTR bstrHintName, BOOL bMemberAddAfter, BSTR* pbstrFilename, ULONG* pnLine, 
		ULONG* pnColumn, BSTR* pbstrTab) PURE;
	STDMETHOD(IsValidSymbol)(HPROJECT hProject, short nParseLanguage, long nObjectType, BSTR bstrName, 
		BOOL* pbIsValidSymbol) PURE;
	STDMETHOD(IsReservedSymbol)(HPROJECT hProject, short nParseLanguage, long nObjectType, BSTR bstrName, 
		SymbolConflictType* pnSymbolType) PURE;

	// Transaction Manager
	STDMETHOD(StartTransaction)(IDOTransaction_Internal** ppvTransaction) PURE;
	STDMETHOD(get_Transaction)(IDOTransaction** ppvTransaction) PURE;	// can be NULL
	STDMETHOD(get_InternalTransaction)(IDOTransaction_Internal** ppvTransaction) PURE;	// can be NULL
	STDMETHOD(AddTransactionParticipant)(IDOTransactionParticipant* pParticipant) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IDOTransaction
//   This interface handles transaction management.
//	 'begin transaction' is implicit in creating one of these.
//
// See IDOTransactionParticipant for details on transaction chronology

#undef  INTERFACE
#define INTERFACE IDOTransaction
DECLARE_INTERFACE_(IDOTransaction, IDispatch)
{
	// generic methods
	STDMETHOD(CommitTransaction)(BOOL bSave) PURE;
	STDMETHOD(AbortTransaction)() PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IDOTransaction_Internal
//   This interface is used to modify any generic IINST-based object.  In addition to 
//   acting just like an IDOTransaction, it allows access to the code modification 
//   infrastructure.  See ICodeManager for more details on methods that are also available
//	 there.
//
// See IDOTransactionParticipant for details on transaction chronology

#undef  INTERFACE
#define INTERFACE IDOTransaction_Internal
DECLARE_INTERFACE_(IDOTransaction_Internal, IUnknown)
{
	// standard transaction methods
	STDMETHOD(CommitTransaction)(BOOL bSave) PURE;
	STDMETHOD(AbortTransaction)() PURE;

	// general services
	STDMETHOD(GetHelper)(REFIID riidInterface, IUnknown** ppvInterface) PURE;
	STDMETHOD(GetCodeManagerLocation)(BSTR* pbstrCodeMgrLoc) PURE;
	STDMETHOD(GetTextEditor)(BOOL bWriteable, BOOL bForceOpen, BSTR bstrFilename, 
		ICodeMgrTextEditor** ppvTextEditor) PURE;
	STDMETHOD(get_LexerForLanguage)(short nParseLanguage, ICodeMgrLexer** ppvLexer) PURE;

	// project services
	STDMETHOD(get_ProjectName)(HPROJECT hProject, BSTR* pbstrProjName) PURE;
	STDMETHOD(get_SelectedProject)(HPROJECT* phProject) PURE;
	STDMETHOD(put_SelectedProject)(HPROJECT hProject) PURE;
	STDMETHOD(IsObjectInProject)(HPROJECT hProject, long nObjectType, short nParseLanguage, 
		BSTR bstrObjectName, long* pnActualType) PURE;

	// Transaction Manager
	STDMETHOD(AddTransactionParticipant)(IDOTransactionParticipant* pParticipant) PURE;
	STDMETHOD(get_TempResourceDO)(HPROJECT hProject, ITransMgrResourceHelper** ppvHelper) PURE;
	STDMETHOD(get_TempProjSystemDO)(HPROJECT hProject, ITransMgrProjHelper** ppvHelper) PURE;

	// read-only services for specific objects
	STDMETHOD(get_FileName)(IINST iinst, long nFileType, short nPathType, BSTR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(IINST iinst, long nFileType, short nPathType, IDOStrings** ppvFiles) PURE;
	STDMETHOD(GetDerivedClasses)(short nParseLanguage, HPROJECT hProject, BSTR bstrBaseClass, 
		BOOL bImmediateOnly, ICodeMgrBscItems** ppvClasses) PURE;
	STDMETHOD(GetInclude)(HPROJECT hProject, long nFileType, BSTR bstrClassName, BOOL bMakeRelative,  
		BSTR bstrRelativeWhere, BSTR* pbstrIncludeFile) PURE;
	STDMETHOD(BreakUpParameter)(IINST iinstParent, BSTR bstrFullParam, BOOL bDoErrorChecks,
		BSTR* pbstrParamType, BSTR* pbstParamName, BSTR* pbstrParamDefault, 
		BSTR* pbstrParamComments, BSTR* pbstrParamAttribs) PURE;

	// transaction support services (don't require transaction to use)
	STDMETHOD(GetSingleNamedMember)(IINST iinstParent, short nParseLanguage, HPROJECT hProject, long nMemberKind, 
		BSTR bstrMemberName, IINST* piiMember) PURE;
	STDMETHOD(GetMultipleNamedMembers)(IINST iinstParent, short nParseLanguage, HPROJECT hProject, long nMemberKind, 
		BSTR bstrMemberName, ICodeMgrBscItems** ppvItems) PURE;
	STDMETHOD(GetMemberConflicts)(IINST iinstClass, long nMemberKind, BSTR bstrMember, IINST* piinstMember) PURE;
	STDMETHOD(CreateFunctionStubBody)(IINST iinstClass, VARTYPE vt, BSTR* pbstrReturn) PURE;
	STDMETHOD(GetAutomationStyle)(IINST iinst, memberAutomationStyles* pmemAutoStyle) PURE;
	STDMETHOD(CreateTemplateDictionary)(IDOTemplateDictionary** ppvDictionary) PURE;
	STDMETHOD(ParseName)(short nParseLanguage, long nParseType, BSTR bstrParseString, BSTR* pbstrResponse) PURE;
	STDMETHOD(MakeRelative)(HPROJECT hProject, BSTR bstrOrigPath, BSTR bstrRelativeWhat, 
		BSTR* pbstrRelativePath) PURE;
	STDMETHOD(FindGlobalInsertLocation)(BSTR bstrFilename, long nHintType, ULONG nDefaultLine, 
		ULONG nDefaultColumn, ULONG* pnActualLine, ULONG* pnActualColumn, BSTR* pbstrTab) PURE;
	STDMETHOD(FindScopedInsertLocation)(IINST iinst, long nMemberKind, short nAccessType, BOOL bInParentDefn, 
		long nHintType, BSTR bstrHintName, BOOL bMemberAddAfter, BSTR* pbstrFilename, ULONG* pnLine, 
		ULONG* pnColumn, BSTR* pbstrTab) PURE;
	STDMETHOD(IsValidSymbol)(HPROJECT hProject, short nParseLanguage, long nObjectType, BSTR bstrName, 
		BOOL* pbIsValidSymbol) PURE;
	STDMETHOD(IsReservedSymbol)(HPROJECT hProject, short nParseLanguage, long nObjectType, BSTR bstrName, 
		SymbolConflictType* pnSymbolType) PURE;

	// generic project modification services
		// AddInclude: 
		//	- nAddWhere lets you set the basic location for where the #include is going to be added 
		//		dxWizProjectInclude - add to the project include file (C++)
		//		dxWizFileInclude - add to the file specified in bstrClassName (C++)
		//		dxWizFileScope - add near top of file (IDL/ODL)
		//		dxWizLibraryScope - add near top of library (IDL/ODL)
		//		dxWizObjectScope - add inside object specified by bstrClassName
		//		dxWizImport - adding an import 
		//		dxWizInclude - adding an include (default for C++)
		//		dxWizImportlib - adding an importlib (IDL/ODL only)
		//		Default is to add to the file indicated by nHintType 
		//	- nHintType 
		//		dxWizDefinition, dxWizDeclaration, dxWizMemberDefinitions, dxWizMemberDeclarations
		//			used in conjunction with default nAddWhere and given the class name in 
		//			bstrClassName
		//		dxWizFilePathRelative - make the path in bstrIncludeName relative to the file
		//			we're adding the directive to
	STDMETHOD(AddInclude)(short nParseLanguage, HPROJECT hProject, long nAddWhere, BSTR bstrClassName, 
		BSTR bstrIncludeName, BSTR bstrAttribs, BSTR bstrConditions, BSTR bstrComments, long nHintType, 
		BSTR bstrHintName, BOOL bAddAfter) PURE;

	// generic IINST-based modification services. 
	STDMETHOD(put_Name)(IINST iinst, BSTR bstrName) PURE;
	STDMETHOD(put_Contents)(IINST iinst, BSTR bstrContents) PURE;
	// shortcut for deleting all attributes on an object is to call put_AllAttributes with bstrAttribs = NULL
	STDMETHOD(put_AllAttributes)(IINST iinstParent, BSTR bstrAttribs) PURE;
	// Hints for AddAttribute:
	//	dxWizDuplicateOK - don't check if this attribute is already present
	//	dxWizEnd - add it to the end of the existing attribute list, if any
	//	dxWizHintIndex - add it at the index specified in bstrHintName (use bAddAfter to designate
	//		before or after); zero-based count
	STDMETHOD(AddAttribute)(IINST iinst, BSTR bstrAttributeName, BSTR bstrAttributeValue, 
		BSTR bstrAttributeComment, long nHintType, BSTR bstrHintName, BOOL bAddAfter) PURE;
	STDMETHOD(put_AccessType)(IINST iinst, short nAccessType) PURE;
	STDMETHOD(GetOneLine)(IINST iinst, long nFileType, long nLineNumber, BSTR* bstrLineContents) PURE;
	STDMETHOD(SetOneLine)(IINST iinst, long nFileType, long nLineNumber, BSTR bstrText) PURE;
	// Usage of elements of InsertText: 
	//	iinst - elemement you're trying to modify
	//	nFileType - dxWizDefinition, dxWizDeclaration, dxWizMemberDefinitions, dxWizMemberDeclarations
	//		specifies which file associated with the IINST to use
	//	nLineNumber
	//		dxWizDefEndLine - last line of the definition of the iinst element
	//		dxWizDefBeginLine - first line of the definition of the iinst element
	//		dxWizModEndLine - last line of the file specified using iinst and nFileType
	//		default - actual line to use
	//	nColumn
	//		dxWizEndOfLine - after last column on specified line
	//		default - actual column location
	STDMETHOD(InsertText)(IINST iinst, long nFileType, BSTR bstrText, long nLineNumber, long nColumn, 
		BOOL bFullLine) PURE;
	// nWhichPart for Delete: (all can be OR'ed together)
	//	dxWizDefinition - object definition
	//	dxWizDeclaration - object declaration 
	//	dxWizMemberDefinitions - member definitions (class only)
	//	dxWizMemberDeclarations - same as dxWizDefinition for a class
	// You'll need to OR together whatever parts you want hard deleted in nCommentOrDeletePart
	//	or it will just be commented out
	STDMETHOD(Delete)(IINST iinst, short nWhichPart, short nCommentOrDeletePart) PURE;
	STDMETHOD(put_Type)(IINST iinst, BSTR bstrType) PURE;
	// Hints for put_Comment
	//	dxWizDeclaration - put comment in declaration file
	//	dxWizDefinition - put comment in definition file
	//	dxWizEnd - make the comment an end-of-line comment
	//	dxWizSameLoc - use the same location previously used if we're replacing an existing comment
	STDMETHOD(put_Comment)(IINST iinst, BSTR bstrComment, long nHintType, BSTR bstrHintName) PURE;

	// IINST-based modification services that require that the IINST be something that has members, 
	// like a class
	// NOTE: AddMember and AddMemberBody only pay attention to nParseLanguage if iinstClass is for
	// the global class.  Otherwise, that parameter will be ignored
		// Hints shared by AddMember, AddMemberBody, AddBaseClass, and AddItem
		//	dxWizDoIndents - put the element at the same tabbing level as what's present near its
		//		insertion point (one tab further in if at beginning or end or just after an access
		//		specifier) with all \r\n pairs in the body supplemented with the new tab level
		//		and follow the whole thing with an extra \r\n pair
		//	dxWizHintCOM - the name is a COM thing (STDMETHOD, STDMETHOD_) and needs to be munged
		//		appropriately (AddMember, AddMemberBody only)
		//	See also FindScopedInsertLocation for further hints available for AddMember and 
		//		FindGlobalInsertLocation for further hints available for AddMemberBody
	STDMETHOD(AddMember)(IINST iinstClass, short nParseLanguage, long nMemberKind, BSTR bstrMemberName, 
		BSTR bstrMemberType, short nAccessType, BSTR bstrAttributes, BSTR bstrComments, BSTR bstrConditions, 
		BSTR bstrBody, long nHintType, BSTR bstrHintName, BOOL bMemberAddAfter) PURE;
		// AddMember: pass a NULL for bstrBody if you want a declaration, not an in-line, for a function
	STDMETHOD(AddMemberBody)(IINST iinstClass, short nParseLanguage, long nMemberKind, BSTR bstrMemberName, 
		BSTR bstrMemberType, BSTR bstrComments, BSTR bstrMemberBody, BSTR bstrConditions, long nHintType, 
		BSTR bstrHintName, BOOL bMemberAddAfter) PURE;
	STDMETHOD(AddBaseClass)(IINST iinstClass, BSTR bstrBaseClass, short nAccessType, long nHintType, 
		BSTR bstrHintName) PURE;

	// IINST-based modification services that require that the IINST be something that 
	// takes parameters, like a function
		// SetParameters: nWhichPart allows you to set the parameters separately for the 
		// definition and declaration if you choose
	STDMETHOD(SetParameters)(IINST iinstObject, short nWhichPart, BSTR bstrParameters) PURE;
	STDMETHOD(AddParameter)(IINST iinstObject, short nParamNum, BOOL bAddAfter, BSTR bstrNewParam,
		BSTR bstrNewParamAttributes, BSTR bstrNewParamComments) PURE;
	STDMETHOD(put_ParameterName)(IINST iinstObject, short nParamNum, BSTR bstrName) PURE;
	STDMETHOD(put_ParameterValue)(IINST iinstObject, short nParamNum, BSTR bstrValue) PURE;
	STDMETHOD(DeleteParameter)(IINST iinstObject, short nParamNum, BOOL bHardDelete) PURE;
	STDMETHOD(put_ParameterType)(IINST iinstObject, short nParamNum, BSTR bstrType) PURE;
	// put_ParameterComment - see put_Comments for list of options for hints.
	STDMETHOD(put_ParameterComment)(IINST iinstObject, short nParamNum, BSTR bstrComment, long nHintType, 
		BSTR bstrHintName) PURE;
	STDMETHOD(put_ParameterAttributes)(IINST iinstObject, short nParamNum, BSTR bstrAttribs) PURE;
	// AddParameterAttribute: see AddParameter for list of options for hints.  Note also that
	//	this is only available for IDL/ODL
	STDMETHOD(AddParameterAttribute)(IINST iinstObject, short nParamNum, BSTR bstrAttributeName, 
		BSTR bstrAttributeValue, BSTR bstrAttributeComment, long nHintType, BSTR bstrHintName, 
		BOOL bAddAfter) PURE;
	STDMETHOD(DeleteParameterAttribute)(IINST iinstObject, short nParamNum, BSTR bstrAttributeName,
		BOOL bHardDelete) PURE;
	STDMETHOD(put_ParameterAttribute)(IINST iinstObject, short nParamNum, BSTR bstrOldAttributeName,
		BSTR bstrAttributeName, BSTR bstrAttributeValue, BSTR bstrAttributeComment) PURE;

	// IINST-based modification services for adding elements to a map or enum.  
	// bstrValue only has meaning for adding an enum item
	//	Hints available for AddItem:
	//		dxWizClassWiz - place inside the ClassWiz block designated by bstrHintName (ex: MSG_MAP)
	//		dxWizEnd - place at end of whatever (end of ClassWiz block if that is also designated)
	//		dxWizHintIndex - place at the index designated in bstrHintName (use bAddAfter to designate
	//			before or after that index); zero-based count
	STDMETHOD(AddItem)(IINST iinstObject, BSTR bstrItem, BSTR bstrValue, BSTR bstrComments, long nHintType, 
		BSTR bstrHintName, BOOL bAddAfter) PURE;

	STDMETHOD(GetLastFileName)(BSTR *pbstrFileName) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ITransMgrResourceHelper
//   This interface is a temporary stand-in for resource DOs.
//   For 6X, this provides us with a limited ability to do transacted resource manipulation.

#undef  INTERFACE
#define INTERFACE ITransMgrResourceHelper
DECLARE_INTERFACE_(ITransMgrResourceHelper, IUnknown)
{	
	STDMETHOD(CreateResourceTable)(UINT nCreateFlags) PURE;
	STDMETHOD(GetResourceInclude)(BSTR* pbstrFilename) PURE;
	STDMETHOD(AttachResourceStream)(LPSTREAM lpStream) PURE;
	STDMETHOD(CreateResourceSymbol)(BSTR bstrID, BSTR* pbstrActualID, int* pnIDValue) PURE;
	STDMETHOD(CreateResource)(BSTR bstrType, BSTR bstrID, int nLangID, BSTR bstrCondition, 
		BSTR bstrNewID) PURE;
	STDMETHOD(ImportResource)(BSTR bstrType, BSTR bstrID, BSTR bstrFileName, int nLangID, 
		BSTR bstrCondition) PURE;
	STDMETHOD(SetResourceID)(BSTR bstrType, BSTR bstrOldID, int nLangID, BSTR bstrCondition, 
		BSTR bstrNewID) PURE;
	STDMETHOD(CreateResourceString)(BSTR bstrID, int nLangID, BSTR bstrCondition, BSTR bstrString) PURE;
	STDMETHOD(ResourceAccess)(UINT nMode) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ITransMgrProjHelper
//   This interface is a temporary stand-in for Proj/Build DOs
//   For 6X, this provides us with the ability to transact at least the addition
//   of new files to a project.

#undef  INTERFACE
#define INTERFACE ITransMgrProjHelper
DECLARE_INTERFACE_(ITransMgrProjHelper, IUnknown)
{
	STDMETHOD(AddFile)(BSTR bstrFilename) PURE;
	STDMETHOD(CalculateFilename)(BSTR bstrFilename, BSTR* pbstrNewFilename, long* pnHint) PURE;
	STDMETHOD(IsFileOnAddList)(BSTR bstrFilename, BOOL* pbIsOnList) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IDOTransactionParticipant
//   This interface handles the various elements that make up a transaction.
//   For 6X, these elements will consist of:
//   - the text editor (ICodeMgrTextEditor, IDOExpandTemplates),
//   - the resource editor (ITransMgrResourceHelper)
//   - the Proj/Build system (ITransMgrProjHelper)
//   It is possible to add additional elements (including specific DOs) to the
//   list by adding one of these elements via 
//   ICodeManager::AddTransactionParticipant
//
//   Chronology of a transaction:
//   - Wizard starts a transaction
//   - Wizard does something to modify a project, ex: add a file, add a member, delete 
//       something, add a string to resources, etc.
//   - As each kind of project modifier comes on line (text edits, resource edits, etc.), 
//       it adds itself as a transaction participant
//   - Wizard commits the transaction
//   - The Code Manager calls CanCommit for each IDOTransactionParticipant object it has.  
//       A failure return from any participant results in aborting the transaction
//   - The Code Manager calls Commit on each participant three times, specifying which round 
//       is involved.  Any given participant should only do work at this point once.  This 
//       is done so that we don't have order dependence between the participants.  
//       Participants should maintain any required state to be aborted throughout this 
//       process.
//       - Round 1: Anybody who uses other transaction services but doesn't provide any 
//           (ex: IClassDO)
//       - Round 2: Anybody who both uses and provides transaction services 
//           (ex, sort of: IDOExpandTemplates)
//       - Round 3: Anybody who only provides transaction services 
//           (ex: ICodeMgrTextEditor)
//   - The Code Manager calls AfterCommit on each participant.  It is now safe to throw 
//       away any maintained state information.
//
//   For a nested transaction, repeat the same scenario above, EXCEPT use the 
//   appropriate methods that apply to nested transactions AND only state information 
//   related to the intermediate state of the transaction can be thrown away.  Abort can 
//   be called on the full transaction at any time except after AfterCommit is called on 
//   the participants.

#undef  INTERFACE
#define INTERFACE IDOTransactionParticipant
DECLARE_INTERFACE_(IDOTransactionParticipant, IUnknown)
{
	// IDOTransactionParticipant methods
	STDMETHOD(InitialTransactionLevel)(int nStartingLevel) PURE;	
		// error out on InitialTransactionLevel() to abort adding yourself to list

	// these methods apply to nested levels within a transaction
	STDMETHOD(AddTransactionLevel)() PURE;
	STDMETHOD(CommitTransactionLevel)(int nRoundNumber, BOOL bSave) PURE;
	STDMETHOD(CanCommitTransactionLevel)() PURE;
	STDMETHOD(AfterCommitTransactionLevel)() PURE;
	STDMETHOD(AbortTransactionLevel)() PURE;	// return value ignored
	STDMETHOD(AfterAbortTransactionLevel)() PURE;	// return value ignored

	// these methods are called on final commit/abort of a transaction
	STDMETHOD(CommitTransaction)(int nRoundNumber, BOOL bSave) PURE;
	STDMETHOD(CanCommitTransaction)() PURE;
	STDMETHOD(AfterCommitTransaction)() PURE;
	STDMETHOD(AbortTransaction)() PURE;	// return value ignored
	STDMETHOD(AfterAbortTransaction)() PURE;	// return value ignored
};

/////////////////////////////////////////////////////////////////////////////
// ICodeMgrBscItems
//   This interface provides access to generic lists of code manager IINST data.
//   The IEnumVARIANT values here are IBscPersistentItem objects.

#undef  INTERFACE
#define INTERFACE ICodeMgrBscItems
DECLARE_INTERFACE_(ICodeMgrBscItems, IDispatch)
{
	// required collection method
	STDMETHOD(_NewEnum)(IEnumVARIANT **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ICodeMgrTextEditor
//	This interface provides access to the code manager's transacted text editor.
//	It is NOT intended for use by the 'old' style Wizard Model wizards.

#undef  INTERFACE
#define INTERFACE ICodeMgrTextEditor
DECLARE_INTERFACE_(ICodeMgrTextEditor, IUnknown)
{	
	// GetLineText: used with lexer, etc.; not intended for wide scale use.  More than one line can be
	//	returned here.  Call ICodeManager::GetLineText if all you really want is the single line of text
	STDMETHOD(GetLineText)(ULONG iLine, BSTR* pbstr, ULONG* pcb, BOOL bStripEOL) PURE;
	STDMETHOD(GetLineCount)(ULONG* piLines) PURE;
	STDMETHOD(GetFileName)(BSTR* pbstrFileName) PURE;
	STDMETHOD(GetTextSection)(ULONG iStartLine, ULONG iStartColumn, ULONG iEndLine, ULONG iEndColumn,
		BSTR* pbstrText) PURE;
	STDMETHOD(FindToken)(ULONG uLineNumber, BSTR bstrToken, BOOL bFuzzyMatch, ULONG* puLineHit, 
		ULONG* puColumnHit) PURE;
	STDMETHOD(FindAnsiToken)(ULONG uLineNumber, LPCTSTR lpszToken, BOOL bFuzzyMatch, ULONG* puLineHit, 
		ULONG* puColumnHit) PURE;
	STDMETHOD(InsertText)(BSTR bstrText, ULONG uline, ULONG uColumn) PURE;
	STDMETHOD(InsertAnsiText)(LPCTSTR pszText, ULONG uline, ULONG uColumn) PURE;
	STDMETHOD(DeleteText)(ULONG uStartLine, ULONG uStartCol, ULONG uEndLine, ULONG uEndCol) PURE;
	STDMETHOD(ChangeText)(ULONG uStartLine, ULONG uStartCol, ULONG uEndLine, ULONG uEndCol, 
		BSTR bstrText) PURE;
	STDMETHOD(ChangeAnsiText)(ULONG uStartLine, ULONG uStartCol, ULONG uEndLine, ULONG uEndCol, 
		LPCTSTR pszText) PURE;
	// [bstr/psz]FileContent is the name of the file we're getting the text from and
	// uLine/uColumn specifies where to put it in the file described by this particular
	// ICodeMgrTextEditor object
	STDMETHOD(InsertFileContent)(BSTR bstrFileContent, ULONG uLine, ULONG uColumn) PURE;
	STDMETHOD(InsertAnsiFileContent)(LPCTSTR pszFileContent, ULONG uLine, ULONG uColumn) PURE;

	STDMETHOD(get_Lexer)(ICodeMgrLexer** ppvLexer) PURE;
	// the command list is only useful if you care about what is already being done to the
	// same file you're working with, so this may actually only be useful inside the Code Manager
	// and not useful at all to DOs.
	STDMETHOD(get_CommandList)(IEnumVARIANT** ppvCommands) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ICodeMgrLexer
//   This interface is used for private communication with the wiz model text lexer
//   Getting one of these from ICodeMgrTextEditor ensures that you've got the right lexer
//   for a particular file.  If you have a text buffer you want to check out, pass
//   the right language symbol (dxWizCPP or dxWizIDL) to the version of get_LexerForLanguage

#undef  INTERFACE
#define INTERFACE ICodeMgrLexer
DECLARE_INTERFACE_(ICodeMgrLexer, IUnknown)
{
	STDMETHOD(InitializeLexer)() PURE;
	STDMETHOD(LexLine)(BSTR bstrLine, UINT cbLine) PURE;
	STDMETHOD(GetTokens)(long* plCount, TXTB** prgTokens) PURE;
	STDMETHOD(ClearLexer)() PURE;
	STDMETHOD(RemoveClassName)(BSTR bstrOriginalDecl, BSTR* pbstrNewDecl, BSTR* pbstrClass) PURE;
	STDMETHOD(AddClassName)(BSTR bstrOriginalDecl, BSTR bstrClass, BSTR* pbstrNewDecl) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ICodeMgrTextEditorCommand
//   This interface is used to describe an individual command for the text editor 

#define dxActionAdd		0x1		// adding text
#define dxActionDelete	0x2		// deleting text
#define dxActionReplace	0x4		// replacing text

#undef  INTERFACE
#define INTERFACE ICodeMgrTextEditorCommand
DECLARE_INTERFACE_(ICodeMgrTextEditorCommand, IUnknown)
{
	STDMETHOD(get_Action)(long* pnActionType) PURE;	// the type of action
	STDMETHOD(get_Text)(BSTR* pbstrText) PURE;	// the text we're putting in, if any
	STDMETHOD(put_Text)(BSTR bstrText) PURE;			// replacement for the intended text
	STDMETHOD(put_AnsiText)(LPCTSTR pszText) PURE;			// replacement for the intended text
	STDMETHOD(get_StartLine)(long* pnStartLine) PURE;
	STDMETHOD(put_StartLine)(long nStartLine) PURE;	// use CAREFULLY
	STDMETHOD(get_StartColumn)(long* pnStartColumn) PURE;
	STDMETHOD(put_StartColumn)(long nStartColumn) PURE;	// use CAREFULLY
	STDMETHOD(get_EndLine)(long* pnEndLine) PURE;		// not valid for dxActionAdd
	STDMETHOD(put_EndLine)(long nEndLine) PURE;	// use CAREFULLY to extend selection for delete/replace
	STDMETHOD(get_EndColumn)(long* pnEndColumn) PURE;	// not valid for dxActionAdd
	STDMETHOD(put_EndColumn)(long nEndColumn) PURE;	// use CAREFULLY to extend selection for delete/replace
};

#endif	// _CODEMGRAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dbgguid.h ===
/////////////////////////////////////////////////////////////////////////////
// DBGGUID.H
//    Debug package interface ids.

// Interface ID for Debug Command {C4E620E1-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_IDebugCmd,
0xc4e620e1, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

// Interface ID for OSDebug {C4E620E2-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_IOSDebug,
0xc4e620e2, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

// Interface ID for Expression Evaluator {C4E620E3-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_IExprEval,
0xc4e620e3, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

// Interface ID for Symbol Handler {C4E620E4-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_ISymbolHandler,
0xc4e620e4, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

// Interface ID for Miscellaneous Debug Command {C4E620E5-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_IMiscDebug,
0xc4e620e5, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\clwzapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	CLWZAPI.H
//		Class Wizard package interface declarations.

#ifndef __CLWZAPI_H__
#define __CLWZAPI_H__

#ifdef _WIZ_INTERNAL
#define WIZ_EXPORT _declspec(dllexport)
#else
#define WIZ_EXPORT _declspec(dllimport)
#endif

__interface IClassWizard;
__interface IChangeClasses;
__interface ICreateClasses2;


typedef IClassWizard* LPCLASSWIZARD;


/////////////////////////////////////////////////////////////////////////////
// IClassWizard
//   This interface is used to access ClassWizard features.  The interface
//   is implemented in the CPP package which implibs to the classwizard DLL.
//

#undef INTERFACE
#define INTERFACE IClassWizard

class CITextDoc;
class CClsWizClass;
#include "ogapi.h"	// need IApplyContext
#include "atlobj.h"  // for OleDB COM object.

#define MAX_LINECOUNTS	4

// Defines for Verb Flags
#define CWV_VIRTFUNCT	0x2
#define CWV_PROTFUNCT	0x4
#define CWV_CONSTFUNCT	0x8
#define CWV_ADVFUNCT	0x10
#define CWV_NOTIFY		0x20	/* verb is a type of WM_NOTIFY */
#define CWV_REFLECTED	0x40	/* verb represents a Windows control message which has been
								   reflected to the message map in the control class.
								 */
#define CWV_WM			0x80	/* verb is a window message (currently this flag is
								 * used only with CWV_REFLECTED).
								 */
#define CWV_NIL			0

// CClassWizInterface::Run return values
#define CODEWIZ_FAILED	0
#define CODEWIZ_OK	1
#define CODEWIZ_UPDATE_CLW	2

// flags for nRequest parameter of IClassWizard::Run
#define	CODEWIZ_CLASS_NAME			0			// lpszWholeName = class name
#define	CODEWIZ_DIALOG_RESOURCE		1			// lpszWholeName = resource
#define	CODEWIZ_MENU_RESOURCE		2			// lpszWholeName = resource
#define CODEWIZ_ACCELERATOR_RESOURCE 3			// lpszWholeName = resource
#define CODEWIZ_LAST_CLASS			4			// lpszWholeName = NULL
#define CODEWIZ_FLUSH_PROJECT		5			// lpszWholeName = NULL
#define CODEWIZ_TOOLBAR_RESOURCE	6			// lpszWholeName = resource

// Flags for determining OLE info that ClassWizard knows about
// these need to stay in same order and have the same meanings as the NAMETYPE enum in oleutil.h
enum oleNameType { ontCName, ontOleName, ontPrettyName, ontOdlName };	

// Non-standard COM
class CClsWizVerb : public CObject
{
public:
	CClsWizVerb() {	m_strVerb.Empty(); m_strData.Empty(); m_nVerbFlags = 0; }
	virtual LPCSTR GetDisplayString() { return m_strVerb; }
	virtual UINT GetFlags() { return m_nVerbFlags; }
	virtual void SetFlags(UINT nFlags) { m_nVerbFlags = nFlags; }
	virtual UINT GetEvents() { return m_indexEvents; }
	virtual void SetEvents(UINT nEvents) { m_indexEvents = nEvents; }
	virtual CString &GetVerb() { return m_strVerb; }
	virtual void SetVerb(CString strVerb) { m_strVerb = strVerb; }
	virtual CString &GetCast() { return m_strCast; }
	virtual void SetCast(CString strCast) { m_strCast = strCast; }
	virtual CString &GetData() { return m_strData; }
	virtual void SetData(CString strData) { m_strData = strData; }
	virtual void GetMFCName(CString& strBuf)
	{
		int index = m_strData.Find('|');
		if (index != -1)
			strBuf = m_strData.Left(index);
		else
			strBuf.Empty();
	}
	virtual void GetHelpText(CString& strBuf)
	{
		int index = m_strData.Find('|');
		if (index != -1)
			strBuf = m_strData.Right(m_strData.GetLength()-index-1);
		else
			strBuf.Empty();
	}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const
	{
		CObject::Dump(dc);
		dc << " named " << m_strVerb;
		dc << " data: " << m_strData;
		dc << "\n";
	}
#endif //_DEBUG

private:
	CString m_strVerb;
	CString m_strData;
	UINT m_nVerbFlags;
	UINT m_indexEvents;
	CString m_strCast;
};

// Non-standard COM.
class CClsWizNoun : public CObject
{
public:
	CClsWizNoun(LPCSTR lpszName) { m_strNoun = lpszName; m_ptinfoEvents = NULL; }
	virtual ~CClsWizNoun() { if (m_ptinfoEvents != NULL) m_ptinfoEvents->Release(); }

	// Temporary in nature - Don't hold this pointer and don't write to it.
	virtual LPCSTR GetDisplayString() { return m_strNoun; }
	virtual void SetNoun(CString strNoun) { m_strNoun = strNoun; }
	virtual UINT GetFlags() { return m_nNounFlags; }
	virtual void SetFlags(UINT nFlags) { m_nNounFlags = nFlags; }
	virtual ITypeInfo *GetEvents() { return m_ptinfoEvents; }
	virtual void SetEvents(ITypeInfo *ptInfo) { m_ptinfoEvents = ptInfo; }
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const
	{
		CObject::Dump(dc);
		dc << " named " << m_strNoun;
		dc << "\n";
	}
#endif //_DEBUG

private:
	CString m_strNoun;
	UINT m_nNounFlags;
	ITypeInfo *m_ptinfoEvents;
};

// There are no exports for the CString object embedded below.
// so turn off Warning 4251 "Don't Ask and don't tell."
#pragma warning(disable: 4251 4275)

typedef CTypedPtrList<CObList, CClsWizVerb*> CClsWizVerbListBase;

class WIZ_EXPORT CClsWizVerbList : public CClsWizVerbListBase
{
// Implementation use only
public:
	virtual BOOL AddVirtualFunctionsToList(const CString& strFilter);
	virtual BOOL AddToListFromResource(LPCSTR lpszResourceName, LPCSTR lpszNoun, char chFilter = '\0',
							   WORD wKey = CWV_NIL, BOOL fFormDlgFilter = FALSE);
	virtual BOOL AddToListFromMemory(LPCSTR lpch, LPCSTR lpszFilter, WORD wKey = 0, BOOL fFormDlgFilter = FALSE);
	virtual BOOL AddToListFromTypeinfo(ITypeInfo *ptinfo);
};

typedef CTypedPtrList<CObList, CClsWizNoun*> CClsWizNounList;


// Non-standard COM.

typedef struct _CWNounEnum
{
	CClsWizNounList *pNounList;
	POSITION posNounEnum;
} CWNounEnum; // Class Wizard noun enumeration state

// Non-standard COM.

typedef struct _CWVerbEnum
{
	CClsWizVerbList *pVerbList;
	POSITION posVerbEnum;
} CWVerbEnum; // Class Wizard verb enumeration state


DECLARE_INTERFACE_(IClassWizard, IUnknown)
{
	STDMETHOD(IsDBAvailable)() PURE;
	STDMETHOD(PickDataSource)(BOOL& bDAO, BOOL& bBindAll, BOOL& bAutoDetect, BOOL bEnableDAO,
									CString& strSQL, CString& strConnect, CString& strTableType,
									CStringList& columns, CStringList& defVarNames,
									CString& strParamVars, CString& strParamBindings, CString& strParamMap,
									CString& strOpen,
									CWnd* pParent = NULL,							// Non-standard COM.
									IOLEDBConsCode *pOleDBConsDlg = NULL) PURE; 	// Non-standard COM.
	STDMETHOD(GenerateControlWrapper)(const GUID& guid, IApplyContext *pAC, LPCSTR szOCXFile) PURE;
	STDMETHOD(RegisterOLEControl)(LPCSTR pszPath) PURE;

	STDMETHOD(Run)(int *i, UINT nRequest, LPCSTR lpszProjPath, HWND hWndOwner,
			LPCSTR lpszWholeName, LPCSTR lpszPartName, LPCSTR lpszAutoContext) PURE;
	STDMETHOD(Update)(UINT nRequest, LPCSTR lpszProjPath, LPCSTR lpszResourceName, LPSTR lpResClwInfo) PURE;
	STDMETHOD(Update)(UINT nRequest, LPCSTR lpszProjPath, LPCSTR lpszOldName,
			LPCSTR lpszNewName, LPSTR lpResClwInfo, BOOL bRebuilding) PURE;
	STDMETHOD(UpdateResourceRebuildStatus)(LPCSTR lpszProjPath, BOOL bForceRebuild) PURE;

	STDMETHOD(DatabaseValid)() PURE;
	STDMETHOD(UpdateCmdUIDatabaseValid)() PURE;
	STDMETHOD(ClassFromFileName)(LPCSTR lpszPathName, CClsWizClass* pClass) PURE; 	// Non-standard COM.
	STDMETHOD(GetClwFileFromFileset)(UINT hFileSet, CString& rstrClwFile) PURE; 	// Non-standard COM.
	STDMETHOD(ImportClass)(UINT hFileSet, LPCSTR lpszClassName, 
							LPCSTR lpszHFileName, LPCSTR lpszCppFileName) PURE;
	STDMETHOD(CreateClassObject)(CClsWizClass** ppClass) PURE; 	// Non-standard COM.
	STDMETHOD(DeleteClassObject)(CClsWizClass* pClass) PURE; 	// Non-standard COM.
	STDMETHOD(GetCreateClasses)(ICreateClasses** ppCreateClasses) PURE;
	STDMETHOD(IsValidClass)(LPCSTR lpszClassName, LPCSTR lpszFileName) PURE;
	STDMETHOD(IsClassWizardClass)(LPCSTR lpszClassName) PURE;
	STDMETHOD(IsValidFile)(LPCSTR lpszFile, CString* pstrClass) PURE; 	// Non-standard COM.
	STDMETHOD(GetAssocFile)(LPCSTR lpszFile, CString& strClass, CString* pstrAssocFile) PURE; 	// Non-standard COM.
	STDMETHOD(SetClass)(CClsWizClass* pClass, LPCSTR lpszFileName, LPCSTR lpszClass) PURE; 	// Non-standard COM.
	STDMETHOD(GetClassWizardClass)(LPCSTR lpszClassName, CClsWizClass** pClass) PURE;       // Non-standard COM.
	STDMETHOD(InitNounEnum)(CClsWizClass *pClass, CWNounEnum *pCWNounEnum) PURE; 	// Non-standard COM.
	STDMETHOD(GetNextNoun)(CClsWizClass *pClass, CWNounEnum *pCWNounEnum, CClsWizNoun **ppNoun) PURE; 	// Non-standard COM.
	STDMETHOD(ReleaseNounEnum)(CClsWizClass *pClass, CWNounEnum *pCWNounEnum, CClsWizNoun *pNounNoDelete) PURE; 	// Non-standard COM.
	STDMETHOD(InitVerbEnum)(CClsWizClass *pClass, CClsWizNoun *pNoun, CWVerbEnum *pCWVerbEnum) PURE;
	STDMETHOD(InitVerbEnumFromFilter)(char chFilterType, CWVerbEnum *pCWVerbEnum) PURE;
	STDMETHOD(GetNextVerb)(CClsWizClass *pClass, CClsWizNoun *pNoun, CWVerbEnum *pCWVerbEnum, CClsWizVerb **ppVerb) PURE; 	// Non-standard COM.
	STDMETHOD(ReleaseVerbEnum)(CClsWizClass *pClass, CClsWizNoun *pNoun, CWVerbEnum *pCWVerbEnum, CClsWizVerb *pVerbNoDelete) PURE; 	// Non-standard COM.
	STDMETHOD(SetNoun)(CClsWizClass *pClass, CClsWizNoun *pNoun) PURE; 	// Non-standard COM.
	STDMETHOD(GetClassDisplayString)(CClsWizClass *pClass, CString &strDisplay) PURE; 	// Non-standard COM.
	STDMETHOD(GetClassFunctionName)(CClsWizClass *pClass, CClsWizVerb *pVerb, CString &strName) PURE; 	// Non-standard COM.
	STDMETHOD(IsClassVerbHandled)(CClsWizClass *pClass, CClsWizVerb *pVerb) PURE; 	// Non-standard COM.
	STDMETHOD(AddClassVerbHandler)(CClsWizClass *pClass, CClsWizVerb *pVerb, BOOL bVerbose) PURE; 	// Non-standard COM.
	STDMETHOD(RemoveClassVerbHandler)(CClsWizClass *pClass, CClsWizVerb *pVerb) PURE; 	// Non-standard COM.
	STDMETHOD(FinishClassChanges)(CClsWizClass *pClass, BOOL bCommit = TRUE) PURE; 	// Non-standard COM.
	STDMETHOD(ClassNameFromResource)(LPCSTR lpszPathName, LPCSTR lpszResourceName, LPCSTR lpszResourceType, CString& rstrClass) PURE;  // Non-standard COM.
	STDMETHOD(GetChangeClasses)(IChangeClasses** ppChangeClasses) PURE;
	STDMETHOD(GetCreateClassesInnerDlg)(ICreateClasses2** ppCreateClasses2) PURE;
	STDMETHOD(GetClassFilterType)(CClsWizClass* pClass, char *pchFilterType) PURE; 	// Non-standard COM.
	STDMETHOD(SetClassFilterType)(CClsWizClass* pClass, char chFilterType, BOOL fWriteToCLW = TRUE) PURE; 	// Non-standard COM.
	STDMETHOD(SetDefaultConfiguration)(LPCTSTR lpszConfig) PURE;
	STDMETHOD(GetCtlDefaultEvent)(LPCTSTR lpszIDCtl, LPCTSTR lpszTypeCtl, CString &rstrEventDef) PURE;
	STDMETHOD(UpdateClassWizardInfo)() PURE;
	STDMETHOD(UpdateClassWizardInfoForRC)(LPCSTR lpszRCFile) PURE;
	STDMETHOD(GetResourceRebuildStatus)(BOOL* pbDoRebuild) PURE;
	STDMETHOD(SetResourceRebuildStatus)(BOOL bDoRebuild) PURE;
	STDMETHOD(RemoveFromClassWizard)(LPCSTR lpszClassName) PURE;
	STDMETHOD(RenameClass)(LPCSTR lpszOldClassName, LPCSTR lpszNewClassName) PURE;
	STDMETHOD(GetSourceFileName)(CClsWizClass* pClass, CString& rstrSourceFile) PURE;	// Non-standard COM.
	STDMETHOD(GetHeaderFileName)(CClsWizClass* pClass, CString& rstrHeaderFile) PURE; // Non-standard COM.

	// These two methods work together to help you access what ClassWizard knows about automation.
	// If *pwOleIndex is (WORD)-1, then ClassWizard doesn't know anything about the type in question.
	// There is a distinction between a type as used for a return type and as used as a parameter type,
	// so be sure to specify bIsReturnType accordingly.
	STDMETHOD(GetOleIndex)(LPCTSTR szName, oleNameType oleWhichName, BOOL bIsReturnType, WORD* pwOleIndex) PURE;
	STDMETHOD(GetOleType)(WORD wOleIndex, oleNameType oleWhichName, BOOL bIsReturnType, CString& rstrName) PURE;	// Non-standard COM
};

/////////////////////////////////////////////////////////////////////////
// IChangeClasses Interface
// This interface allows you to add properties and methods to existing 
// classes.
/////////////////////////////////////////////////////////////////////////
#undef  INTERFACE
#define INTERFACE IChangeClasses
DECLARE_INTERFACE_(IChangeClasses, IUnknown)
{
	STDMETHOD(AddProperty)(THIS_ LPCSTR pszClass) PURE;
	STDMETHOD(AddMethod)(THIS_ LPCSTR pszClass) PURE;
	STDMETHOD (AddEvent) (THIS_ LPCSTR pszClass) PURE;
}; 

/////////////////////////////////////////////////////////////////////////
// ICreateClasses2 Interface
// This interface allows you to manipulate ClassWizard's 'Create New Class'
// dialog as a child dialog instead of as a stand-alone one.
/////////////////////////////////////////////////////////////////////////
#undef  INTERFACE
#define INTERFACE ICreateClasses2
DECLARE_INTERFACE_(ICreateClasses2, IUnknown)
{
	// INewClass methods
	STDMETHOD(SetName)(THIS_ LPCSTR pszName) PURE;
	STDMETHOD(SetBaseClass)(THIS_ LPCSTR pszName) PURE;
	STDMETHOD(SetFiles)(THIS_ LPCSTR pszHeader, LPCSTR pszImplementation) PURE;

	STDMETHOD(SetOLEOptions)(THIS_ UINT nFlags, LPCSTR pszName) PURE;

	// Only for classes that require a dialog template.
	STDMETHOD(SetDialogTemplate)(THIS_ LPCSTR pszDialogID) PURE;

	// These methods are used to allow the user to change class information.
	STDMETHOD(SetNameFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetBaseClassFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetFilesFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetOLEOptionsFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetDialogTemplateFlags)(THIS_ UINT nFlags) PURE;

	// These methods are used to manipulate the window
	STDMETHOD(DoCreate)(THIS_ CWnd* pParentWnd) PURE;
	STDMETHOD(DoDestroyWindow)(THIS) PURE;
	STDMETHOD(OnInitDialog)(THIS) PURE;
    STDMETHOD(DoSetWindowPos)(THIS_ const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags) PURE;
    STDMETHOD(DoShowWindow)(THIS_ int nCmdShow) PURE;
    STDMETHOD(DoEnableWindow)(THIS_ BOOL bEnable) PURE;
	STDMETHOD(DoSetFocus)(THIS_ BOOL bFirst) PURE;
	STDMETHOD(DoUpdateData)(THIS_ BOOL bSaveAndValidate) PURE;
	STDMETHOD(ProcessOnOK)(THIS) PURE;
	STDMETHOD(GetAutoTrackFiles)(THIS_ BOOL* pbAutoTrack) PURE;
	STDMETHOD(SetAutoTrackFiles)(THIS_ BOOL bAutoTrack) PURE;

	// This method actually creates the class.
	STDMETHOD(CreateClass)(THIS) PURE;

	// Error handling for during CreateClass.  We may need to call these
	// if we only called into ICreateClass programatically.  (UI path
	// includes checking with the user in these situations and handling
	// problems that way)
	STDMETHOD(SetGuidFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetResFlags)(THIS_ UINT nFlags) PURE;

	// Information retrieval.
	STDMETHOD(GetName)(THIS_ LPSTR* ppszName) PURE;
	STDMETHOD(GetBaseClass)(THIS_ LPSTR* ppszName) PURE;
	STDMETHOD(GetFiles)(THIS_ LPSTR* ppszHeader, LPSTR* ppszImplementation) PURE;
	STDMETHOD(GetOLEOptions)(THIS_ UINT* pnFlags, LPSTR* ppszName) PURE;
	STDMETHOD(GetDialogTemplate)(THIS_ LPSTR* ppszDialogID) PURE;

	STDMETHOD(GetFormStrings)(THIS_ UINT nTypeForm, LPFORMSTRINGS *ppFormStrings) PURE;
}; 


#endif	// __CLWZAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\codemgrsupportapi.h ===
#ifndef __CODEMGRSUPPORTAPI__
#define __CODEMGRSUPPORTAPI__

// These interfaces are intended for internal use inside the Code Manager or for 
// ClassView's direct benefit (there are MFC parameters on some methods, fer instance).

interface ICodeManagerMenuBuilder;	// menu builder for ClassView

interface ICodeManagerSupport_Internal;	// private interface used by the code manager to talk to the 
										// language packages

class VCDesignElementI;

// nExtra parameter constants to methods within ICodeManagerMenuBuilder
// NOTE: keep these in sync with the elements of the same names in WizRsrv.h
#ifndef COM_MAP_NONE
#define COM_MAP_NONE         0
#define COM_MAP_IMPL         1
#define COM_MAP_IMPL_PROP    2
#endif

/////////////////////////////////////////////////////////////////////////////
// ICodeManagerMenuBuilder
//   This interface is used to build menus for the DO-based ClassView
//   It is non-standard COM to fit with the MSDEV architecture for context menus.  The interface 
//   will need to change dramatically (or go away?) when we move to the new shell.

#undef  INTERFACE
#define INTERFACE ICodeManagerMenuBuilder
DECLARE_INTERFACE_(ICodeManagerMenuBuilder, IUnknown)
{
	STDMETHOD(GetCmdIDs)(VCDesignElementI* pDO, CWordArray& aVerbs, CWordArray& aCmds, int nExtra) PURE;
	STDMETHOD(OnCmdMsg)(VCDesignElementI* pDO, UINT nID, int nCode, void* pExtra, LPBOOL lpRetVal, 
		CWnd* slobWnd, int nExtra) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ICodeManagerSupport_Internal
//   This interface is private to within the code manager and shouldn't be used by
//   code manager clients.  
//   Pay no attention to the man behind the curtain.  :-)

#undef  INTERFACE
#define INTERFACE ICodeManagerSupport_Internal
DECLARE_INTERFACE_(ICodeManagerSupport_Internal, IUnknown)
{
	// basic communication between the parts of the Code Manager
	STDMETHOD(put_MainCodeManager)(ICodeManager* pvCodeManager) PURE;
	STDMETHOD(put_AlternativeCodeManagerSupport)(ICodeManagerSupport_Internal* pvAlternative) PURE;

	// general services
	STDMETHOD(get_Lexer)(LPCTSTR lpszFilename, ICodeMgrLexer** ppvLexer, BOOL* pbHandled) PURE;
	STDMETHOD(get_LexerForLanguage)(short nParseLanguage, ICodeMgrLexer** ppvLexer, BOOL* pbHandled) PURE;
	STDMETHOD(put_SelectedProject)(HPROJECT hProject) PURE;

	// services for specific objects
	STDMETHOD(GotoDialogEditorLocation)(HPROJECT hProject, IINST iinstClass, LPCTSTR lpszDialogID, 
		BOOL* pbHandled) PURE;
	STDMETHOD(get_FileName)(IINST iinst, long nFileType, short nPathType, BSTR* pbstrFileName, 
		BOOL* pbHandled) PURE;
	STDMETHOD(get_AllFileNames)(IINST iinst, long nFileType, short nPathType, IDOStrings** ppvFiles,
		BOOL* pbHandled) PURE;
	STDMETHOD(GetDerivedClasses)(short nParseLanguage, HPROJECT hProject, LPCTSTR lpszBaseClass, 
		BOOL bImmediateOnly, ICodeMgrBscItems** ppvClasses, BOOL* pbHandled) PURE;
	STDMETHOD(GetInclude)(HPROJECT hProject, long nFileType, LPCTSTR lpszClassName, BOOL bMakeRelative,  
		LPCTSTR lpszRelativeWhere, BSTR* pbstrIncludeFile, BOOL* pbHandled) PURE;
	STDMETHOD(BreakUpParameter)(IINST iinstParent, LPCTSTR lpszFullParam, BOOL bDoErrorChecks,
		BSTR* pbstrParamType, BSTR* pbstParamName, BSTR* pbstrParamDefault, BSTR* pbstrParamComments, 
		BSTR* pbstrParamAttribs, BOOL* pbHandled) PURE;

	// ActiveX associations
	STDMETHOD(HasAssociations)(HPROJECT hProject, IINST iinstToAssoc, long nAssociationMajorType, 
		long nAssociationMinorType, BOOL* bHasAssoc, BOOL* pbHandled) PURE;
	STDMETHOD(GetAssociations)(HPROJECT hProject, IINST iinstToAssoc, long nAssociationMajorType, 
		long nAssociationMinorType, ICodeMgrBscItems** ppvBscItems, BOOL* pbHandled) PURE;
	STDMETHOD(GetAssociation)(HPROJECT hProject, IINST iinstToAssoc, long nAssociationMajorType, 
		long nAssociationMinorType, LPCTSTR lpszNameToAssocTo, IBscPersistentItem** ppvBscItem, 
		long* pnType, BSTR* pbstrAttributes, BOOL* pbHandled) PURE;
	STDMETHOD(GetAssociationName)(HPROJECT hProject, IINST iinstToAssoc, long nAssociationMajorType, 
		long nAssociationMinorType, long nPresentHow, long nAssociatedHow, BSTR* pbstrName, 
		BOOL* pbHandled) PURE;
	STDMETHOD(GetAssociatedFunctions)(IINST iinstClass, IINST iinstIFace, long nAssociationMajorType,
		ICodeMgrBscItems** ppvFunctions, BOOL* pbHandled) PURE;
	STDMETHOD(IsAssociatedFunction)(IINST iinstFunction, IINST iinstIFace, long nAssociationMajorType, BOOL* pbHandled) PURE;

	// basic transaction notifications
	STDMETHOD(NotifyStartTransaction)() PURE;
	STDMETHOD(NotifyBeforeCommitTransaction)() PURE;
	STDMETHOD(NotifyAfterCommitTransaction)() PURE;
	STDMETHOD(NotifyBeforeAbortTransaction)() PURE;
	STDMETHOD(NotifyAfterAbortTransaction)() PURE;

	// transaction support services (don't require transaction to use)
	STDMETHOD(GetSingleNamedMember)(IINST iinstParent, short nParseLanguage, HPROJECT hProject, long nMemberKind, 
		LPCTSTR lpszMemberName, IINST* piiMember, BOOL* pbHandled) PURE;
	STDMETHOD(GetMultipleNamedMembers)(IINST iinstParent, short nParseLanguage, HPROJECT hProject, long nMemberKind, 
		LPCTSTR lpszMemberName, ICodeMgrBscItems** ppvItems, BOOL* pbHandled) PURE;
	STDMETHOD(GetMemberConflicts)(IINST iinstClass, long nMemberKind, LPCTSTR lpszMembere, IINST* piinstMember, 
		BOOL* pbHandled) PURE;
	STDMETHOD(CreateFunctionStubBody)(IINST iinstClass, VARTYPE vt, BSTR* pbstrReturn, BOOL* pbHandled) PURE;
	STDMETHOD(GetAutomationStyle)(IINST iinst, memberAutomationStyles* pmemAutoStyle, BOOL* pbHandled) PURE;
	STDMETHOD(ParseName)(short nParseLanguage, long nParseType, LPCTSTR lpszParseString, BSTR* pbstrResponse,
		BOOL* pbHandled) PURE;
	STDMETHOD(FindGlobalInsertLocation)(long nHint, ICodeMgrTextEditor* pEditor, LPCSTR pszFileName, 
		ULONG* puActualLine, ULONG* puActualColumn, BSTR* pbstrTab, BOOL* pbHandled) PURE;
	STDMETHOD(FindScopedInsertLocation)(IINST iinst, long nMemberKind, short nAccessType, BOOL bInParentDefn, 
		long nHintType, LPCTSTR lpszHintName, BOOL bMemberAddAfter, BSTR* pbstrFilename, ULONG* pnLine, 
		ULONG* pnColumn, BSTR* pbstrTab, BOOL* pbHandled) PURE;
	STDMETHOD(IsValidSymbol)(HPROJECT hProject, short nParseLanguage, long nObjectType, LPCTSTR lpszName, 
		BOOL* pbIsValidSymbol, BOOL* pbHandled) PURE;
	STDMETHOD(IsReservedSymbol)(HPROJECT hProject, short nParseLanguage, long nObjectType, LPCTSTR lpszName, 
		SymbolConflictType* pnSymbolType, BOOL* pbHandled) PURE;
	STDMETHOD(FindAnsiToken)(ICodeMgrTextEditor* pEditor, LPCTSTR lpszFilename, ULONG uLineStart, 
		LPCTSTR lpszToken, BOOL bFuzzyMatch, ULONG* puLineHit, ULONG* puColumnHit, 
		BOOL* pbHandled) PURE;

	// transaction support services for files
	STDMETHOD(AddFile)(HPROJECT hProject, LPCTSTR lpszFilename, BOOL* pbHandled) PURE;

	// generic project modification services
	STDMETHOD(AddInclude)(short nParseLanguage, HPROJECT hProject, long nAddWhere, LPCTSTR lpszClassName, 
		LPCTSTR lpszIncludeName, LPCTSTR lpszAttribs, LPCTSTR lpszConditions, LPCTSTR lpszComments, long nHintType, 
		LPCTSTR lpszHintName, BOOL bAddAfter, BOOL* pbHandled) PURE;

	// generic IINST-based modification services
	STDMETHOD(put_Name)(IINST iinst, LPCTSTR lpszName, BOOL* pbHandled) PURE;
	STDMETHOD(put_Contents)(IINST iinst, LPCTSTR lpszContents, BOOL* pbHandled) PURE;
	STDMETHOD(put_AllAttributes)(IINST iinstParent, LPCTSTR lpszAttribs, BOOL* pbHandled) PURE;
	STDMETHOD(AddAttribute)(IINST iinst, LPCTSTR lpszAttributeName, LPCTSTR lpszAttributeValue, 
		LPCTSTR lpszAttributeComment, long nHintType, LPCTSTR lpszHintName, BOOL bAddAfter, 
		BOOL* pbHandled) PURE;
	STDMETHOD(put_AccessType)(IINST iinst, short nAccessType, BOOL* pbHandled) PURE;
	STDMETHOD(GetOneLine)(IINST iinst, long nFileType, long nLineNumber, BSTR* bstrLineContents, 
		BOOL* pbHandled) PURE;
	STDMETHOD(SetOneLine)(IINST iinst, long nFileType, long nLineNumber, LPCTSTR lpszText, 
		BOOL* pbHandled) PURE;
	STDMETHOD(InsertText)(IINST iinst, long nFileType, LPCTSTR lpszText, long nLineNumber, long nColumn, 
		BOOL bFullLine, BOOL* pbHandled) PURE;
	STDMETHOD(Delete)(IINST iinst, short nWhichPart, short nCommentOrDeletePart, BOOL* pbHandled) PURE;
	STDMETHOD(put_Type)(IINST iinst, LPCTSTR lpszType, BOOL* pbHandled) PURE;
	STDMETHOD(put_Comment)(IINST iinst, LPCTSTR lpszComment, long nHintType, LPCTSTR lpszHintName,
		BOOL* pbHandled) PURE;

	// IINST-based modification services that require that the IINST be something that has members, 
	// like a class
	STDMETHOD(AddMember)(IINST iinstClass, short nParseLanguage, long nMemberKind, LPCTSTR lpszMemberName, 
		LPCTSTR lpszMemberType, short nAccessType, LPCTSTR lpszAttributes, LPCTSTR lpszComments, 
		LPCTSTR lpszConditions, LPCTSTR lpszBody, long nHintType, LPCTSTR lpszHintName, BOOL bMemberAddAfter, 
		BOOL* pbHandled) PURE;
	STDMETHOD(AddMemberBody)(IINST iinstClass, short nParseLanguage, long nMemberKind, LPCTSTR lpszMemberName, 
		LPCTSTR lpszMemberType, LPCTSTR lpszComments, LPCTSTR lpszMemberBody, LPCTSTR lpszConditions, 
		long nHintType, LPCTSTR lpszHintName, BOOL bMemberAddAfter, BOOL* pbHandled) PURE;
	STDMETHOD(AddBaseClass)(IINST iinstClass, LPCTSTR lpszBaseClass, short nAccessType, long nHintType, 
		LPCTSTR lpszHintName, BOOL* pbHandled) PURE;

	// IINST-based modification services that require that the IINST be something that takes parameters, 
	// like a function
	STDMETHOD(SetParameters)(IINST iinstObject, short nWhichPart, LPCTSTR lpszParameters, 
		BOOL* pbHandled) PURE;
	STDMETHOD(AddParameter)(IINST iinstObject, short nParamNum, BOOL bAddAfter, LPCTSTR lpszNewParam,
		LPCTSTR lpszNewParamAttributes, LPCTSTR lpszNewParamComments, BOOL* pbHandled) PURE;
	STDMETHOD(put_ParameterName)(IINST iinstObject, short nParamNum, LPCTSTR lpszName, BOOL* pbHandled) PURE;
	STDMETHOD(put_ParameterValue)(IINST iinstObject, short nParamNum, LPCTSTR lpszValue, BOOL* pbHandled) PURE;
	STDMETHOD(DeleteParameter)(IINST iinstObject, short nParamNum, BOOL bHardDelete, BOOL* pbHandled) PURE;
	STDMETHOD(put_ParameterType)(IINST iinstObject, short nParamNum, LPCTSTR lpszType, BOOL* pbHandled) PURE;
	STDMETHOD(put_ParameterComment)(IINST iinstObject, short nParamNum, LPCTSTR lpszComment, long nHintType, 
		LPCTSTR lpszHintName, BOOL* pbHandled) PURE;
	STDMETHOD(put_ParameterAttributes)(IINST iinstObject, short nParamNum, LPCTSTR lpszAttribs, BOOL* pbHandled) PURE;
	STDMETHOD(AddParameterAttribute)(IINST iinstObject, short nParamNum, LPCTSTR lpszAttributeName, 
		LPCTSTR lpszAttributeValue, LPCTSTR lpszAttributeComment, long nHintType, LPCTSTR lpszHintName, 
		BOOL bAddAfter, BOOL* pbHandled) PURE;
	STDMETHOD(DeleteParameterAttribute)(IINST iinstObject, short nParamNum, LPCTSTR lpszAttributeName,
		BOOL bHardDelete, BOOL* pbHandled) PURE;
	STDMETHOD(put_ParameterAttribute)(IINST iinstObject, short nParamNum, LPCTSTR lpszOldAttributeName,
		LPCTSTR lpszAttributeName, LPCTSTR lpszAttributeValue, LPCTSTR lpszAttributeComment, BOOL* pbHandled) PURE;

	// IINST-based modification services for adding elements to a map or enum.  bstrValue only has 
	// meaning for adding an enum item
	STDMETHOD(AddItem)(IINST iinstObject, LPCTSTR lpszItem, LPCTSTR lpszValue, LPCTSTR lpszComments, 
		long nHintType, LPCTSTR lpszHintName, BOOL bAddAfter, BOOL* pbHandled) PURE;

	// menu support services for ICodeManagerMenuBuilder.  These are non-standard COM and will need
	// to be changed (removed?) when we change shell architecture
	STDMETHOD(GetCmdIDs)(VCDesignElementI* pDO, CWordArray& aVerbs, 
		CWordArray& aCmds, int nExtra) PURE;
	STDMETHOD(OnCmdMsg)(VCDesignElementI* pDO, UINT nID, int nCode, void* pExtra, LPBOOL lpRetVal, 
		CWnd* slobWnd, int nExtra) PURE;
};

#endif	// __CODEMGRSUPPORTAPI__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\commguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	COMMGUID.H
//		Common package interface ids.

// {ECA6AE20-DE20-11cf-AD07-00A0C9034965}
DEFINE_GUID(ICommandProvider, 
0xeca6ae20, 0xde20, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dbgapi.h ===
//
// DBGAPI.H
//    Debug package interface declarations.

#ifndef __DBGAPI_H__
#define __DBGAPI_H__

#ifndef OSDEBUG4
typedef FD FAR *  LPFD;
typedef RD FAR *  LPRD;
#endif // OSDEBUG4

interface IDebugCmd;
interface IOSDebug;
interface IExprEval;
interface ISymbolHandler;
interface IMiscDebug;

typedef IDebugCmd *     LPDEBUGCMD;
typedef IOSDebug  *     LPOSDEBUG;
typedef IExprEval *     LPEXPREVAL;
typedef ISymbolHandler* LPSYMBOLHANDLER;
typedef IMiscDebug *    LPMISCDEBUG;

// BPChange Action Items
#define BP_DISABLE   0
#define BP_ENABLE    1
#define BP_CLEAR     2

//
// IDebugCmd interface
//
#undef  INTERFACE
#define INTERFACE IDebugCmd

DECLARE_INTERFACE_(IDebugCmd, IUnknown)
{
   // IUnknown methods
   STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)(THIS) PURE;
   STDMETHOD_(ULONG,Release)(THIS) PURE;

   // IDebugCmd methods

//   Attach - not sure how to do it

//   Kill - have to wait; not sure its purpose

   // This routine changes the current Frame to the nFrameNumber one.
   // If successful, it returns S_OK.
   // Windbg equivalent: % <num>
   STDMETHOD(FrameChange)(
      INT nFrameNumber,
      PCXF pcxf = NULL,
      BOOL fUpdateDisplay = TRUE
   ) PURE;

   // This routine changes the main window title of the debugger.
   // If successful, it returns TRUE.
   // Windbg equivalent: .title <title>
   STDMETHOD(SetTitle)(
      LPSTR lszTitle
   ) PURE;

   // This routine changes the case sensitivity.
   // Used in windbg command options dialog.
   STDMETHOD(SetCaseSensitive)(
      BOOL fcSensitive
   ) PURE;

   // This routine changes the radix settings between hexadecimal and decimal
   // Windbg equivalent: N <8|16>
   STDMETHOD(SetRadix)(
      BOOL fdecimal
   ) PURE;

   // This routine returns the current radix settings.  It can be decimal
   // or hexadecimal.
   // Windbg equivalent: N
   STDMETHOD(IsRadixDecimal)(
      void
   ) PURE;

   // This routine returns TRUE and the next register structure in the
   // list.  The first register strucutres is returned if phwri is hwriNull.
   // Windbg equivalent: fr <reg>=<value>
   STDMETHOD(InitRWI)(
      RD    rd,
      LPRWI lprwi
   ) PURE;

   // This routine returns TRUE if the lprui register was successfully
   // updated with the data in lpur.
   // Windbg equivalent: fr <reg>=<value>
   STDMETHOD(WriteRegister)(
      LPRUI    lprui,
      LPUR     lpur
   ) PURE;

   STDMETHOD(LockRegister)(
      HRWI hrwi1,
      LPRWI *hrwi2
   ) PURE;

   STDMETHOD(UnlockRegister)(
      HRWI hrwi
   ) PURE;

   // Given a thread object, this routine updates it with info
   // from the next thread object in the list.
   // If fFirstThread is TRUE, this routine updates the given
   // thread object with the first thread object info.
   // Windbg equivalent: ~, F, Z
   STDMETHOD(GetThreadInfo)(
      BOOL           fFirstThread,
      THREAD_OBJECT  *pObject
   ) PURE;

   // This routine either suspends or resumes execution of the given thread
   // Windbg equivalent: F, Z
   STDMETHOD(SetThreadState)(
      THREAD_OBJECT  *pObject,
      BOOL           fSuspend
   ) PURE;

   // This routine moves cb bytes starting from addr0 to addr1
   // If successful, TRUE is returned.  It handles overlapped
   // moves correctly.  On failure, the content of the memory
   // is not restored.
   // Windbg equivalent: M
   STDMETHOD(MovMemory)(
      ADDR        addr0,
      size_t      cb,
      ADDR        addr1
   ) PURE;

   // This routine writes bBuff containing cb bytes into
   // memory starting at addr location
   // Windbg equivalent: E, FI
   STDMETHOD(EnterMemory)(
      ADDR        addr,
      size_t      cb,
      void FAR    *bBuff,
      DWORD       dwRepeatCount = 1,
      ADDR        *paddrFail = NULL
   ) PURE;

   // This routine performs a Go and if there is a first
   // chance exception, it will uses the given argument
   // to decide whether the exception should be passed to
   // the debuggee or being ignored.
   // Windbg equivalent: GH, GN
   STDMETHOD(GoException)(
      BOOL fHandled
   ) PURE;

   // This routine takes a bp and allows one of the three
   // operations on it, namely disable, enable, and remove.
   // Windbg equivalent: BC, BE, BD
   STDMETHOD(BPChange)(
      PBREAKPOINTNODE pbpn,
      INT             iAction,
      BOOL            fUpdateUI
   ) PURE;

   // This routine takes a bp declarations
   // and add it into the list.  Currently it
   // takes many arguments but will be refined
   // in the future.
   // Windbg equivalent: BP, BA
   STDMETHOD(BPSet)(
      BREAKPOINTTYPES bpType,
      LPTSTR lszLocation,
      LPTSTR lszExpression,
      LPTSTR lszLength,
      LPTSTR lszPassCnt,
      LPTSTR lszMessage,
      INT    *iRet
   ) PURE;

   // This routine takes the name of a debuggee,
   // its arguments,and start the debugging
   // Windbg equivalent: .start
   STDMETHOD(Start)(
      LPTSTR lszLocalExe,
      char * szDebuggeeArgs
   ) PURE;
   // This routine stops the debugging process - currently
   // not supported by windbg cmd window
   // Windbg equivalent: N/A
   STDMETHOD(Stop)(void) PURE;

   // This routine performs a halt to the debugging process
   // Windbg equivalent: ^C, .break
   STDMETHOD(Break)(void) PURE;

   // The Go routine should not pop up dialog since it is used in a command window
   // Windbg equivalent: g
   STDMETHOD(Go)(void) PURE;

   // This routine restarts the debuggee for debugging
   // Windbg equivalent: l
   STDMETHOD(Restart)(void) PURE;

   // The StepOver routine should take a repeat count arg
   // Windbg equivalent: P
   STDMETHOD(StepOver)(void) PURE;

   // The StepOut routine stops on returning from a routine - currently
   // not supported by windbg cmd window
   // Windbg equivalent: N/A
   STDMETHOD(StepOut)(void) PURE;

   // The TraceInto routine should take a repeat count arg
   // Windbg equivalent: T
   STDMETHOD(TraceInto)(void) PURE;

   // Misc low level routines
   // Windbg equivalent: BA, BP, BC, BD, BE, BL (helper)
   STDMETHOD(BHFirstBPNode)(PBREAKPOINTNODE *hBreakPointNode) PURE;
};

//
// IOSDebug interface
//
#undef  INTERFACE
#define INTERFACE IOSDebug

DECLARE_INTERFACE_(IOSDebug, IUnknown)
{
   // IUnknown methods
   STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)(THIS) PURE;
   STDMETHOD_(ULONG,Release)(THIS) PURE;

   // IOSDebug methods

   //
   // Target Load/Unload Operations
   //

   // Support Windbg command: .kill
   STDMETHOD(COSDProgramFree)(
      HPID hpid,
      XOSD *xosd
   ) PURE;

#ifdef OSDEBUG4
   // Support Windbg command: AttachDebuggee
   STDMETHOD(COSDSetPath)(
      HPID hpid,
      DWORD fSet,
      LPTSTR lszPath,
      XOSD  *xosd
   ) PURE;
#endif // OSDEBUG4

/*
   STDMETHOD(COSDProgramLoad)(
      HPID   hpid,
      LPTSTR lszRemoteExe,
      LPTSTR lszArgs,
      LPTSTR lszWorkingDir,
      LPTSTR lszDebugger,
      DWORD  dwFlags,
      XOSD   *xosd
   ) PURE;
*/

   STDMETHOD(COSDDebugActive)(
      HPID hpid,
      LPVOID lpvData,
      DWORD cbData,
      XOSD  *xosd
   ) PURE;

   //
   // Exception Operations
   //

#ifdef OSDEBUG4
   // Support Windbg command: SXD, SXE
   STDMETHOD(COSDSetExceptionState)(
      HPID hpid,
      HTID htid,
      LPEXCEPTION_DESCRIPTION lpExd,
      XOSD  *xosd
   ) PURE;
#endif // OSDEBUG4

#ifdef OSDEBUG4
   // Support Windbg command: SX
   STDMETHOD(COSDGetExceptionState)(
      HPID hpid,
      HTID htid,
      LPEXCEPTION_DESCRIPTION lpExd,
      EXCEPTION_CONTROL exf,
      XOSD  *xosd
   ) PURE;
#endif // OSDEBUG4

   //
   // Assemble Operations
   //

   // Support Windbg command: .list, DC, U
   STDMETHOD(COSDUnassemble)(
      HPID hpid,
      HTID htid,
      LPSDI lpsdi,
      XOSD  *xosd
   ) PURE;

#ifdef OSDEBUG4
   STDMETHOD(COSDGetPrevInst)(
      HPID hpid,
      HTID htid,
      LPADDR lpaddr,
      LPUOFFSET lpuoffset,
      XOSD  *xosd
   ) PURE;
#endif // OSDEBUG4

   //
   // Stack Operations
   //

   STDMETHOD(COSDGetFrame)(
       HPID hpid,
       HTID htid,
       DWORD cFrame,
       LPHTID lphtid,
       XOSD *xosd
   ) PURE;

   //
   // Address Operations
   //

   // Support Windbg command: C, FI
   STDMETHOD(COSDSetAddr)(
      HPID hpid,
      HTID htid,
      ADR adr,
      LPADDR lpaddr,
      XOSD  *xosd
   ) PURE;

   // Support Windbg command: D
   STDMETHOD(COSDGetAddr)(
      HPID hpid,
      HTID htid,
      ADR adr,
      LPADDR lpaddr,
      XOSD  *xosd
   ) PURE;

   // Support Windbg command: K
   STDMETHOD(COSDUnFixupAddr)(
      HPID hpid,
      HTID htid,
      LPADDR lpaddr,
      XOSD  *xosd
   ) PURE;

   // Subsitute for OSDPtrace
   STDMETHOD(COSDFixupAddr)(
      HPID hpid,
      HTID htid,
      LPADDR lpaddr,
      XOSD  *xosd
   ) PURE;

   // Support Windbg command: K, LN
   STDMETHOD(COSDSetEmi)(
      HPID hpid,
      HTID htid,
      LPADDR lpaddr,
      XOSD  *xosd
   ) PURE;

   STDMETHOD(COSDRegisterEmi)(
      HPID hpid,
      HEMI hemi,
      LPTSTR lsz,
      XOSD  *xosd
   ) PURE;

#ifdef OSDEBUG4
   STDMETHOD(COSDUnRegisterEmi)(
      HPID hpid,
      HEMI hemi,
      XOSD  *xosd
   ) PURE;
#endif

   STDMETHOD(COSDCompareAddrs)(
       HPID hpid,
       LPADDR lpaddr1,
       LPADDR lpaddr2,
       LPDWORD lpResult,
       XOSD *xosd
   ) PURE;

#ifdef OSDEBUG4
   STDMETHOD(COSDGetMemInfo)(
       HPID hpid,
       HTID htid,
       LPMEMINFO lpMemInfo,
       XOSD *xosd
   ) PURE;
#endif // OSDEBUG4

   //
   // Registers Operations
   //

   // Support Windbg command: FR
   STDMETHOD(COSDGetRegDesc)(
      HPID hpid,
      HTID htid,
      DWORD ird,
      LPRD lprd,
      XOSD  *xosd
   ) PURE;

   // Support Windbg command: FR
   STDMETHOD(COSDGetFlagDesc)(
      HPID hpid,
      HTID htid,
      DWORD ifd,
      LPFD lpfd,
      XOSD  *xosd
   ) PURE;

   // Support Windbg command: FR
   STDMETHOD(COSDReadRegister)(
      HPID hpid,
      HTID htid,
      DWORD dwid,
      LPVOID lpValue,
      XOSD  *xosd
   ) PURE;

   // Support Windbg command: FR
   STDMETHOD(COSDReadFlag)(
      HPID hpid,
      HTID htid,
      DWORD dwId,
      LPVOID lpValue,
      XOSD  *xosd
   ) PURE;

   //
   // Target Information
   //

   // Support Windbg command: FR, K
   STDMETHOD(COSDGetDebugMetric)(
      HPID hpid,
      HTID htid,
      MTRC mtrc,
      LPVOID lpv,
      XOSD  *xosd
   ) PURE;

   //
   // Module Operations
   //

#ifdef OSDEBUG4
   // Support Windbg command: LM, LN
   STDMETHOD(COSDGetModuleList)(
      HPID hpid,
      HTID htid,
      LPTSTR lszModuleName,
      LPMODULE_LIST FAR * lplpModuleList,
      XOSD  *xosd
   ) PURE;
#endif // OSDEBUG4

   //
   // TL Operations
   //

   // Support Windbg command: DisconnectDebugger
   STDMETHOD(COSDDeleteTL)(
      HTL htl,
      XOSD  *xosd
   ) PURE;

   //
   // EM Operations
   //

   // Support Windbg command: DisconnectDebugger
   STDMETHOD(COSDDeleteEM)(
      HEM hem,
      XOSD  *xosd
   ) PURE;

   //
   // Process and Thread Operations
   //

   // Support Windbg command: DisconnectDebugger
   STDMETHOD(COSDDestroyPID)(   // same as OSDDestroyPID
      HPID hpid,
      XOSD  *xosd
   ) PURE;

#ifdef OSDEBUG4
   STDMETHOD(COSDDestroyTID)(
      HPID hpid,
      HTID htid,
      XOSD  *xosd
   ) PURE;
#endif // OSDEBUG4

   //
   // Memory Operations
   //

   // Subsitute for OSDPtrace
   STDMETHOD(COSDReadMemory)(
      HPID hpid,
      HTID htid,
      LPADDR lpaddr,
#ifdef OSDEBUG4 // fix should be in od.h
      LPVOID lpBuffer,
#else
      LPB    lpBuffer,
#endif
      DWORD cbBuffer,
      LPDWORD lpcbRead,
      XOSD  *xosd
   ) PURE;

/*
   STDMETHOD(COSDWriteMemory)(
      HPID hpid,
      HTID htid,
      LPADDR lpaddr,
      LPBYTE lpbBuffer,
      DWORD cbBuffer,
      LPDWORD lpcbWritten,
      XOSD  *xosd
   ) PURE;
*/

   //
   // Process and Thread Status
   //

   STDMETHOD(COSDGetObjectLength)(
      HPID hpid,
      HTID htid,
      LPADDR lpaddr,
      LPUOFFSET lpuoffStart,
      LPUOFFSET lpuoffLength,
      XOSD  *xosd
   ) PURE;

   STDMETHOD(COSDGetThreadStatus)(
       HPID hpid,
       HTID htid,
       LPTST lptst,
       XOSD *xosd
   ) PURE;

   STDMETHOD(COSDGetProcessStatus)(
       HPID hpid,
       LPPST lppst,
       XOSD *xosd
   ) PURE;

   //
   // Message Handling
   //

   STDMETHOD(COSDGetMsgMap)(
      HPID            hpid,
      HTID            htid,
      LPMESSAGEMAP*   lplpMessageMap,
      XOSD  *xosd
   ) PURE;

   STDMETHOD(COSDGetMessageMaskMap)(
      HPID hpid,
      HTID htid,
      LPMASKMAP FAR * lplpMaskMap,
      XOSD  *xosd
   ) PURE;

   //
   // OS Specific Services
   //

#ifdef OSDEBUG4
   STDMETHOD(COSDGetTaskList)(
      HPID hpid,
      LPTASKLIST FAR * lplpTaskList,
      XOSD  *xosd
   ) PURE;
#endif // OSDEBUG4

   STDMETHOD(COSDSystemService)(
       HPID hpid,
       HTID htid,
       SSVC ssvc,
       LPVOID  lpvData,
       DWORD cbData,
       LPDWORD lpcbReturn,
       XOSD *xosd
   ) PURE;
};

//
// IExprEval Interface
//
#undef  INTERFACE
#define INTERFACE IExprEval

DECLARE_INTERFACE_(IExprEval, IUnknown)
{
   // IUnknown methods
   STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)(THIS) PURE;
   STDMETHOD_(ULONG,Release)(THIS) PURE;

   // IExprEval methods
   // Required
   STDMETHOD(CEEFreeStr)(
      EEHSTR hszStr
   ) PURE;

   STDMETHOD(CEEParse)(
      char FAR *szExpr,
      uint radix,
      SHFLAG fCase,
      PHTM phTM,
      ushort FAR *pEnd,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEBindTM)(
      PHTM phTM,
      PCXT pcxt,
      SHFLAG fForceBind,
      SHFLAG fEnableProlog,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetExprFromTM)(
      PHTM phTM,
      PEERADIX pRadix,
      PEEHSTR phStr,
      ushort FAR *pEnd,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEFormatCXTFromPCXT)(
      PCXT pCXT,
      PEEHSTR phStr,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEFreeTM)(
      PHTM phTM
   ) PURE;

   STDMETHOD(CEEGetCXTLFromTM)(
      PHTM phTM,
      PHCXTL phCXTL,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetTMFromHSYM)(
      HSYM hSym,
      PCXT pcxt,
      PHTM phTM,
      ushort FAR *pEnd,
      SHFLAG fForceBind,
      SHFLAG fEnableProlog,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEFormatAddress)(
       PADDR paddr,
       char FAR *szAddr
   ) PURE;

   STDMETHOD(CEEGetHSYMList)(
      HDEP FAR *phSYML,
      PCXT pCxt,
      ushort mask,
      uchar FAR * pRE,
      SHFLAG fEnableProlog,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEFreeHSYMList)(
      HDEP FAR *phSYML
   ) PURE;

   // Optional
   STDMETHOD(CEEGetError)(
      PHTM phTM,
      EESTATUS Status,
      PEEHSTR phError,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEvaluateTM)(
      PHTM phTM,
      PFRAME pFrame,
      EEDSP style,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetValueFromTM)(
      PHTM phTM,
      uint Radix,
      PEEFORMAT pFormat,
      PEEHSTR phszValue,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetNameFromTM)(
      PHTM phTM,
      PEEHSTR phszName,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetTypeFromTM)(
      PHTM phTM,
      EEHSTR hszName,
      PEEHSTR phszType,
      ulong select,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEParseBP)(
      char FAR *pExpr,
      uint radix,
      SHFLAG fCase,
      PCXF pCxf,
      PTML pTML,
      ulong select,
      ushort FAR *pEnd,
      SHFLAG fEnableProlog,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEFreeTML)(
      PTML pTML
   ) PURE;

   STDMETHOD(CEEInfoFromTM)(
      PHTM phTM,
      PRI pReqInfo,
      PHTI phTMInfo,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEFreeTI)(
      PHTI phTI
   ) PURE;

   STDMETHOD(CEEFreeCXTL)(
      PHCXTL phCXTL
   ) PURE;

   STDMETHOD(CEEAssignTMToTM)(
      PHTM     phTMLeft,
      PHTM     phTMRight,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEIsExpandable)(
      PHTM     phTM,
      EEPDTYP  *eepdtyp
   ) PURE;

   STDMETHOD(CEEAreTypesEqual)(
      PHTM     phTMLeft,
      PHTM     phTMRight,
      SHFLAG   *shflag
   ) PURE;

   STDMETHOD(CEEcChildrenTM)(
      PHTM phTM,
      DWORD *pcChildren,
      PSHFLAG pVar,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetChildTM)(
      PHTM phTMIn,
      long iChild,
      PHTM phTMOut,
      ushort FAR *pEnd,
      EERADIX eeRadix,
      SHFLAG fCase,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEDereferenceTM)(
      PHTM phTMIn,
      PHTM phTMOut,
      ushort FAR *pEnd,
      SHFLAG fCase,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEcParamTM)(
      PHTM phTM,
      ushort FAR *pcParam,
      PSHFLAG pVarArg,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetParmTM)(
      PHTM phTMIn,
      ushort iParam,
      PHTM phTMOut,
      ushort FAR *pEnd,
      SHFLAG fCase,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetExtendedTypeInfo)(
      PHTM phTM,
      PETI pETI,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetAccessFromTM)(
      PHTM phTM,
      PEEHSTR phszAccess,
      ulong format,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEEnableAutoClassCast)(
      BOOL fNew
   ) PURE;

   STDMETHOD(CEEInvalidateCache)(
      void
   ) PURE;

   STDMETHOD(CEEcSynthChildTM)(
      PHTM phTM,
      long FAR *pcChildren,
      EESTATUS *eestatus
   ) PURE;

   STDMETHOD(CEEGetBCIA)(
       HTM * pHTM,
       PHBCIA pHBCIA,
       EESTATUS   *eestatus
   ) PURE;

   STDMETHOD(CEEFreeBCIA)(
       PHBCIA pHBCIA
   ) PURE;

   STDMETHOD(Evaluate)(
      LSZ    lpsz,
      PCXF   pcxf,
      PHTM   phTm,
      ushort *pEnd,
      EESTATUS *eestatus
   ) PURE;
};

//
// ISymbolHandler interface
//
#undef  INTERFACE
#define INTERFACE ISymbolHandler

DECLARE_INTERFACE_(ISymbolHandler, IUnknown)
{
   // IUnknown methods
   STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)(THIS) PURE;
   STDMETHOD_(ULONG,Release)(THIS) PURE;

   // ISymbolHandler methods
   // Required
   STDMETHOD(CSHCreateProcess)(
      HPDS  *hpdsOut
   ) PURE;

   STDMETHOD(CSHSetHpid)(
      HPID hpid
   ) PURE;

   STDMETHOD(CSHDeleteProcess)(
      HPDS hpds
   ) PURE;

   STDMETHOD(CSHChangeProcess)(
      HPDS hpds
   ) PURE;

   STDMETHOD(CSHGetSymName)(
      HSYM hsym,
      LSZ lszIn,
      LSZ *lszOut
   ) PURE;

   STDMETHOD(CSHAddrFromHsym)(
      LPADDR paddr,
      HSYM hsym
   ) PURE;

   STDMETHOD(CSHGetNextMod)(
      HEXE hexe,
      HMOD hmodIn,
      HMOD *hmodOut
   ) PURE;

   STDMETHOD(CSHSetCxt)(
      LPADDR paddr,
      PCXT pcxtIn,
      PCXT *pcxtOut
   ) PURE;

   STDMETHOD(CSHGethExeFromName)(
      LPTSTR ltszPath,
      HEXE *hexeOut
   ) PURE;

   STDMETHOD(CPHGetNearestHsym)(
      LPADDR   lpaddr,
      HEXE     hexe,
      PHSYM    phsym,
      CV_uoff32_t *cvoffOut
   ) PURE;

   STDMETHOD(CSLLineFromAddr)(
       LPADDR  lpaddr,
       LPW     lpwLine,
       SHOFF * lpcb,
       SHOFF * lpdb
   ) PURE;

   STDMETHOD(CSHWantSymbols)(
      HEXE  hexe
   ) PURE;

   STDMETHOD(CSHGetSymFName)(
      HEXE hexe,
      LSZ  *lszOut
   ) PURE;

   STDMETHOD(CSHGetDebugData)(
      HEXE hexe,
      LPDEBUGDATA *lpDebugDataOut
   ) PURE;

   STDMETHOD(CSHGetModNameFromHexe)(
      HEXE hexe,
      LSZ  *lszOut
   ) PURE;

   STDMETHOD(CSHLszGetErrorText)(
      SHE she,
      LSZ *lszOut
   ) PURE;

   STDMETHOD(CSHGetModule)(
      LPADDR paddrOp,
      LSZ    rgbName,
      LSZ    *lszOut
   ) PURE;

   STDMETHOD(CSHUnloadSymbolHandler)(
      BOOL fResetLists
   ) PURE;

   STDMETHOD(CSHFree)(
      LPV lpv
   ) PURE;

   STDMETHOD(CSHGetDebugStart)(
      HSYM hsym,
      UOFFSET *offOut
   ) PURE;

   STDMETHOD(CSHHModGetNextGlobal)(
      HEXE FAR *phexe,
      HMOD hmodIn,
      HMOD *hmodOut
   ) PURE;

   STDMETHOD(CSHGetSymbol)(
       LPADDR paddrOp,
       LPADDR paddrLoc,
       SOP    sop,
       LPODR  lpodr,
       LSZ    *lszOut
   ) PURE;

   STDMETHOD(CSHGetPublicAddr)(
      LPADDR paddr,
      LSZ    lszName
   ) PURE;

   STDMETHOD(CSHAddDll)(
      LSZ   lsz,
      BOOL  fDll,
      SHE   *sheOut
   ) PURE;

   STDMETHOD(CSHIsLabel)(
      HSYM hsym
   ) PURE;

   STDMETHOD(CSHSetDebuggeeDir)(
      LSZ lszDir
   ) PURE;

   STDMETHOD(CSHUnloadDll)(
      HEXE hexe
   ) PURE;

   STDMETHOD(CSHLoadDll)(
      LSZ  lszName,
      BOOL fLoading,
      SHE  *sheOut
   ) PURE;

   STDMETHOD(CSHAddDllsToProcess)(
      SHE *sheOut
   ) PURE;

   STDMETHOD(CSHHexeFromHmod)(
      HMOD hmod,
      HEXE *hexeOut
   ) PURE;

   STDMETHOD(CSHGetNextExe)(
      HEXE hexeIn,
      HEXE *hexeOut
   ) PURE;

   STDMETHOD(CSHGetCxtFromHmod)(
      HMOD hmod,
      PCXT pcxtIn,
      PCXT *pcxtOut
   ) PURE;

   STDMETHOD(CSHSetCxtMod)(
      LPADDR paddr,
      PCXT  pcxtIn,
      PCXT  *pcxtOut
   ) PURE;

   STDMETHOD(CSHFindNameInGlobal)(
      HSYM   hsym,
      PCXT   pcxt,
      LPSSTR lpsstr,
      SHFLAG fCase,
      PFNCMP pfnCmp,
      PCXT   pcxtOut,
      HSYM   *hSymOut
   ) PURE;

   STDMETHOD(CSHFindNameInContext)(
      HSYM    hSym,
      PCXT    pcxt,
      LPSSTR  lpsstr,
      SHFLAG  fCase,
      PFNCMP  pfnCmp,
      PCXT    pcxtOut,
      HSYM    *hSymOut
   ) PURE;

   STDMETHOD(CSHGoToParent)(
      PCXT pcxt,
      PCXT pcxtOut,
      HSYM *hSymOut
   ) PURE;

   STDMETHOD(CSHHsymFromPcxt)(
      PCXT pcxt,
      HSYM *hSymOut
   ) PURE;

   STDMETHOD(CSHNextHsym)(
      HMOD hmod,
      HSYM hSymIn,
      HSYM *hSymOut
   ) PURE;

   STDMETHOD(CSHCompareRE)(
      LPCH psym,
      LPCH pRe,
      SHFLAG *shflagOut
   ) PURE;

   STDMETHOD(CSHGetModName)(
      HMOD  hmod,
      LSZ *lszOut
   ) PURE;

   STDMETHOD(CSHGetExeName)(
      HEXE hexe,
      LSZ *lszOut
   ) PURE;

   STDMETHOD(CSHCanDisplay)(
      HSYM hsym
   ) PURE;

   STDMETHOD(CSHGetNearestHsym)(
      LPADDR paddr,
      HMOD hmod,
      int mDataCode,
      PHSYM phSym,
      UOFF32 *offOut
   ) PURE;

   STDMETHOD(CSHFindSymInExe)(
      HEXE hexe,
      LPSSTR lpsstr,
      BOOL fCaseSensitive,
      HSYM *hSymOut
   ) PURE;

   STDMETHOD(CSHModelFromAddr)(
      LPADDR   paddr,
      LPW      lpwModel,
      LPB      lpbModel,
      CV_uoff32_t FAR *pobMax,
      int      *Out
   ) PURE;

   STDMETHOD(CSHPublicNameToAddr)(
      PADDR loc,
      PADDR pMpAddr,
      LSZ   lszName,
      int   *Out
   ) PURE;

   STDMETHOD(CSHAddrToLabel)(
      LPADDR paddr,
      LSZ lsz
   ) PURE;

   STDMETHOD(CSHGetSymLoc)(
      HSYM  hsym,
      LSZ   lsz,
      UINT  cbMax,
      PCXT  pcxt,
      int   *Out
   ) PURE;

   STDMETHOD(CSHFIsAddrNonVirtual)(
      LPADDR paddr
   ) PURE;

   STDMETHOD(CSHIsFarProc)(
      HSYM hsym
   ) PURE;

   STDMETHOD(CSHGetFuncCXF)(
      PADDR    paddr,
      PCXF     pcxfIn,
      PCXF     *pcxfOut
   ) PURE;

   STDMETHOD(CSHIsInProlog)(
      PCXT     pcxt,
      SHFLAG *shflagOut
   ) PURE;

   STDMETHOD(CSHIsAddrInCxt)(
      PCXT     pcxt,
      LPADDR   paddr,
      SHFLAG *shflagOut
   ) PURE;

   STDMETHOD(CPHFindNameInPublics)(
      HSYM    hsym,
      HEXE    hexe,
      LPSSTR  lpsstr,
      SHFLAG  fCase,
      PFNCMP  pfnCmp,
      HSYM *hSymOut
   ) PURE;

   STDMETHOD(CTHGetTypeFromIndex)(
      HMOD hmod,
      THIDX index,
      HTYPE *htypeOut
   ) PURE;

   STDMETHOD(CTHGetNextType)(
      HMOD hmod,
      HTYPE hType,
      HTYPE *htypeOut
   ) PURE;

   STDMETHOD(CSHLpGSNGetTable)(
      HEXE hexe,
      LPV *Out
   ) PURE;

   STDMETHOD(CSHFindSymbol)(
      LSZ   lsz,
      PADDR lpaddr,
      LPASR lpasr
   ) PURE;

   STDMETHOD(CSLFLineToAddr)(
      HSF         hsf,
      WORD        line,
      LPADDR      lpaddr,
      SHOFF FAR   *lpcbLn,
      WORD FAR    *rgwNearestLines
   ) PURE;

   STDMETHOD(CSLNameFromHsf)(
      HSF hsf,
      LPCH *lpchOut
   ) PURE;

   STDMETHOD(CSLNameFromHmod)(
      HMOD hmod,
      WORD iFile,
      LPCH *lpchOut
   ) PURE;

   STDMETHOD(CSLFQueryModSrc)(
      HMOD hmod
   ) PURE;

   STDMETHOD(CSLHmodFromHsf)(
      HEXE hexe,
      HSF hsf,
      HMOD *hModOut
   ) PURE;

   STDMETHOD(CSLHsfFromPcxt)(
      PCXT pcxt,
      HSF *hsfOut
   ) PURE;

   STDMETHOD(CSLHsfFromFile)(
      HMOD hmod,
      LSZ lszFile,
      HSF *hsfOut
   ) PURE;

   STDMETHOD(CSLCAddrFromLine)(
      HEXE hexeStart,
      HMOD hmodStart,
      LSZ  lszFileT,
      WORD line,
      LPSLP FAR * lplpslp,
      int *Out
   ) PURE;

   STDMETHOD(CSHPdbNameFromExe)(
      LSZ lszExe,
      LSZ lszPdbName,
      UINT cbMax
   ) PURE;

   STDMETHOD(CSHGetExeTimeStamp)(
      LSZ   szExeName,
      ULONG *lplTimeStamp,
      SHE *sheOut
   ) PURE;

   STDMETHOD(CSHIsThunk)(
      HSYM hsym
   ) PURE;

   STDMETHOD(CSHIsDllLoaded)(
      HEXE hexe
   ) PURE;
};

//
// IMiscDebug
//
#undef  INTERFACE
#define INTERFACE IMiscDebug

DECLARE_INTERFACE_(IMiscDebug, IUnknown)
{
   // IUnknown methods
   STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)(THIS) PURE;
   STDMETHOD_(ULONG,Release)(THIS) PURE;

   // IMiscDebug style methods
   STDMETHOD(SYFixupAddr)(
      PADDR
   ) PURE;

   STDMETHOD(SYUnFixupAddr)(
      PADDR
   ) PURE;

   STDMETHOD(DebuggeeAlive)(
      void
   ) PURE;

   STDMETHOD(DebuggeeActive)(
      void
   ) PURE;

   STDMETHOD(DebuggeeRunning)(
      void
   ) PURE;

   STDMETHOD(UpdateDebuggerState)(
      WORD UpdateFlags
   ) PURE;

   // Support Windbg command: .list, K
   STDMETHOD(GetSourceFromAddr)(
      LPADDR   pAddr,
      LPSTR    SrcName,
      WORD     SrcLen,
      LONG FAR *pSrcLine,
      UOFFSET FAR *pDelta,
      HSF FAR  *lphsf
   ) PURE;

   // Support Windbg command: .list
   STDMETHOD(FindDoc)(
      LPCSTR fileName,
      PTDOC *ppTextDoc,
      BOOL  docOnly
   ) PURE;

   STDMETHOD(theRadix)(
      INT   **Out
   ) PURE;

   STDMETHOD(CurrHPRC)(
      HMEM  **Out
   ) PURE;

   STDMETHOD(CurrLPPRC)(
      LPPRC **Out
   ) PURE;

   STDMETHOD(CurrHTHD)(
      HMEM  **Out
   ) PURE;

   STDMETHOD(CurrLPTHD)(
      LPTHD **Out
   ) PURE;

   STDMETHOD(CxfIp)(
      CXF   **Out
   ) PURE;

   STDMETHOD(BMLock)(
      HMEM  hmem,
      LPV   *Out
   ) PURE;

   STDMETHOD(BMUnlock)(
      HMEM  hmem
   ) PURE;

   STDMETHOD(MHAlloc)(
      size_t   size,
      void FAR *  *Out
   ) PURE;

   STDMETHOD(MHRealloc)(
      void FAR *buffer,
      size_t   size,
      void FAR *  *Out
   ) PURE;

   STDMETHOD(MHFree)(
      void FAR *buffer
   ) PURE;

   STDMETHOD(fCaseSensitive)(
      char **Out
   ) PURE;

#undef AuxPrintf
   STDMETHOD(AuxPrintf)(
      LPSTR text,
      ...
   ) PURE;

   STDMETHOD(LLHlleFindNext)(
      HLLI    hlli,
      HLLE    hlle,
      HLLE    *Out
   ) PURE;

   STDMETHOD(LLLpvFromHlle)(
      HLLE  hlle,
      LPV   *Out
   ) PURE;

   STDMETHOD(LlthdFromHprc)(
      HPRC  hprc,
      HLLI  *Out
   ) PURE;

   STDMETHOD(ValidhprcFromPid)(
      unsigned long  pid,
      HPRC           *Out
   ) PURE;

   STDMETHOD(HthdFromTid)(
      HPRC           hprc,
      unsigned long  tid,
      HTHD           *Out
   ) PURE;

   STDMETHOD(GetHprcHead)(
      HPRC *Out
   ) PURE;

   STDMETHOD(GetLLPRC)(
      HLLI *Out
   ) PURE;

#if defined(_X86_)
   STDMETHOD(SzFromLd)(
      char     *pchBuf,
      size_t   cb,
      FLOAT10  f10,
      char *   *Out
   ) PURE;

   STDMETHOD(LdFromSz)(
      char    * szFloat,
      char    ** ppchEnd,
      FLOAT10 *Out
   ) PURE;
#endif // _X86_

   STDMETHOD(SYGetAddr)(
      HPID  hpid,
      HTID  htid,
      ADR   adr,
      LPADDR   lpaddr,
      XOSD  *Out
   ) PURE;

   // Support Windbg command??: .list
   STDMETHOD(FGetLine)(
      PTDOC doc,
      PCSTR &pcstr,
      ILINE iline
   ) PURE;
};

#endif   // __DBGAPI_H__

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\color.h ===
//-----------------------------------------------------------------------
//
// File:	 color.h
//
// Contains: common structures, helpers for colorizer
//
//-----------------------------------------------------------------------

#pragma once

#include <cppsvc.h>
#include <textmgr.h>

//syntax coloring stuff
struct SYNTAXITEM
{
    COLORINDEX  iDefFgColor;        // Default foreground color index
    COLORINDEX  iDefBkColor;        // Default background color index
    UINT		idDisplayName;      // Resource ID for display name (localized)
    DWORD       dwDefFontFlags;     // UNUSED:  Reserved for future version
};


enum
{
    VC_COLITEM_TEXT = COLITEM_TEXT,
    // Default Color indexes taken from _DEFAULTITEMS
    VC_COLITEM_KEYWORD = COLITEM_KEYWORD,
    VC_COLITEM_COMMENT = COLITEM_COMMENT,
    VC_COLITEM_IDENTIFIER = COLITEM_IDENTIFIER,
    VC_COLITEM_STRING = COLITEM_STRING,
    VC_COLITEM_NUMBER = COLITEM_NUMBER,
	// C++ Custom Color indexes
	VC_COLITEM_OPERATOR,
	VC_COLITEM_PPKEYWORD,
	VC_COLITEM_USERKEYWORD,
	VC_COLITEM_WIZARDCODE
};

#ifdef __VS_COLORIZER_IMPL__ //only colorizer needs this structure
__declspec(selectany) SYNTAXITEM  m_rgSyntaxItems[] = {
	// Default Color indexes taken from _DEFAULTITEMS
	{CI_BLUE,		CI_USERTEXT_BK,	IDS_SYNTAX_KEYWORD,		0},
	{CI_DARKGREEN,		CI_USERTEXT_BK,	IDS_SYNTAX_COMMENT,		0},
	{CI_USERTEXT_FG,	CI_USERTEXT_BK,	IDS_SYNTAX_IDENTIFIER,		0},
	{CI_USERTEXT_FG,	CI_USERTEXT_BK,	IDS_SYNTAX_STRING,		0},
	{CI_USERTEXT_FG,	CI_USERTEXT_BK,	IDS_SYNTAX_NUMBER,		0},
	// C++ Custom Color indexes
	{CI_USERTEXT_FG,	CI_USERTEXT_BK,	IDS_SYNTAX_OPERATOR,		0},
	{CI_BLUE,		CI_USERTEXT_BK,	IDS_SYNTAX_PPKEYWORD,		0},
	{CI_BLUE,		CI_USERTEXT_BK,	IDS_SYNTAX_USERKEYWORD,		0},
	{CI_DARKGRAY,		CI_USERTEXT_BK,	IDS_SYNTAX_WIZARDCODE,		0}
};

#define N_VC_COLOR_ITEMS sizeof(m_rgSyntaxItems)/sizeof(SYNTAXITEM)	// Number of items in m_rgSyntaxItems above
#endif // __VS_COLORIZER_IMPL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\ddatacmd.h ===
//-----------------------------------------------------------------------------
// Microsoft DaVinci
//
// Microsoft Confidential
// Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
// @doc 
//
// @module		ddatacmd.h - Data Tools Command Set |
// Defines the command ids and group ids as well as the guids for the Data 
// tools (Query, Schema)
// 
// @owner		RahulK
//-----------------------------------------------------------------------------


//////////////////////////////////////////////////////////////////////////////
//
// GUIDs for data tools command set and menu/group set 
//
//////////////////////////////////////////////////////////////////////////////
#ifdef DEFINE_GUID

	// Guid for daVinci data tools' group and menu ids
	//{732abe74-cd80-11d0-a2db-00aa00a3efff}
	DEFINE_GUID(CMDSETID_DaVinciDataToolsMenuSet, 0x732abe74, 0xcd80, 0x11d0, 0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff);

	// Guid for daVinci data tools' command ids
	//{732abe75-cd80-11d0-a2db-00aa00a3efff}
	DEFINE_GUID(CMDSETID_DaVinciDataToolsCommandSet, 0x732abe75, 0xcd80, 0x11d0, 0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff);

#else

	// Guid for daVinci data tools' group and menu ids
	//{732abe74-cd80-11d0-a2db-00aa00a3efff}
	#define CMDSETID_DaVinciDataToolsMenuSet	{0x732abe74, 0xcd80, 0x11d0, {0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff} }
  
	// Guid for daVinci data tools' command ids
	//{732abe75-cd80-11d0-a2db-00aa00a3efff}
	#define CMDSETID_DaVinciDataToolsCommandSet	{0x732abe75, 0xcd80, 0x11d0, {0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff} }

	// These following are only needed by the CTC compiler
	// Guid for daVinci query tool's glyph bitmap
	//{732abe76-cd80-11d0-a2db-00aa00a3efff}
	#define guidDavQryBmpId	{0x732abe76, 0xcd80, 0x11d0, {0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff} }

	// Guid for daVinci schema tool's glyph bitmap
	//{732abe77-cd80-11d0-a2db-00aa00a3efff}
	#define guidDavSchBmpId	{0x732abe77, 0xcd80, 0x11d0, {0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff} }

	// Guid for daVinci tools' shared glyph bitmap
	//{732abe78-cd80-11d0-a2db-00aa00a3efff}
	#define guidDavFrmBmpId	{0x732abe78, 0xcd80, 0x11d0, {0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff} }

#endif

#define guidDavDataGrpId	CMDSETID_DaVinciDataToolsMenuSet
#define guidDavDataCmdId	CMDSETID_DaVinciDataToolsCommandSet

#ifndef _DDATACMD_H_
#define _DDATACMD_H_


//////////////////////////////////////////////////////////////////////////////
//
// Command IDs
//
//////////////////////////////////////////////////////////////////////////////
// Note we can't expressions like (cmdidStart + 1) since those cause the
// CTC compiler to fail

#define	cmdidAddRelatedTables			0x0001 
#define cmdidLayoutDiagram				0x0002
#define cmdidLayoutSelection			0x0003
#define cmdidInsertColumn				0x0004
#define cmdidDeleteColumn				0x0005
#define cmdidNewTextAnnotation			0x0006
#define cmdidShowRelLabels				0x0007
#define cmdidViewPageBreaks				0x0008
#define cmdidRecalcPageBreaks			0x0009
#define cmdidViewUserDefined			0x000a
#define cmdidGenerateQuery				0x000b
#define cmdidDeleteFromDB				0x000c
#define cmdidAutoSize					0x000d
#define cmdidEditViewUserDefined		0x000e
#define cmdidSetAnnotationFont			0x000f
#define cmdidZoomPercent200				0x0010 
#define cmdidZoomPercent150				0x0011 
#define cmdidZoomPercent100				0x0012 
#define cmdidZoomPercent75				0x0013 
#define cmdidZoomPercent50				0x0014 
#define cmdidZoomPercent25				0x0015 
#define cmdidZoomPercent10				0x0016 
#define cmdidZoomPercentSelection		0x0017 
#define cmdidZoomPercentFit				0x0018




//////////////////////////////////////////////////////////////////////////////
//
// Menu / Group IDs
//
//////////////////////////////////////////////////////////////////////////////
// Menu / toolbar ids are prefixed with a 0, group ids by a 1
// Note we can't expressions like (cmdidStart + 1) since those cause the
// CTC compiler to fail

// Query Design menus and groups ----------------------------------------------
	
#define	IDM_QRY_TOOLBAR_QUERY			0x0001		// query toolbar
#define IDM_QRY_MAINMENU				0x0002
#define	IDMX_QRY_DIAGRAM_NONE			0x0003		// diagram pane ctx menu
#define	IDMX_QRY_DIAGRAM_TABLE			0x0004		// diagram pane table (ECL) ctx menu
#define	IDMX_QRY_DIAGRAM_FIELD			0x0005		// diagram pane field (ECOL) ctx menu
#define	IDMX_QRY_DIAGRAM_JOINLINE		0x0006		// diagram pane join line (JLN) ctx menu
#define	IDMX_QRY_DIAGRAM_MULTIPLE		0x0007		// diagram pane multi-select ctx menu
#define IDMX_QRY_QBE					0x0008		// qbe pane ctx menu
#define IDMX_QRY_SQL					0x0009		// sql pane ctx menu
#define IDMX_QRY_DATA					0x000a		// data pane ctx menu
#define	IDM_QRY_TOOLBAR_VIEW			0x000b		// view toolbar

#define	IDMC_QRY_GOTOROW				0x0010
#define IDMC_QRY_CHANGETYPE				0x0011
#define IDMC_DTOOLS_TABLE_VIEW			0x0012
#define IDMC_QRY_SHOWPANES				0x0013

#define	IDG_QRY_MAIN_SQL				0x1001	
#define	IDG_QRY_MAIN_SYNTAX				0x1002 
#define	IDG_QRY_MAIN_QUERY				0x1003 
#define IDG_QRY_MAIN_OUTPUT				0x1004 
#define	IDG_QRY_MAIN_SORT				0x1005
#define	IDG_QRY_MAIN_FILTER				0x1006 	 
#define	IDG_QRY_MAIN_JOIN				0x1007
												
#define IDG_QRY_CHANGETYPE				0x1008
#define IDG_QRY_SHOWPANES				0x1009 

#define IDG_QRY_TOOLBAR_PANES			0x100a
#define	IDG_QRY_TOOLBAR_QUERYTYPE		0x100b
#define	IDG_QRY_TOOLBAR_SQL				0x100c
#define	IDG_QRY_TOOLBAR_QUERYSHAPE		0x100d
#define	IDG_QRY_TOOLBAR_VIEWSHAPE		0x100e

#define IDG_QRY_DIAGRAM_NONE_SHAPE		0x100f
#define IDG_QRY_DIAGRAM_NONE_PANE		0x1010
#define IDG_QRY_DIAGRAM_TBL_VIEW		0x1011
#define	IDG_QRY_DIAGRAM_TBL_EDIT		0x1012
#define	IDG_QRY_DIAGRAM_FIELD_OUTPUT	0x1013
#define	IDG_QRY_DIAGRAM_FIELD_SORT		0x1014
#define	IDG_QRY_DIAGRAM_FIELD_FILTER	0x1015
#define IDG_QRY_DIAGRAM_JLN_EDIT		0x1016
#define	IDG_QRY_DIAGRAM_JLN_OUTER		0x1017
#define	IDG_QRY_DIAGRAM_MULTI_EDIT		0x1018
#define	IDG_QRY_QBE_EDIT				0x1019
#define	IDG_QRY_SQL_RUN					0x101a
#define	IDG_QRY_SQL_SYNTAX				0x101b
#define	IDG_QRY_SQL_EDIT				0x101c
#define IDG_QRY_DATA_RUN				0x101d
#define	IDG_QRY_DATA_GOTO				0x101e
#define IDG_QRY_DATA_EDIT				0x101f
#define IDG_QRY_DIAGRAM_NONE_RUN		0x1020
#define IDG_QRY_QBE_RUN					0x1021
#define IDG_QRY_QBE_SHAPE				0x1022

// Shared between Query & Schema
#define	IDG_DTOOLS_VIEW_DT				0x1023
#define IDG_DTOOLS_TABLE_VIEW			0x1024

// Schema Designer menus and groups -------------------------------------------
	
#define	IDM_SCH_TOOLBAR_DIAGRAM			0x0101		// database diagram toolbar
#define	IDMX_SCH_DIAGRAM				0x0102		// diagram ctx menu (nothing selected)
#define	IDMX_SCH_TABLE					0x0103		// table ctx menu
#define	IDMX_SCH_RELATIONSHIP			0x0104		// relationship ctx menu
#define	IDMX_SCH_TEXTANNOTATION			0x0105		// Text annotation ctx menu
#define IDMC_SCH_ZOOM					0x0106		// Zoom cascade menu
#define IDM_SCH_TOOLBAR_TABLE			0x0107	    // table toolbar

#define	IDG_SCH_DIAG_ADDOBJS			0x1101	
#define	IDG_SCH_DIAG_EDIT				0x1102 
#define	IDG_SCH_DIAG_DIAGRAM			0x1103 
#define IDG_SCH_DIAG_LAYOUT				0x1104 

#define	IDG_SCH_TABLE_VIEW				0x1105
#define IDG_SCH_TABLE_ADDREL			0x1106		
#define IDG_SCH_TABLE_OPS				0x1107
#define	IDG_SCH_TABLE_REMOVE			0x1108
#define IDG_SCH_TABLE_LAYOUT			0x1109

#define	IDG_SCH_REL_REMOVE				0x110a

#define IDG_SCH_TOOLBAR_TABLE			0x110b
#define IDG_SCH_TOOLBAR_TABLEOPS		0x110c	
#define IDG_SCH_TOOLBAR_ANNOTATION		0x110d
#define IDG_SCH_TOOLBAR_SAVE			0x110e
#define IDG_SCH_TOOLBAR_TABLEVIEW		0x110f 
#define IDG_SCH_TOOLBAR_DIAGRAM			0x1110
#define IDG_SCH_TOOLBAR_LAYOUT			0x1111
#define IDG_SCH_TOOLBAR_ZOOM			0x1112

#define IDG_SCH_EDIT_KEYS				0x1113		// Edit main menu keys grp
#define IDG_SCH_EDIT_TA					0x1114
#define IDG_SCH_DIAGRAM_SHOWLABELS		0x1115		// Diagram main menu show labels grp	

#define IDG_SCH_ZOOM_LEVELS				0x1116		// Zoom cascade menu groups
#define IDG_SCH_TA_EDIT					0x1117		// TA ctx menu grps
#define IDG_SCH_TA_FONT					0x1118									  

#define IDG_SCH_TABLE_UDV				0x1119

#endif // _DDATACMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dbcguids.h ===
//=[f========================================================================
//	dbcguids.h
//
//	GUIDs used for managing Database Connection collections.
//
//	Copyright (C) 1996 Microsoft Corporation,
//	All rights reserved.
//
//=f]========================================================================

// {79937DA0-AA6D-11cf-97EA-00AA00C006B6}
DEFINE_GUID(IID_IDBConnections, 0x79937da0, 0xaa6d, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);

// {F7CCDBA0-AF0C-11cf-97EA-00AA00C006B6}
DEFINE_GUID(IID_IDBConnection, 0xf7ccdba0, 0xaf0c, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);

// {8B072246-8C1A-11cf-BE23-00AA0062C2EF}
DEFINE_GUID(IID_IDispDBConnections, 0x8b072246, 0x8c1a, 0x11cf, 0xbe, 0x23, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

// {8B072247-8C1A-11cf-BE23-00AA0062C2EF}
DEFINE_GUID(IID_IDispDBConnection, 0x8b072247, 0x8c1a, 0x11cf, 0xbe, 0x23, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dbgpkapi.h ===
#ifndef __DBGPKAPI_H__
#define __DBGPKAPI_H__

interface IDbgPkg;
interface IDLLInfo;

typedef IDbgPkg* PIDBGPKG;
typedef IDbgPkg* LPDEBUGPACKAGE;
typedef IDLLInfo* LPDLLINFO;

typedef enum _DocState {
	DOCSTATE_CLEAR,
	DOCSTATE_EDITED,
	DOCSTATE_SAVED,
} DocState;

/////////////////////////////////////////////////////////////////////////////
//	IDbgPkg interface

#undef INTERFACE
#define INTERFACE IDbgPkg

DECLARE_INTERFACE_(IDbgPkg, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	/*
	** IDbg
	**
	*/

    STDMETHOD_(BOOL, DebuggeeAlive)(void) PURE;
    STDMETHOD_(BOOL, DebuggeeRunning)(void) PURE;
    STDMETHOD_(void *, DbgDAMHsfFromFile)(LPCSTR) PURE;
    STDMETHOD_(BOOL, GetExecutablePath)(LPSTR) PURE;
	STDMETHOD_(BOOL, CanShowDataTip)(void) PURE;
	STDMETHOD(EvaluateExpression)(LPSTR szText, BOOL bFromSelection, LPSTR szResult, ULONG cb) PURE;

	STDMETHOD(SetDebugLines)(CDocument *pDoc, BOOL ResetTraceInfo) PURE;
	STDMETHOD(AdjustDebugLines)(CDocument * pDoc, int StartLine, int NumberLines, BOOL fAdded, BOOL fLineBreak, BOOL fWhiteSpaceOnly) PURE;
	STDMETHOD(DeleteBreakpointLinesInDoc)(LPCSTR sz) PURE;
    STDMETHOD_(BOOL, IsENCProjectFile)(CPath *pPath) PURE;
	STDMETHOD(VTestDebugActive)(BOOL *bActive) PURE;

	STDMETHOD(UpdateDocState)(LPCTSTR szDocName, DocState docState) PURE;
	STDMETHOD(StopDebugging)(void) PURE;

};

/////////////////////////////////////////////////////////////////////////////
//	IDLLInfo interface

typedef struct
{
	BOOL fPreload;
	CString strLocalName;
	CString strRemoteName;
	BOOL fDelete;
} DLLREC;	// DLL record


#undef  INTERFACE
#define INTERFACE IDLLInfo

DECLARE_INTERFACE_(IDLLInfo, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IDLLInfo methods
	STDMETHOD(DiffDLLs)(ULONG hTarget, CPtrList &listDLLs, INT *piRow, UINT *pidMsg) PURE;
	STDMETHOD(GetDLLCount)(ULONG hTarget, int *piCount) PURE;
	STDMETHOD(InitDLLList)(ULONG hTarget, CPtrList &listDLLs) PURE;
	STDMETHOD(SaveDLLList)(ULONG hTarget, CPtrList &listDLLs) PURE;
};

#endif // __DBGPKAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dbgpguid.h ===
// Interface ID for Debugger Functions

DEFINE_GUID(IID_IDbgPkg,
    0xbbdc8f00, 0x68a9, 0x11cf, 0xa8, 0xd, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x54);

// Interface ID for DLLInfo {1A26E5E2-2905-11cf-B250-00AA0057AFF3}
DEFINE_GUID(IID_IDLLInfo, 
	0x1a26e5e2, 0x2905, 0x11cf, 0xb2, 0x50, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

/*
DEFINE_GUID(CLSID_, // {605CD000-7C2F-11cf-A815-00AA00B60154}
    0x605cd000, 0x7c2f, 0x11cf, 0xa8, 0x15, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x54);
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\ddkapi.h ===
//
// DDKAPI.H
//    Debug package interface declarations.

#ifndef __DBGAPI_H__
#define __DBGAPI_H__

interface IDdkCmd;

typedef IDdkCmd *     LPDDKCMD;

//
// IDebugCmd interface
//
#undef  INTERFACE
#define INTERFACE IDdkCmd

DECLARE_INTERFACE_(IDdkCmd, IUnknown)
{
   // IUnknown methods
   STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)(THIS) PURE;
   STDMETHOD_(ULONG,Release)(THIS) PURE;
};

#endif   // __DDKAPI_H__

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dhtmlguid.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       dhtmlguid.h
//
//  Contents:   Defines GUIDs for the dhtml package
//
//  Classes:    
//
//  Functions:  
//
//  History:    30-Jul-98   BruceMa    Created.
//
//----------------------------------------------------------------------

#ifndef __DHTMLGUID_H__
#define __DHTMLGUID_H__

// {336fa928-27f4-11d2-aa6b-00c04f9902d7}
DEFINE_GUID(IID_IDhtmlPkg, 0x336fa928, 0x27f4, 0x11d2, 0xaa, 0x6b, 0x00, 0xc0, 0x4f, 0x99, 0x02, 0xd7);


#endif // __DHTMLGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\ddkguid.h ===
//
// DDKGUID.H
//    DDK package Interface ids.

// {9345E321-6353-11cf-AA83-00006B829112}
DEFINE_GUID(IID_IDdkCmd,
0x9345e321, 0x6353, 0x11cf, 0xaa, 0x83, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);


=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dhtmlapi.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       dhtmlapi.h
//
//  Contents:   Defines the interface from the editor to the dhtml package
//
//  Classes:    
//
//  Functions:  
//
//  History:    29-Jul-98   BruceMa    Created.
//
//----------------------------------------------------------------------

#ifndef __DHTMLAPI_H__
#define __DHTMLAPI_H__



/////////////////////////////////////////////////////////////////////////////
//	IDhtmlPkg interface

#undef  INTERFACE
#define INTERFACE IDhtmlPkg


DECLARE_INTERFACE_(IDhtmlPkg, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

        // IDhtmlPkg methods
	STDMETHOD(RegisterExternalEditor)(THIS_ LPEXTERNALRESPKG pExtRes, 
                                          REFCLSID clsidEditor,
                                          LPCSTR szEditorName,
                                          LPCSTR szResType) PURE;
};


typedef IDhtmlPkg *LPDHTMLPKG;


#endif	// __DHTMLAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dtgapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.59 */
/* at Wed Dec 11 12:17:38 1996
 */
/* Compiler settings for dtgapi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __dtgapi_h__
#define __dtgapi_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDataService_FWD_DEFINED__
#define __IDataService_FWD_DEFINED__
typedef interface IDataService IDataService;
#endif 	/* __IDataService_FWD_DEFINED__ */


#ifndef __IDispDataService_FWD_DEFINED__
#define __IDispDataService_FWD_DEFINED__
typedef interface IDispDataService IDispDataService;
#endif 	/* __IDispDataService_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dtgapi_0000
 * at Wed Dec 11 12:17:38 1996
 * using MIDL 3.01.59
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//--------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_dtgapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dtgapi_0000_v0_0_s_ifspec;


#ifndef __DSDataService_LIBRARY_DEFINED__
#define __DSDataService_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DSDataService
 * at Wed Dec 11 12:17:38 1996
 * using MIDL 3.01.59
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


/////////////////////////////////////////////////////////////////////////
// Dual interface for IDataService
// {C92A228B-E3DD-11cf-A96F-00A0C90F55D6}
DEFINE_GUID(IID_IDataService, 
0xc92a228b, 0xe3dd, 0x11cf, 0xa9, 0x6f, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xd6);
// IDispatch Interface for IDataService
// {C92A228C-E3DD-11cf-A96F-00A0C90F55D6}
DEFINE_GUID(IID_IDispDataService, 
0xc92a228c, 0xe3dd, 0x11cf, 0xa9, 0x6f, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xd6);

EXTERN_C const IID LIBID_DSDataService;

#ifndef __IDataService_INTERFACE_DEFINED__
#define __IDataService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataService
 * at Wed Dec 11 12:17:38 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDataService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C92A228B-E3DD-11cf-A96F-00A0C90F55D6")
    IDataService : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentSelection( 
            /* [retval][out] */ BSTR __RPC_FAR *CurrentUrl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateProject( 
            /* [in] */ BSTR ProjName,
            /* [in] */ BSTR Dir,
            /* [in] */ VARIANT_BOOL UseCurrentWkspaceDoc,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Project) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenProject( 
            /* [in] */ BSTR ProjName,
            /* [in] */ BSTR Dir,
            /* [in] */ VARIANT_BOOL UseCurrentWkspaceDoc,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Project) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoesProjectFileExist( 
            /* [in] */ BSTR ProjName,
            /* [in] */ BSTR Dir,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Bool) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateProjectFile( 
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR Dir,
            /* [in] */ BSTR DSN,
            /* [in] */ BSTR ConnStr,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Bool) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataService __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDataService __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDataService __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDataService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDataService __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentSelection )( 
            IDataService __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *CurrentUrl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IDataService __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDataService __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProject )( 
            IDataService __RPC_FAR * This,
            /* [in] */ BSTR ProjName,
            /* [in] */ BSTR Dir,
            /* [in] */ VARIANT_BOOL UseCurrentWkspaceDoc,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Project);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenProject )( 
            IDataService __RPC_FAR * This,
            /* [in] */ BSTR ProjName,
            /* [in] */ BSTR Dir,
            /* [in] */ VARIANT_BOOL UseCurrentWkspaceDoc,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Project);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoesProjectFileExist )( 
            IDataService __RPC_FAR * This,
            /* [in] */ BSTR ProjName,
            /* [in] */ BSTR Dir,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Bool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProjectFile )( 
            IDataService __RPC_FAR * This,
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR Dir,
            /* [in] */ BSTR DSN,
            /* [in] */ BSTR ConnStr,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Bool);
        
        END_INTERFACE
    } IDataServiceVtbl;

    interface IDataService
    {
        CONST_VTBL struct IDataServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataService_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDataService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDataService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDataService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDataService_get_CurrentSelection(This,CurrentUrl)	\
    (This)->lpVtbl -> get_CurrentSelection(This,CurrentUrl)

#define IDataService_get_Application(This,Application)	\
    (This)->lpVtbl -> get_Application(This,Application)

#define IDataService_get_Parent(This,Parent)	\
    (This)->lpVtbl -> get_Parent(This,Parent)

#define IDataService_CreateProject(This,ProjName,Dir,UseCurrentWkspaceDoc,Project)	\
    (This)->lpVtbl -> CreateProject(This,ProjName,Dir,UseCurrentWkspaceDoc,Project)

#define IDataService_OpenProject(This,ProjName,Dir,UseCurrentWkspaceDoc,Project)	\
    (This)->lpVtbl -> OpenProject(This,ProjName,Dir,UseCurrentWkspaceDoc,Project)

#define IDataService_DoesProjectFileExist(This,ProjName,Dir,Bool)	\
    (This)->lpVtbl -> DoesProjectFileExist(This,ProjName,Dir,Bool)

#define IDataService_CreateProjectFile(This,ProjectName,Dir,DSN,ConnStr,Bool)	\
    (This)->lpVtbl -> CreateProjectFile(This,ProjectName,Dir,DSN,ConnStr,Bool)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDataService_get_CurrentSelection_Proxy( 
    IDataService __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *CurrentUrl);


void __RPC_STUB IDataService_get_CurrentSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDataService_get_Application_Proxy( 
    IDataService __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);


void __RPC_STUB IDataService_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDataService_get_Parent_Proxy( 
    IDataService __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);


void __RPC_STUB IDataService_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataService_CreateProject_Proxy( 
    IDataService __RPC_FAR * This,
    /* [in] */ BSTR ProjName,
    /* [in] */ BSTR Dir,
    /* [in] */ VARIANT_BOOL UseCurrentWkspaceDoc,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Project);


void __RPC_STUB IDataService_CreateProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataService_OpenProject_Proxy( 
    IDataService __RPC_FAR * This,
    /* [in] */ BSTR ProjName,
    /* [in] */ BSTR Dir,
    /* [in] */ VARIANT_BOOL UseCurrentWkspaceDoc,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Project);


void __RPC_STUB IDataService_OpenProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataService_DoesProjectFileExist_Proxy( 
    IDataService __RPC_FAR * This,
    /* [in] */ BSTR ProjName,
    /* [in] */ BSTR Dir,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Bool);


void __RPC_STUB IDataService_DoesProjectFileExist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDataService_CreateProjectFile_Proxy( 
    IDataService __RPC_FAR * This,
    /* [in] */ BSTR ProjectName,
    /* [in] */ BSTR Dir,
    /* [in] */ BSTR DSN,
    /* [in] */ BSTR ConnStr,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Bool);


void __RPC_STUB IDataService_CreateProjectFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataService_INTERFACE_DEFINED__ */


#ifndef __IDispDataService_DISPINTERFACE_DEFINED__
#define __IDispDataService_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IDispDataService
 * at Wed Dec 11 12:17:38 1996
 * using MIDL 3.01.59
 ****************************************/
/* [hidden][uuid] */ 



EXTERN_C const IID DIID_IDispDataService;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("C92A228C-E3DD-11cf-A96F-00A0C90F55D6")
    IDispDataService : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IDispDataServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispDataService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispDataService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispDataService __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDispDataService __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDispDataService __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDispDataService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDispDataService __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IDispDataServiceVtbl;

    interface IDispDataService
    {
        CONST_VTBL struct IDispDataServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispDataService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispDataService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispDataService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispDataService_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDispDataService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDispDataService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDispDataService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IDispDataService_DISPINTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DataService;

class DECLSPEC_UUID("C92A228D-E3DD-11cf-A96F-00A0C90F55D6")
DataService;
#endif
#endif /* __DSDataService_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dtgdbcol.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.59 */
/* at Wed Dec 11 12:17:41 1996
 */
/* Compiler settings for dtgdbcol.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __dtgdbcol_h__
#define __dtgdbcol_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IGenericDocument_FWD_DEFINED__
#define __IGenericDocument_FWD_DEFINED__
typedef interface IGenericDocument IGenericDocument;
#endif 	/* __IGenericDocument_FWD_DEFINED__ */


#ifndef __IGenericWindow_FWD_DEFINED__
#define __IGenericWindow_FWD_DEFINED__
typedef interface IGenericWindow IGenericWindow;
#endif 	/* __IGenericWindow_FWD_DEFINED__ */


#ifndef __IGenericProject_FWD_DEFINED__
#define __IGenericProject_FWD_DEFINED__
typedef interface IGenericProject IGenericProject;
#endif 	/* __IGenericProject_FWD_DEFINED__ */


#ifndef __IDBConnection_FWD_DEFINED__
#define __IDBConnection_FWD_DEFINED__
typedef interface IDBConnection IDBConnection;
#endif 	/* __IDBConnection_FWD_DEFINED__ */


#ifndef __IDBConnections_FWD_DEFINED__
#define __IDBConnections_FWD_DEFINED__
typedef interface IDBConnections IDBConnections;
#endif 	/* __IDBConnections_FWD_DEFINED__ */


#ifndef __IDataProject_FWD_DEFINED__
#define __IDataProject_FWD_DEFINED__
typedef interface IDataProject IDataProject;
#endif 	/* __IDataProject_FWD_DEFINED__ */


#ifndef __IDispDataProject_FWD_DEFINED__
#define __IDispDataProject_FWD_DEFINED__
typedef interface IDispDataProject IDispDataProject;
#endif 	/* __IDispDataProject_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dtgdbcol_0000
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif
#include <ObjModel\AppDefs.h>
#include <ObjModel\AppAuto.h>


extern RPC_IF_HANDLE __MIDL_itf_dtgdbcol_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dtgdbcol_0000_v0_0_s_ifspec;


#ifndef __DSDataProjects_LIBRARY_DEFINED__
#define __DSDataProjects_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DSDataProjects
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


#if 0
typedef /* [hidden] */ 
enum tagDSWINDOWSTATE
    {	dsWindowStateMaximized	= 1,
	dsWindowStateMinimized	= 2,
	dsWindowStateNormal	= 3
    }	DsWindowState;

typedef /* [hidden] */ 
enum tagDSARRANGESTYLE
    {	dsMinimize	= 1,
	dsTileHorizontal	= 2,
	dsTileVertical	= 3,
	dsCascade	= 4
    }	DsArrangeStyle;

typedef /* [hidden] */ 
enum tagDSBUTTONTYPE
    {	dsGlyph	= 1,
	dsText	= 2
    }	DsButtonType;

typedef /* [hidden] */ 
enum tagDSSAVECHANGES
    {	dsSaveChangesYes	= 1,
	dsSaveChangesNo	= 2,
	dsSaveChangesPrompt	= 3
    }	DsSaveChanges;

typedef /* [hidden] */ 
enum tagDSSAVESTATUS
    {	dsSaveSucceeded	= 1,
	dsSaveCanceled	= 2
    }	DsSaveStatus;

#endif // 0

EXTERN_C const IID LIBID_DSDataProjects;

#ifndef __IGenericDocument_INTERFACE_DEFINED__
#define __IGenericDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericDocument
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FB7FDAE1-89B8-11cf-9BE8-00A0C90A632C")
    IGenericDocument : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pPath) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Saved( 
            /* [retval][out] */ boolean __RPC_FAR *pSaved) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveWindow( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ReadOnly( 
            /* [in] */ boolean ReadOnly) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ boolean bActive) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ boolean __RPC_FAR *pbActive) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NewWindow( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Undo( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Redo( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PrintOut( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Saved )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSaved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveWindow )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadOnly )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReadOnly )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ boolean ReadOnly);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windows )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IGenericDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrintOut )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IGenericDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericDocument __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericDocumentVtbl;

    interface IGenericDocument
    {
        CONST_VTBL struct IGenericDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericDocument_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IGenericDocument_get_FullName(This,pName)	\
    (This)->lpVtbl -> get_FullName(This,pName)

#define IGenericDocument_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#define IGenericDocument_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IGenericDocument_get_Path(This,pPath)	\
    (This)->lpVtbl -> get_Path(This,pPath)

#define IGenericDocument_get_Saved(This,pSaved)	\
    (This)->lpVtbl -> get_Saved(This,pSaved)

#define IGenericDocument_get_ActiveWindow(This,ppWindow)	\
    (This)->lpVtbl -> get_ActiveWindow(This,ppWindow)

#define IGenericDocument_get_ReadOnly(This,pReadOnly)	\
    (This)->lpVtbl -> get_ReadOnly(This,pReadOnly)

#define IGenericDocument_put_ReadOnly(This,ReadOnly)	\
    (This)->lpVtbl -> put_ReadOnly(This,ReadOnly)

#define IGenericDocument_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IGenericDocument_get_Windows(This,ppWindows)	\
    (This)->lpVtbl -> get_Windows(This,ppWindows)

#define IGenericDocument_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IGenericDocument_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IGenericDocument_NewWindow(This,ppWindow)	\
    (This)->lpVtbl -> NewWindow(This,ppWindow)

#define IGenericDocument_Save(This,vFilename,vBoolPrompt,pSaved)	\
    (This)->lpVtbl -> Save(This,vFilename,vBoolPrompt,pSaved)

#define IGenericDocument_Undo(This,pSuccess)	\
    (This)->lpVtbl -> Undo(This,pSuccess)

#define IGenericDocument_Redo(This,pSuccess)	\
    (This)->lpVtbl -> Redo(This,pSuccess)

#define IGenericDocument_PrintOut(This,pSuccess)	\
    (This)->lpVtbl -> PrintOut(This,pSuccess)

#define IGenericDocument_Close(This,vSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,vSaveChanges,pSaved)

#define IGenericDocument_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericDocument_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericDocument_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericDocument_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericDocument_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericDocument_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericDocument_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericDocument_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericDocument_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericDocument_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Name_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IGenericDocument_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_FullName_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IGenericDocument_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Application_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IGenericDocument_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Parent_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IGenericDocument_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Path_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pPath);


void __RPC_STUB IGenericDocument_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Saved_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_get_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_ActiveWindow_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);


void __RPC_STUB IGenericDocument_get_ActiveWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_ReadOnly_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pReadOnly);


void __RPC_STUB IGenericDocument_get_ReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericDocument_put_ReadOnly_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [in] */ boolean ReadOnly);


void __RPC_STUB IGenericDocument_put_ReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Type_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IGenericDocument_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Windows_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);


void __RPC_STUB IGenericDocument_get_Windows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericDocument_put_Active_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [in] */ boolean bActive);


void __RPC_STUB IGenericDocument_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Active_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbActive);


void __RPC_STUB IGenericDocument_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_NewWindow_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);


void __RPC_STUB IGenericDocument_NewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Save_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [optional][in] */ VARIANT vFilename,
    /* [optional][in] */ VARIANT vBoolPrompt,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Undo_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Redo_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_Redo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_PrintOut_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_PrintOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Close_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [optional][in] */ VARIANT vSaveChanges,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved1_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved2_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved3_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved4_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved5_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved6_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved7_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved8_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved9_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved10_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericDocument_INTERFACE_DEFINED__ */


#ifndef __IGenericWindow_INTERFACE_DEFINED__
#define __IGenericWindow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericWindow
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD20FC80-A9D2-11cf-9C13-00A0C90A632C")
    IGenericWindow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ boolean bActive) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ boolean __RPC_FAR *pbActive) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Next( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Previous( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ DsWindowState lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ DsWindowState __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ VARIANT boolSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericWindow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericWindow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Index )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Next )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Previous )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WindowState )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ DsWindowState lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WindowState )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ DsWindowState __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ VARIANT boolSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericWindow __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericWindowVtbl;

    interface IGenericWindow
    {
        CONST_VTBL struct IGenericWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericWindow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericWindow_get_Caption(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Caption(This,pbstrCaption)

#define IGenericWindow_get_Type(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Type(This,pbstrCaption)

#define IGenericWindow_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IGenericWindow_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IGenericWindow_put_Left(This,lVal)	\
    (This)->lpVtbl -> put_Left(This,lVal)

#define IGenericWindow_get_Left(This,plVal)	\
    (This)->lpVtbl -> get_Left(This,plVal)

#define IGenericWindow_put_Top(This,lVal)	\
    (This)->lpVtbl -> put_Top(This,lVal)

#define IGenericWindow_get_Top(This,plVal)	\
    (This)->lpVtbl -> get_Top(This,plVal)

#define IGenericWindow_put_Height(This,lVal)	\
    (This)->lpVtbl -> put_Height(This,lVal)

#define IGenericWindow_get_Height(This,plVal)	\
    (This)->lpVtbl -> get_Height(This,plVal)

#define IGenericWindow_put_Width(This,lVal)	\
    (This)->lpVtbl -> put_Width(This,lVal)

#define IGenericWindow_get_Width(This,plVal)	\
    (This)->lpVtbl -> get_Width(This,plVal)

#define IGenericWindow_get_Index(This,plVal)	\
    (This)->lpVtbl -> get_Index(This,plVal)

#define IGenericWindow_get_Next(This,ppDispatch)	\
    (This)->lpVtbl -> get_Next(This,ppDispatch)

#define IGenericWindow_get_Previous(This,ppDispatch)	\
    (This)->lpVtbl -> get_Previous(This,ppDispatch)

#define IGenericWindow_put_WindowState(This,lVal)	\
    (This)->lpVtbl -> put_WindowState(This,lVal)

#define IGenericWindow_get_WindowState(This,plVal)	\
    (This)->lpVtbl -> get_WindowState(This,plVal)

#define IGenericWindow_get_Application(This,ppDispatch)	\
    (This)->lpVtbl -> get_Application(This,ppDispatch)

#define IGenericWindow_get_Parent(This,ppDispatch)	\
    (This)->lpVtbl -> get_Parent(This,ppDispatch)

#define IGenericWindow_Close(This,boolSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,boolSaveChanges,pSaved)

#define IGenericWindow_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericWindow_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericWindow_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericWindow_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericWindow_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericWindow_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericWindow_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericWindow_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericWindow_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericWindow_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Caption_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);


void __RPC_STUB IGenericWindow_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Type_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);


void __RPC_STUB IGenericWindow_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Active_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ boolean bActive);


void __RPC_STUB IGenericWindow_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Active_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbActive);


void __RPC_STUB IGenericWindow_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Left_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Left_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Top_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Top_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Height_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Height_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Width_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Width_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Index_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Next_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Previous_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_WindowState_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ DsWindowState lVal);


void __RPC_STUB IGenericWindow_put_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_WindowState_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ DsWindowState __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Application_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Parent_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Close_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ VARIANT boolSaveChanges,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericWindow_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved1_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved2_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved3_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved4_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved5_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved6_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved7_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved8_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved9_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved10_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericWindow_INTERFACE_DEFINED__ */


#ifndef __IGenericProject_INTERFACE_DEFINED__
#define __IGenericProject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericProject
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8CA5A960-FC7D-11cf-927D-00A0C9138C45")
    IGenericProject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericProject __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericProjectVtbl;

    interface IGenericProject
    {
        CONST_VTBL struct IGenericProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericProject_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IGenericProject_get_FullName(This,Name)	\
    (This)->lpVtbl -> get_FullName(This,Name)

#define IGenericProject_get_Application(This,Application)	\
    (This)->lpVtbl -> get_Application(This,Application)

#define IGenericProject_get_Parent(This,Parent)	\
    (This)->lpVtbl -> get_Parent(This,Parent)

#define IGenericProject_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IGenericProject_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericProject_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericProject_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericProject_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericProject_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericProject_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericProject_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericProject_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericProject_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericProject_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Name_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IGenericProject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_FullName_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IGenericProject_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Application_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);


void __RPC_STUB IGenericProject_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Parent_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);


void __RPC_STUB IGenericProject_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Type_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IGenericProject_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved1_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved2_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved3_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved4_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved5_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved6_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved7_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved8_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved9_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved10_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericProject_INTERFACE_DEFINED__ */


#ifndef __IDBConnection_INTERFACE_DEFINED__
#define __IDBConnection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBConnection
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDBConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("F7CCDBA0-AF0C-11cf-97EA-00AA00C006B6")
    IDBConnection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectString( 
            /* [retval][out] */ BSTR __RPC_FAR *pConnectString) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectString( 
            /* [in] */ BSTR ConnectString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionTimeout( 
            /* [retval][out] */ long __RPC_FAR *pTimeout) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionTimeout( 
            /* [in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CommandTimeout( 
            /* [retval][out] */ long __RPC_FAR *pTimeout) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CommandTimeout( 
            /* [in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Runtime( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Connected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDBConnection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectString )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pConnectString);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectString )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ BSTR ConnectString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pTimeout);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ long Timeout);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pTimeout);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ long Timeout);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Runtime )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Connected )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IDBConnection __RPC_FAR * This);
        
        END_INTERFACE
    } IDBConnectionVtbl;

    interface IDBConnection
    {
        CONST_VTBL struct IDBConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBConnection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDBConnection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDBConnection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDBConnection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDBConnection_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IDBConnection_put_Name(This,Name)	\
    (This)->lpVtbl -> put_Name(This,Name)

#define IDBConnection_get_Parent(This,pParent)	\
    (This)->lpVtbl -> get_Parent(This,pParent)

#define IDBConnection_get_ConnectString(This,pConnectString)	\
    (This)->lpVtbl -> get_ConnectString(This,pConnectString)

#define IDBConnection_put_ConnectString(This,ConnectString)	\
    (This)->lpVtbl -> put_ConnectString(This,ConnectString)

#define IDBConnection_get_ConnectionTimeout(This,pTimeout)	\
    (This)->lpVtbl -> get_ConnectionTimeout(This,pTimeout)

#define IDBConnection_put_ConnectionTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_ConnectionTimeout(This,Timeout)

#define IDBConnection_get_CommandTimeout(This,pTimeout)	\
    (This)->lpVtbl -> get_CommandTimeout(This,pTimeout)

#define IDBConnection_put_CommandTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,Timeout)

#define IDBConnection_get_Runtime(This,pRuntime)	\
    (This)->lpVtbl -> get_Runtime(This,pRuntime)

#define IDBConnection_get_Connected(This,pValid)	\
    (This)->lpVtbl -> get_Connected(This,pValid)

#define IDBConnection_Connect(This)	\
    (This)->lpVtbl -> Connect(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Name_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IDBConnection_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_Name_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IDBConnection_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Parent_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);


void __RPC_STUB IDBConnection_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_ConnectString_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pConnectString);


void __RPC_STUB IDBConnection_get_ConnectString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_ConnectString_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ BSTR ConnectString);


void __RPC_STUB IDBConnection_put_ConnectString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_ConnectionTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pTimeout);


void __RPC_STUB IDBConnection_get_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_ConnectionTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ long Timeout);


void __RPC_STUB IDBConnection_put_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_CommandTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pTimeout);


void __RPC_STUB IDBConnection_get_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_CommandTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ long Timeout);


void __RPC_STUB IDBConnection_put_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Runtime_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime);


void __RPC_STUB IDBConnection_get_Runtime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Connected_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid);


void __RPC_STUB IDBConnection_get_Connected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnection_Connect_Proxy( 
    IDBConnection __RPC_FAR * This);


void __RPC_STUB IDBConnection_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBConnection_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DBConnection;

class DECLSPEC_UUID("F7CCDBA2-AF0C-11cf-97EA-00AA00C006B6")
DBConnection;
#endif

#ifndef __IDBConnections_INTERFACE_DEFINED__
#define __IDBConnections_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBConnections
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDBConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79937DA0-AA6D-11cf-97EA-00AA00C006B6")
    IDBConnections : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR ConnectString,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveConnections( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBConnections __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBConnections __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDBConnections __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR ConnectString,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveConnections )( 
            IDBConnections __RPC_FAR * This);
        
        END_INTERFACE
    } IDBConnectionsVtbl;

    interface IDBConnections
    {
        CONST_VTBL struct IDBConnectionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBConnections_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDBConnections_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDBConnections_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDBConnections_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDBConnections_get__NewEnum(This,_ppNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,_ppNewEnum)

#define IDBConnections_Item(This,Index,pDBConnection)	\
    (This)->lpVtbl -> Item(This,Index,pDBConnection)

#define IDBConnections_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define IDBConnections_get_Parent(This,pWebProject)	\
    (This)->lpVtbl -> get_Parent(This,pWebProject)

#define IDBConnections_Add(This,Name,ConnectString,pDBConnection)	\
    (This)->lpVtbl -> Add(This,Name,ConnectString,pDBConnection)

#define IDBConnections_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IDBConnections_SaveConnections(This)	\
    (This)->lpVtbl -> SaveConnections(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get__NewEnum_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);


void __RPC_STUB IDBConnections_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Item_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);


void __RPC_STUB IDBConnections_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get_Count_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB IDBConnections_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get_Parent_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject);


void __RPC_STUB IDBConnections_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Add_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ BSTR ConnectString,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);


void __RPC_STUB IDBConnections_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Remove_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ VARIANT Index);


void __RPC_STUB IDBConnections_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_SaveConnections_Proxy( 
    IDBConnections __RPC_FAR * This);


void __RPC_STUB IDBConnections_SaveConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBConnections_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DBConnections;

class DECLSPEC_UUID("79937DA2-AA6D-11cf-97EA-00AA00C006B6")
DBConnections;
#endif

#ifndef __IDataProject_INTERFACE_DEFINED__
#define __IDataProject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataProject
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDataProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("1AEE2F43-A42B-11cf-97EA-00AA00C006B6")
    IDataProject : public IGenericProject
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DBConnections( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *IDispatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDataProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDataProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDataProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDataProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDataProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDataProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDataProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IDataProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IDataProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IDataProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDataProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IDataProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IDataProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IDataProject __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBConnections )( 
            IDataProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *IDispatch);
        
        END_INTERFACE
    } IDataProjectVtbl;

    interface IDataProject
    {
        CONST_VTBL struct IDataProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDataProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDataProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDataProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDataProject_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IDataProject_get_FullName(This,Name)	\
    (This)->lpVtbl -> get_FullName(This,Name)

#define IDataProject_get_Application(This,Application)	\
    (This)->lpVtbl -> get_Application(This,Application)

#define IDataProject_get_Parent(This,Parent)	\
    (This)->lpVtbl -> get_Parent(This,Parent)

#define IDataProject_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IDataProject_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IDataProject_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IDataProject_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IDataProject_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IDataProject_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IDataProject_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IDataProject_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IDataProject_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IDataProject_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IDataProject_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)


#define IDataProject_get_DBConnections(This,IDispatch)	\
    (This)->lpVtbl -> get_DBConnections(This,IDispatch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDataProject_get_DBConnections_Proxy( 
    IDataProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *IDispatch);


void __RPC_STUB IDataProject_get_DBConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataProject_INTERFACE_DEFINED__ */


#ifndef __IDispDataProject_DISPINTERFACE_DEFINED__
#define __IDispDataProject_DISPINTERFACE_DEFINED__

/****************************************
 * Generated header for dispinterface: IDispDataProject
 * at Wed Dec 11 12:17:41 1996
 * using MIDL 3.01.59
 ****************************************/
/* [hidden][uuid] */ 



EXTERN_C const IID DIID_IDispDataProject;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("1c39e7e1-a9b7-11cf-97ea-00aa00c006b6")
    IDispDataProject : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IDispDataProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispDataProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispDataProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispDataProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDispDataProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDispDataProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDispDataProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDispDataProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IDispDataProjectVtbl;

    interface IDispDataProject
    {
        CONST_VTBL struct IDispDataProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispDataProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispDataProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispDataProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispDataProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDispDataProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDispDataProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDispDataProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IDispDataProject_DISPINTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DataProject;

class DECLSPEC_UUID("E50D4940-A9BD-11cf-97EA-00AA00C006B6")
DataProject;
#endif
#endif /* __DSDataProjects_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\dsrfid.h ===
//-----------------------------------------------------------------------------
// Microsoft DaVinci
//
// Microsoft Confidential
// Copyright 1994 - 1995 Microsoft Corporation. All Rights Reserved.
//
// File: dsrfguid.h
// Area: DSRef
// Contents:
// GUID definitions
//
// Owner: zacha         (3/17/95)      -       Created 
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// This file is not wrapped by an "#ifndef _DSCPGUID_H_" so that it can be
// included in both precompiled header files and GUID source files
//-----------------------------------------------------------------------------

// {E9B0E6DB-811C-11d0-AD51-00A0C90F5739}
DEFINE_GUID(CLSID_DSRef, 0xe9b0e6db, 0x811c, 0x11d0, 0xad, 0x51, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0x39);

// {ab36de41-2bf4-11ce-ab3c-00aa004404fb}
DEFINE_GUID(IID_IDSRefProvider, 0xab36de41, 0x2bf4, 0x11ce, 0xab, 0x3c, 0x00, 0xaa, 0x00, 0x44, 0x04, 0xfb);

// {ab36de42-2bf4-11ce-ab3c-00aa004404fb}
DEFINE_GUID(IID_IDSRefConsumer, 0xab36de42, 0x2bf4, 0x11ce, 0xab, 0x3c, 0x00, 0xaa, 0x00, 0x44, 0x04, 0xfb);


// {ab36de40-2bf4-11ce-ab3c-00aa004404fb}
DEFINE_GUID(CLSID_DSRef_R1, 0xab36de40, 0x2bf4, 0x11ce, 0xab, 0x3c, 0x00, 0xaa, 0x00, 0x44, 0x04, 0xfb);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\edguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	EDGUID.H
//		Editor package interface ids.
// TypeLibrary ID for Editor {  uuid(2A6DF200-8240-11cf-AB59-00AA00C091A1), 

DEFINE_GUID(TLID_TextEditor, 
	0x2A6DF200, 0x8240, 0x11cf, 0xAB, 0x59, 0x0, 0xAA, 0x00, 0xC0, 0x91, 0xA1);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\filechng.h ===
//-----------------------------------------------------------------------------
//  filechng.h
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:    A dummy class to accomadate filechange operations for the
//				build system. When the filechange notification is enabled
//				in the new shell, we can call the appropriate methods.
//				Untill then, we'll use these dummy methods.
//              modified.
//
//  Revision History:
//
//  []      10-Mar-1997 WinslowF    Created
//
//-----------------------------------------------------------------------------
#ifndef _FILECHNG_H
#define _FILECHNG_H

class FCItem;
typedef void (*PfnFCCallBack)( const FCItem *, DWORD dwUser );  // call back function
typedef void (*PfnAsyncReturn)( const FCItem * );
typedef void *		PV;

class FCItem {  // File Change Item
public:

};

class   CSection : public CRITICAL_SECTION 
{
public:
	CSection() {
		::InitializeCriticalSection ( this );
		}
	~CSection() {
		::DeleteCriticalSection ( this );
		}
	void Enter() {
		::EnterCriticalSection ( this );
		}
	void Leave() {
		::LeaveCriticalSection ( this );
		}
};

class   CTestableSection
{
private:
	CSection m_csBase;			// the "real" c.s. we are wrapping
	LONG m_cLocks;				// conceptually "inside" m_csBase

	DWORD m_idThread;			// thread identifier outside the base CSection
	CSection m_csIdThread;		// guards access to m_idThread
public:
	CTestableSection()
	{
		m_cLocks = 0;
		m_idThread = 0;
	}
	void Enter()
	{
		m_csBase.Enter();
		if (m_cLocks++ == 0)
		{
			// initialize m_idThread
			DWORD idThread = GetCurrentThreadId();

			m_csIdThread.Enter();
			m_idThread = idThread;
			m_csIdThread.Leave();
		}
	}
	void Leave() {
		_ASSERT(m_cLocks > 0);	// underflow test
		if (--m_cLocks == 0)
		{
			// clear m_idThread
			m_csIdThread.Enter();
			m_idThread = 0;
			m_csIdThread.Leave();
		}
		m_csBase.Leave();
	}
	BOOL FOwned()
	{
		DWORD idThread = GetCurrentThreadId();

		m_csIdThread.Enter();
		BOOL fOwned = idThread == m_idThread;
		m_csIdThread.Leave();
		
		return fOwned;
	}
};



// same as CritSection but for the "testable" variety
class CritSectionT 
{
	CTestableSection *	pcs;
public:
	CritSectionT ( CTestableSection & cs ) {
		cs.Enter();
		pcs = &cs;
		}
	~CritSectionT() {
		pcs->Leave();
		}
};


class CFileChange {

public:
	CFileChange(){};
	~CFileChange(){};

	// add a file to be watched
	BOOL FAddFile ( LPCTSTR szFile, PfnFCCallBack pfn, BOOL fCallAlways = FALSE )
    {
        return TRUE;
    };
	
	// remove a file from the list
	BOOL FDelFile ( LPCTSTR szFile, PfnFCCallBack pfn )
    {
        return TRUE;
    };

   	// async add file, returns true if queued successfully
	BOOL FAddFileAsync (LPCTSTR	szFile,	PfnFCCallBack, PfnAsyncReturn,
		PV pvUser1 = NULL, PV pvUser2 = NULL, BOOL fCallAlways = FALSE)
    {
        return TRUE;
    };

	// async del file, returns true if queued successfully
	BOOL FDelFileAsync (LPCTSTR szFile,	PfnFCCallBack, PfnAsyncReturn,
		PV pvUser1 = NULL, PV pvUser2 = NULL)
    {
        return TRUE;
    };

};


extern CFileChange	g_filechange;

inline CFileChange * GetFileChange()
{
    return &g_filechange;
}


// CIgnoreFile...used as an object to automatically ignore changes to
// a file while doing something with it.  Automatically unignores
// when object is destroyed.
//
class CIgnoreFile 
{
	// private default ctor--must use parametered version
	CIgnoreFile();

public:
	CIgnoreFile ( CFileChange * pfc, LPCTSTR sz, PfnFCCallBack pfn = NULL ) 
    {
	}

    ~CIgnoreFile() 
    {
	}

};


#endif // _FILECHNG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\entguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	ENTGUID.H
//		Enterprise package GUIDs.

// Class ID for custom document {34866991-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_EntCustomDocument, 
	0x34866991, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for schema document {34866992-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_EntSchemaDocument, 
	0x34866992, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for schema document {65CC4820-5341-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_EntGridDocument, 
	0x65cc4820, 0x5341, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\errcontext.h ===
// classes in this header
class CBldErrorContext;

#include <vcpb2.h>

/////////////////////////////////////////////////////////////////////////////
//	CBldErrorContext
//
//	Class for error contexts.  These are things you pass to a function to that
//	it can record any error messages it generates.  Thus a typical example is
//
//		BOOL SomeFunc ( argc ... , IVCBuildErrorContext* pEC = NULL );
//
//	The purpose of these things is to keep messages for the user, not to save
//	information for calling functions to examine.  Thus you should not examine
//	the contents of an EC to figure out what happened, rely on return codes or
//	whatever instead.

class CBldErrorContext :
	public IDispatchImpl<IVCBuildErrorContext, &IID_IVCBuildErrorContext, &LIBID_VCProjectEngineLibrary>, 
	public CComObjectRoot
{	 
public:
	CBldErrorContext() {}
	virtual ~CBldErrorContext()	{}
	static HRESULT CreateInstance(IVCBuildErrorContext** ppContext, CBldErrorContext** ppContextObj)
	{
		if (ppContext)
			*ppContext = NULL;
		if (ppContextObj)
			*ppContextObj = NULL;
		HRESULT hr;
		CBldErrorContext *pVar;
		CComObject<CBldErrorContext> *pObj;
		hr = CComObject<CBldErrorContext>::CreateInstance(&pObj);
		if (SUCCEEDED(hr))
		{
			pVar = pObj;
			pVar->AddRef();
			if (ppContext)
				*ppContext = pVar;
			if (ppContextObj)
				*ppContextObj = pObj;
		}
		return(hr);
	}

BEGIN_COM_MAP(CBldErrorContext)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCBuildErrorContext)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CBldErrorContext) 

// IVCBuildErrorContext
public:
	STDMETHOD(AddString)(/*[in]*/ BSTR bstrString) 	{ return S_OK; }
	STDMETHOD(AddLoggableString)(/*[in]*/ BSTR bstrString, /*[in]*/ int fFlags)	{ return S_OK; }
	STDMETHOD(AddLoggableStringFromID)(/*[in]*/ UINT nID, /*[in]*/ int fFlags) { return S_OK; }
	STDMETHOD(WriteLogString)(/*[in]*/ BSTR bstrString, /*[in]*/ VARIANT_BOOL bAddCtlLF) { return S_OK; }
	STDMETHOD(WriteLogStringFromID)(/*[in]*/ UINT nID) { return S_OK; }
	STDMETHOD(Close)() { return S_OK; }
	STDMETHOD(Reset)() { return S_OK; }	//	Clear the content of the context and prepared for a new, unrelated error:
	STDMETHOD(ActivateWindow)() { return S_OK; }
	STDMETHOD(ClearWindow)() { return S_OK; }
	STDMETHOD(AddErrorString)(/*[in]*/ BSTR bstrString) 	{ return S_OK; }
	STDMETHOD(AddWarningString)(/*[in]*/ BSTR bstrString, /*[in]*/ int fFlags)	{ return S_OK; }
	STDMETHOD(get_Warnings)( long *pnErr )
	{
		return S_OK;
	}
	STDMETHOD(get_Errors)( long *pnWrn )
	{
		return S_OK;
	}

protected:
	long m_nErrors;
	long m_nWarnings;


	//	Add a string to the ErrorConext.  Depending on the context, the string
	//	may or may not be displayed at this point:
	virtual void AddString(const TCHAR *pstr) {}
	virtual void AddString(UINT ResID) {}
	virtual void AddLoggableString(const TCHAR *pstr, int fFlags) {}
	virtual void AddLoggableString(UINT ResID, int fFlags) {}

	// Fill a string with all the messages in the context in the order in which
	// they we're added.  This is for _display_ only.  Classes the diplay 
	// messages as they occur may not implement this:
	virtual void GetString(CVCString &rstr) {}
	
	// Fill a string with all the messages in the context in the opposite order 
	// in which they we're added.  This should give a message of increasing 
	// specificity. For example:
	//
	//					Could not load document.
	//					Could not open file "blix.doc."
	//					Disk CRC error in sector la-de-da.
	// This is for _display_ only.  Classes the diplay messages as they occur 
	// may not implement this:
	virtual void GetRevString(CVCString &rstr) {}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\htmlguid.h ===
//===========================================================================
//  htmlguid.h
//
//	HTM Package GUIDS
//
//	Copyright (C) 1996 Microsoft Corporation,
//	All rights reserved.
//===========================================================================

#ifndef __HTMLGUID_H__
#define __HTMLGUID_H__

// {E6899811-0C72-11d0-8BF1-00A0C90F55D6}
DEFINE_GUID(IID_IHtmlLayoutDocument, 0xe6899811, 0xc72, 0x11d0, 0x8b, 0xf1, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xd6);

// {C92A2284-E3DD-11cf-A96F-00A0C90F55D6}
DEFINE_GUID(IID_IHtmlDocument, 0xc92a2284, 0xe3dd, 0x11cf, 0xa9, 0x6f, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xd6);

// {E95101F1-BA66-11cf-A40E-00AA00C00940}
DEFINE_GUID(SID_SHtmlSourceEditorSupport, 0xe95101f1, 0xba66, 0x11cf, 0xa4, 0xe, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);

// {E95101F2-BA66-11cf-A40E-00AA00C00940}
DEFINE_GUID(IID_IHtmlSourceEditorSupport, 0xe95101f2, 0xba66, 0x11cf, 0xa4, 0xe, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);

// {D18C18C1-304C-11d0-8158-00A0C91BBEE3}
DEFINE_GUID(SID_SWebDesignControlContext, 
0xd18c18c1, 0x304c, 0x11d0, 0x81, 0x58, 0x0, 0xa0, 0xc9, 0x1b, 0xbe, 0xe3);


#ifndef __DEFINE_DISPID_WDCC_SERVERLANGUAGE
#define __DEFINE_DISPID_WDCC_SERVERLANGUAGE
#define DISPID_WDCC_SERVERLANGUAGE	100
#endif


#endif // __HTMLGUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\galguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	GALGUID.H
//		Gallery package interface ids.

//	Interface ID for Object Gallery.
DEFINE_GUID(IID_IObjectGallery, 
	0xfa177f20, 0x5f34, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\gmap.h ===
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef INCLUDED_GMAP_H
#define INCLUDED_GMAP_H

#include <afx.h> // CObject
#include <afxtempl.h> // CMap
#include <limits.h> // INT_MAX

/* these are typedef's, not types.

	// GrowingMaps (aka Dictionaries)
	class CGrowingMapWordToOb;         // map from WORD to CObject*
	class CGrowingMapWordToPtr;        // map from WORD to void*
	class CGrowingMapPtrToWord;        // map from void* to WORD
	class CGrowingMapPtrToPtr;         // map from void* to void*

	// Special String variants
	class CGrowingMapStringToPtr;      // map from CString to void*
	class CGrowingMapStringToOb;       // map from CString to CObject*
	class CGrowingMapStringToString;   // map from CString to CString

*/

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CGrowingMap :
	public CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>
{
};

// These typedefs probably cause actual repeated compile time instantiation followed
// by link time dead stripping. They should probably be removed, or changed
// back to declarations with one time instantiation in a .cpp.

//typedef
//	CGrowingMap<CMapWordToOb, WORD, WORD, CObject*, CObject*>
//	CGrowingMapWordToOb;
typedef
	CGrowingMap<WORD, WORD, void*, void*>
	CGrowingMapWordToPtr;
typedef
	CGrowingMap<void*, void*, WORD, WORD>
	CGrowingMapPtrToWord;
typedef
	CGrowingMap<void*, void*, void*, void*>
	CGrowingMapPtrToPtr;
typedef
	CGrowingMap<CString, LPCTSTR, void*, void*>
	CGrowingMapStringToPtr;
//typedef
//	CGrowingMap<CString, LPCTSTR, CObject*, CObject*>
//	CGrowingMapStringToOb;
typedef
	CGrowingMap<CString, LPCTSTR, CString, LPCTSTR>
	CGrowingMapStringToString;


/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

// Some changes compared to CTypedPtrMap
// extra two ARG_ parameters allow CString's to work, cast through LPCTSTR

template<class BASE_CLASS, class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CTypedPtrGrowingMap :
	public BASE_CLASS
{
};

typedef CTypedPtrGrowingMap
<
	CGrowingMapStringToPtr,//CGrowingMap<CString, LPCTSTR, void*, void*>,
	CString, LPCTSTR,
	CObject*, CObject*
>
CGrowingMapStringToOb;

typedef CTypedPtrGrowingMap
<
	CGrowingMapWordToPtr,//CGrowingMap<WORD, WORD, void*, void*>,
	WORD, WORD,
	CObject*, CObject*
>
CGrowingMapWordToOb;

// TODO specialize some maps to not waste 4 bytes to cache a cheaply computed
// hash and recompute it while iterating, like MFC does.

// TODO reintroduce the optimizations of gmap3 and gmap4 that preinstantiated
// common maps in one place and inhibited instantiation otherwise.

#endif // the whole file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\idbgproj.h ===
//-----------------------------------------------------------------------------
// 
//
// Microsoft Confidential
// Copyright 1994 - 1995 Microsoft Corporation. All Rights Reserved.
//
// File: idbgproj.h
// Area: Non-Buildable Projects that can still Debug
// Contents:
//	Interface for Debugging without Building
//
// Owner: apennell		(10/2/96)	-	Created 
//-----------------------------------------------------------------------------

#ifndef _IDBGPROJ_H_
#define _IDBGPROJ_H_


//-----------------------------------------------------------------------------
// Name: IDBGProj
//
// Description:
// COM interface definition allowing non-builder projects to support debugging
//-----------------------------------------------------------------------------
DECLARE_INTERFACE_(IDBGProj, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (VOID) PURE;
	STDMETHOD_(ULONG, Release) (VOID) PURE;

	// IDBDisp methods
	STDMETHOD(SupportsDebugging)(UINT*) PURE;
	STDMETHOD(CommandExecute)(UINT) PURE;
	STDMETHOD(CommandEnabled)( UINT, BOOL* ) PURE;
};
typedef IDBGProj *PDBGPROJ;



#endif  // _IDBDGPROJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\galapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	GALAPI.H
//		Gallery package interface declarations.

#ifndef __GALAPI_H__
#define __GALAPI_H__

#ifndef STRICT
typedef DWORD HCUSTOMFEATUREREF;
#else	// STRICT
DECLARE_HANDLE(HCUSTOMFEATUREREF);
#endif	// STRICT

interface IObjectGallery;

typedef IObjectGallery* LPOBJECTGALLERY;

/////////////////////////////////////////////////////////////////////////////
// IObjectGallery
//   This interface is used by ClassWizard and custom oglets
//   to interact with the database, and create apply contexts.

#undef  INTERFACE
#define INTERFACE IObjectGallery
DECLARE_INTERFACE_(IObjectGallery, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IObjectGallery methods

	// Apply context creation methods
	STDMETHOD(CreateApplyContext)(THIS_ REFGUID rFeatureID, UINT nCreateFlags, LPVOID FAR* ppvObj) PURE;

	// Object Gallery Extension creation methods
	STDMETHOD(BeginNewExtension)(THIS_ LPCSTR pszName, HCUSTOMFEATUREREF* phExt) PURE;
	STDMETHOD(AddFile)(THIS_ HCUSTOMFEATUREREF hExt, LPCSTR pszFilename) PURE;
	STDMETHOD(AddResource)(THIS_ HCUSTOMFEATUREREF hExt, LPCSTR pszType, LPCSTR pszSymbol) PURE;
	STDMETHOD(EndExtension)(THIS_ HCUSTOMFEATUREREF hExt) PURE;
	STDMETHOD(ScanProject)(THIS_ LPCSTR pszConfig) PURE;
	STDMETHOD(ScanClass)(THIS_ LPCSTR pszClass) PURE;

	// Code writer methods.
	STDMETHOD(CreateMember)(THIS_ LPCSTR pszMember, UINT nAccess) PURE;
	STDMETHOD(CreateImplementation)(THIS_ LPCSTR pszMember, LPCSTR pszCode) PURE;

	// Misc.
	STDMETHOD(SetDefaultConfiguration)(THIS_ LPCSTR pszConfig) PURE;
	STDMETHOD(CommitEdits)(THIS) PURE;
	STDMETHOD(RevertEdits)(THIS) PURE;
	STDMETHOD(GetClassFiles)(THIS_ LPCSTR pszClass, CString& rstrHeader, CString& rstrImpl) PURE; 	// Non-standard COM.
	STDMETHOD(ClassAccess)(THIS_ LPCSTR pszClass, UINT nMode) PURE;
	STDMETHOD(FindInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
};
#define OPEN_ALWAYS_AC   (0)
#define CREATE_NEW_AC    (1)
#define OPEN_EXISTING_AC (2)

// Access mode flags
#ifndef MODE_READ
#define MODE_READ   (0)
#endif
#ifndef MODE_WRITE
#define MODE_WRITE  (1)
#endif

/////////////////////////////////////////////////////////////////////////////

#endif	// __GALAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\htmlpkg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.59 */
/* at Wed Dec 11 10:58:12 1996
 */
/* Compiler settings for htmlpkg.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __htmlpkg_h__
#define __htmlpkg_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IGenericDocument_FWD_DEFINED__
#define __IGenericDocument_FWD_DEFINED__
typedef interface IGenericDocument IGenericDocument;
#endif 	/* __IGenericDocument_FWD_DEFINED__ */


#ifndef __IGenericWindow_FWD_DEFINED__
#define __IGenericWindow_FWD_DEFINED__
typedef interface IGenericWindow IGenericWindow;
#endif 	/* __IGenericWindow_FWD_DEFINED__ */


#ifndef __IGenericProject_FWD_DEFINED__
#define __IGenericProject_FWD_DEFINED__
typedef interface IGenericProject IGenericProject;
#endif 	/* __IGenericProject_FWD_DEFINED__ */


#ifndef __IHtmlLayoutDocument_FWD_DEFINED__
#define __IHtmlLayoutDocument_FWD_DEFINED__
typedef interface IHtmlLayoutDocument IHtmlLayoutDocument;
#endif 	/* __IHtmlLayoutDocument_FWD_DEFINED__ */


#ifndef __IHtmlDocument_FWD_DEFINED__
#define __IHtmlDocument_FWD_DEFINED__
typedef interface IHtmlDocument IHtmlDocument;
#endif 	/* __IHtmlDocument_FWD_DEFINED__ */


#ifndef __IHtmlSourceEditorSupport_FWD_DEFINED__
#define __IHtmlSourceEditorSupport_FWD_DEFINED__
typedef interface IHtmlSourceEditorSupport IHtmlSourceEditorSupport;
#endif 	/* __IHtmlSourceEditorSupport_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_htmlpkg_0000
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//--------------------------------------------------------------------------
#ifndef _OLECTL_H_
#include <olectl.h>
#endif
#include <ObjModel\AppDefs.h>
#include <ObjModel\AppAuto.h>


extern RPC_IF_HANDLE __MIDL_itf_htmlpkg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htmlpkg_0000_v0_0_s_ifspec;


#ifndef __DSHTMLEditor_LIBRARY_DEFINED__
#define __DSHTMLEditor_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DSHTMLEditor
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


#if 0
typedef /* [hidden] */ 
enum tagDSWINDOWSTATE
    {	dsWindowStateMaximized	= 1,
	dsWindowStateMinimized	= 2,
	dsWindowStateNormal	= 3
    }	DsWindowState;

typedef /* [hidden] */ 
enum tagDSARRANGESTYLE
    {	dsMinimize	= 1,
	dsTileHorizontal	= 2,
	dsTileVertical	= 3,
	dsCascade	= 4
    }	DsArrangeStyle;

typedef /* [hidden] */ 
enum tagDSBUTTONTYPE
    {	dsGlyph	= 1,
	dsText	= 2
    }	DsButtonType;

typedef /* [hidden] */ 
enum tagDSSAVECHANGES
    {	dsSaveChangesYes	= 1,
	dsSaveChangesNo	= 2,
	dsSaveChangesPrompt	= 3
    }	DsSaveChanges;

typedef /* [hidden] */ 
enum tagDSSAVESTATUS
    {	dsSaveSucceeded	= 1,
	dsSaveCanceled	= 2
    }	DsSaveStatus;

#endif // 0

EXTERN_C const IID LIBID_DSHTMLEditor;

#ifndef __IGenericDocument_INTERFACE_DEFINED__
#define __IGenericDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericDocument
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FB7FDAE1-89B8-11cf-9BE8-00A0C90A632C")
    IGenericDocument : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pPath) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Saved( 
            /* [retval][out] */ boolean __RPC_FAR *pSaved) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveWindow( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ReadOnly( 
            /* [in] */ boolean ReadOnly) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ boolean bActive) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ boolean __RPC_FAR *pbActive) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NewWindow( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Undo( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Redo( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PrintOut( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Saved )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSaved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveWindow )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadOnly )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReadOnly )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ boolean ReadOnly);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windows )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IGenericDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrintOut )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IGenericDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericDocument __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericDocumentVtbl;

    interface IGenericDocument
    {
        CONST_VTBL struct IGenericDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericDocument_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IGenericDocument_get_FullName(This,pName)	\
    (This)->lpVtbl -> get_FullName(This,pName)

#define IGenericDocument_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#define IGenericDocument_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IGenericDocument_get_Path(This,pPath)	\
    (This)->lpVtbl -> get_Path(This,pPath)

#define IGenericDocument_get_Saved(This,pSaved)	\
    (This)->lpVtbl -> get_Saved(This,pSaved)

#define IGenericDocument_get_ActiveWindow(This,ppWindow)	\
    (This)->lpVtbl -> get_ActiveWindow(This,ppWindow)

#define IGenericDocument_get_ReadOnly(This,pReadOnly)	\
    (This)->lpVtbl -> get_ReadOnly(This,pReadOnly)

#define IGenericDocument_put_ReadOnly(This,ReadOnly)	\
    (This)->lpVtbl -> put_ReadOnly(This,ReadOnly)

#define IGenericDocument_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IGenericDocument_get_Windows(This,ppWindows)	\
    (This)->lpVtbl -> get_Windows(This,ppWindows)

#define IGenericDocument_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IGenericDocument_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IGenericDocument_NewWindow(This,ppWindow)	\
    (This)->lpVtbl -> NewWindow(This,ppWindow)

#define IGenericDocument_Save(This,vFilename,vBoolPrompt,pSaved)	\
    (This)->lpVtbl -> Save(This,vFilename,vBoolPrompt,pSaved)

#define IGenericDocument_Undo(This,pSuccess)	\
    (This)->lpVtbl -> Undo(This,pSuccess)

#define IGenericDocument_Redo(This,pSuccess)	\
    (This)->lpVtbl -> Redo(This,pSuccess)

#define IGenericDocument_PrintOut(This,pSuccess)	\
    (This)->lpVtbl -> PrintOut(This,pSuccess)

#define IGenericDocument_Close(This,vSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,vSaveChanges,pSaved)

#define IGenericDocument_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericDocument_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericDocument_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericDocument_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericDocument_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericDocument_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericDocument_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericDocument_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericDocument_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericDocument_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Name_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IGenericDocument_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_FullName_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IGenericDocument_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Application_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IGenericDocument_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Parent_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IGenericDocument_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Path_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pPath);


void __RPC_STUB IGenericDocument_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Saved_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_get_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_ActiveWindow_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);


void __RPC_STUB IGenericDocument_get_ActiveWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_ReadOnly_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pReadOnly);


void __RPC_STUB IGenericDocument_get_ReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericDocument_put_ReadOnly_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [in] */ boolean ReadOnly);


void __RPC_STUB IGenericDocument_put_ReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Type_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IGenericDocument_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Windows_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);


void __RPC_STUB IGenericDocument_get_Windows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericDocument_put_Active_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [in] */ boolean bActive);


void __RPC_STUB IGenericDocument_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Active_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbActive);


void __RPC_STUB IGenericDocument_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_NewWindow_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);


void __RPC_STUB IGenericDocument_NewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Save_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [optional][in] */ VARIANT vFilename,
    /* [optional][in] */ VARIANT vBoolPrompt,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Undo_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Redo_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_Redo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_PrintOut_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_PrintOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Close_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [optional][in] */ VARIANT vSaveChanges,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved1_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved2_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved3_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved4_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved5_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved6_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved7_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved8_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved9_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved10_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericDocument_INTERFACE_DEFINED__ */


#ifndef __IGenericWindow_INTERFACE_DEFINED__
#define __IGenericWindow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericWindow
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD20FC80-A9D2-11cf-9C13-00A0C90A632C")
    IGenericWindow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ boolean bActive) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ boolean __RPC_FAR *pbActive) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Next( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Previous( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ DsWindowState lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ DsWindowState __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ VARIANT boolSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericWindow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericWindow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Index )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Next )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Previous )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WindowState )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ DsWindowState lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WindowState )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ DsWindowState __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ VARIANT boolSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericWindow __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericWindowVtbl;

    interface IGenericWindow
    {
        CONST_VTBL struct IGenericWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericWindow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericWindow_get_Caption(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Caption(This,pbstrCaption)

#define IGenericWindow_get_Type(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Type(This,pbstrCaption)

#define IGenericWindow_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IGenericWindow_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IGenericWindow_put_Left(This,lVal)	\
    (This)->lpVtbl -> put_Left(This,lVal)

#define IGenericWindow_get_Left(This,plVal)	\
    (This)->lpVtbl -> get_Left(This,plVal)

#define IGenericWindow_put_Top(This,lVal)	\
    (This)->lpVtbl -> put_Top(This,lVal)

#define IGenericWindow_get_Top(This,plVal)	\
    (This)->lpVtbl -> get_Top(This,plVal)

#define IGenericWindow_put_Height(This,lVal)	\
    (This)->lpVtbl -> put_Height(This,lVal)

#define IGenericWindow_get_Height(This,plVal)	\
    (This)->lpVtbl -> get_Height(This,plVal)

#define IGenericWindow_put_Width(This,lVal)	\
    (This)->lpVtbl -> put_Width(This,lVal)

#define IGenericWindow_get_Width(This,plVal)	\
    (This)->lpVtbl -> get_Width(This,plVal)

#define IGenericWindow_get_Index(This,plVal)	\
    (This)->lpVtbl -> get_Index(This,plVal)

#define IGenericWindow_get_Next(This,ppDispatch)	\
    (This)->lpVtbl -> get_Next(This,ppDispatch)

#define IGenericWindow_get_Previous(This,ppDispatch)	\
    (This)->lpVtbl -> get_Previous(This,ppDispatch)

#define IGenericWindow_put_WindowState(This,lVal)	\
    (This)->lpVtbl -> put_WindowState(This,lVal)

#define IGenericWindow_get_WindowState(This,plVal)	\
    (This)->lpVtbl -> get_WindowState(This,plVal)

#define IGenericWindow_get_Application(This,ppDispatch)	\
    (This)->lpVtbl -> get_Application(This,ppDispatch)

#define IGenericWindow_get_Parent(This,ppDispatch)	\
    (This)->lpVtbl -> get_Parent(This,ppDispatch)

#define IGenericWindow_Close(This,boolSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,boolSaveChanges,pSaved)

#define IGenericWindow_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericWindow_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericWindow_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericWindow_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericWindow_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericWindow_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericWindow_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericWindow_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericWindow_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericWindow_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Caption_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);


void __RPC_STUB IGenericWindow_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Type_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);


void __RPC_STUB IGenericWindow_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Active_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ boolean bActive);


void __RPC_STUB IGenericWindow_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Active_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbActive);


void __RPC_STUB IGenericWindow_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Left_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Left_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Top_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Top_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Height_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Height_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Width_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Width_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Index_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Next_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Previous_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_WindowState_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ DsWindowState lVal);


void __RPC_STUB IGenericWindow_put_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_WindowState_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ DsWindowState __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Application_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Parent_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Close_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ VARIANT boolSaveChanges,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericWindow_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved1_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved2_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved3_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved4_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved5_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved6_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved7_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved8_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved9_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved10_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericWindow_INTERFACE_DEFINED__ */


#ifndef __IGenericProject_INTERFACE_DEFINED__
#define __IGenericProject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericProject
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8CA5A960-FC7D-11cf-927D-00A0C9138C45")
    IGenericProject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericProject __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericProjectVtbl;

    interface IGenericProject
    {
        CONST_VTBL struct IGenericProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericProject_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IGenericProject_get_FullName(This,Name)	\
    (This)->lpVtbl -> get_FullName(This,Name)

#define IGenericProject_get_Application(This,Application)	\
    (This)->lpVtbl -> get_Application(This,Application)

#define IGenericProject_get_Parent(This,Parent)	\
    (This)->lpVtbl -> get_Parent(This,Parent)

#define IGenericProject_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IGenericProject_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericProject_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericProject_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericProject_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericProject_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericProject_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericProject_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericProject_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericProject_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericProject_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Name_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IGenericProject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_FullName_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IGenericProject_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Application_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);


void __RPC_STUB IGenericProject_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Parent_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);


void __RPC_STUB IGenericProject_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Type_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IGenericProject_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved1_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved2_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved3_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved4_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved5_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved6_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved7_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved8_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved9_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved10_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericProject_INTERFACE_DEFINED__ */


#ifndef __IHtmlLayoutDocument_INTERFACE_DEFINED__
#define __IHtmlLayoutDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHtmlLayoutDocument
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IHtmlLayoutDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("E6899811-0C72-11d0-8BF1-00A0C90F55D6")
    IHtmlLayoutDocument : public IGenericDocument
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppContents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHtmlLayoutDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Saved )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSaved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveWindow )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadOnly )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReadOnly )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [in] */ boolean ReadOnly);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windows )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrintOut )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IHtmlLayoutDocument __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IHtmlLayoutDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppContents);
        
        END_INTERFACE
    } IHtmlLayoutDocumentVtbl;

    interface IHtmlLayoutDocument
    {
        CONST_VTBL struct IHtmlLayoutDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHtmlLayoutDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHtmlLayoutDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHtmlLayoutDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHtmlLayoutDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHtmlLayoutDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHtmlLayoutDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHtmlLayoutDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHtmlLayoutDocument_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IHtmlLayoutDocument_get_FullName(This,pName)	\
    (This)->lpVtbl -> get_FullName(This,pName)

#define IHtmlLayoutDocument_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#define IHtmlLayoutDocument_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IHtmlLayoutDocument_get_Path(This,pPath)	\
    (This)->lpVtbl -> get_Path(This,pPath)

#define IHtmlLayoutDocument_get_Saved(This,pSaved)	\
    (This)->lpVtbl -> get_Saved(This,pSaved)

#define IHtmlLayoutDocument_get_ActiveWindow(This,ppWindow)	\
    (This)->lpVtbl -> get_ActiveWindow(This,ppWindow)

#define IHtmlLayoutDocument_get_ReadOnly(This,pReadOnly)	\
    (This)->lpVtbl -> get_ReadOnly(This,pReadOnly)

#define IHtmlLayoutDocument_put_ReadOnly(This,ReadOnly)	\
    (This)->lpVtbl -> put_ReadOnly(This,ReadOnly)

#define IHtmlLayoutDocument_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IHtmlLayoutDocument_get_Windows(This,ppWindows)	\
    (This)->lpVtbl -> get_Windows(This,ppWindows)

#define IHtmlLayoutDocument_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IHtmlLayoutDocument_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IHtmlLayoutDocument_NewWindow(This,ppWindow)	\
    (This)->lpVtbl -> NewWindow(This,ppWindow)

#define IHtmlLayoutDocument_Save(This,vFilename,vBoolPrompt,pSaved)	\
    (This)->lpVtbl -> Save(This,vFilename,vBoolPrompt,pSaved)

#define IHtmlLayoutDocument_Undo(This,pSuccess)	\
    (This)->lpVtbl -> Undo(This,pSuccess)

#define IHtmlLayoutDocument_Redo(This,pSuccess)	\
    (This)->lpVtbl -> Redo(This,pSuccess)

#define IHtmlLayoutDocument_PrintOut(This,pSuccess)	\
    (This)->lpVtbl -> PrintOut(This,pSuccess)

#define IHtmlLayoutDocument_Close(This,vSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,vSaveChanges,pSaved)

#define IHtmlLayoutDocument_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IHtmlLayoutDocument_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IHtmlLayoutDocument_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IHtmlLayoutDocument_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IHtmlLayoutDocument_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IHtmlLayoutDocument_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IHtmlLayoutDocument_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IHtmlLayoutDocument_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IHtmlLayoutDocument_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IHtmlLayoutDocument_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)


#define IHtmlLayoutDocument_get_Contents(This,ppContents)	\
    (This)->lpVtbl -> get_Contents(This,ppContents)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHtmlLayoutDocument_get_Contents_Proxy( 
    IHtmlLayoutDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppContents);


void __RPC_STUB IHtmlLayoutDocument_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHtmlLayoutDocument_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_HtmlLayoutDocument;

class DECLSPEC_UUID("E6899813-0C72-11d0-8BF1-00A0C90F55D6")
HtmlLayoutDocument;
#endif

#ifndef __IHtmlDocument_INTERFACE_DEFINED__
#define __IHtmlDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHtmlDocument
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IHtmlDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("C92A2284-E3DD-11cf-A96F-00A0C90F55D6")
    IHtmlDocument : public IGenericDocument
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppContents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHtmlDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHtmlDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHtmlDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHtmlDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHtmlDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHtmlDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHtmlDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHtmlDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Saved )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSaved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveWindow )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadOnly )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReadOnly )( 
            IHtmlDocument __RPC_FAR * This,
            /* [in] */ boolean ReadOnly);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windows )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IHtmlDocument __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IHtmlDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrintOut )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IHtmlDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IHtmlDocument __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IHtmlDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppContents);
        
        END_INTERFACE
    } IHtmlDocumentVtbl;

    interface IHtmlDocument
    {
        CONST_VTBL struct IHtmlDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHtmlDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHtmlDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHtmlDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHtmlDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHtmlDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHtmlDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHtmlDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHtmlDocument_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IHtmlDocument_get_FullName(This,pName)	\
    (This)->lpVtbl -> get_FullName(This,pName)

#define IHtmlDocument_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#define IHtmlDocument_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IHtmlDocument_get_Path(This,pPath)	\
    (This)->lpVtbl -> get_Path(This,pPath)

#define IHtmlDocument_get_Saved(This,pSaved)	\
    (This)->lpVtbl -> get_Saved(This,pSaved)

#define IHtmlDocument_get_ActiveWindow(This,ppWindow)	\
    (This)->lpVtbl -> get_ActiveWindow(This,ppWindow)

#define IHtmlDocument_get_ReadOnly(This,pReadOnly)	\
    (This)->lpVtbl -> get_ReadOnly(This,pReadOnly)

#define IHtmlDocument_put_ReadOnly(This,ReadOnly)	\
    (This)->lpVtbl -> put_ReadOnly(This,ReadOnly)

#define IHtmlDocument_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IHtmlDocument_get_Windows(This,ppWindows)	\
    (This)->lpVtbl -> get_Windows(This,ppWindows)

#define IHtmlDocument_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IHtmlDocument_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IHtmlDocument_NewWindow(This,ppWindow)	\
    (This)->lpVtbl -> NewWindow(This,ppWindow)

#define IHtmlDocument_Save(This,vFilename,vBoolPrompt,pSaved)	\
    (This)->lpVtbl -> Save(This,vFilename,vBoolPrompt,pSaved)

#define IHtmlDocument_Undo(This,pSuccess)	\
    (This)->lpVtbl -> Undo(This,pSuccess)

#define IHtmlDocument_Redo(This,pSuccess)	\
    (This)->lpVtbl -> Redo(This,pSuccess)

#define IHtmlDocument_PrintOut(This,pSuccess)	\
    (This)->lpVtbl -> PrintOut(This,pSuccess)

#define IHtmlDocument_Close(This,vSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,vSaveChanges,pSaved)

#define IHtmlDocument_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IHtmlDocument_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IHtmlDocument_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IHtmlDocument_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IHtmlDocument_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IHtmlDocument_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IHtmlDocument_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IHtmlDocument_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IHtmlDocument_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IHtmlDocument_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)


#define IHtmlDocument_get_Contents(This,ppContents)	\
    (This)->lpVtbl -> get_Contents(This,ppContents)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHtmlDocument_get_Contents_Proxy( 
    IHtmlDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppContents);


void __RPC_STUB IHtmlDocument_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHtmlDocument_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_HtmlDocument;

class DECLSPEC_UUID("C92A2286-E3DD-11cf-A96F-00A0C90F55D6")
HtmlDocument;
#endif
#endif /* __DSHTMLEditor_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL_itf_htmlpkg_0101
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [local] */ 


///////////////////////////////////////////////////////////////////////////////
// IHtmlSourceEditorSupport Interface
// 
//
//	HRESULT GetPopDesc
//
//	Description:
//		Returns POPDESC for context menu.  Parses the text document for 
//		current state and returns appropriate POPDESC.  If GetPopDesc returns
//		S_OK, then all interfaces are held onto.  These interfaces will
//		be released in InvokeCommand.  You must always call InvokeCommand
//		if GetPopDesc succeeds.
//			
//	Arguments:
//		IUnknown* pSrcEdit: IN - ISourceEdit* for HTML document
//
//		IUnknown* pTextDoc: IN - ITextDocument for HTML document
//
//		IUnknown* pTextSel: IN - ITextSelection for HTML document
//
//		BYTE** ppPopDesc:  OUT - POPDESC for context menu to be displayed
//
//	Return (HRESULT): S_OK on success, error on failure
//
//
//
//
//	HRESULT InvokeCommand
//
//	Description:
//		Handles the Context menu command.  Releases the interfaces passed to
//		GetPopDesc.  This must be called ONLY if GetPopDesc succeeds.  Returns
//		S_OK if it handles the command.  If an error is returned then the 
//		command belongs to some other component.  In this case the command
//		should be routed in the appropriate manner.
//
//	Arguments:
//		int iCmdID: IN - Menu Command ID
//
//		HWND hwndOwner: HWND for HTML document
//
//	Return (HRESULT): S_OK if handles the command, ERROR otherwise.
//						
//
//
//	HRESULT HandleContextmenuUpdateCommand
//
//	Description:
//		OnUpdate handler for all context menu commands.  Takes the menu command
//		id and enables it depending on the results of parsing the HTML document.
//
//	Arguments:
//		CCmdUI* pCmdUI - IN : CCMDUI for menu item
//
//	Return (HRESULT): S_OK if valid command, E_NOTIMPL otherwise
//
//
//
//	HRESULT HandleCommand
//
//	Description:
//		Handles the top level menu command.  If it cant successfully handle the
//		command it will display an error message, and return an error.
//
//	Arguments:
//		int nID: IN - Menu Command ID
//
//		IUnknown* pSrcEdit: IN - ISourceEdit* for HTML document
//
//		IUnknown* pTextDoc: IN - ITextDocument for HTML document
//
//		IUnknown* pTextSel: IN - ITextSelection for HTML document
//
//		HWND hwndOwner: HWND for HTML document
//
//	Return (HRESULT): S_OK if successfully handled the command, error otherwise.
//


extern RPC_IF_HANDLE __MIDL_itf_htmlpkg_0101_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_htmlpkg_0101_v0_0_s_ifspec;

#ifndef __IHtmlSourceEditorSupport_INTERFACE_DEFINED__
#define __IHtmlSourceEditorSupport_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IHtmlSourceEditorSupport
 * at Wed Dec 11 10:58:12 1996
 * using MIDL 3.01.59
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IHtmlSourceEditorSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("E95101F2-BA66-11cf-A40E-00AA00C00940")
    IHtmlSourceEditorSupport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPopDesc( 
            /* [in] */ IUnknown __RPC_FAR *pSrcEdit,
            /* [in] */ IUnknown __RPC_FAR *pTextDoc,
            /* [in] */ IUnknown __RPC_FAR *pTextSel,
            /* [out] */ byte __RPC_FAR *__RPC_FAR *ppPopDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeCommand( 
            /* [in] */ int nCmdID,
            /* [in] */ HWND hwndOwner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleContextmenuUpdateCommand( 
            /* [in] */ byte __RPC_FAR *pCmdUI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleCommand( 
            /* [in] */ int nID,
            /* [in] */ IUnknown __RPC_FAR *pSrcEdit,
            /* [in] */ IUnknown __RPC_FAR *pTextDoc,
            /* [in] */ IUnknown __RPC_FAR *pTextSel,
            /* [in] */ HWND hwndOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHtmlSourceEditorSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHtmlSourceEditorSupport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHtmlSourceEditorSupport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHtmlSourceEditorSupport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPopDesc )( 
            IHtmlSourceEditorSupport __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pSrcEdit,
            /* [in] */ IUnknown __RPC_FAR *pTextDoc,
            /* [in] */ IUnknown __RPC_FAR *pTextSel,
            /* [out] */ byte __RPC_FAR *__RPC_FAR *ppPopDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeCommand )( 
            IHtmlSourceEditorSupport __RPC_FAR * This,
            /* [in] */ int nCmdID,
            /* [in] */ HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleContextmenuUpdateCommand )( 
            IHtmlSourceEditorSupport __RPC_FAR * This,
            /* [in] */ byte __RPC_FAR *pCmdUI);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleCommand )( 
            IHtmlSourceEditorSupport __RPC_FAR * This,
            /* [in] */ int nID,
            /* [in] */ IUnknown __RPC_FAR *pSrcEdit,
            /* [in] */ IUnknown __RPC_FAR *pTextDoc,
            /* [in] */ IUnknown __RPC_FAR *pTextSel,
            /* [in] */ HWND hwndOwner);
        
        END_INTERFACE
    } IHtmlSourceEditorSupportVtbl;

    interface IHtmlSourceEditorSupport
    {
        CONST_VTBL struct IHtmlSourceEditorSupportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHtmlSourceEditorSupport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHtmlSourceEditorSupport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHtmlSourceEditorSupport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHtmlSourceEditorSupport_GetPopDesc(This,pSrcEdit,pTextDoc,pTextSel,ppPopDesc)	\
    (This)->lpVtbl -> GetPopDesc(This,pSrcEdit,pTextDoc,pTextSel,ppPopDesc)

#define IHtmlSourceEditorSupport_InvokeCommand(This,nCmdID,hwndOwner)	\
    (This)->lpVtbl -> InvokeCommand(This,nCmdID,hwndOwner)

#define IHtmlSourceEditorSupport_HandleContextmenuUpdateCommand(This,pCmdUI)	\
    (This)->lpVtbl -> HandleContextmenuUpdateCommand(This,pCmdUI)

#define IHtmlSourceEditorSupport_HandleCommand(This,nID,pSrcEdit,pTextDoc,pTextSel,hwndOwner)	\
    (This)->lpVtbl -> HandleCommand(This,nID,pSrcEdit,pTextDoc,pTextSel,hwndOwner)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHtmlSourceEditorSupport_GetPopDesc_Proxy( 
    IHtmlSourceEditorSupport __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pSrcEdit,
    /* [in] */ IUnknown __RPC_FAR *pTextDoc,
    /* [in] */ IUnknown __RPC_FAR *pTextSel,
    /* [out] */ byte __RPC_FAR *__RPC_FAR *ppPopDesc);


void __RPC_STUB IHtmlSourceEditorSupport_GetPopDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHtmlSourceEditorSupport_InvokeCommand_Proxy( 
    IHtmlSourceEditorSupport __RPC_FAR * This,
    /* [in] */ int nCmdID,
    /* [in] */ HWND hwndOwner);


void __RPC_STUB IHtmlSourceEditorSupport_InvokeCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHtmlSourceEditorSupport_HandleContextmenuUpdateCommand_Proxy( 
    IHtmlSourceEditorSupport __RPC_FAR * This,
    /* [in] */ byte __RPC_FAR *pCmdUI);


void __RPC_STUB IHtmlSourceEditorSupport_HandleContextmenuUpdateCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHtmlSourceEditorSupport_HandleCommand_Proxy( 
    IHtmlSourceEditorSupport __RPC_FAR * This,
    /* [in] */ int nID,
    /* [in] */ IUnknown __RPC_FAR *pSrcEdit,
    /* [in] */ IUnknown __RPC_FAR *pTextDoc,
    /* [in] */ IUnknown __RPC_FAR *pTextSel,
    /* [in] */ HWND hwndOwner);


void __RPC_STUB IHtmlSourceEditorSupport_HandleCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHtmlSourceEditorSupport_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\iaxro.h ===
#if !defined(WIZARDS_SHELLEXT_IAXRO_H_INCLUDED_)
#define WIZARDS_SHELLEXT_IAXRO_H_INCLUDED_

//
//	Header file which defines the IDevStudioActiveXReferenceObject
//	interface which allows clients of the interface to determine the
//	sort of object which was found in the folder.
//
//	Descriptions:
//
//		GetTypeGuid()	- returns the guid of the type of object.
//						  returns GUID_DEVSTUDIO_ACTIVEX_REFOBJ_TYPE_CONTROL
//					      for ActiveX Controls,
//						  GUID_DEVSTUDIO_ACTIVEX_REFOBJ_TYPE_DEVSTUDIO_COMPONENT
//						  for DevStudio gallery components.
//
//		GetClsid()		- Returns the CLSID of the object
//
//		GetDisplayName()- Returns the name of the object, as desired
//						  by IShellFolder::GetDisplayNameOf()
//

interface IDevStudioActiveXReferenceObject : public IUnknown
{
	STDMETHOD(GetTypeGuid)(GUID &rguidType) PURE;
	STDMETHOD(GetClsid)(CLSID &rguidClsid) PURE;
	STDMETHOD(GetDisplayName)(DWORD uFlags, LPSTRRET lpName) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\idsref.h ===
//-----------------------------------------------------------------------------
// Microsoft DaVinci
//
// Microsoft Confidential
// Copyright 1994 - 1995 Microsoft Corporation. All Rights Reserved.
//
// File: idsref.h
// Area: DSRef
// Contents:
// IDSRefProvider and IDSRefConsumer COM interface definitions
//
// Owner: zacha		(12/28/94)	-	Created 
//-----------------------------------------------------------------------------

#ifndef _IDSREF_H_
#define _IDSREF_H_


// Types and Constants --------------------------------------------------------

// DSRef tree and node type information flags
enum DSREFTYPETag
{
	// Type information only available on DSRef tree root node
	DSREFTYPE_NULL = 0x00,					// Tree has no type information
	DSREFTYPE_COLLECTION = 0x01,			// Tree has multiple root nodes
	DSREFTYPE_MULTIPLE = 0x02,				// Tree has multiple leaf nodes
	DSREFTYPE_MIXED = 0x04,					// Multiple parents have leaf nodes

	// Type information only available on true DSRef tree nodes
	DSREFTYPE_DATASOURCEROOT = 0x10,		// Data source root node

	// Type information available on both DSRef tree root node and true nodes
	DSREFTYPE_FIELD				= 0x00000100,	// Field node
	DSREFTYPE_TABLE				= 0x00000200,	// Table node
	DSREFTYPE_QUERY				= 0x00000400,	// Query node (not a db object)
	DSREFTYPE_DATABASE			= 0x00000800,	// Database node
	DSREFTYPE_TRIGGER			= 0x00001000,	// Trigger node
	DSREFTYPE_STOREDPROCEDURE	= 0x00002000,	// Stored Procedure node
	DSREFTYPE_EXTENDED			= 0x00004000,	// Extended node
	DSREFTYPE_SCHEMADIAGRAM		= 0x00008000,	// Schema diagram
	DSREFTYPE_VIEW				= 0x00100000,	// View node
	DSREFTYPE_SYNONYM			= 0x00800000,   // Synonym node
	DSREFTYPE_FUNCTION			= 0x01000000,   // Function node
	DSREFTYPE_PACKAGE			= 0x02000000,   // Package node
	DSREFTYPE_PACKAGEBODY		= 0x04000000,   // Package body node

	// Type information used for persistence - internal use only
	// Clients of DSRef should not use these bit flags for determining
	// DSRef structure and properties.
	DSREFTYPE_HASFIRSTCHILD		= 0x00010000,	// Node has first child
	DSREFTYPE_HASNEXTSIBLING	= 0x00020000,	// Node has next sibling
	DSREFTYPE_HASNAME			= 0x00040000,	// Node has name
	DSREFTYPE_HASMONIKER		= 0x00080000,	// Node has moniker
	// DSREFTYPE_VIEW above uses  0x00100000
	DSREFTYPE_HASOWNER			= 0x00200000,	// Node has owner property
	DSREFTYPE_HASPROP			= 0x00400000,	// Node has additional properties
	// DSREFTYPE_SYNONYM - DSREFTYPE_PACKAGEBODY above use 0x00800000 - 0x04000000

};
typedef UINT	DSREFTYPE;	// Hungarian: grf

// Bit mask for node data source element type
#define DSREFTYPE_NODE	(DSREFTYPE_FIELD | \
						 DSREFTYPE_TABLE | \
						 DSREFTYPE_VIEW | \
						 DSREFTYPE_DATABASE | \
						 DSREFTYPE_TRIGGER | \
						 DSREFTYPE_STOREDPROCEDURE | \
						 DSREFTYPE_EXTENDED | \
						 DSREFTYPE_SCHEMADIAGRAM | \
						 DSREFTYPE_SYNONYM)

// DSRef node NodeID
#define DSREFNODEID_ROOT	0
#define DSREFNODEID_NIL		0
typedef VOID	*DSREFNODEID;	// Hungarian: drnid




//-----------------------------------------------------------------------------
// Name: IDSRefProvider
//
// Description:
// IDSRefProvider COM interface definition
//
// Thread-Safety: None
//-----------------------------------------------------------------------------
DECLARE_INTERFACE_(IDSRefProvider, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (VOID) PURE;
	STDMETHOD_(ULONG, Release) (VOID) PURE;

	// IDSRefProvider methods
	STDMETHOD(Clear) (VOID) PURE;
	STDMETHOD(CreateFirstChildNode) (
		DSREFNODEID drnidCurr,
		DSREFNODEID *pdrnidChild) PURE;
	STDMETHOD(CreateNextSiblingNode) (
		DSREFNODEID drnidCurr,
		DSREFNODEID *pdrnidSibling) PURE;
	STDMETHOD(SetType) (
		DSREFNODEID drnidCurr,
		DSREFTYPE grfType) PURE;
	STDMETHOD(SetExtendedType) (
		DSREFNODEID drnidCurr,
		const GUID *pguidType) PURE;
	STDMETHOD(SetName) (
		DSREFNODEID drnidCurr,
		BSTR bstrName) PURE;
	STDMETHOD(SetMoniker) (
		DSREFNODEID drnidCurr,
		IMoniker *pIMoniker) PURE;
	STDMETHOD(SetOwner) (
		DSREFNODEID drnidCurr,
		BSTR bstrOwnerName) PURE;
	STDMETHOD(SetProperty) (
		DSREFNODEID drnidCurr,
		REFGUID guidProp,
		VARIANT varPropValue) PURE;

};
typedef IDSRefProvider *PDSREFPROVIDER;




//-----------------------------------------------------------------------------
// Name: IDSRefConsumer
//
// Description:
// IDSRefConsumer COM interface definition
//
// Thread-Safety: None
//-----------------------------------------------------------------------------
DECLARE_INTERFACE_(IDSRefConsumer, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (VOID) PURE;
	STDMETHOD_(ULONG, Release) (VOID) PURE;

	// IDSRefConsumer methods
	STDMETHOD(GetVersion) (DWORD *pdwVersion) PURE;
	STDMETHOD(GetTimestamp) (FILETIME *pftTimestamp) PURE;
	STDMETHOD(GetFirstChildNode) (
		DSREFNODEID drnidCurr,
		DSREFNODEID *pdrnidChild) PURE;
	STDMETHOD(GetNextSiblingNode) (
		DSREFNODEID drnidCurr,
		DSREFNODEID *pdrnidSibling) PURE;
	STDMETHOD(GetType) (
		DSREFNODEID drnidCurr,
		DSREFTYPE *pgrfType) PURE;
	STDMETHOD(GetExtendedType) (
		DSREFNODEID drnidCurr,
		GUID *pguidType) PURE;
	STDMETHOD(GetName) (
		DSREFNODEID drnidCurr,
		BSTR *pbstrName) PURE;
	STDMETHOD(GetMoniker) (
		DSREFNODEID drnidCurr,
		IMoniker **ppIMoniker) PURE;
	STDMETHOD(GetOwner) (
		DSREFNODEID drnidCurr,
		BSTR *pbstrOwnerName) PURE;
	STDMETHOD(GetProperty) (
		DSREFNODEID drnidCurr,
		REFGUID guidProp,
		VARIANT *varPropValue) PURE;

};
typedef IDSRefConsumer *PDSREFCONSUMER;

// DSRef clipboard format text name
const TCHAR			szcfDSRef[] = TEXT("CF_DSREF");

#endif	// _IDSREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\iiv5.h ===
#ifndef __IIV5_H__
#define __IIV5_H__

/*
 *      IIV5.H
 *
 *  This file defines the COM interface IInfoViewer5.  This interface
 *  is used to access functionality of an individual InfoViewer title
 *  other than that available by binding to particular items.
 *
 *  This interface should be accessed by creating a moniker for the
 *  desired InfoViewer title (@ivt://id) and calling BindToObject.
 *
 *  Subfiles may be accessed by creating monikers for those
 *  files (@ivt://id/file) and calling BindToStorage to allocate
 *  an IStream.
 *
 *  Both IInfoViewer5's and IStream's are closed by calling Release.
 *
 *  IInfoViewer5Callback is used by controls to communicate
 *  with the InfoViewer5 application itself.
 *
 *  IInfoViewer5TitleCallback is used by the moniker to communicate
 *  with InfoViewer.
 */

typedef struct tagIVPROMPTINFO
{
    DWORD cbSize;
    DWORD dwFlags;
    LPOLESTR pwzTitleId;
    LPOLESTR pwzTitleName;
    LPOLESTR pwzTitleFile;
    LPOLESTR pwzVolumeId;
    LPOLESTR pwzVolumeName;
    LPOLESTR pwzLocation;
    DWORD cchMaxLocation;
} IVPROMPTINFO;

#define IIV5PROMPT_CONTENT          0x00000001
#define IIV5PROMPT_STRUCTURE        0x00000002
#define IIV5PROMPT_FTS              0x00000004
#define IIV5PROMPT_SINGLEFILE       0x00000008
#define IIV5PROMPT_ALREADYOPEN      0x00000100
#define IIV5PROMPT_LOCATIONCHANGED  0x00001000
#define IIV5PROMPT_NOPROMPT         0x00002000
#define IIV5PROMPT_NOCHECK          0x00004000

interface IInfoViewer5Callback : public IUnknown
{
public:
    STDMETHOD(ExecuteKLink)(LPOLESTR lpwzKeyword, LPOLESTR lpwzDefault) = 0;
    STDMETHOD(ExecuteALink)(LPOLESTR lpwzId, LPOLESTR lpwzDefault) = 0;
    STDMETHOD(GetSampleDir)(LPOLESTR lpwzSampleDir) = 0;
    STDMETHOD(SetSampleDir)(LPOLESTR lpwzSampleDir) = 0;
    STDMETHOD(ViewSample)(LPOLESTR lpwzFileName) = 0;
};

interface IInfoViewer5TitleCallback : public IUnknown
{
    STDMETHOD(Prompt)(IVPROMPTINFO * ppi) = 0;
    STDMETHOD(PollQueryContinue)() = 0;
};

interface IInfoViewer5 : public IUnknown
{
public:
    STDMETHOD(OpenSubfile)(LPOLESTR lpwzItem, IStream ** ppstm) = 0;
    STDMETHOD(LoadSubfile)(LPOLESTR lpwzItem, void ** ppdata, DWORD * pcb) = 0;
    STDMETHOD(FullTextSearch)(LPOLESTR lpwzQuery, int iOptions, int iNear, DWORD ** ppResults) = 0;
    STDMETHOD(SetTitleCallback)(IInfoViewer5TitleCallback * pcb) = 0;
    STDMETHOD(ConfirmFile)(DWORD dwFlags) = 0;
};

#endif

// { DCBF8E3x-9A4F-11CF-928E-00AA0057AD67 }
//
DEFINE_GUID( CLSID_IVT,
             0xdcbf8e30, 0x9a4f, 0x11cf,
             0x92, 0x8e, 0x00, 0xaa, 0x00, 0x57, 0xad, 0x67 );

DEFINE_GUID( CLSID_IVTMON,
             0xDCBF8E31, 0x9A4F, 0x11CF,
             0x92, 0x8e, 0x00, 0xaa, 0x00, 0x57, 0xad, 0x67 );

DEFINE_GUID( IID_IInfoViewer5Callback,
             0xDCBF8E32, 0x9A4F, 0x11CF,
             0x92, 0x8e, 0x00, 0xaa, 0x00, 0x57, 0xad, 0x67 );

DEFINE_GUID( IID_IInfoViewer5,
             0xDCBF8E33, 0x9A4F, 0x11CF,
             0x92, 0x8e, 0x00, 0xaa, 0x00, 0x57, 0xad, 0x67 );

DEFINE_GUID( IID_IInfoViewer5TitleCallback,
             0xDCBF8E34, 0x9A4F, 0x11CF,
             0x92, 0x8e, 0x00, 0xaa, 0x00, 0x57, 0xad, 0x67 );

// special error code from FullTextSearch for invalid query syntax
//
#define IV_ERR_SYNTAX   _HRESULT_TYPEDEF_(0x8CAC0001)
#define IV_ERR_NOINDEX  _HRESULT_TYPEDEF_(0x8CAC0002)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\isensapi.h ===
//	ISENSAPI.H
//
//
//	Interfaces for ISense stuff

#pragma once

#include <vsshell.h>
#include <bsc.h>
#include <cppsvc.h>
// Forward Declarations
//

class CStateSaver;
struct STATE_INFO;
struct BscEx;
struct POSDATA;

typedef 
enum _ERRORKIND
    {	ERROR_FATAL	= 0,
	ERROR_ERROR	= ERROR_FATAL + 1,
	ERROR_WARNING	= ERROR_ERROR + 1
    }	ERRORKIND;

struct IVCISense;
struct IVCSourceParser;
struct IVCAutoComplete;
struct IVsDropdownBarClient;
//struct IVCDropdpwnBarClient;
struct IWizBarInfo;
struct IVsTextView;

extern IVCISense *                  GetIVCISense                (void);
extern IVCAutoComplete *            GetIVCAutoComplete          (void);

__interface __declspec(uuid("{C3B426ED-AEE0-4d3c-8D2D-EE3928799251}")) IVCDropdownBarClient : public IVsDropdownBarClient
{
    STDMETHOD(UpdateCombos)(CComBSTR &bstrFunName, BOOL bInFunc, BOOL bInClass, USHORT uFuncIMod, TYP pTyp, ATR32 uAttr);
	STDMETHOD(OnNCBUpdate)(CodeElement *pElement);
};
typedef IVCDropdownBarClient* LPVCDROPDOWNBARCLIENT;


/////////////////////////////////////////////////////////////////////////////
//	IVCTaskProvider interface - used in taskprov.*

__interface __declspec(uuid("{1E5F7D5B-2698-4224-BD2C-1DA0CFC8922A}")) IVCTaskProvider : public IUnknown
{
	// IVCTaskProvider methods
    STDMETHOD(AddErrorTask)(const WCHAR *wszFileName, long iErrorID, ERRORKIND errKind, long iBegLine, long iBegCol, long iEndLine, long iEndCol, PCWSTR pszText, BOOL fDeferUntilRefresh);
    STDMETHOD(AddCommentTask)(long iLen,const WCHAR *pSTR, VSTASKPRIORITY  iPriority,UINT iLine, UINT iCol);
    STDMETHOD(RemoveErrorTasks)();
    STDMETHOD(RefreshTaskList)();
    STDMETHOD(OnTextEdit)(const POSDATA &posStart, const POSDATA &posOldEnd, const POSDATA &posNewEnd, IVsTextView *pVsTextView);
    STDMETHOD(ReloadForView)(IVsTextView *pVsTextView, BOOL fForce, BOOL *pfAddedToQueue);
    STDMETHOD(RemoveTasks)(IVsTextView *pVsTextView);
    STDMETHOD(SetBuffer)(IVsTextLines *pVsTextLines);
    STDMETHOD(ReParseForSquigglies)(IVsTextView *pVsTextView);
    STDMETHOD(ScanCommentTable)(UINT iStart, UINT iEnd, UINT iDelta, IVsTextView *pView);
    STDMETHOD(OnEndSquigglyParse)(DWORD dwHint);
    STDMETHOD(OnTerminateParseThread)();
};
typedef IVCTaskProvider* LPVCTASKPROVIDER;

__interface VCCodeClass;
/////////////////////////////////////////////////////////////////////////////
//	IVCISense interface - implemented by CISense, see isense subdir

__interface __declspec(uuid("{9B8BE586-02AC-437a-B552-905DE23288EF}")) IVCISense : public IUnknown
{
	// IVCISense methods
    STDMETHOD(GetVCTaskProvider)(IVCTaskProvider **ppVCTaskProvider);
	STDMETHOD(GetOverridesDispatch)(VCCodeClass *pClassIn, IDispatch **ppOut);
	STDMETHOD(GetMessageHandlerDispatch)(VCCodeClass *pClassIn, IDispatch **ppOut);
	STDMETHOD(GetEventHandlerDispatch)(VCCodeClass *pClassIn, IDispatch **ppOut);	
	STDMETHOD(GetControlHandlerDispatch)(VCCodeClass *pClassIn, BSTR bstrControlName, BSTR bstrControlType, IDispatch **ppOut);
	STDMETHOD(GetCommandHandlerDispatch)(VCCodeClass *pClassIn, BSTR bstrCommand, IDispatch **ppOut);
	STDMETHOD_(void, ReleaseAllPGrid)();	
    STDMETHOD(CreateWizardBar)(IWizBarInfo **ppOut);
    STDMETHOD(CreateDDBarClient)(IVsCodeWindow *m_pCodeWin, IWizBarInfo *m_pWizBarInfo, IVCDropdownBarClient **ppOut);
    STDMETHOD(SetCurrentDDBarClient)(IVCDropdownBarClient *ppIn, IVsTextView *pView, /*[in]*/ long iNewLine, IMOD pMod);
    STDMETHOD(SetLastLineAndMod)(long iNewLine, IMOD pMod);
    STDMETHOD_(IVCDropdownBarClient*, GetCurrentDDBarClient)();
};
typedef IVCISense* LPVCISENSE;

/////////////////////////////////////////////////////////////////////////////
//	IVCAutoComplete interface - implemented by CAutoComplete in autocomp.*
class CVCCMLocation;
__interface __declspec(uuid("{849AEF6B-CCAC-452c-80B4-C39970DBD134}")) IVCAutoComplete : public IUnknown
{
	// IVCAutoComplete methods
    STDMETHOD_(BOOL, RetrieveACInfo)(int *iBufferIndex, STATE_INFO **ppsi, BscEx** ppBscEx);
    STDMETHOD_(BOOL, GetActiveSI)(STATE_INFO **ppsi);
	STDMETHOD_(void, ResetActiveSI)(BOOL fSuccessWindow, BOOL fParseNeeded, BOOL fBeep);
	STDMETHOD(DoAutoComplete) (ULONG cmdFlags, ULONG charFlags, ULONG ichInsert, ULONG ilineInsert,
		BOOL fJingle, IVsTextView *pTextView, const WCHAR *wszFileName);
	STDMETHOD(OnChangeInTextEditor) (ULONG flags, ULONG ichInsert, ULONG ilineInsert,
		IVsTextView *pTextView, const WCHAR *wszFileName);
	STDMETHOD_(BOOL, OnACParseDone)(int iBufferIndex);
	STDMETHOD_(BOOL, FParamWindowUp)();
    STDMETHOD_(BOOL, FQuickInfoWindowUp)();
	STDMETHOD(DoAllReleases)();
    STDMETHOD_(BOOL, InitOnlyOnce)();
    STDMETHOD(GetCompletionSet)(IVsCompletionSet **ppSet);
    STDMETHOD_(BOOL, IsParseNeeded)();
    STDMETHOD(StartQuickInfo)(TextSpan *pTS, IVsTextView *pVsTextView, const WCHAR *wszFileName);
    STDMETHOD(OnCommand)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn);
	STDMETHOD(GetCommentForIinst) (IINST iinst, BSTR *pbstrComment) PURE;
	STDMETHOD(GetCommentLocationForIinst)(IINST iinst, INT* pnCommentLoc, 
		CVCCMLocation *pvccmLocation, BOOL* pbEolComment) PURE;
};
typedef IVCAutoComplete* LPVCAUTOCOMPLETE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\idbdisp.h ===
//-----------------------------------------------------------------------------
// 
//
// Microsoft Confidential
// Copyright 1994 - 1995 Microsoft Corporation. All Rights Reserved.
//
// File: idbdisp.h
// Area: DTG - ENT integration for debugging
// Contents:
//	Interface for displaying / editing / setting breakpoints
//
// Owner: cbrown		(8/14/96)	-	Created 
//-----------------------------------------------------------------------------

#ifndef _IDBDISP_H_
#define _IDBDISP_H_


//-----------------------------------------------------------------------------
// Name: IDBDisp
//
// Description:
// COM interface definition allowing ENT package to ask DTG to open stored
// procedures or triggers in edit windows during debug sessions
//-----------------------------------------------------------------------------
DECLARE_INTERFACE_(IDBTextDisp, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (VOID) PURE;
	STDMETHOD_(ULONG, Release) (VOID) PURE;

	// IDBDisp methods
	STDMETHOD(OpenFromName) (BSTR bstrName, BSTR bstrOwner, BSTR bstrDB, BSTR bstrServer, ISourceEdit** ppSEdit) PURE;
	STDMETHOD(OpenFromId) (UINT uProcId, ISourceEdit** ppSEdit) PURE;
	STDMETHOD(IdFromName) (BSTR bstrName, BSTR bstrOwner, BSTR bstrDB, BSTR bstrServer, UINT* pId) PURE;
	STDMETHOD(NameFromId)(BSTR* pbstrName, BSTR* pbstrOwner, BSTR bstrDB, BSTR bstrServer, UINT uId) PURE;
    STDMETHOD(ValidDoc)(ULONG uDocID) PURE;
};
typedef IDBTextDisp *PDBTEXTDISP;



#endif  // _IDBDISP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\iswsapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.59 */
/* at Wed Dec 11 12:17:47 1996
 */
/* Compiler settings for iswsapi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iswsapi_h__
#define __iswsapi_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IGenericDocument_FWD_DEFINED__
#define __IGenericDocument_FWD_DEFINED__
typedef interface IGenericDocument IGenericDocument;
#endif 	/* __IGenericDocument_FWD_DEFINED__ */


#ifndef __IGenericWindow_FWD_DEFINED__
#define __IGenericWindow_FWD_DEFINED__
typedef interface IGenericWindow IGenericWindow;
#endif 	/* __IGenericWindow_FWD_DEFINED__ */


#ifndef __IGenericProject_FWD_DEFINED__
#define __IGenericProject_FWD_DEFINED__
typedef interface IGenericProject IGenericProject;
#endif 	/* __IGenericProject_FWD_DEFINED__ */


#ifndef __IDBConnection_FWD_DEFINED__
#define __IDBConnection_FWD_DEFINED__
typedef interface IDBConnection IDBConnection;
#endif 	/* __IDBConnection_FWD_DEFINED__ */


#ifndef __IDBConnections_FWD_DEFINED__
#define __IDBConnections_FWD_DEFINED__
typedef interface IDBConnections IDBConnections;
#endif 	/* __IDBConnections_FWD_DEFINED__ */


#ifndef __IDBConnectionRuntime_FWD_DEFINED__
#define __IDBConnectionRuntime_FWD_DEFINED__
typedef interface IDBConnectionRuntime IDBConnectionRuntime;
#endif 	/* __IDBConnectionRuntime_FWD_DEFINED__ */


#ifndef __IWebProject_FWD_DEFINED__
#define __IWebProject_FWD_DEFINED__
typedef interface IWebProject IWebProject;
#endif 	/* __IWebProject_FWD_DEFINED__ */


#ifndef __IWebService_FWD_DEFINED__
#define __IWebService_FWD_DEFINED__
typedef interface IWebService IWebService;
#endif 	/* __IWebService_FWD_DEFINED__ */


#ifndef __IWebProjectFiles_FWD_DEFINED__
#define __IWebProjectFiles_FWD_DEFINED__
typedef interface IWebProjectFiles IWebProjectFiles;
#endif 	/* __IWebProjectFiles_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_iswsapi_0000
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif
#include "ObjModel\AppDefs.h"
#include "ObjModel\AppAuto.h"


extern RPC_IF_HANDLE __MIDL_itf_iswsapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iswsapi_0000_v0_0_s_ifspec;


#ifndef __DSWebProjects_LIBRARY_DEFINED__
#define __DSWebProjects_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DSWebProjects
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


#if 0
typedef /* [hidden] */ 
enum tagDSWINDOWSTATE
    {	dsWindowStateMaximized	= 1,
	dsWindowStateMinimized	= 2,
	dsWindowStateNormal	= 3
    }	DsWindowState;

typedef /* [hidden] */ 
enum tagDSARRANGESTYLE
    {	dsMinimize	= 1,
	dsTileHorizontal	= 2,
	dsTileVertical	= 3,
	dsCascade	= 4
    }	DsArrangeStyle;

typedef /* [hidden] */ 
enum tagDSBUTTONTYPE
    {	dsGlyph	= 1,
	dsText	= 2
    }	DsButtonType;

typedef /* [hidden] */ 
enum tagDSSAVECHANGES
    {	dsSaveChangesYes	= 1,
	dsSaveChangesNo	= 2,
	dsSaveChangesPrompt	= 3
    }	DsSaveChanges;

typedef /* [hidden] */ 
enum tagDSSAVESTATUS
    {	dsSaveSucceeded	= 1,
	dsSaveCanceled	= 2
    }	DsSaveStatus;

#endif // 0

EXTERN_C const IID LIBID_DSWebProjects;

#ifndef __IGenericDocument_INTERFACE_DEFINED__
#define __IGenericDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericDocument
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FB7FDAE1-89B8-11cf-9BE8-00A0C90A632C")
    IGenericDocument : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pPath) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Saved( 
            /* [retval][out] */ boolean __RPC_FAR *pSaved) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveWindow( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ReadOnly( 
            /* [in] */ boolean ReadOnly) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ boolean bActive) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ boolean __RPC_FAR *pbActive) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NewWindow( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Undo( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Redo( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PrintOut( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Saved )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSaved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveWindow )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadOnly )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReadOnly )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ boolean ReadOnly);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windows )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IGenericDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrintOut )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IGenericDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericDocument __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericDocumentVtbl;

    interface IGenericDocument
    {
        CONST_VTBL struct IGenericDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericDocument_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IGenericDocument_get_FullName(This,pName)	\
    (This)->lpVtbl -> get_FullName(This,pName)

#define IGenericDocument_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#define IGenericDocument_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IGenericDocument_get_Path(This,pPath)	\
    (This)->lpVtbl -> get_Path(This,pPath)

#define IGenericDocument_get_Saved(This,pSaved)	\
    (This)->lpVtbl -> get_Saved(This,pSaved)

#define IGenericDocument_get_ActiveWindow(This,ppWindow)	\
    (This)->lpVtbl -> get_ActiveWindow(This,ppWindow)

#define IGenericDocument_get_ReadOnly(This,pReadOnly)	\
    (This)->lpVtbl -> get_ReadOnly(This,pReadOnly)

#define IGenericDocument_put_ReadOnly(This,ReadOnly)	\
    (This)->lpVtbl -> put_ReadOnly(This,ReadOnly)

#define IGenericDocument_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IGenericDocument_get_Windows(This,ppWindows)	\
    (This)->lpVtbl -> get_Windows(This,ppWindows)

#define IGenericDocument_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IGenericDocument_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IGenericDocument_NewWindow(This,ppWindow)	\
    (This)->lpVtbl -> NewWindow(This,ppWindow)

#define IGenericDocument_Save(This,vFilename,vBoolPrompt,pSaved)	\
    (This)->lpVtbl -> Save(This,vFilename,vBoolPrompt,pSaved)

#define IGenericDocument_Undo(This,pSuccess)	\
    (This)->lpVtbl -> Undo(This,pSuccess)

#define IGenericDocument_Redo(This,pSuccess)	\
    (This)->lpVtbl -> Redo(This,pSuccess)

#define IGenericDocument_PrintOut(This,pSuccess)	\
    (This)->lpVtbl -> PrintOut(This,pSuccess)

#define IGenericDocument_Close(This,vSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,vSaveChanges,pSaved)

#define IGenericDocument_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericDocument_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericDocument_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericDocument_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericDocument_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericDocument_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericDocument_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericDocument_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericDocument_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericDocument_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Name_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IGenericDocument_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_FullName_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IGenericDocument_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Application_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IGenericDocument_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Parent_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IGenericDocument_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Path_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pPath);


void __RPC_STUB IGenericDocument_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Saved_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_get_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_ActiveWindow_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);


void __RPC_STUB IGenericDocument_get_ActiveWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_ReadOnly_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pReadOnly);


void __RPC_STUB IGenericDocument_get_ReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericDocument_put_ReadOnly_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [in] */ boolean ReadOnly);


void __RPC_STUB IGenericDocument_put_ReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Type_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IGenericDocument_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Windows_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);


void __RPC_STUB IGenericDocument_get_Windows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericDocument_put_Active_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [in] */ boolean bActive);


void __RPC_STUB IGenericDocument_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Active_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbActive);


void __RPC_STUB IGenericDocument_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_NewWindow_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);


void __RPC_STUB IGenericDocument_NewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Save_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [optional][in] */ VARIANT vFilename,
    /* [optional][in] */ VARIANT vBoolPrompt,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Undo_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Redo_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_Redo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_PrintOut_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_PrintOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Close_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [optional][in] */ VARIANT vSaveChanges,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved1_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved2_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved3_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved4_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved5_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved6_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved7_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved8_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved9_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved10_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericDocument_INTERFACE_DEFINED__ */


#ifndef __IGenericWindow_INTERFACE_DEFINED__
#define __IGenericWindow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericWindow
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD20FC80-A9D2-11cf-9C13-00A0C90A632C")
    IGenericWindow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ boolean bActive) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ boolean __RPC_FAR *pbActive) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Next( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Previous( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ DsWindowState lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ DsWindowState __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ VARIANT boolSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericWindow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericWindow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Index )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Next )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Previous )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WindowState )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ DsWindowState lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WindowState )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ DsWindowState __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ VARIANT boolSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericWindow __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericWindowVtbl;

    interface IGenericWindow
    {
        CONST_VTBL struct IGenericWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericWindow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericWindow_get_Caption(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Caption(This,pbstrCaption)

#define IGenericWindow_get_Type(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Type(This,pbstrCaption)

#define IGenericWindow_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IGenericWindow_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IGenericWindow_put_Left(This,lVal)	\
    (This)->lpVtbl -> put_Left(This,lVal)

#define IGenericWindow_get_Left(This,plVal)	\
    (This)->lpVtbl -> get_Left(This,plVal)

#define IGenericWindow_put_Top(This,lVal)	\
    (This)->lpVtbl -> put_Top(This,lVal)

#define IGenericWindow_get_Top(This,plVal)	\
    (This)->lpVtbl -> get_Top(This,plVal)

#define IGenericWindow_put_Height(This,lVal)	\
    (This)->lpVtbl -> put_Height(This,lVal)

#define IGenericWindow_get_Height(This,plVal)	\
    (This)->lpVtbl -> get_Height(This,plVal)

#define IGenericWindow_put_Width(This,lVal)	\
    (This)->lpVtbl -> put_Width(This,lVal)

#define IGenericWindow_get_Width(This,plVal)	\
    (This)->lpVtbl -> get_Width(This,plVal)

#define IGenericWindow_get_Index(This,plVal)	\
    (This)->lpVtbl -> get_Index(This,plVal)

#define IGenericWindow_get_Next(This,ppDispatch)	\
    (This)->lpVtbl -> get_Next(This,ppDispatch)

#define IGenericWindow_get_Previous(This,ppDispatch)	\
    (This)->lpVtbl -> get_Previous(This,ppDispatch)

#define IGenericWindow_put_WindowState(This,lVal)	\
    (This)->lpVtbl -> put_WindowState(This,lVal)

#define IGenericWindow_get_WindowState(This,plVal)	\
    (This)->lpVtbl -> get_WindowState(This,plVal)

#define IGenericWindow_get_Application(This,ppDispatch)	\
    (This)->lpVtbl -> get_Application(This,ppDispatch)

#define IGenericWindow_get_Parent(This,ppDispatch)	\
    (This)->lpVtbl -> get_Parent(This,ppDispatch)

#define IGenericWindow_Close(This,boolSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,boolSaveChanges,pSaved)

#define IGenericWindow_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericWindow_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericWindow_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericWindow_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericWindow_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericWindow_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericWindow_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericWindow_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericWindow_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericWindow_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Caption_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);


void __RPC_STUB IGenericWindow_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Type_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);


void __RPC_STUB IGenericWindow_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Active_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ boolean bActive);


void __RPC_STUB IGenericWindow_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Active_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbActive);


void __RPC_STUB IGenericWindow_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Left_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Left_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Top_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Top_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Height_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Height_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Width_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Width_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Index_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Next_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Previous_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_WindowState_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ DsWindowState lVal);


void __RPC_STUB IGenericWindow_put_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_WindowState_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ DsWindowState __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Application_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Parent_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Close_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ VARIANT boolSaveChanges,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericWindow_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved1_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved2_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved3_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved4_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved5_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved6_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved7_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved8_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved9_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved10_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericWindow_INTERFACE_DEFINED__ */


#ifndef __IGenericProject_INTERFACE_DEFINED__
#define __IGenericProject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericProject
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8CA5A960-FC7D-11cf-927D-00A0C9138C45")
    IGenericProject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericProject __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericProjectVtbl;

    interface IGenericProject
    {
        CONST_VTBL struct IGenericProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericProject_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IGenericProject_get_FullName(This,Name)	\
    (This)->lpVtbl -> get_FullName(This,Name)

#define IGenericProject_get_Application(This,Application)	\
    (This)->lpVtbl -> get_Application(This,Application)

#define IGenericProject_get_Parent(This,Parent)	\
    (This)->lpVtbl -> get_Parent(This,Parent)

#define IGenericProject_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IGenericProject_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericProject_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericProject_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericProject_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericProject_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericProject_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericProject_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericProject_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericProject_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericProject_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Name_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IGenericProject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_FullName_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IGenericProject_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Application_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);


void __RPC_STUB IGenericProject_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Parent_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);


void __RPC_STUB IGenericProject_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Type_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IGenericProject_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved1_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved2_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved3_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved4_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved5_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved6_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved7_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved8_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved9_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved10_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericProject_INTERFACE_DEFINED__ */


#ifndef __IDBConnection_INTERFACE_DEFINED__
#define __IDBConnection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBConnection
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDBConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("F7CCDBA0-AF0C-11cf-97EA-00AA00C006B6")
    IDBConnection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectString( 
            /* [retval][out] */ BSTR __RPC_FAR *pConnectString) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectString( 
            /* [in] */ BSTR ConnectString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionTimeout( 
            /* [retval][out] */ long __RPC_FAR *pTimeout) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionTimeout( 
            /* [in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CommandTimeout( 
            /* [retval][out] */ long __RPC_FAR *pTimeout) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CommandTimeout( 
            /* [in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Runtime( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Connected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDBConnection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectString )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pConnectString);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectString )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ BSTR ConnectString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pTimeout);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ long Timeout);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pTimeout);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ long Timeout);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Runtime )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Connected )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IDBConnection __RPC_FAR * This);
        
        END_INTERFACE
    } IDBConnectionVtbl;

    interface IDBConnection
    {
        CONST_VTBL struct IDBConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBConnection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDBConnection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDBConnection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDBConnection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDBConnection_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IDBConnection_put_Name(This,Name)	\
    (This)->lpVtbl -> put_Name(This,Name)

#define IDBConnection_get_Parent(This,pParent)	\
    (This)->lpVtbl -> get_Parent(This,pParent)

#define IDBConnection_get_ConnectString(This,pConnectString)	\
    (This)->lpVtbl -> get_ConnectString(This,pConnectString)

#define IDBConnection_put_ConnectString(This,ConnectString)	\
    (This)->lpVtbl -> put_ConnectString(This,ConnectString)

#define IDBConnection_get_ConnectionTimeout(This,pTimeout)	\
    (This)->lpVtbl -> get_ConnectionTimeout(This,pTimeout)

#define IDBConnection_put_ConnectionTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_ConnectionTimeout(This,Timeout)

#define IDBConnection_get_CommandTimeout(This,pTimeout)	\
    (This)->lpVtbl -> get_CommandTimeout(This,pTimeout)

#define IDBConnection_put_CommandTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,Timeout)

#define IDBConnection_get_Runtime(This,pRuntime)	\
    (This)->lpVtbl -> get_Runtime(This,pRuntime)

#define IDBConnection_get_Connected(This,pValid)	\
    (This)->lpVtbl -> get_Connected(This,pValid)

#define IDBConnection_Connect(This)	\
    (This)->lpVtbl -> Connect(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Name_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IDBConnection_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_Name_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IDBConnection_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Parent_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);


void __RPC_STUB IDBConnection_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_ConnectString_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pConnectString);


void __RPC_STUB IDBConnection_get_ConnectString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_ConnectString_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ BSTR ConnectString);


void __RPC_STUB IDBConnection_put_ConnectString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_ConnectionTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pTimeout);


void __RPC_STUB IDBConnection_get_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_ConnectionTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ long Timeout);


void __RPC_STUB IDBConnection_put_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_CommandTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pTimeout);


void __RPC_STUB IDBConnection_get_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_CommandTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ long Timeout);


void __RPC_STUB IDBConnection_put_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Runtime_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime);


void __RPC_STUB IDBConnection_get_Runtime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Connected_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid);


void __RPC_STUB IDBConnection_get_Connected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnection_Connect_Proxy( 
    IDBConnection __RPC_FAR * This);


void __RPC_STUB IDBConnection_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBConnection_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DBConnection;

class DECLSPEC_UUID("F7CCDBA2-AF0C-11cf-97EA-00AA00C006B6")
DBConnection;
#endif

#ifndef __IDBConnections_INTERFACE_DEFINED__
#define __IDBConnections_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBConnections
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDBConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79937DA0-AA6D-11cf-97EA-00AA00C006B6")
    IDBConnections : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR ConnectString,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveConnections( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBConnections __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBConnections __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDBConnections __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR ConnectString,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveConnections )( 
            IDBConnections __RPC_FAR * This);
        
        END_INTERFACE
    } IDBConnectionsVtbl;

    interface IDBConnections
    {
        CONST_VTBL struct IDBConnectionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBConnections_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDBConnections_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDBConnections_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDBConnections_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDBConnections_get__NewEnum(This,_ppNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,_ppNewEnum)

#define IDBConnections_Item(This,Index,pDBConnection)	\
    (This)->lpVtbl -> Item(This,Index,pDBConnection)

#define IDBConnections_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define IDBConnections_get_Parent(This,pWebProject)	\
    (This)->lpVtbl -> get_Parent(This,pWebProject)

#define IDBConnections_Add(This,Name,ConnectString,pDBConnection)	\
    (This)->lpVtbl -> Add(This,Name,ConnectString,pDBConnection)

#define IDBConnections_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IDBConnections_SaveConnections(This)	\
    (This)->lpVtbl -> SaveConnections(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get__NewEnum_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);


void __RPC_STUB IDBConnections_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Item_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);


void __RPC_STUB IDBConnections_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get_Count_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB IDBConnections_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get_Parent_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject);


void __RPC_STUB IDBConnections_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Add_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ BSTR ConnectString,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);


void __RPC_STUB IDBConnections_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Remove_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ VARIANT Index);


void __RPC_STUB IDBConnections_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_SaveConnections_Proxy( 
    IDBConnections __RPC_FAR * This);


void __RPC_STUB IDBConnections_SaveConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBConnections_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DBConnections;

class DECLSPEC_UUID("79937DA2-AA6D-11cf-97EA-00AA00C006B6")
DBConnections;
#endif

#ifndef __IDBConnectionRuntime_INTERFACE_DEFINED__
#define __IDBConnectionRuntime_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBConnectionRuntime
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDBConnectionRuntime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7FE1F3C1-076E-11d0-8BEC-00A0C90F55D6")
    IDBConnectionRuntime : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UserName( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Password( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Password( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CursorLocation( 
            /* [retval][out] */ long __RPC_FAR *pLocation) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CursorLocation( 
            /* [in] */ long Location) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBConnectionRuntimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBConnectionRuntime __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBConnectionRuntime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserName )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserName )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Password )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Password )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorLocation )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pLocation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorLocation )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ long Location);
        
        END_INTERFACE
    } IDBConnectionRuntimeVtbl;

    interface IDBConnectionRuntime
    {
        CONST_VTBL struct IDBConnectionRuntimeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBConnectionRuntime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBConnectionRuntime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBConnectionRuntime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBConnectionRuntime_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDBConnectionRuntime_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDBConnectionRuntime_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDBConnectionRuntime_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDBConnectionRuntime_get_Parent(This,pParent)	\
    (This)->lpVtbl -> get_Parent(This,pParent)

#define IDBConnectionRuntime_get_UserName(This,pName)	\
    (This)->lpVtbl -> get_UserName(This,pName)

#define IDBConnectionRuntime_put_UserName(This,Name)	\
    (This)->lpVtbl -> put_UserName(This,Name)

#define IDBConnectionRuntime_get_Password(This,pName)	\
    (This)->lpVtbl -> get_Password(This,pName)

#define IDBConnectionRuntime_put_Password(This,Name)	\
    (This)->lpVtbl -> put_Password(This,Name)

#define IDBConnectionRuntime_get_CursorLocation(This,pLocation)	\
    (This)->lpVtbl -> get_CursorLocation(This,pLocation)

#define IDBConnectionRuntime_put_CursorLocation(This,Location)	\
    (This)->lpVtbl -> put_CursorLocation(This,Location)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_get_Parent_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);


void __RPC_STUB IDBConnectionRuntime_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_get_UserName_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IDBConnectionRuntime_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_put_UserName_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IDBConnectionRuntime_put_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_get_Password_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IDBConnectionRuntime_get_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_put_Password_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IDBConnectionRuntime_put_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_get_CursorLocation_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pLocation);


void __RPC_STUB IDBConnectionRuntime_get_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_put_CursorLocation_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [in] */ long Location);


void __RPC_STUB IDBConnectionRuntime_put_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBConnectionRuntime_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DBConnectionRuntime;

class DECLSPEC_UUID("FF35DE52-0772-11d0-8BEC-00A0C90F55D6")
DBConnectionRuntime;
#endif

#ifndef __IWebProject_INTERFACE_DEFINED__
#define __IWebProject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWebProject
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IWebProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("1AEE2F43-A42B-11cf-97EA-00AA00C006B6")
    IWebProject : public IGenericProject
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WorkingDirectory( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkingDirectory) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
            /* [retval][out] */ BSTR __RPC_FAR *pServerName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualRoot( 
            /* [retval][out] */ BSTR __RPC_FAR *pVirtualRoot) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FPWebProject( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFpWebProject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DBConnections( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDBConnections) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddFolder( 
            /* [in] */ BSTR FolderURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddFile( 
            /* [in] */ BSTR FileURL,
            /* [in] */ BSTR LocalFilename,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFiles( 
            /* [in] */ BSTR ProjectRelativeURL,
            /* [in] */ long Flags,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseFiles( 
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateFiles( 
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFileStatus( 
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SyncProject( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveFiles( 
            /* [in] */ BSTR FromProjectRelativeURL,
            /* [in] */ BSTR ToProjectRelativeURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RenameFiles( 
            /* [in] */ BSTR FromProjectRelativeURL,
            /* [in] */ BSTR ToProjectRelativeURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteFiles( 
            /* [in] */ BSTR ProjectRelativeURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseProject( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteProject( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IWebProject __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkingDirectory )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkingDirectory);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerName )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pServerName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VirtualRoot )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVirtualRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FPWebProject )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFpWebProject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBConnections )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDBConnections);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFolder )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR FolderURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFile )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR FileURL,
            /* [in] */ BSTR LocalFilename,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL,
            /* [in] */ long Flags,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileStatus )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SyncProject )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR FromProjectRelativeURL,
            /* [in] */ BSTR ToProjectRelativeURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenameFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR FromProjectRelativeURL,
            /* [in] */ BSTR ToProjectRelativeURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseProject )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProject )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        END_INTERFACE
    } IWebProjectVtbl;

    interface IWebProject
    {
        CONST_VTBL struct IWebProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebProject_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IWebProject_get_FullName(This,Name)	\
    (This)->lpVtbl -> get_FullName(This,Name)

#define IWebProject_get_Application(This,Application)	\
    (This)->lpVtbl -> get_Application(This,Application)

#define IWebProject_get_Parent(This,Parent)	\
    (This)->lpVtbl -> get_Parent(This,Parent)

#define IWebProject_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IWebProject_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IWebProject_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IWebProject_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IWebProject_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IWebProject_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IWebProject_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IWebProject_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IWebProject_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IWebProject_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IWebProject_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)


#define IWebProject_get_WorkingDirectory(This,pWorkingDirectory)	\
    (This)->lpVtbl -> get_WorkingDirectory(This,pWorkingDirectory)

#define IWebProject_get_ServerName(This,pServerName)	\
    (This)->lpVtbl -> get_ServerName(This,pServerName)

#define IWebProject_get_VirtualRoot(This,pVirtualRoot)	\
    (This)->lpVtbl -> get_VirtualRoot(This,pVirtualRoot)

#define IWebProject_get_FPWebProject(This,ppFpWebProject)	\
    (This)->lpVtbl -> get_FPWebProject(This,ppFpWebProject)

#define IWebProject_get_DBConnections(This,ppDBConnections)	\
    (This)->lpVtbl -> get_DBConnections(This,ppDBConnections)

#define IWebProject_AddFolder(This,FolderURL,pSuccess)	\
    (This)->lpVtbl -> AddFolder(This,FolderURL,pSuccess)

#define IWebProject_AddFile(This,FileURL,LocalFilename,pSuccess)	\
    (This)->lpVtbl -> AddFile(This,FileURL,LocalFilename,pSuccess)

#define IWebProject_GetFiles(This,ProjectRelativeURL,Flags,pSuccess)	\
    (This)->lpVtbl -> GetFiles(This,ProjectRelativeURL,Flags,pSuccess)

#define IWebProject_ReleaseFiles(This,ProjectRelativeURL,pSuccess)	\
    (This)->lpVtbl -> ReleaseFiles(This,ProjectRelativeURL,pSuccess)

#define IWebProject_UpdateFiles(This,ProjectRelativeURL,pSuccess)	\
    (This)->lpVtbl -> UpdateFiles(This,ProjectRelativeURL,pSuccess)

#define IWebProject_GetFileStatus(This,ProjectRelativeURL,pSuccess)	\
    (This)->lpVtbl -> GetFileStatus(This,ProjectRelativeURL,pSuccess)

#define IWebProject_SyncProject(This,pSuccess)	\
    (This)->lpVtbl -> SyncProject(This,pSuccess)

#define IWebProject_MoveFiles(This,FromProjectRelativeURL,ToProjectRelativeURL)	\
    (This)->lpVtbl -> MoveFiles(This,FromProjectRelativeURL,ToProjectRelativeURL)

#define IWebProject_RenameFiles(This,FromProjectRelativeURL,ToProjectRelativeURL)	\
    (This)->lpVtbl -> RenameFiles(This,FromProjectRelativeURL,ToProjectRelativeURL)

#define IWebProject_DeleteFiles(This,ProjectRelativeURL)	\
    (This)->lpVtbl -> DeleteFiles(This,ProjectRelativeURL)

#define IWebProject_CloseProject(This,pSuccess)	\
    (This)->lpVtbl -> CloseProject(This,pSuccess)

#define IWebProject_DeleteProject(This,pSuccess)	\
    (This)->lpVtbl -> DeleteProject(This,pSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_WorkingDirectory_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkingDirectory);


void __RPC_STUB IWebProject_get_WorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_ServerName_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pServerName);


void __RPC_STUB IWebProject_get_ServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_VirtualRoot_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVirtualRoot);


void __RPC_STUB IWebProject_get_VirtualRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_FPWebProject_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFpWebProject);


void __RPC_STUB IWebProject_get_FPWebProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_DBConnections_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDBConnections);


void __RPC_STUB IWebProject_get_DBConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_AddFolder_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR FolderURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_AddFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_AddFile_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR FileURL,
    /* [in] */ BSTR LocalFilename,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_AddFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_GetFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL,
    /* [in] */ long Flags,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_GetFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_ReleaseFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_ReleaseFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_UpdateFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_UpdateFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_GetFileStatus_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_GetFileStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_SyncProject_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_SyncProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_MoveFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR FromProjectRelativeURL,
    /* [in] */ BSTR ToProjectRelativeURL);


void __RPC_STUB IWebProject_MoveFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_RenameFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR FromProjectRelativeURL,
    /* [in] */ BSTR ToProjectRelativeURL);


void __RPC_STUB IWebProject_RenameFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_DeleteFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL);


void __RPC_STUB IWebProject_DeleteFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_CloseProject_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_CloseProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_DeleteProject_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_DeleteProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebProject_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WebProject;

class DECLSPEC_UUID("E50D4940-A9BD-11cf-97EA-00AA00C006B6")
WebProject;
#endif

#ifndef __IWebService_INTERFACE_DEFINED__
#define __IWebService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWebService
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IWebService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("50BC5FE5-AEA2-11cf-B4D3-00AA00B8DDEA")
    IWebService : public IDispatch
    {
    public:
        virtual /* [hidden][helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentSelection( 
            /* [retval][out] */ BSTR __RPC_FAR *pCurrentURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFPWebServer( 
            /* [in] */ BSTR Server,
            /* [in] */ BSTR User,
            /* [in] */ BSTR Password,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFPWebServer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWebProjectFromLocalFile( 
            /* [in] */ BSTR Filename,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWebProjectFromUrl( 
            /* [in] */ BSTR ProjectURL,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoesProjectFileExist( 
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR LocalDirectory,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateProjectFile( 
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR LocalDirectory,
            /* [in] */ BSTR ServerName,
            /* [in] */ BSTR WebName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBaseUrlFromLocalFile( 
            /* [in] */ BSTR LocalFileName,
            /* [retval][out] */ BSTR __RPC_FAR *pBaseURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenFile( 
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PreviewFile( 
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebService __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebService __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebService __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebService __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [hidden][helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IWebService __RPC_FAR * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentSelection )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pCurrentURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFPWebServer )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR Server,
            /* [in] */ BSTR User,
            /* [in] */ BSTR Password,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFPWebServer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWebProjectFromLocalFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR Filename,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWebProjectFromUrl )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR ProjectURL,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoesProjectFileExist )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR LocalDirectory,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProjectFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR LocalDirectory,
            /* [in] */ BSTR ServerName,
            /* [in] */ BSTR WebName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaseUrlFromLocalFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR LocalFileName,
            /* [retval][out] */ BSTR __RPC_FAR *pBaseURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PreviewFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);
        
        END_INTERFACE
    } IWebServiceVtbl;

    interface IWebService
    {
        CONST_VTBL struct IWebServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebService_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebService_get__NewEnum(This,_ppNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,_ppNewEnum)

#define IWebService_Item(This,index,ppDispatch)	\
    (This)->lpVtbl -> Item(This,index,ppDispatch)

#define IWebService_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define IWebService_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IWebService_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#define IWebService_get_CurrentSelection(This,pCurrentURL)	\
    (This)->lpVtbl -> get_CurrentSelection(This,pCurrentURL)

#define IWebService_GetFPWebServer(This,Server,User,Password,ppFPWebServer)	\
    (This)->lpVtbl -> GetFPWebServer(This,Server,User,Password,ppFPWebServer)

#define IWebService_GetWebProjectFromLocalFile(This,Filename,ppWebProject)	\
    (This)->lpVtbl -> GetWebProjectFromLocalFile(This,Filename,ppWebProject)

#define IWebService_GetWebProjectFromUrl(This,ProjectURL,ppWebProject)	\
    (This)->lpVtbl -> GetWebProjectFromUrl(This,ProjectURL,ppWebProject)

#define IWebService_DoesProjectFileExist(This,ProjectName,LocalDirectory,vtBoolean)	\
    (This)->lpVtbl -> DoesProjectFileExist(This,ProjectName,LocalDirectory,vtBoolean)

#define IWebService_CreateProjectFile(This,ProjectName,LocalDirectory,ServerName,WebName,vtBoolean)	\
    (This)->lpVtbl -> CreateProjectFile(This,ProjectName,LocalDirectory,ServerName,WebName,vtBoolean)

#define IWebService_GetBaseUrlFromLocalFile(This,LocalFileName,pBaseURL)	\
    (This)->lpVtbl -> GetBaseUrlFromLocalFile(This,LocalFileName,pBaseURL)

#define IWebService_GetFile(This,BaseURL,FileURL,Flags,pLocalFileName)	\
    (This)->lpVtbl -> GetFile(This,BaseURL,FileURL,Flags,pLocalFileName)

#define IWebService_OpenFile(This,BaseURL,FileURL,Flags,pLocalFileName)	\
    (This)->lpVtbl -> OpenFile(This,BaseURL,FileURL,Flags,pLocalFileName)

#define IWebService_PreviewFile(This,BaseURL,FileURL,Flags,pLocalFileName)	\
    (This)->lpVtbl -> PreviewFile(This,BaseURL,FileURL,Flags,pLocalFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get__NewEnum_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);


void __RPC_STUB IWebService_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_Item_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IWebService_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get_Count_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB IWebService_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get_Parent_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IWebService_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get_Application_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IWebService_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get_CurrentSelection_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pCurrentURL);


void __RPC_STUB IWebService_get_CurrentSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetFPWebServer_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR Server,
    /* [in] */ BSTR User,
    /* [in] */ BSTR Password,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFPWebServer);


void __RPC_STUB IWebService_GetFPWebServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetWebProjectFromLocalFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR Filename,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject);


void __RPC_STUB IWebService_GetWebProjectFromLocalFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetWebProjectFromUrl_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR ProjectURL,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject);


void __RPC_STUB IWebService_GetWebProjectFromUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_DoesProjectFileExist_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR ProjectName,
    /* [in] */ BSTR LocalDirectory,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean);


void __RPC_STUB IWebService_DoesProjectFileExist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_CreateProjectFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR ProjectName,
    /* [in] */ BSTR LocalDirectory,
    /* [in] */ BSTR ServerName,
    /* [in] */ BSTR WebName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean);


void __RPC_STUB IWebService_CreateProjectFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetBaseUrlFromLocalFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR LocalFileName,
    /* [retval][out] */ BSTR __RPC_FAR *pBaseURL);


void __RPC_STUB IWebService_GetBaseUrlFromLocalFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR BaseURL,
    /* [in] */ BSTR FileURL,
    /* [in] */ long Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);


void __RPC_STUB IWebService_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_OpenFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR BaseURL,
    /* [in] */ BSTR FileURL,
    /* [in] */ long Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);


void __RPC_STUB IWebService_OpenFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_PreviewFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR BaseURL,
    /* [in] */ BSTR FileURL,
    /* [in] */ long Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);


void __RPC_STUB IWebService_PreviewFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebService_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WebService;

class DECLSPEC_UUID("50BC5FE7-AEA2-11cf-B4D3-00AA00B8DDEA")
WebService;
#endif
#endif /* __DSWebProjects_LIBRARY_DEFINED__ */

#ifndef __IWebProjectFiles_INTERFACE_DEFINED__
#define __IWebProjectFiles_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWebProjectFiles
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_IWebProjectFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("D11F0D22-1333-11d0-8155-00A0C91E29D5")
    IWebProjectFiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumFolders( 
            /* [in] */ LPCOLESTR pszFolder,
            /* [retval][out] */ CALPOLESTR __RPC_FAR *calFolders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFiles( 
            /* [in] */ LPCOLESTR pszFolder,
            /* [retval][out] */ CALPOLESTR __RPC_FAR *calFiles) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebProjectFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebProjectFiles __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebProjectFiles __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebProjectFiles __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumFolders )( 
            IWebProjectFiles __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFolder,
            /* [retval][out] */ CALPOLESTR __RPC_FAR *calFolders);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumFiles )( 
            IWebProjectFiles __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFolder,
            /* [retval][out] */ CALPOLESTR __RPC_FAR *calFiles);
        
        END_INTERFACE
    } IWebProjectFilesVtbl;

    interface IWebProjectFiles
    {
        CONST_VTBL struct IWebProjectFilesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebProjectFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebProjectFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebProjectFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebProjectFiles_EnumFolders(This,pszFolder,calFolders)	\
    (This)->lpVtbl -> EnumFolders(This,pszFolder,calFolders)

#define IWebProjectFiles_EnumFiles(This,pszFolder,calFiles)	\
    (This)->lpVtbl -> EnumFiles(This,pszFolder,calFiles)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWebProjectFiles_EnumFolders_Proxy( 
    IWebProjectFiles __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFolder,
    /* [retval][out] */ CALPOLESTR __RPC_FAR *calFolders);


void __RPC_STUB IWebProjectFiles_EnumFolders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWebProjectFiles_EnumFiles_Proxy( 
    IWebProjectFiles __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFolder,
    /* [retval][out] */ CALPOLESTR __RPC_FAR *calFiles);


void __RPC_STUB IWebProjectFiles_EnumFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebProjectFiles_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\iswsguid.h ===
//=[f========================================================================
// 	iswsguid.h
//
//	Guids defined for IStudio. Include after <initguid.h> to define storage.
//
//	Copyright (C) 1996 Microsoft Corporation,
//	All rights reserved.
//
//=f]========================================================================

// Our doc template guid
// {6F97F641-726F-11cf-97EA-00AA00C006B6}
DEFINE_GUID(CLSID_IStudioDoc, 0x6f97f641, 0x726f, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);

// Webscope document guid (used by shell)
#ifndef GUID_CLSID_WebScope
#define GUID_CLSID_WebScope
DEFINE_GUID(CLSID_WebScopeDoc, 0x4d6ff300, 0x7cde, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);
#endif

// {1AEE2F43-A42B-11cf-97EA-00AA00C006B6}
DEFINE_GUID(IID_IWebProject, 0x1aee2f43, 0xa42b, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);
// {0C11C141-A4C0-11cf-97EA-00AA00C006B6}
DEFINE_GUID(SID_SWebProject, 0xc11c141, 0xa4c0, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);


// {50BC5FE5-AEA2-11cf-B4D3-00AA00B8DDEA}
DEFINE_GUID(IID_IWebService, 0x50bc5fe5, 0xaea2, 0x11cf, 0xb4, 0xd3, 0x0, 0xaa, 0x0, 0xb8, 0xdd, 0xea);
// {0ACD4D51-B345-11cf-B7D4-00AA00B8DDEA}
DEFINE_GUID(SID_SWebService, 0xacd4d51, 0xb345, 0x11cf, 0xb7, 0xd4, 0x0, 0xaa, 0x0, 0xb8, 0xdd, 0xea);


// {9834F751-168C-11d0-8158-00A0C91E29D5}
DEFINE_GUID(SID_SDBConnection, 0x9834f751, 0x168c, 0x11d0, 0x81, 0x58, 0x0, 0xa0, 0xc9, 0x1e, 0x29, 0xd5);


// {7FE1F3C1-076E-11d0-8BEC-00A0C90F55D6}
DEFINE_GUID(IID_IDBConnectionRuntime, 0x7fe1f3c1, 0x76e, 0x11d0, 0x8b, 0xec, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xd6);


// Guid to differinate us from other PkgProjects
// {0A535520-DF5F-11cf-B4B2-00C04FD71DE9}
DEFINE_GUID(IID_IWebPkgProject, 0xa535520, 0xdf5f, 0x11cf, 0xb4, 0xb2, 0x0, 0xc0, 0x4f, 0xd7, 0x1d, 0xe9);


// {D11F0D22-1333-11d0-8155-00A0C91E29D5}
DEFINE_GUID(IID_IWebProjectFiles, 0xd11f0d22, 0x1333, 0x11d0, 0x81, 0x55, 0x0, 0xa0, 0xc9, 0x1e, 0x29, 0xd5);

// End of iswsguid.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\iswserr.h ===
/////////////////////////////////////////////////////////////////////////////
// ISWSERR.H - ISWS Error codes
//
// 05/13/96	Billhie	Initial Creation

#ifndef __ISWSERR__
#define __ISWSERR__

#define ISP_E_FIRST					0x80040300L
#define ISP_E_NOPROJECT				ISP_E_FIRST
#define ISP_E_NOGLOBALPAGE			ISP_E_FIRST+1
#define ISP_E_ACCESSINGGLOBALPAGE	ISP_E_FIRST+2
#define ISP_E_PARSINGGLOBALPAGE		ISP_E_FIRST+3
#define ISP_E_LAST					ISP_E_FIRST+3
#define ISP_E_CANCELED				ISP_E_FIRST+4

#endif 

// End of iswserr.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\inamespc.h ===
//-----------------------------------------------------------------------------
// Microsoft DaVinci
//
// Microsoft Confidential
// Copyright 1994 - 1995 Microsoft Corporation. All Rights Reserved.
//
// File: inamespc.h
// Area: TNamespace (Database)
// Contents:
// INamespace and related COM interface definitions
//
// Owner: zacha		(3/17/95)	-	Created 
//-----------------------------------------------------------------------------

#ifndef _INAMESPC_H_
#define _INAMESPC_H_

#include "idsref.h"

//-----------------------------------------------------------------------------
// Name: NSItemID
//
// Description:
// INamespace ItemID uniquely identifying an item within its container
//
// Hungarian:  nsiid
//-----------------------------------------------------------------------------
typedef struct tagNSItemID
{
	USHORT	cb;			// ItemID byte data byte count
	BYTE	rgbID[1];	// ItemID byte data
} NSItemID,	*PNSItemID;




//-----------------------------------------------------------------------------
// Name: NSIDPath
//
// Description:
// INamespace ItemID path uniquely identifying an item within its containers
//
// Hungarian:  nsidp
//-----------------------------------------------------------------------------
typedef struct tagNSIDPath
{
	NSItemID	nsiid;	// First NSItemID in contiguous list
} NSIDPath,	*PNSIDPath;




//-----------------------------------------------------------------------------
// Name: IEnumNSItemChild
//
// Description:
// IEnumNSItemChild COM interface definition
//-----------------------------------------------------------------------------
DECLARE_INTERFACE_(IEnumNSItemChild, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (VOID) PURE;
	STDMETHOD_(ULONG, Release) (VOID) PURE;

	// IEnumNSItemChild methods
	STDMETHOD(Next) (
		ULONG cChild,
		PNSIDPath *rgpnsidpItemChild,
		ULONG *pcChild) PURE;
	STDMETHOD(Skip) (ULONG cChild) PURE;
	STDMETHOD(Reset) (VOID) PURE;
	STDMETHOD(Clone) (IEnumNSItemChild **ppIEnumNSItemChild) PURE;
};
typedef IEnumNSItemChild *PENUMNSITEMCHILD;




//-----------------------------------------------------------------------------
// Name: INSEventSink
//
// Description:
// INSEventSink COM interface definition
//-----------------------------------------------------------------------------
DECLARE_INTERFACE_(INSEventSink, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (VOID) PURE;
	STDMETHOD_(ULONG, Release) (VOID) PURE;

	// INSEventSink methods
	STDMETHOD_(VOID, OnItemAdded) (const PNSIDPath pnsidpItemAdded) PURE;
	STDMETHOD_(VOID, OnItemDeleted) (const PNSIDPath pnsidpItemDeleted) PURE;
	STDMETHOD_(VOID, OnItemRenamed) (const PNSIDPath pnsidpItemRenamed) PURE;
	STDMETHOD_(VOID, OnPropertyChanged) (const PNSIDPath pnsidpPropertyChanged) PURE;
};
typedef INSEventSink *PNSEVENTSINK;




//-----------------------------------------------------------------------------
// Name: INamespace
//
// Description:
// INamespace COM interface definition
//-----------------------------------------------------------------------------
DECLARE_INTERFACE_(INamespace, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (void) PURE;
	STDMETHOD_(ULONG, Release) (void) PURE;

	// INamespace methods
	STDMETHOD(GetItemChildEnum) (
		const PNSIDPath pnsidpItemCurr,
		PENUMNSITEMCHILD *ppIEnumNSItemChild) PURE;
	STDMETHOD(GetItemName) (
		const PNSIDPath pnsidpItemCurr,
		BSTR *pbstrName) PURE;
	STDMETHOD(GetItemProperties) (
		const PNSIDPath pnsidpItemCurr,
		LPPROPERTYSETSTORAGE *ppIPropertySetStorage) PURE;
	STDMETHOD(AppendDSRef) (
		const PNSIDPath pnsidpItemCurr,
		PDSREFPROVIDER pIDSRefProvider) PURE;
	STDMETHOD(Reduce) (
		const PNSIDPath pnsidpItemCurr,
		INamespace **ppINamespace,
		PNSIDPath *ppnsidpItemReduced) PURE;
	STDMETHOD(GetImageList) (HIMAGELIST *phil) PURE;
	STDMETHOD(GetItemImageListIndex) (
		const PNSIDPath pnsidpItemCurr,
		INT *piImageListIndex) PURE;
	STDMETHOD(GetItemTypeGUID) (
		const PNSIDPath pnsidpItemCurr,
		GUID * pGuid) PURE;
	STDMETHOD(GetItemChildEnumEx) (
		const PNSIDPath pnsidpItemCurr,
		REFGUID guidType,
		PENUMNSITEMCHILD *ppIEnumNSItemChild) PURE;
	STDMETHOD(AddChild) (
		REFGUID guidType,
		LPCOLESTR pszItemName,
		LPCOLESTR pszItemOwner) PURE;
	STDMETHOD(RemoveChild) (
		const PNSIDPath pnsidpItemCurr) PURE;
	STDMETHOD(AddChildEx) (
		REFGUID guidType,
		const PNSIDPath pnsidpParent,
		LPCOLESTR pszItemName,
		LPCOLESTR pszItemOwner) PURE;
	STDMETHOD(RenameItem) (
		const PNSIDPath pnsidpItem,
		LPCOLESTR pszNewName,
		LPCOLESTR pszNewOwner) PURE;
	STDMETHOD(UpdateItemProperties) (
		const PNSIDPath pnsidpItem) PURE;

};
typedef INamespace *PNAMESPACE;

#endif	// _INAMESPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\indent.h ===
//--------------------------------------------------------------
//
//  File:       indent.h
//
//  Contents:   Indentation code called by language manager
//
//  History:    
//---------------------------------------------------------------
#pragma once

#include "lexcpp.h"
#include <tokcpp.h>

HRESULT InitSmartIndent(long initialBufferSize);
void UninitSmartIndent(void);

HRESULT DoSmartIndent(long lLine, long lCol, IVsTextLines *pVsTextLines, IVsTextView *pVsTextView,
    LANGPREFERENCES *plangPref, VCPREFERENCES * pVCPrefs, long *pDifflLine=NULL, long *pDifflEndLine=NULL);
BOOL DoMatchBraces(long *lLine, long *lColumn, IVsTextLines *pVsTextLines);
BOOL FFindTokenMatchWithinStatement(TOKCPP tok, long *plLine, long *plCol, IVsTextLines *pVsTextLines);

//////////////////////////////////////////////////
// CLineStatus
//  used to hold the tokenized line information
//  it knows its line number and can reposition itself if IsFixed()==FALSE
//  if IsFixed()==TRUE, it does not know its line number, ex. when holding a buffer
/////////////////////////////////////////////////
class CLineStatus
{
public:
    enum eSLineKind
    {
        eMovable,
        eFixed
    };
protected:
    //when IsFixed(), it's -1, which means this does not know its line number
    long    m_currentLine; //if it knows the line, then it can relex/move to a different line
public:
    RGTXTB  m_TokenInfo;
    LINEDATA m_LineData;
public:
    CLineStatus ();
    CLineStatus (IVsTextLines *pVsTextLines, UINT phyLine, eSLineKind bFixed = eMovable, BOOL bIsODL = FALSE);
    ~CLineStatus();
    inline BOOL IsFixed() {return m_currentLine==-1;}
    inline void SetFixed(){m_currentLine=-1;}
    BOOL    InitTokens(UINT phyLine, eSLineKind bFixed = eMovable, BOOL bIsODL = FALSE);
    void    ReleaseTokens();
    BOOL    InitTokensAtPosition(long iPosition, long *piLine, CharIndex *piColumn, eSLineKind bFixed);
    _TS     GetTabSpace(int ctchTab);
    BOOL    GetFirstToken(TOKCPP * pToken, BOOL bSkipComment, UINT * piPos = NULL);
    BOOL    GetLastToken (TOKCPP * pToken, BOOL bSkipComment, UINT * piPos = NULL);
    BOOL    CompareTokenStream(CLineStatus &lsCompare, BOOL bSkipComment = TRUE);
//when IsFixed()==FALSE, those function can move it to previous/next line
//when IsFixed()==TURE, those functions return FALSE on its First/Last token
    INT     GetNextToken(TOKCPP * pToken, BOOL bSkipComment, /*in,out*/UINT * piPos);
    INT     GetPrevToken (TOKCPP * pToken, BOOL bSkipComment,/*in,out*/UINT * piPos);
    inline UINT GetNumToken(){ return m_TokenInfo.size();}
protected:
    IVsTextLines *m_spVsTextLines;
    //functions that must access m_spVsTextLines
    friend class CSmartIndentCPP;
    friend class CVsCppLangInfo;
public:
//getter functions
    inline long     GetCurrentLine()     {return m_currentLine;}
};


//limit of BraceMatcher.DoMatchBraces() in some editor situations
//like brace highlighting & current block searching for Find Scope
const ULONG g_cLineLimit = 1000;
//HRESULTs that can be returned by CBraceMatcher::GetBlockName() and included in dwClient field of new region
//S_OK is returned for function block
#define S_BM_NAMESPACE 8 //namespace block
#define S_BM_CLASS 4 //class/struct/interface/union/enum block
#define S_BM_STMNT 2 //statement block (other than function or type declaration)
#define S_BM_FUNCT 1 //function definition

#define S_BM_COMMENT 16//comment block
#define S_BM_EXTERN  32//extern "C" {} block
#define S_BM_NONAME  64//unnamed block (syntax error before opening "{" or simply grouping instruction)
#define S_BM_JUNK   128//the block of globals in between codeelements' definitions
//flags for CBraceMatcher::GetOutlinesInBlock()
#define dwBlockCollapsed       0 //it's an opposite to dwBlockExpanded
#define dwBlockExpanded        1
#define dwBlockOneOnly         2 //only the current block, ends at the closing brace


// CBraceMatcher - class to help finding a match for [ and { braces, < and ( parens, the ends of strings
//   comments, and conditional compile directives (#if/#ifdef/#ifndef/#elif/#else/#endif)
// Can either find a match for the token at current position (initialized in the constructor)
//   or the caller can supply a token (DoMatchBracesForThisToken).
class CBraceMatcher : public CLineStatus
{
public:
    enum eBMatchDirection
    {
        eBackward = -1,
        eForward = 1
    };
    CBraceMatcher   ();
    HRESULT         Init(LPCWSTR szStream, ULONG lPosCur = 0, LXS lxs = 0);
    HRESULT         Init(long lLineCur, long lColCur, IVsTextLines *pVsTextLines, eSLineKind bFixed = eMovable);
    
    //when tok = tokUNKNOWN : use token at position given by *plLine, *plCol
    BOOL            DoMatchBraces(TOKCPP tok = tokUNKNOWN, INT nIgnoreTokens = 0, ULONG lineLimit = 0xFFFFFFFF);

    BOOL            FFindMatchingForStringOrComment(long *plLine, long *plCol, ULONG lineLimit = 0xFFFFFFFF);
    BOOL            FFindEndOfMacro(long *plLine, long *plCol);

    BOOL            FSkip_ToPPBoundary(eBMatchDirection direction, ULONG *plineLimit=NULL);
    BOOL            FFindMatching_PPKeyw(eBMatchDirection direction, ULONG lineLimit=0xFFFFFFFF);
public:
    //direction<0 - backwards; direction>0 - forwards; direction==0 - does not move
    //returns the TOKCPP at the new location or -1 if error
    TOKCPP          MoveToNextToken(int direction = eForward, BOOL bSkipComment = TRUE, ULONG *plineLimit = NULL);
    BOOL            FindToken(TOKCPP tok, int direction = eForward, BOOL bSkipComment = TRUE, ULONG *plineLimit = NULL);
    BOOL            FindToken(TOKCPP * rgtok, int direction = eForward, BOOL bSkipComment = TRUE, ULONG *plineLimit = NULL);
    BOOL            FindIdentifier(LPCWSTR bstrText, int direction = eForward, BOOL bSkipComment = TRUE, ULONG *plineLimit = NULL);
    //block parsing operations
    HRESULT         GetBlockName(BSTR *pbstrFunName = NULL, bool bRestoreState = true);
    void            GetOutlinesInBlock(DWORD dwFlags, CSimpleArray<NewHiddenRegion> &OpenRegions, CSimpleArray<NewHiddenRegion> &MatchedRegions,
                    ULONG *nLineLimit = NULL);
    void            OpenJunkOutline(HIDDEN_REGION_STATE dwState, CSimpleArray<NewHiddenRegion> &OpenRegions);
private:
    void            OpenOutline(DWORD dwFlags, HRESULT hrType, long firstLine, CharIndex firstCol,
                    CSimpleArray<NewHiddenRegion> &OpenRegions);
    HRESULT         GetJunkToFirstDefinition(CSimpleArray<NewHiddenRegion> &OpenRegions, CSimpleArray<NewHiddenRegion> &Regions,
                    DWORD flags, ULONG *nLineLimit = NULL);
    TOKCPP          AddCommentOutline(HIDDEN_REGION_STATE dwState, CSimpleArray<NewHiddenRegion> &OpenRegions, CSimpleArray<NewHiddenRegion> &MatchedRegions,
                    ULONG *pnLineLimit = NULL);
//state of this object
protected:
    INT                         m_iPos;
//  CLexCPP                     m_lex; //could be hidden inside CLineStatus, but it's a stack object there
public:
    inline UINT     GetCurrentPos()      
    {
        VSASSERT(m_TokenInfo.size()>(UINT)m_iPos, "BraceMatcher in unknown state. Assign bug to ChrisKoz");
        return m_iPos;
    }
    inline TOKCPP   GetCurrentToken()    {return static_cast<TOKCPP>(m_TokenInfo[GetCurrentPos()].tok);}
    INT             CompareCurrentTokenText(LPCWSTR bstrCompare);
    HRESULT         GetCurrentToken(BSTR *pbstrToken);
    INT             CompareCurrentTokenTextFirstNChars(BSTR bstrCompare, int nChar);
    inline UINT     GetCurrentBeginCol() {return m_TokenInfo[GetCurrentPos()].ibTokMin;}
    inline UINT     GetCurrentEndCol()   {return m_TokenInfo[GetCurrentPos()].ibTokMac;}

    inline void     SetCurrentPos(int iPos)
    {
        VSASSERT(m_TokenInfo.size()>(UINT)iPos, "Attempt to set BraceMatcher to wrong state");
        m_iPos=iPos; //how useful is it?
    }
    inline void     ResetPos(INT iLine, INT iPos)
    {
        if(iLine!=GetCurrentLine())
        {
            ReleaseTokens();
            InitTokens(iLine);
        }
        SetCurrentPos(iPos);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\langapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	LANGAPI.H
//		Language package interface declarations.

#ifndef __LANGAPI_H__
#define __LANGAPI_H__

class CLex; 	// Non-standard COM.
class CParser; 	// Non-standard COM.

typedef CLex* PLEXER;
typedef CParser* PPARSER;

interface ILangPackage;

typedef ILangPackage* LPLANGPACKAGE;

/////////////////////////////////////////////////////////////////////////////
// ILangPackage

#undef  INTERFACE
#define INTERFACE ILangPackage
DECLARE_INTERFACE_(ILangPackage, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ILangPackage methods
	STDMETHOD(RegisterLexers)(PLEXER **pppLexers) PURE;
	STDMETHOD(RegisterParsers)(PPARSER **pppParsers) PURE;
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __LANGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\lexcpp.h ===
//-----------------------------------------------------------------------
//
// File:	 lexcpp.h
//
// Contains: Smart indenting code for C / C++ files.  A number of defines
//			 and structures from various places in the old shell tree have
//			 been added to this file in order to get things to work.
//
// REVIEW:   This code is just a port of the old lexer code and is a 
//			 candidate for a rewrite since it has to be hacked in order
//			 to work with the new shell editor.  I've tried to isolate
//			 this code as much as possible so that a rewrite would be 
//			 easier in the event that we decide to do one.		
//
//-----------------------------------------------------------------------

#pragma once

#include "lex.h"
	
class CLexCPP: public CLex
{
public :

	static CVCStringList m_listLexExtensions;
	static CVCStringList m_listNCBExtensions;
    //default NCBExtentions if not present in registry
    static LPCTSTR m_rgszNCBExtensions[];

	CLexCPP(ReservedWord *pUserDefKW = NULL);
	virtual ~CLexCPP(void);

	// see if this lexer will by default handle this type of file
//	static BOOL FCanLexFile(LPCTSTR szFilename);
	static BOOL FIsNCBFile(LPCTSTR szFilename);

	// lex the line, giving us back ton'o'info,
	// returns count of bytes that were tokenized in
	// ptchLine.
	virtual UINT CbLexLine (
					LPCWSTR		ptchLine,
					UINT		cbLine,
					PLXS		plxs,	  // in: BOL state, out: eol state
					P_OUT (RGTXTB) rgtxtb,
					P_IO(DWORD)	dwUserKwArraySize
					);

	// slim version of lex line, i.e.: without
	// rgtxtb since only interested in plxs
	virtual UINT CbLexLine (
					LPCWSTR		ptchLine,
					UINT		cbLine,
					PLXS		plxs,	  // in: BOL state, out: eol state
					P_IO(DWORD)	dwUserKwArraySize
					);
	//		lex a line & fill the color table
	//		it returns the lex state at the end of the line (plxs)
	virtual UINT CbLexLine (LPCWSTR		ptchLine,
						 UINT		cbLine,
						 PLXS		plxs,
						 ULONG		pAttributes[],
						 P_IO(DWORD)	dwUserKwArraySize
						 );

private:
	UINT GetToken (LPCWSTR ptchLine, 
					UINT  cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo);

	UINT FindEndComment (LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo);

	BOOL IsContinuationLine(LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent);

	UINT FindEndString (LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo);

	UINT FindNextToken (LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo);

	BOOL IsCharacter (LPCWSTR ptchLine,
						UINT cbLength,
						UINT cbCurrent,
						TXTB & tokenInfo); 
	HINT GetHint (LPCWSTR ptchLine,
				  UINT cbLength,
				  UINT cbCurrent,
				  DWORD * plxs,
				  TXTB & tokenInfo);
	__inline BOOL IsSingleOp (HINT hint);
	__inline BOOL IsMulOp (HINT hint);
	void FindMulOp (LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo,
					HINT hint);
	UINT SkipWhiteSpace (LPCWSTR ptchLine, 
						 UINT cbLength,
						 UINT cbCurrent);
	BOOL IsWhiteSpace (WCHAR wch)
	{
		return iswspace(wch);
	};
	BOOL IsValidHintKey(WCHAR wchKey)
	{
		return wchKey < 128u;
	};
	int GetTokenLength (LPCWSTR ptchLine,
						UINT cbLength,
						UINT cbCurrent);
	BOOL IsKeyword (LPCWSTR ptchLine,
					UINT cbCurrent,
					int iTokenLength,
					DWORD * plxs,
					TXTB & tokenInfo,
					HINT hint);
	BOOL IsUserDefinedKW (LPCWSTR ptchLine,
	                      UINT cbCurrent,
	                      int iTokenLength,
	                      TXTB & tokenInfo);		
	BOOL LookupIndexedKeyWord (ReservedWord rwTable[],
						BYTE *indexTable,
						int iTableSize,
						LPCWSTR ptchLine, 
						int iTokenLength, 
						TXTB & tokenInfo);
	BOOL IsIdentifier (int iTokenLength,
					   TXTB & tokenInfo);
	BOOL IsPPKeyWord (LPCWSTR ptchLine,
					  UINT cbLength,
					  UINT cbCurrent,
						DWORD * plxs,
					  TXTB & tokenInfo);
	BOOL LookupLinearKeyWord (ReservedWord rwTable[],
						int iTableSize,
						LPCWSTR ptchLine,
						int length, 
						TXTB & tokenInfo);
	BOOL IsUnknownID (LPCWSTR ptchLine,
					  UINT cbLength,
					  UINT cbCurrent,
					  TXTB & tokenInfo);
	BOOL IsNumber (LPCWSTR ptchLine,
				   UINT cbLength,
				   UINT cbCurrent,
				   TXTB & tokenInfo);
	void FindRightTBracket (LPCWSTR ptchLine,
							UINT cbLength,
							UINT cbCurrent,
							TXTB & tokenInfo);
} ;

bool FIsLocationInsideAttribBlock(long ich, long iline, long *pichBeginBlock, long *pilineBeginBlock, IVsTextLines *pTextLines);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\lex.h ===
//-----------------------------------------------------------------------
//
// File:	 lex.h
//
// Contains: Smart indenting code for C / C++ files.  A number of defines
//			 and structures from various places in the old shell tree have
//			 been added to this file in order to get things to work.
//
// REVIEW:   This code is just a port of the old lexer code and is a 
//			 candidate for a rewrite since it has to be hacked in order
//			 to work with the new shell editor.  I've tried to isolate
//			 this code as much as possible so that a rewrite would be 
//			 easier in the event that we decide to do one.		
//
//-----------------------------------------------------------------------

#pragma once

#include "memref.h"
#include <cppsvc.h>
#include "cvr.h"
#include "assert_.h"
#include "helper.h"
#include "array_t.h"

#define P_IN(x)     const x &
#define P_OUT(x)    x &
#define P_IO(x)     x &
#define PURE        = 0

class CLex;
// Lex state, kept at the beginning of every line (lxsBOL) from
// previous line's state at its end (lxsEOL). Must fit all bits
// necessary to restart lexing on a line by line basis.

const int       cbLexState = sizeof (DWORD);
typedef DWORD   LXS;
typedef LXS *   PLXS;
const LXS       lxsMaskFortranFixed =   0x80000000;
const LXS       lxsMaskFortranTab6 =    0x40000000;
const LXS       lxsMaskFortran =        lxsMaskFortranFixed | lxsMaskFortranTab6;
const LXS       lxsMaskValid =          0x20000000; // Set internally, lexers should not use

inline LXS  LxsFortranBits ( LXS lxs ) { return lxs & lxsMaskFortran; }
inline BOOL FFortranFixed ( LXS lxs ) { return !!(lxs & lxsMaskFortranFixed); }
inline BOOL FFortranTab6 ( LXS lxs ) { return (lxs & lxsMaskFortran) == lxsMaskFortran; }

//
// smart indent support
//
enum INDENT_TYPE {	// Indent Type
	itNone,		// always move caret to home
	itStd,		// move caret to previous lines indent
	itSmart		// smart, context based indenting
	};

// CMemoryBlock TBD, but supports 2 sizes (allocated/used)
// as well as pointer casting operators.
typedef CRefMem * PMEMBL;

typedef DWORD _TS;  // Tabs and Spaces

struct TAB_METRIC;  // forward declaration
typedef TAB_METRIC *PTABMETRIC;
typedef const TAB_METRIC *PCTABMETRIC;

struct GET_LINE_STATE
{
	UINT        lineCur;
	LXS         lxsBolCur;  // necessary for some impls.
	PCTABMETRIC pTabMetric;
	VOID *      pvReserved; // for holding a CTextDoc*
};
typedef GET_LINE_STATE *PGLST;

// A tab expansion block is used to determine how to expand tabs
// in the cases where the lexer does special tab expansion as
// well as for variable indent levels.  Given both the tab
// expansion and an array of TABEXBs describing indents,
// the lexer (or anyone) can handle all tabbing/indent behaviors.
typedef INT CTAB;
const CTAB  ctabEnd = 0;
const CTAB  ctabInfinite = -1;  // also implies end of list

struct TABEXB // Tab Expansion Block
{
	CTAB ctabRun;  // run of tabs this width expand to
	union
	{
		UINT ctchIndent; // count of spaces to expand indent
		UINT ctchTab;    // count of spaces to expand tab
	};
};
typedef TABEXB * PTABEXB;
typedef const TABEXB * PCTABEXB;

typedef Array <TXTB> RGTXTB;

typedef UINT	TOKENTYPE;

typedef unsigned short HINT;

typedef struct ReservedWord
{
	WCHAR *		psz;		// pointer to reserved word string 
	int			ich;		// length of reserved word
	TOKENTYPE	tTokenType;	// token type
} ReservedWord;


class CVCStringList;

///////////////////////////////////////////////////////
// Class CLex
// 	specific lexer should derive from this class
///////////////////////////////////////////////////////
class CLex
{
protected :

	ReservedWord *		m_pUserDefKW;
    int					m_iSizeUserDef;

	CLex(ReservedWord * pUserDefKW = NULL) : m_pUserDefKW(pUserDefKW), m_iSizeUserDef(0) { }
	virtual ~CLex(void) {};

	static void LoadNCBExtensionsFromRegistry(LPCTSTR szRegistryValueName, LPCTSTR * rgszDefaultExtensions,
		CVCStringList & listExtensions);

	static BOOL FIsValidFile(LPCTSTR szFileName, const CVCStringList & listExtensions);

public:
    static void LoadCPPODLExtensionsFromRegistry();

public :

	// lex the line, giving us back ton'o'info,
	// returns count of TCHAR that were tokenized in ptchLine.
	//
	
	virtual UINT CbLexLine (
					LPCWSTR			ptchLine,
					UINT			cbLine,
					PLXS			plxs,	  // in: BOL state, out: eol state
					P_OUT (RGTXTB)	rgtxtb,
					P_IO(DWORD)		dwReserved
					) PURE;

	// slim version of lex line since only interested in the plxs.
	//

	virtual UINT CbLexLine (
					LPCWSTR			ptchLine,
					UINT			cbLine,
					PLXS			plxs,	  // in: BOL state, out: eol state
					P_IO(DWORD)		dwReserved
					) PURE;
};

typedef CLex *	PLEX;

// Maximum length (not including \0 at end) of name returned by CLex::SzLanguage()
#define MAX_LANGNAMELEN (50)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\lcppguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	lcppguid.h
//		LangCPP interface ids.


// {4AA0AD46-61B7-11CF-B120-00AA006C28B3}
DEFINE_GUID(IID_ILangCPP, 
	0x4aa0ad46, 0x61b7, 0x11cf, 0xb1, 0x20, 0x0, 0xaa, 0x0, 0x6c, 0x28, 0xb3);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\langdsgn.h ===
#ifndef __DESIGNER_H__
#define __DESIGNER_H__

// designer.h : header file
//

#define PROJ_APPLICATION	0x0001
#define PROJ_DLL			0x0002
#define PROJ_UNICODE		0x0004
#define PROJ_CONSOLE_APP	0x0008
#define PROJ_STATIC_LIB		0x0010
#define PROJ_GEN_PROJ		0x0020
#define PROJ_NEW_WORKSPACE	0x1000

#define ITEM_INTERFACE		0x0001
#define ITEM_DISPINTERFACE	0x0002
#define ITEM_CLASS			0x0004
#define ITEM_FUNCTION		0x0008
#define ITEM_VARIABLE		0x0010
#define ITEM_METHOD			0x0020
#define ITEM_PROPERTY		0x0040
#define ITEM_MAP			0x0080
#define ITEM_FILES			0x0100

/////////////////////////////////////////////////////////////////////////////
// ILangDesigner
//   This is an interface to get to language specific stuff.  Current focus: C++

#undef  INTERFACE
#define INTERFACE ILangDesigner
DECLARE_INTERFACE_(ILangDesigner, IDispatch)
{
#ifndef NO_BASEINTERFACE_FUNCS

	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)() PURE;
	STDMETHOD_(ULONG,Release)() PURE;
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

#endif

	// ILangDesigner methods
	STDMETHOD(CreateProject)(LPCOLESTR pwstrProjName, long flags, BSTR *pbstrBuilder) PURE;
	STDMETHOD(GetActiveBuilderName)(BSTR *pbstrBuilder) PURE;
	STDMETHOD(AddFile)(LPCOLESTR pwstrBuilder, LPCOLESTR pwstrFileName, long flags) PURE;

	// Project Query methods
	STDMETHOD(GetAllMembers)(LPCOLESTR pwstrBuilder, 
		LPCOLESTR pwstrName, long flags, VARIANT *pvarNames, VARIANT *pvarAttribs) PURE;

	STDMETHOD (GetSourceInformation)
		(LPCOLESTR pwstrBuilder,
		LPCOLESTR pwstrName, 
		long flags, 
		BSTR *pbstrDefn,  
		long *plDefnStart, 
		long *plDefnEnd,
		BSTR *pbstrDecl, 
		long *plDeclStart,
		long *plDeclEnd) PURE;

	STDMETHOD(GetActiveXAssociation)(LPCOLESTR pwstrBuilder, 
		LPCOLESTR pwstrInterfaceName, VARIANT *pvtClassNames) PURE;
	STDMETHOD(GetFileInfo)(LPCOLESTR pwstrBuilder,
		LPCOLESTR pwstrFileName, long flags, long *lastIncludeLine, VARIANT *pvtIncludes) PURE;
	STDMETHOD(GetSourceInformationEx) (
				LPCOLESTR pwstrBuilder, 
				LPCOLESTR pwstrName, 
				long flags, 
				VARIANT *pvarDeclaration, // This gives the complete declaration
				VARIANT *pvarDefnFile,  
				VARIANT *pvarDefnStart, 
				VARIANT *pvarDefnEnd,
				VARIANT *pvarDeclFile, 
				VARIANT *pvarDeclStart,
				VARIANT *pvarDeclEnd) PURE;
};

/////////////////////////////////////////////////////////////////////////////

#endif //__DESIGNER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\msodcid.h ===
/*-----------------------------------------------------------------------------
Microsoft Sterling

Microsoft Confidential
Copyright 1994-1996 Microsoft Corporation.  All Rights Reserved.

File:		msodcid.h
Contents:	This file describes the data context interfaces
-----------------------------------------------------------------------------*/

// {A43D9461-EA36-11ce-AE99-00AA00A28331}
DEFINE_GUID(SID_NAMESPACE,
0xa43d9461, 0xea36, 0x11ce, 0xae, 0x99, 0x0, 0xaa, 0x0, 0xa2, 0x83, 0x31);

// {A43D9462-EA36-11ce-AE99-00AA00A28331}
DEFINE_GUID(IID_INamespaceSource,
0xa43d9462, 0xea36, 0x11ce, 0xae, 0x99, 0x0, 0xaa, 0x0, 0xa2, 0x83, 0x31);

// {A43D9463-EA36-11ce-AE99-00AA00A28331}
DEFINE_GUID(IID_IPersistDataStore,
0xa43d9463, 0xea36, 0x11ce, 0xae, 0x99, 0x0, 0xaa, 0x0, 0xa2, 0x83, 0x31);




// **** IID_IDBConnectObject ****
//
// {B7A1D4A0-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IDBConnectObject, 
0xb7a1d4a0, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

// **** IID_IODBCConnectObject ****
//
// {B7A1D4A1-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IODBCConnectObject, 
0xb7a1d4a1, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

// **** IID_IJetConnectObject ****
//
// {B7A1D4A2-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IJetConnectObject, 
0xb7a1d4a2, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);



// **** IID_IDBConnectionManager ****
//
// {B7A1D4A3-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IDBConnectionManager, 
0xb7a1d4a3, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#define SID_IDBConnectionManager  IID_IDBConnectionManager

// **** IID_IAsyncQueryBuilder ****
//
// {B7A1D4A4-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IAsyncQueryBuilder, 
0xb7a1d4a4, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);


// **** IID_IDBDisp ****
// {B7A1D4A5-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IDBTextDisp, 
0xb7a1d4a5, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#define SID_IDBTextDisp IID_IDBTextDisp

// **** IID_IDataSrcClient ****
//
// {B7A1D4A6-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IDataSrcClient, 
0xb7a1d4a6, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#define SID_SDataSrcClient IID_IDataSrcClient

// {BE377880-0B1D-11d0-8923-00AA00BF0506}
DEFINE_GUID(IID_IDataSrcDebug, 
0xbe377880, 0xb1d, 0x11d0, 0x89, 0x23, 0x0, 0xaa, 0x0, 0xbf, 0x5, 0x6);

#define SID_SDataSrcDebug IID_IDataSrcDebug

// **** IID_IDataSrcDebugConsumer ****
//
// {b0c47fd0-1220-11d0-9d16-00c04fd9dfd9}

DEFINE_GUID(IID_IDataSrcDebugConsumer,
    0xb0c47fd0, 0x1220, 0x11d0, 0x9d, 0x16, 0x00, 0xc0, 0x4f, 0xd9, 0xdf, 0xd9) ;

#define SID_SDataSrcDebugConsumer IID_IDataSrcDebugConsumer

// {8B072243-8C1A-11cf-BE23-00AA0062C2EF}
DEFINE_GUID(IID_DataPkgProject, 0x8b072243, 0x8c1a, 0x11cf, 0xbe, 0x23, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\lexodl.h ===
#ifndef __LEXODL__
#define __LEXODL__

#include <cstringt.h>
#include "lex.h"
#include "vccolls.h"

#if 0 //obsolete, should be removed, IMO
//////////////////////////////////////////////////////needed by m_usertokenArray
const unsigned ctchUserTokenPhrase = 100;
struct USERTOKENS
{
	INT			token;		// preassigned in the user range
	TCHAR		szToken[ctchUserTokenPhrase+1];	// token class name exposed to user
	COLORREF	RGBText;
	COLORREF	RGBBackground;
	//AUTO_COLOR	autocolorFore;
	//AUTO_COLOR	autocolorBack;
};

typedef USERTOKENS *		PUSERTOKENS;
typedef const USERTOKENS *	PCUSERTOKENS;
/////////////////////////////////////////////////////end of m_usertokenArray
#endif

class CLexODL: public CLex
{
public :

	static CVCStringList m_listLexExtensions;
	static CVCStringList m_listNCBExtensions;
    //default NCBExtentions if not present in registry
    static LPCTSTR m_rgszNCBExtensions[];

	CLexODL(ReservedWord *pUserDefKW = NULL);
	virtual ~CLexODL(void) { }

//	static SMART_STYLES	m_smartStyles;
//	static USERTOKENS   m_usertokenArray[]; //replaced by m_pUserDefKW

	// give a pointer to the language specific metrics.
	// Lexer can expect it to be used at any time, so leave
	// it allocated and unchanged. It can ( and probably
	// should) be in r/o memory.
//	virtual void QueryLangMetrics (P_IO(LANGMETRICS));
	
//	virtual UINT GetDefaultFileExtension(LPCTSTR szSubLanguage);

	// see if this lexer will by default handle this type of file
	static BOOL FCanLexFile(LPCTSTR szFilename);
	static BOOL FIsNCBFile(LPCTSTR szFilename);

	// lex the line, giving us back ton'o'info,
	// returns count of bytes that were tokenized in
	// ptchLine.
	virtual UINT CbLexLine (
					LPCWSTR		ptchLine,
					UINT		cbLine,
					PLXS		plxs,	  // in: BOL state, out: eol state
					P_OUT (RGTXTB) rgtxtb,
					P_IO(DWORD)	dwUserKwArraySize
					);

	// slim version of lex line, i.e.: without
	// rgtxtb since only interested in plxs
	virtual UINT CbLexLine (
					LPCWSTR		ptchLine,
					UINT		cbLine,
					PLXS		plxs,	  // in: BOL state, out: eol state
					P_IO(DWORD)	dwUserKwArraySize
					);
	//		lex a line & fill the color table
	//		it returns the lex state at the end of the line (plxs)
	virtual UINT CbLexLine (LPCWSTR		ptchLine,
						 UINT		cbLine,
						 PLXS		plxs,
						 ULONG		pAttributes[],
						 P_IO(DWORD)	dwUserKwArraySize
						 );

	// give out the smart indent info
//	virtual void QuerySmartStyles ( P_IO(SMART_STYLES) );

	// get the initial LXS for this file, so one lexer can handle multiple
	//	languages or variations of the same language.
	virtual LXS LxsInitial ( LPCTSTR szFilename );
	
	// returns TRUE if LXS is in the special state (in C++, in AFX_WIZARD state for instance)
//	virtual BOOL IsInSpecialState (LXS lxs) { return (lxs & inWizard)? TRUE : FALSE; };

	// reset the state if it is in the special state
//	virtual void UnsetSpecialState (P_IO(LXS) lxs) { lxs &= ~inWizard; };

private:
	UINT GetToken (LPCWSTR ptchLine, 
					UINT  cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo);

	UINT FindEndComment (LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo);

	BOOL IsContinuationLine(LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent);

	UINT FindEndString (LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo);

	UINT FindNextToken (LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo);

	BOOL IsCharacter (LPCWSTR ptchLine,
						UINT cbLength,
						UINT cbCurrent,
						TXTB & tokenInfo); 
	HINT GetHint (LPCWSTR ptchLine,
				  UINT cbLength,
				  UINT cbCurrent,
				  DWORD * plxs,
				  TXTB & tokenInfo);
	__inline BOOL IsSingleOp (HINT hint);
	__inline BOOL IsMulOp (HINT hint);
	void FindMulOp (LPCWSTR ptchLine,
					UINT cbLength,
					UINT cbCurrent,
					DWORD * plxs,
					TXTB & tokenInfo,
					HINT hint);
	UINT SkipWhiteSpace (LPCWSTR ptchLine, 
						 UINT cbLength,
						 UINT cbCurrent);
	BOOL IsWhiteSpace (WCHAR wch)
	{
		return iswspace(wch);
	};
	BOOL IsValidHintKey(WCHAR wchKey)
	{
		return wchKey < 128u;
	};
	int GetTokenLength (LPCWSTR ptchLine,
						UINT cbLength,
						UINT cbCurrent);
	BOOL IsKeyword (LPCWSTR ptchLine,
					UINT cbCurrent,
					int iTokenLength,
					DWORD * plxs,
					TXTB & tokenInfo,
					HINT hint);
	BOOL IsUserDefinedKW (LPCWSTR ptchLine,
	                      UINT cbCurrent,
	                      int iTokenLength,
	                      TXTB & tokenInfo);		
	BOOL LookupIndexedKeyWord (ReservedWord rwTable[],
						short *indexTable,
						int iTableSize,
						LPCWSTR ptchLine, 
						int iTokenLength, 
						TXTB & tokenInfo);
	BOOL IsIdentifier (int iTokenLength,
					   TXTB & tokenInfo);
	BOOL IsPPKeyWord (LPCWSTR ptchLine,
					  UINT cbLength,
					  UINT cbCurrent,
						DWORD * plxs,
					  TXTB & tokenInfo);
	BOOL LookupLinearKeyWord (ReservedWord rwTable[],
						int iTableSize,
						LPCWSTR ptchLine,
						int length, 
						TXTB & tokenInfo);
	BOOL IsUnknownID (LPCWSTR ptchLine,
					  UINT cbLength,
					  UINT cbCurrent,
					  TXTB & tokenInfo);
	BOOL IsNumber (LPCWSTR ptchLine,
				   UINT cbLength,
				   UINT cbCurrent,
				   TXTB & tokenInfo);
	BOOL IsUuidString (LPCWSTR ptchLine, 
						UINT cbLength, 
						UINT cbCurrent, 
						TXTB & tokenInfo);
	void FindRightTBracket (LPCWSTR ptchLine,
							UINT cbLength,
							UINT cbCurrent,
							TXTB & tokenInfo);
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\langguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	LANGGUID.H
//		Language package interface ids.

// Interface ID for LangPackage {296EF9E1-528D-11cf-B257-00AA0057AFF3}
DEFINE_GUID(IID_ILangPackage, 
	0x296ef9e1, 0x528d, 0x11cf, 0xb2, 0x57, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for LanguageService {A730D9EA-391B-11d2-8AF0-00C04F7956C9}
DEFINE_GUID(IID_ILanguageService, 
	0xa730d9ea, 0x391b, 0x11d2, 0x8a, 0xf0, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LangDesigner {0833C9C0-B5EE-11D0-A528-00A0C91F381B}
DEFINE_GUID(IID_ILangDesigner, 
	0x833c9c0, 0xb5ee, 0x11d0, 0xa5, 0x28, 0x0, 0xa0, 0xc9, 0x1f, 0x38, 0x1b);

// Interface ID for dispatch version of LangDesigner {0833C9C1-B5EE-11d0-A528-00A0C91F381B}
DEFINE_GUID(DIID_ILangDesigner, 
	0x833c9c1, 0xb5ee, 0x11d0, 0xa5, 0x28, 0x0, 0xa0, 0xc9, 0x1f, 0x38, 0x1b);

// Interface ID for LanguageServices {5300DBB6-0AB8-11d2-B4DD-00A0C915070C}
DEFINE_GUID(IID_ILanguageServices, 
	0x5300dbb6, 0xab8, 0x11d2, 0xb4, 0xdd, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for LanguageItem {757A9E69-5350-11d2-8AFA-00C04F7956C9}
DEFINE_GUID(IID_ILanguageItem, 
	0x757a9e69, 0x5350, 0x11d2, 0x8a, 0xfa, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LanguageClass {6D7A034C-78D2-11d2-8B12-00C04F7956C9}
DEFINE_GUID(IID_ILanguageClass, 
	0x6d7a034c, 0x78d2, 0x11d2, 0x8b, 0x12, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LanguageFunction {003AAD10-75E7-11d2-8B12-00C04F7956C9}
DEFINE_GUID(IID_ILanguageFunction, 
	0x3aad10, 0x75e7, 0x11d2, 0x8b, 0x12, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LanguageVariable {757A9E6C-5350-11d2-8AFA-00C04F7956C9}
DEFINE_GUID(IID_ILanguageVariable, 
	0x757a9e6c, 0x5350, 0x11d2, 0x8a, 0xfa, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LanguageMap {757A9E6D-5350-11d2-8AFA-00C04F7956C9}
DEFINE_GUID(IID_ILanguageMap, 
	0x757a9e6d, 0x5350, 0x11d2, 0x8a, 0xfa, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LanguageMapItem {757A9E6E-5350-11d2-8AFA-00C04F7956C9}
DEFINE_GUID(IID_ILanguageMapItem, 
	0x757a9e6e, 0x5350, 0x11d2, 0x8a, 0xfa, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LanguageEnum {757A9E6F-5350-11d2-8AFA-00C04F7956C9}
DEFINE_GUID(IID_ILanguageEnum, 
	0x757a9e6f, 0x5350, 0x11d2, 0x8a, 0xfa, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LanguageEnumItem {757A9E70-5350-11d2-8AFA-00C04F7956C9}
DEFINE_GUID(IID_ILanguageEnumItem, 
	0x757a9e70, 0x5350, 0x11d2, 0x8a, 0xfa, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for LanguageTypedef {757A9E71-5350-11d2-8AFA-00C04F7956C9}
DEFINE_GUID(IID_ILanguageTypedef, 
	0x757a9e71, 0x5350, 0x11d2, 0x8a, 0xfa, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for CollectionEvents {F1FCD220-6AB0-11cf-B440-0080C79E6C87}
DEFINE_GUID(IID_ICollectionEvents, 
	0xf1fcd220, 0x6ab0, 0x11cf, 0xb4, 0x40, 0x0, 0x80, 0xc7, 0x9e, 0x6c, 0x87);

// Interface ID for LanguageItems {C6090FF2-F5AE-11d1-B4D2-00A0C915070C}
DEFINE_GUID(IID_ILanguageItems, 
	0xc6090ff2, 0xf5ae, 0x11d1, 0xb4, 0xd2, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for WizardTransaction {ED6FD584-1C16-11d2-B4E3-00A0C915070C}
DEFINE_GUID(IID_IWizardTransaction, 
	0xed6fd584, 0x1c16, 0x11d2, 0xb4, 0xe3, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for DOTransactionParticipant {5300DBB4-0AB8-11d2-B4DD-00A0C915070C}
DEFINE_GUID(IID_IDOTransactionParticipant, 
	0x5300dbb4, 0xab8, 0x11d2, 0xb4, 0xdd, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for DOTransaction {FA426E37-FFF1-11d1-B4D7-00A0C915070C}
DEFINE_GUID(IID_IDOTransaction, 
	0xfa426e37, 0xfff1, 0x11d1, 0xb4, 0xd7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for DOTransaction_Internal {6D7A0349-78D2-11d2-8B12-00C04F7956C9}
DEFINE_GUID(IID_IDOTransaction_Internal, 
	0x6d7a0349, 0x78d2, 0x11d2, 0x8b, 0x12, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for CodeManagerMenuBuilder {19D46FA7-2D78-11d2-8AEE-00C04F7956C9}
DEFINE_GUID(IID_ICodeManagerMenuBuilder, 
0x19d46fa7, 0x2d78, 0x11d2, 0x8a, 0xee, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface for CodeManagerSupport_Internal {6D7A034A-78D2-11d2-8B12-00C04F7956C9}
DEFINE_GUID(IID_ICodeManagerSupport_Internal, 
	0x6d7a034a, 0x78d2, 0x11d2, 0x8b, 0x12, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for TransMgrResourceHelper {FA426E36-FFF1-11d1-B4D7-00A0C915070C}
DEFINE_GUID(IID_ITransMgrResourceHelper, 
	0xfa426e36, 0xfff1, 0x11d1, 0xb4, 0xd7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for TransMgrProjHelper {FA426E39-FFF1-11d1-B4D7-00A0C915070C}
DEFINE_GUID(IID_ITransMgrProjHelper, 
	0xfa426e39, 0xfff1, 0x11d1, 0xb4, 0xd7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for CodeMgrBscItems {23E2C8A1-06FF-11d2-B4DB-00A0C915070C}
DEFINE_GUID(IID_ICodeMgrBscItems, 
	0x23e2c8a1, 0x6ff, 0x11d2, 0xb4, 0xdb, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for BscPersistentItem {1FBE7E80-6AB0-11cf-B440-0080C79E6C87}
DEFINE_GUID(IID_IBscPersistentItem, 
	0x1fbe7e80, 0x6ab0, 0x11cf, 0xb4, 0x40, 0x0, 0x80, 0xc7, 0x9e, 0x6c, 0x87);

// Interface ID for PrivateLanguageItems {5300DBC1-0AB8-11d2-B4DD-00A0C915070C}
DEFINE_GUID(IID_IPrivateLanguageItems, 
	0x5300dbc1, 0xab8, 0x11d2, 0xb4, 0xdd, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for PrivateLangToLang {A730D9EB-391B-11d2-8AF0-00C04F7956C9}
DEFINE_GUID(IID_IPrivateLangToLang, 
	0xa730d9eb, 0x391b, 0x11d2, 0x8a, 0xf0, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for PrivateDynamicUI {E2954E90-D9C7-11cf-B78E-00AA00B8DDCE}
DEFINE_GUID(IID_IPrivateDynamicUI, 
	0xe2954e90, 0xd9c7, 0x11cf, 0xb7, 0x8e, 0x0, 0xaa, 0x0, 0xb8, 0xdd, 0xce);

// Interface ID for IPrivateDynamicClsFldUI {A730D9EC-391B-11d2-8AF0-00C04F7956C9}
DEFINE_GUID(IID_IPrivateDynamicClsFldUI, 
	0xa730d9ec, 0x391b, 0x11d2, 0x8a, 0xf0, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for PrivateLanguageItem {C9D0E290-32AA-11d0-9912-00A0C91BC8E5}
DEFINE_GUID(IID_IPrivateLanguageItem,
	0xc9d0e290, 0x32aa, 0x11d0, 0x99, 0x12, 0x0, 0xa0, 0xc9, 0x1b, 0xc8, 0xe5);

// Interface ID for ICodeMgrTextEditor {FA426E33-FFF1-11d1-B4D7-00A0C915070C}
DEFINE_GUID(IID_ICodeMgrTextEditor, 
	0xfa426e33, 0xfff1, 0x11d1, 0xb4, 0xd7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for ICodeMgrTextEditorCommand {FA426E32-FFF1-11d1-B4D7-00A0C915070C}
DEFINE_GUID(IID_ICodeMgrTextEditorCommand, 
	0xfa426e32, 0xfff1, 0x11d1, 0xb4, 0xd7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for ICodeMgrLexer {FA426E31-FFF1-11d1-B4D7-00A0C915070C}
DEFINE_GUID(IID_ICodeMgrLexer, 
	0xfa426e31, 0xfff1, 0x11d1, 0xb4, 0xd7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for IDOExpandTemplates {D26C1B68-1833-11d2-B4E1-00A0C915070C}
DEFINE_GUID(IID_IDOExpandTemplates, 
	0xd26c1b68, 0x1833, 0x11d2, 0xb4, 0xe1, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for IDOTemplateDictionary {FA426E34-FFF1-11d1-B4D7-00A0C915070C}
DEFINE_GUID(IID_IDOTemplateDictionary, 
	0xfa426e34, 0xfff1, 0x11d1, 0xb4, 0xd7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for IVCSimpleWizard {5300DBB2-0AB8-11d2-B4DD-00A0C915070C}
DEFINE_GUID(IID_IVCSimpleWizard, 
	0x5300dbb2, 0xab8, 0x11d2, 0xb4, 0xdd, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for IVCWizardContext {A730D9E9-391B-11d2-8AF0-00C04F7956C9}
DEFINE_GUID(IID_IVCWizardContext, 
	0xa730d9e9, 0x391b, 0x11d2, 0x8a, 0xf0, 0x0, 0xc0, 0x4f, 0x79, 0x56, 0xc9);

// Interface ID for IPrivateLangToWiz {5300DBC2-0AB8-11d2-B4DD-00A0C915070C}
DEFINE_GUID(IID_IPrivateLangToWiz, 
	0x5300dbc2, 0xab8, 0x11d2, 0xb4, 0xdd, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\msodc.h ===
/*-----------------------------------------------------------------------------
Microsoft Sterling

Microsoft Confidential
Copyright 1994-1996 Microsoft Corporation.  All Rights Reserved.

File:		msodc.h
Contents:	This file describes the data context interfaces
-----------------------------------------------------------------------------*/

#ifndef _MSODC_H_
#define _MSODC_H_

#include <sql.h>
#include "inamespc.h"

// Forward Declarations -------------------------------------------------------
interface INamespace;
interface IDSRefConsumer;
interface IPkgProject;

///////////////////////////////////////////////////////////////////////////////
//
//    INamespaceSource
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// NSTYPE enumeration
typedef enum tagNSTYPE {
	NSTYPE_PROJECT		= 0x00000001,
	NSTYPE_DATASTORE	= 0x00000002
} NSTYPE;

#undef	INTERFACE
#define	INTERFACE	INamespaceSource
DECLARE_INTERFACE_(INamespaceSource, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, VOID** ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// INamespaceSource methods
	STDMETHOD(GetNamespace)(THIS_ DWORD nstype, INamespace** ppNamespace) PURE;
};


///////////////////////////////////////////////////////////////////////////////
//
//    IPersistDataStore
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// DSPERSIST enumeration
typedef enum tagDSPERSIST {
	DSPERSIST_NONE          = 0x00000000,
	DSPERSIST_DATASTORE		= 0x00000001,
	DSPERSIST_STORAGE		= 0x00000002,
	DSPERSIST_STREAM		= 0x00000004,

	// new ones added for Schema
	DSPERSIST_DEFERREDDDL	= 0x00000008,
	DSPERSIST_CHANGESCRIPT	= 0x00000010,

	// added to identify Query Builder Mode
	DSPERSIST_QUERYBUILDER	= 0x00000020,
	// open Query data pane only & run query
	DSPERSIST_RUNQUERY		= 0x00000040,

	// new ones added for Schema (R2)
	DSPERSIST_SAVEDIAGRAM		= 0x00000080,
	DSPERSIST_ALLOWOVERWRITE    = 0x00000100,
	DSPERSIST_NOCANCEL          = 0x00000200
} DSPERSIST;


// flags for PromptIfDirty() method to return to caller what User action to do.
typedef enum tagDSPERSISTUSERACTION {
	DSPERSIST_SAVE,
	DSPERSIST_NOSAVE,
	DSPERSIST_CANCEL
} DSPERSISTUSERACTION;



#undef	INTERFACE
#define	INTERFACE	IPersistDataStore
DECLARE_INTERFACE_(IPersistDataStore, IPersist)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, VOID** ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IPersist methods
	STDMETHOD(GetClassID)(THIS_ CLSID* pClassID) PURE;

	// IPersistDataStore methods
	STDMETHOD(IsDirty)(THIS_ DWORD grfDSPersist) PURE;
	STDMETHOD(InitNew)(THIS_ IDSRefConsumer* pDSRef,
					IUnknown* pUnkConnectObj, IStream* pstm, IStorage* pstg,
					DWORD grfDSPersist) PURE;
	STDMETHOD(Load)(THIS_ IDSRefConsumer* pDSRef,
					IUnknown* pUnkConnectObj, IStream* pstm, IStorage* pstg,
					DWORD grfDSPersist) PURE;
	STDMETHOD(Save)(THIS_ IDSRefConsumer* pDSRef,
					IUnknown* pUnkConnectObj, IStream* pstm, IStorage* pstg,
					DWORD grfDSPersist,
					BOOL fSameAsLoad) PURE;
	STDMETHOD(SaveCompleted)(THIS_ IDSRefConsumer* pDSRef,
					IUnknown* pUnkConnectObj, IStream* pstm, IStorage* pstg,
					DWORD grfDSPersist) PURE;
	STDMETHOD(HandsOffDataStore)(THIS) PURE;
	STDMETHOD(PromptIfDirty)(DWORD * pUserAction, DWORD * pgrfDSPersist) PURE;
	STDMETHOD(GetName)(BSTR * pbstrName) PURE;
};



///////////////////////////////////////////////////////////////////////////////
//
//    IDBConnectObject
//
///////////////////////////////////////////////////////////////////////////////

// {B7A1D4A0-7210-11cf-BE16-00AA0062C2EF}
// DEFINE_GUID(IID_IDBConnectObject, 0xb7a1d4a0, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);
//
enum {DBCONN_SHOW_CONNECTION, DBCONN_SHOW_PROPERTY};

#undef	INTERFACE
#define	INTERFACE	IDBConnectObject
DECLARE_INTERFACE_(IDBConnectObject, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, VOID** ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IDBConnectObject methods
	STDMETHOD(LockHandle)(THIS_ VOID** ppvConnectHandle) PURE;
	STDMETHOD_(VOID,UnlockHandle)(THIS) PURE;
	STDMETHOD(GetConnectString)(THIS_ LPOLESTR* ppszConnectString) PURE;
	STDMETHOD(GetNamespace)(THIS_ INamespace** ppNamespace) PURE;
	STDMETHOD(GetDisplayName)(THIS_ LPOLESTR * ppszDisplayName) PURE; 
	STDMETHOD(SetDisplayName)(THIS_ LPCOLESTR pszNewDisplayName) PURE; 
	STDMETHOD(GetNSIDPath)(THIS_ REFGUID guidObjType, LPCOLESTR pszObjName, LPCOLESTR pszOwnerName, NSIDPath ** ppNSIDPath) PURE; 
	STDMETHOD(Show)(THIS_ BOOL fUserControl, DWORD dwShow) PURE; 
};



///////////////////////////////////////////////////////////////////////////////
//
//    IODBCConnectObject
//
///////////////////////////////////////////////////////////////////////////////


// {B7A1D4A1-7210-11cf-BE16-00AA0062C2EF}
// DEFINE_GUID(IID_IODBCConnectObject, 0xb7a1d4a1, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);


#undef	INTERFACE
#define	INTERFACE	IODBCConnectObject
DECLARE_INTERFACE_(IODBCConnectObject, IDBConnectObject)
{
	STDMETHOD_(VOID,ShowError)(THIS_ HSTMT hstmt) PURE;
	STDMETHOD_(BOOL,FShowSystemObjects)() PURE;
};


///////////////////////////////////////////////////////////////////////////////
//
//    IJetConnectObject
//
///////////////////////////////////////////////////////////////////////////////

// {B7A1D4A2-7210-11cf-BE16-00AA0062C2EF}
// DEFINE_GUID(IID_IJetConnectObject, 0xb7a1d4a2, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#undef	INTERFACE
#define	INTERFACE	IJetConnectObject
DECLARE_INTERFACE_(IJetConnectObject, IDBConnectObject)
{
};


///////////////////////////////////////////////////////////////////////////////
//
//    IDBConnectionManager
//
///////////////////////////////////////////////////////////////////////////////

typedef enum {
CONNSTR_ODBCSTR = 0, 
CONNSTR_ODBCFILEDSN = 1,
CONNSTR_JET = 2, 
} CONNSTR;

// {B7A1D4A3-7210-11cf-BE16-00AA0062C2EF}
// DEFINE_GUID(IID_IDBConnectionManager, 0xb7a1d4a3, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#undef	INTERFACE
#define	INTERFACE	IDBConnectionManager
DECLARE_INTERFACE_(IDBConnectionManager, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, VOID** ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IDBConnectionManager methods
	STDMETHOD(GetConnectObjFromString)(THIS_
								LPCOLESTR pszDisplayName,
								LPCOLESTR pszConnectStr,
								DWORD dwConnStrType,
								REFIID iidConnectObj,
								IUnknown* punkPkgProject,
								void ** ppConnectObj) PURE;
	STDMETHOD(GetConnectObjects)(THIS_
								ULONG cMaxConnections,
								IDBConnectObject **rgpConnObj, 
								ULONG *pcNumConnectObj) PURE;
	STDMETHOD(AddNewConnection)(THIS_
								DWORD dwConnStrType,
								LPCOLESTR pszDisplayName, 
								LPCOLESTR pszConnStrIn,
								IUnknown* punkPkgProject,
								LPOLESTR * ppszConnStrOut,
								IDBConnectObject ** ppConnectObj) PURE;
};

// {B7A1D4A4-7210-11cf-BE16-00AA0062C2EF}
// DEFINE_GUID(IID_IAsyncQueryBuilder, 0xb7a1d4a4, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#undef	INTERFACE
#define	INTERFACE	IAsyncQueryBuilder
DECLARE_INTERFACE_(IAsyncQueryBuilder, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, VOID** ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    STDMETHOD(Execute)(THIS_ 
            /* [in] */ IDispatch * pdispApp,
            /* [in] */ HWND * hwndBuilderOwner,
            /* [in] */ LPCOLESTR pszBuilderOwner,
            /* [in] */ IDBConnectObject * pDBConnObj,
            /* [in] */ IDispatch * pdispCaller,
            /* [in] */ DISPID  dispidSQLText,
            /* [in] */ CALPOLESTR * pcaRunPropNames,
            /* [in] */ CADWORD * pcaRunPropDISPIDs,
            /* [in] */ ULONG cDesignProp,
            /* [in] */ VARIANTARG * pvargDesignPropNames,
            /* [in] */ VARIANTARG * pvargDesignPropValues) PURE;
};

// {B7A1D4A6-7210-11cf-BE16-00AA0062C2EF}
// DEFINE_GUID(IID_IDataSrcClient, 0xb7a1d4a6, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#undef	INTERFACE
#define	INTERFACE	IDataSrcClient
DECLARE_INTERFACE_(IDataSrcClient, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, VOID** ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    STDMETHOD(AddDataSource)(THIS) PURE;
};

// {BE377880-0B1D-11d0-8923-00AA00BF0506}
// DEFINE_GUID(IDataSrcDebug, 0xbe377880, 0xb1d, 0x11d0, 0x89, 0x23, 0x0, 0xaa, 0x0, 0xbf, 0x5, 0x6);

#undef	INTERFACE
#define INTERFACE   IDataSrcDebug
DECLARE_INTERFACE_(IDataSrcDebug, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, VOID** ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    STDMETHOD(InitDebugging)(THIS_ ULONG hStmt, ULONG hEvent) PURE;
	STDMETHOD(ExitDebugging)(THIS) PURE;
    STDMETHOD(SetObjectName)(THIS_ LPOLESTR, LPOLESTR, LPOLESTR) PURE;
    STDMETHOD_(BOOL, CanDebugObject)(THIS_ BOOL fCheckLocal) PURE;
	STDMETHOD(SetDebugLines)(THIS_ LPVOID) PURE;
	STDMETHOD(GetDebugStatus)(THIS_ ULONG*) PURE;
	STDMETHOD(SetDebugStatus)(THIS_ ULONG) PURE;
};

typedef IDataSrcDebug *PDBDBG;

// {b0c47fd0-1220-11d0-9d16-00c04fd9dfd9}
// DEFINE_GUID(IDataClientDebugConsumer, 0xb0c47fd0, 0x1220, 0x11d0, 0x9d, 0x16, 0x00, 0xc0, 0x4f, 0xd90x, 0xdf, 0xd9);

#define ACTIVE_DOC_TYPE_SP			0
#define ACTIVE_DOC_TYPE_TRIGGER		1
#define ACTIVE_DOC_TYPE_TABLE		2
#define ACTIVE_DOC_TYPE_DATABASE	3
#define ACTIVE_DOC_TYPE_ERROR       0x100
#define ACTIVE_DOC_TYPE_NOACTIVE    0x101
#define ACTIVE_DOC_TYPE_OTHER       0x102

#undef	INTERFACE
#define	INTERFACE	IDataSrcDebugConsumer
DECLARE_INTERFACE_(IDataSrcDebugConsumer, IUnknown)
{
	// IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, VOID** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    STDMETHOD(StopDebugging)(void) PURE ;
    STDMETHOD(BuildDebugLineTable)(LPTSTR pchBuf, unsigned short** pprgElems, unsigned short* pcElems) PURE;
	STDMETHOD_(DWORD,GetActiveDocType)(void) PURE ;
};

typedef IDataSrcDebugConsumer *PDBDBGCONSUMER;


#endif //_MSODC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\memref.h ===
#ifndef __MEMREF_H__
#define __MEMREF_H__

#if defined(_DEBUG)
#define	MRDebug(x)	x
#else
#define	MRDebug(x)
#endif

/////////////////////////////////////////////////////////////////////////////
// CRefObj--handles ref counted garbage collection and dyncasting

class CRefObj
{
private:
	unsigned _cUses;

public:
	CRefObj() { _cUses = 0; }

	// copy ctor, does not copy usage count of object being copied from
	CRefObj(const CRefObj &) { _cUses = 0; }

	// virtual dtor should cause all descendents of CRefObj to have a virtual dtor
	virtual ~CRefObj() { }

	CRefObj &operator= (const CRefObj &) { return *this; }

	unsigned CUses() { return _cUses; }

	void Use() { _cUses++; }

	BOOL FUnUse() { return !(--_cUses); }
};

/////////////////////////////////////////////////////////////////////////////
// CRefMem

class CRefMem : public CRefObj
{
private:
	VOID * _pv;
	size_t _cbAlloc;
	size_t _cbUsed;
	HANDLE _hHeap;

	inline void Uninit();

public:
	CRefMem(HANDLE hHeap = 0)
	{
		_pv = 0;
		_cbAlloc = 0;
		_cbUsed = 0;
		_hHeap = hHeap;
	}

	~CRefMem() { Uninit(); }

	inline BOOL FInit(size_t cb);
	inline BOOL FRealloc(size_t cb);	// If the allocation succeeds, the old
										// data will be copied to the new address;
										// otherwise, the original allocation is
										// left intact.

	operator BYTE *() { return ((BYTE *) _pv); }
	operator VOID *() { return _pv; }
//	operator TCHAR *() { return (TCHAR *) _pv; }
	operator char *() { return reinterpret_cast<char *> (_pv); }
	operator WCHAR *() { return reinterpret_cast<WCHAR *> (_pv); }

	operator const BYTE *() const { return (const BYTE *) _pv; }
	operator const VOID *() const { return (const VOID *) _pv; }
//	operator const TCHAR *() const { return (const TCHAR *) _pv; }
	operator const char *() const { return reinterpret_cast<const char *> (_pv); }
	operator const WCHAR *() const { return reinterpret_cast<const WCHAR *>(_pv); }

	size_t CbAlloc() { return _cbAlloc; }

	size_t CbUsed() { return _cbUsed; }

	void SetCbUsed(size_t cb) 
	{
		if (cb < _cbAlloc)
			_cbUsed = cb;
		else
			_cbUsed = _cbAlloc;
	}
};

/////////////////////////////////////////////////////////////////////////////

#define refNil	0

template <class TARG> class Ref
{
private:
	TARG *_ptarg;

	// unuse pointer and free if last user
	VOID Release()
	{
		if (_ptarg != NULL && _ptarg->FUnUse())
			delete _ptarg;
		// put garbage in pointer
#ifdef _WIN64
		MRDebug(_ptarg = (TARG *)0xdadadadadadadada);
#else
		MRDebug(_ptarg = (TARG *)0xdadadada);
#endif // _WIN64
	}

public:
	// constructors
	Ref<TARG>() { _ptarg = NULL; }

	Ref<TARG>(TARG *ptargNew)
	{
		_ptarg = ptargNew;
		if (ptargNew != NULL)
			ptargNew->Use();
	}

	Ref<TARG>(const Ref<TARG> &rtarg)
	{
		_ptarg = rtarg._ptarg;
		if (rtarg._ptarg != NULL)
			rtarg._ptarg->Use();
	}

	// destructor
	~Ref<TARG>() { Release(); }

	// assignment functions (mirror the ctors)
	Ref<TARG>& operator=(TARG *ptargNew)
	{
		if (ptargNew != NULL)
			ptargNew->Use();
		Release();
		_ptarg = ptargNew;
		return *this;
	}

	Ref<TARG>& operator=(const Ref<TARG> &rtarg)
	{
		if (rtarg._ptarg != NULL)
			rtarg._ptarg->Use();
		Release();
		_ptarg = rtarg._ptarg;
		return *this;
	}

	BOOL  operator==(TARG *ptarg) const { return _ptarg == ptarg; }
	BOOL  operator!=(TARG *ptarg) const { return _ptarg != ptarg; }
	TARG &operator*()			  const { return *_ptarg; }
	TARG *operator->()			  const { return _ptarg; }
		  operator TARG *()		  const { return _ptarg; }
};

/////////////////////////////////////////////////////////////////////////////

typedef Ref<CRefMem> RMEM;

inline BOOL MEM_FCreate(RMEM &refMem, size_t cb, HANDLE hHeap = 0)
{
	BOOL f = FALSE;
	CRefMem *pMem = new CRefMem(hHeap);

	if (pMem)
	{
		if (!(f = pMem->FInit(cb)))
		{
			delete pMem;
			pMem = 0;
		}
	}
	refMem = pMem;
	return f;
}

inline BOOL CRefMem::FInit(size_t cb)
{
	BOOL f = FALSE;
	if (_pv && _cbAlloc)
		Uninit();
	if (_hHeap)
		f = (_pv = HeapAlloc(_hHeap, HEAP_ZERO_MEMORY, cb)) != NULL;
	else
		f = (_pv = calloc( 1, cb)) != NULL;
	MRDebug((f ? memset(_pv, 0xcc, cb) : 0));
	if (f)
		_cbAlloc = _cbUsed = cb;
	return f;
}

inline void CRefMem::Uninit()
{
	if (_pv)
	{
		MRDebug(memset(_pv, 0xda, _cbAlloc));
		if (_hHeap)
			HeapFree(_hHeap, 0, _pv);
		else
			free(_pv);
		_pv = 0;
		_cbAlloc = _cbUsed = 0;
	}
}

inline BOOL CRefMem::FRealloc(size_t cb)
{
	BOOL f = FALSE;

	if (_pv)
	{
		VOID *pvT;
		if (_hHeap)
			pvT = HeapAlloc(_hHeap, HEAP_ZERO_MEMORY, cb);
		else
			pvT = calloc(1, cb);
		if (pvT)
		{
			memcpy(pvT, _pv, min(cb, _cbAlloc));
			MRDebug(memset(_pv, 0xda, _cbAlloc));
			if (_hHeap)
				HeapFree(_hHeap, 0, _pv);
			else
				free(_pv);
			MRDebug((cb > _cbAlloc ? memset((BYTE *)pvT + _cbAlloc, 0xcc, cb - _cbAlloc) : 0));
			_cbAlloc = cb;
			if (_cbUsed > cb)
				_cbUsed = cb;
			_pv = pvT;
			f = TRUE;
		}		
	}
	else
		f = FInit(cb);

	return f;
}

#endif	// __MEMREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\msgboxes.inl ===
/* MsgBoxes.inl
 *                                                    
 * Purpose:	Inline implementations for message boxes.
 *
 * Created:	28 July 1993 -by- Andrew Milton [w-amilt]
 *
 * Notes:	See <MsgBoxes.h> for details.
 *	
 * Copyright (c) 1993 Microsoft Corporation.  All rights reserved. 
 ****************************************************************************/

#ifndef MSGBOXES_H

#error Must #include 'msgboxes.h' before 'msgboxes.inl'

#else

#ifndef MSGBOXES_INL
#define MSGBOXES_INL

/***************************** Inline Function ******************************\
 MsgBox()

 Purpose:	Load a string from the resource table & display it in a message
 			box.

 Returns:	ID of the button pressed to dismiss the box.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/
 
inline int 
MsgBox(
	const MsgBoxTypes BoxType,
	const int nMessageID,
	UINT nButtonIDs, 	/* = DEFAULT_BUTTONS 	*/
	UINT nHelpContext)	/* = DEFAULT_HELP		*/
{
	CString strMsg;
	strMsg.LoadString(nMessageID);
	return(MsgBox(BoxType, strMsg, nButtonIDs, nHelpContext));
}

/***************************** Inline Function ******************************\
 [V]MsgText()

 Purpose:	To load strings from the resource table for formatting purposes.

 Returns:	Pointer to the formatted text.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline LPCTSTR
VMsgText(
	CString &strBuffer,
	const int idsMsgFormat,
	va_list VarArguments)
{
	CString strMsgFormat;
	VERIFY(strMsgFormat.LoadString(idsMsgFormat));
	return SubstituteBytes(strBuffer, strMsgFormat, VarArguments);
}

inline LPCTSTR
MsgText(
	CString &strBuffer,
	const int idsMsgFormat,
	...)
{ 
	CString strMsgFormat;
	VERIFY(strMsgFormat.LoadString(idsMsgFormat));
	va_list VarArguments;
	va_start(VarArguments, idsMsgFormat);
	return SubstituteBytes(strBuffer, strMsgFormat, VarArguments);
}

inline LPCTSTR
MsgText(
	CString &strBuffer,
	const CPath &pathOffendingFile,
	const int idsFileOperation,
	const CFileException *peOffence)
{
	CString strOperation;
	VERIFY(strOperation.LoadString(idsFileOperation));
	return MsgText(strBuffer, pathOffendingFile, strOperation, peOffence);
}

/***************************** Inline Function ******************************\
 InformationBox()
 QuestionBox()
 ErrorBox()

 Purpose:	Shortcut functions for the IDE's convenience.  Let's not be
 			using these, eh?

 Returns:	Information - Nada, Error - FALSE, Question - Button pressed.

 Notes:		Roughly speaking, we have <Foo>Box(ids, <stuff>) is the same as
 			MsgBox(<Foo>, MsgText(str, ids, <stuff>))
			The exception is QuestionBox, which sets the available buttons.

			These functions were ripped out of VCPP32\C\UTIL.C 

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline BOOL __cdecl 
ErrorBox(
	UINT idsMsgFormat,
	...)
{
	CString strErrText;
	va_list VarArguments;
	va_start(VarArguments, idsMsgFormat);

	MsgBox(Error, VMsgText(strErrText, idsMsgFormat, VarArguments));

	return FALSE; //Keep it always FALSE please
}

inline void __cdecl
InformationBox(
	UINT idsMsgFormat,
	...)
{
	CString strInfoText;
	va_list VarArguments;
	va_start(VarArguments, idsMsgFormat);

	MsgBox(Information, VMsgText(strInfoText, idsMsgFormat, VarArguments));

	return; 
}

inline int __cdecl 
QuestionBox(
	UINT idsMsgFormat,
	UINT nButtons,
	...)
{
	CString strQuestionText;
	va_list VarArguments;
	va_start(VarArguments, nButtons);

	return MsgBox(Question, 
					VMsgText(strQuestionText, idsMsgFormat, VarArguments),
					nButtons);
}

/************************** DLL Exported Function ***************************\
 SubstituteBytes()

 Purpose:	To construct a display string given a CString buffer, a format
 			string, and a va_list of substitution variables.

 Returns:	Constant pointer to the constructed string.

 Notes:		This function should *not* be called directly.  It is used by the
 			inline versions of the MsgText() functions to construct message
 			box string.  See the header file for details.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline LPCTSTR
SubstituteBytes(
	CString &strBuffer,
	LPCTSTR pszFormat,
	va_list VarArguments)
{
// Get some space in the buffer...

    int cchBuffer = lstrlen(pszFormat) + MAX_SUBSTITUTION_BYTES;
    LPTSTR pszBuffer = strBuffer.GetBuffer(cchBuffer);

// ...and fill it.

	VERIFY(wvsprintf(pszBuffer, pszFormat, VarArguments) < cchBuffer);
	strBuffer.ReleaseBuffer();

	return strBuffer;
}


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\ncbguid.h ===
//////////////////////////////////////////////
// NCBGUID.H
//		NCB package for interface ids.
///////////////////////////////////////////////

// Interface ID for NCB
// {9ADE0EB0-6273-11cf-BF4F-00AA006C2891}
DEFINE_GUID(IID_INCB, 
	0x9ade0eb0, 0x6273, 0x11cf, 0xbf, 0x4f, 0x0, 0xaa, 0x0, 0x6c, 0x28, 0x91);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\ogapi.h ===
#ifndef __OGAPI_H__
#define __OGAPI_H__

// Component Gallery interface declarations

// These are all interfaces on an apply context object
interface IApplyContext;
interface IManageValues;
interface IAddFiles;
interface IAddResources;
interface IFindClasses;
interface IWriteCode;

// This interface is used to create a new class.
interface ICreateClasses;

interface IFormStrings;	// handles lists of strings returned from various queries from ICreateClasses


// This is an interface provided by a client of the apply context, in order to
// provide information to the user while editing the value map.
interface IExplainValues;

// These interfaces are used as results from the parser
interface IEnumClasses;
interface IExplainClasses;

interface IEnumMembers;
interface IExplainMembers;

// This interface is used to interact with templates.
interface IExpandTemplates;

// These interfaces are supplied by external Components.
interface IComponentType;
interface IImportComponents;
interface IComponent;
interface IExplainComponents;

// This interface is used by external components to
// interact with the Gallery.
interface IComponentGallery;


// Interface pointer types.
typedef IApplyContext* LPAPPLYCONTEXT;
typedef IManageValues* LPMANAGEVALUES;
typedef IAddFiles* LPADDFILES;
typedef IAddResources* LPADDRESOURCES;
typedef IFindClasses* LPFINDCLASSES;
typedef IWriteCode* LPWRITECODE;
typedef ICreateClasses* LPCREATECLASSES;
typedef IExplainValues* LPEXPLAINVALUES;
typedef IEnumClasses* LPENUMCLASSES;
typedef IExplainClasses* LPEXPLAINCLASSES;
typedef IEnumMembers* LPENUMMEMBERS;
typedef IExplainMembers* LPEXPLAINMEMBERS;
typedef IExpandTemplates* LPEXPANDTEMPLATES;
typedef IComponentType* LPCOMPONENTTYPE;
typedef IImportComponents* LPIMPORTCOMPONENTS;
typedef IComponent* LPCOMPONENT;
typedef IExplainComponents* LPEXPLAINCOMPONENTS;
typedef IComponentGallery* LPCOMPONENTGALLERY;
typedef IFormStrings* LPFORMSTRINGS;


/////////////////////////////////////////////////////////////////////////////
// IApplyContext
//   This is the primary interface on an Apply Context object.

#undef  INTERFACE
#define INTERFACE IApplyContext
DECLARE_INTERFACE_(IApplyContext, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IApplyContext methods
	STDMETHOD(FinishApply)(THIS_ BOOL bRemember) PURE;
	STDMETHOD(AbortApply)(THIS) PURE;

	STDMETHOD(DoModal)(THIS_ IExplainValues FAR* pev) PURE;

	STDMETHOD(GetIComponentGallery)(THIS_ IComponentGallery ** pCG) PURE;

};


/////////////////////////////////////////////////////////////////////////////
// IManageValues
//   This interface allows interaction with the value table.

#undef  INTERFACE
#define INTERFACE IManageValues
DECLARE_INTERFACE_(IManageValues, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Value interaction
	STDMETHOD(AddValue)(THIS_ LPCSTR pszKey, LPCSTR pszValue) PURE;
	STDMETHOD(GetValue)(THIS_ LPCSTR pszKey, LPSTR FAR* ppszValue) PURE;
	STDMETHOD(SetValue)(THIS_ LPCSTR pszKey, LPCSTR pszValue) PURE;
	STDMETHOD(RemoveValue)(THIS_ LPCSTR pszKey) PURE;
	STDMETHOD(ClearValues)(THIS) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IAddFiles
//   This interface on an Apply Context object is used to interact with the
//   project.  i.e. add/enumerate files, etc.

#define DW_FILE_EXIST	0x00000001
#define DW_FILE_IN_PROJECT 0x00000002
#define DW_FILE_INSERT_IFACE 0x00010000
#define DW_FILE_INSERT_COCLASS 0x00020000

#undef  INTERFACE
#define INTERFACE IAddFiles
DECLARE_INTERFACE_(IAddFiles, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Filename methods.
	STDMETHOD(CalculateFilename)(THIS_ LPCSTR pszFilename, LPSTR FAR* ppszNewFilename) PURE;
	STDMETHOD(SaveFilename)(THIS_ LPCSTR pszDesiredFilename, LPCSTR pszActualFilename) PURE;
	STDMETHOD(AddFile)(THIS_ LPCSTR pszFilename) PURE;
	STDMETHOD (CalculateFilenameEx) (THIS_ LPCSTR pszFilename, LPSTR FAR * ppszNewFilename, DWORD * pdwHint) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IAddResources
//   This interface on an Apply Context object is used to interact with
//   the projects resource script.

#undef  INTERFACE
#define INTERFACE IAddResources
DECLARE_INTERFACE_(IAddResources, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Resource methods.
	STDMETHOD(Create)(THIS_ UINT nCreateFlags) PURE;
	STDMETHOD(GetResourceInclude)(THIS_ LPSTR FAR* ppszFilename) PURE;

	STDMETHOD(AttachResourceStream)(THIS_ LPSTREAM lpStream) PURE;
	STDMETHOD(CreateSymbol)(THIS_ LPCSTR pszID, LPSTR FAR* ppszActualID) PURE;
	STDMETHOD(CreateResource)(THIS_ LPCSTR pszType, LPCSTR pszID, int nLangID, LPCSTR szCondition, LPCSTR pszNewID) PURE;
	STDMETHOD(ImportResource)(THIS_ LPCSTR pszType, LPCSTR pszID, LPCSTR pszFileName, int nLangID, LPCSTR szCondition) PURE;
	STDMETHOD(SetResourceID)(THIS_ LPCSTR pszType, LPCSTR pszOldID, int nLangID, LPCSTR szCondition, LPCSTR pszNewID) PURE;
	STDMETHOD(CreateString)(THIS_ LPCSTR pszID, int nLangID, LPCSTR szCondition, LPCSTR pszString) PURE;
	STDMETHOD(Access)(THIS_ UINT nMode) PURE;
};
// Open flags
#define OPEN_ALWAYS_RC   (0)
#define CREATE_NEW_RC    (1)
#define OPEN_EXISTING_RC (2)

// Access mode flags
#ifndef MODE_READ
#define MODE_READ   (0)
#endif
#ifndef MODE_WRITE
#define MODE_WRITE  (1)
#endif

/////////////////////////////////////////////////////////////////////////////
// IFindClasses
//   This interface on an Apply Context object is used to query the parser
//   as to the location and existence of interesting things.

#undef  INTERFACE
#define INTERFACE IFindClasses
DECLARE_INTERFACE_(IFindClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Class interaction methods.
	STDMETHOD(GetClassInfo)(THIS_ LPCSTR pszClass, IExplainClasses FAR** ppec) PURE;
	STDMETHOD(GetDerivedClasses)(THIS_ LPCSTR pszParent, BOOL bImmediateOnly, IEnumClasses FAR** ppec) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IWriteCode
//   This interface on an Apply Context object is used to make code changes
//   to the project.  It allows the addition of new members, and some simple
//   additions to existing members.

#undef  INTERFACE
#define INTERFACE IWriteCode
DECLARE_INTERFACE_(IWriteCode, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Code modification methods
	STDMETHOD(InsertMember)(THIS_ LPCSTR pszMember, UINT nAccess) PURE;
	STDMETHOD(CreateImplementation)(THIS_ LPCSTR pszMember, LPCSTR pszCode, UINT nPlacement, BOOL bCreate) PURE;
	STDMETHOD(InsertMapEntry)(THIS_ LPCSTR pszMap, LPCSTR pszClass, LPCSTR pszEntry) PURE;

	// Helper methods
	STDMETHOD(ValidateSymbol)(THIS_ LPCSTR pszSymbol) PURE;
	STDMETHOD(IsMFCClass)(THIS_ LPCSTR pszClass) PURE;
	STDMETHOD(CreateFilenameDefine)(THIS_ LPCSTR pszFilename, LPSTR FAR *ppszSymbol) PURE;

	// Include directive methods
	STDMETHOD(AddProjectInclude)(THIS_ LPCSTR pszIncludeFile) PURE;
	STDMETHOD(AddClassInclude)(THIS_ LPCSTR pszClass, LPCSTR pszIncludeFile, UINT nFlags) PURE;
	STDMETHOD(AddFileInclude)(THIS_ LPCSTR pszFilename, LPCSTR pszIncludeName) PURE;
	
	// Generic code addition.
	STDMETHOD(AddClassCode)(THIS_ LPCSTR pszClass, LPCSTR pszCode) PURE;
	STDMETHOD(AddFileCode)(THIS_ LPCSTR pszFile, LPCSTR pszCode) PURE;

	// Project query methods.
	STDMETHOD(GetProjectName)(THIS_ LPSTR FAR* ppszProjectName) PURE;

	// Insert file content to file
	STDMETHOD(InsertFileContent)(THIS_ LPCSTR pszFileContent, LPCSTR szLang, DWORD dwHint, LPCSTR pszFileName) PURE;

	//Get name of project include file (99% of time is stdafx.h)
	STDMETHOD(GetProjectIncludeFile)(THIS_ LPSTR FAR* ppszProjectInclude) PURE;

};
// Access flags
#define ACCESS_DONTCARE  (0)
#define ACCESS_PUBLIC    (1)
#define ACCESS_PROTECTED (2)
#define ACCESS_PRIVATE   (3)

// Placement flags
#define PLACEMENT_BEGIN         (1)
#define PLACEMENT_END           (2)
#define PLACEMENT_BEFORE_PARENT (3)
#define PLACEMENT_AFTER_PARENT  (4)

// Include flags
#define CLASS_DEFINITION	(0)
#define CLASS_IMPLEMENTATION	(1)


/////////////////////////////////////////////////////////////////////////////
// ICreateClasses
//   This interface is returned by the IOGCodeMunge interface, and is used to
//   manipulate the attributes of a new class.

#undef  INTERFACE
#define INTERFACE ICreateClasses
DECLARE_INTERFACE_(ICreateClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// INewClass methods
	STDMETHOD(SetName)(THIS_ LPCSTR pszName) PURE;
	STDMETHOD(SetBaseClass)(THIS_ LPCSTR pszName) PURE;
	STDMETHOD(SetFiles)(THIS_ LPCSTR pszHeader, LPCSTR pszImplementation) PURE;

	STDMETHOD(SetOLEOptions)(THIS_ UINT nFlags, LPCSTR pszName) PURE;

	// Only for classes that require a dialog template.
	STDMETHOD(SetDialogTemplate)(THIS_ LPCSTR pszDialogID) PURE;

	// These methods are used to allow the user to change class information.
	STDMETHOD(SetNameFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetBaseClassFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetFilesFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetOLEOptionsFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetDialogTemplateFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetDialogTitle)(THIS_ LPCSTR pszTitle) PURE;
	STDMETHOD(DoModal)(THIS) PURE;

	// This method actually creates the class.
	STDMETHOD(CreateClass)(THIS) PURE;

	// Error handling for during CreateClass.  We may need to call these
	// if we only called into ICreateClasses2 programatically.  (UI path
	// includes checking with the user in these situations and handling
	// problems that way)
	STDMETHOD(SetGuidFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetResFlags)(THIS_ UINT nFlags) PURE;

	// Information retrieval.
	STDMETHOD(GetName)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetBaseClass)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetFiles)(THIS_ LPSTR FAR* ppszHeader, LPSTR FAR* ppszImplementation) PURE;
	STDMETHOD(GetOLEOptions)(THIS_ UINT FAR* pnFlags, LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetDialogTemplate)(THIS_ LPSTR FAR* ppszDialogID) PURE;

	STDMETHOD(GetFormStrings)(THIS_ UINT nTypeForm, LPFORMSTRINGS *ppFormStrings) PURE;
};

// FORM String interface types (nTypeForm values in GetFormStrings)

#define FS_DIALOG_ID (1)
#define FS_BASE_CLASS (2)


// OLE Option flags
#define NC_OLE_NONE   (0)
#define NC_OLE_AUTO   (1)
#define NC_OLE_CREATE (2)
// UI flags
#define NC_ALLOW_EDIT    (0)
#define NC_DISALLOW_EDIT (1)
// Base class filters
#define NC_BASE_ALL   (0x0000)
#define NC_BASE_DOC   (0x0100)
#define NC_BASE_VIEW  (0x0200)
#define NC_BASE_FRAME (0x0400)
#define NC_BASE_DLG   (0x0800)
#define NC_BASE_CTRL  (0x1000)

// this one causes some classes to be added to the set which "ALL" doesn't include.
// ONLY SET THIS FLAG IF YOU ARE GOING TO BE USING ClassWizard UI WITH ICreateClasses.
// The database source won't get setup properly if you don't let ClassWizard handle
// the UI.
#define NC_BASE_ADD_DB_CLASSES	(0x2000)

// Error response flags
#define NC_USE_EXISTING_GUID   (1)
#define NC_CREATE_NEW_GUID     (2)
#define NC_USE_RES_ASIS        (3)
#define NC_USE_PLACEHOLDER_RES (4)

/////////////////////////////////////////////////////////////////////////////
// IExplainValues
//   This is an interface used by a client of the apply context, in order to
//   provide information to the user while editing the value map.

#undef  INTERFACE
#define INTERFACE IExplainValues
DECLARE_INTERFACE_(IExplainValues, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Validation methods
	STDMETHOD(ValidateValue)(THIS_ LPCSTR pszKey, LPCSTR pszNewValue) PURE;

	// Information methods.  The info returned by these methods
	// is used to populate the grid control in the value editor.
	STDMETHOD(GetValueInfo)(THIS_ LPCSTR pszKey, LPSTR FAR* ppszName, LPSTR FAR* ppszType, LPSTR FAR* ppszExtraInfo) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IEnumClasses
//   This is a simple interface to a list of classes.  It is used as a result
//   from some of the parser queries.

#undef  INTERFACE
#define INTERFACE IEnumClasses
DECLARE_INTERFACE_(IEnumClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnum style methods
	STDMETHOD(Next)(THIS_ ULONG celt, IExplainClasses FAR** rgelt, ULONG* pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumClasses** ppenum) PURE;

	// Custom search method.
	STDMETHOD(Find)(THIS_ LPCSTR pszClass, IExplainClasses FAR** ppec) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IExplainClasses
//   Use this interface to get details on a particular class.

#undef  INTERFACE
#define INTERFACE IExplainClasses
DECLARE_INTERFACE_(IExplainClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Class information methods.
	STDMETHOD(GetName)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetBaseClasses)(THIS_ LPSTR FAR* ppszParent) PURE;
	STDMETHOD(GetMembers)(THIS_ IEnumMembers FAR** ppem) PURE;
	STDMETHOD(Access)(THIS_ UINT nMode) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IEnumMembers
//   This is a simple interface on a list of members

#undef  INTERFACE
#define INTERFACE IEnumMembers
DECLARE_INTERFACE_(IEnumMembers, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnum style methods
	STDMETHOD(Next)(THIS_ ULONG celt, IExplainMembers FAR** rgelt, ULONG* pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumMembers** ppenum) PURE;

	// Custom search method.
	STDMETHOD(Find)(THIS_ LPCSTR pszMember, IExplainMembers FAR** ppem) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IExplainMembers
//   Use this interface to get details on a member

#undef  INTERFACE
#define INTERFACE IExplainMembers
DECLARE_INTERFACE_(IExplainMembers, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Member information methods.
	STDMETHOD(GetName)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetType)(THIS_ LPSTR FAR* ppszType) PURE;
	STDMETHOD(GetAccess)(THIS_ UINT FAR* pnAccess) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IExpandTemplates
//   This interface is used to interact with templates.

#undef  INTERFACE
#define INTERFACE IExpandTemplates
DECLARE_INTERFACE_(IExpandTemplates, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	STDMETHOD(Render)(THIS_ LPSTREAM lpStm, IApplyContext FAR* lpAC) PURE;
	STDMETHOD (RenderIntoFile) (THIS_ LPCTSTR szFileName, LPCTSTR szLang, DWORD dwHint, IApplyContext FAR * lpAC) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IComponentType
//   This interface is exposed by external components.

#undef  INTERFACE
#define INTERFACE IComponentType
DECLARE_INTERFACE_(IComponentType, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Component type methods.
	STDMETHOD(OnRegister)(THIS_ UINT nTypeID, LPCOMPONENTGALLERY lpcg) PURE;
	STDMETHOD(OnInitialRegister)(THIS) PURE;
	STDMETHOD(BltTypeGlyph)(THIS_ HDC hDC, int x, int y) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IImportComponents
//   This interface is exposed by external components.

#undef  INTERFACE
#define INTERFACE IImportComponents
DECLARE_INTERFACE_(IImportComponents, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Import methods.
	STDMETHOD(ImportFile)(THIS_ LPCSTR pszFilename, BOOL bCopyToGallery) PURE;
	STDMETHOD(GetFilterStrings)(THIS_ LPSTR FAR* ppszFilter) PURE;
	STDMETHOD(CanImportFile)(THIS_ LPCSTR pszFile) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IComponent
//   This interface is exposed by external components.

#undef  INTERFACE
#define INTERFACE IComponent
DECLARE_INTERFACE_(IComponent, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Component methods.
	STDMETHOD(GetTypeID)(THIS_ UINT FAR* pnTypeID) PURE;
	STDMETHOD(OnInsertComponent)(THIS_ LPAPPLYCONTEXT lpac) PURE;
	STDMETHOD(OnComponentHelp)(THIS) PURE;

	STDMETHOD(WriteState)(THIS_ LPSTREAM lpsr) PURE;
	STDMETHOD(ReadState)(THIS_ LPSTREAM lpsr) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IExplainComponents
//   This interface is exposed by external components.

#undef  INTERFACE
#define INTERFACE IExplainComponents
DECLARE_INTERFACE_(IExplainComponents, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Component information methods.
	STDMETHOD(GetCLSID)(THIS_ CLSID FAR* pClsID) PURE;
	STDMETHOD(GetStrings)(THIS_ LPSTR FAR* ppvTitle, LPSTR FAR* ppvDescription) PURE;
	STDMETHOD(GetIcon)(THIS_ HICON FAR* phIcon) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IComponentGallery
//   This interface is used to interact with the Gallery itself.

#undef  INTERFACE
#define INTERFACE IComponentGallery
DECLARE_INTERFACE_(IComponentGallery, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IComponentGallery methods
	STDMETHOD(GetGalleryLocation)(THIS_ LPSTR FAR* ppszPath) PURE;
	STDMETHOD(AddComponent)(THIS_ IComponent FAR* lpc, UINT nTypeID, LPCSTR pszCategory) PURE;
	STDMETHOD(CreateTemplate)(THIS_ LPSTREAM lpStm, IExpandTemplates FAR** ppvObj) PURE;
	STDMETHOD(CreateNewClass)(THIS_ ICreateClasses FAR** ppvObj) PURE;
	STDMETHOD(CheckVersion)(THIS_ UINT nMajor, UINT nMinor) PURE;
	STDMETHOD(CreateTemplateFromText)(THIS_ LPSTREAM lpStm, IExpandTemplates FAR** ppvObj) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// Version number:
#define GALLERY_VER_MAJ (0x0002)
#define GALLERY_VER_MIN (0x0000)


/////////////////////////////////////////////////////////////////////////////
// Result codes
#define CG_FAC (463)
#define CG_S(code) MAKE_HRESULT(SEVERITY_SUCCESS,CG_FAC,code)
#define CG_E(code) MAKE_HRESULT(SEVERITY_ERROR,CG_FAC,code)

#define CG_E_MEMBER_EXISTS      CG_E(50)
#define CG_E_MEMBER_CONFLICTS   CG_E(51)
#define CG_E_MEMBER_NOT_FOUND   CG_E(52)

#define CG_E_PARSE_MISMATCH_PARENT  CG_E(53)
#define CG_E_PARSE_NO_TEMPLATE_DEFN CG_E(54)
#define CG_E_PARSE_NO_DEFN          CG_E(55)
#define CG_E_PARSE_MULTI_LINE       CG_E(56)
#define CG_E_PARSE_INVALID_TOKEN    CG_E(57)
#define CG_E_PARSE_NO_LEXER         CG_E(58)
#define CG_E_PARSE_EMPTY_STREAM     CG_E(59)
#define CG_E_PARSE_MISMATCH_BRACKET CG_E(60)
#define CG_E_PARSE_UNEXPECTED_EOL   CG_E(61)
#define CG_E_PARSE_EXTRA_TOKEN      CG_E(62)
#define CG_E_PARSE_CTOR_RET_TYPE    CG_E(63)
#define CG_E_PARSE_DUP_ACCESS_SPEC  CG_E(64)
#define CG_E_PARSE_INVALID_MODIFIER CG_E(65)
#define CG_E_PARSE_MACROERROR       CG_E(66)
#define CG_E_PARSE_PARAM_COUNT_MISMATCH CG_E(67)

#define CG_E_NO_FILE						 CG_E(100)

#define CG_E_CREATECLASS_NO_CLASSNAME        CG_E(200)
#define CG_E_CREATECLASS_RESERVED_CLASSNAME  CG_E(201)
#define CG_E_CREATECLASS_EXISTING_CLASSNAME  CG_E(202)
#define CG_E_CREATECLASS_NO_HEADERFILE       CG_E(203)
#define CG_E_CREATECLASS_CREATE_HEADERFILE   CG_E(204)
#define CG_E_CREATECLASS_NO_IMPLFILE         CG_E(205)      
#define CG_E_CREATECLASS_CREATE_IMPLFILE     CG_E(206)
#define CG_E_CREATECLASS_WRITE_FILES         CG_E(207)
#define CG_E_CREATECLASS_INVALID_FILES       CG_E(208)
#define CG_E_CREATECLASS_NO_BASECLASS        CG_E(209)
#define CG_E_CREATECLASS_UNKNOWN_BASECLASS   CG_E(210)
#define CG_E_CREATECLASS_GUID_EXISTS         CG_E(211)
#define CG_E_CREATECLASS_CLASS_EXISTS        CG_E(212)
#define CG_E_CREATECLASS_DUP_RES             CG_E(213)
#define CG_E_CREATECLASS_INVALID_RES         CG_E(214)
#define CG_E_CREATECLASS_BLANK_RES           CG_E(215)
#define CG_E_CREATECLASS_QUOTED_RES          CG_E(216)
#define CG_E_CREATECLASS_NO_CLASSWIZINFO     CG_E(217)
#define CG_E_CREATECLASS_COCREATEGUID_FAILED CG_E(218)
#define CG_E_CREATECLASS_NEED_RECSET         CG_E(219)


/////////////////////////////////////////////////////////////////////////////
// IFormStrings
//   This interface provides access to generic lists of New Form string data.

#undef  INTERFACE
#define INTERFACE IFormStrings
DECLARE_INTERFACE_(IFormStrings, IUnknown)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
 	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

	// IFormStrings methods
	STDMETHOD(_NewEnum)(IEnumVARIANT **ppenum) PURE;
};


#endif // __OGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\msgboxes.h ===
/* MsgBoxes.h
 *
 * Purpose:	Specification file for the Dolphin WADG compliant message box 
 *			interface.
 *
 * Created:	22 July 1993 -by- Andrew Milton [w-amilt]
 *
 * Notes:	To ensure WADG compliance,  all message boxes in Dolphin must be 
 *			posted with some flavour of the MsgBox() function or one of its 
 *			derivatives [InformationBox(), QuestionBox(), ErrorBox()].  
 *			The message	text it contains should be formatted using one of the  
 *			MsgText() functions.  
 *
 *			The essential points we're trying to ensure here are avoiding 
 *			focus-theft from other applications and the three-line COMMDLG
 *			format for file errors.
 *
 *			Through the magic of enum's and overloading, a wide variety of 
 *			options are available for message posting and formatting.
 *
 *			Five message box types are currently available, defined by the
 *			enum MsgBoxTypes:  Information, Question, Error, InternalError, 
 *			and FatalError.  All forms of the MsgBox() function take a 
 *			MsgBoxTypes as the first parameter.  The default style for each
 *			type of message box is:
 *				Information		=>	MB_ICONINFORMATION	| MB_OK
 *				Question		=>	MB_ICONQUESTION		| MB_YESNOCANCEL
 *				Error			=>	MB_ICONEXCLAMATION	| MB_OK
 *				InternalError	=>	MB_ICONSTOP			| MB_OK
 *				FatalError		=>	MB_ICONSTOP			| MB_OK
 *			All message boxes use the MB_APPLMODAL mode.  Except for 
 *			InternalError and FatalError, message boxes are posted silently 
 *
 *			The button styles on the Question, Error and InternalError
 *			message box types may be overridden.  However, neither the
 *			icon nor the mode may be changed.  See the MsgBox() prototypes
 *			for more details.
 *
 *			InternalError and FatalError do special processing when raised.
 *				InternalError	=>	The error text is substituted into the 
 *									string "Internal Errror.  Please contact
 *									Microsoft Product Support Services (%s)"
 *									before it is displayed.
 *				FatalError		=>	Causes a panic shutdown of Dolphin.
 *
 *			The MsgBox() functions take either a string ID or a string 
 *			pointer for the the message text.  They do not allow variable 
 *			substitution into the message text.  The MsgText() family is 
 *			provided for substitions.  All return a LPCTSTR so that the call
 *			may be imbedded into a MsgBox() call, as in:
 *				MsgBox(Error,	
 *						MsgText(strBuffer, IDS_STRING_NOT_FOUND, pszToFind));
 *
 *			The MsgBox() functions also allow an F1 help context to be 
 *			passed as the last parameter.  The default is 'No help'.  If
 *			several message boxes are going to be displayed in a function 
 *			that use a common help context, then the default help can changed
 *			by delcaring a CLocalHelpContext object on the stack & passing
 *			the new default help context to the constructor.  The destructor
 *			will reset the help context when the object goes out of scope.
 *			Lastly, to get default buttond & set a help context, you can use 
 *			the DEFAULT_BUTTONS symbol, as in:
 *				MsgBox(Error,	
 *						MsgText(strBuffer, IDS_STRING_NOT_FOUND, pszToFind),
 *						DEFAULT_BUTTONS,
 *						helpFind);
 *
 *			Observe that all calls to LoadString() occur inline.  This 
 *			guarantees that if you have a local resource context set up, then
 *			MFC will look in the right place first for your string.
 *
 *			Lastly, the InformationBox(), QuestionBox() and ErrorBox() 
 *			functions are provided as convenience to the IDE.  They are 
 *			remnants of 'the old way' of doing message boxes.  If at all 
 *			possible, please avoid using these functions.  They're only
 *			inline wrappers to a MsgBox() and MsgText() call.
 *
 * Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
 ****************************************************************************/

#ifndef MSGBOXES_H
#define MSGBOXES_H

#include <tchar.h>
#include <stdarg.h>	// for var args stuff.
#include "path.h"

#define IDT_WINDOW_FLASH		101
#define DEFAULT_BUTTONS			((UINT) -1)
#define DEFAULT_HELP			((UINT) -1)
#define MAX_SUBSTITUTION_BYTES	1024

#ifndef _WIN32
#define LPCTSTR LPCSTR
#define LPTSTR LPSTR
#endif

/* WARNING!!!	WARNING!!!	WARNING!!!	 
 *
 * The following enum defines the available styles of message boxes.
 * If you add a message box style, then you MUST alter the three style arrays
 * g_rnIconStyles, g_rnButtonStyles, and  g_rfBeepOnMessage to reflect the 
 * change.
 */ 

#define NUMBER_OF_MESSAGE_BOXES 5

typedef enum tagMsgBoxTypes {
	Information		= 0, 
	Question		= 1, 
	Error			= 2, 
	InternalError	= 3, 
	FatalError		= 4
} MsgBoxTypes;

/* Function Prototypes ******************************************************/


extern void
InitMsgBoxes();	// Private to the message box implementation.  


/*************************** Interface Definition ***************************\
 MsgBox()

 Purpose:	To display a message box that conforms to the WADG.

 Returns:	The ID of the button pressed to dismiss the message.

 Notes:		- No mode or icon flags are allowed to be set for the message 
 			box by the calling function.  If any are slipped in with the 
			button options, then we ASSERT.
			- No button options are allowed with Information or FatalError
			message box types
			- If Dolphin is not active, then the IDE main frame is set into 
 			a flash state & the message box is suppressed until Dolphin 
 			becomes active. 
			- The displayed icon & default buttons are determined by the
			g_rnDefaultButtons[] and g_rnIconStyles[] arrays.  See the 
			WARNING!!! above.

			The first version of this function displays the string pointed 
			to by <pszMessage>.  The second version loads its message from 
			the resource table (inline), and then calls the first version to
			display the message.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/
 
int 
MsgBox(
	const MsgBoxTypes MsgBoxType, 
	LPCTSTR pszMessage,
	UINT nButtonIDs		= DEFAULT_BUTTONS,
	UINT nHelpContext	= DEFAULT_HELP);

inline int 
MsgBox(
	const MsgBoxTypes BoxType,
	const int nMessageID,
	UINT nButtonIDs		= DEFAULT_BUTTONS,
	UINT nHelpContext	= DEFAULT_HELP);

/*************************** Interface Definition ***************************\
 MsgText()

 Purpose:	To format text for display in a message box.  

 Returns:	Constant pointer to the formatted text.

 Notes:		Each version of this function requires a CString reference as its
 			first parameter.  This allows MsgText() to allocate buffer space
			on the heap for the formatted text with the assurance that the 
			buffer space will go away when the CString goes out of scope in 
			the calling function.  Why do we want to do this?  Well, it 
			guarantees that there will be enough space to store a message
			in the event that it changes length under translation to 
			different languages.  This way, we don't have to worry about
			buffer overruns on the stack (which can be unpleasant to isolate!)

			The first two versions of MsgText() corrospond with wsprintf()
			and wvsprintf() -- only the format string is loaded from the 
			resource table.

			The other two versions take a CFileException pointer & a CPath
			reference to construct a file error message.  The file error
			is formatted into three lines:

				<Name of the file>
				<Operation that failed>
				<Why it failed>

			This code is shamelessly based on code in <vres\mytlab.cpp>.

			The SubstituteBytes() function is reserved for use by the 
			message text routines.  It contains the common functionality for 
			the inline versions of MsgText().

			*IMPORTANT*

			The formatted text is stored in <strBuffer> AND returned by 
			MsgText().  If the same text is going to be used in several 
			message boxes, then  using the 	appropriate cast, <strBuffer> 
			can be reused in a later call to MsgBox().  ie:

			{
				CString strFooError;
				MsgBox(Error, MsgText(strFooError, IDS_FOO, cFooActions));

				// Stuff Happens to cause the same error 

				MsgBox(Error, (LPCTSR)strFooError);
			
			}

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline LPCTSTR
MsgText(
	CString &strBuffer,
	const int idsMsgFormat,
	...);

inline LPCTSTR
VMsgText(
	CString &strBuffer,
	const int idsMsgFormat,
	va_list VarArguments);

inline LPCTSTR
MsgText(
	CString &strBuffer,
	const CPath &pathOffendingFile,
	const int idsFileOperation,
	const CFileException *peOffence);

LPCTSTR
MsgText(
	CString &strBuffer,
	const CPath &pathOffendingFile,
	LPCTSTR pszFileOperation,
	const CFileException *peOffence);

LPCTSTR
SubstituteBytes(
	CString &strBuffer,
	LPCTSTR pszFormat,
	va_list VarArguments);	   // RESERVED.  Do not use.

/*************************** Interface Definition ***************************\
 InformationBox()
 QuestionBox()
 ErrorBox()

 Purpose:	Shortcut functions for the IDE's convenience.  Let's not be
 			using these, eh?

 Returns:	Information - Nada, Error - FALSE, Question - Button pressed.

 Notes:		Roughly speaking, we have <Foo>Box(ids, <stuff>) is the same as
 			MsgBox(<Foo>, MsgText(str, <stuff>))
			The exception is QuestionBox, which sets the available buttons.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

inline void
InformationBox(
	UINT idsMsgFormat,
	...);

inline int
QuestionBox(
	UINT idsMsgFormat,
	UINT nButtons,
	...);

inline BOOL
ErrorBox(
	UINT idsMsgFormat,
	...);

/*************************** Interface Definition ***************************\
 class CLocalHelpContext
 PushHelpContext()
 PopHelpContext()

 Purpose:	To set/reset the default message box F1-help context.
  
 Returns:	Push - Nada.  Pop - last help context

 Notes:		The push/pop functions should *not* be called directly.  The 
 			CLocalHelpContext constuctor/destructor call them to set up local
			help contexts, and using this class guarantees that help contexts
			will be reset at the end of a scope block.  See the comments at
			the top of the file for more details.

 Copyright (c) 1993 Microsoft Corporation.  All rights reserved.
\****************************************************************************/

void
PushHelpContext(             
	UINT nNewHelp);

UINT
PopHelpContext();

class CLocalHelpContext {
public:
	CLocalHelpContext(UINT nHelp) { PushHelpContext(nHelp);}
	~CLocalHelpContext() 		 { PopHelpContext();}
};

// Stolen out of the debugger headers for consistancy
void FAR PASCAL 
DebuggerMessage(
	MsgBoxTypes MsgType, 
	UINT idsErrorFormat,	
	LPSTR Msg,	
	int ShowType);

#include "msgboxes.inl"

/////////////////////////////////////////////////////////////////////////////
// CMessageBox dialog
//	Simulates a message box (by borrowing from Windows code)
//	but allows you to set your own buttons
//	Can either create an instance, and call DoModal(), 
//	or call the static DisplayMessageBox().

class CMessageBox : public CDialog
{
// Construction
public:
	CMessageBox(LPCSTR lpszText, LPCSTR lpszCaption, LPCSTR lpszButtons, 
		WORD wStyle, DWORD* pHelpIDs = NULL, CWnd* pParentWnd = NULL);
	~CMessageBox();

// Attributes
	CFont* m_pFont;
// Operations
	static int DoMessageBox(LPCSTR lpszText, LPCSTR lpszCaption, 
		LPCSTR lpszButtons, WORD wStyle, int nDef = 0, int nCancel = -1, 
		DWORD* pHelpIDs = NULL, CWnd* pParentWnd = NULL);

	void AddButton(CString& strButton) { m_strArray.Add(strButton);}
	void AddButtons(LPCSTR lpszButton);
	void SetCancel(int nCancel)
		{ ASSERT(nCancel < m_strArray.GetSize()); m_nCancel = nCancel;}
	void SetDefault(int nDef)
		{ ASSERT(nDef < m_strArray.GetSize()); m_nDefButton = nDef;}
	void FillInHeader(LPDLGTEMPLATE lpDlgTmp);

// Overridables
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual INT_PTR DoModal();

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() {return m_pHelpIDs;}
	DWORD* m_pHelpIDs;
	int m_nDefButton;
	int m_nCancel;
	HGLOBAL m_hDlgTmp;
	UINT m_nBaseID;
	WORD m_wStyle;
	CButton* m_pButtons;
	CStatic m_staticIcon;
	CStatic m_staticText;
	CString m_strCaption;
	CString m_strText;
	CStringArray m_strArray;
	CSize GetBaseUnits();
	LPCSTR GetIconID(WORD wFlags);
	void PositionControls();

	// Generated message map functions
	//{{AFX_MSG(CMessageBox)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////////
//	File Error support
//		note that file error codes where the high word is 0 are 
//		CFileException::m_cause codes.


enum
{
	ferrShellPackageFirst = MAKELONG(1000, 1),
	ferrCantSaveReadOnly,
	ferrCantSaveTempFiles,
	ferrIllformedFile,
};

int GetFileError();
void SetFileError(int nCause);
void FileErrorMessageBox(UINT idsOperation, LPCTSTR szFileName);

#endif	// MSGBOXES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\ogguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	OGGUID.H
//		Gallery interface IDs.

// Interface ID for IApplyContext.
// {D7260DF0-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IApplyContext, 
	0xd7260df0, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IManageValues.
// {D7260DF1-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IManageValues, 
	0xd7260df1, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IAddFiles.
// {D7260DF2-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IAddFiles, 
	0xd7260df2, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IAddResources.
// {D7260DF3-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IAddResources, 
	0xd7260df3, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IFindClasses.
// {D7260DF4-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IFindClasses, 
	0xd7260df4, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IWriteCode.
// {D7260DF5-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IWriteCode, 
	0xd7260df5, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for ICreateClasses.
// {F8EE5121-78F2-11ce-90FB-00AA005B435C}
DEFINE_GUID(IID_ICreateClasses, 
	0xf8ee5121, 0x78f2, 0x11ce, 0x90, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IExplainValues.
// {D7260DF5-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IExplainValues, 
	0xd7260df5, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IEnumClasses.
// {D7260DF6-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IEnumClasses, 
	0xd7260df6, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IExplainClasses.
// {D7260DF7-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IExplainClasses, 
	0xd7260df7, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IEnumMembers.
// {D7260DF8-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IEnumMembers, 
	0xd7260df8, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IExplainMembers.
// {D7260DF9-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IExplainMembers, 
	0xd7260df9, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IExpandTemplates.
// {D7260DFA-5F3B-11ce-90E2-00AA005B435C}
DEFINE_GUID(IID_IExpandTemplates, 
	0xd7260dfa, 0x5f3b, 0x11ce, 0x90, 0xe2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IComponentType.
// {03F591A0-8000-11ce-90FB-00AA005B435C}
DEFINE_GUID(IID_IComponentType, 
	0x3f591a0, 0x8000, 0x11ce, 0x90, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IImportComponents.
// {03F591A1-8000-11ce-90FB-00AA005B435C}
DEFINE_GUID(IID_IImportComponents, 
	0x3f591a1, 0x8000, 0x11ce, 0x90, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IComponent.
// {03F591A2-8000-11ce-90FB-00AA005B435C}
DEFINE_GUID(IID_IComponent, 
	0x3f591a2, 0x8000, 0x11ce, 0x90, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IExplainComponents.
// {03F591A4-8000-11ce-90FB-00AA005B435C}
DEFINE_GUID(IID_IExplainComponents, 
	0x3f591a4, 0x8000, 0x11ce, 0x90, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IComponentGallery.
// {03F591A3-8000-11ce-90FB-00AA005B435C}
DEFINE_GUID(IID_IComponentGallery, 
	0x3f591a3, 0x8000, 0x11ce, 0x90, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x5c);

// Interface ID for IFormStrings
// {5AA7F921-BB06-11d0-A787-00A0C91BBEE1}
DEFINE_GUID(IID_IFormStrings, 
0x5aa7f921, 0xbb06, 0x11d0, 0xa7, 0x87, 0x0, 0xa0, 0xc9, 0x1b, 0xbe, 0xe1);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\parse.h ===
#pragma once

#include "lex.h"
#include "ncparex.h"
#include "vccolls.h"

#define PARSE_NOERROR				0
#define E_PARSE_MISMATCH_PARENT		1
#define E_PARSE_NO_TEMPLATE_DEFN	2
#define E_PARSE_NO_DEFN				3
#define E_PARSE_MULTI_LINE			4
#define E_PARSE_INVALID_TOKEN		5
#define E_PARSE_NO_LEXER			6
#define E_PARSE_EMPTY_STREAM		7
#define E_PARSE_MISMATCH_BRACKET	8
#define E_PARSE_UNEXPECTED_EOL		9
#define E_PARSE_EXTRA_TOKEN			10
#define E_PARSE_CTOR_RET_TYPE       11
#define E_PARSE_DUP_ACCESS_SPEC     12
#define E_PARSE_INVALID_MODIFIER    13
#define E_PARSE_MACROERROR			14
#define E_PARSE_PARAM_COUNT_MISMATCH 15

#define PARSE_TYP_FUNC			0x00000001
#define PARSE_TYP_VAR			0x00000002
#define PARSE_TYP_PURE			0x00000004
#define PARSE_TYP_STATIC		0x00000008
#define PARSE_TYP_VIRTUAL		0x00000010
#define PARSE_TYP_EXTERN		0x00000020
#define PARSE_TYP_INLINE		0x00000040
#define PARSE_TYP_CONSTFUNC		0x00000080
#define PARSE_TYP_MAPENTRY      0x00000100

//////////////////////////////////////////////////////////////
enum parsetype 
{
	functionType = 0x0001,
	classType = 0x0002,
	varType = 0x0004,
	templateType = 0x0008,
	typedefType = 0x0010,
	unionType = 0x0020,
	enumType = 0x0040,
	structType = 0x0080,
	fileType = 0x0100,
	msgmapType = 0x0200,
	mapitemType = 0x0400,
	unknownType = 0x0800,
};

enum decldefn
{
	decl,
	defn
};

enum Action
{
	noOperation = -1, //REVIEW: to be compatible with old enum
	initFile,	
	addFile,		
	updateFile,
	delFile,
	initDone,
	reparseTarget,
	updateFileFromBuffer,
	forceReparse,
	squigglyInfo,
	includeFileParse,
    refParse,
    addOpenStore,
    delUnrefMods,
    delTarget
};

class CParser
{
private :

	////////////////////////////////////////////////////////////////////////////////////		
	// this struct is used to set the ordering of include files based on line number
	//
	struct CLineInfo
	{
		USHORT m_index;
		LINE m_lineno;
	};

protected :

	////////////////////////////////////////////////////////////////////////////////////
	// used by qsort to sort CLineInfo
	////////////////////////////////////////////////////////////////////////////////////
	static int CompareLineNo(const void * elem1, const void * elem2);
	void rgIinstToStrList (IINST * rgIinst, ULONG cinst, CVCStringList & slIncl, NcbParseEx * pDBase);


public:	 
	CParser() {};
	~CParser() {};
	// initialize parser w/ specific filename
	// or should it be a pointer to a Doc ?
	virtual BOOL Init (LPCSTR szFilename, void * pTextDocs) PURE;
	virtual BOOL CanAutoComplete() PURE;
	// parsing the file we just opened
	virtual BOOL Parse (LPCSTR szFilename, void * pTextDoc, Action action, HTARGET hTarget, CLex * lexer, BOOL fComPlus, const WCHAR *wszIncDirsAddtl, NcbParse * pDBase, 
		BOOL bParseIncludeFiles, BOOL bPrjSource, BOOL & bSuspendThread) PURE;
	virtual BOOL ParseForAutoComplete (void *pACInfo, BscEx* pDBase) PURE;
	virtual BOOL ParseFunction (CLex * pLex, LPCSTR ptchLine, UINT cbLine, PLXS plxs, CVCStringList & slFunc) PURE;
	virtual BOOL ParseFunction (CLex * pLex, LPCSTR ptchLine, UINT cbLine, PLXS plxs, CVCStringList & slFunc, BOOL & bFunction) PURE;
	virtual UINT ParseFunction (CLex * pLex, LPCSTR ptchLine, UINT cbLine, PLXS plxs, CVCStringList & slFunc, DWORD & dwFlags, UINT & iPos) PURE;
	// closing the file
	virtual void Close() PURE;
	// loading the macros
	// virtual LoadMacros (LPCSTR pszFile) PURE;
	virtual CParser * Duplicate() PURE;
	virtual void Release() PURE;


protected:
	BOOL BeforeUpdate(IMOD imod, NcbParseEx *pDBase);
	BOOL AfterUpdate(IMOD imod, NcbParseEx *pDBase, BOOL *pfIncludesChanged);
};

typedef DWORD	PARSETYPE;

struct ParseInfo
{
public:
	ATR32		m_atr;
	TYP			m_typ;
	BOOL		m_bIsDefinition;
	CString		m_strName	;
	CString		m_strType	;
	CString		m_strParam	;
	int			m_iNumParam ;
	int			m_iLineStart;
	int			m_iLineEnd	;
	CString		m_strFilename;
};


struct TokenInfo
{
	UINT		m_tok;
	CString		m_strToken;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\pkgapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	PKGAPI.H
//		Sample package interface declarations.

#ifndef __PKGAPI_H__
#define __PKGAPI_H__

interface IExample;

typedef IExample* LPEXAMPLE;

/////////////////////////////////////////////////////////////////////////////
// IExample

#undef  INTERFACE
#define INTERFACE IExample
DECLARE_INTERFACE_(IExample, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IExample methods

	STDMETHOD(IsAvailable)(VOID) PURE;
	STDMETHOD(SetAvailable)(BOOL bAvailable) PURE;
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __PKGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\prjapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	PRJAPI.H
//		Project package interface declarations.

#pragma once
#include "vcpkg.h"

__interface IProjectWorkspaceWindow;

typedef IProjectWorkspaceWindow* LPPROJECTWORKSPACEWINDOW;

class CDefProvidedNode;
class CStateSaver;

// These interfaces are used by the build system, class view, and information
// presentation to interact with the project and global workspace windows.

HRESULT CreateClassWinPackageComponent(IVCPackageComponent **ppVCPkgComp);

////////////////////////////////////////////////////////////////////////////
// IProjectWorkspaceWindow

__interface __declspec(uuid("{AD8B7E82-8DA6-11cf-8FB8-00A0C903494F}")) IProjectWorkspaceWindow : public IUnknown
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IProjectWorkspaceWindow methods
	STDMETHOD(AddRootProvidedNode)(CDefProvidedNode *pProvidedNode,	CSlob* pAddSlob) PURE; 	// Non-standard COM.
	STDMETHOD(RemoveSlob)(CSlob *pRemoveSlob, BOOL fRemovePaneIfEmpty) PURE; 	// Non-standard COM.
	STDMETHOD(ActivateContainingPane)(CSlob *pContainedSlob, BOOL bEnsureVisible, BOOL bSetFocusUpon) PURE; 	// Non-standard COM.
	STDMETHOD(FreezeContainingPane)(CSlob *pContainedSlob) PURE; 	// Non-standard COM.
	STDMETHOD(ThawContainingPane)(CSlob *pContainedSlob) PURE; 	// Non-standard COM.
	STDMETHOD(SelectSlob)(CSlob *pSelectSlob, BOOL bClearSelection) PURE; 	// Non-standard COM.
	STDMETHOD(DeselectSlob)(CSlob *pDeselectSlob) PURE; 	// Non-standard COM.
	STDMETHOD(ExpandSlob)(CSlob *pExpandSlob, BOOL bExpandFully) PURE; 	// Non-standard COM.
	STDMETHOD(CollapseSlob)(CSlob *pCollapseSlob) PURE; 	// Non-standard COM.
	STDMETHOD(RefreshSlob)(CSlob *pRefreshSlob) PURE; 	// Non-standard COM.
	STDMETHOD(ScrollSlobIntoView)(CSlob *pViewSlob, BOOL bScrollToTop) PURE; 	// Non-standard COM.
	STDMETHOD(GetVerbPosition)(UINT *pu) PURE;
	STDMETHOD(GetSelectedSlob)(CMultiSlob **ppSlob) PURE; 	// Non-standard COM.
	STDMETHOD(GetSelectedItems)(CMultiSlob *pSlob) PURE;	// Non-standard COM.
	STDMETHOD(IsWindowActive)(VOID) PURE;
	STDMETHOD(IsContainingPaneActive)(CSlob *pContainedSlob) PURE; 	// Non-standard COM.
	STDMETHOD(IsWindowLocked)(VOID) PURE;
	STDMETHOD(PreModalWindow)(VOID) PURE;
	STDMETHOD(PostModalWindow)(VOID) PURE;
	STDMETHOD(BeginUndo)(UINT nID) PURE;
	STDMETHOD(EndUndo)(VOID) PURE;
	STDMETHOD(FlushUndo)(VOID) PURE;
	STDMETHOD(CreateDragger)(CSlobDraggerEx** ppDragger) PURE; 	// Non-standard COM.
	STDMETHOD(GetSlobFromPoint)(POINT *ppt, CSlob **ppSlob) PURE;
	STDMETHOD(GetCurrentSlobRect)(RECT *prt) PURE;
	STDMETHOD(GetSlobRect)(CSlob * pSlob, RECT * prt);
	STDMETHOD(GetSelectedIDispatch)(UINT * piCount, IUnknown *** prgpIDispatch);
};

IProjectWorkspaceWindow *GetIProjectWorkspaceWindow();

/////////////////////////////////////////////////////////////////////////////
//	IPkgDropDataSource interface
//	Use this interface for OLE based project drag drop
#undef  INTERFACE
#define INTERFACE IPkgDropDataSource

DECLARE_INTERFACE_(IPkgDropDataSource, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (void) PURE;
	STDMETHOD_(ULONG,Release) (void) PURE;

	// Data Provider methods for Drop Sources
	STDMETHOD(GetDropInfo) (DWORD *pdwOKEffects, 
							IDataObject **ppDataObject, IDropSource **pDropSource) PURE;
	STDMETHOD(OnDropNotify) (BOOL fDropped, DWORD dwEffects) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IPkgDropDataTarget interface
//	Use this interface for OLE based project drag drop
#undef  INTERFACE
#define INTERFACE IPkgDropDataTarget

DECLARE_INTERFACE_(IPkgDropDataTarget, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (void) PURE;
	STDMETHOD_(ULONG,Release) (void) PURE;

	// Data Provider methods for Drop Target
	STDMETHOD(OnDragEnter)(IDataObject *pDataObj, 
							DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) PURE;
	STDMETHOD(OnDragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) PURE;
	STDMETHOD(OnDragLeave)(void) PURE;
	STDMETHOD(OnDrop)(IDataObject *pDataObj, 
							DWORD grfKeyState, POINTL pt,DWORD *pdwEffect) PURE;
};
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\resapi.h ===
/////////////////////////////////////////////////////////////////////////////
//  RESAPI.H
//      Resource package interface declarations.

#ifndef __RESAPI_H__
#define __RESAPI_H__

#include "bldtypes.h"

#include "resservice.h"

interface IResourceIntl;
interface IControlList;
interface IResObject;
interface IExternalResPkg;
interface IExternalResDoc;
interface IExternalResView;
interface IResourceBrowserState;
interface IResourceEditorState;
interface IItemEditorInfo;
interface IBinaryResEditor;

typedef IResourceIntl* LPRESOURCEINTL;
typedef IControlList* LPCONTROLLIST;
typedef IResObject* LPRESOBJECT;
typedef IExternalResDoc* LPEXTERNALRESDOC;
typedef IExternalResView* LPEXTERNALRESVIEW;
typedef IResourceBrowserState* LPRESOURCEBROWSERSTATE;
typedef IResourceEditorState* LPRESOURCEEDITORSTATE;
typedef IItemEditorInfo* LPITEMEDITORINFO;
typedef IBinaryResEditor* LPBINARYRESEDITOR;

#define P_FrameTitle                128 // For resource editor frames

#ifdef LOCTOOLS
/////////////////////////////////////////////////////////////////////////////
//  IResourceIntl interface
//      Espresso access to resource package functionality.

#undef  INTERFACE
#define INTERFACE IResourceIntl

typedef BOOL (__stdcall* CANCLOSE_CALLBACK)(CFrameWnd * pFrame);

DECLARE_INTERFACE_(IResourceIntl, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IResourceIntl methods
    STDMETHOD(IntlSetMode)(THIS_ BOOL bMode) PURE;
    STDMETHOD(IntlEditResource)(THIS_ CVCFile* pFile, CObArray * pSlobs,
        CSlob** ppSelection, CPartDoc** ppDocument) PURE;   // Non-standard COM.
};
#endif

/////////////////////////////////////////////////////////////////////////////
//  IControlList interface
//      Feature gallery access to resource package OLE control list.

#undef  INTERFACE
#define INTERFACE IControlList

DECLARE_INTERFACE_(IControlList, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IControlList methods
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(AddControl)(THIS_ REFCLSID rClsID) PURE;
    STDMETHOD(RemoveControl)(THIS_ REFCLSID rClsID) PURE;
    STDMETHOD(GetControl)(THIS_ int iCtl, LPCLSID lpClsID) PURE;
};

/////////////////////////////////////////////////////////////////////////////
/*
struct SResHeader
{
//  SResHeader(): m_clsidEditor(NULL){};
    HCOMPOSITION m_hComp;       // handle for parent res file
    HRESOURCE    m_hRes;        // handle of resource object
    REFCLSID  m_clsidEditor;    // clsid of CPartTemplate to use
};
typedef SResHeader RESHEADER, * LPRESHEADER;
*/

enum    // flags for IResObject::OnUpdateCommandUI
{
    OUCUI_ENABLE = 0x1,
    OUCUI_CHECK = 0x2,
    OUCUI_RADIO = 0x3,
};

/////////////////////////////////////////////////////////////////////////////
//  IResPackage interface
//      Used by external resource editors to initiate communication with RES
//      package.  When RES package wants to initiate, use IExternalRes.

#undef  INTERFACE
#define INTERFACE IResPackage

DECLARE_INTERFACE_(IResPackage, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IMasterRes methods
};

/////////////////////////////////////////////////////////////////////////////
//  IResObject interface
//      Used by external resource editors to initiate communication with RES
//      package.  When RES package wants to initiate, use IExternalRes.

#undef  INTERFACE
#define INTERFACE IResObject

DECLARE_INTERFACE_(IResObject, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IMasterRes methods
    STDMETHOD(UpdateData)(THIS_ CVCFile* pFile) PURE;   // REVIEW: non-standard COM
    STDMETHOD(EditorClosed)(THIS) PURE;
    STDMETHOD(SetDirty)(THIS) PURE;

    STDMETHOD_(GPT, GetIntProp)(THIS_ int idProp, int& rn) PURE;    // REVIEW: non-standard COM
    STDMETHOD_(GPT, GetStrProp)(THIS_ int idProp, CString& rstr) PURE;  // REVIEW: non-standard COM
    STDMETHOD_(BOOL, SetIntProp)(THIS_ int idProp, int n) PURE;
    STDMETHOD_(BOOL, SetStrProp)(THIS_ int idProp, const CString& rstr) PURE;   // REVIEW: non-standard COM
    STDMETHOD(SetupPropertyGrid)(THIS_ ITrackSelection *pTrackSelection) PURE;
    STDMETHOD(SetupPropertyPages)(THIS_ BOOL bSetCaption) PURE;

    STDMETHOD(OnCommand)(THIS_ UINT idCmd) PURE;
    STDMETHOD(OnUpdateCommandUI)(THIS_ UINT idCmd, DWORD* pdwFlags) PURE;
    /*
    STDMETHOD(AddDependant)(THIS_ CSlob * pSlob) PURE;
    STDMETHOD(RemoveDependant)(THIS_ CSlob * pSlob) PURE;
    */
};

/////////////////////////////////////////////////////////////////////////////
//  IExternalResPkg interface
//      Used by CResObjects to create communication with external res
//      packages.

#undef  INTERFACE
#define INTERFACE IExternalResPkg

DECLARE_INTERFACE_(IExternalResPkg, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IExternalResPkg methods
    STDMETHOD_(LPEXTERNALRESDOC, OpenStream)(THIS_ REFCLSID clsidTemplate, 
        CVCFile* pFile, LPRESOBJECT pResObject) PURE;   // REVIEW: non-standard COM
    STDMETHOD_(LPEXTERNALRESDOC, NewResource)(THIS_ REFCLSID clsidTemplate, 
        LPRESOBJECT pResObject) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//  IExternalResDoc interface
//      Contained by CExternalResDoc in external resource editors.
//      A CResObject keeps a pointer to it when it is opened externally.

#undef  INTERFACE
#define INTERFACE IExternalResDoc

DECLARE_INTERFACE_(IExternalResDoc, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IExternalResDoc methods
    STDMETHOD(CloseEditor)(THIS_ BOOL bDoSave) PURE;
    STDMETHOD(SaveEditor)(THIS) PURE;
    STDMETHOD(UpdateStream)(THIS_ CVCFile* pFile) PURE; // REVIEW: non-standard COM
    STDMETHOD(NotifyPropChange)(THIS_ UINT idProp) PURE;
    STDMETHOD_(HWND,GetEditorView)(THIS) PURE;  // TODO: remove
    STDMETHOD(ActivateEditor)(THIS) PURE;
    STDMETHOD (Reload) (THIS_ CVCFile * pFile) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//  IExternalResView interface
//      Used to recognize external resource editors among the various MDI
//      children in the IDE.

#undef  INTERFACE
#define INTERFACE IExternalResView

DECLARE_INTERFACE_(IExternalResView, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IExternalResView methods
    STDMETHOD_(LPEXTERNALRESDOC, GetDocument)(THIS) PURE;
    STDMETHOD_(LPRESOBJECT, GetResObject)(THIS) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//  IResourceBrowserState interface
//      Used to determine the identity, selection state and other 
//      information about a resource browser.

#undef  INTERFACE
#define INTERFACE IResourceBrowserState

DECLARE_INTERFACE_(IResourceBrowserState, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Resource identification methods
    STDMETHOD_(int, GetFileName)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;

    // Dialog State methods
    STDMETHOD_(int, GetSelectionCount)(THIS) PURE;
    STDMETHOD(GetSelectedItem)(THIS_ int nItem, LPITEMEDITORINFO* ppEditor) PURE;
};


/////////////////////////////////////////////////////////////////////////////
//  IResourceEditorState interface
//      Used to determine the identity, selection state and other 
//      information about a resource editor.

#undef  INTERFACE
#define INTERFACE IResourceEditorState

DECLARE_INTERFACE_(IResourceEditorState, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Resource identification methods
    STDMETHOD_(int, GetFileName)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
    STDMETHOD_(int, GetResourceName)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
    STDMETHOD(GetResourceValue)(THIS_ WORD* pValue) PURE;
    STDMETHOD(GetResourceLanguage)(THIS_ WORD* pLanguage) PURE;
    STDMETHOD_(int, GetResourceCondition)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
    STDMETHOD_(int, GetResourceExternalFilename)(THIS_ 
        LPTSTR szBuffer, int cchBuffer) PURE;

    // Dialog State methods
    STDMETHOD_(int, GetSelectionCount)(THIS) PURE;
    STDMETHOD(GetSelectedItem)(THIS_ int nItem, LPITEMEDITORINFO* ppEditor) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//  IItemEditorInfo interface
//      Used to retreive information about a specific editor in any of a
//      variety of resource editors.
//      This interface is used for dialog controls (and the dialog itself),
//      menu items and popups, strings table strings, accelerators, 
//      toolbars buttons, resources in the resource browser tree, etc.

#undef  INTERFACE
#define INTERFACE IItemEditorInfo

DECLARE_INTERFACE_(IItemEditorInfo, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Resource identification methods
    STDMETHOD(GetResourceEditor)(THIS_ LPRESOURCEEDITORSTATE* ppResource) PURE;

    // Item info methods
    STDMETHOD_(int, GetClassName)(THIS_ LPTSTR szNameBuffer, int cchBuffer) PURE;
    STDMETHOD_(int, GetItemName)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
    STDMETHOD(GetItemValue)(THIS_ WORD* pValue) PURE;
    STDMETHOD_(int, GetItemCaption)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
    STDMETHOD_(int, GetClassType)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
    // IDEA: GetStyleBits and GetExStyleBits might be useful
};

/////////////////////////////////////////////////////////////////////////////
//  IBinaryResEditor interface
//      Used by CResObjects to create communication with the binary editor.

#undef  INTERFACE
#define INTERFACE IBinaryResEditor

DECLARE_INTERFACE_(IBinaryResEditor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IBinaryResEditor methods
    STDMETHOD(SetStream)(THIS_ CVCFile* pFile, LPRESOBJECT pResObject) PURE;
    STDMETHOD_(LPEXTERNALRESDOC, GetExternalResDoc)(THIS) PURE;
};

#endif  // __RESAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\prjguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	PRJGUID.H
//		Project package interface ids.


// Interface ID for IProjectWorkspace {AD8B7E81-8DA6-11cf-8FB8-00A0C903494F}
DEFINE_GUID(IID_IProjectWorkspace,
	0xad8b7e81, 0x8da6, 0x11cf, 0x8f, 0xb8, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x4f);

// Interface ID for IProjectWorkspaceWindow {AD8B7E82-8DA6-11cf-8FB8-00A0C903494F}
DEFINE_GUID(IID_IProjectWorkspaceWindow,
	0xad8b7e82, 0x8da6, 0x11cf, 0x8f, 0xb8, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x4f);

// Interface ID for SourceControlStatus {EE8F5FD1-185E-11cf-B24F-00AA0057AFF3}
DEFINE_GUID(IID_ISourceControlStatus,
	0xee8f5fd1, 0x185e, 0x11cf, 0xb2, 0x4f, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for SourceControl {EE8F5FD2-185E-11cf-B24F-00AA0057AFF3}
DEFINE_GUID(IID_ISourceControl,
	0xee8f5fd2, 0x185e, 0x11cf, 0xb2, 0x4f, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Class ID for project document {34866983-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_WorkspaceDocument, 
	0x34866983, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for package drag drop service {6CEFADB1-94BF-11cf-A405-00AA00C00940}
DEFINE_GUID(SID_SPkgDragDrop, 
0x6cefadb1, 0x94bf, 0x11cf, 0xa4, 0x5, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);

// Interface ID for IPkgDropDataSource {6CEFADB2-94BF-11cf-A405-00AA00C00940}
DEFINE_GUID(IID_IPkgDropDataSource,
0x6cefadb2, 0x94bf, 0x11cf, 0xa4, 0x5, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);

// Interface ID for IID_IPkgDropDataTarget {6CEFADB3-94BF-11cf-A405-00AA00C00940}
DEFINE_GUID(IID_IPkgDropDataTarget, 
0x6cefadb3, 0x94bf, 0x11cf, 0xa4, 0x5, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);

// Interface ID for IID_IPkgProject  {7E52B9C0-D13D-11cf-925A-00A0C9138C45}
DEFINE_GUID(IID_IPkgProject, 
0x7e52b9c0, 0xd13d, 0x11cf, 0x92, 0x5a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x45);

// Interface ID for IID_IPkgProjectProvider  {7E52B9D0-D13D-11cf-925A-00A0C9138C45}
DEFINE_GUID(IID_IPkgProjectProvider, 
0x7e52b9d0, 0xd13d, 0x11cf, 0x92, 0x5a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x45);

// Interface ID for IID_DBGProject {D593BCB0-1C73-11d0-9825-00A0C9034944}
DEFINE_GUID(IID_IDBGProject, 
0xd593bcb0, 0x1c73, 0x11d0, 0x98, 0x25, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x44);


// DispInterface
// {4109DFBF-E9B9-11D1-833B-00A0C91BC942}
DEFINE_GUID(IID_IDispWorkspace,
0x4109DFBFL,0xE9B9,0x11D1,0x83,0x3B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);

// {4109DFC0-E9B9-11D1-833B-00A0C91BC942}
DEFINE_GUID(CLSID_Workspace,
0x4109DFC0L,0xE9B9,0x11D1,0x83,0x3B,0x00,0xA0,0xC9,0x1B,0xC9,0x42);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\pkgguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	PKGGUID.H
//		Sample package interface ids.

// Interface ID for Example {1B2B9C71-2B7F-11cf-B252-00AA0057AFF3}
DEFINE_GUID(IID_IExample,
	0x1b2b9c71, 0x2b7f, 0x11cf, 0xb2, 0x52, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Class ID for example document {34866982-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_SimpleDocument, 
	0x34866982, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\propguid.h ===
// propguid.h


#pragma once
// for property browser.
// define these custom guids on a property for special effects


// GUID_PROPERTYRECURSE -- the property is an IDispatch and will become a parent node. It is expected that the interface have
// a DISPID_ENABLED property, which will be displayed as a bool.
// {BF7971D2-28BF-11d2-8314-0000F8076314}
extern "C" const __declspec(selectany) GUID GUID_PROPERTYRECURSE = {0xBF7971D2L,0x28BF,0x11D2, { 0x83,0x14,0x00,0x00,0xF8,0x07,0x63,0x14 } };

// GUID_PROPERTYPOPULARITY -- the property is considered the rank in popularity of a property. This is for quick filtering in the property grid.
//                            highest rank is 0. Common have a value < 256. Esoteric have value > 256. Set this in idl similar to:
//                            [custom(GUID_PROPERTYPOPULARITY, 32)]
// {08315133-3C6C-11D2-8CED-00C04F8EEA30}
extern "C" const __declspec(selectany) GUID GUID_PROPERTYPOPULARITY = {0x08315133L,0x3C6C,0x11D2, { 0x8C,0xED,0x00,0xC0,0x4F,0x8E,0xEA,0x30 }};

// GUID_PROPERTYITALICS -- the property's tag is to be shown in italics
// {08315134-3C6C-11D2-8CED-00C04F8EEA30}
extern "C" const __declspec(selectany) GUID GUID_PROPERTYITALICS = {0x08315134L,0x3C6C,0x11D2, { 0x8C,0xED,0x00,0xC0,0x4F,0x8E,0xEA,0x30 }};

// GUID_PROPERTYBOLD -- the property's tag is to be shown in bold
// {08315135-3C6C-11D2-8CED-00C04F8EEA30}
extern "C" const __declspec(selectany) GUID GUID_PROPERTYBOLD = {0x08315135L,0x3C6C,0x11D2, { 0x8C,0xED,0x00,0xC0,0x4F,0x8E,0xEA,0x30 }};

// GUID_PROPERTYINDENTSIZE -- the property's tag is to be shown indented by the specified amount. 
//							[custom(GUID_PROPERTYINDENTSIZE, 4)]  // indent property tag by 4. Default is 0.
// {08315136-3C6C-11D2-8CED-00C04F8EEA30}
extern "C" const __declspec(selectany) GUID GUID_PROPERTYINDENTSIZE = {0x08315136L,0x3C6C,0x11D2, { 0x8C,0xED,0x00,0xC0,0x4F,0x8E,0xEA,0x30 }};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\posdata.h ===
////////////////////////////////////////////////////////////////////////////////
// POSDATA.H

#pragma once

#define MAX_POS_LINE_LEN    2046    // One less to distinguish from -1
#define MAX_POS_LINE        2097151 //  "   "    "    "         "

////////////////////////////////////////////////////////////////////////////////
// POSDATA
//
// This miniscule class holds line and character index data IN 32 BITS and also
// provides conversion to unsigned long (DWORD) for comparison functions.
// POSDATA's can be compared in stream-oriented fashion, since they always
// represent a single character in the stream.

struct POSDATA
{
    union
    {
        struct
        {
            // iChar being first makes it the least significant set of bits
            unsigned long   iChar:11;       // 2047 characters per line max
            unsigned long   iLine:21;       // 2097152 lines per file max
        };

        unsigned long   dwPos;
    };

    POSDATA () {}
    POSDATA (long i) : dwPos(0xffffffff) { }
    POSDATA (const POSDATA &p) { dwPos = p.dwPos; }
    POSDATA (long i, long c) : iLine(i), iChar(c) {}
    //operator DWORD () { return dwPos; }
    BOOL    operator < (const POSDATA &p) const { return dwPos < p.dwPos; }
    BOOL    operator > (const POSDATA &p) const { return dwPos > p.dwPos; }
    BOOL    operator <= (const POSDATA &p) const { return dwPos <= p.dwPos; }
    BOOL    operator >= (const POSDATA &p) const { return dwPos >= p.dwPos; }
    BOOL    operator == (const POSDATA &p) const { return dwPos == p.dwPos; }
    BOOL    operator != (const POSDATA &p) const { return dwPos != p.dwPos; }

    POSDATA & operator = (DWORD dw) { dwPos = dw; return *this; }
    void    SetEmpty () { dwPos = 0xFFFFFFFF; }
    BOOL    IsEmpty () { return dwPos == 0xFFFFFFFF; }

    friend POSDATA operator - (POSDATA p, unsigned long i);
    friend POSDATA operator + (POSDATA p, unsigned long i);
    friend long    operator - (POSDATA p1, POSDATA p2);
    friend long    operator + (POSDATA p1, POSDATA p2);
};

inline  POSDATA operator - (POSDATA p, unsigned long i) { /*ASSERT (p.iChar > i);*/ POSDATA pr; pr.dwPos = p.dwPos - i; return pr; }
inline  POSDATA operator + (POSDATA p, unsigned long i) {/* ASSERT (p.iChar + i <= MAX_POS_LINE_LEN);*/ POSDATA pr; pr.dwPos = p.dwPos + i; return pr; }
inline  long    operator - (POSDATA p1, POSDATA p2) { /*ASSERT (p1.iLine == p2.iLine); ASSERT (p1.iChar >= p2.iChar);*/ return (long)(p1.dwPos - p2.dwPos); }
inline  long    operator + (POSDATA p1, POSDATA p2) { /*ASSERT (FALSE);*/ return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\resource.h ===
// this a stub for the actual resource file existing
// in the vc pkg
//

#include "..\vcpkg\ui\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\resguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	RESGUID.H
//		Resource package interface ids.

//	Interface ID for resource I/O.
DEFINE_GUID(IID_IResourceIO,
	0xA89AEB01,0x52E0,0x11CE,0xBF,0x46,0x00,0xAA,0x00,0x4C,0x12,0xE2);

//	Interface ID for control list.
DEFINE_GUID(IID_IControlList, 
	0xb16cd900, 0x632a, 0x11ce, 0x86, 0xcd, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x5c);

#ifdef LOCTOOLS
//	Interface ID for resource localization.
DEFINE_GUID(IID_IResourceIntl,
	0xF52E90A1,0x596D,0x11CE,0xBF,0x46,0x00,0xAA,0x00,0x4C,0x12,0xE2);
#endif

// Class ID for RC file document {34866984-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_RCDocument, 
	0x34866984, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for resource template document {34866985-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_RCTDocument, 
	0x34866985, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for RES file document {34866986-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_RESDocument, 
	0x34866986, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for 16-bit EXE document {34866987-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_EXEDocument, 
	0x34866987, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for 32-bit EXE document {34866988-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_PEDocument, 
	0x34866988, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for binary document {34866989-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_BinaryDocument, 
	0x34866989, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for bitmap document {3486698A-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_BitmapDocument, 
	0x3486698a, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for icon document {3486698B-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_IconDocument, 
	0x3486698b, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for cursor document {3486698C-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_CursorDocument, 
	0x3486698c, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for toolbar document {3BC47C40-6AF8-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_ToolbarDocument, 
	0x3bc47c40, 0x6af8, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for dialog document {474A4B60-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_DialogDocument, 
	0x474a4b60, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for menu document {474A4B61-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_MenuDocument, 
	0x474a4b61, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for accelerator document {474A4B62-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_AccelDocument, 
0x474a4b62, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for stringtable document {474A4B63-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_StringDocument, 
0x474a4b63, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for version document {474A4B64-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_VersionDocument, 
0x474a4b64, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);


//	Interface ID for External resources packages
DEFINE_GUID(IID_IExternalResPkg,	// {452EADA1-5BBC-11cf-B254-00AA006C2A9A}
	0x452eada1, 0x5bbc, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for External resources documents
DEFINE_GUID(IID_IExternalResDoc,	// {452EADA2-5BBC-11cf-B254-00AA006C2A9A}
	0x452eada2, 0x5bbc, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for External resources frames
DEFINE_GUID(IID_IExternalResView,	// {452EADA3-5BBC-11cf-B254-00AA006C2A9A}
	0x452eada3, 0x5bbc, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for Internal CResObjects
DEFINE_GUID(IID_IResObject,			// {12068F00-5BBD-11cf-B254-00AA006C2A9A}
	0x12068f00, 0x5bbd, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for Resource View state information
DEFINE_GUID(IID_IResourceEditorState,	// {90125C00-AA58-11cf-B254-00AA006C2A9A}
	0x90125c00, 0xaa58, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for Resource View Item state information
DEFINE_GUID(IID_IItemEditorInfo,	// {90125C01-AA58-11cf-B254-00AA006C2A9A}
	0x90125c01, 0xaa58, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for Resource Browser state information
DEFINE_GUID(IID_IResourceBrowserState,	// {90125C02-AA58-11cf-B254-00AA006C2A9A}
	0x90125c02, 0xaa58, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//  Interface ID for binary resource editor
DEFINE_GUID(IID_IBinaryResEditor,   // {7B7EF34A-181E-4614-AC87-37F879C14F7C}
    0x7b7ef34a, 0x181e, 0x4614, 0xac, 0x87, 0x37, 0xf8, 0x79, 0xc1, 0x4f, 0x7c);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\restypes.h ===
#ifndef __RESTYPES_H__
#define __RESTYPES_H__
// #define for resource types as a word
// same as in windows.h but as words as opposed to lpstrs
//

#define W_RT_NEWRESOURCE    0x2000
#define W_RT_ERROR          0x7fff
#define W_RT_CURSOR         1
#define W_RT_BITMAP         2
#define W_RT_ICON           3
#define W_RT_MENU           4
#define W_RT_DIALOG         5
#define W_RT_STRING         6
#define W_RT_FONTDIR        7
#define W_RT_FONT           8
#define W_RT_ACCELERATOR    9
#define W_RT_RCDATA         10

// folowing are not in windows.h

#define W_RT_ERROR_TABLE    11
#define W_RT_GROUP_CURSOR   12
/* The value 13 is unused */
#define W_RT_GROUP_ICON     14
#define W_RT_NAME_TABLE     15 /* Name Tables no longer exist (made for 3.1) */
#define W_RT_VERSION        16

// new, from winuser.h
#define W_RT_PLUGPLAY       19
#define W_RT_VXD            20
#define W_RT_ANICURSOR		21
#define W_RT_ANIICON		22
#define W_RT_HTML			23
// app framework stuff

#define W_RT_DLGINIT			240
#define W_RT_TOOLBAR			241
#define W_RT_GROUP_STRING		255

// WAVE file stuff
#define SZ_RT_WAVE "WAVE"

// flags in a resource type object

#define RTT_NONE    0x0000
#define RTT_GROUP   0x0001      // is a group
#define RTT_IGNORE  0x0002      // don't display these
#define RTT_NONEW   0x0004      // can't new these
#define RTT_ONLYONE 0x0008      // make only one
#define RTT_NORCOUT 0x0010      // don't call OutputToRc for this one
#define RTT_MFCONLY 0x0020		// only allowed in Mfc mode Compositions

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\slobprop.h ===
#ifndef __SLOBPROP_H__
#define __SLOBPROP_H__

// This is used for inter-package slob property id

#define P_ResType				1025

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\shlapi_.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLAPI_.H
//		Private interfaces between shell and devaut1
//		(Other private interfaces implemented by the shell
//		are welcome.  Please, join the party.)

#ifndef __SHLAPI__H__
#define __SHLAPI__H__

/////////////////////////////////////////////////////////////////////////////
//	IAutomationItems interface.  This interface is implemented by
//   the shell, and is called exclusively by devaut1.pkg

// This structure is used to pass information from the shell to
//  devaut1 via IAutomationItems::GetAutomationItems.
#define MAX_LENGTH_NAMED_ITEM 64
struct CAutomationItem
{
	TCHAR m_szName[MAX_LENGTH_NAMED_ITEM];		// Name of named item
	GUID m_tlid;								// GUID of its type library
	GUID m_clsid;								// CLSID of its object
	WORD m_wMajorVersion;						// Major ver.# of typelib
	WORD m_wMinorVersion;						// Minor ver.# of typelib
};

#undef  INTERFACE
#define INTERFACE IAutomationItems

DECLARE_INTERFACE_(IAutomationItems, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IAutomationItems methods

	// The caller (aut1) allocates a *pdwNumItems-count array of CAutomationItem's
	//  in pAutomationItems.  The shell fills in the array with data it gathered
	//  when loading the packages and calling CPackage::GetApplicationExtensions
	//  for each package.  The callee (shell) fills in *pdwNumItems with the number
	//  of elements of the array it filled in.
	// If the caller passes NULL for pAutomationItems, the callee will leave that
	//  alone, and will fill in *pdwNumItems with the total number of items.
	//  The callee can use this to determine how much space to allocate for
	//  the next call to GetAutomationItems.
	STDMETHOD(GetAutomationItems)(CAutomationItem* pAutomationItems, DWORD* pdwNumItems) PURE;

	// Aut1 will call this for each CAutomationItem::m_szName it was passed by the shell
	//  during a previous call to GetAutomationItems.  This is called when VBS requests
	//  of devaut1 an IUnknown for a named item.
	STDMETHOD(GetIDispatch)(LPCTSTR szItemName, IDispatch** ppDispatch) PURE;
};


/////////////////////////////////////////////////////////////////////////////
//	IRecordNotifyShell interface.  This interface is implemented by
//   the shell, and is called exclusively by devaut1.pkg to inform the
//   the shell of state changes with the Macro Recorder.

#undef  INTERFACE
#define INTERFACE IRecordNotifyShell

DECLARE_INTERFACE_(IRecordNotifyShell, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IRecordNotifyShell methods
	STDMETHOD(OnStartRecord)(THIS) PURE;
	STDMETHOD(OnStopRecord)(THIS) PURE;
	STDMETHOD(OnPauseRecord)(THIS) PURE;
	STDMETHOD(OnResumeRecord)(THIS) PURE;
	STDMETHOD(SetShouldRecordText)(THIS_ BOOL bShouldRecordText) PURE;
};


#endif //__SHLAPI__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\resservice.h ===
#pragma once

#include "bldtypes.h"
#include "vcfileclasses.h"

//	GetDocLong enum
//		For use with resource template documents.

enum
{
	GDL_CMP_FIRST						= 1000,
	GDL_CMP_SAVE_AS_FILTER,
	GDL_CMP_SYMBOL_VALIDATION_CALLBACK,
	GDL_CMP_SUPPORT_EXTERNAL_FILES,
	GDL_CMP_USES_EXTERNAL_FILES,
	GDL_CMP_SUPPORT_MFC_MODE,
	GDL_CMP_USE_3D_CONTROLS,
};


#ifndef STRICT
typedef DWORD HCOMPOSITION;
typedef DWORD HCOMPIO;
typedef DWORD HRCIO;
typedef DWORD HRESIO;
typedef DWORD HRESOURCE;
#else	// STRICT
DECLARE_HANDLE(HCOMPOSITION);
DECLARE_HANDLE(HCOMPIO);
DECLARE_HANDLE(HRCIO);
DECLARE_HANDLE(HRESIO);
DECLARE_HANDLE(HRESOURCE);
#endif	// STRICT

interface IResourceIO;
interface IExternalResPkg;

typedef IExternalResPkg* LPEXTERNALRESPKG;

/////////////////////////////////////////////////////////////////////////////
//	IResourceIO interface
//		Feature gallery access to resource package I/O funtionality.

#undef  INTERFACE
#define INTERFACE IResourceIO

enum { NEWRESTYPE_RC, NEWRESTYPE_RCT, NEWRESTYPE_RES };
typedef BOOL (CALLBACK* SYMBOL_VALIDATION_CALLBACK)(LPCSTR szSymbol);

DECLARE_INTERFACE_(IResourceIO, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IResourceIO methods
	STDMETHOD(LoadCmpIO)(THIS_ CVCFile* pFile, HCOMPIO* phComp) PURE; 	// Non-standard COM.
	STDMETHOD(LoadRctFile)(THIS_ LPCSTR lpszPath, BOOL& bCloseIt, HRCIO* phComp) PURE;
	STDMETHOD(NewCmpIO)(THIS_ HCOMPIO* phComp) PURE;
	STDMETHOD(NewRctFile)(THIS_ HRCIO* phComp) PURE;
	STDMETHOD(SaveComp)(THIS_ HCOMPOSITION hComp, CVCFile* pFile) PURE; 	// Non-standard COM.
	STDMETHOD(SaveRctFile)(THIS_ HCOMPOSITION hComp, LPCSTR lpszPath) PURE;
	STDMETHOD(CloseComp)(THIS_ HCOMPOSITION hComp) PURE;
	STDMETHOD(NewUniqueSymbol)(THIS_ HCOMPOSITION hComp, LPCSTR szName,
		CString& rstrName, CString& rstrValue) PURE; 	// Non-standard COM.
	STDMETHOD(CloneIntoComp)(THIS_ HCOMPOSITION hSrc, HCOMPOSITION hDest,
		LPCSTR lpszType, LPCSTR lpszID, int nLangID, LPCSTR szCondition,
		LPCSTR szNewSymbol, LPCSTR szNewValue, int nNewLangID,
		LPCSTR szNewCondition) PURE;
	STDMETHOD(ImportIntoComp)(THIS_ HCOMPOSITION hDest, LPCTSTR szType, LPCTSTR szID, 
		LPCTSTR szValue, LPCTSTR szContents, int nLangID, LPCTSTR szCondition) PURE;
	STDMETHOD(DeleteItem)(THIS_ HCOMPOSITION hComp,
		LPCSTR lpszType, LPCSTR lpszID, int nLandID, LPCSTR lpszCondition) PURE;
	STDMETHOD(GetSymbolInclude)(THIS_ HRESIO hComp, CString& rStr) PURE; 	// Non-standard COM.
	STDMETHOD(NewString)(THIS_ HCOMPOSITION hComp, LPCSTR pszSymbol,
		LPCSTR szValue, int nLangID, LPCSTR pszString) PURE;
	STDMETHOD(ChangeItemSymbol)(THIS_ HCOMPOSITION hComp,
		LPCSTR lpszType, LPCSTR lpszID, int nLangID, LPCSTR lpszNewID, LPCSTR szValue) PURE;
	STDMETHOD(UpdateClassWizardInfo)(THIS_ LPCSTR lpszPath, BOOL bUpdateScope) PURE;
	STDMETHOD(RegisterExternalEditor)(THIS_ LPEXTERNALRESPKG pExtRes, 
		REFCLSID clsidEditor, LPCSTR szEditorName, LPCSTR szResType) PURE;
	STDMETHOD(OpenRcFile)(THIS_ LPCSTR lpszPath, HCOMPOSITION* phComp) PURE;
	STDMETHOD(OpenResource)(THIS_ HCOMPOSITION hComp, LPCTSTR szResType, 
		LPCTSTR szResName, long nLanguage, LPCTSTR szCondition) PURE;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\srcguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	SRCGUID.H
//		Source package interface ids.

//	Interface ID for source package
DEFINE_GUID(IID_ISourceQuery, 
	0xA8A111D0,0x54D7,0x11CE,0xA5,0x55,0x00,0xAA,0x00,0x42,0x54,0xC4);

//	Interface ID for source package editing
DEFINE_GUID(IID_ISourceEdit, 
	0xE831F200,0x54DA,0x11CE,0xA5,0x55,0x00,0xAA,0x00,0x42,0x54,0xC4);

// Interface ID for ParserDataBase {CCE64B71-1F6E-11cf-B24F-00AA0057AFF3}
DEFINE_GUID(IID_IParserDataBase,
	0xcce64b71, 0x1f6e, 0x11cf, 0xb2, 0x4f, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for EditDebugStatus {7161AE01-2901-11cf-B250-00AA0057AFF3}
DEFINE_GUID(IID_IEditDebugStatus, 
	0x7161ae01, 0x2901, 0x11cf, 0xb2, 0x50, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for ParserAssist {90D1AE81-29DC-11cf-B250-00AA0057AFF3}
DEFINE_GUID(IID_IParserAssist, 
	0x90d1ae81, 0x29dc, 0x11cf, 0xb2, 0x50, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for OutputWindow {1A26E5E1-2905-11cf-B250-00AA0057AFF3}
DEFINE_GUID(IID_IOutputWindow, 
	0x1a26e5e1, 0x2905, 0x11cf, 0xb2, 0x50, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for IFileAccess {51CF0451-4F97-11cf-B257-00AA0057AFF3}
DEFINE_GUID(IID_IFileAccess, 
	0x51cf0451, 0x4f97, 0x11cf, 0xb2, 0x57, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Class ID for text document {3486698D-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_TextDoc, // was CLSID_TextDocument
	0x3486698d, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for external text document {EF383AB0-4BF7-11d1-996F-00A0C91BC8E5}
DEFINE_GUID(CLSID_ExtTextDoc, 
0xef383ab0, 0x4bf7, 0x11d1, 0x99, 0x6f, 0x0, 0xa0, 0xc9, 0x1b, 0xc8, 0xe5);

// Class ID for browse document {3486698E-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_BrowseDocument, 
	0x3486698e, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Interface ID for lang/lexer based custom context menu
DEFINE_GUID(IID_ICustomContextMenu, 
0xe882e260, 0x709c, 0x11cf, 0x89, 0xc0, 0x0, 0xaa, 0x0, 0xbf, 0x5, 0x6);


#ifdef _SQLDBG

// Interface ID for SQL Execution control

DEFINE_GUID(IID_ISqlExec, 
0xfbca3ca2, 0x6abe, 0x11cf, 0x92, 0x81, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x10);

// Interface ID for debugging

DEFINE_GUID(IID_ISrcDebug, 
0x1c3d3480, 0x6ad9, 0x11cf, 0x92, 0x81, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x10);

#endif // _SQLDBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\squigapi.h ===
#ifndef __SQUIGAPI_H__
#define __SQUIGAPI_H__

// squigapi.h : header file
//

#define assert _ASSERT
#define dassert _ASSERT
#include <array_t.h>
#include <ParseErr.h>

#define WM_PARSER_COPYTOFILE	(WM_USER + 701)
#define WM_PARSER_SHOWSQUIGGLY	(WM_USER + 702)

struct CSItem {
	DWORD dwBeginLine;
	DWORD dwEndLine;
	WORD wBeginColumn;
	WORD wEndColumn;
	SZ   szErrId;
	SZ	 szErrTxt;
	SZ	 szFileName;
	DWORD dwFlags;
};

enum ARRAY_TYPE {ReadArray, WriteArray};
/////////////////////////////////////////////////////////////////////////////
// IVcCodeSense
//   This is an interface to maintain VC specific code sense information

#undef  INTERFACE
#define INTERFACE IVcCodeSense
DECLARE_INTERFACE_(IVcCodeSense, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)() PURE;
	STDMETHOD_(ULONG,Release)() PURE;
	STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj) PURE;
#endif

	// IVcCodeSense methods
	STDMETHOD(Add)(DWORD dwErrId, DWORD dwErrType, SZ szFileName,
					DWORD begLine, DWORD endLine, WORD begCol, WORD endCol, SZ szErrTxt) PURE;
	STDMETHOD(Clear) (ARRAY_TYPE) PURE;
	STDMETHOD(Refresh) () PURE;
	STDMETHOD(GetErrorCount) (DWORD *dwErrorCount) PURE;
	STDMETHOD(RetrieveErrorInfo) (Array<CSItem>& rgCSItems) PURE; 
};

/////////////////////////////////////////////////////////////////////////////

#endif //__SQUIGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\utilguid.h ===
// Interface ID for Source Utility Functions

DEFINE_GUID(IID_ISrcUtil,
	0x83a9f010, 0x60c5, 0x11cf, 0xa8, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x54);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\sharedmgrapi.h ===
#ifndef _SHAREDMGRAPI_H_
#define _SHAREDMGRAPI_H_

// This file contains the shared API information between the 'old' Wizard Model code manager
// and the 'new' Code Manager model intended to be DO support.

#include <cppsvc.h>
#include <bldtypes.h>

interface IDOStrings;		// handles lists of strings returned from various queries

// these interfaces help during the execution of a transaction
interface IDOExpandTemplates;	// used to expand templates into the project
interface IDOTemplateDictionary;	// dictionary used to help render template

interface IBscPersistentItem;	// PRIVATE in wizard model, used for thinly wrapping IINST info for DOs

// access flags
// NOTE: we are expecting the first four elements to be 0 - 4 as these values are being used
// for array indices.  DO NOT ADD THINGS IN THE MIDDLE WITHOUT CHECKING WHAT YOU HAVE AFFECTED.
#define dxWizAccessDontCare         (0)
#define dxWizAccessPublic           (1)
#define dxWizAccessProtected        (2)
#define dxWizAccessPrivate          (3)
#define dxWizAccessJavaProtected    (4)         // protected means something different in Java, we need a different glyph
#define dxWizAccessDefault          (5)

// file types and 'include' variations
#define dxWizDefinition			0x0001
#define dxWizDeclaration		0x0002
#define dxWizMemberDefinitions	0x0004	// file the members of a class are defined in (the .cpp for a class)
#define dxWizMemberDeclarations	0x0008	// file the members of a class are declared in (the .h for a class)
#define dxWizImport				0x0010	// it's an import
#define dxWizImportlib			0x0020	// it's an importlib
#define dxWizInclude			0x0040	// it's an include
#define dxWizProjectInclude		0x0100	// typically, stdafx.h
#define dxWizGlobalItem			0x0200	// use this to get the #include file for a global func or var 
#define dxWizFileInclude		0x0400	// use this to put an #include in a particular file
#define dxWizAllFileTypes		0x0FFF

// these flags are for determining scope for IDL/ODL import/importlib inclusion
// we need to be able to OR them with dxWizImport and dxWizImportlib
#define dxWizFileScope			0x1000	// it's at file scope (matters only for IDL/ODL)
#define dxWizLibraryScope		0x2000	// it's at library scope (matters only for IDL/ODL)
#define dxWizObjectScope		0x4000	// it's at the scope of whatever object we resolved the filename for

// file existence types
#define dxWizFileExist				0x00000001	// the file already exists
#define dxWizFileInProject			0x00000002	// the file is already in the project
#define dxWizFileInsertIface		0x00010000	// insert an interface appropriately into IDL/ODL
#define dxWizFileInsertCoclass		0x00020000	// insert a coclass appropriately into IDL/ODL
#define dxWizFileInsertDispIface	0x00040000	// insert a dispinterface appropriately into IDL/ODL

// location & hint types
#define dxWizHintNone			0x00000000	// no hint
#define dxWizFilePathDontCare	0x00000000	// yes, we want this to be default...
#define dxWizStart				0x00000001	// start of whatever it is
#define dxWizEnd				0x00000002	// end of whatever it is (end of prototype for comment)
#define dxWizHintCOM			0x00000004	// it's a COM thingie (like STDMETHOD)
#define dxWizHintLineNumber		0x00000008	// hint is a line number
#define dxWizFilePathAbsolute	0x00000100	// absolute path
#define dxWizFilePathRelative	0x00000200	// relative to project directory
#define dxWizFilePathSimple		0x00000400	// just the file name, no directories
#define dxWizName				0x00000800	// want the name of whatever it is
#define dxWizHintGlobalScope	0x00001000	// want the thing at global scope
#define dxWizHintCodeStart		0x00002000	// want start of file, below any #includes, etc.
#define dxWizDoIndents			0x00004000	// want the code we're inserting to be indented like auto-indent would do
#define dxWizClassWiz			0x00008000	// want whatever it is to be compatible with ClassWizard comments
#define dxWizHintFileName		0x00010000	// hint is the file name to use
#define dxWizHintIndex          0x00020000	// hint is an index number
#define dxWizHintUseSameLoc     0x00040000	// use the same location (for comment) as was used before
#define dxWizDuplicateOK        0x00080000  // allow something to duplicate something already present
#define dxWizIgnoreScope        0x00100000  // This is used to handle adding a function in interface::method format

// some basic types
#define dxWizNormal				0x00000000	// can be anything
#define dxWizVariable			0x00000100	// variable
#define dxWizFunction			0x00000200	// function
#define dxWizCoclass			0x00000400	// coclass
#define dxWizInterface			0x00000800	// interface
#define dxWizClass				0x00001000	// class
#define	dxWizTemplate			0x00002000	// it is ok for this thing to be a template
#define dxWizDispinterface		0x00004000	// dispinterface
#define dxWizLibrary			0x00008000	// library
#define dxWizEnum				0x00000001	// enum	-- never OR'ed with other type flags
#define dxWizTypedef			0x00000002	// typedef -- never OR'ed with other type flags
#define dxWizMap				0x00000003	// map -- never OR'ed with other type flags
#define dxWizMacro				0x00000004	// macro -- never OR'ed with other type flags
#define dxWizEnumItem           0x00000005  // enum item -- never OR'ed with other type flags
#define dxWizStruct             0x00000006  // struct -- never OR'ed with other type flags
#define dxWizUnion              0x00000007 // union -- never OR'ed with other type flags
#define dxWizConstant           0x00000008  // constant -- never OR'ed with other type flags
#define dxWizAttribute          0x00000009  // attribute -- never OR'ed with other type flags
#define dxWizBaseClass          0x0000000A  // base class -- never OR'ed with other type flags
#define dxWizParameter          0x0000000B  // parameter -- never OR'ed with other type flags
#define dxWizMapItem            0x0000000C  // map item -- never OR'ed with other type flags
#define dxWizNameSpace			0x0000000D	// name space -- never OR'ed with other type flags

// ActiveX association types
#define dxWizNothing			0x00000000	// current item has no association
	// need to be able to OR these types with dxWizFunction and dxWizVariable
#define dxWizProperty			0x00000001	// current item, variable or function, is actually a property
#define dxWizPropertyNotify		0x00000002	// current item is a property change notification function
#define dxWizMethod				0x00000004	// current item is a function

// generic association major types
#define dxWizActiveXMatch		0x00000010	// ActiveX assoc present
#define dxWizActiveXMissing		0x00000020	// would be present for ActiveX assoc if wasn't missing
#define dxWizActiveXNone		0x00000040	// not related to ActiveX assoc

// these are expected to be just barely smaller than the allowable range
#define dxWizModEndLine			-1					// last line of the module
#define dxWizDefEndLine			dxWizModEndLine-1	// last line of the definition
#define dxWizEndOfLine			-1					// last column of the line
#define dxWizDefBeginLine		dxWizDefEndLine-1	// first line of the definition (for func, mostly)

// file access types
#define dxWizModeRead			0	// read access
#define dxWizModeWrite			1	// read/write access

// symbol types
enum SymbolConflictType 
{ 
	eSymbolConflictNone,		// no conflicts whatsoever for this name
	eSymbolConflictInProject,	// this symbol exists in this project at this scope
	eSymbolConflictIntrinsic,	// this symbol is an intrinsic keyword (like 'int')
	eSymbolConflictMFCName		// this global symbol is the same as an MFC class name
};

// automation style enforced on members of the specified class
enum memberAutomationStyles 
{ 
	memAutoNone,				// not an automation class at all
	memAutoDispinterface,		// dispinterface
	memAutoInterfaceDual,		// dual interface
	memAutoInterfaceAutomation,	// interface with the automation attribute
	memAutoInterfaceObject,		// interface with the object attribute and not the local attribute
	memAutoInterfaceLocal		// interface with both object and local attributes
};

// Open flags for working with the rc file
#define dxWizOpenAlwaysRC   (0)
#define dxWizCreateNewRC    (1)
#define dxWizOpenExistingRC (2)

// short hand ways of specifying default projects/targets
#define dxWizAllProjects		(HPROJECT)-1
#define dxWizSelectedProject	(HPROJECT)NULL

// these exactly match the build system's Prop_UseOfMFC values
enum UseOfMFC { eMFCNone = 0, eMFCStaticLib = 1, eMFCDLL = 2 };		

/////////////////////////////////////////////////////////////////////////////
// IDOTemplateDictionary
//   This interface handles template creation including the generation of templates that
//	 use that dictionary.

#undef  INTERFACE
#define INTERFACE IDOTemplateDictionary
DECLARE_INTERFACE_(IDOTemplateDictionary, IDispatch)
{
	// value interaction
	STDMETHOD(GetValue)(BSTR bstrKey, BSTR* pbstrValue) PURE;
	STDMETHOD(SetValue)(BSTR bstrKey, BSTR bstrValue) PURE;	// can set new or reset existing
	STDMETHOD(RemoveValue)(BSTR bstrKey) PURE;
	STDMETHOD(ClearValues)() PURE;

	// template creation
	STDMETHOD(CreateTemplateFromFile)(BSTR bstrTemplateFile, IDOExpandTemplates** ppvObj) PURE;
	STDMETHOD(CreateTemplateFromString)(BSTR bstrTemplateString, IDOExpandTemplates** ppvObj) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IDOExpandTemplates
//   This interface is used to interact with templates.
//	NOTE: you can create one of these without a transaction, but you must have a transaction
//		in place to render one.

#undef  INTERFACE
#define INTERFACE IDOExpandTemplates
DECLARE_INTERFACE_(IDOExpandTemplates, IDispatch)
{
	STDMETHOD(RenderIntoFile)(BSTR bstrFileName, long nHint, DWORD iLine, DWORD iColumn, BSTR bstrTab) PURE;
	STDMETHOD(RenderIntoString)(BSTR bstrTab, BSTR* pbstrRenderedTemplate) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IDOStrings
//   This interface provides access to generic lists of Wizard or DO string data.

#undef  INTERFACE
#define INTERFACE IDOStrings
DECLARE_INTERFACE_(IDOStrings, IDispatch)
{
	STDMETHOD(_NewEnum)(IEnumVARIANT **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IBscPersistentItem
//	This interface is the extremely thin wrapper we put on IINST objects
//	to pass them from the code manager to the DOs.
//
//	It is also an interface that all items in a CBscCollection must support.
//
//	For 'old' style Wizard Model wizards, this can be considered a PRIVATE interface
//	inside the code manager.

#undef  INTERFACE
#define INTERFACE IBscPersistentItem
DECLARE_INTERFACE_(IBscPersistentItem, IDispatch)
{
	STDMETHOD(GetIinst)(DWORD *piinst) PURE;
	STDMETHOD(SetIinst)(DWORD iinst) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// Result codes
// WARNING: make sure you don't conflict numerically with errors in ogapi.h
// that mean something different than what we have here.
// Stay out of the 50 - 299 range unless the error really is the same as the
// one in ogapi.h.  (No note there about overlaps since ogapi.h can ship to ISVs.)
#define WIZ_FAC (463)
#define WIZ_S(code) MAKE_HRESULT(SEVERITY_SUCCESS,WIZ_FAC,code)
#define WIZ_E(code) MAKE_HRESULT(SEVERITY_ERROR,WIZ_FAC,code)

#define WIZ_S_CLASSWIZ_UNRECOGNIZED_AUTOMATION_TYPE  WIZ_S(3)
#define WIZ_S_AUTOMATION_FIXED_PARAM_LIST            WIZ_S(4)
#define WIZ_S_ACCESS_TYPE_NEEDED                     WIZ_S(5)	// insert location found, but desired access specifier needs to be added

#define WIZ_E_MEMBER_EXISTS      WIZ_E(50)
#define WIZ_E_MEMBER_CONFLICTS   WIZ_E(51)
#define WIZ_E_MEMBER_NOT_FOUND   WIZ_E(52)

#define WIZ_E_PARSE_MISMATCH_PARENT  WIZ_E(53)
#define WIZ_E_PARSE_NO_TEMPLATE_DEFN WIZ_E(54)
#define WIZ_E_PARSE_NO_DEFN          WIZ_E(55)
#define WIZ_E_PARSE_MULTI_LINE       WIZ_E(56)
#define WIZ_E_PARSE_INVALID_TOKEN    WIZ_E(57)
#define WIZ_E_PARSE_NO_LEXER         WIZ_E(58)
#define WIZ_E_PARSE_EMPTY_STREAM     WIZ_E(59)
#define WIZ_E_PARSE_MISMATCH_BRACKET WIZ_E(60)
#define WIZ_E_PARSE_UNEXPECTED_EOL   WIZ_E(61)
#define WIZ_E_PARSE_EXTRA_TOKEN      WIZ_E(62)
#define WIZ_E_PARSE_CTOR_RET_TYPE    WIZ_E(63)
#define WIZ_E_PARSE_DUP_ACCESS_SPEC  WIZ_E(64)
#define WIZ_E_PARSE_INVALID_MODIFIER WIZ_E(65)
#define WIZ_E_PARSE_MACROERROR       WIZ_E(66)

#define WIZ_E_PARAMETER_CONFLICTS    WIZ_E(67)
#define WIZ_E_DUP_BASE_CLASS		 WIZ_E(68)
#define WIZ_E_PARSE_PARAM_COUNT_MISMATCH WIZ_E(69)

#define WIZ_E_NO_FILE				 WIZ_E(100)
#define WIZ_E_FILE_READONLY			 WIZ_E(101)

#define WIZ_E_NO_TRANSACTION         WIZ_E(300)
#define WIZ_E_BODY_EXPECTED          WIZ_E(301)
#define WIZ_E_CLASS_NOT_FOUND        WIZ_E(302)
#define WIZ_E_NO_PARSE_DATA          WIZ_E(303)
#define WIZ_E_INVALID_PARSE_DATA     WIZ_E(304)
#define WIZ_E_ILLEGAL_OPERATION      WIZ_E(305)
#define WIZ_E_FUNCTION_EXPECTED      WIZ_E(306)
#define WIZ_E_NOT_FOUND              WIZ_E(307)
#define WIZ_E_PARENT_NOT_FOUND       WIZ_E(308)
#define WIZ_E_OUT_OF_RANGE           WIZ_E(309)
#define WIZ_E_INTERNAL_ERROR         WIZ_E(310)
#define WIZ_E_USER_CANCEL            WIZ_E(311)
#define WIZ_E_IMPL_FILE              WIZ_E(312)
#define WIZ_E_LEXER_NOT_INIT         WIZ_E(313)
#define WIZ_E_WIZARD_CANT_RUN        WIZ_E(314)
#define WIZ_E_NO_TARGET              WIZ_E(315)
#define WIZ_E_AMBIGUOUS_FLAGS        WIZ_E(316)
#define WIZ_E_CONFLICTS              WIZ_E(317)
#define WIZ_E_RETURN_TYPE_FIXED      WIZ_E(318)
#define WIZ_E_READ_ONLY_PROPERTY     WIZ_E(319)
#define WIZ_E_AMBIGUOUS              WIZ_E(320)
#define WIZ_E_TEMPLATE_ELEMENT_NOT_FOUND WIZ_E(350)
#define WIZ_E_TEMPLATE_INVALID_VALUE     WIZ_E(351)
#define WIZ_E_TEMPLATE_MISMATCHED_TOKENS WIZ_E(352)
#define WIZ_E_TEMPLATE_MISMATCHED_IF     WIZ_E(353)
#define WIZ_E_TEMPLATE_SYNTAX_ERR        WIZ_E(354)
#define WIZ_E_TEMPLATE_EMPTY_CONDITIONAL WIZ_E(355)
#define WIZ_E_TEMPLATE_LOOP_ERR          WIZ_E(356)
#define WIZ_E_TEMPLATE_EXTRA_END         WIZ_E(357)
#define WIZ_E_FUNC_NAME_FIXED        WIZ_E(400)
#define WIZ_E_FUNC_TYPE_FIXED        WIZ_E(401)
#define WIZ_E_PARAM_TYPES_FIXED      WIZ_E(402)
#define WIZ_E_NOT_AUTOMATION_TYPE    WIZ_E(403)
#define WIZ_E_INVALID_IDENTIFIER_NAME    WIZ_E(404)

#endif	// _SHAREDMGRAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\shlguid_.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLGUID_.H
//		Private interface between shell and devaut1

// {2F483CC0-CDE2-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IAutomationItems, 
0x2f483cc0, 0xcde2, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);

// {072169C0-D0FC-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IRecordNotifyShell, 
0x72169c0, 0xd0fc, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\utilapi.h ===
#ifndef __UTILAPI_H__
#define __UTILAPI_H__

interface ISrcUtil;

typedef ISrcUtil*   PSRCUTIL;

/////////////////////////////////////////////////////////////////////////////
//  ISrcUtil interface
//      Allow the new debugger package access to the general utility routines

#undef INTERFACE
#define INTERFACE ISrcUtil

// Source environment settings.
#define ENV_HSCROLL                     1
#define ENV_VSCROLL                     2
#define ENV_ENABLE_MARGIN_GLYPHS        3
#define ENV_CX_DEFAULT_SELECT_MARGIN    4
#define ENV_PROMPT_BEFORE_SAVE          5
#define ENV_ENABLE_AUTO_COMPLETE		6
#define ENV_ENABLE_AUTO_COMMENTS		7
#define ENV_ENABLE_QUICK_INFO			8
#define ENV_ENABLE_PARAMETER_HELP		9
#define ENV_ENABLE_SQUIGGLY				10
#define ENV_ENABLE_WARN					11
#define ENV_ENABLE_COMMENTS				12


// Source color settings
#define CLR_TEXT                        0
#define CLR_CURRENTLINE                 1
#define CLR_COMMENT                     2
#define CLR_BREAKPT                     3

// CTextDoc Callback values
#define DCB_CLOSE                       1

class CIDEView;

DECLARE_INTERFACE_(ISrcUtil, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	/*
	** ISrcUtil
	**
	*/

    STDMETHOD_(BOOL, RECompare)(LPSTR sz, PSTR szRE) PURE;
    
	STDMETHOD_(BOOL, StatusText)(UINT uID, UINT uType, BOOL fForceUpdate) PURE;

    STDMETHOD_(BOOL, HandleBuildStateChange)(void) PURE;
    STDMETHOD_(BOOL, HandleProjectStateChange)(void) PURE;
    STDMETHOD_(BOOL, DebuggeeStateModified)(void) PURE;
    STDMETHOD_(BOOL, ProjectStateModified)(void) PURE;
    STDMETHOD_(BOOL, ClearAllDocStatus)(UINT state) PURE;
    STDMETHOD_(BOOL, ResetProjectState)(void) PURE;
	STDMETHOD_(BOOL, InitProjectState)(void) PURE;

    STDMETHOD_(FMT_ELEMENT *, GetSourceColor)(UINT) PURE;

    STDMETHOD_(DWORD, GetSrcEnvironParam)(UINT) PURE;

    STDMETHOD_(BOOL, SetLineStatus)(CDocument *, LONG, UINT, UINT, BOOL, BOOL) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, FindLineStatus)(CDocument *, UINT, BOOL, LONG *) PURE; 	// Non-standard COM.
    STDMETHOD_(USHORT, GetLStat)(CDocument *, LONG) PURE; 	// Non-standard COM.

    STDMETHOD_(BOOL, GetCurrentText)(CView *, BOOL *, LPSTR, ULONG, ULONG *, ULONG *) PURE; 	// Non-standard COM.

    STDMETHOD_(BOOL, LoadDocument)(LPCSTR, FARPROC) PURE;
    STDMETHOD_(BOOL, FindDocument)(LPCSTR, CDocument **, BOOL) PURE; 	// Non-standard COM.
    STDMETHOD_(CView *, GetCurTextView)(void) PURE; 	// Non-standard COM.
    STDMETHOD_(CView *, FirstView)(CDocument *) PURE; 	// Non-standard COM.
    STDMETHOD_(CView *, FindTextDocActiveView)(CDocument *) PURE; 	// Non-standard COM.
    STDMETHOD_(CDocument *, GetDocFromHsf)(void *) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, Select)(CView *, INT, INT, BOOL) PURE; 	// Non-standard COM.
    
	STDMETHOD_(BOOL, ResetDocMod)(void) PURE;
    STDMETHOD_(void *, GetHSF)(CDocument *) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, SetHSF)(CDocument *, void *) PURE; 	// Non-standard COM.
    
	STDMETHOD_(BOOL, ViewBelongsToSrc)(CView *) PURE; 	// Non-standard COM.
    STDMETHOD_(INT, GetCurrentLine)(CView *) PURE; 	// Non-standard COM.
    STDMETHOD_(CDocument *, GetDocFromFileName)(PCSTR) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, ThingyForBFHFindDoc)(CDocument **, CPath &) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, ActivateTextDoc)(LPCSTR, INT) PURE;
	STDMETHOD(CreateSourceEditForHSF)(THIS_ void * hsf, ISourceEdit **ppISourceEdit) PURE;
	STDMETHOD(SetCallback)(THIS_ CDocument *, FARPROC) PURE;

	// This is used by the debugger to find non-disk based files
	// through the ISourceEdit::GetPseudoPath method
	STDMETHOD(CreateSourceEditFromDoc)(THIS_ CDocument* pDoc, ISourceEdit **ppISourceEdit, BOOL fWriteable) PURE;
	STDMETHOD(LoadNonDiskDocument)(LPCTSTR szName, CDocument** ppDoc) PURE;
	// TODO: this method should be replaced by one that is more general. [t-mashra]
    STDMETHOD(GetCurFontDimensions)(UINT &, UINT &) PURE; 	// Non-standard COM.

    // Edit-n-Continue support
    STDMETHOD_(BOOL, ENCStateModified)(void) PURE;
    STDMETHOD_(BOOL, GetSrcPathsForENC)(CStringList *plstPath) PURE; // Non-standard COM.

	// Identifier info for AutoCompletion/NCB
	STDMETHOD (CreateQuickInfoForIdentifier) (LPCOLESTR lpstrIdent) PURE;
};

#endif // __UTILAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\tokhtml.h ===
// tokhtml.h - Tokens and lex state for HTML
//
// Include lex.h before including this file.
//

#ifndef __TOKHTML_H__
#define __TOKHTML_H__

enum HtmlToken
{
    tokUNKNOWN = tokclsError,
    tokIDENTIFIER = tokclsIdentMin,     // identifier/plain text
    tokNEWLINE = tokclsUserMin,
	//
	// colored HTML items
	//
    tokElem,     // element name
    tokAttr,     // attribute name
	tokValue,    // attribute value
	tokComment,  // comment
    tokEntity,   // entity reference: e.g. "&nbsp;"
	tokTag,      // tag delimiter
	tokString,   // string
	tokSpace,    // whitespace and unrecognized text in a tag
	tokOp,       // operator
	tokSSS,      // server-side script <%...%>
	//
	// parsed HTML and SGML items - tokens folded with items above
	//
	tokName,     // NAMETOKEN
	tokNum,      // NUMTOKEN
	tokParEnt,   // parameter entity: e.g. "%name;"
	tokResName,  // reserved name
	//
	// operators - colors folded with tokOp above
	//
	tokOP_MIN,
	tokOpDash = tokOP_MIN,         // -
	tokOP_SINGLE,
	tokOpQuestion = tokOP_SINGLE,  // ?
	tokOpComma,                    // ,
	tokOpPipe,                     // |
	tokOpPlus,                     // +
	tokOpEqual,                    // =
	tokOpStar,                     // *
	tokOpAmp,                      // &
	tokOpCent,                     // %
	tokOpLP,                       // (
	tokOpRP,                       // )
	tokOpLB,                       // [
	tokOpRB,                       // ]
    tokOP_MAX,                     // token op MAX

    tokEOF
};

// the state of lexical analyser 
//
// We're generally in one of two states:
// 1.  scanning text
// 2.  scanning tag info
//
// Within these states, the lexer can be in several substates.
// 
// Text substates:
//
// 	inText       HTML text content -- process markup
//	inPLAINTEXT  after a <PLAINTEXT> tag - remainder of file is not HTML
//	inCOMMENT    COMMENT content -- suppress all markup but </COMMENT>
//               color text as comment
//	inXMP        XMP content -- suppress all markup but </XMP>
//	inLISTING    LISTING content -- suppress all markup but </LISTING>
//
// Tag substates:
//
// inTag       inside a tag < ... >
// inBangTag   inside an SGML MDO tag <! ... >
// inPITag     inside an SGML Prcessing Instruction tag <? ... >
// inHTXTag    inside an ODBC HTML Extension template tag <% ... %>
// inEndTag    inside an end tag </name>
// inAttribute expecting an attribute
// inValue     expecting an attribute value (right of =)
// inComment   inside a comment
// inString	   inside a " string, terminated by "
// inStringA   inside a ' (Alternate) string, terminated by '
//
enum HtmlLexState
{
	// tag types
	inTag        = 0x00000001, // <  ... >
	inBangTag    = 0x00000002, // <! ... >
	inPITag      = 0x00000004, // <? ... >
	inHTXTag     = 0x00000008, // <% ... %>
	inEndTag	 = 0x00000010, // </ ... >

	// tag scanning states
	inAttribute  = 0x00000020,
	inValue      = 0x00000040,
	
	inComment    = 0x00000080,
	inString     = 0x00000100,
	inStringA    = 0x00000200,

	// text content model states
	inPLAINTEXT  = 0x00001000,
	inCOMMENT    = 0x00002000,
	inXMP        = 0x00004000,
	inLISTING    = 0x00008000,

	// sublanguages
	inVariant    = 0x00F00000, // mask for sublang index
	inHTML2      = 0x00000000,
	inIExplore2  = 0x00100000,
	inIExplore3  = 0x00200000,

};

// masks for subsets of the state
#define INTAG (inTag|inBangTag|inPITag|inHTXTag|inEndTag)
#define INSTRING (inString|inStringA)
#define TAGMASK (INTAG|inAttribute|inValue|inComment|INSTRING)
#define TEXTMASK (inPLAINTEXT|inCOMMENT|inXMP|inLISTING)
#define STATEMASK (TAGMASK|TEXTMASK)

// convert state <-> sublang index
inline DWORD SubLangIndexFromLxs(DWORD lxs) { return (lxs & inVariant) >> 20UL; }
inline DWORD LxsFromSubLangIndex(DWORD isl) { return (isl << 20UL) & inVariant; }

#endif // __TOKHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\tokcpp.h ===
// tokcpp.h - tokens for C++
//
// Include lex.h before including this file.
//

#pragma once

#include <cppsvc.h>

enum TOKCPP {	
	tokUNKNOWN = tokclsError,
	tokKEYW_AUTO = tokclsKeyWordMin,
	tokKEYW_BREAK,
	tokKEYW_BOOL,
	tokKEYW_BOOLEAN,//ODL
	tokKEYW_BYTE,//ODL
	tokKEYW_CASE,
	tokKEYW_CATCH,
	tokKEYW_CHAR,
	tokKEYW_CLASS,
	tokKEYW_COCLASS,//ODL
	tokKEYW_CONST,
	tokKEYW_CONST_CAST,
	tokKEYW_CONTINUE,
	tokKEYW_CPP_QUOTE,//ODL
	tokKEYW_DISPINTERFACE,//ODL
	tokKEYW_DEFAULT,
	tokKEYW_DELETE,
	tokKEYW_DO,
	tokKEYW_DOUBLE,
	tokKEYW_DYNAMIC_CAST,
	tokKEYW_ELSE,
	tokKEYW_ENUM,
	tokKEYW_ERROR_STATUS_T,//ODL
	tokKEYW_EXPLICIT,
	tokKEYW_EXTERN,
	tokKEYW_FALSE,
	tokKEYW_FLOAT,
	tokKEYW_HANDLE_T,//ODL
	tokKEYW_HYPER,//ODL
	tokKEYW_FOR,
	tokKEYW_FRIEND,
	tokKEYW_GOTO,
	tokKEYW_IF,
	tokKEYW_IMPORT,//ODL
	tokKEYW_IMPORTLIB,//ODL
	tokKEYW_INCLUDE,//ODL
	tokKEYW_INLINE,
	tokKEYW_INT,
	tokKEYW_INTERFACE,
	tokKEYW_LIBRARY,//ODL
	tokKEYW_LONG,
	tokKEYW_MAIN,
	tokKEYW_METHODS,//ODL
	tokKEYW_MODULE,//ODL
	tokKEYW_MUTABLE,
	tokKEYW_NAMESPACE,
	tokKEYW_NEW,
	tokKEYW_OPERATOR,
	tokKEYW_PASCAL,
	tokKEYW_PRIVATE,
	tokKEYW_PROPERTIES,//ODL
	tokKEYW_PROTECTED,
	tokKEYW_PUBLIC,
	tokKEYW_REGISTER,
	tokKEYW_REINTERPRET_CAST,
	tokKEYW_RETURN,
	tokKEYW_SHORT,
	tokKEYW_SIGNED,
	tokKEYW_SIZEOF,
	tokKEYW_SMALL,//ODL
	tokKEYW_STATIC,
	tokKEYW_STATIC_CAST,
	tokKEYW_STRUCT,
	tokKEYW_SUPER,
	tokKEYW_SWITCH,
	tokKEYW_TEMPLATE,
	tokKEYW_THIS,
	tokKEYW_THROW,
	tokKEYW_TRUE,
	tokKEYW_TRY,
	tokKEYW_TYPEDEF,
	tokKEYW_TYPEID,
	tokKEYW_TYPENAME,
	tokKEYW_UNION,
	tokKEYW_UNSIGNED,
	tokKEYW_USING,
	tokKEYW_VIRTUAL,
	tokKEYW_VOID,
	tokKEYW_VOLATILE,
	tokKEYW_WHILE,
	tokKEYW_WMAIN,
	tokKEYW_XALLOC,
	tokKEYW_WCHAR_T,

	tokKEYW__ABSTRACT,//MC++
	tokKEYW__ALIGNOF,
	tokKEYW__ASM,
	tokKEYW__ASSUME,
	tokKEYW__BASED,
	tokKEYW__BOX,//MC++
	tokKEYW__CDECL,
	tokKEYW__DECLSPEC,
	tokKEYW__DELEGATE,//MC++
	tokKEYW__EVENT,//MC++
	tokKEYW__EXCEPT,
	tokKEYW__FASTCALL,
	tokKEYW__FINALLY,
	tokKEYW__FORCEINLINE,
	tokKEYW__GC,//MC++
    tokKEYW__HOOK,//MC++
	tokKEYW__IDENTIFIER,//MC++
	tokKEYW__IF_EXISTS,
	tokKEYW__IF_NEXISTS,
	tokKEYW__INLINE,
	tokKEYW__INT16,
	tokKEYW__INT32,
	tokKEYW__INT64,
	tokKEYW__INT8,
	tokKEYW__INTERFACE,//MC++
	tokKEYW__LEAVE,
    tokKEYW__M128,//MC++
    tokKEYW__M128D,//MC++
    tokKEYW__M128I,//MC++
    tokKEYW__M64,//MC++
	tokKEYW__MULTINHERIT,//MC++
	tokKEYW__NOGC,//MC++
	tokKEYW__NOOP,
	tokKEYW__PASCAL,
	tokKEYW__PIN,//MC++
	tokKEYW__PRAGMA,
	tokKEYW__PROPERTY,//MC++
	tokKEYW__PTR64,
	tokKEYW__RAISE,//MC++
	tokKEYW__SEALED,//MC++
	tokKEYW__SERIALIZABLE,//MC++
	tokKEYW__SINGINHERIT,
	tokKEYW__STDCALL,
	tokKEYW__SUPER,
	tokKEYW__TRANSIENT,//MC++
	tokKEYW__TRY,
	tokKEYW__TRY_CAST,//MC++
	tokKEYW__TYPEOF,//MC++
	tokKEYW__UNALIGNED,
	tokKEYW__UNHOOK,//MC++
	tokKEYW__UUIDOF,
	tokKEYW__VALUE,//MC++
	tokKEYW__VIRTINHERIT,
	tokKEYW__WCHAR_T,

	tokATTR_MIN,//ODL
	tokATTR_APPOBJECT,//ODL
    tokATTR_ASYNC_UUID, //ODL
	tokATTR_AUTO_HANDLE,//ODL
	tokATTR_BASE_TYPES,//ODL
	tokATTR_BINDABLE,//ODL
	tokATTR_BROADCAST,//ODL
	tokATTR_BYTE_COUNT,//ODL
	tokATTR_CALL_AS,//ODL
	tokATTR_CALLBACK,//ODL
	tokATTR_CODE,//ODL
	tokATTR_COMM_STATUS,//ODL
	tokATTR_CONTEXT_HANDLE,//ODL
	tokATTR_CONTROL,//ODL
	tokATTR_CUSTOM,//ODL
	tokATTR_DECODE,//ODL
	tokATTR_DEFAULT,//ODL
	tokATTR_DEFAULTBIND,//ODL
    tokATTR_DEFAULTCOLLELEM,//ODL
    tokATTR_DEFAULTVALUE, //ODL
	tokATTR_DISPLAYBIND,//ODL
	tokATTR_DLLNAME,//ODL
	tokATTR_DUAL,//ODL
	tokATTR_ENABLE_ALLOCATE,//ODL
	tokATTR_ENCODE,//ODL
	tokATTR_ENDPOINT,//ODL
	tokATTR_ENTRY,//ODL
	tokATTR_EXPLICIT_HANDLE,//ODL
	tokATTR_FAULT_STATUS,//ODL
	tokATTR_FIRST_IS,//ODL
	tokATTR_HANDLE,//ODL
	tokATTR_HELPCONTEXT,//ODL
	tokATTR_HELPFILE,//ODL
	tokATTR_HELPSTRING,//ODL
	tokATTR_HELPSTRINGCONTEXT,//ODL
	tokATTR_HIDDEN,//ODL
	tokATTR_ID,//ODL
	tokATTR_IGNORE,//ODL
	tokATTR_IID_IS,//ODL
    tokATTR_IMMEDIATEBIND,//ODL
	tokATTR_IMPLICIT_HANDLE,//ODL
	tokATTR_IN,//ODL
	tokATTR_LAST_IS,//ODL
	tokATTR_LCID,//ODL
	tokATTR_LENGTH_IS,//ODL
	tokATTR_LICENSED,//ODL
	tokATTR_LOCAL,//ODL
	tokATTR_MAX_IS,//ODL
	tokATTR_MAYBE,//ODL
	tokATTR_MS_UNION,//ODL
	tokATTR_NOCODE,//ODL
	tokATTR_NONBROWSABLE,//ODL
	tokATTR_NONEXTENSIBLE,//ODL
	tokATTR_NOTIFY,//ODL
	tokATTR_OBJECT,//ODL
	tokATTR_ODL,//ODL
	tokATTR_OLEAUTOMATION,//ODL
	tokATTR_OPTIMIZE,//ODL
	tokATTR_OPTIONAL,//ODL
	tokATTR_OUT,//ODL
	tokATTR_POINTER_DEFAULT,//ODL
	tokATTR_PROPGET,//ODL
	tokATTR_PROPPUT,//ODL
	tokATTR_PROPPUTREF,//ODL
	tokATTR_PTR,//ODL
	tokATTR_PUBLIC,//ODL
	tokATTR_READONLY,//ODL
	tokATTR_REF,//ODL
	tokATTR_REPRESENT_AS,//ODL
	tokATTR_REQUESTEDIT,//ODL
	tokATTR_RESTRICTED,//ODL
	tokATTR_RETVAL,//ODL
	tokATTR_SIZE_IS,//ODL
	tokATTR_SOURCE,//ODL
	tokATTR_STRING,//ODL
	tokATTR_SWITCH_IS,//ODL
	tokATTR_SWITCH_TYPE,//ODL
	tokATTR_TRANSMIT_AS,//ODL
	tokATTR_UNIQUE,//ODL
	tokATTR_UUID,//ODL
	tokATTR_V1_ENUM,//ODL
	tokATTR_VARARG,//ODL
	tokATTR_VERSION,//ODL
	tokATTR_MAX,//ODL			// last attribute key


	tokKEYW__MAX,			/* last keyword */

	tokPPKEYW_MIN,			/* min Preprocessor keyword */
	tokPPKEYW_DEFINE,
	tokPPKEYW_ELIF,
	tokPPKEYW_ELSE,
	tokPPKEYW_ENDIF,
	tokPPKEYW_ERROR,
	tokPPKEYW_IF,
	tokPPKEYW_IFDEF,
	tokPPKEYW_IFNDEF,
	tokPPKEYW_IMPORT,
	tokPPKEYW_INCLUDE,
	tokPPKEYW_LINE,
	tokPPKEYW_PRAGMA,
	tokPPKEYW_UNDEF,
	tokPPKEYW_USING,//MC++
	tokPPKEYW_MAX,			/* max Preprocessor keyword */	

	tokDECLKEYW_ALIGN,	/* keywords following _declspec */
	tokDECLKEYW_ALLOCATE,
	tokDECLKEYW_DEPRECATED,
	tokDECLKEYW_DLLEXPORT,
	tokDECLKEYW_DLLIMPORT,
	tokDECLKEYW_NAKED,
	tokDECLKEYW_NOINLINE,
	tokDECLKEYW_NORETURN,
	tokDECLKEYW_NOTHROW,
	tokDECLKEYW_NOVTABLE,
	tokDECLKEYW_PROPERTY,
	tokDECLKEYW_SEALED,
	tokDECLKEYW_SELECTANY,
	tokDECLKEYW_THREAD,
	tokDECLKEYW_UUID,
	
	tokASSUMEKEYW_EVAL,		// keywords following __assume
	tokASSUMEKEYW_NOEVAL,

	tokPPIFKEYW_DEFINED, 	/* keyword following #if */

	tokPRAGKEYW_ALLOCTEXT,	/* keywords following #pragma */    
	tokPRAGKEYW_AUTOINLINE,
	tokPRAGKEYW_BESTCASE,
	tokPRAGKEYW_BSS_SEG,
	tokPRAGKEYW_CHKSTACK,
	tokPRAGKEYW_CODESEG,
	tokPRAGKEYW_COMMENT,
	tokPRAGKEYW_COMPILER,
	tokPRAGKEYW_COMPONENT,
	tokPRAGKEYW_CONFORM,
	tokPRAGKEYW_CONST_SEG,
	tokPRAGKEYW_DATASEG,
	tokPRAGKEYW_DEFAULT,
	tokPRAGKEYW_DEPRACATED,
	tokPRAGKEYW_DISABLE,
	tokPRAGKEYW_ERROR,
	tokPRAGKEYW_EXESTR,
	tokPRAGKEYW_FULLGENERALITY,
	tokPRAGKEYW_FUNCTION,
	tokPRAGKEYW_HDRSTOP,
	tokPRAGKEYW_INCLUDE_ALIAS,
	tokPRAGKEYW_INITSEG,
	tokPRAGKEYW_INLINEDEPTH,
	tokPRAGKEYW_INLINERECURSE,
	tokPRAGKEYW_INSTRINSIC,
	tokPRAGKEYW_KEYWORD,
	tokPRAGKEYW_LIB,
	tokPRAGKEYW_MANAGED,
	tokPRAGKEYW_MESSAGE,
	tokPRAGKEYW_MIDL_ECHO,//ODL
	tokPRAGKEYW_MULINHERIT,
	tokPRAGKEYW_OFF,
	tokPRAGKEYW_ON,
	tokPRAGKEYW_ONCE,
	tokPRAGKEYW_OPTIMIZE,
	tokPRAGKEYW_PACK,
	tokPRAGKEYW_PTRTOMEMBERS,
	tokPRAGKEYW_POP,
	tokPRAGKEYW_POPMACRO,
	tokPRAGKEYW_PUSH,
	tokPRAGKEYW_PUSHMACRO,
	tokPRAGKEYW_RESTORE,
	tokPRAGKEYW_RUNTIME_CHECKS,
	tokPRAGKEYW_SECTION,
	tokPRAGKEYW_SETLOCALE,
	tokPRAGKEYW_SINGINHERIT,
	tokPRAGKEYW_UNMANAGED,
	tokPRAGKEYW_USER,
	tokPRAGKEYW_VIRTINHERIT,
	tokPRAGKEYW_VTORDISP,
	tokPRAGKEYW_WARNING,
//#if tokPRAGKEYW_WARNING >= tokclsOpMin
//#error To many keywords, adjust tokclsOpMin value
//#endif
	tokDELI_LPAREN = tokclsOpMin,			// ( 
	tokDELI_RPAREN,							// ) 
	tokDELI_LBKT,							// [ 
	tokDELI_RBKT,							// ] 

	tokOP_COMA,								// ,    
	tokOP_DOT,								// .    
	tokOP_DOTSTAR,							// .*    
	tokOP_SCOLON,							// ;    
	tokOP_TILDE	,							// ~    
	tokOP_QUEST,							// ?    

	tokOP_NOT,								// !    
	tokOP_NOTEQ,							// !=   
	tokOP_MOD,								// %    
	tokOP_MODEQ,							// %=   
	tokOP_AND,								// &   
	tokOP_ANDAND,							// &&  
	tokOP_ANDEQ,							// &=  
	tokOP_MUL,								// *   
	tokOP_MULEQ,							// *=  
	tokOP_ENDCOMMENT,						// */  
	tokOP_PLUS,								// +   
	tokOP_INC,								// ++  
	tokOP_PLUSEQ,							// +=  
	tokOP_MINUS,							// -   
	tokOP_DECR,								// --  
	tokOP_MINUSEQ,							// -=  
	tokOP_DIV,								// /   
	tokOP_DIVEQ,							// /=  
	tokOP_BEGINCOMMENT,						// /*  
	tokOP_LT,								// <   
	tokOP_LSHIFT,							// <<  
	tokOP_LEQ,								// <=  
	tokOP_ASGN,								// =   
	tokOP_EQ,								// ==  
	tokOP_GT,								// >   
	tokOP_RSHIFT,							// >>  
	tokOP_GEQ,								// >=  
	tokOP_XOR,								// ^   
	tokOP_XOREQ,							// ^=  
	tokOP_OR,								// |   
	tokOP_OROR,								// ||  
	tokOP_OREQ,								// |=  
	tokOP_COLON,							// :
	tokOP_DCOLON,							// ::    
	tokOP_ARROW,							// ->  
	tokOP_ARROWSTAR,						// ->* 
	tokOP_RSHIFTEQ,							// >>= 
	tokOP_LSHIFTEQ,							// <<= 
	tokDELI_LCBKT = tokclsOpSpecOpenBlock,	// { 
	tokDELI_RCBKT = tokclsOpSpecCloseBlock,	// } 
	tokOP_MAX,								// token op MAX

	tokOP_LINECMT =  tokclsOpSpecLineCmt,	// line comment

	tokIDENTIFIER = tokclsIdentMin,			// identifier
	tokNUMBER = tokclsConstInteger,			// number const
	tokREAL = tokclsConstReal,
	tokSTRING = tokclsConstString,			// string
	tokBEGINSTRING,
	tokCHAR,
	tokSTRINGERR,

	tokCOMMENT = tokclsCommentMin,			// comment

	tokWIZ = tokclsUserMin,					//return this token  if we are in the wizard modified code,
	tokNEWLINE,
	tokFILENAME,							// <filename> after #define
	tokUSERDEFKW,
	tokEOF
};


#define BASED_HINT		0x9000

// token hints
#define ERR			BASED_HINT + 0	// error
#define HWS			BASED_HINT + 1	// white space
#define HST			BASED_HINT + 2	// string
#define HPP			BASED_HINT + 3	// preprocessor
#define HCH			BASED_HINT + 4	// character (')
#define HNU			BASED_HINT + 5	// number
#define HKW			BASED_HINT + 6	// keyword


#define OLP	tokDELI_LPAREN	
#define ORP tokDELI_RPAREN	
#define OLB tokDELI_LBKT		
#define ORB tokDELI_RBKT		
#define OLC tokDELI_LCBKT	
#define ORC tokDELI_RCBKT	
                
#define OCO tokOP_COMA		
#define ODO tokOP_DOT		
#define OSC tokOP_SCOLON		
#define OUN tokOP_TILDE		
#define OQU tokOP_QUEST
#define ONL tokNEWLINE
#define EOS tokEOF

#define BASED_MULOP		0
#define M00		BASED_MULOP + 0
#define M01		BASED_MULOP + 1	
#define M02		BASED_MULOP + 2
#define M03		BASED_MULOP + 3	
#define M04		BASED_MULOP + 4
#define M05		BASED_MULOP + 5	
#define M06		BASED_MULOP + 6
#define M07		BASED_MULOP + 7	
#define M08		BASED_MULOP + 8
#define M09		BASED_MULOP + 9	
#define M0A		BASED_MULOP + 10
#define M0B		BASED_MULOP + 11
#define M0C		BASED_MULOP + 12	
#define M0D		BASED_MULOP + 13
#define BASED_MULOP_MAX	BASED_MULOP + 14			


// the state of lexical analyser 
// ie:
// inComment : we're inside a comment before getting the next token
//				so we need to find end of comment code (*/)	and if
//				we can't find a matching comment then put everything
//				inside the comment.
// inString	 : we're inside a string before getting the next token
//				so we need to find end of string (") or continuation (\)
//				otherwise we need to return an error.
// inCode	 : should parse a regular code
// inWizard	 : should parse wizard modified code
//
// The following states are used only internally (ie: inside lexer)
// since we want to do differently after we encounter a
// inPPIf	 : after the preprocessor #if is encountered but before eol
// inPPPragma: after #pragma is encountered but before eol
// inPPInclude: after #include is encountered but before eol
// 
enum lexstate
{
	inComment       = 0x0001,
	inString        = 0x0002,
	inCode          = 0x0004,
	inPPIf          = 0x0008,
	inPPPragma      = 0x0010,
	inPPInclude     = 0x0020,
	inWizard        = 0x0040,
	inDeclspec      = 0x0080,
	inPreProcessor  = 0x0100,
	inSingleComment = 0x0200,
	inAssume		= 0x0400,
	inPPError       = 0x0800,
	inUuid			= 0x1000,//ODL
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\srcapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	SRCAPI.H
//		Source package interface declarations.
#ifndef __SRCAPI_H__
#define __SRCAPI_H__

/////////////////////////////////////////////////////////////////////////////
//	IVCSourceParser interface

#include <parse.h>
class CVCPath;
#include <textmgr.h>
#ifndef STRICT
typedef DWORD HLEXER;
typedef DWORD HPARSER;
typedef DWORD HBSC;
typedef DWORD HNCB;
#else	// STRICT
DECLARE_HANDLE(HLEXER);
DECLARE_HANDLE(HPARSER);
DECLARE_HANDLE(HBSC);
DECLARE_HANDLE(HNCB);
#endif	// STRICT


enum EXEFROM	// where did GetExecutableFilename get name from?
{
	exefromNone,	// nowhere (no name found)
	exefromProj,	// from project
	exefromLastDoc,	// from last open src window
	exefromExe,		// from currently active exe window
	exefromPid,		// from PID on command line (just-in-time debugging)
};

interface VCProject;
interface VCConfiguration;

interface IVsHierarchy;
interface IVsProjectCfg;

/////////////////////////////////////////////////////////////////////////////
//	IVCSourceParser interface

__interface __declspec(uuid("{90D1AE81-29DC-11cf-B250-00AA0057AFF3}")) IVCSourceParser : public IUnknown
{
    STDMETHOD(GetLexerAndParser)(const TCHAR *szFileName, HLEXER *phLexer, HPARSER *phParser);
    STDMETHOD(GetBsc)(IVsProjectCfg * pIVsProjectCfg, BscEx ** ppBscEx);
    STDMETHOD(GetBscForActiveConfiguration)(IVsHierarchy * pIVsHierarchy, BscEx ** ppBscEx);
    STDMETHOD(GetBscForActiveConfigurationOfSelectedProject)(BscEx ** ppBscEx);
    STDMETHOD(GetBscForVCConfiguration)(VCConfiguration * pIVCConfiguration, BscEx ** ppBscEx);
    STDMETHOD(CanParseFile)(BSTR bstrFileName);
    STDMETHOD(IsTerminateThread)();
    STDMETHOD(GetDBase)(HNCB *phNcbParse);
    STDMETHOD(IsSuspendThread)();
    STDMETHOD(NotifyParseDone)(LPCSTR lpszFileName);
    STDMETHOD(WaitParserSuspended)();
    STDMETHOD(AddDirtyFilesToParseQueue)(BOOL fParse = TRUE);
    STDMETHOD(GetLine)(void *pTextDoc, int iLine, LPSTR &pszLine, UINT &uLength, DWORD &lxs) PURE;
    STDMETHOD(RegisterFileToWatch)(CString &strFileName) PURE;  // Non-standard COM.
    STDMETHOD(UnregisterFileToWatch)(CString &strFileName) PURE;    // Non-standard COM.
    STDMETHOD(AddToQueue)(const CVCPath *pPath, HTARGET hTarget, Action action, BOOL fAtTheEnd, BOOL fOverrideComPlus, BOOL fComPlus) PURE; // Non-standard COM
    STDMETHOD(SetEventAddQueue)() PURE; // to wake up the parser thread whenever there is some autocompletion needs to be done
    STDMETHOD(SetDynamicParsing) (BOOL fDyParse) PURE;
    STDMETHOD(GetCurrentParseFileBuffer)(LPCCH *ppFileContents, ULONG *pcbFile, LONG *pilineBegin, LONG *pilineEnd);
    STDMETHOD(NotifyOfNewView)(const WCHAR *wszFileName, IVsTextView *pVsTextView, IVsCodeWindow *pVsCodeWindow);
    STDMETHOD(NotifyOfWindowClose)(const WCHAR *wszFileName, IVsCodeWindow *pVsCodeWindow);
    STDMETHOD(OnUserPreferencesChanged)();    // used by IVsTextManagerEvents::OnUserPreferencesChanged (cpp.cpp)
    STDMETHOD(GetQueueSize)(int *piSize);     // Returns the number of items in the queue
    STDMETHOD_(BOOL, FComPlusFile)(const WCHAR *wszFileName);  // queries the proj system to see if COM+ compilation is enabled for this file
    STDMETHOD_(LPCRITICAL_SECTION, GetFeacpCS)(); // critical section, because FEACP is not reantrant
    STDMETHOD(SuspendParse)();
    STDMETHOD(ResumeParse)();
    STDMETHOD(GetAutoCompEvent)(HANDLE *hEvent);
};
typedef IVCSourceParser* LPVCSOURCEPARSER;

/////////////////////////////////////////////////////////////////////////////
//	IOutputWindow interface

#undef  INTERFACE
#define INTERFACE IOutputWindow

DECLARE_INTERFACE_(IOutputWindow, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IOutputWindow methods
	STDMETHOD(ShowOutputWindow)() PURE;
	STDMETHOD(ClearOutputWindow)() PURE;
	STDMETHOD(WriteStringToOutputWindow)(LPCSTR lpszError, BOOL fToolError, BOOL fAppendCrLf) PURE;
	STDMETHOD(OutputWindowQueueHit)(UINT nCommandID, LPCSTR lpszError,
		BOOL fToolError, BOOL fAppendCrLf, BOOL fForceFlush) PURE;
	STDMETHOD(OutputWindowDeleteVwin)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowShowVwin)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowSelectVwin)(UINT nCommandID, BOOL fOnTop) PURE;
	STDMETHOD(OutputWindowAddVwin)(LPSTR szToolName, BOOL fCurrentVwin, UINT *puRet) PURE;
	STDMETHOD(OutputWindowModifyVwin)(UINT nCommandID, LPSTR szToolName, UINT *puRet) PURE;
	STDMETHOD(OutputWindowVwinClear)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowClearWindow)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowClearContents)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowGetLine)(ULONG iline, ULONG *pcbLine, LPCSTR *ppLine) PURE;
	STDMETHOD(OwinGetBuildCommandID)(UINT *puRet) PURE;
	STDMETHOD(OwinGetDebugCommandID)(UINT *puRet) PURE;
	STDMETHOD(OwinIsBufferFull)(BOOL* fFull) PURE;	
};

/////////////////////////////////////////////////////////////////////////////
//	IFileAccess interface

#undef  INTERFACE
#define INTERFACE IFileAccess

DECLARE_INTERFACE_(IFileAccess, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IFileAccess methods
	STDMETHOD(CreateFile)(LPCTSTR lpszName, DWORD fdwAccess, DWORD fdwShareMode, LPSECURITY_ATTRIBUTES lpsa, DWORD fdwCreate, DWORD fdwAttrsAndFlags, HANDLE hTemplateFile, HANDLE *hRet) PURE;
	STDMETHOD(OpenFile)(const char *pszFileName, const char *pszMode, FILE **ppRet) PURE;
	STDMETHOD(CreateFileForParse)(LPCTSTR lpszName, DWORD fdwAccess, DWORD fdwShareMode, LPSECURITY_ATTRIBUTES lpsa, DWORD fdwCreate, DWORD fdwAttrsAndFlags, HANDLE hTemplateFile, HANDLE *hRet) PURE;
	STDMETHOD(CloseFileForParse)(HANDLE handle) PURE;
	STDMETHOD(Replace)(const char *pszOldName, const char *pszNewName, int *iRet) PURE;
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//	ICustomContextMenu interface
//		Access to custom context menus on a per-language / lexer basis

#undef  INTERFACE
#define INTERFACE ICustomContextMenu

/////////////////////////////////////////////////////////////////////////////
//	forward declaration
struct POPDESC;
typedef POPDESC* LPPOPDESC;


DECLARE_INTERFACE_(ICustomContextMenu, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ICustomContextMenu methods
	STDMETHOD(GetContextMenu)(THIS_ LPCTSTR, LPPOPDESC*) PURE;
};

#ifdef _SQLDBG
#include "sqlpkapi.h"
#endif // _SQLDBG

#endif	// __SRCAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\tokodl.h ===
// tokodl.h - the tokens needed for lexing IDL/ODL files
//
// Include lex.h before including this file.
//

#pragma once

#define TOKODL TOKCPP
#include <tokcpp.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vccmd.h ===
//----------------------------------------------------------------------------
//
//
//  File:	vccmd.h
//	Area:	VC Package Commands
//
//  Contents:
//		VC Package Menu, Group, Command IDs
//
//----------------------------------------------------------------------------
#ifndef _VCCMD_H
#define _VCCMD_H

#include "vcrange.h" // lists the range of ids that one could use
#include "stdidcmd.h"

// Menus
#define IDM_VCP_VCPROJ				0x00F1
#define IDMX_VCP_PROJECTNODE		0x00F4
// Groups
//#define	IDG_VC_EXECUTE				0xF100
#define	IDG_VCP_PROJECT				0xF200
#define IDG_VCP_VCPROJ				0xF300
#define	IDG_VC_DO					0xF400
#define IDG_VC_CV_PROJECT_WIZARDS   0xF500  // ClassView wizards grp for VC added to the CV ptoject context menu
#define	IDG_VC_CPPSVC				0xF600
#define	IDG_VC_CV_ITEM_WIZARDS	    0xF700  // ClassView wizards grp for VC added to the default CV item context menu


//Command IDs
#define	icmdLaunchDesigner			0xF100
#define	icmdLaunchDDS				0xF200
#define	icmdLaunchToolBox			0xF300
#define	icmdSyncDesigner			0xF400

#define	icmdClassFromTypeLibWiz		0x8916
#define	icmdClassFromAxControlWiz	0x8917
#define	icmdPerfObjectWiz			0x8918
#define	icmdPerfCounterWiz			0x8919

#define	icmdCollapseBlock			0x8924
#define	icmdCollapseAllBlocks		0x8925

#endif //_VCCMD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vbpkguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	VBPKGUID.H
//		VBA package GUIDs.

// Class ID for form document {3486698F-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_FormDocument, 
	0x3486698f, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for VBA document {34866990-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_VbaDocument, 
	0x34866990, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vcrange.h ===
// ids.h to be used for the vc pkg
// These are the suggested id ranges 

#define MIN_ID_VC_PKG	1000
#define MAX_ID_VC_PKG	1999

#define MIN_ID_CODEMGR	2000
#define MAX_ID_CODEMGR	2999

#define MIN_ID_CLSVIEW	3000
#define MAX_ID_CLSVIEW	3999

#define MIN_ID_ISENSE	4000
#define MAX_ID_ISENSE	4999

#define MIN_ID_PARSER	5000
#define MAX_ID_PARSER	5999

#define MIN_ID_VCDO		6000
#define MAX_ID_VCDO		6999

#define MIN_ID_CLSWIN	7000
#define MAX_ID_CLSWIN	7999

//#define MIN_ID_TALIESIN	8000
//#define MAX_ID_TALIESIN	8999

#define MIN_ID_CPPSVC	9000
#define MAX_ID_CPPSVC	9999

#define MIN_ID_CODEMODELHELPSTRINGS 28000
#define MAX_ID_CODEMODELHELPSTRINGS 28999
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vcpkg.h ===
//	VCPKG.H
//
//
//	VC package interface

#pragma once

// Forward Declarations
//

class CStateSaver;
#include <commctrl.h>
// Package Component Interface Access
//

// So we do not have to #include the headers.
//


struct IVCPackage;
struct IVCPackageComponent;
struct IBuildSystem;
struct IBuildSystem2;			
struct IVCSourceParser;
struct ICodeManager;				
struct ICodeManagerMenuBuilder;	
class  VCCodeModelService;	
struct IDesignerObjectFilters;	
struct IProjectWorkspaceWindow;	
__interface INCB;
struct BscEx;
struct IVsUIShell;

extern IVCPackage *					GetIVCPackage				(void);
extern IOleCommandTarget*			GetIVCCommandTarget			(void);
extern IBuildSystem *				GetIBuildSystem				(void);
extern IBuildSystem2 *				GetIBuildSystem2			(void);
extern ICodeManager *				GetICodeManager				(void);
extern ICodeManagerMenuBuilder *	GetICodeManagerMenuBuilder	(void);
extern VCCodeModelService *			GetVCCodeModelService		(void);
extern IDesignerObjectFilters *		GetIDesignerObjectFilters	(void);
extern IProjectWorkspaceWindow *	GetIProjectWorkspaceWindow	(void);
extern IVCSourceParser *            GetIVCSourceParser          (void);
extern BscEx *						GetSolutionBSC				(void);
extern IDispatch * GetCVSelectedDispatch(void);
extern void SetCVSelectedDispatch(IDispatch* pDispSelected);
#if defined(_NCB_PACKAGE_COMPONENT_)
extern INCB *						GetINCB						(void);
#endif // _NCB_PACKAGE_COMPONENT_
// HACK! HACK! Remove as soon as we are using the DTE to get to the Solution
// object.
//

class IWorkspaceDO_Internal;
extern IWorkspaceDO_Internal * GetWorkspaceDO(void);

// Remove this implementation as you implement these for real in the appropriate 
// static library.
//

inline IBuildSystem *				GetIBuildSystem				(void) { return NULL; }
inline IBuildSystem2 *				GetIBuildSystem2			(void) { return NULL; }
inline ICodeManager *				GetICodeManager				(void) { return NULL; }
inline ICodeManagerMenuBuilder *	GetICodeManagerMenuBuilder	(void) { return NULL; }
inline IDesignerObjectFilters *		GetIDesignerObjectFilters	(void) { return NULL; }

// Package Component Creation
//
// These are defined by their respective package extensions
//

extern HRESULT CreateClassViewPackageComponent(IVCPackageComponent** ppIVCPackageComponent);
extern HRESULT CreateClassWinPackageComponent(IVCPackageComponent** ppIVCPackageComponent);
// this one is the old taliesin stuff
//extern HRESULT CreateVCDesignerPackageComponent(IVCPackageComponent** ppIVCPackageComponent);
#if defined(_NCB_PACKAGE_COMPONENT_)
extern HRESULT CreateNcbPackageComponent(IVCPackageComponent ** ppIVCPackageComponent);
#endif // _NCB_PACKAGE_COMPONENT_
extern HRESULT CreateParserPackageComponent(IVCPackageComponent ** ppIVCPackageComponent);
extern HRESULT CreateCodeModelPackageComponent(IVCPackageComponent ** ppIVCPackageComponent);
extern HRESULT CreateIsensePackageComponent(IVCPackageComponent ** ppIVCPackageComponent);
extern HRESULT CreateCRToolsPackageComponent(IVCPackageComponent ** ppIVCPackageComponent);

#define IMGLIST_WIDTH           16
#define IMGLIST_BACKGROUND      0x0000ff00

enum VCPackageComponent 
{
	vcPackageComponentInvalid = -1,
	vcPackageComponentCodeModel = 0,
#if defined(_NCB_PACKAGE_COMPONENT_)
	vcPackageComponentNCB,
#endif // _NCB_PACKAGE_COMPONENT_
	vcPackageComponentParser,
//	vcPackageComponentTaliesin,
	vcPackageComponentCRTools,
	vcPackageComponentIsense,
#ifndef DAVEWAGON
	vcPackageComponentLast,
#endif
	vcPackageComponentClassView = vcPackageComponentIsense+1,
	vcPackageComponentClassWin,
#ifdef DAVEWAGON
	vcPackageComponentLast,
#endif
	vcPackageComponentCppService = vcPackageComponentClassWin+1 // After vcPackageComponentLast because it is not a package component
};


struct __declspec(uuid("{6025237E-ABF9-11d2-AA84-00C04F72DB55}")) IVCPackage : public IUnknown
{
	STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void** ppv) = 0; // Calls Shell's query service
	STDMETHOD(Init)(void) = 0;
	STDMETHOD_(HIMAGELIST, GetImageList)(void) = 0;
	STDMETHOD_(LPDLGTEMPLATE, LoadDialog)	(IVCPackageComponent * pIVCPackageComponent, UINT nIDResource) = 0;
	STDMETHOD_(HCURSOR, LoadCursor)			(IVCPackageComponent * pIVCPackageComponent, UINT nIDResource) = 0;
	STDMETHOD_(HICON, LoadIcon)				(IVCPackageComponent * pIVCPackageComponent, UINT nIDResource) = 0;
	STDMETHOD_(HBITMAP, LoadBitmap)			(IVCPackageComponent * pIVCPackageComponent, UINT nIDResource) = 0;
	STDMETHOD_(void, LoadString)			(IVCPackageComponent * pIVCPackageComponent, UINT nIDResource, BSTR*) = 0;
	STDMETHOD_(BOOL, PlaySound)				(IVCPackageComponent * pIVCPackageComponent, UINT nIDResource) = 0;
	STDMETHOD(VCMessageBox)(LPCWSTR wstrMsg) = 0;
};


// CVCPackageResourceManager
//
class CVCPackageResourceManager
{
public :
	CVCPackageResourceManager(void) {};
	void SetSite(IServiceProvider *pVsShellSP);

	// IVCPackageResourceManager
	STDMETHOD_(LPDLGTEMPLATE, LoadDialog)(VCPackageComponent vcPackageID, UINT nIDResource);
	STDMETHOD_(HCURSOR, LoadCursor)(VCPackageComponent vcPackageID, UINT nIDResource);
	STDMETHOD_(HICON, LoadIcon)(VCPackageComponent vcPackageID, UINT nIDResource);
	STDMETHOD_(HBITMAP, LoadBitmap)(VCPackageComponent vcPackageID, UINT nIDResource);
	STDMETHOD_(void, LoadString)(VCPackageComponent vcPackageID, UINT nIDResource, BSTR*);
	STDMETHOD_(BOOL, PlaySound)(VCPackageComponent vcPackageID, UINT nIDResource);
private:
	CComPtr<IServiceProvider>	m_spVsShellSP;
	HINSTANCE GetResourceInstance();
	bool VerifyPackageComponentResourceRange(VCPackageComponent vcPackageID, UINT nIDResource) const;
	friend class CVCPackage;

};


// helper class to synchronize SuspendParse and ResumeParse
class CSmartSuspendResumeThread
{
public:
	CSmartSuspendResumeThread();
	virtual ~CSmartSuspendResumeThread();
private:
	static bool bSuspend;

};

// IVCPackageComponent
//

struct __declspec(uuid("{6025237F-ABF9-11d2-AA84-00C04F72DB55}")) IVCPackageComponent : public IUnknown
{
	STDMETHOD_(UINT, GetPackageID)(void) const = 0;
	STDMETHOD(OnInit)(void) { return S_FALSE; }

	STDMETHOD(OnPreExit)(void) { return S_FALSE; }
	STDMETHOD(OnExit)(void) { return S_FALSE; }
	STDMETHOD(OnNotify)(DWORD dwID, DWORD dwHint) { return S_FALSE; }
	STDMETHOD_(BOOL, OnIdle)(long lIdleCount) { return FALSE; }
	// Registry Serialization
	//

	STDMETHOD(SaveSettings)(void) { return S_FALSE; }

	// Local Solution Level Serialization (.OPT)
	//

	STDMETHOD(SerializeWorkspaceSettings)(CStateSaver & stateSave, DWORD dwFlags) { return S_FALSE; }
	STDMETHOD(SerializeWkspcConvSettings)(CStateSaver & stateSave, DWORD dwFlags) { return S_FALSE; }

	// Shared Project Level Serializtion (.DSW)
	//

	STDMETHOD_(LPCTSTR, GetProjectWorkspaceInfoText)(LPCTSTR lpszProject) { return NULL; }
	STDMETHOD(SetProjectWorkspaceInfoText)(LPCTSTR lpszProject, LPCTSTR lpszInfo) { return S_FALSE; }

	// Shared Solution Level Serialization (.DSW)
	//

	STDMETHOD_(LPCTSTR, GetGlobalWorkspaceInfoText)(void) { return NULL; }
	STDMETHOD(SetGlobalWorkspaceInfoText)(LPCTSTR lpszInfo)	{ return S_FALSE; }
};


// GUIDs required during package registration
//

//class __declspec(uuid("{5A4901A4-BC76-11d2-AAA2-00C04F72DB55}")) ATL_NO_VTABLE CVCTaliesinEditorFactory;


// Clipboard formats (for drag & drop)
//

__declspec(selectany) extern const CLIPFORMAT g_cfDesignerObject(0x7007);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vcdlg.h ===
// std ATL includes MUST be included before this file

#ifndef _VCDLG_H_
#define _VCDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Base class to handle Unicode-ness in dialogs
template <class T> 
class ATL_NO_VTABLE CVCAxDialogImpl :
	public CDialogImpl<T>
{
protected:
	// protected so that descendants can access
	bool m_bIsWin9x;

public:
	// construction
	CVCAxDialogImpl() : m_bIsWin9x( true )
	{
		// what OS are we running on?
		OSVERSIONINFO osver;
		memset( &osver, 0, sizeof(osver) );
		osver.dwOSVersionInfoSize = sizeof(osver);
		GetVersionEx( &osver );
		if( osver.dwPlatformId == VER_PLATFORM_WIN32_NT )
			m_bIsWin9x = false;
	}
	
	// modal dialogs
	INT_PTR DoModalW(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		// NOTE: CWindow is used directly here because we don't have access to
		// the TBASE template arg that CAxDialogImpl does
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT<CWindow>*)this);
#ifdef _DEBUG
		m_bModal = true;
#endif //_DEBUG
		T* pT;
		pT = static_cast<T*>(this);
		if( m_bIsWin9x )
			return AtlAxDialogBox(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pT->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
		else
			return AtlAxDialogBoxW(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCEW(pT->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
	}

	// modeless dialogs
	HWND CreateW(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		// NOTE: CWindow is used directly here because we don't have access to
		// the TBASE template arg that CAxDialogImpl does
		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT<CWindow>*)this);
#ifdef _DEBUG
		m_bModal = false;
#endif //_DEBUG
		T* pT;
		pT = static_cast<T*>(this);
		HWND hWnd;
		if( m_bIsWin9x )
			hWnd = AtlAxCreateDialog(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(pT->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
		else
			hWnd = AtlAxCreateDialogW(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCEW(pT->IDD),
					hWndParent, T::StartDialogProc, dwInitParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}
};

#endif // include fence
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vcids.h ===
/////////////////////////////////////////////////////////////////////////////
//  IDS.H
//      Header files containing all shared ID spaces.  These are 16 or 32-bit
//      IDs which used by packages with no methodology to guarantee uniqueness
//      other than ID or range allocation.

#ifndef __IDS_H__
#define __IDS_H__

//  Contains:
//      Package IDs
//      Resource and string ID ranges
//      Command ID ranges
//      Status Bar Indicator IDs
//      Command group IDs
//      Help IDs
//      Package notification IDs.   *Fix for v5.0*
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Package IDs

#define PACKAGE_SUSHI            1   // DEVSHL Must be first
#define PACKAGE_VCPP             2   // DEVSRC
#define PACKAGE_VRES             3   // DEVRES
#define PACKAGE_VPROJ            4   // DEVBLD
#define PACKAGE_PRJSYS           5   // DEVPRJ
#define PACKAGE_MSIN             6   // DEVMSIN
#define PACKAGE_LANGCPP          7   // DEVCPP
#define PACKAGE_LANGFOR          8   // DEVFOR
#define PACKAGE_GALLERY         10   // DEVGAL
#define PACKAGE_LANGMST         11   // DEVTEST
#define PACKAGE_CLASSVIEW       12   // DEVCLS
#define PACKAGE_ENT             13   // DEVENT
#define PACKAGE_LANGHTML        14
#define PACKAGE_BIN             15   // DEVBIN
#define PACKAGE_IMG             16   // DEVIMG
#define PACKAGE_NUMEGA          17
#define PACKAGE_HTMLEX          18   // DEVHTMX
#define PACKAGE_IATOOL          19  // Interactive Authoring Tool Package
#define PACKAGE_NCB             20
#define PACKAGE_AUT1            24   // DEVAUT1
#define PACKAGE_DEBUG           25   // DEVDBG
#define PACKAGE_ODL             26   // DEVODL.PKG
#define PACKAGE_AUT2            27   // DEVAUT2
#define PACKAGE_HTM             28   // DEVHTM
#define PACKAGE_DTG             29   // DEVDTG
#define PACKAGE_DDK             30   // DEVDDK
#define PACKAGE_IV              31   // DEVIV (eventual replacement for devmsin)

#define PACKAGE_ESPRESSO_PRJ    51
#define PACKAGE_ESPRESSO_RESTBL 52

#define PACKAGE_PARTNER        100   // Package wizard initial ID.
#define PACKAGE_SIMPLE         101   // DEVPKG (Sample package)

#define PACKET_NIL      UINT(-1)    // For dockable windows with no command ui.

// This is for internal use by the system only
#define PACKET_SHARED   UINT(-2)    // the command is shared by more than one packet

// REVIEW(davidga): move these into Espresso?
// Packet IDs for Espresso
//
#define RESTBL_PACKET           2
#define PROJECT_PACKET          3

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Resource and string ID ranges
//

//  Sample Package
#define MIN_SAMPLE_RESOURCE_ID     0        // 0000
#define MAX_SAMPLE_RESOURCE_ID   399        // 018f
//  Espresso
#define MIN_ESPRESSO_RESOURCE_ID 12000       // 2EE0
#define MAX_ESPRESSO_RESOURCE_ID 12999       // 32C7
//  Test
#define MIN_TEST_RESOURCE_ID    2000        // 07d0
#define MAX_TEST_RESOURCE_ID    2991        // 0baf
//  Fortran
#define MIN_FORTRAN_RESOURCE_ID 2992        // 0bb0
#define MAX_FORTRAN_RESOURCE_ID 3999        // 0f9f
//  Intel x86 for Fortran
#define MIN_X86FOR_RESOURCE_ID  4000        // 0fa0
#define MAX_X86FOR_RESOURCE_ID  4999        // 1387

// SPACE 5000-5999  (0x1388 - 0x176f)

//  Package Partner Package (define one min/max set per partner--0x200 IDs)
//  Partners use 'PARTNER' IDs until a specific range is established for them.
#define MIN_PARTNER_RESOURCE_ID 6000        // 1770
#define MAX_PARTNER_RESOURCE_ID 6495        // 195f
// IATOOL (Interactive Authoring Tool Package)
#define MIN_IATOOL_RESOURCE_ID  6496        // 1960
#define MAX_IATOOL_RESOURCE_ID  6687        // 101f

// SPACE 6688 - 7023 (0x1020 - 0x1b6f)

// HTMLEX (HTML lexer)
#define MIN_HTMLEX_RESOURCE_ID  7024        // 1b70 
#define MAX_HTMLEX_RESOURCE_ID  7039        // 1b7f
// DEVAUT1 (OLE Automation 1)
#define MIN_AUT1_RESOURCE_ID    7040        // 1b80 
#define MAX_AUT1_RESOURCE_ID    7535        // 1d6f
// DEVAUT2 (OLE Automation 2)
#define MIN_AUT2_RESOURCE_ID    7536        // 1d70 
#define MAX_AUT2_RESOURCE_ID    7631        // 1dcf
// DEVHTM
#define MIN_HTM_RESOURCE_ID     7632        // 1dd0 
#define MAX_HTM_RESOURCE_ID     7679        // 1dff
// DEVDTG
#define MIN_DTG_RESOURCE_ID     7680        // 1e00 
#define MAX_DTG_RESOURCE_ID     7759        // 1e4f
// DEVDDK
#define MIN_DDK_RESOURCE_ID     7760        // 1e50 
#define MAX_DDK_RESOURCE_ID     7807        // 1e7f

//  SPACE 7776-9999  (0x1e60 - 0x270f)

// Helpstring IDs (intentionally not contiguous to allow neighbors room
//  to grow)--stored in DEVBLD.PKG, DEVEDIT.PKG, DEVSHL.DLL, DEVDBG.PKG, etc
// These IDs are shared by packages exposing a type library.  Each such package
//  stores its helpstrings in its string table, with IDs in this range.
//  Multiple packages reuse this range, but conflict isn't a problem, since
//  the helpstrings are loaded (by DevTLDc.dll) explicitly from the package.
// Strings shared across type libraries (e.g., helpstring for Application
//  properties) are stored in DevTLDc.dll's string table, with IDs in the range
//  between MIN_SHARED_HELPSTRING_ID and MAX_SHARED_HELPSTRING_ID (see below).
//  This range must not conflict with the SHARED_HELPSTRING_ID range.
#define MIN_HELPSTRING_ID               10000           // 0x2710
#define MAX_HELPSTRING_ID               11000           // 0x2af8

//  NuMega Package
#define MIN_NUMEGA_RESOURCE_ID    11001       // 2af9
#define MAX_NUMEGA_RESOURCE_ID    12500       // 30d4
//  BlueSky Package
#define MIN_BLUESKY_RESOURCE_ID   12501       // 30d5
#define MAX_BLUESKY_RESOURCE_ID   13500       // 34bc
//  Rational Package
#define MIN_RATIONAL_RESOURCE_ID  13501       // 34bd
#define MAX_RATIONAL_RESOURCE_ID  14500       // 38a4

//  SPACE 14501-15583  (0x38a4-0x3cdf)

//  PowerPC
#define MIN_POWERPC_RESOURCE_ID 15584       // 3ce0
#define MAX_POWERPC_RESOURCE_ID 15615       // 3cff
//  PowerMac
#define MIN_POWERMAC_RESOURCE_ID    15616   // 3d00
#define MAX_POWERMAC_RESOURCE_ID    15711   // 3d5f
//  Mips
#define MIN_MIPS_RESOURCE_ID    15712       // 3d60
#define MAX_MIPS_RESOURCE_ID    15775       // 3d9f
//  Alpha
#define MIN_ALPHA_RESOURCE_ID   15776       // 3da0
#define MAX_ALPHA_RESOURCE_ID   15839       // 3ddf
//  Mac68K
#define MIN_68K_RESOURCE_ID     15840       // 3de0
#define MAX_68K_RESOURCE_ID     15919       // 3e2f
//  Intel x86
#define MIN_X86_RESOURCE_ID     15920       // 3e30
#define MAX_X86_RESOURCE_ID     15999       // 3e7f
//  Build package
#define MIN_BUILD_RESOURCE_ID   16000       // 3e80
#define MAX_BUILD_RESOURCE_ID   16991       // 425f
// App wizard
#define MIN_APP_WIZARD_ID       16992       // 4260
#define MAX_APP_WIZARD_ID       17487       // 444f
// Class wizard
#define MIN_CLASS_WIZARD_ID     17488       // 4450
#define MAX_CLASS_WIZARD_ID     17999       // 464f

//  SPACE 18000-19999  (0x4650 - 0x4e1f)

//  Shell
#define MIN_SHARED_RESOURCE_ID  20000       // 4e20
#define MAX_SHARED_RESOURCE_ID  20207       // 4eef
#define MIN_EXE_RESOURCE_ID     20208       // 4f00
#define MAX_EXE_RESOURCE_ID     20287       // 4f3f
#define MIN_EXE_STRING_ID       57344               // e000
#define MAX_EXE_STRING_ID       57359               // e00f
#define MIN_SHELL_RESOURCE_ID   20288       // 4f40
#define MAX_SHELL_RESOURCE_ID   21999       // 55ef

//  Object Gallery
#define MIN_GALLERY_RESOURCE_ID 22000       // 55f0
#define MAX_GALLERY_RESOURCE_ID 22495       // 57df
// HTML
#define MIN_HTML_RESOURCE_ID    22496       // 57e0
#define MAX_HTML_RESOURCE_ID    22591       // 583f

//  SPACE 22592-22991  (0x5840 - 0x59ef)

//  Debug
#define MIN_DEBUG_RESOURCE_ID   24000       // 5dc0
#define MAX_DEBUG_RESOURCE_ID   25951       // 655f
//  CPP LangPackage
#define MIN_CPP_RESOURCE_ID     25952       // 6560
#define MAX_CPP_RESOURCE_ID     25999       // 658f
//  Resource package
#define MIN_RES_RESOURCE_ID     26000       // 6590
#define MAX_RES_RESOURCE_ID     27951       // 6d2f
//  BIN (Binary Editor)
#define MIN_BIN_RESOURCE_ID     27952       // 6d30
#define MAX_BIN_RESOURCE_ID     27967       // 6d3f
//  IMG (Image Editor)
#define MIN_IMG_RESOURCE_ID     27968       // 6d40
#define MAX_IMG_RESOURCE_ID     27999       // 6d5f
//  Edit package
#define MIN_EDIT_RESOURCE_ID    28000       // 6d60
#define MAX_EDIT_RESOURCE_ID    28527       // 6f6f
//  Odl package
#define MIN_ODL_RESOURCE_ID     28528       // 6f70
#define MAX_ODL_RESOURCE_ID     28591       // 6faf

//  SPACE 28591-28991  (0x6faf - 0x713f)

//  MSIN
#define MIN_MSIN_RESOURCE_ID    28992       // 7140
#define MAX_MSIN_RESOURCE_ID    29999       // 752f

//  IV
#define MIN_IV_RESOURCE_ID      30000       // 7530
#define MAX_IV_RESOURCE_ID      30499       // 7723

//  SPACE 30500-30992

//  Proj
#define MIN_WORKSPACE_RESOURCE_ID   30992   // 7910
#define MAX_WORKSPACE_RESOURCE_ID   31999   // 7cff
//  ClsView
#define MIN_CLSVIEW_RESOURCE_ID 32000       // 7d00
#define MAX_CLSVIEW_RESOURCE_ID 32095       // 7d5f
//  ENT (Galileo)  
#define MIN_ENT_RESOURCE_ID     32096       // 7d60
#define MAX_ENT_RESOURCE_ID     32511       // 7eff
// NCB (No Compile Browser)  
#define MIN_NCB_RESOURCE_ID     32512       // 7f00
#define MAX_NCB_RESOURCE_ID     32543       // 7f1f

//  String IDs  (Range 32k to 64k) 
//  These ranges can ONLY be used by string resource types

// IV (InfoViewer)
#define MIN_IV_STRING_ID        30200               // 75f8
#define MAX_IV_STRING_ID        30326               // 7676

//  HTMLEX (HTML Lexer)
#define MIN_HTMLEX_STRING_ID    32768               // 8000
#define MAX_HTMLEX_STRING_ID    32831               // 803f
// NCB (No Compile Browser)
#define MIN_NCB_STRING_ID       32832               // 8040
#define MAX_NCB_STRING_ID       32895               // 807f
//  IATool (Interactive Authoring Tool Package)
#define MIN_IATOOL_STRING_ID    32896               // 8080
#define MAX_IATOOL_STRING_ID    33951               // 849f

// SPACE 33952 - 34671 (84a0 - 879f)

//  Odl package
#define MIN_ODL_STRING_ID       34672               // 8770
#define MAX_ODL_STRING_ID       34719               // 879f

//  SPACE 34719-35007  (0x879f - 0x88bf)

// CLASSVIEW
#define MIN_CLASSVIEW_STRING_ID 35008               // 88c0
#define MAX_CLASSVIEW_STRING_ID 35103               // 891f
// HTM
#define MIN_HTM_STRING_ID       35104               // 8920
#define MAX_HTM_STRING_ID       35295               // 89df
// DTG
#define MIN_DTG_STRING_ID       35296               // 89e0
#define MAX_DTG_STRING_ID       35839               // 8bff
// DDK
#define MIN_DDK_STRING_ID       35840               // 8c00
#define MAX_DDK_STRING_ID       35935               // 8c5f
// POWERPC
#define MIN_POWERPC_STRING_ID   35936               // 8c60
#define MAX_POWERPC_STRING_ID   35999               // 8c9f
// LANGCPP
#define MIN_LANGCPP_STRING_ID   36000               // 8ca0
#define MAX_LANGCPP_STRING_ID   36255               // 8d9f
// IST  (Internet Studio) 
#define MIN_IST_STRING_ID       36256               // 8dA0
#define MAX_IST_STRING_ID       37503               // 927F


/////////////////////////////////////////////////////////////////////////////
// Shared resource IDs
//

// resource type ids
// The numbering of these types has been modified to fit with the 
// shared resource numbering scheme. This allows any package
// to use its own resource types in safety. martynl 13May96

// This one is used in entry.rc and the shell package for the default UI layout
#define IDRT_LAYOUT          20000
// Used in various packages (*.rc2 files) to store their encrypted package id information
#define IDRT_PID             20001

// The actual product ID resource number
#define ID_PID               20000

// command table stored in the main executable file
#define IDCT_MAINEXE                    20397

// Dialog controls
#define IDC_CAPTION                     102
#define IDC_ID_CAP                      104
#define IDC_ID                          222
#define IDC_SCC_STATUS                  16830
#define IDC_SCC_STATUS_TEXT             16831

#define IDC_SCC                         21094
#define IDC_SCC_HELPERTEXT              21101
#define IDC_SCC_SEPARATOR               21102

// Resources
#define IDC_CURSOR_RECORD               7066    // Stored in DevAut1.pkg
#define IDR_MAINFRAME                   20000
#define IDR_FIND_SPECIAL                21093 // stored in devshl.dll

#define IDB_SPLASH                      20001
#define IDB_SPLASH16                    20002
#define IDB_ABOUT                       20003
#define IDB_SPLASH16_GR                 20004
#define IDB_SPLASH_GR                   20005

#define IDB_DROP                        20508
#define IDB_DROP95                      21086 
#define IDB_DROPLARGE                   21182
#define IDB_DROP95LARGE                 21183

#define IDB_DROPFLAT                    21200
#define IDB_DROP95FLAT                  21201
#define IDB_DROP95LARGEFLAT             21204
#define IDB_DROPLARGEFLAT               21205

#define IDB_DROPCL                      20544
#define IDB_DROPCL95                    21083
#define IDB_DROPCLLARGE                 21184
#define IDB_DROPCL95LARGE               21185

#define IDB_DROPCR                      20545
#define IDB_DROPCR95                    21084
#define IDB_DROPCRLARGE                 21186
#define IDB_DROPCR95LARGE               21187

#define IDB_DROPDISABLED                20547
#define IDB_DROPDISABLED95              21085
#define IDB_DROPDISABLEDLARGE           21188
#define IDB_DROPDISABLED95LARGE         21189

#define IDC_RIGHT_ARROW                 20001
#define IDC_SIZE_BAR_HORZ               20002
#define IDCUR_VSIZE                     20003
#define IDCUR_COPY                      20004

#define IDD_ABOUTBOX                    20001
#define IDD_GOTODIALOG                  20002
#define IDD_PUSHPIN_DIALOGBAR           20003
#define IDD_SUSHI_FILEOPEN              20522
#define IDD_OPTIONS_FONTCOLOR           21080

// Strings
#define IDS_DEBUG_CONFIG                20001
#define IDS_RELEASE_CONFIG              20002
#define IDS_UNDO_PROPEDIT               20003
#define IDS_UNDO_MOVE                   20004
#define IDS_UNDO_COPY                    20005
#define IDS_UNDO_PASTE                  20006
#define IDS_UNDO_CUT                    20007
#define IDS_UNDO_DELETE                 20008
#define IDS_ABOUTTITLE                  20009
#define IDS_COPYRIGHT                   20010
#define IDS_PRODUCTLICENSEDTO           20011
#define IDS_SERIALNUMBER                20012
#define IDS_ADDITIONS                   20013
#define IDS_PID                         20014
#define IDS_WARNING1                    20015
#define IDS_WARNING2                    20016
#define IDS_WARNING3                    20017
#define IDS_WARNING4                    20018
#define IDS_WARNING5                    20019
#define IDS_WARNING6                    20020
#define IDS_WARNING7                    20021
#define IDS_NOMATHCHIP                  20022
#define IDS_HASMATHCHIP                 20023
#define IDS_FMTFREESPACE                20024
#define IDS_UNAVAILABLE                 20025
#define IDS_FMTAVAILMEM                 20026
#define IDS_CANT_LOAD_PACKAGE           20027
#define IDS_CANT_LOAD_MAC               20028
#define IDS_LICENSEDTO                  20029
#define IDS_GENERAL                     20030
#define IDS_STYLES                      20031
#define IDS_EXSTYLES                    20032
#define IDS_UNNAMED                     20033
#define IDS_ABOUTTITLEPADDING           20034
#define IDS_DSPROJ_SIG_STRING           20035
#define IDS_PACKAGE_OWNER               20036
#define IDS_KEYBOARD                    20037
#define IDS_COMMANDS                    20038
#define IDS_DSPROJ_NAME                 20039

#define IDS_MOVETO                      27997
#define IDS_ROCOMMENT                   27998
#define IDS_ERROR_CANT_SAVERO2          27999

// Shared Help String Context IDs--strings stored in DEVTLDC.DLL
// These are IDs used in the string table of DevTLDc.dll and are referenced
//  by type libraries via helpstringcontext attribute.  These strings are
//  NOT stored in devshl.dll-- they're in DevTLDc.dll.  As long as these IDs
//  don't collide with the HELPSTRING_ID range (see above) no conflicts can
//  arise.
#define MIN_SHARED_HELPSTRING_ID                1000
#define MAX_SHARED_HELPSTRING_ID                2000
// The following strings are all between the above two ranges.

// Misc. Shared help strings.
#define MIN_HS_SHARED                                                   MIN_SHARED_HELPSTRING_ID
#define IDS_HS_SHARED_APPLICATION                               MIN_HS_SHARED
#define IDS_HS_SHARED_PARENT                                    (IDS_HS_SHARED_APPLICATION+1)
#define MAX_HS_SHARED                                                   (IDS_HS_SHARED_PARENT+1)

// Help strings for IGenericDocument.
#define IDS_HS_GENERICDOCUMENT                                  MAX_HS_SHARED
#define IDS_HS_GENERICDOCUMENT_NAME                             (IDS_HS_GENERICDOCUMENT+1)
#define IDS_HS_GENERICDOCUMENT_FULLNAME                 (IDS_HS_GENERICDOCUMENT+2)
#define IDS_HS_GENERICDOCUMENT_PATH                             (IDS_HS_GENERICDOCUMENT+3)
#define IDS_HS_GENERICDOCUMENT_SAVED                    (IDS_HS_GENERICDOCUMENT+4)
#define IDS_HS_GENERICDOCUMENT_ACTIVEWINDOW             (IDS_HS_GENERICDOCUMENT+5)
#define IDS_HS_GENERICDOCUMENT_READONLY                 (IDS_HS_GENERICDOCUMENT+6)
#define IDS_HS_GENERICDOCUMENT_TYPE                             (IDS_HS_GENERICDOCUMENT+7)
#define IDS_HS_GENERICDOCUMENT_WINDOWS                  (IDS_HS_GENERICDOCUMENT+8)
#define IDS_HS_GENERICDOCUMENT_NEWWINDOW                (IDS_HS_GENERICDOCUMENT+9)
#define IDS_HS_GENERICDOCUMENT_SAVE                             (IDS_HS_GENERICDOCUMENT+10)
#define IDS_HS_GENERICDOCUMENT_CLOSE                    (IDS_HS_GENERICDOCUMENT+11)
#define IDS_HS_GENERICDOCUMENT_UNDO                             (IDS_HS_GENERICDOCUMENT+12)
#define IDS_HS_GENERICDOCUMENT_REDO                             (IDS_HS_GENERICDOCUMENT+13)
#define IDS_HS_GENERICDOCUMENT_PRINTOUT                 (IDS_HS_GENERICDOCUMENT+14)
#define IDS_HS_GENERICDOCUMENT_ACTIVE                   (IDS_HS_GENERICDOCUMENT+15)
#define IDS_HS_GENERICDOCUMENT_max                              (IDS_HS_GENERICDOCUMENT+17)

// Help strings for IGenericWindow
#define IDS_HS_GENERICWINDOW                                    IDS_HS_GENERICDOCUMENT_max
#define IDS_HS_GENERICWINDOW_CAPTION                    (IDS_HS_GENERICWINDOW+1)
#define IDS_HS_GENERICWINDOW_TYPE                               (IDS_HS_GENERICWINDOW+2)
#define IDS_HS_GENERICWINDOW_ACTIVE                     (IDS_HS_GENERICWINDOW+3)
#define IDS_HS_GENERICWINDOW_LEFT                               (IDS_HS_GENERICWINDOW+4)
#define IDS_HS_GENERICWINDOW_TOP                                (IDS_HS_GENERICWINDOW+5)
#define IDS_HS_GENERICWINDOW_WIDTH                              (IDS_HS_GENERICWINDOW+6)
#define IDS_HS_GENERICWINDOW_HEIGHT                     (IDS_HS_GENERICWINDOW+7)
#define IDS_HS_GENERICWINDOW_INDEX                              (IDS_HS_GENERICWINDOW+8)
#define IDS_HS_GENERICWINDOW_NEXT                               (IDS_HS_GENERICWINDOW+9)
#define IDS_HS_GENERICWINDOW_PREVIOUS                   (IDS_HS_GENERICWINDOW+10)
#define IDS_HS_GENERICWINDOW_WINDOWSTATE                (IDS_HS_GENERICWINDOW+11)
#define IDS_HS_GENERICWINDOW_CLOSE                              (IDS_HS_GENERICWINDOW+12)
#define IDS_HS_GENERICWINDOW_PARENT                     (IDS_HS_GENERICWINDOW+13)
#define IDS_HS_GENERICWINDOW_max                                (IDS_HS_GENERICWINDOW+14)


// Help strings for IGenericProject
#define IDS_HS_GENERICPROJECT                                   IDS_HS_GENERICWINDOW_max
#define IDS_HS_GENERICPROJECT_NAME                              (IDS_HS_GENERICPROJECT+1)
#define IDS_HS_GENERICPROJECT_FULLNAME                  (IDS_HS_GENERICPROJECT+2)
#define IDS_HS_GENERICPROJECT_TYPE                              (IDS_HS_GENERICPROJECT+3)
#define IDS_HS_GENERICPROJECT_max                               (IDS_HS_GENERICPROJECT+4)

// Help strings for enums and other constants

// Help strings for DsWindowState
#define IDS_HS_DSWINDOWSTATE                                    IDS_HS_GENERICPROJECT_max
#define IDS_HS_DSWINDOWSTATE_MAXIMIZED                  (IDS_HS_DSWINDOWSTATE+1)
#define IDS_HS_DSWINDOWSTATE_MINIMIZED                  (IDS_HS_DSWINDOWSTATE+2)
#define IDS_HS_DSWINDOWSTATE_NORMAL                     (IDS_HS_DSWINDOWSTATE+3)
#define IDS_HS_DSWINDOWSTATE_max                                (IDS_HS_DSWINDOWSTATE+4)


// Help strings for DsArrangeStyle
#define IDS_HS_DSARRANGESTYE                                    IDS_HS_DSWINDOWSTATE_max
#define IDS_HS_DSARRANGESTYE_MINIMIZE                   (IDS_HS_DSARRANGESTYE+1)
#define IDS_HS_DSARRANGESTYE_TILEHORIZONTAL     (IDS_HS_DSARRANGESTYE+2)
#define IDS_HS_DSARRANGESTYE_TILEVERTICAL               (IDS_HS_DSARRANGESTYE+3)
#define IDS_HS_DSARRANGESTYE_CASCADE                    (IDS_HS_DSARRANGESTYE+4)
#define IDS_HS_DSARRANGESTYE_max                                (IDS_HS_DSARRANGESTYE+5)


// Help strings for DsButtonType 
#define IDS_HS_DSBUTTONTYPE                                     IDS_HS_DSARRANGESTYE_max
#define IDS_HS_DSBUTTONTYPE_GLYPH                               (IDS_HS_DSBUTTONTYPE+1)
#define IDS_HS_DSBUTTONTYPE_TEXT                                (IDS_HS_DSBUTTONTYPE+2)
#define IDS_HS_DSBUTTONTYPE_max                                 (IDS_HS_DSBUTTONTYPE+3)

// Help string for DsSaveChanges
#define IDS_HS_DSSAVECHANGES                                    IDS_HS_DSBUTTONTYPE_max
#define IDS_HS_DSSAVECHANGES_YES                                (IDS_HS_DSSAVECHANGES+1)
#define IDS_HS_DSSAVECHANGES_NO                                 (IDS_HS_DSSAVECHANGES+2)
#define IDS_HS_DSSAVECHANGES_PROMPT                     (IDS_HS_DSSAVECHANGES+3)
#define IDS_HS_DSSAVECHANGES_max                                (IDS_HS_DSSAVECHANGES+4)

// Help string for DsSaveStatus
#define IDS_HS_DSAVESTATUS                                              IDS_HS_DSSAVECHANGES_max
#define IDS_HS_DSAVESTATUS_SUCCEEDED                    (IDS_HS_DSAVESTATUS+1)
#define IDS_HS_DSAVESTATUS_CANCELED                     (IDS_HS_DSAVESTATUS+2)
#define IDS_HS_DSAVESTATUS_max                                  (IDS_HS_DSAVESTATUS+3)

/////////////////////////////////////////////////////////////////////////////
//
//  Resource Editors
//
/////////////////////////////////////////////////////////////////////////////
#define IDS_HS_DLGEDITOR                    2000
#define IDS_HS_DLGEDITOR_ID                 2001
#define IDS_HS_DLGEDITOR_CAPTION            2002
#define IDS_HS_DLGEDITOR_MENU               2003
#define IDS_HS_DLGEDITOR_FONTNAME           2004
#define IDS_HS_DLGEDITOR_FONTSIZE           2005
#define IDS_HS_DLGEDITOR_XPOS               2006
#define IDS_HS_DLGEDITOR_YPOS               2007
#define IDS_HS_DLGEDITOR_STYLE              2008
#define IDS_HS_DLGEDITOR_BORDER             2009
#define IDS_HS_DLGEDITOR_TITLEBAR           2010
#define IDS_HS_DLGEDITOR_SYSTEMMENU         2011
#define IDS_HS_DLGEDITOR_MINIMIZEBOX        2012
#define IDS_HS_DLGEDITOR_MAXIMIZEBOX        2013
#define IDS_HS_DLGEDITOR_CLIPSIBLINGS       2014
#define IDS_HS_DLGEDITOR_HORIZONTALSCROLL   2015
#define IDS_HS_DLGEDITOR_VERTICALSCROLL     2016
#define IDS_HS_DLGEDITOR_SYSTEMMODAL        2017
#define IDS_HS_DLGEDITOR_ABSOLUTEALIGN      2018
#define IDS_HS_DLGEDITOR_VISIBLE            2019
#define IDS_HS_DLGEDITOR_CONTEXTHELP        2020
#define IDS_HS_DLGEDITOR_SETFOREGROUND      2021
#define IDS_HS_DLGEDITOR_THREEDLOOK         2022
#define IDS_HS_DLGEDITOR_NOFAILCREATE       2023
#define IDS_HS_DLGEDITOR_NOIDLEMESSAGE      2024
#define IDS_HS_DLGEDITOR_CONTROL            2025
#define IDS_HS_DLGEDITOR_CENTER             2026
#define IDS_HS_DLGEDITOR_CENTERMOUSE        2027
#define IDS_HS_DLGEDITOR_LOCALEDIT          2028
#define IDS_HS_DLGEDITOR_TOOLWINDOW         2029
#define IDS_HS_DLGEDITOR_CLIENTEDGE         2030
#define IDS_HS_DLGEDITOR_STATICEDGE         2031
#define IDS_HS_DLGEDITOR_TRANSPARENT        2032
#define IDS_HS_DLGEDITOR_ACCEPTFILES        2033
#define IDS_HS_DLGEDITOR_CONTROLPARENT      2034
#define IDS_HS_DLGEDITOR_NOPARENTNOTIFY     2035
#define IDS_HS_DLGEDITOR_RTLREADINGORDER    2036
#define IDS_HS_DLGEDITOR_RIGHTALIGNEDTEXT   2037
#define IDS_HS_DLGEDITOR_LEFTSCROLLBAR      2038
#define IDS_HS_DLGEDITOR_DLGMODALFRAME      2039
#define IDS_HS_DLGEDITOR_CLIPCHILDREN       2040
#define IDS_HS_DLGEDITOR_DISABLED           2041
#define IDS_HS_DLGEDITOR_SHELLFONT          2736
// More Dialog Properties are defined below ( IDS_HS_DLGEDITOR_APPWINDOW)

#define IDS_HS_PICT                         2042
#define IDS_HS_PICT_ID                      2043
#define IDS_HS_PICT_VISIBLE                 2044
#define IDS_HS_PICT_DISABLED                2045
#define IDS_HS_PICT_HELPID                  2046
#define IDS_HS_PICT_GROUP                   2047
#define IDS_HS_PICT_TABSTOP                 2048
#define IDS_HS_PICT_TYPE                    2049
#define IDS_HS_PICT_IMAGE                   2050
#define IDS_HS_PICT_COLOR                   2051
#define IDS_HS_PICT_SUNKEN                  2052
#define IDS_HS_PICT_BORDER                  2053
#define IDS_HS_PICT_NOTIFY                  2054
#define IDS_HS_PICT_CENTERIMAGE             2055
#define IDS_HS_PICT_RIGHTJUSTIFY            2056
#define IDS_HS_PICT_REALSIZEIMAGE           2057
#define IDS_HS_PICT_CLIENTEDGE              2058
#define IDS_HS_PICT_STATICEDGE              2059
#define IDS_HS_PICT_MODALFRAME              2060
#define IDS_HS_PICT_TRANSPARENT             2061
#define IDS_HS_PICT_ACCEPTFILES             2062

#define IDS_HS_STATIC                       2063
#define IDS_HS_STATIC_ID                    2064
#define IDS_HS_STATIC_VISIBLE               2065
#define IDS_HS_STATIC_DISABLED              2066
#define IDS_HS_STATIC_HELPID                2067
#define IDS_HS_STATIC_GROUP                 2068
#define IDS_HS_STATIC_TABSTOP               2069
#define IDS_HS_STATIC_CAPTION               2070
#define IDS_HS_STATIC_ALIGNTEXT             2071
#define IDS_HS_STATIC_CENTERVERTICALLY      2072
#define IDS_HS_STATIC_NOPREFIX              2073
#define IDS_HS_STATIC_NOWRAP                2074
#define IDS_HS_STATIC_SIMPLE                2075
#define IDS_HS_STATIC_NOTIFY                2076
#define IDS_HS_STATIC_SUNKEN                2077
#define IDS_HS_STATIC_BORDER                2078
#define IDS_HS_STATIC_CLIENTEDGE            2079
#define IDS_HS_STATIC_STATICEDGE            2080
#define IDS_HS_STATIC_MODALFRAME            2081
#define IDS_HS_STATIC_TRANSPARENT           2082
#define IDS_HS_STATIC_ACCEPTFILES           2083
#define IDS_HS_STATIC_RIGHTALIGNTEXT        2084
#define IDS_HS_STATIC_RTLREADINGORDER       2085

#define IDS_HS_EDBOX                        2086
#define IDS_HS_EDBOX_ID                     2087
#define IDS_HS_EDBOX_VISIBLE                2088
#define IDS_HS_EDBOX_DISABLED               2089
#define IDS_HS_EDBOX_HELPID                 2090
#define IDS_HS_EDBOX_GROUP                  2091
#define IDS_HS_EDBOX_TABSTOP                2092
#define IDS_HS_EDBOX_ALIGNTEXT              2093
#define IDS_HS_EDBOX_MULTILINE              2094
#define IDS_HS_EDBOX_NUMBER                 2095
#define IDS_HS_EDBOX_HORIZONTALSCROLL       2096
#define IDS_HS_EDBOX_AUTOHSCROLL            2097
#define IDS_HS_EDBOX_VERTICALSCROLL         2098
#define IDS_HS_EDBOX_AUTOVSCROLL            2099
#define IDS_HS_EDBOX_PASSWORD               2100
#define IDS_HS_EDBOX_NOHIDESELECTION        2101
#define IDS_HS_EDBOX_OEMCONVERT             2102
#define IDS_HS_EDBOX_WANTRETURN             2103
#define IDS_HS_EDBOX_BORDER                 2104
#define IDS_HS_EDBOX_UPPERCASE              2105
#define IDS_HS_EDBOX_LOWERCASE              2106
#define IDS_HS_EDBOX_READONLY               2107
#define IDS_HS_EDBOX_CLIENTEDGE             2108
#define IDS_HS_EDBOX_STATICEDGE             2109
#define IDS_HS_EDBOX_MODALFRAME             2110
#define IDS_HS_EDBOX_TRANSPARENT            2111
#define IDS_HS_EDBOX_ACCEPTFILES            2112
#define IDS_HS_EDBOX_RIGHTALIGNTEXT         2113
#define IDS_HS_EDBOX_RTLREADINGORDER        2114
#define IDS_HS_EDBOX_LEFTSCROLLBAR          2115

#define IDS_HS_GROUPBOX                     2116
#define IDS_HS_GROUPBOX_ID                  2117
#define IDS_HS_GROUPBOX_VISIBLE             2118
#define IDS_HS_GROUPBOX_DISABLED            2119
#define IDS_HS_GROUPBOX_HELPID              2120
#define IDS_HS_GROUPBOX_GROUP               2121
#define IDS_HS_GROUPBOX_TABSTOP             2122
#define IDS_HS_GROUPBOX_CAPTION             2123
#define IDS_HS_GROUPBOX_HORIZONTALALIGNMENT 2124
#define IDS_HS_GROUPBOX_ICON                2125
#define IDS_HS_GROUPBOX_BITMAP              2126
#define IDS_HS_GROUPBOX_NOTIFY              2127
#define IDS_HS_GROUPBOX_FLAT                2128
#define IDS_HS_GROUPBOX_CLIENTEDGE          2129
#define IDS_HS_GROUPBOX_STATICEDGE          2130
#define IDS_HS_GROUPBOX_MODALFRAME          2131
#define IDS_HS_GROUPBOX_TRANSPARENT         2132
#define IDS_HS_GROUPBOX_ACCEPTFILES         2133
#define IDS_HS_GROUPBOX_RIGHTALIGNTEXT      2134
#define IDS_HS_GROUPBOX_RTLREADING          2135

#define IDS_HS_BUTTON                       2136
#define IDS_HS_BUTTON_ID                    2137
#define IDS_HS_BUTTON_VISIBLE               2138
#define IDS_HS_BUTTON_DISABLED              2139
#define IDS_HS_BUTTON_GROUP                 2140
#define IDS_HS_BUTTON_TABSTOP               2141
#define IDS_HS_BUTTON_HELPID                2142
#define IDS_HS_BUTTON_CAPTION               2143
#define IDS_HS_BUTTON_HORIZONTALALIGNMENT   2144
#define IDS_HS_BUTTON_VERTICALALIGNMENT     2145
#define IDS_HS_BUTTON_ICON                  2146
#define IDS_HS_BUTTON_BITMAP                2147
#define IDS_HS_BUTTON_NOTIFY                2148
#define IDS_HS_BUTTON_FLAT                  2149
#define IDS_HS_BUTTON_DEFAULTBUTTON         2150
#define IDS_HS_BUTTON_OWNERDRAW             2151
#define IDS_HS_BUTTON_MULTILINE             2152
#define IDS_HS_BUTTON_CLIENTEDGE            2153
#define IDS_HS_BUTTON_STATICEDGE            2154
#define IDS_HS_BUTTON_MODALFRAME            2155
#define IDS_HS_BUTTON_TRANSPARENT           2156
#define IDS_HS_BUTTON_ACCEPTFILES           2157
#define IDS_HS_BUTTON_RIGHTALIGNTEXT        2158
#define IDS_HS_BUTTON_RTLREADING            2159

#define IDS_HS_CHECK                        2160
#define IDS_HS_CHECK_ID                     2161
#define IDS_HS_CHECK_VISIBLE                2162
#define IDS_HS_CHECK_DISABLED               2163
#define IDS_HS_CHECK_GROUP                  2164
#define IDS_HS_CHECK_TABSTOP                2165
#define IDS_HS_CHECK_HELPID                 2166
#define IDS_HS_CHECK_CAPTION                2167
#define IDS_HS_CHECK_AUTO                   2168
#define IDS_HS_CHECK_LEFTTEXT               2169
#define IDS_HS_CHECK_TRISTATE               2170
#define IDS_HS_CHECK_PUSHLIKE               2171
#define IDS_HS_CHECK_MULTILINE              2172
#define IDS_HS_CHECK_NOTIFY                 2173
#define IDS_HS_CHECK_FLAT                   2174
#define IDS_HS_CHECK_ICON                   2175
#define IDS_HS_CHECK_BITMAP                 2176
#define IDS_HS_CHECK_HORIZONTALALIGNMENT    2177
#define IDS_HS_CHECK_VERTICALALIGNMENT      2178
#define IDS_HS_CHECK_CLIENTEDGE             2179
#define IDS_HS_CHECK_STATICEDGE             2180
#define IDS_HS_CHECK_MODALFRAME             2181
#define IDS_HS_CHECK_TRANSPARENT            2182
#define IDS_HS_CHECK_ACCEPTFILES            2183
#define IDS_HS_CHECK_RIGHTALIGNTEXT         2184
#define IDS_HS_CHECK_RTLREADING             2185

#define IDS_HS_RADIO                        2186
#define IDS_HS_RADIO_ID                     2187
#define IDS_HS_RADIO_VISIBLE                2188
#define IDS_HS_RADIO_DISABLED               2189
#define IDS_HS_RADIO_GROUP                  2190
#define IDS_HS_RADIO_TABSTOP                2191
#define IDS_HS_RADIO_HELPID                 2192
#define IDS_HS_RADIO_CAPTION                2193
#define IDS_HS_RADIO_AUTO                   2194
#define IDS_HS_RADIO_LEFTTEXT               2195
#define IDS_HS_RADIO_PUSHLIKE               2196
#define IDS_HS_RADIO_MULTILINE              2197
#define IDS_HS_RADIO_NOTIFY                 2198
#define IDS_HS_RADIO_FLAT                   2199
#define IDS_HS_RADIO_ICON                   2200
#define IDS_HS_RADIO_BITMAP                 2201
#define IDS_HS_RADIO_HORIZONTALALIGNMENT    2202
#define IDS_HS_RADIO_VERTICALALIGNMENT      2203
#define IDS_HS_RADIO_CLIENTEDGE             2204
#define IDS_HS_RADIO_STATICEDGE             2205
#define IDS_HS_RADIO_MODALFRAME             2206
#define IDS_HS_RADIO_TRANSPARENT            2207
#define IDS_HS_RADIO_ACCEPTFILES            2208
#define IDS_HS_RADIO_RIGHTALIGNTEXT         2209
#define IDS_HS_RADIO_RTLREADING             2210
                                            
#define IDS_HS_HORZSCROLL                   2211
#define IDS_HS_HORZSCROLL_ID                2212
#define IDS_HS_HORZSCROLL_VISIBLE           2213
#define IDS_HS_HORZSCROLL_DISABLED          2214
#define IDS_HS_HORZSCROLL_GROUP             2215
#define IDS_HS_HORZSCROLL_TABSTOP           2216
#define IDS_HS_HORZSCROLL_HELPID            2217
#define IDS_HS_HORZSCROLL_ALIGN             2218
                                            
#define IDS_HS_VERSCROLL                    2219
#define IDS_HS_VERSCROLL_ID                 2220
#define IDS_HS_VERSCROLL_VISIBLE            2221
#define IDS_HS_VERSCROLL_DISABLED           2222
#define IDS_HS_VERSCROLL_GROUP              2223
#define IDS_HS_VERSCROLL_TABSTOP            2224
#define IDS_HS_VERSCROLL_HELPID             2225
#define IDS_HS_VERSCROLL_ALIGN              2226
                                            
#define IDS_HS_PROGRESS                     2227
#define IDS_HS_PROGRESS_ID                  2228
#define IDS_HS_PROGRESS_VISIBLE             2229
#define IDS_HS_PROGRESS_DISABLED            2230
#define IDS_HS_PROGRESS_GROUP               2231
#define IDS_HS_PROGRESS_TABSTOP             2232
#define IDS_HS_PROGRESS_HELPID              2233
#define IDS_HS_PROGRESS_BORDER              2234
#define IDS_HS_PROGRESS_VERTICAL            2235
#define IDS_HS_PROGRESS_SMOOTH              2236
#define IDS_HS_PROGRESS_CLIENTEDGE          2237
#define IDS_HS_PROGRESS_STATICEDGE          2238
#define IDS_HS_PROGRESS_MODALFRAME          2239
#define IDS_HS_PROGRESS_TRANSPARENT         2240
#define IDS_HS_PROGRESS_ACCEPTFILES         2241

#define IDS_HS_SPIN                         2242
#define IDS_HS_SPIN_ID                      2243
#define IDS_HS_SPIN_VISIBLE                 2244
#define IDS_HS_SPIN_DISABLED                2245
#define IDS_HS_SPIN_GROUP                   2246
#define IDS_HS_SPIN_TABSTOP                 2247
#define IDS_HS_SPIN_HELPID                  2248
#define IDS_HS_SPIN_ORIENTATION             2249
#define IDS_HS_SPIN_ALIGNMENT               2250
#define IDS_HS_SPIN_AUTOBUDDY               2251
#define IDS_HS_SPIN_SETBUDDYINTEGER         2252
#define IDS_HS_SPIN_NOTHOUSANDS             2253
#define IDS_HS_SPIN_WRAP                    2254
#define IDS_HS_SPIN_ARROWKEYS               2255
#define IDS_HS_SPIN_HOTTRACK                2256
#define IDS_HS_SPIN_CLIENTEDGE              2257
#define IDS_HS_SPIN_STATICEDGE              2258
#define IDS_HS_SPIN_MODALFRAME              2259
#define IDS_HS_SPIN_TRANSPARENT             2260
#define IDS_HS_SPIN_ACCEPTFILES             2261
                                            
#define IDS_HS_SLIDER                       2262
#define IDS_HS_SLIDER_ID                    2263
#define IDS_HS_SLIDER_VISIBLE               2264
#define IDS_HS_SLIDER_DISABLED              2265
#define IDS_HS_SLIDER_GROUP                 2266
#define IDS_HS_SLIDER_TABSTOP               2267
#define IDS_HS_SLIDER_HELPID                2268
#define IDS_HS_SLIDER_ORIENTATION           2269
#define IDS_HS_SLIDER_POINT                 2270
#define IDS_HS_SLIDER_TICKMARKS             2271
#define IDS_HS_SLIDER_AUTOTICKS             2272
#define IDS_HS_SLIDER_TOOLTIPS              2273
#define IDS_HS_SLIDER_BORDER                2274
#define IDS_HS_SLIDER_ENABLESELECTION       2275
#define IDS_HS_SLIDER_CLIENTEDGE            2276
#define IDS_HS_SLIDER_STATICEDGE            2277
#define IDS_HS_SLIDER_MODALFRAME            2278
#define IDS_HS_SLIDER_TRANSPARENT           2279
#define IDS_HS_SLIDER_ACCEPTFILES           2280

#define IDS_HS_HOTKEY                       2281
#define IDS_HS_HOTKEY_ID                    2282
#define IDS_HS_HOTKEY_VISIBLE               2283
#define IDS_HS_HOTKEY_DISABLED              2284
#define IDS_HS_HOTKEY_GROUP                 2285
#define IDS_HS_HOTKEY_TABSTOP               2286
#define IDS_HS_HOTKEY_HELPID                2287
#define IDS_HS_HOTKEY_CLIENTEDGE            2288
#define IDS_HS_HOTKEY_STATICEDGE            2289
#define IDS_HS_HOTKEY_MODALFRAME            2290
#define IDS_HS_HOTKEY_TRANSPARENT           2291
#define IDS_HS_HOTKEY_ACCEPTFILES           2292
#define IDS_HS_HOTKEY_RIGHTALIGNTEXT        2293
#define IDS_HS_HOTKEY_RTLREADINGORDER       2294

#define IDS_HS_LIST                         2295
#define IDS_HS_LIST_ID                      2296
#define IDS_HS_LIST_VISIBLE                 2297
#define IDS_HS_LIST_DISABLED                2298
#define IDS_HS_LIST_GROUP                   2299
#define IDS_HS_LIST_TABSTOP                 2300
#define IDS_HS_LIST_HELPID                  2301
#define IDS_HS_LIST_VIEW                    2302
#define IDS_HS_LIST_ALIGN                   2303
#define IDS_HS_LIST_SORT                    2304
#define IDS_HS_LIST_SINGLESELECTION         2305
#define IDS_HS_LIST_AUTOARRANGE             2306
#define IDS_HS_LIST_NOLABELWRAP             2307
#define IDS_HS_LIST_EDITLABELS              2308
#define IDS_HS_LIST_NOSCROLL                2309
#define IDS_HS_LIST_NOCOLUMNHEADER          2310
#define IDS_HS_LIST_ALWAYSSHOWSELECTION     2311
#define IDS_HS_LIST_OWNERDRAWFIXED          2312
#define IDS_HS_LIST_OWNERDATA               2313
#define IDS_HS_LIST_SHAREIMAGELIST          2314
#define IDS_HS_LIST_BORDER                  2315
#define IDS_HS_LIST_CLIENTEDGE              2316
#define IDS_HS_LIST_STATICEDGE              2317
#define IDS_HS_LIST_MODALFRAME              2318
#define IDS_HS_LIST_TRANSPARENT             2319
#define IDS_HS_LIST_ACCEPTFILES             2320
#define IDS_HS_LIST_RIGHTALIGNTEXT          2321
#define IDS_HS_LIST_LEFTSCROLLBAR           2322
#define IDS_HS_LIST_NOSORTHEADER            2323

#define IDS_HS_TREE                         2324
#define IDS_HS_TREE_ID                      2325
#define IDS_HS_TREE_VISIBLE                 2326
#define IDS_HS_TREE_DISABLED                2327
#define IDS_HS_TREE_GROUP                   2328
#define IDS_HS_TREE_TABSTOP                 2329
#define IDS_HS_TREE_HELPID                  2330
#define IDS_HS_TREE_HASBUTTONS              2331
#define IDS_HS_TREE_HASLINES                2332
#define IDS_HS_TREE_LINESATROOT             2333
#define IDS_HS_TREE_EDITLABELS              2334
#define IDS_HS_TREE_DISABLEDRAGDROP         2335
#define IDS_HS_TREE_BORDER                  2336
#define IDS_HS_TREE_ALWAYSSHOWSELECTION     2337
#define IDS_HS_TREE_CHECKBOXES              2338
#define IDS_HS_TREE_FULLROWSELECT           2339
#define IDS_HS_TREE_INFOTIP                 2340
#define IDS_HS_TREE_SCROLL                  2341
#define IDS_HS_TREE_TOOLTIPS                2342
#define IDS_HS_TREE_NONEVENHEIGHT           2343
#define IDS_HS_TREE_TRACKSELECT             2344
#define IDS_HS_TREE_SINGLEEXPAND            2345
#define IDS_HS_TREE_CLIENTEDGE              2346
#define IDS_HS_TREE_STATICEDGE              2347
#define IDS_HS_TREE_MODALFRAME              2348
#define IDS_HS_TREE_TRANSPARENT             2349
#define IDS_HS_TREE_ACCEPTFILES             2350
#define IDS_HS_TREE_RIGHTALIGNTEXT          2351
#define IDS_HS_TREE_RTLREADINGORDER         2352
#define IDS_HS_TREE_LEFTSCROLLBAR           2353

#define IDS_HS_TAB                          2354
#define IDS_HS_TAB_ID                       2355
#define IDS_HS_TAB_VISIBLE                  2356
#define IDS_HS_TAB_DISABLED                 2357
#define IDS_HS_TAB_GROUP                    2358
#define IDS_HS_TAB_TABSTOP                  2359
#define IDS_HS_TAB_HELPID                   2360
#define IDS_HS_TAB_ALIGNMENT                2361
#define IDS_HS_TAB_FOCUS                    2362
#define IDS_HS_TAB_BUTTONS                  2363
#define IDS_HS_TAB_TOOLTIPS                 2364
#define IDS_HS_TAB_BORDER                   2365
#define IDS_HS_TAB_MULTILINE                2366
#define IDS_HS_TAB_OWNERDRAWFIXED           2367
#define IDS_HS_TAB_FORCELABELLEFT           2368
#define IDS_HS_TAB_FORCEICONLEFT            2369
#define IDS_HS_TAB_HOTTRACK                 2370
#define IDS_HS_TAB_BOTTOM                   2371
#define IDS_HS_TAB_MULTISELECT              2372
#define IDS_HS_TAB_SCROLLOPPOSITE           2373
#define IDS_HS_TAB_VERTICAL                 2374
#define IDS_HS_TAB_CLIENTEDGE               2375
#define IDS_HS_TAB_STATICEDGE               2376
#define IDS_HS_TAB_MODALFRAME               2377
#define IDS_HS_TAB_TRANSPARENT              2378
#define IDS_HS_TAB_ACCEPTFILES              2379
#define IDS_HS_TAB_RIGHTALIGNTEXT           2380
#define IDS_HS_TAB_RTLREADINGORDER          2381
#define IDS_HS_TAB_FLATBUTTONS              2701

#define IDS_HS_ANI                          2382
#define IDS_HS_ANI_ID                       2383
#define IDS_HS_ANI_VISIBLE                  2384
#define IDS_HS_ANI_DISABLED                 2385
#define IDS_HS_ANI_GROUP                    2386
#define IDS_HS_ANI_TABSTOP                  2387
#define IDS_HS_ANI_HELPID                   2388
#define IDS_HS_ANI_CENTER                   2389
#define IDS_HS_ANI_ANITRANSPARENT           2390
#define IDS_HS_ANI_AUTOPLAY                 2391
#define IDS_HS_ANI_BORDER                   2392
#define IDS_HS_ANI_CLIENTEDGE               2393
#define IDS_HS_ANI_STATICEDGE               2394
#define IDS_HS_ANI_MODALFRAME               2395
#define IDS_HS_ANI_TRANSPARENT              2396
#define IDS_HS_ANI_ACCEPTFILES              2397

#define IDS_HS_RICH                         2398
#define IDS_HS_RICH_ID                      2399
#define IDS_HS_RICH_VISIBLE                 2400
#define IDS_HS_RICH_DISABLED                2401
#define IDS_HS_RICH_GROUP                   2402
#define IDS_HS_RICH_TABSTOP                 2403
#define IDS_HS_RICH_HELPID                  2404
#define IDS_HS_RICH_ALIGNTEXT               2405
#define IDS_HS_RICH_MULTILINE               2406
#define IDS_HS_RICH_NUMBER                  2407
#define IDS_HS_RICH_HORIZONTALSCROLL        2408
#define IDS_HS_RICH_AUTOHSCROLL             2409
#define IDS_HS_RICH_VERTICALSCROLL          2410
#define IDS_HS_RICH_AUTOVSCROLL             2411
#define IDS_HS_RICH_PASSWORD                2412
#define IDS_HS_RICH_NOHIDESELECTION         2413
#define IDS_HS_RICH_OEMCONVERT              2414
#define IDS_HS_RICH_WANTRETURN              2415
#define IDS_HS_RICH_BORDER                  2416
#define IDS_HS_RICH_UPPERCASE               2417
#define IDS_HS_RICH_LOWERCASE               2418
#define IDS_HS_RICH_READONLY                2419
#define IDS_HS_RICH_DISABLENOSCROLL         2420
#define IDS_HS_RICH_CLIENTEDGE              2421
#define IDS_HS_RICH_STATICEDGE              2422
#define IDS_HS_RICH_MODALFRAME              2423
#define IDS_HS_RICH_TRANSPARENT             2424
#define IDS_HS_RICH_ACCEPTFILES             2425
#define IDS_HS_RICH_RIGHTALIGNTEXT          2426
#define IDS_HS_RICH_RTLREADINGORDER         2427
#define IDS_HS_RICH_LEFTSCROLLBAR           2428

#define IDS_HS_DTP                          2429
#define IDS_HS_DTP_ID                       2430
#define IDS_HS_DTP_VISIBLE                  2431
#define IDS_HS_DTP_DISABLED                 2432
#define IDS_HS_DTP_GROUP                    2433
#define IDS_HS_DTP_TABSTOP                  2434
#define IDS_HS_DTP_HELPID                   2435
#define IDS_HS_DTP_FORMAT                   2436
#define IDS_HS_DTP_RIGHTALIGN               2437
#define IDS_HS_DTP_USESPINCONTROL           2438
#define IDS_HS_DTP_SHOWNONE                 2439
#define IDS_HS_DTP_ALLOWEDIT                2440
#define IDS_HS_DTP_CLIENTEDGE               2441
#define IDS_HS_DTP_STATICEDGE               2442
#define IDS_HS_DTP_MODALFRAME               2443
#define IDS_HS_DTP_TRANSPARENT              2444
#define IDS_HS_DTP_ACCEPTFILES              2445
#define IDS_HS_DTP_RIGHTALIGNTEXT           2446
#define IDS_HS_DTP_RTLREADINGORDER          2447
#define IDS_HS_DTP_LEFTSCROLLBAR            2448

#define IDS_HS_CAL                          2449
#define IDS_HS_CAL_ID                       2450
#define IDS_HS_CAL_VISIBLE                  2451
#define IDS_HS_CAL_DISABLED                 2452
#define IDS_HS_CAL_GROUP                    2453
#define IDS_HS_CAL_TABSTOP                  2454
#define IDS_HS_CAL_HELPID                   2455
#define IDS_HS_CAL_DAYSTATES                2456
#define IDS_HS_CAL_MULTISELECT              2457
#define IDS_HS_CAL_NOTODAYCIRCLE            2458
#define IDS_HS_CAL_NOTODAY                  2459
#define IDS_HS_CAL_WEEKNUMBERS              2460
#define IDS_HS_CAL_CLIENTEDGE               2461
#define IDS_HS_CAL_STATICEDGE               2462
#define IDS_HS_CAL_MODALFRAME               2463
#define IDS_HS_CAL_TRANSPARENT              2464
#define IDS_HS_CAL_ACCEPTFILES              2465
#define IDS_HS_CAL_RIGHTALIGNTEXT           2466
#define IDS_HS_CAL_RTLREADINGORDER          2467
#define IDS_HS_CAL_LEFTSCROLLBAR            2468

#define IDS_HS_IP                           2469
#define IDS_HS_IP_ID                        2470
#define IDS_HS_IP_VISIBLE                   2471
#define IDS_HS_IP_DISABLED                  2472
#define IDS_HS_IP_GROUP                     2473
#define IDS_HS_IP_TABSTOP                   2474
#define IDS_HS_IP_HELPID                    2475
#define IDS_HS_IP_CLIENTEDGE                2476
#define IDS_HS_IP_STATICEDGE                2477
#define IDS_HS_IP_MODALFRAME                2478
#define IDS_HS_IP_TRANSPARENT               2479
#define IDS_HS_IP_ACCEPTFILES               2480
#define IDS_HS_IP_RIGHTALIGNTEXT            2481
#define IDS_HS_IP_RTLREADINGORDER           2482
#define IDS_HS_IP_LEFTSCROLLBAR             2483

#define IDS_HS_COMBOEX                      2484
#define IDS_HS_COMBOEX_ID                   2485
#define IDS_HS_COMBOEX_VISIBLE              2486
#define IDS_HS_COMBOEX_DISABLED             2487
#define IDS_HS_COMBOEX_GROUP                2488
#define IDS_HS_COMBOEX_TABSTOP              2489
#define IDS_HS_COMBOEX_HELPID               2490
#define IDS_HS_COMBOEX_TYPE                 2491
#define IDS_HS_COMBOEX_CLIENTEDGE           2492
#define IDS_HS_COMBOEX_STATICEDGE           2493
#define IDS_HS_COMBOEX_MODALFRAME           2494
#define IDS_HS_COMBOEX_TRANSPARENT          2495
#define IDS_HS_COMBOEX_ACCEPTFILES          2496
#define IDS_HS_COMBOEX_RIGHTALIGNTEXT       2497
#define IDS_HS_COMBOEX_RTLREADINGORDER      2498
#define IDS_HS_COMBOEX_LEFTSCROLLBAR        2499

#define IDS_HS_CUSTOM                       2500
#define IDS_HS_CUSTOM_ID                    2501
#define IDS_HS_CUSTOM_VISIBLE               2502
#define IDS_HS_CUSTOM_DISABLED              2503
#define IDS_HS_CUSTOM_HELPID                2504
#define IDS_HS_CUSTOM_GROUP                 2505
#define IDS_HS_CUSTOM_TABSTOP               2506
#define IDS_HS_CUSTOM_CAPTION               2507
#define IDS_HS_CUSTOM_CLASS                 2508
#define IDS_HS_CUSTOM_STYLE                 2509
#define IDS_HS_CUSTOM_EXTENDEDSTYLE         2510

#define IDS_HS_LB                           2511
#define IDS_HS_LB_ID                        2512
#define IDS_HS_LB_VISIBLE                   2513
#define IDS_HS_LB_DISABLED                  2514
#define IDS_HS_LB_GROUP                     2515
#define IDS_HS_LB_TABSTOP                   2516
#define IDS_HS_LB_HELPID                    2517
#define IDS_HS_LB_SELECTION                 2518
#define IDS_HS_LB_OWNERDRAW                 2519
#define IDS_HS_LB_HASSTRINGS                2520
#define IDS_HS_LB_BORDER                    2521
#define IDS_HS_LB_SORT                      2522
#define IDS_HS_LB_NOTIFY                    2523
#define IDS_HS_LB_MULTICOLUMN               2524
#define IDS_HS_LB_HORIZONTALSCROLL          2525
#define IDS_HS_LB_VERTICALSCROLL            2526
#define IDS_HS_LB_NOREDRAW                  2527
#define IDS_HS_LB_USETABSTOPS               2528
#define IDS_HS_LB_WANTKEYINPUT              2529
#define IDS_HS_LB_DISABLENOSCROLL           2530
#define IDS_HS_LB_NOINTEGRALHEIGHT          2531
#define IDS_HS_LB_CLIENTEDGE                2532
#define IDS_HS_LB_STATICEDGE                2533
#define IDS_HS_LB_MODALFRAME                2534
#define IDS_HS_LB_TRANSPARENT               2535
#define IDS_HS_LB_ACCEPTFILES               2536
#define IDS_HS_LB_RIGHTALIGNTEXT            2537
#define IDS_HS_LB_RTLREADINGORDER           2538
#define IDS_HS_LB_LEFTSCROLLBAR             2539
#define IDS_HS_LB_NODATA                    2700

#define IDS_HS_COMBO                        2540
#define IDS_HS_COMBO_ID                     2541
#define IDS_HS_COMBO_VISIBLE                2542
#define IDS_HS_COMBO_DISABLED               2543
#define IDS_HS_COMBO_GROUP                  2544
#define IDS_HS_COMBO_TABSTOP                2545
#define IDS_HS_COMBO_HELPID                 2546
#define IDS_HS_COMBO_TYPE                   2547
#define IDS_HS_COMBO_OWNERDRAW              2548
#define IDS_HS_COMBO_HASSTRINGS             2549
#define IDS_HS_COMBO_SORT                   2550
#define IDS_HS_COMBO_VERTICALSCROLL         2551
#define IDS_HS_COMBO_NOINTEGRALHEIGHT       2552
#define IDS_HS_COMBO_OEMCONVERT             2553
#define IDS_HS_COMBO_AUTOSCROLL             2554
#define IDS_HS_COMBO_DISABLENOSCROLL        2555
#define IDS_HS_COMBO_UPPERCASE              2556
#define IDS_HS_COMBO_LOWERCASE              2557
#define IDS_HS_COMBO_CLIENTEDGE             2558
#define IDS_HS_COMBO_MODALFRAME             2559
#define IDS_HS_COMBO_STATICEDGE             2560
#define IDS_HS_COMBO_TRANSPARENT            2561
#define IDS_HS_COMBO_ACCEPTFILES            2562
#define IDS_HS_COMBO_RIGHTALIGNTEXT         2563
#define IDS_HS_COMBO_RTLREADINGORDER        2564
#define IDS_HS_COMBO_LEFTSCROLLBAR          2565
#define IDS_HS_COMBO_DATA                   2694

#define IDS_HS_SYS                          2716
#define IDS_HS_SYS_ID                       2717
#define IDS_HS_SYS_VISIBLE                  2718
#define IDS_HS_SYS_DISABLED                 2719
#define IDS_HS_SYS_GROUP                    2720
#define IDS_HS_SYS_TABSTOP                  2721
#define IDS_HS_SYS_HELPID                   2722
#define IDS_HS_SYS_CLIENTEDGE               2723
#define IDS_HS_SYS_STATICEDGE               2724
#define IDS_HS_SYS_MODALFRAME               2725
#define IDS_HS_SYS_TRANSPARENT              2726
#define IDS_HS_SYS_ACCEPTFILES              2727
#define IDS_HS_SYS_RIGHTALIGNTEXT           2728
#define IDS_HS_SYS_RTLREADINGORDER          2729
#define IDS_HS_SYS_LEFTSCROLLBAR            2730
#define IDS_HS_SYS_CAPTION                  2731
#define IDS_HS_SYS_FOCUSSED                 2732
#define IDS_HS_SYS_ENABLED                  2733
#define IDS_HS_SYS_VISITED                  2734
#define IDS_HS_SYS_SHELLEXECURL             2735


#define IDS_HS_CUSTOMRES                    2566
#define IDS_HS_CUSTOMRES_ID                 2567
#define IDS_HS_CUSTOMRES_LANGUAGE           2568
#define IDS_HS_CUSTOMRES_CONDITION          2569
#define IDS_HS_CUSTOMRES_FILENAME           2570
#define IDS_HS_CUSTOMRES_EXTERNALFILE       2571

#define IDS_HS_ACCELRES                     2572
#define IDS_HS_ACCELRES_ID                  2573
#define IDS_HS_ACCELRES_LANGUAGE            2574
#define IDS_HS_ACCELRES_CONDITION           2575

#define IDS_HS_DIALOGRES                    2576
#define IDS_HS_DIALOGRES_ID                 2577
#define IDS_HS_DIALOGRES_LANGUAGE           2578
#define IDS_HS_DIALOGRES_CONDITION          2579

#define IDS_HS_MENURES                      2580
#define IDS_HS_MENURES_ID                   2581
#define IDS_HS_MENURES_LANGUAGE             2582
#define IDS_HS_MENURES_CONDITION            2583

#define IDS_HS_VERRES                       2584
#define IDS_HS_VERRES_ID                    2585
#define IDS_HS_VERRES_LANGUAGE              2586
#define IDS_HS_VERRES_CONDITION             2587

#define IDS_HS_BITMAPRES                    2588
#define IDS_HS_BITMAPRES_ID                 2589
#define IDS_HS_BITMAPRES_LANGUAGE           2590
#define IDS_HS_BITMAPRES_CONDITION          2591
#define IDS_HS_BITMAPRES_FILENAME           2592

#define IDS_HS_CURSORRES                    2593
#define IDS_HS_CURSORRES_ID                 2594
#define IDS_HS_CURSORRES_LANGUAGE           2595
#define IDS_HS_CURSORRES_CONDITION          2596
#define IDS_HS_CURSORRES_FILENAME           2597

#define IDS_HS_ICONRES                      2598
#define IDS_HS_ICONRES_ID                   2599
#define IDS_HS_ICONRES_LANGUAGE             2600
#define IDS_HS_ICONRES_CONDITION            2601
#define IDS_HS_ICONRES_FILENAME             2602

#define IDS_HS_TOOLBARRES                   2603
#define IDS_HS_TOOLBARRES_ID                2604
#define IDS_HS_TOOLBARRES_LANGUAGE          2605
#define IDS_HS_TOOLBARRES_CONDITION         2606
#define IDS_HS_TOOLBARRES_FILENAME          2607

#define IDS_HS_STRINGRES                    2608
#define IDS_HS_STRINGRES_LANGUAGE           2609
#define IDS_HS_STRINGRES_CONDITION          2685

#define IDS_HS_FILEFLAGS                    2610
#define IDS_HS_FILEFLAGS_VS_FF_DEBUG        2611
#define IDS_HS_FILEFLAGS_VS_FF_PRERELEASE   2612

#define IDS_HS_VERSIONBLOCK                 2613
#define IDS_HS_VERSIONBLOCK_LANGUAGEID      2614
#define IDS_HS_VERSIONBLOCK_CODEPAGE        2615
#define IDS_HS_VERSIONBLOCK_FILEFLAGS       2683
#define IDS_HS_VERSIONBLOCK_VALUE           2684
#define IDS_HS_VERSIONBLOCK_KEY             2692

#define IDS_HS_STRED                        2616
#define IDS_HS_STRED_ID                     2617
#define IDS_HS_STRED_VALUE                  2699
#define IDS_HS_STRED_CAPTION                2618

#define IDS_HS_CTBED                        2619
#define IDS_HS_CTBED_ID                     2620
#define IDS_HS_CTBED_WIDTH                  2621
#define IDS_HS_CTBED_HEIGHT                 2622
#define IDS_HS_CTBED_PROMPT                 2623

#define IDS_HS_ICONED                       2624
#define IDS_HS_ICONED_DEVICE                2625
#define IDS_HS_ICONED_ID                    2626
#define IDS_HS_ICONED_FILENAME              2627

#define IDS_HS_CUSTOMED                     2628
#define IDS_HS_CUSTOMED_ID                  2629
#define IDS_HS_CUSTOMED_LANGUAGE            2630
#define IDS_HS_CUSTOMED_CONDITION           2631
#define IDS_HS_CUSTOMED_FILENAME            2632
#define IDS_HS_CUSTOMED_EXTERNALFILE        2633

#define IDS_HS_CURSORED                     2634
#define IDS_HS_CURSORED_ID                  2635
#define IDS_HS_CURSORED_DEVICE              2636
#define IDS_HS_CURSORED_HOTSPOT             2637
#define IDS_HS_CURSORED_FILENAME            2638

//2639 - unused

#define IDS_HS_BITMAPED                     2640
#define IDS_HS_BITMAPED_ID                  2641
#define IDS_HS_BITMAPED_WIDTH               2642
#define IDS_HS_BITMAPED_HEIGHT              2643
#define IDS_HS_BITMAPED_COLORS              2644
#define IDS_HS_BITMAPED_FILENAME            2645
#define IDS_HS_BITMAPED_SAVECOMPRESSED      2646
#define IDS_HS_BITMAPED_PALETTE             2647

#define IDS_HS_ACCEL                        2648
#define IDS_HS_ACCEL_ID                     2649
#define IDS_HS_ACCEL_KEY                    2650
#define IDS_HS_ACCEL_CONTROL                2651
#define IDS_HS_ACCEL_ALT                    2652
#define IDS_HS_ACCEL_SHIFT                  2653
#define IDS_HS_ACCEL_TYPE                   2654

#define IDS_HS_MENU                         2655
#define IDS_HS_MENU_ID                      2656
#define IDS_HS_MENU_CAPTION                 2657
#define IDS_HS_MENU_SEPARATOR               2658
#define IDS_HS_MENU_POPUP                   2659
#define IDS_HS_MENU_ENABLED                 2660
#define IDS_HS_MENU_CHECKED                 2661
#define IDS_HS_MENU_GRAYED                  2662
#define IDS_HS_MENU_HELP                    2663
#define IDS_HS_MENU_BREAK                   2664
#define IDS_HS_MENU_PROMPT                  2665
#define IDS_HS_MENU_RIGHTTOLEFTJUSTIFY      2666
#define IDS_HS_MENU_RIGHTTOLEFTORDER        2687

#define IDS_HS_POPMENU                      2668
#define IDS_HS_POPMENU_ID                   2669

#define IDS_HS_RCNODE                       2670
#define IDS_HS_RCNODE_FILENAME              2671
#define IDS_HS_RCNODE_MFCMODE               2672
#define IDS_HS_RCNODE_USE3DCONTROL          2673

// Dialogs 
#define IDS_HS_DLGEDITOR_APPWINDOW          2674
#define IDS_HS_DLGEDITOR_WINDOWEDGE         2675
#define IDS_HS_DLGEDITOR_OVERLAPPEDWINDOW   2678
#define IDS_HS_DLGEDITOR_PALETTEWINDOW      2679
#define IDS_HS_DLGEDITOR_LAYOUTRTL          2680
#define IDS_HS_DLGEDITOR_NOINHERITLAYOUT    2681
#define IDS_HS_DLGEDITOR_TOPMOST            2682
#define IDS_HS_DLGEDITOR_CLASS              2691
#define IDS_HS_EDITOR_NAME                  2693

//#define IDS_HS_VERSIONBLOCK_FILEFLAGS     2683 - defined above
//#define IDS_HS_VERSIONBLOCK_VALUE         2684 - defined above
//#define IDS_HS_STRINGRES_CONDITION        2685 - defined above
//#define IDS_HS_VERSIONBLOCK_KEY           2692 - defined above
//#define IDS_HS_DLGEDITOR_NAME             2693 - defined above
#define IDS_LANG_ID                         2694
#define IDS_LANG_NEUTRAL                    2695

// Static 
#define IDS_HS_STATIC_ENDELLIPSIS           2688
#define IDS_HS_STATIC_PATHELLIPSIS          2689
#define IDS_HS_STATIC_WORDELLIPSIS          2690
//#define IDS_HS_DLGEDITOR_CLASS            2691 - defined above
//#define IDS_HS_COMBO_DATA                 2694 - defined above

#define IDS_HS_RESVIEW_HEADER               2696
#define IDS_HS_RESVIEW_SYMBOLDIRECTIVES     2697
#define IDS_HS_RESVIEW_COMPILEDIRECTIVES    2698
//#define IDS_HS_STRED_VALUE                2699 - defined above
//#define IDS_HS_LB_NODATA                  2700 - defined above
//#define IDS_HS_TAB_FLATBUTTONS            2701 - defined above
#define IDS_HS_HTMLRES                      2702

//#define IDS_HS_SYS                          2716
//#define IDS_HS_SYS_ID                       2717
//#define IDS_HS_SYS_VISIBLE                  2718
//#define IDS_HS_SYS_DISABLED                 2719
//#define IDS_HS_SYS_GROUP                    2720
//#define IDS_HS_SYS_TABSTOP                  2721
//#define IDS_HS_SYS_HELPID                   2722
//#define IDS_HS_SYS_CLIENTEDGE               2723
//#define IDS_HS_SYS_STATICEDGE               2724
//#define IDS_HS_SYS_MODALFRAME               2725
//#define IDS_HS_SYS_TRANSPARENT              2726
//#define IDS_HS_SYS_ACCEPTFILES              2727
//#define IDS_HS_SYS_RIGHTALIGNTEXT           2728
//#define IDS_HS_SYS_RTLREADINGORDER          2729
//#define IDS_HS_SYS_LEFTSCROLLBAR            2730
//#define IDS_HS_SYS_CAPTION                  2731        - defined above
//#define IDS_HS_SYS_FOCUSSED                   2732
//#define IDS_HS_SYS_ENABLED                    2733
//#define IDS_HS_SYS_VISITED                    2734
//#define IDS_HS_SYS_SHELLEXECURL               2735
//#define IDS_HS_DLGEDITOR_SHELLFONT          2736
// RES

#define ECMD_EVENT_HANDLER                  2715

#define IDM_ICON_IMAGE_TYPES                2713
#define IDM_CURSOR_IMAGE_TYPES             2714

#define IDG_ICON_IMAGE_TYPES                2736
#define IDG_CURSOR_IMAGE_TYPES             2737

//ECMD_IMAGE_TYPE? items need to stay in order
#define ECMD_IMAGE_TYPE1I                   2703
#define ECMD_IMAGE_TYPE2I                   2704
#define ECMD_IMAGE_TYPE3I                   2705
#define ECMD_IMAGE_TYPE4I                   2706
#define ECMD_IMAGE_TYPE5I                   2707
#define ECMD_IMAGE_TYPE6I                   2708
#define ECMD_IMAGE_TYPE7I                   2709
#define ECMD_IMAGE_TYPE8I                   2710
#define ECMD_IMAGE_TYPE9I                   2711
#define ECMD_IMAGE_TYPE10I                  2712

#define ECMD_IMAGE_TYPE1C                   2738
#define ECMD_IMAGE_TYPE2C                   2739
#define ECMD_IMAGE_TYPE3C                   2740
#define ECMD_IMAGE_TYPE4C                   2741
#define ECMD_IMAGE_TYPE5C                   2742
#define ECMD_IMAGE_TYPE6C                   2743
#define ECMD_IMAGE_TYPE7C                   2744
#define ECMD_IMAGE_TYPE8C                   2745
#define ECMD_IMAGE_TYPE9C                   2746
#define ECMD_IMAGE_TYPE10C                  2747

#define HID_WND_RESOURCE_BROWSER        0x28010
#define HID_WND_DIALOG                  0x28011
#define HID_WND_MENU                    0x28012
#define HID_WND_BITMAP                  0x28013
#define HID_WND_CURSOR                  0x28014
#define HID_WND_ICON                    0x28015
#define HID_WND_STRING                  0x28016
#define HID_WND_ACCEL                   0x28017
#define HID_WND_VERSION                 0x28018
#define HID_WND_BINARY                  0x28019
#define HID_WND_IMAGE_TOOLS             0x2801a
#define HID_WND_DIALOG_TOOLS            0x2801b
#define HID_WND_BITMAP_TEXTTOOL         0x2801c
#define HID_WND_TOOLBAR_EDIT            0x2801d
#define HID_WND_RESOURCEVIEW            0x2801e
// RES range
#define MIN_RES_WINDOW_ID               HID_WND_RESOURCE_BROWSER
#define MAX_RES_WINDOW_ID               HID_WND_RESOURCEVIEW

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Command ID ranges

//  Shell
#define MIN_SHELL_COMMAND_ID    0x8000
#define MAX_SHELL_COMMAND_ID    0x83FF
//  Build package
#define MIN_BUILD_COMMAND_ID    0x8400
#define MAX_BUILD_COMMAND_ID    0x85FF
//  Res package
#define MIN_RES_COMMAND_ID      0x8600
#define MAX_RES_COMMAND_ID      0x86FF
//  Src
#define MIN_SOURCE_COMMAND_ID   0x8700
#define MAX_SOURCE_COMMAND_ID   0x88FF
//  ClassView/Wizards
#define MIN_CLASSVIEW_COMMAND_ID   0x8900
#define MAX_CLASSVIEW_COMMAND_ID   0x89FF
//  MSIN
#define MIN_MSIN_COMMAND_ID     0x8A00
#define MAX_MSIN_COMMAND_ID     0x8BFF
//  Proj
#define MIN_WORKSPACE_COMMAND_ID 0x8C00
#define MAX_WORKSPACE_COMMAND_ID 0x8FFF
//  HTML
#define MIN_HTML_COMMAND_ID  0x9000
#define MAX_HTML_COMMAND_ID  0x900F
//  BIN
#define MIN_BIN_COMMAND_ID  0x9010
#define MAX_BIN_COMMAND_ID  0x901F
//  IMG
#define MIN_IMG_COMMAND_ID  0x9020
#define MAX_IMG_COMMAND_ID  0x907F
//  ODL
#define MIN_ODL_COMMAND_ID  0x9080
#define MAX_ODL_COMMAND_ID  0x909F
// IV
#define MIN_IV_COMMAND_ID   0x90A0
#define MAX_IV_COMMAND_ID   0x9FFF
//  Fortran
#define MIN_FORTRAN_COMMAND_ID  0xA000
#define MAX_FORTRAN_COMMAND_ID  0xA1FF
//  Test
#define MIN_TEST_COMMAND_ID     0xA200
#define MAX_TEST_COMMAND_ID     0xA3FF
//  Espresso
#define MIN_ESPRESSO_COMMAND_ID 0xA400
#define MAX_ESPRESSO_COMMAND_ID 0xA5FF
//  Enterprise Edition (Galileo)
#define MIN_ENT_COMMAND_ID      0xA600
#define MAX_ENT_COMMAND_ID      0xA67F

// SPACE 0xA681 - 0xA7FF

//  LangCPP
#define MIN_LANGCPP_COMMAND_ID  0xA800
#define MAX_LANGCPP_COMMAND_ID  0xA8FF

//  SPACE 0xA900-0xAEFF

//  Sample Package
#define MIN_SAMPLE_COMMAND_ID   0xAF00
#define MAX_SAMPLE_COMMAND_ID   0xAFFF
//  NuMega Package
#define MIN_NUMEGA_COMMAND_ID   0xB000
#define MAX_NUMEGA_COMMAND_ID   0xB1FF
//  Package Partner Package (define one min/max set per partner--512 IDs)
//  Partners use 'PARTNER' IDs until a specific range is established for them.
#define MIN_PARTNER_COMMAND_ID  0xB200
#define MAX_PARTNER_COMMAND_ID  0xB3FF

//  SPACE 0xB400-0xB78F 

// IATOOL (Interactive Authoring Tool Package)
#define MIN_IATOOL_COMMAND_ID   0xB400
#define MAX_IATOOL_COMMAND_ID   0xB5FF
// NCB (No Compile Browser)
// !!!!!This is an internal package.
#define MIN_NCB_COMMAND_ID      0xB600
#define MAX_NCB_COMMAND_ID      0xB625
// IST (Internet Studio)    
#define MIN_IST_COMMAND_ID      0xB650
#define MAX_IST_COMMAND_ID      0xB6FF

// SPACE 0xB700 - 0xB78F

// OLE Automation 1 (DevAUT1.pkg)
#define MIN_AUT1_COMMAND_ID     0xB790
#define MAX_AUT1_COMMAND_ID     0xC78F
// OLE Automation 2 (DevAUT2.pkg)
#define MIN_AUT2_COMMAND_ID     0xC790
#define MAX_AUT2_COMMAND_ID     0xC8EF
// HTM
#define MIN_HTM_COMMAND_ID      0xC8F0
#define MAX_HTM_COMMAND_ID      0xCAEF
// DTG
#define MIN_DTG_COMMAND_ID      0xCAF0
#define MAX_DTG_COMMAND_ID      0xCCEF
// DDK
#define MIN_DDK_COMMAND_ID      0xCCF0
#define MAX_DDK_COMMAND_ID      0xCCFF

//  SPACE 0xCD00-0xDFFF

// MFC
#define MIN_MFC_COMMAND_ID      0xE000
#define MAX_MFC_COMMAND_ID      0xFFFF

/////////////////////////////////////////////////////////////////////
// Shell Commands
//
#define IDM_TOOLBAR_EDIT                0x8000
#define IDM_CUSTOMIZE                   0x8001
#define ID_WINDOW_CLOSE_ALL             0x8002
#define IDM_OPTIONS                     0x8003
#define IDM_TOGGLE_MDI                  0x8004
#define IDM_TOOLBAR_CUSTOMIZE           0x8005
#define ID_WINDOW_FULLSCREEN            0x8006
#define ID_FILE_SAVE_ALL_EXIT           0x8007
#define IDM_CONTEXT_SEPARATOR           0x8008
#define IDM_TOOLBARS_LIST               0x8009
#define IDM_TOOLBARS_CUSTOMIZE          0x800a

// These two only used for tooltips
#define IDM_BUTTON_DOCK_CLOSE           0x800b
#define IDM_BUTTON_DOCK_MAX             0x800c
#define IDM_BUTTON_DOCK_RESTORE         0x800d

// Window commands
#define IDM_WINDOW_CLOSE                                0x800e
#define IDM_WINDOW_NEXT                                 0x800f
#define IDM_WINDOW_PREVIOUS                             0x8010

#define IDM_REFRESH                                             0x8011
#define IDM_FILE_NEW_IN_PROJ            0x8012

// This command group is special becuase it is enabled even when the toolbar
// customisation window is visible. martynl 25Mar96
#define IDM_BUTTON_BASE                 0x8080
#define IDM_BUTTON_COPYIMAGE                    0x8080
#define IDM_BUTTON_PASTEIMAGE                   0x8081
#define IDM_BUTTON_RESETIMAGE           0x8082
#define IDM_BUTTON_CHOOSEAPPEARANCE     0x8083
#define IDM_BUTTON_RESET                                0x8084
#define IDM_BUTTON_DELETE                               0x8085
#define IDM_BUTTON_IMAGEONLY                    0x8086
#define IDM_BUTTON_TEXTONLY                             0x8088
#define IDM_BUTTON_IMAGETEXT                    0x8089
#define IDM_BUTTON_GROUPSTART                   0x808a
#define IDM_BUTTON_LAST                 0x808a

// READ THIS IF YOU ARE MODIFYING MENU IDS:
// Menus are now commands, and as such, have command ids like everything else in the world.
// Code elsewhere (entry.cpp) relies on the order of these, and the fact that they increase 
// monotonically, so change with caution.
// THIS MEANS THAT EACH OF THESE SHOULD BE ONE MORE THAN THE PREVIOUS ONE. NO SPACES ALLOWED

#define IDM_MENU_FIRSTMAIN                              0x8100
#define IDM_MENU_BAR                                    0x8100
#define IDM_MENU_FILE                                   0x8101
#define IDM_MENU_EDIT                                   0x8102
#define IDM_MENU_VIEW                                   0x8103
#define IDM_MENU_INSERT                                 0x8104
#define IDM_MENU_BUILD_DEBUG            0x8105
#define IDM_MENU_BUILD                                  0x8106
#define IDM_MENU_IMAGE                  0x8107
#define IDM_MENU_LAYOUT_ALIGN                   0x8108
#define IDM_MENU_LAYOUT_SPACE           0x8109
#define IDM_MENU_LAYOUT_CENTER          0x810a
#define IDM_MENU_LAYOUT_ARRANGE         0x810b
#define IDM_MENU_LAYOUT_SAMESIZE        0x810c
#define IDM_MENU_LAYOUT_AUTO                    0x810d
#define IDM_MENU_LAYOUT                                 0x810e
#define IDM_MENU_TEST                                   0x810f
#define IDM_MENU_CODECOVERAGE                   0x8110
#define IDM_MENU_DEBUG                  0x8111
#define IDM_MENU_TOOLS_SCC              0x8112
#define IDM_MENU_TOOLS                                  0x8113
#define IDM_MENU_WINDOW                 0x8114
#define IDM_MENU_HELP                   0x8115
#define IDM_MENU_INTERNAL_DEBUG         0x8116
#define IDM_MENU_INTERNAL_PERF          0x8117
#define IDM_MENU_VIEW_TOOLBARS                          0x8118
#define IDM_MENU_OLEBAR                          0x8119
#define IDM_MENU_HELP_MSONTHEWEB                0x811a
#define IDM_MENU_FILEMRU                                0x811b
#define IDM_MENU_WKSMRU                                 0x811c
#define IDM_MENU_DEBUG_WINDOWS                  0x811d
#define IDM_MENU_PROJECT                                0x811e
#define IDM_MENU_PROJECT_LIST                           0x811f
#define IDM_MENU_PROJECT_ADD                            0x8120
#define IDM_MENU_LASTMAIN                               0x8120

#define IDM_DOCKSHOW_BASE               0x8200
#define IDM_DOCKSHOW_LAST               0x8218  //24 possible show commands for all dockable windows.

// Custom menu ids for 'new' menus generated and managed by the shell
#define IDM_CUSTOMMENU_BASE                             0x8240

#define IDM_CUSTOMMENU_0                (IDM_CUSTOMMENU_BASE + 0)
#define IDM_CUSTOMMENU_1                (IDM_CUSTOMMENU_BASE + 1)
#define IDM_CUSTOMMENU_2                (IDM_CUSTOMMENU_BASE + 2)
#define IDM_CUSTOMMENU_3                (IDM_CUSTOMMENU_BASE + 3)
#define IDM_CUSTOMMENU_4                (IDM_CUSTOMMENU_BASE + 4)
#define IDM_CUSTOMMENU_5                (IDM_CUSTOMMENU_BASE + 5)
#define IDM_CUSTOMMENU_6                (IDM_CUSTOMMENU_BASE + 6)
#define IDM_CUSTOMMENU_7                (IDM_CUSTOMMENU_BASE + 7)
#define IDM_CUSTOMMENU_8                (IDM_CUSTOMMENU_BASE + 8)
#define IDM_CUSTOMMENU_9                (IDM_CUSTOMMENU_BASE + 9)
#define IDM_CUSTOMMENU_10               (IDM_CUSTOMMENU_BASE + 10)
#define IDM_CUSTOMMENU_11               (IDM_CUSTOMMENU_BASE + 11)
#define IDM_CUSTOMMENU_12               (IDM_CUSTOMMENU_BASE + 12)
#define IDM_CUSTOMMENU_13               (IDM_CUSTOMMENU_BASE + 13)
#define IDM_CUSTOMMENU_14               (IDM_CUSTOMMENU_BASE + 14)
#define IDM_CUSTOMMENU_15               (IDM_CUSTOMMENU_BASE + 15)
#define IDM_CUSTOMMENU_LAST                             0x824f

#define IDM_ACTIVATE_PROJECT_WORKSPACE  0x8280
#define IDM_TOGGLE_PROJECT_WORKSPACE    0x8281

#define IDM_ACTIVATE_PROPERTY_PAGE      0x8282
#define IDM_TOGGLE_PROPERTY_PAGE        0x8283

#define IDMX_IDPROP                     0x8290
#define IDMX_PROPGENERAL                0x8291
#define IDMX_PROPSTYLES                 0x8292
#define ID_FASTHELP                     0x8298

#define IDM_USERTOOLS_BASE              0x82A0
#define IDM_USERTOOLS_0                 (IDM_USERTOOLS_BASE + 0)
#define IDM_USERTOOLS_1                 (IDM_USERTOOLS_BASE + 1)
#define IDM_USERTOOLS_2                 (IDM_USERTOOLS_BASE + 2)
#define IDM_USERTOOLS_3                 (IDM_USERTOOLS_BASE + 3)
#define IDM_USERTOOLS_4                 (IDM_USERTOOLS_BASE + 4)
#define IDM_USERTOOLS_5                 (IDM_USERTOOLS_BASE + 5)
#define IDM_USERTOOLS_6                 (IDM_USERTOOLS_BASE + 6)
#define IDM_USERTOOLS_7                 (IDM_USERTOOLS_BASE + 7)
#define IDM_USERTOOLS_8                 (IDM_USERTOOLS_BASE + 8)
#define IDM_USERTOOLS_9                 (IDM_USERTOOLS_BASE + 9)
#define IDM_USERTOOLS_10                (IDM_USERTOOLS_BASE + 10)
#define IDM_USERTOOLS_11                (IDM_USERTOOLS_BASE + 11)
#define IDM_USERTOOLS_12                (IDM_USERTOOLS_BASE + 12)
#define IDM_USERTOOLS_13                (IDM_USERTOOLS_BASE + 13)
#define IDM_USERTOOLS_14                (IDM_USERTOOLS_BASE + 14)
#define IDM_USERTOOLS_15                (IDM_USERTOOLS_BASE + 15)
#define IDM_USERTOOLS_LAST              0x82AF  //16 user tools on Tools menu

#define IDM_WINDOWS_BASE              0x82B0
#define IDM_WINDOWS_0                 (IDM_WINDOWS_BASE + 0)
#define IDM_WINDOWS_1                 (IDM_WINDOWS_BASE + 1)
#define IDM_WINDOWS_2                 (IDM_WINDOWS_BASE + 2)
#define IDM_WINDOWS_3                 (IDM_WINDOWS_BASE + 3)
#define IDM_WINDOWS_4                 (IDM_WINDOWS_BASE + 4)
#define IDM_WINDOWS_5                 (IDM_WINDOWS_BASE + 5)
#define IDM_WINDOWS_6                 (IDM_WINDOWS_BASE + 6)
#define IDM_WINDOWS_7                 (IDM_WINDOWS_BASE + 7)
#define IDM_WINDOWS_8                 (IDM_WINDOWS_BASE + 8)
#define IDM_WINDOWS_9                 (IDM_WINDOWS_BASE + 9)
#define IDM_WINDOWS_10                (IDM_WINDOWS_BASE + 10)
#define IDM_WINDOWS_11                (IDM_WINDOWS_BASE + 11)
#define IDM_WINDOWS_12                (IDM_WINDOWS_BASE + 12)
#define IDM_WINDOWS_13                (IDM_WINDOWS_BASE + 13)
#define IDM_WINDOWS_14                (IDM_WINDOWS_BASE + 14)
#define IDM_WINDOWS_15                (IDM_WINDOWS_BASE + 15)
#define IDM_WINDOWS_16                (IDM_WINDOWS_BASE + 16)
#define IDM_WINDOWS_17                (IDM_WINDOWS_BASE + 17)
#define IDM_WINDOWS_18                (IDM_WINDOWS_BASE + 18)
#define IDM_WINDOWS_19                (IDM_WINDOWS_BASE + 19)
#define IDM_WINDOWS_20                (IDM_WINDOWS_BASE + 20)
#define IDM_WINDOWS_21                (IDM_WINDOWS_BASE + 21)
#define IDM_WINDOWS_22                (IDM_WINDOWS_BASE + 22)
#define IDM_WINDOWS_23                (IDM_WINDOWS_BASE + 23)
#define IDM_WINDOWS_24                (IDM_WINDOWS_BASE + 24)
#define IDM_WINDOWS_25                (IDM_WINDOWS_BASE + 25)
#define IDM_WINDOWS_26                (IDM_WINDOWS_BASE + 26)
#define IDM_WINDOWS_27                (IDM_WINDOWS_BASE + 27)
#define IDM_WINDOWS_28                (IDM_WINDOWS_BASE + 28)
#define IDM_WINDOWS_29                (IDM_WINDOWS_BASE + 29)
#define IDM_WINDOWS_30                (IDM_WINDOWS_BASE + 30)
#define IDM_WINDOWS_31                (IDM_WINDOWS_BASE + 31)
#define IDM_WINDOWS_LAST              0x82CF  //32 items max on windows menu
#define ID_WINDOW_LIST_DOCS           0x82D0

#define ID_PROJ_MRU_FIRST                               0x82E0
#define ID_PROJ_MRU_FILE1               (ID_PROJ_MRU_FIRST)
#define ID_PROJ_MRU_FILE2               (ID_PROJ_MRU_FIRST + 1)
#define ID_PROJ_MRU_FILE3               (ID_PROJ_MRU_FIRST + 2)
#define ID_PROJ_MRU_FILE4               (ID_PROJ_MRU_FIRST + 3)
#define ID_PROJ_MRU_FILE5               (ID_PROJ_MRU_FIRST + 4)
#define ID_PROJ_MRU_FILE6               (ID_PROJ_MRU_FIRST + 5)
#define ID_PROJ_MRU_FILE7               (ID_PROJ_MRU_FIRST + 6)
#define ID_PROJ_MRU_FILE8               (ID_PROJ_MRU_FIRST + 7)
#define ID_PROJ_MRU_FILE9               (ID_PROJ_MRU_FIRST + 8)
#define ID_PROJ_MRU_FILE10              (ID_PROJ_MRU_FIRST + 9)
#define ID_PROJ_MRU_FILE11              (ID_PROJ_MRU_FIRST + 10)
#define ID_PROJ_MRU_FILE12              (ID_PROJ_MRU_FIRST + 11)
#define ID_PROJ_MRU_FILE13              (ID_PROJ_MRU_FIRST + 12)
#define ID_PROJ_MRU_FILE14              (ID_PROJ_MRU_FIRST + 13)
#define ID_PROJ_MRU_FILE15              (ID_PROJ_MRU_FIRST + 14)
#define ID_PROJ_MRU_FILE16              (ID_PROJ_MRU_FIRST + 15)
#define ID_PROJ_MRU_LAST                                0x82EF

#ifdef _DEBUG
#define IDM_OPENLAYOUT                  0x8300
#endif

#define IDM_INSERT_FILES                0x8301
#define ID_TOOLS_RECORD                 0x8302
#define ID_TOOLS_PLAYBACK               0x8303
#define ID_FILE_NEW_SOURCE              0x8304
#define ID_FILE_NEW_RC                  0x8305
#define IDM_WINDOW_SHOWPROPERTIES       0x8306
#define IDM_WINDOW_HSPROPERTIES         0x8307
#define ID_WINDOW_HIDE                  0x8308
#define ID_WINDOW_POPUP_HIDE            0x8309

#define ID_PROP_PUSHPIN                 0x4edf
#define MIN_ID_REPEAT_CMD               0x8321
#define ID_REPEAT_CMD                   0x8321
#define ID_REPEAT_CMD0                  0x8322
#define ID_REPEAT_CMD1                  0x8323
#define ID_REPEAT_CMD2                  0x8324
#define ID_REPEAT_CMD3                  0x8325
#define ID_REPEAT_CMD4                  0x8326
#define ID_REPEAT_CMD5                  0x8327
#define ID_REPEAT_CMD6                  0x8328
#define ID_REPEAT_CMD7                  0x8329
#define ID_REPEAT_CMD8                  0x832A
#define ID_REPEAT_CMD9                  0x832B
#define MAX_ID_REPEAT_CMD               0x832B

#define ID_DRAG_MOVE                    0x8330
#define ID_DRAG_COPY                    0x8331
#define ID_DRAG_CANCEL                  0x8332

#define ID_CANCEL                       0x8333
#define ID_MDI_CYCLE_FORWARD            0x8334
#define ID_PROJECT_COMBO                0x8335

#define ID_GRD_NEW                      0x4ed0
#define ID_GRD_DELETE                   0x4ed1
#define ID_GRD_MOVEUP                   0x4ed2
#define ID_GRD_MOVEDOWN                 0x4ed3

// IDs reserved for internal developer utilities
#define ID_INTERNAL_FIRST               0x8350
#ifdef  PERF_MEASUREMENTS
#define ID_DUMP_MEM                     (ID_INTERNAL_FIRST+0)
#endif
#define ID_INTERNAL_LAST                0x835f

// Shell groups

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Command Group IDs

// Below are groups that commands may go in.  (These used to be called "minor
//  groups"-- note that the IDs relating to "major groups" have been removed.)
//  Each command or menu is a member of one of the following groups. If the command 
//  or menu appears on a menu, its location is determined by the group's location (on 
//  which menu, and where in that menu).  See ide\exes\dev\entry.cpp.
// The Tools.Customize dialog lists commands by "category".  The category
//  is determined by which of the following groups the command is a member of,
//  and then what main menu that group is a part of.  Note that you can
//  have hidden menus, which allow you to group your commands in the
//  Tools.Customize.Keyboard dialog any way you like, without affecting the
//  visible menu structure.  To have a hidden menu, simply make sure that
//  all commands in all groups on that menu have the CT_NOMENU flag.
//  (See ide\include\cmdtable.h.)  This is set in your .cmd file, or
//  as an argument to CTheApp::AddCommand.

// Packages are free to create their own groups. The group ids should be in the same range as
// the packages command ids, though the two sets of numbers may overlap.

// If a group has its low bit set, then no separator will appear after it. Otherwise, a 
// separator will be inserted

// Currently groups for all packages appear here. Gradually, some of these group ids can be
// exported to other places

#define IDG_FILEOPS                  0x8000
#define IDG_FILESAVE                 0x8002
#define IDG_PRINT                    0x8005
#define IDG_MRU                      0x8006
#define IDG_EXIT                     0x8008
#define IDG_PROJ_MRU_MENU            0x800c
#define IDG_MSINOPEN                 0x8010
#define IDG_PRINTMAIN                        0x8012
#define IDG_MRU_MENU                             0x8014
#define IDG_PROJ_MRU                 0x8016
#define IDG_FILE_RENAME                          0x8018
#define IDG_FILE_NEW                 0x8019

#define IDG_UNDO                     0x8020
#define IDG_FILE_NEW_IN_PROJ         0x8021
#define IDG_CLIPBOARD                0x8023
#define IDG_FIND_1                   0x8025
#define IDG_FIND_COMBO               0x8026
#define IDG_GOTO                     0x8029
#define IDG_BOOKMARK                 0x802a
#define IDG_EDITPROPS                0x802c
#define IDG_BREAKPOINTS              0x8030
#define IDG_FORMATEDITOR             0x8032
#define IDG_SELECTALL                            0x8034
#define IDG_FIND_2                   0x8036
#define IDG_CLIPBOARD_2                          0x8038
#define IDG_GOTO_2                                   0x803b

#define IDG_PROJECTOPS               0x8040
#define IDG_BUILD                    0x8042
#define IDG_ERROR                    0x8044
#define IDG_DEPENDENCIES             0x8046
#define IDG_PROJECTCLOSE             0x8048
#define IDG_PROJECTOPS_STD           0x804a
#define IDG_PROJECT_ADD              0x804c
#define IDG_PROJECTOPS_ADD           0x804e
#define IDG_PROJECTOPS_SCAN          0x8050
#define IDG_PROJECTOPS_SCHM          0x8052

#define IDG_RESOURCENEW              0x8060
#define IDG_RESOURCEIMPORTEXPORT     0x8062
#define IDG_SYMBOLS                  0x8064
#define IDG_VIEW_AS_POPUP            0x8066
#define IDG_NEWRES                   0x8068
#define IDG_CLASSWIZARD              0x806a
#define IDG_LAYOUTOPT                0x806c
#define IDG_WORKSPACEOPS             0x806e

#define IDG_DEBUGRUN                 0x8080
#define IDG_DEBUGSHOW                0x8082
#define IDG_DEBUGTHREADS             0x8084
#define IDG_CODECOVER                0x8086
#define IDG_COVERITEMS               0x8088
#define IDG_DEBUGOPTS                0x808a
#define IDG_DEBUGACTIVE              0x808c
// This group id is deliberately odd, because it is a no-break group
#define IDG_DEBUGSTEP1               0x808f 
#define IDG_DEBUGSTEP2               0x8090

#define IDG_TOOLOPS                  0x80a0
#define IDG_TOOLS_PROFILE                        0x80a1         // WinslowF Adding profiler
#define IDG_TOOLS_PACKAGES           0x80a2
#define IDG_OPTIONS                  0x80a4
#define IDG_TOOLS_SEARCH             0x80a6
#define IDG_USERTOOLS                0x80a8
#define IDG_MACROS                   0x80aa
#define IDG_BUTTONOPS                0x80ac     // Button customize context menu.
#define IDG_TOOLS_RUN                            0x80ae
#define IDG_TOOLS_RESOURCE                       0x80b0
#define IDG_TOOLS_WEB_1              0x80b3
#define IDG_TOOLS_WEB_2              0x80b4

#define IDG_WINDOWOPS                0x80c0
#define IDG_WINDOWALL                0x80c3
#define IDG_WINDOW_WINDOWS           0x80c4
#define IDG_WINDOWLIST               0x80c6
#define IDG_WINDOWNEXT                           0x80c8

#define IDG_HELPGENERAL              0x80e0
#define IDG_HELPDOCS                 0x80e1
#define IDG_MSONTHEWEB               0x80e4
#define IDG_HELPINSTALLED            0x80e6
#define IDG_HELP_SUBSETCOMBO         0x80e8
#define IDG_HELPABOUT                0x80ea
#define IDG_HELP_OPENCOMBO           0x80ec
#define IDG_HELP_CONTENTS            0x80f0
#define IDG_HELP_BROWSE              0x80f2
#define IDG_HELP_MSONTHEWEB_NEWS         0x80f4         // Items on the mow submenu
#define IDG_HELP_MSONTHEWEB_INFO         0x80f6
#define IDG_HELP_MSONTHEWEB_HOME         0x80f8
#define IDG_HELP_KEYBOARD            0x80fa
#define IDG_HELP_TOPLEVEL                0x80fc

#define IDG_IMAGEOPS                 0x8100
#define IDG_IMAGECOLORS              0x8102
#define IDG_IMAGEGRID                0x8104
#define IDG_IMAGETOOLS               0x8106
#define IDG_IMAGE_DEVICE             0x8108

#define IDG_LAYOUTOPS_1              0x8121
#define IDG_LAYOUTGRID               0x8122
#define IDG_LAYOUTTAB                0x8124
#define IDG_RULER_CONTEXT            0x8126
#define IDG_ALIGNEDGE                0x8128
#define IDG_ALIGNCENTER              0x812a
#define IDG_SPACEEVENLY              0x812c
#define IDG_CENTERDIALOG             0x812e
#define IDG_ARRANGEBUTTONS           0x8130
#define IDG_SAMESIZE                 0x8132
#define IDG_LAYOUTGROUP                          0x8134
#define IDG_LAYOUTZORDER             0x8136
#define IDG_LAYOUTGUIDES             0x8138
#define IDG_LAYOUTTEST               0x813a
#define IDG_LAYOUTAUTO               0x813c
#define IDG_LAYOUTOPS_2                          0x813e

#define IDG_BROWSE                  0x8140
#define IDG_KEY                     0x8142

// InfoViewer Groups 0x815x to 0x817F

#define IDG_IV_FILE_OPS             0x8150
#define IDG_IV_FILE_NEW_NOSEP       0x8151
#define IDG_IV_FILE_SAVE            0x8152
#define IDG_IV_FILE_PRINT           0x8154
#define IDG_IV_FILE_MISC            0x8156
#define IDG_IV_FILE_LAST            0x8157
#define IDG_IV_EDIT_OPS             0x815a
#define IDG_IV_EDIT_FIND            0x815c
#define IDG_IV_EDIT_BOOKMARKS       0x815c
#define IDG_IV_EDIT_BOOKMARKS_NOSEP 0x815d
#define IDG_IV_EDIT_LAST            0x815f
#define IDG_IV_VIEW_HOME            0x8160
#define IDG_IV_VIEW_LISTS           0x8162
#define IDG_IV_VIEW_LIST_OPS        0x8164
#define IDG_IV_VIEW_LAST            0x8167
#define IDG_IV_VIEW_WINDOWS         0x8169
#define IDG_IV_TOOLS_SEARCH         0x816a
#define IDG_IV_TOOLS_SYNC           0x816c
#define IDG_IV_TOOLS_SYNC_NOSEP     0x816d
#define IDG_IV_TOOLS_SUBSETS        0x816e
#define IDG_IV_TOOLS_LAST           0x816f
#define IDG_IV_WINDOW_MISC          0x8170
#define IDG_IV_WINDOW_CONTENTS      0x8172
#define IDG_IV_WINDOW_TOPIC         0x8174
#define IDG_IV_WINDOW_LAST          0x8177
#define IDG_IV_HELP_FIRST           0x817a
#define IDG_IV_HELP_CONTENTS        0x817a
#define IDG_IV_HELP_MISC            0x817c
#define IDG_IV_HELP_ABOUT           0x817f

#define IDG_PROJECT                 0x8180
#define IDG_PRJSYS_OPS              0x8182
#define IDG_BLDSYS_TOOL             0x8184
#define IDG_TARGET_COMBO            0x8186
#define IDG_BUILD_1                 0x8188
#define IDG_BUILD_DEBUGMENU         0x818a
#define IDG_BUILD_2                 0x818c
#define IDG_CONFIG_COMBO            0x818e

#define IDG_VIEW_WINDOWS            0x81a1
#define IDG_VIEW_MSIN1              0x81a2
#define IDG_VIEW_MSIN2              0x81a4
#define IDG_VIEW_MSIN3              0x81a6
#define IDG_MSIN_PRINT              0x81a8
#define IDG_VIEW_WINDOWS_2                      0x81aa
#define IDG_VIEW_WEB                0x81ad
#define IDG_VIEW_WEB_2              0x81ae
#define IDG_VIEW_DB                                 0x81b1
#define IDG_VIEW_DB_2               0x81b3
#define IDG_VIEW_DB_3               0x81b4
#define IDG_VIEW_REFRESH            0x81b6
#define IDG_VIEW_DEBUG_WINDOWS          0x81ba

#define IDG_SCC_POPUP               0x81c0
#define IDG_SCC_OPS1                0x81c2
#define IDG_SCC_OPS2                0x81c4
#define IDG_SCC_OPS3                0x81c6
#define IDG_SCC_RUN                 0x81c8

#define IDG_BROWSE_OPS              0x81e0
#define IDG_WIZBARU                 0x81e4
#define IDG_WIZBARU_CTL             0x81e6
#define IDG_WIZBARU_CMDS            0x81e8

#define IDG_INTERNAL_UTILS          0x8202
// the edit advanced submenu
#define IDG_MENU_EDIT_ADVANCED      0x8204
// Items on the edit advanced submenu
#define IDG_EDIT_ADVANCED           0x8206

#define IDG_TOOLBARS_LIST           0x8220
#define IDG_TOOLBARS_CUSTOMIZE      0x8222

#define IDG_VIEW_FULLSCREEN         0x8240
#define IDG_INSERT_0                0x8241
#define IDG_INSERT_1                0x8243
#define IDG_INSERT_2                0x8244
#define IDG_INSERT_3                0x8246
#define IDG_INSERT_4                0x8248
#define IDG_BUILD_SETTINGS          0x824a
#define IDG_VIEW_TOOLBARS           0x824c
#define IDG_TOOLS_REMOTE            0x824e
#define IDG_INSERT_FILE                         0x8250
#define IDG_DEBUG_GO                0x8251
#define IDG_DEBUG_STEPINTO          0x8253
#define IDG_DEBUG_RUNTOCURSOR       0x8255
#define IDG_DEBUG_ATTACH            0x8257
#define IDG_INSERT_RESOURCE         0x8258

// These groups dictate the ordering of the menus within the main menu bar
// Keep them numerically adjacent, so the popup main menu bar is drawn without separators
#define IDG_MENUBAR_FILE            0x8261
#define IDG_MENUBAR_EDIT            0x8263
#define IDG_MENUBAR_VIEW            0x8265
#define IDG_MENUBAR_INSERT          0x8267
#define IDG_MENUBAR_BUILD           0x8269     // includes build and debug
#define IDG_MENUBAR_TEST            0x826b
#define IDG_MENUBAR_RESOURCE        0x826d
#define IDG_MENUBAR_TOOLS           0x826f
#define IDG_MENUBAR_WINDOW          0x8271
#define IDG_MENUBAR_HELP            0x8273
#define IDG_MENUBAR_INTERNAL        0x8275
#define IDG_MENUBAR_PROJECT         0x8277

// Special kinds of menus
#define IDG_CUSTOMMENU              0x8280
#define IDG_MENUBAR_BAR             0x8282      // group containing the main menu bar. Shouldn't be used outside of shell

#define IDG_DEBUG_1                 0x82a0
#define IDG_DEBUG_2                 0x82a2
#define IDG_DEBUG_3                 0x82a4
#define IDG_DEBUG_4                 0x82a6
#define IDG_DEBUG_5                 0x82a8
#define IDG_DEBUG_6                 0x82aa
#define IDG_DEBUG_7                 0x82ac
#define IDG_DEBUG_8                 0x82ae
#define IDG_DEBUG_PERF              0x82b0

#define IDG_PROJECT_MODIFY                      0x82c0
#define IDG_PROJECT_WEB                         0x82c2
#define IDG_PROJECT_SCCS                        0x82c4
#define IDG_PROJECT_SETTINGS            0x82c6
#define IDG_PROJECT_INSERT                      0x82c8
#define IDG_PROJECT_LIST                        0x82ca
#define IDG_PROJECT_ADD_NEW         0x82cc
#define IDG_PROJECT_ADD_INSERT          0x82ce
#define IDG_PROJECT_ADD_DB                      0x82d0
#define IDG_PROJECT_ADD_COMPONENT   0x82d2
#define IDG_PROJECT_ADD_PROJECT                 0x82d4


// Espresso special command groups
// REVIEW(BrendanX): Better location for non-DevStudio EXE commands.
// Martynl: Can now move out to packages, since they can own their own menus.
#define IDG_GLOSSARY_MISC_OPS               0x8300
#define IDG_GLOSSARY_OPS                    0x8302
#define IDG_TRANSLATE_APPROVALSTATEFAILED   0x8304
#define IDG_TRANSLATE_APPROVALSTATE         0x8306
#define IDG_TRANSLATE_USERFLAG              0x8308
#define IDG_TRANSLATE_TESTWHAT              0x830a
#define IDG_TRANSLATE_ITEM                  0x830c
#define IDG_TRANSLATE_STATE                 0x830e
#define IDG_TRANSLATE_AUTO                  0x8310
#define IDG_TRANSLATE_TEST                  0x8312
#define IDG_DATABASEOPS                     0x8314
#define IDG_VIEW_EDITORS                    0x8316
#define IDG_VIEW_REPORTS                    0x8318
#define IDG_VIEW_REPORT_FILES               0x8320
#define IDG_HELPESPRESSOABOUT               0x8322
#define IDG_ESPRESSO_LAYOUT                 0x8324
#define IDG_ESPRESSO_TOOLS                  0x8326
#define IDG_ESPRESSO_MISC1                  0x8328
#define IDG_ESPRESSO_MISC2                  0x832a
#define IDG_ESPRESSO_MISC3                  0x832c
#define IDG_IMPORT_PROJECT                  0x832e
#define IDG_ESPESSO_DB                      0x8330
#define IDG_AUTOLAYOUT                      0x8332
#define IDG_REVERT                          0x8334
#define IDG_DIALOGLAYOUT                    0x8336
#define IDG_HELPESPRESSO                    0x8338
#define IDG_VIEW_EDITORWALK                 0x833a

#define IDG_TEST_DEBUG              0x8380
#define IDG_TEST_RECORD             0x8382
#define IDG_TEST_SCREENS            0x8384
#define IDG_TEST_DIALOGS            0x8386
#define IDG_TEST_DRIVER             0x8388

// HTM Insert.Html group
#define IDG_INSERTHTML                                          0x8389

#define IDM_GROUP_END                    0x83a0
#define IDM_GROUP_FIRST                  0x83a1
#define IDM_GROUP_ADD                    0x83a1
#define IDM_GROUP_BUILDDEBUG             0x83a2
#define IDM_GROUP_CLSVIEW_GROUP_CHILDREN 0x83a3
#define IDM_GROUP_LAST                   0x83af

/////////////////////////////////////////////////////////////////////
// ClassView/DO Commands
//
#define IDM_PROJITEM_ADD_GROUP          0x8407
#define IDM_PROJECT_SET_AS_DEFAULT      0x8420


/////////////////////////////////////////////////////////////////////
// VRES Commands
//
#define IDM_FILE_SETINCLUDES        0x8600
#define IDM_FILE_INSTALLCONTROLS    0x8601
#define IDM_EDIT_SYMBOLS            0x8602
#define IDM_RESOURCE_NEW            0x8603
#define IDM_RESOURCE_OPEN           0x8604
#define IDM_RESOURCE_OPENBINARY     0x8605
#define IDM_RESOURCE_IMPORT         0x8606
#define IDM_RESOURCE_EXPORT         0x8607
#define IDM_RESOURCE_SAVE           0x8608
#define IDM_PROPERTIES              0x8609
#define IDMB_NEW_DIALOG             0x860A
#define IDMB_NEW_CURSOR             0x860B
#define IDMB_NEW_ICON               0x860C
#define IDMB_NEW_BITMAP             0x860D
#define IDMB_NEW_MENUBAR            0x860E
#define IDMB_NEW_STRINGTABLE        0x860F
#define IDMB_NEW_ACCTABLE           0x8610
#define IDMB_NEWRC                  0x8611
#define IDMB_NEW_VERSION            0x8612
#define ID_CANCEL_EDIT              0x8613
#define IDM_RESOURCE_ADD            0x8614
#define IDM_RESOURCE_NEWCOPY        0x8615
#define IDMB_NEW_TOOLBAR            0x8616
#define IDM_RESOURCENODE_SAVE       0x8617
#define ECMD_RES_IMPORT             0x8618
#define ECMD_RES_DLG_EDITCONTROL    0x8619
#define ECMD_RES_DLG_PROPPAGES      0x861A

// special commands for specific VRES resource types
#define IDM_FIND_STRING             0x8620
#define IDM_FIND_NEXT               0x8621
#define IDM_NEW_STRING              0x8622
#define IDM_NEW_ACCELERATOR         0x8623
#define IDM_NEW_STRINGBLOCK         0x8624
#define IDM_DELETE_STRINGBLOCK      0x8625
#define IDMY_TEST                   0x8626
#define IDM_SETTABORDER             0x8627
#define IDMY_ALIGNLEFT              0x8628
#define IDMY_ALIGNRIGHT             0x8629
#define IDMY_ALIGNTOP               0x862A
#define IDMY_ALIGNBOTTOM            0x862B
#define IDMY_SPACEACROSS            0x862C
#define IDMY_SPACEDOWN              0x862D
#define IDM_BUTTONRIGHT             0x862E
#define IDM_BUTTONBOTTOM            0x862F
#define IDMY_MAKESAMEWIDTH          0x8630
#define IDMY_MAKESAMEHEIGHT         0x8631
#define IDMY_MAKESAMEBOTH           0x8632
#define IDM_SIZETOTEXT              0x8633
#define IDM_GRIDSETTINGS            0x8634
#define IDMB_SHOWGRID               0x8635
#define IDM_VIEWASPOPUP             0x8636

#ifndef IMAGE_EDITOR_BROKEN_OUT
#define ID_FILE_NEW_BITMAP          0x830A
#define IDM_TOOLBAR_WIZARD          0x8608
#define IDMY_PICKCOLOR              0x8637
#define IDM_FLIPBSHH                0x8638
#define IDM_FLIPBSHV                0x8639
#define IDM_MAGNIFY                 0x863A
#define IDM_NEWDEVIMG               0x863B
#define IDM_OPENDEVIMG              0x863C
#define IDM_DELDEVIMG               0x863D
#define IDM_INVERTCOLORS            0x863E
#define IDM_TGLOPAQUE               0x863F
#define IDM_EDITCOLORS              0x8640
#define IDM_LOADCOLORS              0x8641
#define IDM_SAVECOLORS              0x8642
#define IDM_SETHOTSPOT              0x8643
#define IDM_ALIGNCVERT              0x8644
#define IDM_ALIGNCHORZ              0x8645
#define IDMY_CENTERVERT             0x8646
#define IDMY_CENTERHORZ             0x8647
#define IDM_INSTALLCONTROLS         0x8648
#define IDMY_CHECKHOTKEYS           0x8649
#define IDMZ_IMGSEPARATOR           0x8650
#define IDMX_ZOOMIN                 0x8651
#define IDMX_ZOOMOUT                0x8652
#define IDMX_SMALLERBRUSH           0x8653
#define IDMX_LARGERBRUSH            0x8654
#define IDMB_RECTTOOL               0x8655
#define IDMB_FRECTTOOL              0x8656
#define IDMB_ELLIPSETOOL            0x8657
#define IDMB_FELLIPSETOOL           0x8658
#define IDMZ_BRUSHTOOL              0x8659
#define IDMB_FILLTOOL               0x865A
#define IDMB_LINETOOL               0x865B
#define IDMB_PICKTOOL               0x865C
#define IDMX_PREVCOLOR              0x865D
#define IDMX_NEXTCOLOR              0x865E
#define IDMX_PREVECOLOR             0x865F
#define IDMB_3DRECTTOOL             0x8660
#define IDMX_NEXTECOLOR             0x8661
#define IDMX_TEXTTOOL               0x8662
#define IDMB_CURVETOOL              0x8663
#define IDMB_ORECTTOOL              0x8664
#define IDMB_ORNDRECTTOOL           0x8665
#define IDMB_OELLIPSETOOL           0x8666
#define IDMB_POLYGONTOOL            0x8667
#define IDMB_FPOLYGONTOOL           0x8668
#define IDMB_OPOLYGONTOOL           0x8669
#define IDMB_PICKRGNTOOL            0x866A
#define IDMX_OUTLINEBSH             0x866B
#define IDMB_AIRBSHTOOL             0x866C
#define IDMX_SMALLBRUSH             0x866D
#define IDMX_SEL2BSH                0x866E
#define IDMB_RNDRECTTOOL            0x866F
#define IDMB_FRNDRECTTOOL           0x8671
#define IDMB_PENCILTOOL             0x8672
#define IDMB_ERASERTOOL             0x8673
#define IDMB_ZOOMTOOL               0x8674
#define IDMB_CBRUSHTOOL             0x8675
#define IDM_GRIDOPT                 0x8676
#define IDMX_SHOWTILEGRID           0x8677
#define IDM_ROT90                   0x8678
#define IDMX_OTHERPANE              0x8679
#define IDM_SHOWIMAGEGRID           0x867A
#define IDM_WINDOWRECTTOOL          0x867B

#define IDMB_TRANSPARENT            0x8680
#define IDMB_OPAQUE                 0x8681
#define IDMB_AIRBSHTOOL1            0x8682
#define IDMB_AIRBSHTOOL2            0x8683
#define IDMB_AIRBSHTOOL3            0x8684
#define IDMB_ERASERTOOL1            0x8685
#define IDMB_ERASERTOOL2            0x8686
#define IDMB_ERASERTOOL3            0x8687
#define IDMB_ERASERTOOL4            0x8688
#define IDMB_RECTTOOL1              0x8689
#define IDMB_RECTTOOL2              0x868A
#define IDMB_RECTTOOL3              0x868B
#define IDMB_RECTTOOL4              0x868C
#define IDMB_RECTTOOL5              0x868D
#define IDMB_TOOL11                 0x868E
#define IDMB_TOOL12                 0x868F
#define IDMB_TOOL13                 0x8690
#define IDMB_TOOL21                 0x8691
#define IDMB_TOOL22                 0x8692
#define IDMB_TOOL23                 0x8693
#define IDMB_TOOL31                 0x8694
#define IDMB_TOOL32                 0x8695
#define IDMB_TOOL33                 0x8696
#define IDMB_TOOL41                 0x8697
#define IDMB_TOOL42                 0x8698
#define IDMB_TOOL43                 0x8699
#define IDMB_ZOOMTOOL1              0x869A
#define IDMB_ZOOMTOOL2              0x869B
#define IDMB_ZOOMTOOL6              0x869C
#define IDMB_ZOOMTOOL8              0x869D
#define IDM_DISPLAY_COLORS          0x869E
#endif  // IMAGE_EDITOR_BROKEN_OUT

#define ECMD_SET_SIZE_N_POS         0x86A1
//unused 0x86A2 - 0x86E4

#define IDM_VIEW_POPUP              0x869F
#define IDM_MNEMONICS               0x86A0

#define IDMB_SHOWRULER              0x86E5
#define IDMB_TOGGLEGUIDES           0x86E6
#define IDM_GUIDE_ATTACH_LEFT       0x86E7
#define IDM_GUIDE_ATTACH_RIGHT      0x86E8
#define IDM_GUIDE_ATTACH_PROPORTIONAL 0x86E9
#define IDM_GUIDE_CLEAR             0x86EA
#define IDM_GUIDE_CLEAR_ALL         0x86EB
#define IDMY_FLIPDIALOG             0x86EC

#define IDM_CTL_POSFIRST            0x86ED
    #define IDM_CTL_MOVELEFT            0x86ED
    #define IDM_CTL_MOVEUP              0x86EE
    #define IDM_CTL_MOVERIGHT           0x86EF
    #define IDM_CTL_MOVEDOWN            0x86F0
#define IDM_CTL_SIZEFIRST           0x86F1
    #define IDM_CTL_SIZELEFT            0x86F1
    #define IDM_CTL_SIZEUP              0x86F2
    #define IDM_CTL_SIZERIGHT           0x86F3
    #define IDM_CTL_SIZEDOWN            0x86F4
#define IDM_CTL_POSLAST             0x86F4

#define IDM_CTL_HOTSPOT_LOC         0x86F5
#define IDM_CTL_INSERT              0x86F6

// Espresso commands for dialog editor
#define IDM_REVERT_SIZES            0x86F7
#define IDM_REVERT_COORDINATES      0x86F8
#define IDM_REVERT_STYLES           0x86F9
#define IDMY_AUTOLAYOUT_GROW        0x86FA
#define IDMY_AUTOLAYOUT_OPTIMIZE    0x86FB
#define IDMY_AUTOLAYOUT_NORESIZE    0x86FC

// Wizard Bar New Event Handler command for Dialog controls
#define IDM_WIZBARU_EVENTS                      0x86FD
// Wizard Bar Help Id (Generic) here because makehm needs non-releaive hex number bobz
#define IDM_WIZBARU_HELP                        0x86FE

// insert Activex control w/out wrapper class - dialog editor only
#define IDM_CTL_INSERT_RES           0x86FF

/////////////////////////////////////////////////////////////////////
// VCPP Commands
//
// Many of the standard ones (FileOpen, etc) now use the MFC
// predefined IDs.
//
// REVIEW: This block is a hodge-podge of Edit, Debug, Browse,
//         Shell, Output window, obsolete, and shared commands.
//
#define IDM_FILE_SAVE_ALL               0x8700
#define ID_EDIT_FIND_DLG        0x8701 // invoke find dialog
#define IDM_EDIT_GREP                   0x8702
//#define IDM_EDIT_FINDMATCH              0x8703  note: now in pkgs\edit\resource.h
#define IDM_EDIT_READONLY               0x8704
#define ID_CUT_LINE             0x8705
#define ID_EDIT_FIND_NEXT       0x8706
#define ID_EDIT_FIND_PREV       0x8707
#define ID_EDIT_FIND_COMBO      0x8708 // activate find combo
#define IDM_ADDTOPROJECT                0x8709
#define IDM_EDIT_CLEAR_OUTPUT   0x870A
#define IDM_FILE_SEND                   0x870B
#define IDM_FILE_REVERT                 0x870C
#define IDM_FILE_LIST_DOCS              0x870D
#define IDM_EDIT_TOGGLE_CASE            0x870E
#define IDM_EDIT_TOGGLE_RE              0x870F
#define IDM_EDIT_TOGGLE_WORD            0x8710
#define IDM_EDIT_TOGGLE_SEARCH_ALL_DOCS 0x872E

// DEBUG
#define IDM_GOTO_LINE                   0x8711
#define IDM_VIEW_MIXEDMODE              0x8712
#define IDM_GOTO_DISASSY                0x8713
#define IDM_GOTO_SOURCE                 0x8714

// OUTPUT
#define IDM_GOTO_CURRENTERROR   0x8715
#define IDM_VIEW_NEXTERROR              0x8716
#define IDM_VIEW_PREVIOUSERROR  0x8717

// EDIT
#define IDM_VIEW_TOGGLETAG              0x8718
#define IDM_VIEW_NEXTTAG                0x8719
#define IDM_VIEW_PREVIOUSTAG    0x871A
#define IDM_VIEW_CLEARALLTAGS   0x871B
#define IDM_GOTO_FILE                   0x871C

// OUTPUT
#define IDM_VIEW_OUTTOOLS               0x871D

// EDIT (for now)
#define IDM_BOOKMARKS                   0x871E

// ??
#define IDM_GOTO_CODE                   0x871F

// BROWSE
#define IDM_BROWSE_GOTOREF              0x8720
#define IDM_BROWSE_GOTODEF              0x8721
#define IDM_BROWSE_NEXT                 0x8722
#define IDM_BROWSE_PREVIOUS             0x8723
#define IDM_BROWSE_OPEN                 0x8724
#define IDM_BROWSE_POP                  0x8725
#define IDM_BROWSE_SYM                  0x8726
#define IDM_BROWSE_OUTLINE              0x8727
#define IDM_BROWSE_FGRAPH               0x8728
#define IDM_BROWSE_CGRAPH               0x8729
#define IDM_BROWSE_FGRAPH_R             0x872A
#define IDM_BROWSE_CGRAPH_R             0x872B
#define IDM_BROWSE_QUERY                0x872C
#define IDM_BROWSE_FILES                0x872D
// note: 0x872E is used above by the shell

// DEBUG
#define IDM_DEBUG_RADIX                 0x872F
#define IDM_RUN_GO                      0x8730
#define IDM_RUN_RESTART                 0x8731
#define IDM_RUN_STOPDEBUGGING           0x8732
#define IDM_RUN_BREAK                   0x8733
#define IDM_RUN_TOCURSOR                0x8734
#define IDM_RUN_TRACEINTO               0x8735
#define IDM_RUN_STEPOVER                0x8736
#define IDM_RUN_STOPAFTERRETURN         0x8737
#define IDM_RUN_CALLS                   0x8738
#define IDM_RUN_SETBREAK                0x8739
#define IDM_RUN_QUICKWATCH              0x873A
#define IDM_RUN_EXCEPTIONS              0x873B
#define IDM_RUN_THREADS                 0x873C
//      IDM_RUN_FIBERS                          0x876B
#define IDM_RUN_ATTACH_TO_ACTIVE        0x873D
#define IDM_RUN_COVER_TOGGLE            0x873E
#define IDM_RUN_COVER_CLEAR             0x873F
#define IDM_RUN_SETNEXTSTMT             0x8740
#define IDM_RUN_CLEARALLBREAK           0x8741
#define IDM_RUN_SRC_TRACEINTO           0x8742
#define IDM_RUN_SRC_STEPOVER            0x8743
#define IDM_RUN_FLIPHACK                0x8744 // not used in release build
#define IDM_RUN_REMOTEDEBUGGER          0x8745
#define IDM_RUN_JIT_GO                  0x8746
#define IDM_DEBUG_ACTIVE                0x8747
#define IDM_RUN_TRACEFUNCTION           0x8749
#define IDM_RUN_SRC_TRACEFUNCTION       0x874A
#define IDM_RUN_ENABLEBREAK             0x874B
#define IDM_RUN_TOGGLEBREAK             0x874C
#define IDM_RUN_DISABLEALLBREAK         0x874D
#define IDM_MEMORY_NEXTFORMAT           0x874E
#define IDM_MEMORY_PREVFORMAT           0x874F
#define IDM_RUN_PROFILE                 0x8750  // WinslowF Adding profiler

// OUTPUT
#define IDM_OUTPUT_EXECTOOL             0x8750
#define IDM_OUTPUT_CLEAR                0x8751
#define IDM_OUTPUT_GOTO_TAG             0x8752

// DEBUG
#define IDM_DEBUG_SHOWIP                0x8753
#define IDM_DEBUG_GOTOSOURCE    0x8754
#define IDM_DBGSHOW_FLOAT               0x8755
#define IDM_DBGSHOW_STACKTYPES  0x8756
#define IDM_DBGSHOW_STACKVALUES 0x8757
#define IDM_DBGSHOW_SOURCE              0x8758
#define IDM_DBGSHOW_MEMBYTE             0x8759
#define IDM_DBGSHOW_MEMSHORT    0x875A
#define IDM_DBGSHOW_MEMLONG             0x875B
#define IDM_DBGSHOW_CODEBYTES           0x875C
#define IDM_DBGSHOW_MEMORY_BAR          0x875F

// EDIT
#define IDM_INDENT              0x8760
#define IDM_UNINDENT            0x8761

// DEBUG
#define IDM_DBGSHOW_VARS_BAR    0x8762

// EDIT
#define IDM_KEYBOARDINDENT      0x8763
#define IDM_KEYBOARDUNINDENT    0x8764

// SHELL
#define IDM_TOOL_STOP           0x8765
#define IDM_FIRST_TOOL          0x8766

// EDIT
#define IDM_MACRO_RECORD                0x8767
#define IDM_MACRO_PLAY                  0x8768
#define IDM_MACRO_PAUSE                 0x8769
#define IDM_MACRO_STOP                  0x876A

#define IDM_RUN_FIBERS                                  0x876B
// OUTPUT
//#define IDM_WINDOW_ERRORS               0x876C // AXE(CFlaat) doesn't appear to be needed

// ??
#define IDM_WINDOWCHILD         0x876D

// SHELL
#define IDM_HELP_MSPROD                         0x8774
#define IDM_HELP_CONTENTS                       0x8776
#define IDM_HELP_INDEX                          0x8777
#define IDM_HELP_SEARCH                         0x8778
#define IDM_HELP_EXTHELP                        0x8779
#define IDM_HELP_TIPOFTHEDAY            0x877b

// EDIT
#define IDM_REFORMAT                                    0x877f
#define IDM_UPPERCASE                   0x8780
#define IDM_NEWLINE                     0x8781
#define IDM_NEXTLINE                    0x8782
#define IDM_NEWLINEABOVE                0x8783
#define IDM_LOWERCASE                   0x8784
#define IDM_CLEARSELECTION              0x8785
#define IDM_SCROLL_LINEUP               0x8786
#define IDM_SCROLL_LINEDOWN             0x8787
#define ID_EDIT_FIND_NEXTCURRENTWORD    0x8788
#define ID_EDIT_FIND_PREVCURRENTWORD    0x8789
#define IDM_EDIT_DELETEWORDRIGHT        0x878a
#define IDM_EDIT_DELETELEFT             0x878b
#define IDM_FIND_IFDEF_UP               0x878c
#define IDM_FIND_IFDEF_DOWN             0x878d
#define IDM_EXTEND_FIND_IFDEF_UP        0x878e
#define IDM_EXTEND_FIND_IFDEF_DOWN      0x878f
#define IDM_CURSOR_STARTNEXTLINE        0x8790
#define ID_COL_SELECT                   0x8791
#define IDM_INSERT                                              0x8792

// DEBUG
#define ID_RUN_GO                               0x8793
#define ID_RUN_RESTART                          0x8794
#define ID_RUN_TOCURSOR                         0x8795
#define ID_RUN_TRACEINTO                        0x8796
#define ID_RUN_STEPOVER                         0x8797
#define ID_RUN_STOPAFTERRETURN                  0x8798
#define ID_RUN_SRC_TRACEINTO                    0x8799
#define ID_RUN_SRC_STEPOVER                     0x879a
#define ID_RUN_STOPDEBUGGING                    0x879b

// EDIT
#define IDM_VIEW_EPSDROPBOOKMARK                0x879c
#define IDM_VIEW_EPSNEXTBOOKMARK                0x879d
#define IDM_VIEW_BRF_DROPBOOKMARK1              0x879e
#define IDM_VIEW_BRF_DROPBOOKMARK2              0x879f
#define IDM_VIEW_BRF_DROPBOOKMARK3              0x87a0
#define IDM_VIEW_BRF_DROPBOOKMARK4              0x87a1
#define IDM_VIEW_BRF_DROPBOOKMARK5              0x87a2
#define IDM_VIEW_BRF_DROPBOOKMARK6              0x87a3
#define IDM_VIEW_BRF_DROPBOOKMARK7              0x87a4
#define IDM_VIEW_BRF_DROPBOOKMARK8              0x87a5
#define IDM_VIEW_BRF_DROPBOOKMARK9              0x87a6
#define IDM_VIEW_BRF_DROPBOOKMARK10             0x87a7
#define ID_RUN_TRACEFUNCTION                    0x87a8
#define ID_RUN_SRC_TRACEFUNCTION                0x87a9

// DEBUG
#define IDM_ACTIVATE_SRCFIRST                                   0x87B0
#define IDM_ACTIVATE_OUTPUT                     0x87B0
#define IDM_ACTIVATE_WATCH                      0x87B1
#define IDM_ACTIVATE_VARIABLES                  0x87B2
#define IDM_ACTIVATE_REGISTERS                  0x87B3
#define IDM_ACTIVATE_MEMORY                     0x87B4
#define IDM_ACTIVATE_CALLSTACK                  0x87B5
#define IDM_ACTIVATE_DISASSEMBLY                0x87B6
#define IDM_ACTIVATE_SRCLAST                                    0x87BF

#define IDM_TOGGLE_SRCFIRST                                             0x87B0
#define IDM_TOGGLE_OUTPUT                       0x87C0
#define IDM_TOGGLE_WATCH                        0x87C1
#define IDM_TOGGLE_VARIABLES                    0x87C2
#define IDM_TOGGLE_REGISTERS                    0x87C3
#define IDM_TOGGLE_MEMORY                       0x87C4
#define IDM_TOGGLE_CALLSTACK                    0x87C5
#define IDM_TOGGLE_DISASSEMBLY                  0x87C6
#define IDM_TOGGLE_SRCLAST                                              0x87CF

// Shell
#define IDM_HELP_MOW_FIRST                                              0x87D0
#define IDM_HELP_MOW_FREESTUFF                                  0x87D0
#define IDM_HELP_MOW_PRODUCTNEWS                                0x87D1
#define IDM_HELP_MOW_FAQ                                                0x87D2
#define IDM_HELP_MOW_ONLINESUPPORT                              0x87D3
#define IDM_HELP_MOW_DEVONLYHOMEPAGE                    0x87D4
#define IDM_HELP_MOW_SENDFEEDBACK                               0x87D5
#define IDM_HELP_MOW_BESTOFTHEWEB                               0x87D6
#define IDM_HELP_MOW_SEARCHTHEWEB                               0x87D7
#define IDM_HELP_MOW_WEBTUTORIAL                                0x87D8
#define IDM_HELP_MOW_MSHOMEPAGE                                 0x87D9
#define IDM_HELP_MOW_LAST                                               0x87DF

// DEBUG
#define IDM_CTL_LOCAL_FUNCS                     0x6400
#define IDM_CTL_WATCH_EDIT                      0x6401
#define IDM_CTL_WATCH_DELETE                    0x6402

// BROWSE
#define IDM_CTL_BROWSE_CLASS                    0x6403
#define IDM_CTL_BROWSE_FUNCMEM                  0x6404
#define IDM_CTL_BROWSE_DATAMEM                  0x6405
#define IDM_CTL_BROWSE_MACRO                    0x6406
#define IDM_CTL_BROWSE_TYPE                     0x6407
#define IDM_CTL_BROWSE_FUNCS                    0x6408
#define IDM_CTL_BROWSE_DATA                     0x6409
#define IDM_CTL_MEMORY_EDIT                     0x640A
#define IDM_CTL_VARS_FUNCS                      0x640B

// PARSER
#define IDM_PARSER_PARSE                0x87F0
#define IDM_PARSER_INFO                 0x87F1
#define IDM_PARSER_PARSEPROJ    0x87F2
#define IDM_PARSER_OPENDBASE    0x87F3
#define IDM_PARSER_CLOSEDBASE   0x87F4

// EDIT
#define ID_DELETE_LINE                  0x8800
#define ID_EDIT_REPLACE_DLG             0x8801
#define ID_NEXT_WINDOW          0x8802
#define ID_PREV_WINDOW          0x8803
#define ID_TOGGLE_RESTORE               0x8806
#define ID_SEARCH_AGAIN                 0x8807

#define IDM_CURSOR_CHARLEFT     0x8808
#define IDM_CURSOR_CHARRIGHT    0x8809
#define IDM_CURSOR_LINEUP               0x880A
#define IDM_CURSOR_LINEDOWN             0x880B
#define IDM_CURSOR_WORDLEFT             0x880C
#define IDM_CURSOR_WORDRIGHT    0x880D
#define IDM_CURSOR_SCREENUP             0x880E
#define IDM_CURSOR_SCREENDOWN   0x880F
#define IDM_EPSILON_ESCAPE              0x8810
#define IDM_CURSOR_LINESTART    0x8811
#define IDM_CURSOR_LINEEND              0x8812
#define IDM_CURSOR_FILESTART    0x8813
#define IDM_CURSOR_FILEEND              0x8814
#define IDM_CURSOR_BEGINPANE    0x8815
#define IDM_CURSOR_ENDPANE              0x8816
#define IDM_CURSOR_LEFTPANE             0x8817
#define IDM_CURSOR_RIGHTPANE    0x8818
#define IDM_CURSOR_BEGINLINE    0x8819
#define IDM_CURSOR_BRIEFHOME    0x881A
#define IDM_CURSOR_BRIEFEND             0x881B
#define IDM_TABIFYREGION        0x881C
#define IDM_UNTABIFYREGION      0x881D
#define IDM_HIGHLIGHTREGION             0x881E
#define IDM_EPSILON_INDENT_REGION       0x881F
#define IDM_EPSILON_KILLREGION  0x8820
#define IDM_EDIT_DELETEBRIEFEOLN        0x8821
#define IDM_EPSILON_FWDPARAGRAPH        0x8822
#define IDM_EPSILON_BCKPARAGRAPH        0x8823
#define IDM_EPSILON_FWDSENTENCE 0x8824
#define IDM_EPSILON_BCKSENTENCE 0x8825
#define IDM_EPSILON_DELSENTENCE 0x8826
#define IDM_EDIT_DELETEBRIEFBOLN        0x8827
#define IDM_EPSILON_TRANSPOSECH 0x8828
#define IDM_EPSILON_TRANSPOSEWD 0x8829
#define IDM_EPSILON_TRANSPOSELN 0x882A
#define IDM_EPSILON_CAPWORD             0x882B
#define IDM_EPSILON_LOWERWORD   0x882C
#define IDM_EPSILON_UPPERWORD   0x882D
#define ID_CMD_INVALID                  0x882E
#define IDM_NEWLINEBELOW                0x882F
#define ID_EDIT_REDOCHANGES             0x8830
#define ID_EDIT_UNDOCHANGES             0x8831
#define IDM_EPSILON_MARKPARAGRAPH       0x8832
#define IDM_EPSILON_CENTERWINDOW        0x8833
#define IDM_EPSILON_DELHORZSPACE        0x8834
#define IDM_EPSILON_DELBLANKLINES       0x8835
#define IDM_EPSILON_APPENDNEXTKILL      0x8839
#define IDM_EPSILON_TOINDENT    0x883A
#define IDM_FORMAT_REGION               0x883B
#define IDM_INDENT_UNDER                0x883C
#define IDM_REGEX_SRCH_FWD              0x883E
#define IDM_REGEX_SRCH_BCK              0x883F

// DEBUG
#define IDM_BP_CURRENT_ADDR                             0x8840
#define IDM_BP_CURRENT_LINE                             0x8841
#define IDM_BP_CURRENT_FUNC                             0x8842
#define IDM_BP_ADVANCED                                 0x8843

// EDIT
#define ID_EDIT_RE_REPLACE                              0x8844
#define IDM_SEARCH_ISEARCH_FWD                  0x8845
#define IDM_SEARCH_ISEARCH_BACK                 0x8846
#define IDM_SEARCH_ISEARCH_REFWD        0x8847
#define IDM_SEARCH_ISEARCH_REBACK       0x8848
#define IDM_ISEARCH_ISEARCH_FWD         0x8849
#define IDM_ISEARCH_ISEARCH_BACK        0x884A
#define IDM_ISEARCH_TOGGLE_CASE         0x884B
#define IDM_ISEARCH_TOGGLE_WORD         0x884C
#define IDM_ISEARCH_TOGGLE_REGEX        0x884D
#define ID_QUOTED_INSERT                                0x884E
#define ID_CHANGE_PANE_UP                               0x884F
#define ID_CHANGE_PANE_DOWN                             0x8850
#define ID_CHANGE_PANE_LEFT                             0x8851
#define ID_CHANGE_PANE_RIGHT                    0x8852
#define ID_DELETE_ROW_UP                                0x8853
#define ID_DELETE_ROW_DOWN                              0x8854
#define ID_DELETE_COL_LEFT                              0x8855
#define ID_DELETE_COL_RIGHT                             0x8856
#define ID_LINE_TO_TOP                                  0x8857
#define ID_LINE_TO_BOTTOM                               0x8858

// SHELL??
#define ID_FILESET_FIRST                                0x8859
#define ID_FILESET0                                     (ID_FILESET_FIRST+0)
#define ID_FILESET1                                     (ID_FILESET_FIRST+1)
#define ID_FILESET2                                     (ID_FILESET_FIRST+2)
#define ID_FILESET3                                     (ID_FILESET_FIRST+3)
#define ID_FILESET4                                     (ID_FILESET_FIRST+4)
#define ID_FILESET5                                     (ID_FILESET_FIRST+5)
#define ID_FILESET6                                     (ID_FILESET_FIRST+6)
#define ID_FILESET7                                     (ID_FILESET_FIRST+7)
#define ID_FILESET8                                     (ID_FILESET_FIRST+8)
#define ID_FILESET9                                     (ID_FILESET_FIRST+9)
#define ID_FILESET10                                    (ID_FILESET_FIRST+10)
#define ID_FILESET11                                    (ID_FILESET_FIRST+11)
#define ID_FILESET12                                    (ID_FILESET_FIRST+12)
#define ID_FILESET13                                    (ID_FILESET_FIRST+13)
#define ID_FILESET14                                    (ID_FILESET_FIRST+14)
#define ID_FILESET15                                    (ID_FILESET_FIRST+15)
#define ID_FILESET_LAST                                 0x8868

// EDIT
#define ID_EDIT_BACKWARD_LEVEL                  0x8869
#define ID_EDIT_FORWARD_LEVEL                   0x8870
#define ID_EDIT_KILL_LEVEL                      0x8871
#define ID_EDIT_BACKWARD_KILL_LEVEL             0x8872

// RES??
#define IDM_STRING_TO_RESOURCE                  0x8873

// EDIT ("Advanced" menu)
#define IDM_MENU_EDIT_ADVANCED                                  0x8874

// HTM commands squatting in the edit package
#define IDM_HTMLX_SCUSEWIZARD                                   0x8875
#define IDM_HTMLX_SCINSERTCONTROL                               0x8876
#define IDM_HTMLX_SCINSERTHTMLLAYOUT                    0x8877
#define IDM_HTMLX_SCSCRIPTWIZARD                                0x8878
#define IDM_HTMLX_SCEDITCONTROL                         0x8879
#define IDM_HTMLX_SCEDITDESIGNCONTROL                   0x887a
#define IDM_HTMLX_SCEDITHTMLLAYOUT                              0x887b
#define IDM_HTMLX_INTOHTMLSUBMENU                               0x887c

/////////////////////////////////////////////////////////////////////
// MSIN Commands
//
#define IDM_MSIN                        0x8a00
#define ID_SEARCH                       0x8a01
#define ID_QUERY_RESULTS                0x8a02
#define ID_SELECT_TITLE                 0x8a10
#define ID_SELECT_SUBSET                0x8a11
#define ID_FIND_FIND                    0x8a12
#define ID_FIND_KEYWORD                 0x8a13
#define ID_RESULTS_FIND                 0x8a14
#define ID_RESULTS_HISTORY              0x8a15
#define ID_BACK                         0x8a16
#define ID_NEXT                         0x8a17
#define ID_PREV                         0x8a18
#define ID_FIND_NEXT                    0x8a19
#define ID_BOOK_NEXT                    0x8a1a
#define ID_FIND_PREV                    0x8a1b
#define ID_BOOK_PREV                    0x8a1c
#define ID_PRINT_TOPIC                  0x8a1d
#define ID_PRINT_TOC                    0x8a1e
#define ID_SYNC                         0x8a1f
#define ID_TOGGLE_HIGHLIGHTS            0x8a20
#define ID_ADD_BOOKMARK                 0x8a21
#define ID_EDIT_BOOKMARK                0x8a22
#define ID_WHATSNEW                     0x8a24
#define ID_COPYTOPIC                    0x8a25
#define ID_SELECTION_RIGHT              0x8a26
#define ID_SELECTION_LEFT               0x8a27
#define ID_SELECTION_UP                 0x8a28
#define ID_SELECTION_DOWN               0x8a29
#define ID_SELECTION_ENTIRE             0x8a2a
#define ID_SEEALSO                      0x8a2b
#define ID_FIRST_TOPIC                  0x8a2c
#define ID_HOME_SCREEN                  0x8a2d
#define ID_EDIT_HELPBOOKMARKS           0x8a2e
#define ID_EDIT_ANNOTATION              0x8a30
#define ID_ADD_ANNOTATION               0x8a31
#define ID_NEXT_BOOKMARK                0x8a32
#define ID_PREV_BOOKMARK                0x8a33
#define ID_NEXT_LIST                    0x8a34
#define ID_PREV_LIST                    0x8a35
#define ID_SHOWBAR                      0x8a37
#define ID_SHOWNSR                      0x8a38
#define ID_DISPLAY_OPTIONS              0x8a39
#define ID_FIND_OPTIONS                 0x8a3a
#define ID_DEFINE_SUBSETS               0x8a3b
#define ID_SWITCHMVB                    0x8a3c
#define ID_NEXT_BOOKMARK_LIST           0x8a3d
#define ID_PREV_BOOKMARK_LIST           0x8a3e
#define ID_HELP_QUERY_RESULTS           0x8a3f
#define ID_HELP_BOOKMARK_LIST           0x8a40
#define ID_NEXT_JUMP                    0x8a41
#define ID_SEEALSOP                     0x8a42
#define ID_BACKP                        0x8a43
#define ID_HELPP                        0x8a44
#define ID_TOPIC                        0x8a45
#define ID_MSIN_OPEN                    0x8a46
#define ID_MSIN_ABOUT                   0x8a47
#define ID_NEXT_HIGHLIGHT               0x8b48
#define ID_PREV_HIGHLIGHT               0x8b49
#define ID_MSIN_PRINT_SETUP             0x8b4a
#define ID_HELP_KEYBOARD                0x8a4b
#define IDM_TOGGLE_TOPICWIN             0x8a4c
#define ID_SET_SUBSET                   0x8a4d
#define ID_EDIT_SELECTALL_POPUP         0x8a4e
#define ID_PREV_JUMP                    0x8a4f
#define ID_HELP_WEB                     0x8a50
#define ID_HELP_ESPRESSO                0x8a51

//////////////////////////////////////////////////////////
//
// New IV command defines here.
//
#define ID_IV_HOME                         MIN_IV_COMMAND_ID + 1
#define ID_IV_URL_SF                       MIN_IV_COMMAND_ID + 2
#define ID_IV_OPEN_URL                     MIN_IV_COMMAND_ID + 3 
#define ID_IV_SYNC                         MIN_IV_COMMAND_ID + 4 
#define ID_IV_BACK                         MIN_IV_COMMAND_ID + 5 
#define ID_IV_NEXT                         MIN_IV_COMMAND_ID + 6 
#define ID_IV_PREV                         MIN_IV_COMMAND_ID + 7
#define ID_IV_FORWARD                      MIN_IV_COMMAND_ID + 8
#define ID_IV_REFRESH                      MIN_IV_COMMAND_ID + 9
#define ID_IV_STOP_DOWNLOAD                MIN_IV_COMMAND_ID + 10
#define ID_IV_LIST_BOOKMARKS               MIN_IV_COMMAND_ID + 11
#define ID_IV_ADD_BOOKMARK                 MIN_IV_COMMAND_ID + 12
#define ID_IV_PREV_BOOKMARK                MIN_IV_COMMAND_ID + 13
#define ID_IV_NEXT_BOOKMARK                MIN_IV_COMMAND_ID + 14
#define ID_IV_DEF_SUBSET                   MIN_IV_COMMAND_ID + 15
#define ID_IV_SELECT_SUBSET                MIN_IV_COMMAND_ID + 16
#define ID_IV_SELECT_TOC_SUBSET_COMBO      MIN_IV_COMMAND_ID + 17
#define ID_IV_SEARCH                       MIN_IV_COMMAND_ID + 18
#define ID_IV_RESULTS_LIST                 MIN_IV_COMMAND_ID + 19
#define ID_IV_TOPIC_WINDOW                 MIN_IV_COMMAND_ID + 20
#define ID_IV_NEXT_LISTITEM                MIN_IV_COMMAND_ID + 21
#define ID_IV_PREV_LISTITEM                MIN_IV_COMMAND_ID + 22
#define ID_IV_QUERY                        MIN_IV_COMMAND_ID + 23
#define ID_IV_KEYWORD_INDEX                MIN_IV_COMMAND_ID + 24
#define ID_IV_SEARCH_LIST                  MIN_IV_COMMAND_ID + 25
#define ID_IV_NEXT_SEARCH                  MIN_IV_COMMAND_ID + 26
#define ID_IV_PREV_SEARCH                  MIN_IV_COMMAND_ID + 27
#define ID_IV_QUERY_LIST                   MIN_IV_COMMAND_ID + 28
#define ID_IV_NEXT_QUERY                   MIN_IV_COMMAND_ID + 29
#define ID_IV_PREV_QUERY                   MIN_IV_COMMAND_ID + 30
#define ID_IV_RESULTS_LIST_SHOWDETAIL      MIN_IV_COMMAND_ID + 31
#define ID_IV_RESULTS_LIST_SHOWLIST        MIN_IV_COMMAND_ID + 32
#define ID_IV_PRINT_TOC                    MIN_IV_COMMAND_ID + 33
#define ID_IV_HELP_CONTENTS                MIN_IV_COMMAND_ID + 34
#define ID_IV_HELP_ABOUT                   MIN_IV_COMMAND_ID + 35
#define ID_IV_DOWNLOADCOMPLETE             MIN_IV_COMMAND_ID + 36
#define ID_IV_FONT_SIZE                    MIN_IV_COMMAND_ID + 37

//////////////////////////////////////////////////////////////
//
// The following commands are handled by the MSIN macro system
//
#define IDM_MSIN_MACRO_FIRST    0x8b00  //ID of first one
#define IDM_NEXT_HIGHLIGHT              0x8b00
#define IDM_PREV_HIGHLIGHT              0x8b01
#define IDM_ANNOTATION                  0x8b02
#define IDM_MSIN_MACRO_LAST             0x8b02  //ID of last one

/////////////////////////////////////////////////////////////////////
// Classview/Wizard Commands
//
// TODO(davidga): reconcile this with the CLASSVIEW_COMMAND_ID range
// possible creating a CLASSVIEW_STRING_ID range
#define IDM_CLASSVIEW_FIRST             (MIN_CLASSVIEW_COMMAND_ID)
#define IDM_ADDCLASS                    (IDM_CLASSVIEW_FIRST+0)
#define IDM_ADDATLCOMP                  (IDM_CLASSVIEW_FIRST+1)
#define IDM_GALLERY                     (IDM_CLASSVIEW_FIRST+2)
#define IDMY_CLASSWIZARD                (IDM_CLASSVIEW_FIRST+3)
#define IDM_CLASSVIEW_LAST              (IDM_CLASSVIEW_FIRST+3)


#define IDM_WIZBARU_CLASS               (IDM_CLASSVIEW_LAST+1)
#define IDM_WIZBARU_OBJECT              (IDM_CLASSVIEW_LAST+2)
#define IDM_WIZBARU_TARGET              (IDM_CLASSVIEW_LAST+3)
#define IDM_WIZBARU_ACTION              (IDM_CLASSVIEW_LAST+4)

//  wizard bar commands that can be assigned to keys
#define ID_WIZBARU_COMBO_CLASS          (IDM_CLASSVIEW_LAST+5)  // activate the class combo
#define ID_WIZBARU_COMBO_OBJECT         (IDM_CLASSVIEW_LAST+6)
#define ID_WIZBARU_COMBO_TARGET         (IDM_CLASSVIEW_LAST+7)
#define ID_WIZBARU_CTL_ACTION           (IDM_CLASSVIEW_LAST+8)
 
#define IDM_WIZBARU_COMMANDS            (IDM_CLASSVIEW_LAST+9)  // menu entry for tools customize

#define IDM_WIZBARU_CMD_FIRST            (IDM_CLASSVIEW_LAST+10)    // first generic or shared WB command

#define IDM_WIZBARU_DEFAULT               (IDM_WIZBARU_CMD_FIRST)  // current appropriate default action for client

#define IDM_WIZBARNCB_GOFUNCIMPL          (IDM_WIZBARU_CMD_FIRST + 1)
#define IDM_WIZBARNCB_GOFUNCNEXT          (IDM_WIZBARU_CMD_FIRST + 2)
#define IDM_WIZBARNCB_GOFUNCPREV          (IDM_WIZBARU_CMD_FIRST + 3)
#define IDM_WIZBARNCB_DELETE              (IDM_WIZBARU_CMD_FIRST + 4)
#define IDM_WIZBARNCB_CREATE              (IDM_WIZBARU_CMD_FIRST + 5)
#define IDM_WIZBARNCB_NEW_FUNC            (IDM_WIZBARU_CMD_FIRST + 6)
#define IDM_WIZBARNCB_GOCLASSDEF          (IDM_WIZBARU_CMD_FIRST + 7)

#define IDM_WIZBARU_CMD_LAST              (IDM_WIZBARNCB_GOCLASSDEF)    // last generic or shared WB command 
// NOTE: non-default Wizard Bar command ids added by clients to menus  are defined in the client's package

// note: Gallery/Explorer uses MANY id's. It uses them for its context menu's which
//        it builds from the Explorer/Shell's menus.

#define IDM_CREATENEWCLASS              (IDM_WIZBARU_CMD_LAST + 1)
#define IDM_NEWATLCOMP                  (IDM_WIZBARU_CMD_LAST + 2)
#define IDM_CREATENEWFORM               (IDM_WIZBARU_CMD_LAST + 3)
#define IDM_ADDFORM                     (IDM_WIZBARU_CMD_LAST + 4)

#define IDM_GALLERY_FIRST               (IDM_ADDFORM + 1)
#define IDM_GAL_ADDTOPROJECT            (IDM_GALLERY_FIRST+ 1)
#define IDM_GAL_RUN                     (IDM_GAL_ADDTOPROJECT+ 1)
#define IDM_GAL_OPEN                    (IDM_GAL_RUN+ 1)
#define IDM_GAL_INSTALL                 (IDM_GAL_OPEN+ 1)
#define IDM_GAL_SETPATH                 (IDM_GAL_INSTALL+ 1)
#define IDM_GAL_NEWFOLDER               (IDM_GAL_SETPATH+ 1)
#define IDM_GAL_CUT                     (IDM_GAL_NEWFOLDER+ 1)
#define IDM_GAL_COPY                    (IDM_GAL_CUT+ 1)
#define IDM_GAL_PASTE                   (IDM_GAL_COPY+ 1)
#define IDM_GAL_DISCONNECT              (IDM_GAL_PASTE+ 1)
#define IDM_GAL_CREATESHORTCUT          (IDM_GAL_DISCONNECT+ 1)
#define IDM_GAL_DELETE                  (IDM_GAL_CREATESHORTCUT+ 1)
#define IDM_GAL_RENAME                  (IDM_GAL_DELETE+ 1)
#define IDM_GAL_HELP                    (IDM_GAL_RENAME+ 1)
#define IDM_GAL_SEARCH                  (IDM_GAL_HELP+ 1)
#define IDM_EXPLORERCONTEXTMENU_BASE    (IDM_GAL_SEARCH + 1)
#define IDM_EXPLORERCONTEXTMENU_0       (IDM_EXPLORERCONTEXTMENU_BASE + 0)

// ... go all the way to end
// stolen id's for gallery
#define IDM_GAL_LAST                    (MAX_CLASSVIEW_COMMAND_ID)
#define IDM_EXPLORERCONTEXTMENU_LAST    (MAX_CLASSVIEW_COMMAND_ID)

// Commands which are dynamically bound to actions via the CDynCT instance in CTheApp.
#define IDM_DYNAMIC_BASE                0x8d00
#define IDM_DYNAMIC_LAST                0x8eff

/////////////////////////////////////////////////////////////////////
// Project Window Commands
//
#define IDM_PROJECT_FIRST                               0x8c00
#define IDM_PROJECT_LAST                                0x8cff

#define IDM_PRJWIN_FIRST            0x8f00
#define IDM_ADDFOLDER               (IDM_PRJWIN_FIRST+0)
#define IDM_ADDSUBFOLDER            (IDM_PRJWIN_FIRST+1)
#define IDM_ADDMENU                 (IDM_PRJWIN_FIRST+2)
#define IDM_ADDSELECTEDNODE         (IDM_PRJWIN_FIRST+3)
#define IDM_ADDPANE                 (IDM_PRJWIN_FIRST+4)
#define IDM_DELETEPANE              (IDM_PRJWIN_FIRST+5)
#define IDM_ADDPROVIDEDNODE1        (IDM_PRJWIN_FIRST+6)
#define IDM_ADDPROVIDEDNODE2        (IDM_PRJWIN_FIRST+7)
#define IDM_ADDPROVIDEDNODE3        (IDM_PRJWIN_FIRST+8)
#define IDM_ADDPROVIDEDNODE4        (IDM_PRJWIN_FIRST+9)
#define IDM_ADDPROVIDEDNODE5        (IDM_PRJWIN_FIRST+10)
#define IDM_ADDPROVIDEDNODE6        (IDM_PRJWIN_FIRST+11)
#define IDM_ADDPROVIDEDNODE7        (IDM_PRJWIN_FIRST+12)
#define IDM_ADDPROVIDEDNODE8        (IDM_PRJWIN_FIRST+13)
#define IDM_ADDPROVIDEDNODE9        (IDM_PRJWIN_FIRST+14)
#define IDM_ADDPROVIDEDNODE10       (IDM_PRJWIN_FIRST+15)
#define IDM_ADDPROVIDEDNODE11       (IDM_PRJWIN_FIRST+16)
#define IDM_ADDPROVIDEDNODE12       (IDM_PRJWIN_FIRST+17)
#define IDM_ADDPROVIDEDNODE13       (IDM_PRJWIN_FIRST+18)
#define IDM_ADDPROVIDEDNODE14       (IDM_PRJWIN_FIRST+19)
#define IDM_ADDPROVIDEDNODE15       (IDM_PRJWIN_FIRST+20)
#define IDM_ADDPROVIDEDNODE16       (IDM_PRJWIN_FIRST+21)
#define IDM_SLOB_DEFAULTCMD         (IDM_PRJWIN_FIRST+22)
#define IDM_TOGGLE_TITLETIPS        (IDM_PRJWIN_FIRST+23)
#define IDM_OPEN_WORKSPACE          (IDM_PRJWIN_FIRST+24)
#define IDM_CLOSE_WORKSPACE         (IDM_PRJWIN_FIRST+25)
#define IDM_TOGGLE_SHOWTITLE        (IDM_PRJWIN_FIRST+26)
#define IDM_PANE1_VISIBLE           (IDM_PRJWIN_FIRST+27)
#define IDM_PANE2_VISIBLE           (IDM_PRJWIN_FIRST+28)
#define IDM_PANE3_VISIBLE           (IDM_PRJWIN_FIRST+29)
#define IDM_PANE4_VISIBLE           (IDM_PRJWIN_FIRST+30)
#define IDM_PANE5_VISIBLE           (IDM_PRJWIN_FIRST+31)
#define IDM_PANE6_VISIBLE           (IDM_PRJWIN_FIRST+32)
#define IDM_PANE7_VISIBLE           (IDM_PRJWIN_FIRST+33)
#define IDM_PANE8_VISIBLE           (IDM_PRJWIN_FIRST+34)
#define IDM_PANE9_VISIBLE           (IDM_PRJWIN_FIRST+35)
#define IDM_INSERT_PROJECTS         (IDM_PRJWIN_FIRST+36)
#define IDM_SAVE_WORKSPACE          (IDM_PRJWIN_FIRST+37)
#define IDM_FILE_RENAME             (IDM_PRJWIN_FIRST+38)       // Rename command
#define IDM_PROJECT_COMBO_ALIAS     (IDM_PRJWIN_FIRST+39)       // Activates Proj Combo
#define IDM_ADD_NEW_PROJECT         (IDM_PRJWIN_FIRST+40)

// Begin Class View specific
#define IDM_CLSVIEW_GOTO_DECL       (IDM_PRJWIN_FIRST+50)
#define IDM_CLSVIEW_DERIVED_CLASSES (IDM_PRJWIN_FIRST+51)
#define IDM_CLSVIEW_BASE_CLASSES    (IDM_PRJWIN_FIRST+52)
#define IDM_CLSVIEW_REFS            (IDM_PRJWIN_FIRST+53)
#define IDM_CLSVIEW_CALLED_FUNCS    (IDM_PRJWIN_FIRST+54)
#define IDM_CLSVIEW_CALLING_FUNCS   (IDM_PRJWIN_FIRST+55)
#define IDM_CLSVIEW_ADD_MF          (IDM_PRJWIN_FIRST+56)
#define IDM_CLSVIEW_ADD_MV          (IDM_PRJWIN_FIRST+57)
#define IDM_GROUPBYACCESS           (IDM_PRJWIN_FIRST+58)
#define IDM_CLSVIEW_ADD_TO_GALLERY  (IDM_PRJWIN_FIRST+59)
#define IDM_CLSVIEW_ADD_IPROP       (IDM_PRJWIN_FIRST+60)
#define IDM_CLSVIEW_ADD_IMETH       (IDM_PRJWIN_FIRST+61)
#define IDM_CLSVIEW_ADD_IEVENT      (IDM_PRJWIN_FIRST+62)
// End Class View specific
// Begin Source Control specific
#define IDM_SCC_FIRST               (IDM_PRJWIN_FIRST+80)
#define IDM_SCC_POP                 (IDM_SCC_FIRST+0)
#define IDM_SCC_GET                 (IDM_SCC_FIRST+1)
#define IDM_SCC_OUT                 (IDM_SCC_FIRST+2)
#define IDM_SCC_IN                  (IDM_SCC_FIRST+3)
#define IDM_SCC_UNOUT               (IDM_SCC_FIRST+4)
#define IDM_SCC_ADD                 (IDM_SCC_FIRST+5)
#define IDM_SCC_REMOVE              (IDM_SCC_FIRST+6)
#define IDM_SCC_HISTORY             (IDM_SCC_FIRST+7)
#define IDM_SCC_DIFF                (IDM_SCC_FIRST+8)
#define IDM_SCC_PROPS               (IDM_SCC_FIRST+9)
#define IDM_SCC_SHARE               (IDM_SCC_FIRST+10)
#define IDM_SCC_ADMIN               (IDM_SCC_FIRST+11)
#define IDM_SCC_REFRESH             (IDM_SCC_FIRST+12)
#define IDM_SCC_LAST                (IDM_SCC_FIRST+19) // (IDM_PRJWIN_FIRST+99)
// End Source Control specific
#define IDM_PRJWIN_LAST                 0x8FFF  // (IDM_PRJWIN_FIRST + 255)

// Fortran commands
#define ID_FORMAT_EDITOR            MIN_FORTRAN_COMMAND_ID

// LangCPP commands
#define IDM_WIZBARCPP_CMD_FIRST           (MIN_LANGCPP_COMMAND_ID)    // first in range of wizard bar actions

#define IDM_WIZBARCPP_GOFUNCDECL          (IDM_WIZBARCPP_CMD_FIRST+0)
#define IDM_WIZBARCPP_GOFUNCIMPLBASE      (IDM_WIZBARCPP_CMD_FIRST+1)
#define IDM_WIZBARCPP_GOFUNCDECLBASE      (IDM_WIZBARCPP_CMD_FIRST+2)
#define IDM_WIZBARCPP_NEW_WINMSG          (IDM_WIZBARCPP_CMD_FIRST+3)
#define IDM_WIZBARCPP_NEW_VIRT            (IDM_WIZBARCPP_CMD_FIRST+4)
#define IDM_WIZBARCPP_NEW_VAR             (IDM_WIZBARCPP_CMD_FIRST+5)
#define IDM_WIZBARCPP_GODIALOG            (IDM_WIZBARCPP_CMD_FIRST+6) 

// editor specific commands
#define IDM_WIZBARCPP_OPEN_INCLUDE        (IDM_WIZBARCPP_CMD_FIRST+7)

#define IDM_WIZBARCPP_CMD_LAST            (IDM_WIZBARCPP_OPEN_INCLUDE + 1)    // last in range of wizard bar actions (plus buffer)

#define IDM_ADD_MF                        (IDM_WIZBARCPP_CMD_LAST+1)
#define IDM_ADD_MV                        (IDM_WIZBARCPP_CMD_LAST+2)
#define IDM_ADD_TO_GALLERY                (IDM_WIZBARCPP_CMD_LAST+3)

#define ID_AUTO_COMPLETE                  (IDM_WIZBARCPP_CMD_LAST+4)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//  Status Bar Indicator IDs
//      Note that several "standard" ones (ID_INDICATOR_OVR, ID_INDICATOR_CAPS,
//      ID_INDICATOR_NUM) are defined by MFC.

#define ID_INDICATOR_LNCOL              20192
#define ID_INDICATOR_READ               20193
#define ID_INDICATOR_POSITION           20194
#define ID_INDICATOR_SIZE               20195
#define ID_INDICATOR_ZOOM               20196
#define ID_INDICATOR_CLOCK              20197
#define ID_INDICATOR_OFFSET             20198
#define ID_INDICATOR_EXTENT             20199

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Help IDs and ranges

#ifndef HID_BASE_RESOURCE
#define HID_BASE_RESOURCE           0x20000 // Afx Standard
#endif

// SRC
#define HID_WND_TEXT                    0x28001
#define HID_WND_OUTPUT                  0x28002
#define HID_WND_MEMORY                  0x28003
#define HID_WND_VARS                    0x28004
#define HID_WND_WATCH                   0x28005
#define HID_WND_CALL_STACK              0x28006
#define HID_WND_REGISTERS               0x28007
#define HID_WND_DISASSEMBLY             0x28008
// SRC range
#define MIN_SOURCE_WINDOW_ID            HID_WND_TEXT
#define MAX_SOURCE_WINDOW_ID            HID_WND_DISASSEMBLY

// RES
#define HID_WND_RESOURCE_BROWSER        0x28010
#define HID_WND_DIALOG                  0x28011
#define HID_WND_MENU                    0x28012
#define HID_WND_BITMAP                  0x28013
#define HID_WND_CURSOR                  0x28014
#define HID_WND_ICON                    0x28015
#define HID_WND_STRING                  0x28016
#define HID_WND_ACCEL                   0x28017
#define HID_WND_VERSION                 0x28018
#define HID_WND_BINARY                  0x28019
#define HID_WND_IMAGE_TOOLS             0x2801a
#define HID_WND_DIALOG_TOOLS            0x2801b
#define HID_WND_BITMAP_TEXTTOOL         0x2801c
#define HID_WND_TOOLBAR_EDIT            0x2801d
#define HID_WND_RESOURCEVIEW            0x2801e
// RES range
#define MIN_RES_WINDOW_ID               HID_WND_RESOURCE_BROWSER
#define MAX_RES_WINDOW_ID               HID_WND_RESOURCEVIEW

// PRJ
#define HID_WND_PROJECT_WORKSPACE       0x28020
// PRJ range
#define MIN_WORKSPACE_WINDOW_ID         HID_WND_PROJECT_WORKSPACE
#define MAX_WORKSPACE_WINDOW_ID         HID_WND_PROJECT_WORKSPACE

// MSIN
#define HID_WND_TOPIC                   0x28030
// MSIN range
#define MIN_MSIN_WINDOW_ID              HID_WND_TOPIC
#define MAX_MSIN_WINDOW_ID              HID_WND_TOPIC

// IV
#define HID_WND_TOPIC2                  0x28035
#define HID_WND_INFOVIEW                0x28036
// IV range
#define MIN_IV_WINDOW_ID                HID_WND_TOPIC2
#define MAX_IV_WINDOW_ID                HID_WND_INFOVIEW

// MS-Test
#define HID_WND_TEST_LOCALS             0x28040
#define HID_WND_TEST_WATCH              0x28041
// MS-Test range
#define MIN_TEST_WINDOW_ID              HID_WND_TEST_LOCALS
#define MAX_TEST_WINDOW_ID              HID_WND_TEST_WATCH

// BLD
#define HID_WND_FILEVIEW                0x28050
// BLD range
#define MIN_BLD_WINDOW_ID               HID_WND_FILEVIEW
#define MAX_BLD_WINDOW_ID               HID_WND_FILEVIEW

// ClassView
#define HID_WND_CLASSVIEW               0x28060
// ClassView range
#define MIN_CLASSVIEW_WINDOW_ID         HID_WND_CLASSVIEW
#define MAX_CLASSVIEW_WINDOW_ID         HID_WND_CLASSVIEW

// DTG/ENT
#define HID_WND_DATAVIEW                0x28070
// DTG/ENT range
#define MIN_DTGENT_WINDOW_ID            HID_WND_DATAVIEW
#define MAX_DTGENT_WINDOW_ID            HID_WND_DATAVIEW

// In a number of places, several dialogs share a single dialog template.
// The following dialog IDs are used solely for generating separate help
// contexts for such cases, and do not actually have any dialog templates
// associated with them.
//
#define IDD_REGISTER_CONTROL        0x3990
#define IDD_PROFILE_BROWSE          0x2010
#define IDD_GOTOADDR                0x6978
#define IDD_FILE_SAVE_AS            0x7005
#define IDD_FILE_NEW                0x7801

#define IDD_IMAGE_NEWICONIMAGE      0x0F20
#define IDD_IMAGE_NEWCURSORIMAGE    0x0F21
#define IDD_IMAGE_OPENICONIMAGE     0x0F22
#define IDD_IMAGE_OPENCURSORIMAGE   0x0F23
#define IDD_IMAGE_COLOR             0x0F30
#define IDD_DIR_PICKER              0x0F50
#define IDD_DIR_FINDFILE            0x0F51
#define IDD_ADDTOOL_FILE_OPEN       0x0F60
#define IDD_PROJ_ADDDEP             0x0F70
#define IDD_PROJ_SELECT_TARGET      0x0F71

#define IDDP_BROWSE_DEFREF          0x8101
#define IDDP_BROWSE_FILEOUTLINE     0x8102
#define IDDP_BROWSE_BASEGRAPH       0x8103
#define IDDP_BROWSE_DERVGRAPH       0x8104
#define IDDP_BROWSE_CALLGRAPH       0x8105
#define IDDP_BROWSE_REVCALLGRAPH    0x8106

#define IDDP_RESOURCE_CURSOR        0x8121
#define IDDP_RESOURCE_ICON          0x8122

//  Needed for compatibility when converting 4.x .mdp files
//
//  Streams used in a project's MSF file.  Since we use 512 byte pages, these
//  numbers must be  between 0 and 256
//
#define PROJ_MSF_PROJINTINFO    0   // Internal project info
#define PROJ_MSF_PROJEXTINFO    1   // External project info
#define PROJ_MSF_WORKSPACE      2
#define PROJ_MSF_VCPPINFO       3
#define PROJ_MSF_BRSINFO        4
#define PROJ_MSF_PROJSYSINFO    5   // new project system info
#define PROJ_MSF_PROJSCCINFO    6   // project source control info
#define PROJ_MSF_HELPINFO       7   // help system info
#define PROJ_MSF_ENT                    9       // Enterprise package info
#define PROJ_MSF_DBASE          50  // no-compile browse info
                    // this must be the last one
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//  Package notification IDs.
//      REVIEW(BrendanX):  Use GUIDs.

#define PN_NEW_PROJECT          1
#define PN_OPEN_PROJECT         2
#define PN_CLOSE_PROJECT        3
#define PN_BEGIN_BUILD          4
#define PN_END_BUILD            5
#define PN_START_BSCMAKE        6
#define PN_END_BSCMAKE          7
#define PN_CHANGE_PROJECT       8
#define PN_CHANGE_BSC           9
#define PN_CHANGE_CONFIG        10
#define PN_CHANGE_PLATFORM      11
#define PN_FULL_SCREEN          12
#define PN_FULL_SCREEN_END      13
#define PN_ADD_FILE             14
#define PN_DEL_FILE             15
#define PN_ADD_TARGET           16
#define PN_DEL_TARGET           17
#define PN_DBASE_CHANGE         18
#define PN_WORKSPACE_INIT       19
#define PN_WORKSPACE_CLOSE      20
#define PN_BEGIN_MULTIOP        21
#define PN_END_MULTIOP          22
#define PN_ADD_FILESET          23
#define PN_DEL_FILESET          24
#define PN_ADD_RCFILE           25
#define PN_DEL_RCFILE           26
#define PN_EXTCHNG_PROJECT      27
#define PN_BLD_SETTINGS_CHANGED 29
#define PN_END_PARSEPROJECT     30
#define PN_BEGIN_SCCOP          31
#define PN_END_SCCOP            32
#define PN_DIRECTORIES_CHANGED  33
#define PN_RENAME_FILE          34
#define PN_DEL_PROJECTDEP       35
#define PN_DOCKMGR_LOADED       36

// Notifcatations after PN_FIRST_VETO are actaully queries to the 
// packages. If any package returns FALSE for these notfications,
// the sender should abort whatever its trying to do.  For example,
// the build systems sends PN_QUERY_BEGIN_BUILD before starting
// a build.  The debugger, when it gets this and debugging is active
// brings up its warning message box and returns false if the user
// hits cancel

#define PN_FIRST_VETO               100
#define PN_QUERY_NEW_PROJECT        100
#define PN_QUERY_OPEN_PROJECT       101
#define PN_QUERY_CLOSE_PROJECT      102
#define PN_QUERY_BEGIN_BUILD        103
#define PN_QUERY_CHANGE_CONFIG      104
#define PN_QUERY_NEW_WORKSPACE      105
#define PN_QUERY_OPEN_WORKSPACE     106
#define PN_QUERY_CLOSE_WORKSPACE    107
#define PN_QUERY_DEL_FILE           108
#define PN_QUERY_DEL_FILESET        109
#define PN_BLD_INIT_COMPLETE        110
#define PN_QUERY_RENAME_FILE        111

//Resource Editor Menus, Groups and ToolBars

#define IDM_DLGEDITOR_TOOLBAR       5000
//#define IDM_RESOURCE_TOOLBAR        5010
#define IDM_UNDEFINED               5020
#define IDM_RESVIEW_CTXT            5030
#define IDM_EDITOR_CTXT             5040
#define IDM_DIALOG_CTXT             5050
#define IDM_STRING_CTXT             5060
#define IDM_VERSION_CTXT            5070
#define IDM_BINEDIT_CTXT            5080

//Groups for the Dialog Editor Toolbar
#define IDG_DLGEDITOR_TEST          6000
#define IDG_DLGEDITOR_ALIGN         6010
#define IDG_DLGEDITOR_CENTER        6020
#define IDG_DLGEDITOR_SPACE         6030
#define IDG_DLGEDITOR_SAME          6040
#define IDG_DLGEDITOR_TOGGLE        6050

//Resource view/doc groups
#define IDG_RESEDIT_UNDEFINED       6060
#define IDG_RESVIEW_RESSYM          6070
#define IDG_RESVIEW_INSERT          6080

//yet more groups
#define IDG_CUT_COPY_PASTE          6090
#define IDG_EDITOR_CTX_1            6100
#define IDG_EDITOR_CTX_2            6110
#define IDG_EDITOR_CTX_3            6120
#define IDG_EDITOR_CTX_4            6130
#define IDG_EDITOR_PROP             6140
#define IDG_UNDO_REDO               6150

//Image editor groups
#define IDM_IMGEDITOR_TOOLBAR       5080
#define IDG_IMGTOOLS                5100
#define IDG_IMG_DRAW                5102
#define IDG_IMG_RECT                5104
//#define IDG_IMGCOLORS               5110
#define IDG_IMG_MISC                5112

//even more groups
#define IDG_RESVIEW_OPEN            5200

//"Main menu" menus
#define IDM_MAIN_IMAGE              502

#define IDM_LAYOUT_ALIGN            510
#define IDM_LAYOUT_SPACE            511
#define IDM_LAYOUT_SIZE             512
#define IDM_LAYOUT_ARRANGE          513
#define IDM_LAYOUT_CENTER           514
#define IDM_LAYOUT_AUTOSIZE         515

//"Main menu" groups
#define IDG_VC_MENU                 520

#define IDG_MAIN_IMAGE1             522
#define IDG_MAIN_IMAGE2             523
#define IDG_MAIN_IMAGE3             524
#define IDG_MAIN_IMAGE4             525
#define IDG_MAIN_IMAGE5             526
#define IDM_MAIN_IMAGE5             527
#define IDG_TOOL_IMAGE1             528
#define IDG_TOOL_IMAGE2             529
#define IDG_TOOL_IMAGE3             530

#define IDG_MAIN_LAYOUT1            535
#define IDG_MAIN_LAYOUT2            536
#define IDG_MAIN_LAYOUT3            537

#define IDG_LAYOUT_ALIGN            540
#define IDG_LAYOUT_SPACE            541
#define IDG_LAYOUT_SIZE             542
#define IDG_LAYOUT_ARRANGE          543
#define IDG_LAYOUT_CENTER           544
#define IDG_LAYOUT_AUTOSIZE         545

//and still, even more gropus than the even more groups listed above
#define IDG_RESOURCE_TOOLBAR        6500  

#endif  // __IDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vcvsutil.h ===
#pragma once

// VCUGetHierarchyAndItemFromFileName will do just what the name implies.
HRESULT VCUGetHierarchyAndItemFromFileName(BSTR bstrFileName, IVsHierarchy ** ppIVsHierarchy, VSITEMID * pItemID);

// VCUOpenFile will open the file
HRESULT VCUOpenFile(BSTR bstrFileName, bool bShow, IVsTextView** ppView);

// VCOpenTextLines will create just the buffer, but not open the file
HRESULT VCUOpenTextLines(BSTR bstrFileName, IVsTextLines** ppTextLines);

// Default to VC Package
__declspec(selectany) extern const char g_ptszVCPackageUISatelliteDLL[] = "vcpkgui.dll";

// VCUGetResourceInstance will also do just what the name implies.
HINSTANCE VCUGetResourceInstance(const char * ptszUISatelliteDLL = g_ptszVCPackageUISatelliteDLL);
HINSTANCE VCUGetResourceInstance(const wchar_t * ptszUISatelliteDLL);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vcextgd.h ===
// vcextgd.h external vc guids.


// Interface ID for VCSrevice 
// {411479A0-AC5F-11d0-A4F0-00A0C90A6332}
DEFINE_GUID(SID_SVCService, 
0x411479a0, 0xac5f, 0x11d0, 0xa4, 0xf0, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x32);


// menu comands and group that defined by the build system
// {6CD672F3-9C1A-11d1-ADE3-00C04FB6BE4C}
DEFINE_GUID (guidVCPCmdId,
0x6cd672f3, 0x9c1a, 0x11d1, 0xad, 0xe3, 0x0, 0xc0, 0x4f, 0xb6, 0xbe, 0x4c);


// {6CD672F5-9C1A-11d1-ADE3-00C04FB6BE4C}
DEFINE_GUID (guidCppSvcCmdId,
0x6cd672f5, 0x9c1a, 0x11d1, 0xad, 0xe3, 0x0, 0xc0, 0x4f, 0xb6, 0xbe, 0x4c);

// {6CD672F4-9C1A-11d1-ADE3-00C04FB6BE4C}
DEFINE_GUID (guidVCPGrpId,
0x6cd672f4, 0x9c1a, 0x11d1, 0xad, 0xe3, 0x0, 0xc0, 0x4f, 0xb6, 0xbe, 0x4c);

// {6CD672F6-9C1A-11d1-ADE3-00C04FB6BE4C}
DEFINE_GUID (guidCppSvcGrpId,
0x6cd672f6, 0x9c1a, 0x11d1, 0xad, 0xe3, 0x0, 0xc0, 0x4f, 0xb6, 0xbe, 0x4c);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\vcguid.h ===
//=[f========================================================================
// 	vcguid.h
//
//	Guids defined for IStudio. Include after <initguid.h> to define storage.
//
//	Copyright (C) 1996 Microsoft Corporation,
//	All rights reserved.
//
//=f]========================================================================

// VS6 VC Project GUID for VsHierarchy, VsUIHierarchy
// {8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}
DEFINE_GUID(IID_IVCArchy, 0x8bc9ceb8, 0x8b4a, 0x11d0, 0x8d, 0x11, 0x0, 0xa0, 0xc9, 0x1b, 0xc9, 0x42);

// {8BC9CEB9-8B4A-11D0-8D11-00A0C91BC942}
DEFINE_GUID(IID_IExeHierarchy, 0x8bc9ceb9, 0x8b4a, 0x11d0, 0x8d, 0x11, 0x0, 0xa0, 0xc9, 0x1b, 0xc9, 0x42);

// {8BC9CEB9-9B4A-11D0-8D11-00A0C91BC942}
DEFINE_GUID(IID_ICrashDumpHierarchy, 0x8bc9ceb9, 0x9b4a, 0x11d0, 0x8d, 0x11, 0x0, 0xa0, 0xc9, 0x1b, 0xc9, 0x42);

// {75A84468-C7B7-4d00-A17A-B052BDBE2E21}
DEFINE_GUID(IID_IVUPHierarchy, 0x75a84468, 0xc7b7, 0x4d00, 0xa1, 0x7a, 0xb0, 0x52, 0xbd, 0xbe, 0x2e, 0x21);

// {8BC9CEC0-8B4A-11D0-8D11-00A0C91BC942}
DEFINE_GUID(IID_IVCAddClassHierarchy, 0x8bc9ceba, 0x8b4a, 0x11d0, 0x8d, 0x11, 0x0, 0xa0, 0xc9, 0x1b, 0xc9, 0x42);

// {77280048-B6B7-11d0-AD88-00C04FB6BE4C}
DEFINE_GUID(guidVCGrpId, 
	0x77280048, 0xb6b7, 0x11d0, 0xad, 0x88, 0x0, 0xc0, 0x4f, 0xb6, 0xbe, 0x4c);

// {041CB556-B6A5-11d0-AD88-00C04FB6BE4C}
DEFINE_GUID(guidVCCmdId,
	0x41cb556, 0xb6a5, 0x11d0, 0xad, 0x88, 0x0, 0xc0, 0x4f, 0xb6, 0xbe, 0x4c);

// VB command group id GUID
DEFINE_GUID(guidVBGrpId,
  0xca599eb2, 0x9b37, 0x11d0, 0x9f, 0x3, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f);

// VB command id GUID
DEFINE_GUID(guidVBCmdId,
  0x3dd99d50, 0x8c43, 0x11d0, 0x9e, 0xfb, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f);

// VS command id GUID
//DEFINE_GUID(guidVSStd97,
//  0x5efc7975, 0x14bc, 0x11cf, 0x9b, 0x2b, 0x00, 0xaa, 0x00, 0x57, 0x38, 0x19 );

// {5AB92497-2311-4bf6-96AA-38EAFECD3F1E}
DEFINE_GUID(IID_IBscLibraryMgr, 
0x5ab92497, 0x2311, 0x4bf6, 0x96, 0xaa, 0x38, 0xea, 0xfe, 0xcd, 0x3f, 0x1e);

// {15A83EFD-0958-4ec1-9E94-5540B4E03AA1}
DEFINE_GUID(IID_IResLibraryMgr, 
0x15a83efd, 0x958, 0x4ec1, 0x9e, 0x94, 0x55, 0x40, 0xb4, 0xe0, 0x3a, 0xa1);

// {4226A5C6-6AD0-42ed-9F03-ADCEE923A7FD}
DEFINE_GUID(CLSID_CCPPOptionsPage, 
0x4226a5c6, 0x6ad0, 0x42ed, 0x9f, 0x3, 0xad, 0xce, 0xe9, 0x23, 0xa7, 0xfd);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\wizbar.h ===
#ifndef __WIZBARAPI_H__
#define __WIZBARAPI_H__

#include "parse.h"  // for IINST mostly

interface ILanguageService;		// #include <wizapi.h> if you actually need to work with this

interface IWizardBar;
interface IWizBarClntEditor;
interface IWizBarClntLang;
interface IWizBarClntEditors;
interface IWizBarClntLangProvider;

typedef IWizardBar* LPWIZARDBAR;
typedef IWizBarClntEditor* LPWIZBARCLNTEDITOR;
typedef IWizBarClntLang* LPWIZBARCLNTLANG;
typedef IWizBarClntEditors* LPWIZBARCLNTEDITORS;
typedef IWizBarClntLangProvider* LPWIZBARCLNTLANGPROVIDER;

/////////////////////////////////////////////////////////////////////////////
// IWizardBar
// This interface exposes methods that the Wizard bar clients use, though ActivateWizBar 
// and WizBarInvalidate are used by "outsiders"


// structures required as passed arguments for IWizardBar and IWizardBarClient

enum WB_LIST_TYPE {WBL_INVALID = -1, WBL_CLASS = 0, WBL_OBJECT = 1, WBL_TARGET = 2}; // types of wizard bar lists
enum WB_CTL_TYPE  {WBC_INVALID = -1, WBC_CLASS = 0, WBC_OBJECT = 1, WBC_TARGET = 2, WBC_ACTION = 3}; // types of wizard bar controls

#define IW_PUBLIC          0
#define IW_PROTECTED       1
#define IW_PRIVATE         2

#define IMGLIST_BACKGROUND      0x0000ff00

enum WB_TARGET_TYPE 
{
	IW_CLASS = 0, 
	IW_CLASS_PROTECTED,
	IW_CLASS_PRIVATE,
	IW_CONSTANT, 
	IW_CONSTANT_PROTECTED,
	IW_CONSTANT_PRIVATE,
	IW_DELEGATE, 
	IW_DELEGATE_PROTECTED,
	IW_DELEGATE_PRIVATE,
	IW_ENUM, 
	IW_ENUM_PROTECTED,
	IW_ENUM_PRIVATE,
	IW_ENUMITEM, 
	IW_ENUMITEM_PROTECTED,
	IW_ENUMITEM_PRIVATE,
	IW_EVENT, 
	IW_EVENT_PROTECTED,
	IW_EVENT_PRIVATE,
	IW_EXCEPTION, 
	IW_EXCEPTION_PROTECTED,
	IW_EXCEPTION_PRIVATE,
	IW_FIELD, 
	IW_FIELD_PROTECTED,
	IW_FIELD_PRIVATE,
	IW_INTERFACE, 
	IW_INTERFACE_PROTECTED,
	IW_INTERFACE_PRIVATE,
	IW_MACRO, 
	IW_MACRO_PROTECTED,
	IW_MACRO_PRIVATE,
	IW_MAP, 
	IW_MAP_PROTECTED,
	IW_MAP_PRIVATE,
	IW_MAPITEM, 
	IW_MAPITEM_PROTECTED,
	IW_MAPITEM_PRIVATE,
	IW_FUNC, 
	IW_FUNC_PROTECTED,
	IW_FUNC_PRIVATE,
	IW_OVERLOADED,
	IW_OVERLOADED_PROTECTED,
	IW_OVERLOADED_PRIVATE,
	IW_MODULE, 
	IW_MODULE_PROTECTED,
	IW_MODULE_PRIVATE,
	IW_NAMESPACE, 
	IW_NAMESPACE_PROTECTED,
	IW_NAMESPACE_PRIVATE,
	IW_OPERATOR, 
	IW_OPERATOR_PROTECTED,
	IW_OPERATOR_PRIVATE,
	IW_PROPERTY, 
	IW_PROPERTY_PROTECTED,
	IW_PROPERTY_PRIVATE,
	IW_STRUCT, 
	IW_STRUCT_PROTECTED,
	IW_STRUCT_PRIVATE,
	IW_TEMPLATE, 
	IW_TEMPLATE_PROTECTED,
	IW_TEMPLATE_PRIVATE,
	IW_TYPEDEF, 
	IW_TYPEDEF_PROTECTED,
	IW_TYPEDEF_PRIVATE,
	IW_TYPE, 
	IW_TYPE_PROTECTED,
	IW_TYPE_PRIVATE,
	IW_UNION, 
	IW_UNION_PROTECTED,
	IW_UNION_PRIVATE,
	IW_VAR, 
	IW_VAR_PROTECTED,
	IW_VAR_PRIVATE,
	IW_VALUETYPE, 
	IW_VALUETYPE_PROTECTED,
	IW_VALUETYPE_PRIVATE,
	IW_ERROR,
	IW_CLASS_GRAY,
	IW_FUNC_PRIVATE_GRAY,
	IW_FUNC_PROTECTED_GRAY,
	IW_FUNC_GRAY,
	IW_BSCFILE,
	IW_IDL_LIBRARY,
	IW_UNKNOWN3,
	IW_UNKNOWN4,
	IW_UNKNOWN5,
	IW_UNKNOWN6,
	IW_UNKNOWN7,
	IW_UNKNOWN8,
	IW_PROJECT,
	IW_DIALOG_ID,
}; // ids of standard targets/glyphs

/*    IW_INTERFACE_DEF,
	IW_IFACE_METHOD,
	IW_IFACE_PROP,
	IW_DIALOG_ID,
	IW_FUNC_DEFAULT,
	IW_FUNC_JAVA_PROTECTED,
	IW_VAR_DEFAULT,
	IW_VAR_JAVA_PROTECTED,
*/

enum WB_ERROR_CODE
{
	WB_ERR_NO_DEF_FUNCTION = 1,
	WB_ERR_NO_NEXTPREV,
	WB_ERR_NO_DEF_CLASS
}; // ids for errors that ShowWBError can handle

const cItemContext = (WBL_TARGET - WBL_CLASS + 1);
const cWBControls =  (WBC_ACTION - WBC_CLASS + 1);

typedef struct _WBContext
{
	// an array of 3 items (class, filter, memner)
	void *rgwbcitem[cItemContext];
	BOOL fScopeIsProject;  // if true, include all project elements (e.g., classes.) if false limit to context
} WBContext; // Wizard Bar Context

// this is data gathered by an editor that does tracking. Its corresponding language/project
// knows how to interpret the data and return equivalent WBContext entries.
typedef struct _WBContextTrack
{
	// an array of 3 items (class, filter, member + 1 "extra item" for additional data)
	void *rgwbtitem[cItemContext + 1];
} WBContextTrack; // Wizard Bar Tracking Data for Context


// bit flag masks for pbfSupportsWB in FSupportsWBActivate
enum MASK_TYPES 
{
	mskSWANoSupport = 0,
	mskSWAProjectSupport = 1,
	mskSWATrackingSupport = 2,
	mskSWAFilterSupport = 4,
	mskSWAUninitialized = 8
};


// bit flag masks for GetWizBarFlags

#define mskWBFlagsNotExist 0
#define mskWBExists 1
#define mskWBEnabled 2
#define mskWBInvalid 4
#define mskWBTrackedByView 8
#define mskWBSetupTrackForCmd 16

// bit flag masks for puDrawStringFlags in DrawWBItemGlyph
// Note these are mutually exclusive flags. Setting more that more will only
// do 1 action. Don't do it!

#define mskWBDrawStringNormal 0
#define mskWBDrawStringGray 1
#define mskWBDrawStringBold 2

/////////////////////////////////////////////////////////////////////////////
//	forward declaration
struct POPDESC;
typedef POPDESC* LPPOPDESC;

#undef  INTERFACE
#define INTERFACE IWizardBar
DECLARE_INTERFACE_(IWizardBar, IUnknown)
{
	// IWizardBar methods

	// Methods for determining Wiz Bar status


	// ********* Begin Method*****************************************
	// Basically a subset of GetWizBarFlags. Return S_OK if the CWizBarUniversal
	// object has been created. If fCreateIfNone, force creation of the object
	// if not there already.

	STDMETHOD(FExistWizBar)(BOOL fCreateIfNone = FALSE) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Force creation of the Wizard bar object if not there already.

	STDMETHOD(FCreateWizBar)() PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// more status info than FExistsWizBar. Tells if it exists,or is tracking
	// etc. See mks definitions above. If fCreateIfNone, force creation of the object
	// if not there already.

	// returns ULONG. Use mskWB*  to interpret values
	STDMETHOD(GetWizBarFlags)(ULONG *puFlags, BOOL fCreateIfNone = FALSE) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Called by shell when active view changes. 
	STDMETHOD(ActivateWizBar)(BOOL bActivate) PURE; 
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Called by tracking editor when the current selection changes. 
	// Wizard Bar will update at idle time. Should only call when
	// the selection changes enough to change the Wizard Bar status - in the
	// source editor, call when the line selected has changed, not for changes
	// within the line.

	STDMETHOD(WizBarInvalidate)() PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Enable or disable the WizardBar. Should be used with caution (no current callers 6/96)
	STDMETHOD(EnableWizBar)(BOOL bEnable = TRUE) PURE;

  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// free any interface data. If fNoRefill, leave disabled and empty, otherwise
	// refill with current data.

	STDMETHOD(ResetWizBar)(BOOL fNoRefill = FALSE) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Perform specified action. Will force immediate update of Wizard Bar before action is 
	// performed. If WB does not exist, it will be created.
	// If fOnlyIfTracked (useful for double click in dialog editor), ignore action
	// if not tracking. *pfHandledAction indicates whether action ever happened.

	STDMETHOD(DoWizBarAction)(UINT idAction, BOOL *pfHandledAction, BOOL fOnlyIfTracked, BOOL fReportError = TRUE) PURE;
  	// ********* End Method ******************************************



	// IWizardBar methods for context lists


	// ********* Begin Method*****************************************
    // Returns the position of the current selection (*pdwPos) for the WB list
	// specified by wblType. Useful as input to GetWizBarItem, etc.
	
  	STDMETHOD(GetCurSelList)(WB_LIST_TYPE wblType, DWORD *pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Sets the position of the current selection (*pdwPos) for the WB list
	// specified by wblType. 

	STDMETHOD(SetCurSelList)(WB_LIST_TYPE wblType, DWORD *pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Find position of a specified item (pwbItem) in a list specified by wblType.
	// Does NOT addref item
	STDMETHOD(FindWizBarItemExact)(WB_LIST_TYPE wblType, void * pWbItem, DWORD * pdwPosItem) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Return pointer (*ppWbItem) to the item at position dwPos in list specified by wblType.
	// note: this will call AddRef on the item returned

	STDMETHOD(GetWizBarItem)(WB_LIST_TYPE wblType, void ** ppWbItem, DWORD dwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************
	// Return pointer (*ppWbItemSel) to the currently selected item in list specified by wblType.
	// note: this will call AddRef on the item returned

	STDMETHOD(GetSelWizBarItem)(WB_LIST_TYPE wblType, void ** ppWbItemSel) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Empties list specified by wblType. Causes items in list to be Released.
	// If fNoDelPosSel, do not rlease the currently selected item (Note:
	// fNoDelPosSel may be obsolete. I recommend only using FALSE)

	STDMETHOD(EmptyWizBarList)(WB_LIST_TYPE wblType, BOOL fNoDelPosSel) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Sorts list specified by wblType. Uses qsort and calls IWizBarLang::CompareWBItems
	// Lists are sorted to make filtering combos faster

	STDMETHOD(SortWizBarList)(WB_LIST_TYPE wblType) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Add item specified by pwbItem to list specified by wblType. Returns
	// location where item was added in *pdwPos

	STDMETHOD(AddTailList)(WB_LIST_TYPE wblType, void * pWbItem, DWORD * pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Return in *pdwPos the location of the first item in the list
	// specified by wblType.

	STDMETHOD(GetHeadList)(WB_LIST_TYPE wblType, DWORD *pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Analog of CObList::GetNext. Return in *ppWbItem the item in table wblType
	// at position *pdwPos.  Update *pdwPos to point to the next item in the list.
	// note: this will call AddRef on the item returned

	STDMETHOD(GetNextList)(WB_LIST_TYPE wblType, void ** ppWbItem, DWORD *pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Return in *pcEntries the number of items in list specified by wblType

	STDMETHOD(GetCountList)(WB_LIST_TYPE wblType, UINT *pcEntries) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Draw the "standard" glyph specified by idGlyphStd and associated with an item (pwbItem, wblType)
	// at rect lpRect in hDC. Usually called by IWizBarClntLang::DrawWBItemGlyph
	// NOTE: if this function succeeds, lpRect will be set to the area remaining in the original
	// rect after the glyph id drawn (usually means left value is increased). It is untouched on failure

	STDMETHOD(DrawWBStdGlyph) (WB_TARGET_TYPE idGlyphStd, HDC hDC, RECT *lpRect) PURE; 
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************
	// Returns current string for a shared wizard bar command control specified by wbcType to use
	// for its command or tooltip text. This lets us specify new tooltips or menu
	// text for commands in the wizard bar core set (defined in ClsView package)

	STDMETHOD(GetDynamicCmdString)(UINT nID, UINT iString, BSTR* pbstrCmd) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************
	// Returns command id for default command based on current Wizard bar context
	// will put up an error message on failure if fReportError.

	STDMETHOD(GetCmdDefault)(UINT *pnIDDefault, BOOL fReportError = TRUE) PURE;

  	// ********* End Method ******************************************

	// IWizardBar methods for action button menu. More can be added if needed, essentially CMenu / CPopupMenu APIs


	// ********* Begin Method*****************************************

	// Fill us action button memu with commands specified in POPDESC structure. See
	// shlmenu.h for POPDESC description

	STDMETHOD(CreateMenuFromPopdesc)(POPDESC *ppop) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Remove command from menu. See CMenu::RemoveMenu for description

	STDMETHOD(RemoveMenu)(UINT nPosition, UINT nFlags, BOOL *pfOK) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Append command to menu. See CMenu::AppendMenu for description

	STDMETHOD(AppendMenu)(UINT nFlags, UINT nIDNewItem, LPCTSTR lpszNewItem, BOOL *pfOK) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Insert command to menu at nPosition. See CMenu::InsertMenu for description

	STDMETHOD(InsertMenu)(UINT nPosition, UINT nFlags, UINT nIDNewItem, LPCTSTR lpszNewItem, BOOL *pfOK) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Modify command to menu at nPosition. See CMenu::InsertMenu for description

	STDMETHOD(ModifyMenu)(UINT nPosition, UINT nFlags, UINT nIDNewItem, LPCTSTR lpszNewItem, BOOL *pfOK) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Analog of CMenuPopup::AddMenuItem
	// appends command with id id and text lpszText to menu

	STDMETHOD(AddMenuItem)(UINT id, LPCTSTR lpszText) PURE;
  	// ********* End Method ******************************************


	// IWizardBar methods for accessing "current" client interfaces


	// ********* Begin Method*****************************************

	// Returns pointer to currently active IWizBarClntEditor interface or
	// NULL if none

	STDMETHOD(GetCurWizBarClntEditor)(LPWIZBARCLNTEDITOR *ppWBClntEditor) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Returns pointer to currently active IWizBarClntLang interface or
	// NULL if none

	STDMETHOD(GetCurWizBarClntLang)(LPWIZBARCLNTLANG *ppWBClntLang) PURE;
  	// ********* End Method ******************************************


	// IWizardBar methods for accessing *specific* client interfaces


	// ********* Begin Method*****************************************

	// Returns pointer to IWizBarClntEditor interface specified by lpszLang and pguidEditor,  or
	// NULL if none

	STDMETHOD(GetWizBarClntEditor)(LPCTSTR lpszLang, GUID* pguidEditor, LPWIZBARCLNTEDITOR *ppWBClntEditor) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Returns pointer to IWizBarClntLang interface specified by lpszLang or
	// NULL if none

	STDMETHOD(GetWizBarClntLang)(LPCTSTR lpszLang, LPWIZBARCLNTLANG *ppWBClntLang) PURE;
  	// ********* End Method ******************************************

	// Misc functions
	// ********* Begin Method*****************************************

	// Displays error message for specified error (needed for shared
	// errors in langlib only)

	STDMETHOD(ShowWBError)(WB_ERROR_CODE wec) PURE;
  	// ********* End Method ******************************************
};



/////////////////////////////////////////////////////////////////////////////
// IWizBarClntLang
// This interface does most of the work for a Wizard bar client. If not present, these is no
// Wizard Bar support for a particular programming language.

// Methods in this interface create objects that fill the Wizard bar combos. They compare, display and handle
// AddRef and Release on iitems in the list. They fill the lists and perform actions based onthe combo contents.

// This interface may be associated with one or more IWizardBarEditor interfaces, which support
// selection tracking in an editor

// These methods are all called by the Wizard Bar itself. Noone else should be calling them.


#undef  INTERFACE
#define INTERFACE IWizBarClntLang
DECLARE_INTERFACE_(IWizBarClntLang, IUnknown)
{
	// IWizBarClntLang methods

	// ********* Begin Method *****************************************
	// Returns flags through pbfSupportsWB indicating whether this interface supports the current project
	// Typically returns mskSWAProjectSupport if the project can be supported or mskSWANoSupport otherwise. 
	// May use existence of a parser database to determine if it supports this project.
	// If mskSWANoSupport, the Wizard bar will be deactivated.

	STDMETHOD(FSupportsWBActivate)(UINT *pbfSupportsWB) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method *****************************************
	// Initializes any data required by this interface. Called after FSupportsWBActivate succeeds.
	// bfSupportsWB is the value returned by FSupportsWBActivate.

	STDMETHOD(InitWBLangData)(UINT bfSupportsWB) PURE; // argument is what you get back from FSupportsWBActivate
  	// ********* End Method *******************************************

	// ********* Begin Method *****************************************
	// Frees any interface specific data when a project	configuration changes or at shutdown

 	STDMETHOD(ClearWBLangData)() PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method *****************************************
	// Used to fill succeeding context entries with information based on the previous context
	// entries. wbltFirstEmpty indicated which items need to be filled in; any items in pwbcontext
	// >= wbltFirstEmpty will be NULL and need to be filled in.
	// This is a tricky and important method. If someone changes the 2nd combo, this is called to
	// fill up the third. You may not have to refill the entire list to do this; You do not need
	// to empty a list - You need to produce at most 3 items. Typically the Wizard Bar will take
	// what you give it here and empty its lists and refill with the context.
	// This is called directly from the Wizard Bar. GetCurWBCFromTrackData may also find it useful.

	// This method fill up the "surface" of the lists - only 1 item deep. It is called when tracking
	// as part of getting the current context, and also when dropping the first or 2nd combo. The list
	// associated with the item we return here is marked as needing to be filled if dropped.

	STDMETHOD(CompleteWBContext)(WBContext * pwbcontext, WB_LIST_TYPE wbltFirstEmpty) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method *****************************************
	// The wizard Bar has 3 "lists" each associated with one of the combos. When a combo is dropped
	// this method is called to fill the list. wblType indicates which list is to be filled. The
	// data in pwbcontext is often useful for determining what goes in this list.

	// Current implementations save the current context entry to use for reselecting, then empty the
	// list, then create objects appropriate to the list, and call IWizardBar::AddTailList to add them
	// to the list. The Wizard Bar knows nothing of the nature of these objects, except that they
	// support some interfaces (GetWBItemText, DrawWBItemGlyph, CompareWBItems, AddRefWBItem, ReleaseWBItem).
	// It just holds a pointer and calls the interface to do what it needs

	STDMETHOD(FillWizBarList) (WBContext * pwbcontext, WB_LIST_TYPE wblType, BOOL *pfSortedByFiller) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Called by the Wizard Bar when the action menu is dropped. Fill the menu with commands appropriate
	// to the context in pwbcontext. Indicate the index of the default command in piMenuDefault.
	// Several IWizardBar methods are available for filling the menu (CreateMenuFromPopdesc, RemoveMenu,
	// AppendMenu, InsertMenu, ModifyMenu, AddMenuItem).

	STDMETHOD(CreateWBMenuAction)(WBContext * pwbcontext, int *piMenuDefault) PURE; 
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Implements action menu commands that are unique to this language, appropriate to the 
	// context in pwbcontext, and which were added to the menu by CreateWBMenuAction.
	// Set *pfHandledAction	TRUE if you have implemented the command idAction.
	// This function is called after the IWizBarClntEditor equivalent.

	STDMETHOD(DoWBAction)(WBContext * pwbcontext, UINT idAction, BOOL *pfHandledAction) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// called by IWizBarClntEditor::GetCurWBContext. Knows how to interpret data in pwbctrack
	// to produce a valid pwbcontext. This lets the IWizBarClntEditor be ignorant of the 
	// details of the objects that fill the lists. This function needs to be in sync with GetCurWBContext.
	// For example, in the C++ SOurce editor, the editor interface gets the name of the class and function
	// from the current line in the editor. This is passed in pwbctrack, and this function knows how to
	// produce appropriate Class, Object and Target objects to fill the context with.

	STDMETHOD(GetCurWBCFromTrackData)(WBContextTrack * pwbctrack, WBContext * pwbcontext) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Returns ILanguageService associated with this interface, if any. Not currently (6/96) used
	// by the Wizard Bar itself, may be useful in the future. If there is no associated
	// IULanguageService, return something other than S_OK (E_NOTIMPL might be a good choice).

	STDMETHOD(GetLanguageService)(ILanguageService** ppvLangService) PURE;  // associated ILanguageService
  	// ********* End Method *******************************************

	// ********* Begin Method*******************************************
	// Returns language name associated with the IWizBarClntLang interface.
	// The language string is usually the same as those used by the Source editor (ISourceEdit::GetLanguage)
	// or that returned by ILanguageService::get_LanguageName

	STDMETHOD(GetLanguageName)(BSTR* pbstrLang) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Returns pointer to a collection interface containing IWizBarClntEditor interface
	// pointers for this language. Example, in C++, there are Source and Dialog editor interfaces
	// These interfaces are optional. If you have none return a non S_OK value and set
	// *ppvClntEditors NULL.

	STDMETHOD(GetAllClntEditors)(LPWIZBARCLNTEDITORS* ppvClntEditors) PURE;  // associated IWizBarClntEditors interface
  	// ********* End Method *******************************************



	// IWizBarClntLang methods for list items
	// These methods are called by the Wizard Bar to manipulate individual list objects.



	// ********* Begin Method*****************************************

	// Given an item (pwbItem) and its type (wblType), return its associated text in *ppText.
	// If there should be different text in the edit control of a combo than what appears in the
	// list, use fTextForEdit to determine which to return. 

	STDMETHOD(GetWBItemText) (void * pwbItem, WB_LIST_TYPE wblType, BSTR* pbstrText, BOOL fTextForEdit) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Draw the glyph associated with an item (pwbItem, wblType) at rect lpRect in hDC.
	// If the glyph should be a "standard" Class View glyph, you can have IWizardBar::DrawWBStdGlyph
	// draw it for you.
	// uDrawStringFlags are hints to the drawing code that the string drawn with the glyph
	// should be drawn in a special way. Basically a hanger on argument to avoid a new member function.
	// see mskWBDrawString* for available options
	// NOTE: if this function succeeds, lpRect will be set to the area remaining in the original
	// rect after the glyph id drawn (usually means left value is increased). It is untouched on failure

	STDMETHOD(DrawWBItemGlyph) (void * pwbItem, WB_LIST_TYPE wblType, HDC hDC, RECT *lpRect, UINT *puDrawStringFlags) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Compare 2 list object items. Return Zero if the items are identical, < 0 if pwbItem1 is less 
	// than pwbItem2, or > 0 if this pwbItem1 is greater than pwbItem2.  Usually this is a
	// comarison of the text returned by GetWBItemText.You can choose
	// whether to make this case sensitive or not. (For C++ comparisons ARE case sensitive).

	STDMETHOD(CompareWBItems) (const void * pwbItem1, const void * pwbItem2, WB_LIST_TYPE wblType, int *pRetCompare) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Increases the reference count of the specified item. The Wizard Bar calls this
	// when it gets its current context from its lists so we can have multiple copies and 
	// still delete at the right time. When you create an item, set its ref count to 1. Don;t
	// addref again if adding to a WizBar list.

	STDMETHOD(AddRefWBItem) (void * pwbItem, WB_LIST_TYPE wblType) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Decreases the reference count on the item. When the count goes to 0
	// the item should be deleted. At item destruction time, the ref count
	// should be 0 or 1 (similar to how CCmdTarget works).
	STDMETHOD(ReleaseWBItem) (void * pwbItem, WB_LIST_TYPE wblType) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Returns current string for a shared wizard bar command control specified by wbcType to use
	// for its command or tooltip text. This lets us specify new tooltips or menu
	// text for commands in the wizard bar core set (defined in ClsView package)
	// if not implemented, NULL is returned, which means get string from command table

	STDMETHOD(GetDynamicCmdString)(UINT nID, UINT iString, BSTR* pbstrCmd) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Returns command id for default command based on Wizard bar context
	// if not handled, returns FALSE in *pfHandled.

	STDMETHOD(GetCmdDefault)(WBContext *pwbcontext, UINT *pnIDDefault, BOOL *pfHandled) PURE;
  	// ********* End Method *******************************************

};




/////////////////////////////////////////////////////////////////////////////
// IWizBarClntEditor
// This interface is optional. If not implemented, the user can still use the Wizard Bar
// by changing the combos by hand. It is used primarily to implement tracking of selection (via the
// GetCurWBContext method (which can call GetCurWBCFromTrackData in IWizBarClntLang)). It can also 
// add menu commands that are active only in this editor (AddWBMenuAction, DoWBAction)

// This interface is associated with a single editor and programming language, and is accessed
// through the IWizBarClntLang method GetAllClntEditors. You can have several of these interfaces
// associated with a single programming language.

// These methods are all called by the Wizard Bar itself. Noone else should be calling them.

#undef  INTERFACE
#define INTERFACE IWizBarClntEditor
DECLARE_INTERFACE_(IWizBarClntEditor, IUnknown)
{
	// IWizBarClntEditor methods

	// ********* Begin Method*******************************************

	// Returns flags through pbfSupportsWB indicating whether this interface supports the current active
	// view. Typically returns mskSWATrackingSupport if it can track selection changes, and  mskSWANoSupport
	// otherwise. Typically uses info on the current editor and language of the doc in the view to
	// determine if it has support

	STDMETHOD(FSupportsWBActivate)(UINT *pbfSupportsWB) PURE; 
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Initializes any data required by this interface. Called after FSupportsWBActivate succeeds.
	// bfSupportsWB is the value returned by FSupportsWBActivate.

	STDMETHOD(InitWBEditorData)(UINT bfSupportsWB) PURE; // argument is what you get back from FSupportsWBActivate
	// ********** End Method ******************************************

	// ********* Begin Method*****************************************

	// Frees any editor specific data when a new editor is activated

	STDMETHOD(ClearWBEditorData)() PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// The main tracking interface. Fills pwbcontext with information appropriate to
	// the current selection. (Note that the editor must call IWizardBar::WizBarInvalidate()
	// when its selection changes to make this work).
	// pwbcontext is empty when this is called. Set *pfUnchanged true if the selection
	// has not changed since the last call. 
	// This method usually has a contract with GetCurWBCFromTrackData in IWizBarClntLang. It
	// analyzes the current selection and gathers data that	GetCurWBCFromTrackData can use to
	// fill pwbcontext. These 2 methods should be written in tamdem.

	STDMETHOD(GetCurWBContext)(WBContext * pwbcontext, BOOL *pfUnchanged) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Optional. Use to add commands that are unique to this editor, not common to the language
	// implementation. Example, in C++ source editor, GoToNextFunction uses editor tracking
	// and so is implemented in this interface.

	STDMETHOD(AddWBMenuAction)(WBContext * pwbcontext) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Optional. Implements commands that are unique to this editor, not common to the language,
	// and which were added to the menu by AddWBMenuAction.
	// Set *pfHandledAction	TRUE if you have implemented the command idAction.
	// This function is called before the IWizBarClntLang equivalent, so it has first try.

	STDMETHOD(DoWBAction)(WBContext * pwbcontext, UINT idAction, BOOL *pfHandledAction) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*******************************************
	// Identification of interface. This info is usually hard coded. Editors are identified by
	// a guid, accessible through CPartView::GetEditorID, and we store the approriate value.
	// The language string is usually the same as those used by the Source editor (ISourceEdit::GetLanguage)

	STDMETHOD(GetLangAndEditor)(BSTR* pbstrLang, GUID* pguidEditor) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************
	// A convenience call. Each of these interfaces is associated with an IWizBarClntLang and the
	// pointer to that interface should be returned here.

	STDMETHOD(GetIClntLang)(LPWIZBARCLNTLANG *ppWBClntLang) PURE;  // get associated IWizBarClntLang interface
	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Returns current string for a shared wizard bar command control specified by wbcType to use
	// for its command or tooltip text. This lets us specify new tooltips or menu
	// text for commands in the wizard bar core set (defined in ClsView package)
	// if not implemented, NULL is returned, which means get string from command table

	STDMETHOD(GetDynamicCmdString)(UINT nID, UINT iString, BSTR* pbstrCmd) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Returns command id for default command based on Wizard bar context
	// if not handled, returns FALSE in *pfHandled.

	STDMETHOD(GetCmdDefault)(WBContext *pwbcontext, UINT *pnIDDefault, BOOL *pfHandled) PURE;
  	// ********* End Method *******************************************

};

/////////////////////////////////////////////////////////////////////////////
// IWizBarClntEditors
// Collections of wiz bar client editors (get from IWizBarClntLang)
// If you derive an object from CWizBarEditorCollection (see langlib package)
// You will get these interfaces for free. You will have to implement the
// CWizBarEditorCollection Init() and destructors, but those are pretty simple.
// See CWizBarEditorCollectionCpp in the langcpp package for an example.

#undef  INTERFACE
#define INTERFACE IWizBarClntEditors
DECLARE_INTERFACE_(IWizBarClntEditors, IUnknown)
{
	STDMETHOD(_NewEnum)(THIS_ IEnumVARIANT **ppenum) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IWizBarClntLangProvider
// Provides access to IWizBarClntLang interface implemented on object
// in the package. A package that implements IWizBarClntLang have have
// one of these interfaces to give the Wizard Bar access to IWizBarClntLang

#undef  INTERFACE
#define INTERFACE IWizBarClntLangProvider
DECLARE_INTERFACE_(IWizBarClntLangProvider, IUnknown)
{
	// Returns pointer to IWizBarClntLang interface or NULL if none

	STDMETHOD(GetClntLang)(LPWIZBARCLNTLANG *ppWBClntLang) PURE;
};


/////////////////////////////////////////////////////////////////////////////

#endif // __WIZBARAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\wizbase.h ===
// wizbase.h : header file
//
#ifndef _WIZBASE_
#define _WIZBASE_

// classes in this header
class CWizBarEditorCollection;
class CWizBarClntEditor;
class CWizBarClntLang;
class CWizBarObject;
class CWizBarItem;

#include <wizbar.h>
///#include <clvwguid.h>
#include "..\include\langlib\olecoll.h"
#include <prjapi.h>
//#include <utilapi.h>
//#include <utilguid.h>
//#include <srcapi3.h>
//#include <srcguid.h>
//#include "ncparex.h"


// ***********  generic classes for WizBar 
// Need these classes in every language package that supports wizard bar.

 
class CWizBarEditorCollection : public COleCollection
{
public:
	CWizBarEditorCollection();
	~CWizBarEditorCollection();

 	virtual BOOL Do_Init(LPWIZBARCLNTLANG pWBClntLang);

  	virtual BOOL Init() PURE;  // must be implemented by derived classes. Tells what is available in the collection

protected:
	virtual IID const* PiidMember()	// interface all items must support, if any
		{ return NULL; }

	LPWIZBARCLNTLANG	m_pWBClntLang;

	DECLARE_DYNAMIC(CWizBarEditorCollection)

	DECLARE_INTERFACE_MAP()
	BEGIN_INTERFACE_PART(WizBarClntEditors, IWizBarClntEditors)
		STDMETHOD(_NewEnum)(IEnumVARIANT **ppenum);
	END_INTERFACE_PART(WizBarClntEditors)
};
 


class CWizBarClntLang : public CCmdTarget
	// object that supports the IWizBarClntLang interface. All users derive.
{
	DECLARE_DYNAMIC(CWizBarClntLang)

public:
	CWizBarClntLang(CTheApp *app, LPCTSTR szLanguageName, ILanguageService* pvLangService);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWizBarClntLang)
	//}}AFX_VIRTUAL

		// cache the Project Workspace interface
	LPPROJECTWORKSPACE GetWorkspace()
	{
		if (m_pWorkspace == NULL)
			m_pTheApp->FindInterface(IID_IProjectWorkspace, (LPVOID*)&m_pWorkspace);
		return (m_pWorkspace);
	}

	void ReleaseWorkspace()
	{
		if (m_pWorkspace != NULL)
		{
			m_pWorkspace->Release();
			m_pWorkspace = NULL;
		}
	}

protected:
	CTheApp		*m_pTheApp;
	ILanguageService* m_pvLangService;
	CString m_strLanguageName;
	LPPROJECTWORKSPACE m_pWorkspace;


protected:
	~CWizBarClntLang();

	// virtuals that implement the interface (implement in derived classes)

		virtual HRESULT Do_GetLanguageService(ILanguageService** ppvLangService)
		{
			*ppvLangService = m_pvLangService;  // associated ILanguageService, if any
			if (m_pvLangService != NULL)
				(*ppvLangService)->AddRef();
			return S_OK;
		}

		virtual HRESULT Do_GetLanguageName(BSTR* pbstrLang)
		{
			BSTR bstr = m_strLanguageName.AllocSysString();
			*pbstrLang = bstr;
			return S_OK;
		}

	// Dynamic command strings are resource strings in this format:
	// "STRING_COMMAND\nSTRING_MENUTEXT\nSTRING_PROMPT\nSTRING_TIP". 
	// Omit unused portions with adjacent \n's. NULL will be returned for these
	// which will cause called to extract string from the command table
	// the total string must be <= 1024 bytes
	// Command strings are in the order described by the defined indexes used as iString:
	// #define STRING_COMMAND	0
	// #define STRING_MENUTEXT 1
	// #define STRING_PROMPT   2
	// #define STRING_TIP		3

		virtual HRESULT Do_GetDynamicCmdString(UINT nID, UINT iString, BSTR* pbstrCmd)
		{
			*pbstrCmd = NULL;
			return NOERROR;
		}

  		virtual HRESULT	Do_GetCmdDefault(WBContext *pwbcontext, UINT *pnIDDefault, BOOL *pfHandled)
		{
			*pfHandled = FALSE;
			*pnIDDefault = (UINT)(-1);
			return NOERROR;
		}

	   	virtual HRESULT Do_FSupportsWBActivate(UINT *pbfSupportsWB) PURE;
		virtual HRESULT Do_InitWBLangData(UINT bfSupportsWB) PURE;
		virtual HRESULT Do_ClearWBLangData() PURE;

		virtual HRESULT Do_CompleteWBContext(WBContext * pwbcontext, WB_LIST_TYPE wbltFirstEmpty) PURE;
		virtual HRESULT Do_FillWizBarList (WBContext * pwbcontext, WB_LIST_TYPE wblType, BOOL *pfSortedByFiller) PURE;
		virtual HRESULT Do_CreateWBMenuAction(WBContext * pwbcontext, int *piMenuDefault) PURE; 
		virtual HRESULT Do_DoWBAction(WBContext * pwbcontext, UINT idAction, BOOL *pfHandledAction) PURE;
		virtual HRESULT Do_GetCurWBCFromTrackData(WBContextTrack * pwbctrack, WBContext * pwbcontext) PURE;
		virtual HRESULT Do_GetAllClntEditors(LPWIZBARCLNTLANG pWBClntLang, LPWIZBARCLNTEDITORS* ppvClntEditors);  // associated IWizBarClntEditors interface

		virtual HRESULT Do_GetWBItemText (void * pwbItem, WB_LIST_TYPE wblType, BSTR* pbstrText, BOOL fTextForEdit) PURE;
		virtual HRESULT Do_DrawWBItemGlyph (void * pwbItem, WB_LIST_TYPE wblType, HDC hDC, RECT *lpRect, UINT *puDrawStringFlags) PURE;
		virtual HRESULT Do_CompareWBItems (const void * pwbItem1, const void * pwbItem2, WB_LIST_TYPE wblType, int *pRetCompare) PURE;
		virtual HRESULT Do_AddRefWBItem (void * pwbItem, WB_LIST_TYPE wblType) PURE;
		virtual HRESULT Do_ReleaseWBItem (void * pwbItem, WB_LIST_TYPE wblType) PURE;


		virtual	CWizBarEditorCollection *GetNewEditorCollection() PURE;

		// get a project type id from the build system
		HRESULT GetProjectID (LPPROJECTWORKSPACE pWWInterface, CLSID *pClsidProj);

	DECLARE_INTERFACE_MAP()

	// Wizard Bar Client Language interface
	BEGIN_INTERFACE_PART(WizBarClntLang, IWizBarClntLang)
		INIT_INTERFACE_PART(CWizBarClntLang, WizBarClntLang)

   		STDMETHOD(FSupportsWBActivate)(UINT *pbfSupportsWB);
		STDMETHOD(InitWBLangData)(UINT bfSupportsWB);
		STDMETHOD(ClearWBLangData)();

		STDMETHOD(CompleteWBContext)(WBContext * pwbcontext, WB_LIST_TYPE wbltFirstEmpty);
		STDMETHOD(FillWizBarList) (WBContext * pwbcontext, WB_LIST_TYPE wblType, BOOL *pfSortedByFiller);
		STDMETHOD(CreateWBMenuAction)(WBContext * pwbcontext, int *piMenuDefault); 
		STDMETHOD(DoWBAction)(WBContext * pwbcontext, UINT idAction, BOOL *pfHandledAction);
		STDMETHOD(GetCurWBCFromTrackData)(WBContextTrack * pwbctrack, WBContext * pwbcontext);

		STDMETHOD(GetLanguageService)(ILanguageService** ppvLangService);  // associated ILanguageService
		STDMETHOD(GetLanguageName)(BSTR* pbstrLang);  // associated language name

		STDMETHOD(GetAllClntEditors)(LPWIZBARCLNTEDITORS* ppvClntEditors);  // associated IWizBarClntEditors interface

		STDMETHOD(GetWBItemText) (void * pwbItem, WB_LIST_TYPE wblType, BSTR* pbstrText, BOOL fTextForEdit);
		STDMETHOD(DrawWBItemGlyph) (void * pwbItem, WB_LIST_TYPE wblType, HDC hDC, RECT *lpRect, UINT *puDrawStringFlags);
		STDMETHOD(CompareWBItems) (const void * pwbItem1, const void * pwbItem2, WB_LIST_TYPE wblType, int *pRetCompare);
		STDMETHOD(AddRefWBItem) (void * pwbItem, WB_LIST_TYPE wblType);
		STDMETHOD(ReleaseWBItem) (void * pwbItem, WB_LIST_TYPE wblType);

		STDMETHOD(GetDynamicCmdString)(UINT nID, UINT iString, BSTR* pbstrCmd);
		STDMETHOD(GetCmdDefault)(WBContext *pwbcontext, UINT *pnIDDefault, BOOL *pfHandled);

	END_INTERFACE_PART(WizBarClntLang)

};


class CWizBarClntEditor : public CCmdTarget
	// object that supports the IWizBarClntEditor interface. All users derive.
{
public:
	CWizBarClntEditor(CTheApp* app, const GUID &rguidEditor, LPCTSTR lpszLang, LPWIZBARCLNTLANG pWBClntLang);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWizBarClntEditor)
	//}}AFX_VIRTUAL


protected:
	CTheApp				*m_pTheApp;
	LPWIZBARCLNTLANG	m_pWBClntLang;
	const GUID			&m_rguidEditor;
	CString				m_strLang;

protected:
	~CWizBarClntEditor();

	// virtuals that implement the interface (implement in derived classes)
   		virtual HRESULT Do_FSupportsWBActivate(UINT *pbfSupportsWB) PURE;
		virtual HRESULT Do_InitWBEditorData(UINT bfSupportsWB) PURE;
		virtual HRESULT Do_ClearWBEditorData() PURE;
		virtual HRESULT Do_GetCurWBContext(WBContext * pwbcontext, BOOL *pfUnchanged) PURE;
		virtual HRESULT Do_AddWBMenuAction(WBContext * pwbcontext) PURE;
		virtual HRESULT Do_DoWBAction(WBContext * pwbcontext, UINT idAction, BOOL *pfHandledAction) PURE;

		virtual HRESULT Do_GetLangAndEditor(BSTR* pbstrLang, GUID* pguidEditor) 
		{
			BSTR bstr = m_strLang.AllocSysString();
			*pbstrLang = bstr;
			*pguidEditor = m_rguidEditor;
			return NOERROR;
		}

		virtual HRESULT Do_GetIClntLang(LPWIZBARCLNTLANG *ppWBClntLang)
		{
			m_pWBClntLang->AddRef();
			*ppWBClntLang =  m_pWBClntLang;
			return NOERROR;
		}

		// Dynamic command strings are resource strings in this format:
		// "STRING_COMMAND\nSTRING_MENUTEXT\nSTRING_PROMPT\nSTRING_TIP". 
		// Omit unused portions with adjacent \n's. NULL will be returned for these
		// which will cause called to extract string from the command table
		// the total string must be <= 1024 bytes
		// Command strings are in the order described by the defined indexes used as iString:
		// #define STRING_COMMAND	0
		// #define STRING_MENUTEXT 1
		// #define STRING_PROMPT   2
		// #define STRING_TIP		3

		virtual HRESULT Do_GetDynamicCmdString(UINT nID, UINT iString, BSTR* pbstrCmd)
		{
			*pbstrCmd = NULL;
			return NOERROR;
		}


		 virtual HRESULT Do_GetCmdDefault(WBContext *pwbcontext, UINT *pnIDDefault, BOOL *pfHandled)
		{
			*pfHandled = FALSE;
			*pnIDDefault = (UINT)(-1);
			return NOERROR;
		}

	DECLARE_INTERFACE_MAP()

		// Wizard Bar Client Editor interface 
	BEGIN_INTERFACE_PART(WizBarClntEditor, IWizBarClntEditor)
		INIT_INTERFACE_PART(CWizBarClntEditor, WizBarClntEditor)

   		STDMETHOD(FSupportsWBActivate)(UINT *pbfSupportsWB);
		STDMETHOD(InitWBEditorData)(UINT bfSupportsWB); 	
		STDMETHOD(ClearWBEditorData)();

		STDMETHOD(GetCurWBContext)(WBContext * pwbcontext, BOOL *pfUnchanged);
		STDMETHOD(AddWBMenuAction)(WBContext * pwbcontext);
		STDMETHOD(DoWBAction)(WBContext * pwbcontext, UINT idAction, BOOL *pfHandledAction);
		STDMETHOD(GetLangAndEditor)(BSTR* pbstrLang, GUID* pguidEditor);
		STDMETHOD(GetIClntLang)(LPWIZBARCLNTLANG *ppWBClntLang);  // get associated IWizBarClntLang interface

		STDMETHOD(GetDynamicCmdString)(UINT nID, UINT iString, BSTR* pbstrCmd);
		STDMETHOD(GetCmdDefault)(WBContext *pwbcontext, UINT *pnIDDefault, BOOL *pfHandled);

	END_INTERFACE_PART(WizBarClntEditor)

};


// addreffable objects usedin wizard bar

// Classes such as CWizBarItem derive from this. It is a fairly cheap objec that supports addref and release

class CWizBarObject : public CObject
{
public:
	DECLARE_DYNAMIC(CWizBarObject)

	CWizBarObject()
	{
		m_dwRef = 1;
	}
	virtual ~CWizBarObject() 
	{
		ASSERT(m_dwRef <= 1);
	}

	virtual void AddRef()
	{
		m_dwRef++;
	}

	virtual void Release()
	{
		m_dwRef--;
		ASSERT(m_dwRef >= 0);
		if (m_dwRef < 1)
			delete (this);
	}

protected:
	long m_dwRef;	// used for addref and release
};


// objects stored in wizard bar lists

// Clients derive from this class to put entries into the wizard bar lists
// the derived classes destructor must take care of deleting the contents
// of these objects

class CWizBarItem : public CWizBarObject
{
public:
	DECLARE_DYNAMIC(CWizBarItem)

	CWizBarItem()
	{
	}
	virtual ~CWizBarItem()
	{
	}

	// Temporary in nature - Don't hold this pointer and don't write to it.
	virtual LPCTSTR GetText(BOOL fTextForEdit) PURE;
	virtual int Compare(CWizBarItem *pcwbitem) PURE;

};


#endif	// _WIZBASE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\alpha.h ===
//
// Alpha (RISC) C/C++ AddOn
//
// Alpha (RISC) Platform C/C++ Tools Component Add-On 'package'
//
// [matthewt]
//

#pragma once

// platforms, tools, option handlers provided by this module

// add-on's name
#define szAddOnAlpha "Microsoft Alpha (RISC) C/C++ v1.0"

// our 'Alpha' build system components

#define BCID_Platform_Alpha			3		

#define BCID_OptHdlr_Compiler_Alpha	320
#define BCID_OptHdlr_Linker_Alpha	321

#define BCID_Tool_Compiler_Alpha	340
#define BCID_Tool_Linker_Alpha		341

#define BCID_ProjType_AlphaExe		360
#define BCID_ProjType_AlphaDll		361
#define BCID_ProjType_AlphaCon		362
#define BCID_ProjType_AlphaLib		363
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\axpoptn.cpp ===
//
// ALPHA Compiler Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "axpoptn.h"	// our local header file

//----------------------------------------------------------------
// our ALPHA compiler option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(CompilerAlpha, (UINT)NULL, (UINT)NULL, P_CpuAlpha, P_BBThresholdAlpha, TRUE)
	IDOPT_CALLCONV_ALPHA,	"G%{d}1",		OPTARGS1(P_CallConvAlpha),					single,
	IDOPT_BYTE_ALPHA,	"Zp%{2|4|8|16|[1]}1",	OPTARGS1(P_ByteAlignAlpha),					single,
	IDOPT_THREAD_ALPHA,	"M%{L|T|D}1",		OPTARGS1(P_ThreadAlpha),						single,
    IDOPT_GTVALUE_ALPHA, "Gt%1",     OPTARGS1(P_GtvalueAlpha), single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(CompilerAlpha)
	OPTDEF_INT(CpuAlpha, 1)
	OPTDEF_INT(CallConvAlpha, 1)
	OPTDEF_INT(ByteAlignAlpha, 3)
	OPTDEF_INT(ThreadAlpha, 1)
    OPTDEF_INT(GtvalueAlpha, 0)
    OPTDEF_INT(BBThresholdAlpha, 2000)
END_OPTDEF_MAP()

//----------------------------------------------------------------
// our ALPHA linker option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(LinkerAlpha, (UINT)NULL, (UINT)NULL, (UINT)NULL, (UINT)NULL, TRUE)
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerAlpha)
END_OPTDEF_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CCCompilerAlphaTool, CCCompilerNTTool)
IMPLEMENT_DYNAMIC(CLinkerAlphaTool, CLinkerNTTool)

BOOL OLD_OPTION_HANDLER(CompilerAlpha)::AlwaysShowDefault(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_GtvalueAlpha || idPropL == P_BBThresholdAlpha);
}

//////////////////////////////////////////////////////////////////////////////////
// CCompilerAlphaTool
//////////////////////////////////////////////////////////////////////////////////
CCCompilerAlphaTool::CCCompilerAlphaTool() : CCCompilerNTTool()
{
}

///////////////////////////////////////////////////////////////////////////////
// Ensure that this project compiler Intelx86 options are ok to use/not use MFC
BOOL CCCompilerAlphaTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	// Set the thread type usage
	pProjItem->SetIntProp(MapLogical(P_ThreadAlpha), 1);

	return CCCompilerNTTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}

//////////////////////////////////////////////////////////////////////////////////
// CLinkerAlphaTool
//////////////////////////////////////////////////////////////////////////////////
CLinkerAlphaTool::CLinkerAlphaTool() : CLinkerNTTool()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\axptoolc.cpp ===
//
// ALPHA (RISC) Compiler Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "axptoolc.h"	// our local header file

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CCCompilerAlphaTool, CCCompilerNTTool)

CCCompilerAlphaTool::CCCompilerAlphaTool() : CCCompilerNTTool()
{
}

///////////////////////////////////////////////////////////////////////////////
// Ensure that this project compiler Intelx86 options are ok to use/not use MFC
BOOL CCCompilerAlphaTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	// Set the thread type usage
	pProjItem->SetIntProp(MapLogical(P_ThreadAlpha), 1);

	return CCCompilerNTTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\axpoptn.h ===
//
// Alpha Tool Options and Tools
//

#pragma once

#include "alpha.h"

//----------------------------------------------------------------
// our ALPHA compiler option data
//----------------------------------------------------------------

// ALPHA compiler option handler
DEFN_OPTHDLR_PLATFORM
(
	CompilerAlpha, /* name */
	szAddOnx86, BCID_OptHdlr_Compiler_Alpha, /* Alpha compiler option handler */
	szAddOnx86, BCID_Tool_Compiler_Alpha, /* Alpha compiler tool */
	szAddOnGeneric, BCID_OptHdlr_Compiler /* base generic compiler option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	virtual BOOL AlwaysShowDefault(UINT idProp);

END_OPTHDLR()

// ALPHA compiler tool properties
#define P_CpuAlpha				 		0x1000
#define P_CallConvAlpha				 	0x1001
#define P_ByteAlignAlpha				0x1002
#define P_ThreadAlpha				 	0x1003
#define P_GtvalueAlpha           		0x1004
#define P_BBThresholdAlpha              0x1005

// ALPHA compiler tool options (option ids)
#define IDOPT_CPU_ALPHA					6000//072199 IDOPT_BASE + 0
#define IDOPT_CALLCONV_ALPHA			6001//072199 IDOPT_BASE + 1
#define IDOPT_BYTE_ALPHA				6002//072199 IDOPT_BASE + 2
#define IDOPT_THREAD_ALPHA				6003//072199 IDOPT_BASE + 3
#define IDOPT_GTVALUE_ALPHA				6004//072199 IDOPT_BASE + 4
#define IDOPT_BBTHRESHOLD_ALPHA			6005//072199 IDOPT_BASE + 5

//----------------------------------------------------------------
// our ALPHA linker option data
//----------------------------------------------------------------

// ALPHA compiler option handler
DEFN_OPTHDLR_PLATFORM
(
	LinkerAlpha, /* name */
	szAddOnx86, BCID_OptHdlr_Linker_Alpha, /* Alpha linker option handler */
	szAddOnx86, BCID_Tool_Linker_Alpha, /* Alpha linker tool */
	szAddOnGeneric, BCID_OptHdlr_LinkerNT /* base NT linker option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

END_OPTHDLR()

#include "optncplr.h"	// our COMMON compiler tool

class CCCompilerAlphaTool : public CCCompilerNTTool
{
	DECLARE_DYNAMIC (CCCompilerAlphaTool)

public:
	CCCompilerAlphaTool();

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};

#include "optnlink.h"	// our COMMON linker tool

class CLinkerAlphaTool : public CLinkerNTTool
{
	DECLARE_DYNAMIC (CLinkerAlphaTool)

public:
	CLinkerAlphaTool();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\axptooll.cpp ===
//
// ALPHA Linker Tool
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "axptooll.h"	// our local header file

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CLinkerAlphaTool, CLinkerNTTool)

CLinkerAlphaTool::CLinkerAlphaTool() : CLinkerNTTool()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\include\wizrsrv.h ===
#ifndef _WIZRESERVED_
#define _WIZRESERVED_

// NOTE: you will need to define HTARGET, HFILESET, and uniq_platform to include this file
// These are all traditionally defined in bldapi.h.

// these interfaces are reserved for use within the implementation of the Wizard model
// Users of the Wizard model don't need to know about them.

interface IPrivateLangToLang;	// for private communication between ILanguageServices
interface IPrivateDynamicUI;	// for private communication between class view and lang packages
interface IPrivateDynamicClsFldUI;	// for private communication between class folder and lang packages
interface IPrivateLangToWiz;	// for private communication between lang package and IWizardService

typedef IPrivateLangToLang* LPPRIVATELANGTOLANG;
typedef IPrivateDynamicUI* LPPRIVATEDYNAMICUI;
typedef IPrivateDynamicClsFldUI* LPPRIVATEDYNAMICCLSFLDUI;
typedef IPrivateLangToWiz* LPPRIVATELANGTOWIZ;

// nExtra parameter constants to methods within IPrivateDynamicUI
#define COM_MAP_NONE         0
#define COM_MAP_IMPL         1
#define COM_MAP_IMPL_PROP    2

/////////////////////////////////////////////////////////////////////////////
// IPrivateLangToLang
//   This interface is used for private communication between ILanguageService and ILanguageService

#undef  INTERFACE
#define INTERFACE IPrivateLangToLang
DECLARE_INTERFACE_(IPrivateLangToLang, IUnknown)
{
	STDMETHOD(CreateClassCollection)(short nClassType, CStringList &rstrList, HTARGET hTarget, 
		ILanguageClasses** ppBscColl) PURE;
	STDMETHOD(GetFunctionSet)(LPCSTR lpszInterface, HTARGET hTarget, ILanguageFunctions** ppFuncColl) PURE;
	STDMETHOD(GetClassSet)(short nClassType, LPCSTR lpszInterface, HTARGET hTarget, 
		ILanguageClasses** ppClassColl) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IPrivateDynamicUI
//   This interface is used for private communication between class view and lang packages

#undef  INTERFACE
#define INTERFACE IPrivateDynamicUI
DECLARE_INTERFACE_(IPrivateDynamicUI, IUnknown)
{
	STDMETHOD(GetCmdIDs)(CWordArray& aVerbs, CWordArray& aCmds, int nExtra) PURE;
	STDMETHOD(OnCmdMsg)(UINT nID, int nCode, void* pExtra, LPBOOL lpRetVal, CWnd* slobWnd, int nExtra) PURE;
	STDMETHOD(ExcludeCommonUI)(LPWORD lpwExcludeMask, int nExtra) PURE;
	STDMETHOD(SetPropertyCaption)(BOOL *pSetCaption, CString& strCaption) PURE;
	STDMETHOD(GetBaseClassText)(BOOL *pSetText, CString& strText) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IPrivateLanguageItems
//		Private interface for collections

#undef INTERFACE
#define INTERFACE IPrivateLanguageItems
DECLARE_INTERFACE_(IPrivateLanguageItems, IUnknown)
{
	STDMETHOD(Intersect)(ILanguageItems *pLangItems, CRuntimeClass * const pClass, ILanguageItems **ppLangItemsOut) PURE;
	STDMETHOD(Subtract)(ILanguageItems *pLangItems, CRuntimeClass * const pClass, ILanguageItems **ppLangItemsOut) PURE;
	STDMETHOD(Union)(ILanguageItems *pLangItems) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IPrivateLanguageItem
//		Private interface for language item (class, function, var)

#undef INTERFACE
#define INTERFACE IPrivateLanguageItem
DECLARE_INTERFACE_(IPrivateLanguageItem, IUnknown)
{
	STDMETHOD(GetIinst)(IINST * pIinst) PURE;
	STDMETHOD(CompareParams)(IINST iinst, BOOL * pbResult) PURE;
	STDMETHOD(GetNameString)(short nNameType, CString & rstrName) PURE;
	STDMETHOD(GetBrowserInfo)(SZ* psz, TYP* ptyp, ATR32* patr, BOOL* pbSuccess) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IPrivateDynamicUI
//   This interface is used for private communication between class view folder and lang packages

#undef  INTERFACE
#define INTERFACE IPrivateDynamicClsFldUI
DECLARE_INTERFACE_(IPrivateDynamicClsFldUI, IUnknown)
{
	STDMETHOD(SupportsPlatform)(uniq_platform platform, BOOL* fSupport) PURE;
	STDMETHOD(GetCmdIDs)(HTARGET hTarget, HFILESET hFileSet, CWordArray& aVerbs, CWordArray& aCmds) PURE;
	STDMETHOD(OnCmdMsg)(HTARGET hTarget, HFILESET hFileSet, UINT nID, int nCode, void* pExtra, LPBOOL lpRetVal, CWnd* slobWnd) PURE;
	STDMETHOD(OnUpdateCreateNewClass)(CCmdUI* pCmdUI, BOOL fEmpty) PURE;
	STDMETHOD(OnUpdateInvokeATLComp)(CCmdUI* pCmdUI, HTARGET hTarget) PURE;
	STDMETHOD(OnCreateNewClass)(HTARGET hTarget, CWnd* slobWnd) PURE;
	STDMETHOD(OnInvokeATLComp)(HTARGET hTarget, CWnd* slobWnd) PURE;
	STDMETHOD(OnCreateNewForm)(HTARGET hTarget, CWnd* slobWnd) PURE;
	STDMETHOD(OnUpdateCreateNewForm)(CCmdUI* pCmdUI, HTARGET hTarget, BOOL fEmpty) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IPrivateLangToWiz
//   This interface is used for private communication between lang packages and IWizardService

#undef  INTERFACE
#define INTERFACE IPrivateLangToWiz
DECLARE_INTERFACE_(IPrivateLangToWiz, IUnknown)
{
	STDMETHOD(CreateFolderContext)(IVCWizardContext** pvContext) PURE;
};

#endif	// _WIZRESERVED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\bldpack.h ===
#ifndef __BLDPACK_H__
#define __BLDPACK_H__

class CProjComponentMgr;

class CPackage: public CObject {
public:
	virtual BOOL DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD blc_id){return TRUE;};

	// Help information (including legal resource, command, and window id ranges)
	enum RANGE_TYPE
	{
		MIN_RESOURCE, MAX_RESOURCE, 
		MIN_COMMAND, MAX_COMMAND, 
		MIN_WINDOW, MAX_WINDOW,
		MIN_STRING, MAX_STRING,
	};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\bldrfile.h ===
// CBuildFile
//
// Build file reading and writing.
//
// [matthewt]
//
				   
#ifndef _BUILD_FILE_H_
#define _BUILD_FILE_H_


#include "makread.h"

extern const UINT nVersionNumber;
extern const UINT nLastCompatibleMakefile;
extern const UINT nLastCompatibleOPTFile;

// Computed value do not alter
extern const UINT nVersionMajor;
extern const UINT nVersionMinor;
extern const UINT nLastCompatibleMakefileMinor;

class CNameMunger;

class CBuildFile 
{
public:
	CBuildFile();
	virtual ~CBuildFile();

	//
	// Top-level read/write
	//

	// read in the VC++ builder file
	BOOL ReadBuildFile(const CProject * pBuilder);

	// 'NMake syntax' section read/write
	BOOL ReadSectionForNMake(const TCHAR * pchname);

	CMakFileReader * m_pmr;

private:
	// current builder we are reading or writing
	CProject * m_pBuilder;

	// list of tools which were included in the read/write
	CVCPtrList m_lstToolsUsed;
};

// our *single* instance of the build file reader and writer
extern  CBuildFile g_buildfile;

#endif // _BUILD_FILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\bldrfile.cpp ===
// CBuildFile
//
// Build file reading and writing.
//
// [matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "bldrfile.h"	// local header
#include "version.h"    // for makefile versions
#include "project.h"	// g_pActiveProject

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define SECT_READ 0x0	// writing (supply buffer)
#define SECT_WRITE 0x1	// reading (process buffer)
#define SECT_END 0x2	// ended read or write (free buffer?)

//---------------------------------------------------
// EXTERNS



///////////////////////////////////////////////////////////////////////////////
// Convention: bump by 1 for OPT changes or simple makefile changes;
// Bump up to multiple of 10 for incompatible makefile format changes.

///////////////////////////////////////////////////////////////////////////////
// Makefile change history
// ALWAYS update this when bumping the OPT/Makefile version number
//
// Version number					Change							Made by
// 		30000						<reserved for release>			colint
// 		30001						Added targets					colint
//		30002						Fixed mirroring for targitems	colint
//		30003						Added file mapping				billjoy
//		30004						Removed old clw filename		colint
//      40000                       Break all old v3 makefiles      colint
//                                  (target name changes)
//      40001                       Fix INTDIR creation rule        colint
//                                  to use $(NULL), not nul


// Change these
static const UINT nMakeFileFormat = 00;	// internal makefile format number
const UINT nLastCompatibleMakefile = 40000;
const UINT nLastCompatibleOPTFile = 50009;

// Computed values do not alter
const UINT nVersionMajor = rmj;		// whole product major version
const UINT nVersionMinor = rmm;		// whole product minor version
const UINT nVersionNumber = (rmj * 10000) + (rmm * 100) + nMakeFileFormat;
const UINT nLastCompatibleMakefileMinor = ((nLastCompatibleMakefile % 10000) / 100);

#ifndef _SHIP
extern BOOL	g_bUseReleaseVersion;
#endif

// our instance of the build file reader and writer
CBuildFile  g_buildfile;

// builder file delimiters
static const TCHAR * pcPropertyPrefix = _TEXT("PROP ");
static const TCHAR * pcEndToken = _TEXT("End");

CBuildFile::CBuildFile()
{
}

CBuildFile::~CBuildFile()
{
}

// tool info. struct
typedef struct
{
	CBuildTool *	pTool;
	CBuildAction *	pAction;
	int				iAreas;
} S_ToolRec;

int TRcompare( const void *arg1, const void *arg2 )
{
	/* Compare all of both strings: */
	CBuildTool *pTool1 = (*( S_ToolRec ** )arg1)->pTool;
	CBuildTool *pTool2 = (*( S_ToolRec ** )arg2)->pTool;

	return _stricmp( (const TCHAR *)pTool1->m_strToolPrefix,(const TCHAR *)pTool2->m_strToolPrefix  );
}

// read in the VC++ builder file
BOOL CBuildFile::ReadBuildFile(const CProject * pBuilder)
{
	// remember this builder
	m_pBuilder = (CProject *)pBuilder;

	// no tool's used yet
	m_lstToolsUsed.RemoveAll();

	BOOL bRetval = TRUE;

	return bRetval;
}

// 'NMake syntax' section read
#define CCH_ALLOC_BLOCK		256
BOOL CBuildFile::ReadSectionForNMake(const TCHAR * pchname)
{
	// dynamic creation of sections?
	BOOL fAddDynaSection = FALSE;

	// get a section with this name?
	CBldrSection * pbldsect = g_BldSysIFace.FindSection(pchname);
	if (pbldsect == (CBldrSection *)NULL)
	{	
		HPROJECT hProj = (HPROJECT)g_pActiveProject; //dra
		if ((pbldsect = new CBldrSection(hProj)) == (CBldrSection *)NULL)
			return FALSE;

		// set the name, and mark as async.
		pbldsect->m_strName = pchname;
		pbldsect->m_pfn = NULL;

		fAddDynaSection = TRUE;
	}

	// init.
	pbldsect->m_pch = (TCHAR *)NULL;
	pbldsect->m_cch = 0;

 	// file exceptions can occur during builder file read
 	CFileException e;
	BOOL bRetval;

	// builder file object
	CObject * pObject = (CObject *)NULL;

	TRY
	{
		TCHAR * pch;
		size_t cch = 0;
		size_t cchAlloc = CCH_ALLOC_BLOCK;
		pch = (TCHAR *)calloc(cchAlloc + 1, sizeof(TCHAR));	// alloc. one for zero-term.
		if (pch == (TCHAR *)NULL)
			AfxThrowFileException(CFileException::generic);

		pbldsect->m_pch = pch;

		// break out when we reach the end of the section or EOF
		for (;;)
		{
			// read in section
			pObject = m_pmr->GetNextElement();
			VSASSERT(pObject != (CObject *)NULL, "NULL object in list!");

			// reached end of builder file prematurely?
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
				AfxThrowFileException(CFileException::generic);

			// read in our sections
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
			{
				TCHAR * pchComment = (TCHAR *)(const TCHAR *)((CMakComment *)pObject)->m_strText;

				// end of the section?
				if (!_tcsncmp(pchComment, pcEndToken, _tcslen(pcEndToken)))
				{
					*(pbldsect->m_pch + cch) = _T('\0'); cch++;	// zero. term

					// set out buffer size
					pbldsect->m_cch = cch;

					// provide the section data and get the return code?
					if (pbldsect->m_pfn)
						bRetval = (*pbldsect->m_pfn)(pbldsect, SECT_READ);
					else
						bRetval = TRUE;
					break;
				}

				// data length in section?
				size_t cchLen = _tcslen(pchComment);

			TryAgain:

				if ((cchLen + 1) > (cchAlloc - cch))	// incl zero. term
				{
					// need more memory so re-alloc
					cchAlloc += CCH_ALLOC_BLOCK;
					pch = (TCHAR *)realloc(pbldsect->m_pch, sizeof(TCHAR) * (cchAlloc + 1));		// alloc. one for zero-term.
					if (pch == (TCHAR *)NULL)
						AfxThrowFileException(CFileException::generic);

 					pbldsect->m_pch = pch;

					goto TryAgain;
				}

				// copy data into our buffer
				_tcscpy(pbldsect->m_pch + cch, pchComment);
				cch += cchLen;
				*(pbldsect->m_pch + cch) = _T('\0'); cch++;	// zero. term
			}

			// delete this object
			delete pObject; pObject = (CObject *)NULL;
		}
	}
	CATCH(CException, e)
	{	
		bRetval = FALSE;	// failure
	}
	END_CATCH

	// unget the last builder file element so that
	// our caller can process it
	if (pObject != (CObject *)NULL)
		m_pmr->UngetElement(pObject);

	// got a dyna-section and ok?
	if (fAddDynaSection)
	{
		// ok?
		if (bRetval)
		{
			// register this one
			g_BldSysIFace.RegisterSection((CBldrSection *)pbldsect);
		}
		else
		{
			// free up our data (we used sync. notify)
			if (pbldsect->m_pch != (TCHAR *)NULL)
				free(pbldsect->m_pch);

			// delete our section
			delete pbldsect;
		}
	}
	else
	{
		// free up our data (we used sync. notify)
		if (pbldsect->m_pch != (TCHAR *)NULL){
			free(pbldsect->m_pch);
			pbldsect->m_pch = NULL;
		}
	}

	return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\bldiface.cpp ===
//
// CBldSysIFace
//
// Build System Interface
//
// [matthewt]
//

#include "stdafx.h"

#include "bldiface.h"	// local header
#include "optnlink.h"	// to include P_MachineType constant
#include "targitem.h"
#include "project.h"	// g_pActiveProject
#include "projdep.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CBldSysIFace g_BldSysIFace;	// one 'n' only bld system interface

CProject *g_pActiveProject = NULL;

extern CProjComponentMgr * g_pPrjcompmgr;
extern BOOL g_bNoUI;		// defined in project.cpp

CString g_strTarg = _TEXT("");

CBldSysIFace::CBldSysIFace() {
}

CBldSysIFace::~CBldSysIFace() {
}

//
// Project object conversion
//
CProject * CBldSysIFace::CnvHProject(HPROJECT hProj)
{
	CProject * pProject = (CProject *)(hProj != ACTIVE_PROJECT ? hProj : GetActiveProject());
	return pProject;
}

CTargetItem * CBldSysIFace::CnvHConfig(HPROJECT hProj, HCONFIGURATION hConfig)
{
	if (hConfig==ACTIVE_CONFIG)
	{
		if (hProj == ACTIVE_PROJECT)
			hProj = (HPROJECT)g_pActiveProject;

		if (hProj != NO_PROJECT)
		{
			return ((CProject *)hProj)->GetActiveTarget();
		}
		return NULL;
	}
	
	if (hConfig==NO_CONFIG)
		return NULL;

	if (hProj == ACTIVE_PROJECT)
		hProj = GetProject(hConfig); // don't trust caller default

	if (hProj==NO_PROJECT)
		return NULL;

	return CnvHProject(hProj)->GetTarget(m_strlstConfigs.GetAt((POSITION)hConfig));
}

CTargetItem * CBldSysIFace::CnvHFileSet(HPROJECT hProj, HFILESET hFileSet)
{
	CTargetItem * pTargetItem = (CTargetItem *)(hFileSet != ACTIVE_FILESET ? hFileSet : (HFILESET)CnvHConfig(hProj, GetActiveConfig(hProj)));
	if( pTargetItem == NULL )
		return pTargetItem;

	ASSERT_VALID(pTargetItem);
	return pTargetItem;
}

HFILESET CBldSysIFace::GetFileSet(HPROJECT hProj, HCONFIGURATION hConfig)
{
	return (HFILESET)CnvHConfig(hProj, hConfig);
}

BOOL CBldSysIFace::GetFlavourFromConfigName
(
	const TCHAR * pchConfigName,
	CString & strFlavour
)
{
	// Form the whole configuration name
	CString strConfig = pchConfigName;
	int nFirst = strConfig.ReverseFind(_T('-'));
	VSASSERT(nFirst != -1, "Malformed config name!");
	nFirst += 2; // Skip over hyphen and trailing space

	CString strPlatformAndFlavour = strConfig.Right(strConfig.GetLength() - nFirst);
	CString strRemain;

	do 
	{
		CString strPlatform;
		CPlatform * pPlatform;	
		g_pPrjcompmgr->InitPlatformEnum();
		while (g_pPrjcompmgr->NextPlatform(pPlatform))
		{
			strPlatform = *(pPlatform->GetName());
			if (strPlatform.Compare(strPlatformAndFlavour.Left(strPlatform.GetLength())) == 0)
			{
				// Found the platform.
				strFlavour = strPlatformAndFlavour.Right(strPlatformAndFlavour.GetLength() - (strPlatform.GetLength() + 1));
				return TRUE;
 			}
		}
		strRemain = strConfig.Left(nFirst-2);
		nFirst = strRemain.ReverseFind(_T('-'));
		if (nFirst != -1 && (strRemain.GetLength()>4))
		{
			nFirst += 2;
			strPlatformAndFlavour = strConfig.Right(strConfig.GetLength() - nFirst);
		}
		else
		{
			// no more '-', we didn't get a standard config name, but...
			// olympus 1991 [patbr] look again using short name for Intel
			CString strWinPlatform("Win32");
			if (strWinPlatform.Compare(strPlatformAndFlavour.Left(strWinPlatform.GetLength())) == 0)
			{
				// Found the platform.
				strFlavour = strPlatformAndFlavour.Right(strPlatformAndFlavour.GetLength() - (strWinPlatform.GetLength() + 1));
				return TRUE;
			}
			else
			{
				VSASSERT(FALSE, "Don't understand any platform but Win32!");
				return FALSE;
			}
		}
	} while (1);

	return FALSE;
}

//
// Project query API
//

// Get the active project
HPROJECT CBldSysIFace::GetActiveProject() 
{
	return (HPROJECT)g_pActiveProject;
}

HPROJECT CBldSysIFace::GetProject(HCONFIGURATION hCfg)
{
	HPROJECT hProj;
	if (m_mapPrjConfigs.Lookup((void*)hCfg, (void *&)hProj))
		return (hProj);

	return NO_PROJECT;
}

//
// Project creation API
//
// Using this API, a project can be created, targets added, files added
// to those targets and tool settings & properties set for the files.
//
HPROJECT CBldSysIFace::CreateProject
(
	const TCHAR *	pchProjPath	// project path
)
{
	// Create the project object
	CProject * pOldProject = g_pActiveProject;
	CProject * pProject;
	pProject = new CProject;
	g_pActiveProject = pProject;

	CDir dirOld; dirOld.CreateFromCurrent();
	CPath path;

	if (pchProjPath != (const TCHAR *)NULL && path.Create(pchProjPath))
	{
		// set the current directory to match the pathname 
		if( !_tcsicmp( path.GetExtension(), ".mdp") ) {
			path.ChangeExtension(".mak");
			pchProjPath = (const TCHAR *)path;
		}

		CDir currentDir; currentDir.CreateFromPath(path);
		currentDir.MakeCurrent();
	}

	// No private data to initialize for a new project.
	// Pls. note active target is initialised by calls to CBldSysIFace::AddTarget()
	pProject->m_bPrivateDataInitialized = TRUE;

	if (!pProject->InitNew(NULL))
		goto CreationError;

	if (pchProjPath != NULL)
	{
		CPath pathProjName;
		if	(!pathProjName.Create(pchProjPath) ||
			 !pProject->SetFile(&pathProjName))
			goto CreationError;
	}
	else
	{
		CString strProjectName;
		BOOL bOK = pProject->GetStrProp(P_ProjItemName, strProjectName);
		VSASSERT(bOK, "Project property bag probably not properly associated.");
	}

	// return a pointer to this newly created project
	return (HPROJECT)pProject;

CreationError:

	g_pActiveProject = pOldProject;

	// Delete the project object
	if (pProject->m_bConvertedDS4x)
	{
		// may also need to delete temp projects
		POSITION pos = CProject::m_lstProjects.GetTailPosition();  // use our own private pos pointer
		while (pos != NULL)
		{
			pProject = (CProject *)CProject::m_lstProjects.GetPrev(pos);
			if (pProject->m_bConvertedDS4x)
			{
				delete pProject;
			}
		}
	}
	else
	{
		delete pProject;
	}
	g_pActiveProject = pOldProject;
 
	// set back the current directory since it fails to open
	dirOld.MakeCurrent();

	return NO_PROJECT;
}

HPROJECT CBldSysIFace::DeactivateProject(HPROJECT hProj)
{
	VSASSERT(hProj, "Invalid input parameter");
	CProject * pProject = (CProject *)hProj;

	// set active project to something else
	if (pProject && pProject == g_pActiveProject)
	{
		CProject * pActiveProject;
		g_pActiveProject = NULL;  	// we may no longer have an active project!
		POSITION pos = CProject::m_lstProjects.GetHeadPosition();  // use our own private pos pointer
		while (pos != NULL)
		{
			pActiveProject = (CProject *)CProject::m_lstProjects.GetNext(pos);
			if ((pActiveProject != NULL) && (pActiveProject != pProject))
			{
				ASSERT_VALID(pActiveProject);
				if (pActiveProject->IsLoaded())
				{
					HCONFIGURATION hConfig = GetActiveConfig((HPROJECT)pActiveProject);
					if (hConfig==NO_CONFIG)
					{
						CTargetItem * pTargetItem;
						CString strTargetName;
						pActiveProject->InitTargetEnum();
						pActiveProject->NextTargetEnum(strTargetName, pTargetItem);
						hConfig = GetConfig(strTargetName, (HPROJECT)pActiveProject);
						VSASSERT (hConfig, "No configs present in project?!?");
					}
					SetActiveConfig(hConfig, (HPROJECT)pActiveProject);
					break;
				}
				else
				{
					g_pActiveProject = pActiveProject; // at least we have one
				}
			}
		}
	}
	return (HPROJECT)g_pActiveProject;
}

// Close a project.
BOOL CBldSysIFace::CloseProject
(
	HPROJECT	hProj,			// project to close, if == ACTIVE_PROJECT, then close active project
	DeletionCause dcCause
)
{
	if (hProj == ACTIVE_PROJECT)
	{
		// actually closing the workspace
		CString strProject = _T("<no name>");
		BOOL retval = TRUE; // default
		// special case: close all projects
		InitProjectEnum();
		while ((retval) && ((hProj = GetNextProject(strProject, FALSE)) != NO_PROJECT))
		{
			VSASSERT(hProj != ACTIVE_PROJECT, "Failed to find the correct project!");
			g_bInProjClose = TRUE;
			retval = retval && CloseProject(hProj,dcCause);
			InitProjectEnum(); // hack: must re-init, since first project was just removed!
		}
		g_bInProjClose = FALSE;

		return retval;
	}

	VSASSERT(hProj != ACTIVE_PROJECT, "Failed to find the correct project!");
	// Get the project
   	CProject * pProject = CnvHProject(hProj);
	if (pProject == (CProject *)NULL)
		return TRUE;	// nothing to do

	hProj = (HPROJECT)pProject; // make sure not NULL
	if (!pProject->m_bProjectComplete)
	{
		VSASSERT(0, "Project not fully loaded before attempt to close it!");
		return FALSE;  // avoid recursion
	}

	// set active project to something else
	if (pProject == g_pActiveProject)
	{
		DeactivateProject((HPROJECT)pProject);
	}

	CString strName;
	pProject->GetName(strName);
	delete pProject;

	// if we are deleting this project from the workspace, then delete all the project deps that refer to it
	if (dcCause == ProjectDelete)
		::RemoveAllReferences(strName);

	// only do this when we're closing the very last project
	if (g_pActiveProject==NULL)
		m_lstFile.RemoveAll();

	return TRUE;	// success
}

// Get the active target if there is on, or NO_CONFIG if there isn't.
HCONFIGURATION CBldSysIFace::GetActiveConfig
(
	HPROJECT		hProj		// handle to the project containing the targets, default='active project'
)
{
	// get a project for this target to be searched in
	CProject * pProject = CnvHProject(hProj);

	if (pProject == NULL)
		return NO_CONFIG;

	if (pProject->GetActiveConfig() == NULL)
		return NO_CONFIG;

	// get our active target name
	CString strTarg = pProject->GetActiveConfig()->GetConfigurationName();

	return GetConfig((const TCHAR *)strTarg, (HPROJECT)pProject);
}

// Set the active target.
BOOL CBldSysIFace::SetActiveConfig
(
	HCONFIGURATION		hConfig,		// target to make the active one
	HPROJECT		hProj		// handle to the project containing the targets, default='active project'
)
{
	VSASSERT(hConfig != NO_CONFIG, "Only works for non-active config!");

	// get our target name
	CString strTarg = m_strlstConfigs.GetAt((POSITION)hConfig);

	// get a project for this target to be searched in
	if (hProj == ACTIVE_PROJECT)
		hProj = GetProject(hConfig); // don't trust caller default

	if( hProj == NO_PROJECT )
		return FALSE;

	CProject * pProject = CnvHProject(hProj);
	VSASSERT(pProject != NULL, "Failed to find even one project!");

	if (pProject != g_pActiveProject && g_pActiveProject)
	{
		if (pProject != g_pActiveProject)
			return FALSE;
	}

	// set this target as our active one
	BOOL bRet = TRUE;
	if (g_pActiveProject)
		bRet = g_pActiveProject->SetStrProp(P_ProjActiveConfiguration, strTarg);
	if(bRet)
		pProject->SetActiveConfig(strTarg);

	return bRet;	// ok?
}

// Get a target with name 'pchTarg' from the project, 'hProj'.
HCONFIGURATION CBldSysIFace::GetConfig
(
	const TCHAR *	pchTarg,	// name of this target to get
	HPROJECT		hProj		// handle to the project containing the target, default='active project'
)
{
	// null-terminated empty string?
	if (*pchTarg == _T('\0'))
		return NO_CONFIG;

	CString strKey = pchTarg;
	strKey.MakeUpper();	// case insensitive lookup
	HCONFIGURATION hConfig = (HCONFIGURATION)m_strlstConfigs.Find(strKey);
	
	if (hConfig == NO_CONFIG)
	{
		// It is okay for someone to ask us for a TARGET when there is no BUILDER. We should
		// just answer no.

		if (hProj != NO_PROJECT)
		{
			hConfig = (HCONFIGURATION)m_strlstConfigs.AddTail(strKey);
			m_mapPrjConfigs.SetAt((void *)hConfig, (void *)hProj);
		}
	}

	return hConfig;
}

BOOL CBldSysIFace::GetConfigName
(
	HCONFIGURATION		hConfig,		// target to get name of
	CString &		str,		// target name
	HPROJECT		hProj		// handle to the project containing the target, default='active project'
)
{
	if (hConfig == NO_CONFIG)
		return FALSE;

	hProj = GetProject(hConfig); // don't trust caller default

	if (hProj == NO_PROJECT)
		return FALSE;

	CConfigurationRecord * pcr = GetConfigRecFromConfigI(hConfig, hProj);
    if (pcr != NULL)
	    str = pcr->GetConfigurationName();
 	return (pcr != NULL);
}

// Create a target with name 'pchTarg' and add it to a project.
// Name of the 'official' platform must be specified in 'pchPlat', eg. "Win32 (x86)"
// Name of the target type must be specified in 'pchType', eg. "Application"
// Create debug or release default settings when a file is added to this target, 'fDebug'?
// A target can mirror another target's, 'hMirrorTarg', fileset.
// Function may fail (HCONFIGURATION == NO_CONFIG).
HCONFIGURATION CBldSysIFace::AddConfig
(
	const TCHAR *	pchTarg,				// name of this target

	const TCHAR *	pchPlat,				// name of this target's platform
	const TCHAR *	pchType,				// name of this target type
	BOOL			fUIDesc,				// platform and type are UI descriptions?
   
   	BOOL			fDebug,					// debug or release settings? default=debug

	TrgCreateOp		trgop,					// clone or mirrors another target? default=no
	HCONFIGURATION		hOtherTarg,				// target to clone or mirror

	SettingOp		setop,					// copy or default settings?
	HCONFIGURATION		hSettingsTarg,			// target to copy settings from 

	BOOL			bQuiet,					// show any warnings/errors during creation? default=yes
	BOOL			fOutDir,				// output directories? default=no
 	BOOL			fUseMFC,				// use MFC? default=yes
	HPROJECT		hProj					// project that contains target? default=('current'==ACTIVE_PROJECT) 
)
{
	VSASSERT(hProj != ACTIVE_PROJECT, "Specific project required!");
	if( hProj == ACTIVE_PROJECT || hProj == NO_PROJECT )
		return NO_CONFIG;

 	// a string version of our target type, eg. 'Win32 (x86) Application" 
	CString strTargName = CProjType::MakeNameFromPlatformAndType(pchPlat, pchType);

	CProjType * pProjType = NULL;
	if ((!fUIDesc && !g_pPrjcompmgr->LookupProjTypeByName((LPCTSTR)strTargName, pProjType)) ||
		(fUIDesc && !g_pPrjcompmgr->LookupProjTypeByUIDescription((LPCTSTR)strTargName, pProjType))
	   )
		return NO_CONFIG;

	// get a project for this target to be searched in
	CProject * pProject = CnvHProject(hProj);
	CProjTempProjectChange projChange(pProject);

	// store away the current config so we can reset it at the end of this
	// operation
	CString strActiveConfig;
	pProject->GetStrProp(P_ProjActiveConfiguration, strActiveConfig);

	// adjust our use of MFC
	fUseMFC = fUseMFC && g_pPrjcompmgr->MFCIsInstalled();

	// a string version of our target name
	CString strTarg;
	if (pchTarg != (const TCHAR *)NULL)
	{
		strTarg = pchTarg;	// user-supplied
		strTarg.TrimLeft();
		strTarg.TrimRight();
	}
	else
	{
		// auto-created by us
 		DefaultConfig(pProject, *(pProjType->GetPlatformUIDescription()), fDebug ? IDS_DEBUG_CONFIG : IDS_RELEASE_CONFIG, strTarg);
	}

	// string versions of our 'other' targets name
	CString strOtherTarg, strSettingsTarg;

	// do we have these?
	if (hOtherTarg != NO_CONFIG)
		strOtherTarg = m_strlstConfigs.GetAt((POSITION)hOtherTarg);
	else
		VSASSERT(trgop == TrgDefault, "with no other target we must have this");

	if (hSettingsTarg != NO_CONFIG)
		strSettingsTarg = m_strlstConfigs.GetAt((POSITION)hSettingsTarg);
	else
		VSASSERT(setop == SettingsDefault, "with no settings target we must have this!");

	CObList olItemList;
	POSITION pos;
	CProjItem *pItem;

	HCONFIGURATION hConfig = (HCONFIGURATION)GetConfig(strTarg, hProj);
	pProject->CreateTarget(strTarg, pProjType, trgop == TrgMirror ? strOtherTarg : _TEXT(""));

	CConfigurationRecord * pcrNewTarg = GetConfigRecFromConfigI(hConfig, hProj);
	CTargetItem * pNewTarget = pProject->GetTarget(strTarg);
	const CPlatform * pNewPlatform = pProjType->GetPlatform();

	// set target dir
	if (!g_strTarg.IsEmpty())
		pNewTarget->SetTargDir(g_strTarg);

	if (pNewTarget->GetTargetName().IsEmpty())
	{
		int index = strTarg.Find(" - ");
		VSASSERT(index > 0, "Malformed config name");
		CString strTargetName = strTarg.Left(index);
		pNewTarget->SetTargetName(strTargetName);
		if (pProject->GetTargetName().IsEmpty())
			pProject->SetTargetName(strTargetName);
		VSASSERT(strTargetName == pProject->GetTargetName(), "Target name doesn't match that for project!");
	}

	// establish output dirs for new target?
	CString strProjDir = _TEXT("");
	CString strOutDirs;
	if (fOutDir)
	{
		if (!g_strTarg.IsEmpty() )
		{
			CPath path;
			CDir  dir;

			TCHAR buffer[MAX_PATH];
			_tcscpy( buffer, (LPCSTR)g_strTarg );
			int nLen = lstrlen( buffer );

			if( *_tcsdec( buffer, buffer+ nLen ) != _T('\\') ) {
				_tcscat( buffer, _T("\\") );
			}
			// add a dummy file for CPath
			_tcscat( buffer, _T("a") );

			path.Create( buffer );
			dir = pProject->GetWorkspaceDir();

			path.GetRelativeName( dir, strProjDir );
			// remove the dumy filename
			strProjDir = strProjDir.Left( strProjDir.GetLength() - 1 );


			// remove the leading ".\"  if GetRelativeName succeeded
			if ( (strProjDir.Find('.') == 0) && (strProjDir.Find('\\') == 1)  ) {
				strProjDir = strProjDir.Right(strProjDir.GetLength()-2);
			}

			// remove ending '\\'
			int ich = strProjDir.ReverseFind('\\');
			if (ich != -1 && ich == strProjDir.GetLength()-1)
			{
				strProjDir = strProjDir.Left(strProjDir.GetLength()-1);	
			}
		}
		if (pchTarg != (const TCHAR *)NULL)
		{
			if (!g_strTarg.IsEmpty())
			{
				CPath path;
				CString strConfig;
				GetFlavourFromConfigName(strTarg, strConfig); 

				if ( (strConfig.Compare("Debug") == 0) || (strConfig.Compare("Release") == 0) )
				{
					strOutDirs = *(pProjType->GetPlatform()->GetDefOutDirPrefix());
					if (strOutDirs.IsEmpty())
					{
						// x86 platform
						strOutDirs += fDebug ? _T("Debug") : _T("Release");
					}
					else
					{
						// others
						strOutDirs += fDebug ? _T("Dbg") : _T("Rel");
					}
					if (path.CreateFromDirAndFilename(pProject->GetProjDir(), strOutDirs) 
						&& path.ExistsOnDisk())
					{
						GetNewOutputDirName(pProject, strTarg, strOutDirs);
					}
				}
				else
				{
					// added config, use config name as default dir
					strOutDirs += strConfig;
				}
			}
			else
			{
				// attempt to generate a unique name 
				GetNewOutputDirName(pProject, strTarg, strOutDirs);
			}
		}
		else
		{
			// set up defaults for intermediate and target directories
			strOutDirs = *(pProjType->GetPlatform()->GetDefOutDirPrefix());
			if (strOutDirs.IsEmpty())
			{
				strOutDirs += fDebug ? _T("Debug") : _T("Release");
			}
			else
			{
				strOutDirs += fDebug ? _T("Dbg") : _T("Rel");
			}
		}

		VSASSERT(!strOutDirs.IsEmpty(), "Output dir must be non-blank!");

		if (!g_strTarg.IsEmpty() )
		{
			CString strTmp;
			if (!strProjDir.IsEmpty())
			{
				strTmp = strProjDir + _T("\\") + strOutDirs;
			}
			else
			{
				strTmp = strOutDirs;
			}
			strOutDirs = strTmp;
		}

		if ( pProjType && 
			( (pProjType->GetUniqueTypeId() == CProjType::exttarget) ||
			  (pProjType->GetUniqueTypeId() == CProjType::generic) )
		   )
		{
			// for makefile or utility projects, the output directory should be the current directory.
			strOutDirs = "";
		}


		CString strBlank;
		pProject->SetStrProp(P_OutDirs_Intermediate, strOutDirs);
		pProject->SetStrProp(P_OutDirs_Target, strOutDirs);
		pProject->SetStrProp(P_Proj_TargDir, strProjDir);
		pProject->SetStrProp(P_ConfigDefaultDebugExe, strBlank);
	}

	// WINSLOWF
	pcrNewTarg->SetBuildToolsMap();
	// assign the build actions
	CBuildAction::AssignActions(pNewTarget, (CVCPtrList *)NULL, pcrNewTarg);
				

	// do the target-level settings
	if (setop != SettingsClone)
	{
		// create a fresh configuration here

		// set the debug/release default settings	
		pProject->SetIntProp(P_UseDebugLibs, fDebug); // used for MFC libs

		// set a deferred browser database make
		pProject->SetIntProp(P_NoDeferredBscmake, FALSE);

		if (fDebug)
			g_pPrjcompmgr->SetDefaultDebugToolOptions(pProject);
		else
			g_pPrjcompmgr->SetDefaultReleaseToolOptions(pProject);

		pProject->SetStrProp(P_ProjActiveConfiguration, strTarg);
		if (fDebug)
			pProjType->SetDefaultDebugTargetOptions(pProject, pNewTarget, fUseMFC);
		else
			pProjType->SetDefaultReleaseTargetOptions(pProject, pNewTarget, fUseMFC);
	}
	else
	{
		VSASSERT(setop == SettingsClone, "must be clone");

		// we are creating a new config by cloning from an existing one

	 	// get the platform for the original 'settings' target
	    CConfigurationRecord * pcrOldTarg = GetConfigRecFromConfigI(hSettingsTarg, hProj);

		CProjTempConfigChange projTempConfigChange(pProject);
		projTempConfigChange.ChangeConfig(pcrOldTarg);

		const CPlatform* pOldPlatform = pProject->GetProjType()->GetPlatform();
		projTempConfigChange.Release();

		// cross-platform?
		// if so then set up our default settings first
		if (pOldPlatform != pNewPlatform)
		{
			// copy in default tool settings
			if (fDebug)
				g_pPrjcompmgr->SetDefaultDebugToolOptions(pProject);
			else
				g_pPrjcompmgr->SetDefaultReleaseToolOptions(pProject);
		}

		// CreateConfig()  creates property bag ONLY in the project level, 
		// and the lower level will be created when SetStrProp(P_ProjActiveConfiguration,..)
		// is called.
		pProject->CopyCommonProps(pProject, strSettingsTarg);
		
		// after the prop bag is cloned
		// we need to reset
		// o original project type
		// o project configuration name
		// o active configuration name
		pProject->SetStrProp(P_ProjOriginalType, *pProjType->GetName());
		pProject->SetStrProp(P_ProjConfiguration, strTarg);
		pProject->SetStrProp(P_ProjActiveConfiguration, strTarg);

		// cross-platform?
		// if so then set up our us of MFC
		if (pOldPlatform != pNewPlatform)
		{
			// if we were using MFC make sure we use the right default
			// o we want NoMFC if none, or the library if dll is not supported
			int iUseMFC, iUseMFCDef;

			if (fUseMFC)
				iUseMFCDef = (pNewPlatform->GetAttributes() & PIA_Allow_MFCinDLL) ? UseMFCInDll : UseMFCInLibrary;
			else
				iUseMFCDef = NoUseMFC;

	 		if (!pProject->GetIntProp(P_ProjUseMFC, iUseMFC) || iUseMFC > iUseMFCDef)
				iUseMFC = iUseMFCDef;

			pProject->SetIntProp(P_ProjUseMFC, iUseMFC);

			// not handled in ::InformDependants do it here 
			if (!pProject->m_bProjectComplete)
				// we need to make sure we have the right setup
				// for an MFC project
				pProjType->PerformSettingsWizard(pProject, iUseMFC);

			// Set up the Machine option as this will be incorrect
			UINT nPlatformId = pNewPlatform->GetUniqueId();
			UINT nMachineProp;
			switch (nPlatformId)
			{
				case win32x86:		nMachineProp = 2;	break;
				case win16x86:		nMachineProp = 1;	break;
				case mac68k:		nMachineProp = 3;	break;
				case macppc:		nMachineProp = 5;	break;
				case win32alpha:	nMachineProp = 4;	break;
				default:			nMachineProp = 2;	break;	// default to x86
 			}

			COptionHandler * popthdlr;
			g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Linker),
				(CBldSysCmp *&)popthdlr);
 			pProject->SetIntProp (popthdlr->MapLogical(P_MachineType), nMachineProp);
 		}

		// also need to inform dependants that things are changing
		pProject->InformDependants(SN_ALL);
	} 

	if (fOutDir)
	{
		pProject->SetStrProp(P_OutDirs_Intermediate, strOutDirs);
		pProject->SetStrProp(P_OutDirs_Target, strOutDirs);
		pProject->SetStrProp(P_Proj_TargDir, strProjDir);
	}

	// do the file-level settings
	if (setop != SettingsClone)
	{
		// Copy any files we need to
		if (trgop == TrgCopy)
		{
			// Get the target to copy from and the target to copy to.
			CTargetItem* pTarget = pProject->GetTarget(strOtherTarg);
 			ASSERT_VALID(pTarget);
			ASSERT_VALID(pNewTarget);

 			// Now copy all the files
			HFILESET hFileSet = GetFileSet(ACTIVE_PROJECT, hConfig);
			for (POSITION pos = pTarget->GetHeadPosition(); pos != NULL;)
			{
				CObject* pOb = pTarget->GetNext(pos);
				// We copy only fileitems except target references
 				if (pOb->IsKindOf(RUNTIME_CLASS(CFileItem)))
  					(void)AddFile(hFileSet, ((CFileItem *)pOb)->GetFilePath(), FALSE, hProj);
  			}
		}
	}
	else
	{
		// Get the target to copy from and the target to copy to.
		CTargetItem* pTarget = pProject->GetTarget(strOtherTarg);
		CTargetItem* pNewTarget = pProject->GetTarget(strTarg);
		ASSERT_VALID(pTarget);
		ASSERT_VALID(pNewTarget);

		// Copy any files we need to
		if (trgop == TrgCopy)
		{
 			// Now copy all the files
			HFILESET hFileSet = GetFileSet(ACTIVE_PROJECT, hConfig);
			for (POSITION pos = pTarget->GetHeadPosition(); pos != NULL;)
			{
				CObject* pOb = pTarget->GetNext(pos);
 				if (pOb->IsKindOf(RUNTIME_CLASS(CFileItem)))
  					(void)AddFile(hFileSet, ((CFileItem *)pOb)->GetFilePath(), FALSE, hProj);
  			}
		}

		// we have to clone the CProjItem's property bags as well
		// but we can only do this AFTER setting the P_ProjActiveConfiguration 
		// property (above), since that is the time where the property bags
		// at the lower lever are created.
		// 
		// First, flatten the destination subtree
 		pNewTarget->FlattenSubtree(olItemList, CProjItem::flt_Normal | 
								   CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjDeps);
		if (trgop == TrgCopy)
		{
			// We are copying files so the src and destination items are NOT the same, so
			// we must flatten the src target subtree too
			CObList olSrcItemList;
			pTarget->FlattenSubtree(olSrcItemList, CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | 
									CProjItem::flt_ExcludeProjDeps);

			// Now we iterate through the subtrees, getting corresponding items from each flattened subtree
			POSITION posSrc, posDest;
            CProjItem *pSrcItem, *pDestItem;
			for (posSrc = olSrcItemList.GetHeadPosition(), posDest = olItemList.GetHeadPosition(); 
				 posSrc != NULL && posDest != NULL ;)
			{
				// Get the destination and src projitems
				pDestItem = (CProjItem *) olItemList.GetNext(posDest);
				pSrcItem = (CProjItem *) olSrcItemList.GetNext(posSrc);

				// Clone the property bag
				pDestItem->CopyCommonProps(pSrcItem, strSettingsTarg);

				// Set the base settings to be the same as the current settings at the
				// time of the copy
				pDestItem->SetCurrentConfigAsBase(); // copy the prop bag to default prop bag

				// also need to inform dependants that things are changing
				pDestItem->InformDependants(SN_ALL);
 			}
		}
		else
		{
			VSASSERT(trgop == TrgMirror, "Must be mirror");

			// We are mirroring which means the src and destination items are the same
			// So loop through the destination list of projitems
			for (pos = olItemList.GetHeadPosition(); pos != NULL ;)
			{
				// Get the src, and destination projitem
				pItem = (CProjItem *) olItemList.GetNext(pos);
			 	
			 	// Copy the current settings
			 	pItem->CopyCommonProps(pItem, strSettingsTarg);

                // Set the base settings to be the same as the current settings at the
                // time of the copy
                pItem->SetCurrentConfigAsBase(); // copt the prop bag to default prop bag

				// also need to inform dependants that things are changing
				pItem->InformDependants(SN_ALL);
 			}
		}
	}

	// finally make sure that we remember the 'base' (default) options
 	pProject->SetCurrentConfigAsBase();

	// set 'default' config to first debug config. created
 	if (fDebug &&
 		(pProject->m_strProjDefaultConfiguration.IsEmpty() ||
		 pProjType->GetPlatform()->IsPrimaryPlatform())			 
	   )
	{
		pProject->m_strProjDefaultConfiguration = strTarg;
	}

	// Make sure we are in the same config we were in when we
	// started to do this operation
	if (!strActiveConfig.IsEmpty())
		pProject->SetStrProp(P_ProjActiveConfiguration, strActiveConfig);

	return hConfig;
}

BOOL CBldSysIFace::AddDefaultConfigs
(
	const TCHAR *	pchPlat,				// UI or 'official' name of this target's platform
	const TCHAR *	pchType,				// UI or 'official' name of this target type

	HCONFIGURATION &	hDebugTarg,				// our created debug target
	HCONFIGURATION &	hReleaseTarg,			// our created release target

	BOOL			fUIDesc,				// using UI or 'official' names? default=UI
	BOOL			fOutDir,				// output directories? default=yes
	BOOL			fUseMFC,				// use MFC? default=yes

	HCONFIGURATION		hMirrorTarg,			// do we want to 'chain the mirroring'?
	HPROJECT		hProj,					// project that contains target? default='active project'
	const TCHAR *	pchTarg 				// name of this target, default use NULL to official names
)
{
	// get a project for this target to be searched in
	CProject * pProject = CnvHProject(hProj);
	hProj = (HPROJECT)pProject; // convert ACTIVE_PROJECT to actual value;
	if( hProj == NO_PROJECT )
		return FALSE;

	g_strTarg = pProject->GetWorkspaceDir();
	
	CProjTempProjectChange projChange(pProject);

	hDebugTarg = hReleaseTarg = NO_CONFIG;

	CString strTarg;

	// a string version of our target type, eg. 'Win32 (x86) Application" 
	CString strTargName = CProjType::MakeNameFromPlatformAndType(pchPlat, pchType);

	// Get the project type for these targets
	CProjType * pProjType = NULL;
	if ((!fUIDesc && !g_pPrjcompmgr->LookupProjTypeByName((LPCTSTR)strTargName, pProjType)) ||
		(fUIDesc && !g_pPrjcompmgr->LookupProjTypeByUIDescription((LPCTSTR)strTargName, pProjType))
	   )
		return FALSE;

	//
	// create our release config. for this project type
	//

	if (pchTarg != NULL)
	{
		CString strMode, strPlatformUIDescription;
		BOOL bOK = strMode.LoadString(IDS_RELEASE_CONFIG);
		VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
		strPlatformUIDescription = *(pProjType->GetPlatformUIDescription());
		strTarg = pchTarg;	// user-supplied
		strTarg += _T(" - ") + strPlatformUIDescription + _T(" ") + strMode;
	}
	else
	{
		strTarg = _TEXT("");
	}

	hReleaseTarg = AddConfig
	(
		(pchTarg!=NULL) ? (LPCTSTR)strTarg:NULL,

		pchPlat,				// 'official' name of this target's platform
		pchType,				// 'official' name of this target type
		fUIDesc,				// we're using 'official' names

		FALSE,					// release settings

		hMirrorTarg == NO_CONFIG ? TrgDefault : TrgMirror,	// default or 'chain-the-mirroring' target? default=no chaining
		hMirrorTarg,										// no target to clone or mirror

		SettingsDefault,		// default settings
		NO_CONFIG,				// no target to copy settings from
		 
		FALSE,					// show any warnings/errors during creation? default=yes
		fOutDir,				// create output directories?
		fUseMFC,				// use MFC?
		hProj					// project that contains target? default='active project'
	);
	if (hReleaseTarg == NO_CONFIG)
		return FALSE;	// failure

	//
	// create our debug config. for this project type
	//
	
	if (pchTarg != NULL)
	{
		CString strMode, strPlatformUIDescription;
		BOOL bOK = strMode.LoadString(IDS_DEBUG_CONFIG);
		VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
		strPlatformUIDescription = *(pProjType->GetPlatformUIDescription());
		strTarg = pchTarg;	// user-supplied
		strTarg += _T(" - ") + strPlatformUIDescription + _T(" ") + strMode;
	}
	else
	{
		strTarg= _TEXT("");
	}

	hDebugTarg = AddConfig
	(
		(pchTarg!=NULL) ? (LPCTSTR)strTarg:NULL,

		pchPlat,				// 'official' name of this target's platform
		pchType,				// 'official' name of this target type
		fUIDesc,				// we're using 'official' names

		TRUE,					// debug settings

		TrgMirror,				// default target
		hReleaseTarg,			// mirror other default target

		SettingsDefault,		// default settings
		NO_CONFIG,				// no target to copy settings from
		 
		FALSE,					// show any warnings/errors during creation? default=yes
		fOutDir,				// create output directories?
		fUseMFC,				// use MFC?
		hProj					// project that contains target? default='active project'
	);
	if (hDebugTarg == NO_CONFIG)
		return FALSE;	// failure

 	// set active config to be the default
	pProject->SetStrProp(P_ProjActiveConfiguration, pProject->m_strProjDefaultConfiguration);
	g_strTarg = "";
 
	return TRUE;	// success
}

// Delete an existing target
BOOL CBldSysIFace::DeleteConfig
(
	HCONFIGURATION	hConfig,		// target to delete
	HPROJECT		hProj			// project that contains target? default='active project'
)
{
	// get a project for this target to be searched in

	VSASSERT(NO_PROJECT!=hProj, "Must specify particular project!");
	HPROJECT hCmpBld = GetProject(hConfig);
	VSASSERT(NO_PROJECT!=hCmpBld, "Must specify particular config!");
	VSASSERT(hProj == hCmpBld, "Config doesn't come from specified project!");
	hProj = hCmpBld;
	VSASSERT(hProj, "Config doesn't belong to a project!");

	CProject * pProject = CnvHProject(hProj);
	VSASSERT(pProject, "Failed to pick up the correct project!");

	if( pProject == NULL )
		return FALSE;

	// Get the name of the target to delete
	CString strTarget;
	GetConfigName(hConfig, strTarget, hProj);

	const CVCPtrArray* pConfigArray = pProject->GetConfigArray();
	INT_PTR nSize = pConfigArray->GetSize();

	if (pProject->m_bProjectComplete)
	{
		// if we're destroying the project, make sure it is not active
		if ((nSize==1) && (pProject == g_pActiveProject))
			DeactivateProject(hProj);
	}

	// Delete the target
	BOOL bRetVal = pProject->DeleteTarget(strTarget);

	// Remove the target from our list of targets if we succeeded in deleting it
	if (bRetVal)
	{
		m_mapPrjConfigs.RemoveKey((void *)hConfig);
 		m_strlstConfigs.RemoveAt((POSITION)hConfig);
	}

	pConfigArray = pProject->GetConfigArray();
	nSize = pConfigArray->GetSize();
	if (pProject->m_bProjectComplete)
		VSASSERT(bRetVal, "Something failed during DeleteConfig!");

	// success?
	return bRetVal;
}

// Create a file and add it to a target, 'hConfig', with or without default settings, 'fSettings'.
// Function may fail (HBLDFILE == NO_FILE).
HBLDFILE CBldSysIFace::AddFile
(
	HFILESET		hFileSet,				// handle to the fileset
	const CPath *	ppathFile,				// file path
	int				fSettings,				// default settings for this fileitem
	HPROJECT		hBld,					// builder that contains target? default='active builder' 
	HFOLDER			hFolder,				// default is NO_FOLDER
	BOOL			fDeploy,				// for deploy outputs allow duplicate files
	BOOL			fNoFilter				// do not filter files by extension
)
{
	// get a builder for this target to be added to
	if (hBld == ACTIVE_PROJECT)
		hBld = GetActiveProject();

	if( hBld == NO_PROJECT )
		return NO_FILE;

	CProject * pProject = CnvHProject(hBld);
	CProjTempProjectChange projChange(pProject);

	// get the target item 
	CTargetItem * pTarget = CnvHFileSet(hBld, hFileSet);
	if (pTarget == NULL)
		return NO_FILE;

	CDir dir;
	// special logic to identify template files so that they go
	// in the right folder and so that ClassView never sees them
	BOOL bIsTemplate = FALSE;
	if (dir.CreateFromPath(*ppathFile))
	{
		CString strDir = dir;
		strDir.MakeLower();
		int nTemplate, nEnd;
		if ((nTemplate = strDir.Find("\\template")) != -1)
		{
			nEnd = nTemplate + lstrlenA("\\template");
			if ((nEnd >= strDir.GetLength()) || (strDir[nEnd] == '\\'))
				bIsTemplate = TRUE;
		}
	}
	CProjContainer * pContainer = (CProjContainer *)hFolder;  // use specified folder, if any
	if ((pContainer == NULL) || (!pContainer->IsKindOf(RUNTIME_CLASS(CProjContainer))))
	{
		pContainer = pTarget;  // by default, just add to the target
		CProjItem * pItem;

		CString strFilter;
		CString strTemplateFilter;
		strTemplateFilter.LoadString(IDS_TEMPLATE_FILES_FILTER);
		CObList ol;
 		pTarget->FlattenSubtree(ol, CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjDeps);
		POSITION pos = ol.GetHeadPosition();
		while (pos != NULL && !fNoFilter)
		{
			pItem = (CProjItem *)ol.GetNext(pos);
			VSASSERT(pItem->IsKindOf(RUNTIME_CLASS(CProjItem)), "Non-CProjItem in project item list!");
			if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
			{
				if ((pItem->GetStrProp(P_GroupDefaultFilter, strFilter)==valid) && (!strFilter.IsEmpty()))
				{
					if (strFilter == strTemplateFilter) // "<templates>"
					{
						if (bIsTemplate)
						{
							pContainer = (CProjContainer *)pItem;
							break;
						}
					}
					else if (FileNameMatchesExtension(ppathFile, strFilter))
					{
						// found appropriate group to add this too
						if (pContainer == pTarget) // make sure we're overriding the default
							pContainer = (CProjContainer *)pItem;
						if (!bIsTemplate)
							break;
					}
				}
			}
		}
	}
	
	// create the file
	CFileItem * pFile;
	if ((pFile = new CFileItem) == (CFileItem *)NULL)
		return NO_FILE;

	// set the file path
	pFile->SetFile(ppathFile);

	// move the file into the target
	pFile->MoveInto(pContainer);
	// For 98' set deploy property to be true
	pFile->SetIntProp(P_ItemDeployMode, DoNotDeploy);
	{
		pFile->SetIntProp(P_ItemDeployMode, DoNotDeploy);

		// WinslowF -- Bug 
		int iSize = pTarget->GetPropBagCount();
		VSASSERT(iSize, "Target must have at least one property bag!");
		const CVCPtrArray * pArrayCfg = pTarget->GetConfigArray();
		for (int i = 0; i < iSize; i++)
		{
			CConfigurationRecord * pcr = (CConfigurationRecord *)(*pArrayCfg)[i]; 
			if (pcr->IsValid())
			{
				CProjTempConfigChange projTempConfigChange(pProject);
				projTempConfigChange.ChangeConfig((CConfigurationRecord *)pcr->m_pBaseRecord);
				pFile->SetIntProp(P_ItemDeployMode, DoNotDeploy);
				int idOldBag = pFile->UsePropertyBag(BaseBag);
				pFile->SetIntProp(P_ItemDeployMode, DoNotDeploy);
				(void) pFile->UsePropertyBag(idOldBag);
			}
		}
	}

	// return the newly created file
	return (HBLDFILE)pFile;
}

// Map an external property number to an internal property number
static UINT mapPropToPropI[] =
{
	P_ItemExcludedFromBuild,		// property 0
	P_ProjUseMFC,					// property 1
	P_ProjAppWizUseMFC,				// property 2
	0,								// property 3
	0,								// property 4
	P_OutDirs_Intermediate,			// property 5
	P_OutDirs_Target,				// property 6
	P_Proj_TargDefExt,				// property 7
};

// Get the config. record for a target, 'hConfig'
CConfigurationRecord * CBldSysIFace::GetConfigRecFromConfigI
(
	HCONFIGURATION		hConfig,	// handle to the target
	HPROJECT		hProj	// project that contains target? default=('current'==ACTIVE_PROJECT) 
)
{
	// get the target file CProject
	CProject * pItem = CnvHProject(hProj);
	if( pItem == NULL )
		return NULL;
	
	VSASSERT(pItem->IsKindOf(RUNTIME_CLASS(CProject)), "Bad project pointer specified");

	// get our target name
	CString strTarg = m_strlstConfigs.GetAt((POSITION)hConfig);

	// get this target config record
	return pItem->ConfigRecordFromConfigName((const TCHAR *)strTarg);
}

// Enumerate projects
void CBldSysIFace::InitProjectEnum()
{
	CProject::InitProjectEnum();
}

HPROJECT CBldSysIFace::GetNextProject(CString & strProject, BOOL bOnlyLoaded /* = TRUE */)
{
	return (HPROJECT)(CProject::NextProjectEnum(strProject, bOnlyLoaded));
}

// Enumerate targets
void CBldSysIFace::InitConfigEnum(HPROJECT hProj)
{
	// get a project for this target to be searched in
	CProject * pProject = CnvHProject(hProj);
	if (pProject == (CProject *)NULL)
		return;

	pProject->InitTargetEnum();
}

HCONFIGURATION CBldSysIFace::GetNextConfig(CString & strTarget, HPROJECT hProj)
{
	// get a project for this target to be searched in
	CProject * pProject = CnvHProject(hProj);
	if (pProject == (CProject *)NULL)
		return NO_CONFIG;

	CTargetItem * pTargetItem;
	if (!pProject->NextTargetEnum(strTarget, pTargetItem))
		return NO_CONFIG;

	return GetConfig(strTarget, hProj);
}

// Enumerate files
void CBldSysIFace::InitFileEnum(HPROJECT hProj)
{
	// FUTURE: extend to allow enum of multiple fileset files cache
	m_lstFile.RemoveAll();
	m_posHFile = (POSITION)NULL;

	// get our list to enumerate
	int fo = (CProjItem::flt_ExcludeProjDeps | CProjItem::flt_ExcludeGroups);	// remove project deps
	CTargetItem * pTarget = CnvHConfig(hProj, GetActiveConfig(hProj));
	if (pTarget)
		pTarget->FlattenSubtree(m_lstFile, fo);

	// get start of enumeration
	m_posHFile = m_lstFile.GetHeadPosition();
}

HBLDFILE CBldSysIFace::GetNextFile()
{
	if (m_posHFile == (POSITION)NULL)
		return (HBLDFILE)NO_FILE;

	CFileItem * pItem = (CFileItem *)m_lstFile.GetNext(m_posHFile);
	VSASSERT(pItem->IsKindOf(RUNTIME_CLASS(CFileItem)), "Non-file in file set!");
	if (!pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		return (HBLDFILE)NO_FILE;
	}

	return (HBLDFILE)pItem;
}												

//
// Project file section support
//
// Provide a callback function that will be called when 
// a buffer needs to be provided to be written or a 
// buffer has been read and can be processed.
//
// Pls. note that sections are distinguished by name.

// UNDONE: fix for multiple project model
BOOL CBldSysIFace::RegisterSection(CBldrSection * pbldsect)
{
	void * pvDummy;
	CString strKey;

	if (pbldsect->m_hBld == NULL)
	{
		pbldsect->m_hBld = GetActiveProject();
	}
	strKey.Format("%d:%s", pbldsect->m_hBld, pbldsect->m_strName);


	// check the validity of the section
	if (pbldsect->m_strName.IsEmpty() ||					// got a name?
		m_mapSections.Lookup(strKey, pvDummy)	// unique?
	   )
		return FALSE;

	m_mapSections.SetAt(strKey, (void *)pbldsect);
	return TRUE;	// success
}

BOOL CBldSysIFace::DeregisterSection(const CBldrSection * pbldsect)
{
	CString strKey;
	HPROJECT hProj;

	hProj = pbldsect->m_hBld;
	if (hProj == NULL)
	{
		hProj = GetActiveProject();
	}
	strKey.Format("%d:%s", hProj, pbldsect->m_strName);

	return m_mapSections.RemoveKey(strKey);
}

void CBldSysIFace::InitSectionEnum()
{
	m_posSection = m_mapSections.GetStartPosition();
}

CBldrSection * CBldSysIFace::GetNextSection(CString & strSection)
{
	CBldrSection * pbldsect = (CBldrSection *)NULL;
	strSection = "";

	if (m_posSection != (POSITION)NULL)
		m_mapSections.GetNextAssoc(m_posSection, strSection, (void * &)pbldsect);

	return pbldsect;
}

CBldrSection * CBldSysIFace::FindSection(const TCHAR * pchName, HPROJECT hProj /*  = ACTIVE_PROJECT */)
{
	CBldrSection * pbldsect;
	CString strKey;

	if (hProj == ACTIVE_PROJECT)
	{
		hProj = GetActiveProject();
	}
	strKey.Format("%d:%s", hProj, pchName);

	if (!m_mapSections.Lookup(strKey, (void * &)pbldsect))
	{
		hProj = ACTIVE_PROJECT; // failed. Look up "global" build section (created before projects). BUG Orion 20232
		strKey.Format("%d:%s", hProj, pchName);
		if (!m_mapSections.Lookup(strKey, (void * &)pbldsect))
			pbldsect = (CBldrSection *)NULL;

	}

	return pbldsect;
}

// compiler option handler
#include "optncplr.h"

// Map a build file id to an internal property number and component
typedef struct
{
	UINT s_idProp;
	UINT s_idOptHdlr;
	const TCHAR * s_pcDefFilename;
	const TCHAR * s_pcDefExtension;
} S_FileId;

int CBldSysIFace::GetProjectToolset(HPROJECT hProj)
{
	CProject *pProject = CnvHProject(hProj);
	if (pProject != NULL)
		return(pProject->GetProjectToolset());
	else
		return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\bldiface.h ===
//
// CBldSysIFace
//
// Build System Interface
//
// [matthewt]
//

#ifndef _INCLUDE_BLDSYSIFACE_H
#define _INCLUDE_BLDSYSIFACE_H

#pragma warning(disable:4251) // dll-interface warnings...
#pragma warning(disable:4275)

// our project interface (project.h)
class CProject;
class CProjItem;
class CProjComponentMgr;
class CBldSysIFace;
class CBldrSection;
class CConfigurationRecord;

// our file registry (pfilereg.h)
//#include "pfilereg.h"

// Translation Guide
// An HPROJECT is a CProject *
// An HFILESET is a CTargetItem *
// An HCONFIGURATION is a POSITION in a list of CStrings of configuration names
// An HFOLDER is a CProjGroup *
// An HBLDFILE is a CFileItem *


// properties
//

// item excluded in the build (currently only applicable to files)
#define Prop_ExcludeFromBuild		0x0
// 0 - included
// !0 - excluded

// use of MFC (integer prop)
#define Prop_UseOfMFC				0x1  
// 0 - not using MFC
// 1 - using MFC in a static lib
// 2 - using MFC in a DLL

// mark as an AppWiz target
#define Prop_AppWizTarg				0x2

// class wizard file name
#define Prop_ClsWzdName				0x3

// target directory name
#define Prop_TargetDirectory		0x4

// output directories
#define Prop_IntermediateOutDir		0x5
#define Prop_TargetOutDir			0x6

// default target extension
// if not set then
// '.exe' for apps
// '.dll' for dynamic link libraries
// '.lib' for static libraries
#define Prop_TargetDefExt			0x7

enum DeletionCause {WorkspaceClose, ProjectDelete, ProjectUnload};
typedef enum {TrgDefault, TrgCopy, TrgMirror} TrgCreateOp;
typedef enum {SettingsDefault, SettingsClone} SettingOp;

class CProject;
class CTargetItem;
class CFileItem;


class CBldSysIFace : CObject
{
public:
	CBldSysIFace();
	~CBldSysIFace();

	//
	// Project API
	//

	// Return the active build system if there is one, or NO_PROJECT if there isn't
	HPROJECT GetActiveProject();

	//
	// Using this API, a project can be created, targets added, files added
	// to those targets and tool settings & properties set for the files.
	//
	// Create a project with the name 'pchPrjPath'.
	// If fForce == TRUE then if any project is already open the user will
	// be prompted to close this project, else the function will fail (HPROJECT == NO_PROJECT).
	HPROJECT CreateProject
	(
		const TCHAR *	pchPrjPath		// project path
	);

	// Close a project.
	BOOL CloseProject
	(
		HPROJECT		hPrj, 	// project to close, default='close active project'
		DeletionCause	dcCause 	// project to close, default='close active project'
	);

	//
	// Config API
	//

	// Get the active target if there is on, or NO_CONFIG if there isn't.
	HCONFIGURATION GetActiveConfig
	(
		HPROJECT		hPrj = ACTIVE_PROJECT		// handle to the project containing the targets, default='active project'
	);

	// Set the active target.
	BOOL SetActiveConfig
	(
		HCONFIGURATION		hConfig,						// target to make the active one
		HPROJECT		hPrj = ACTIVE_PROJECT		// handle to the project containing the targets, default='active project'
	);

	// Get a target with name 'pchTarg' from the project, 'hPrj'.
	HCONFIGURATION GetConfig
	(
		const TCHAR *	pchTarg,					// name of this target to get
		HPROJECT		hPrj 	// handle to the project containing the target, default='active project'
	);

	BOOL GetConfigName
	(
		HCONFIGURATION		hConfig,						// target to get name of
		CString &		str,						// target name
		HPROJECT		hPrj 	// handle to the project containing the target, default='active project'
	);

	// Create a target with name 'pchTarg' and add it to a project.
	// Name of the 'official' or 'UI' platform must be specified in 'pchPlat', eg. "Win32 (x86)"
	// Name of the target type must be specified in 'pchType', eg. "Application"
	// Create debug or release default settings when a file is added to this target, 'fDebug'?
	// A target can mirror another target's, 'hMirrorTarg', fileset.
	// Function may fail (HCONFIGURATION == NO_CONFIG).
	HCONFIGURATION AddConfig
	(
		const TCHAR *	pchTarg,				// name of this target (if == NULL then names auto created)

		const TCHAR *	pchPlat,				// UI or 'official' name of this target's platform
		const TCHAR *	pchType,				// UI or 'official' name of this target type
		BOOL			fUIDesc = TRUE,			// using UI or 'official' names? default=UI

		BOOL			fDebug = TRUE,			// debug or release settings? default=debug

		TrgCreateOp		trgop = TrgDefault,		// clone or mirros another target? default=no
		HCONFIGURATION		hOtherTarg = NO_CONFIG,	// target to clone or mirror

		SettingOp		setop = SettingsDefault,	// copy or default settings?
		HCONFIGURATION		hSettingsTarg = NO_CONFIG,	// target to copy settings from
		 
		BOOL			fQuiet = FALSE,			// show any warnings/errors during creation? default=yes
		BOOL			fOutDir = TRUE,			// output directories? default=yes
		BOOL			fUseMFC = TRUE,			// use MFC? default=yes
		HPROJECT		hPrj = ACTIVE_PROJECT	// project that contains target? default='active project' 
	);

	// Create a pair of debug and release targets that mirror each other's file sets.
	BOOL AddDefaultConfigs
	(
		const TCHAR *	pchPlat,				// UI or 'official' name of this target's platform
		const TCHAR *	pchType,				// UI or 'official' name of this target type

		HCONFIGURATION &	hDebugTarg,				// newly created debug target
		HCONFIGURATION &	hReleaseTarg,			// newly created release target

		BOOL			fUIDesc = TRUE,			// using UI or 'official' names? default=UI
		BOOL			fOutDir = TRUE,			// output directories? default=yes
		BOOL			fUseMFC = TRUE,			// use MFC? default=yes

		HCONFIGURATION		hMirrorTarg = NO_CONFIG,// do we want to 'chain the mirroring'?
		HPROJECT		hPrj = ACTIVE_PROJECT,	// project that contains target? default='active project'
		const TCHAR *	pchTarg = NULL			// name of this target (if == NULL then names auto created)
	);
	
	// Delete an existing target
	BOOL DeleteConfig
	(
		HCONFIGURATION	hConfig,				// target to delete
		HPROJECT		hPrj 					// project that contains target? default='active project'
	);

	//
	// File API
	//

	// Create a file and add it to a fileset, 'hFileSet', with or without default settings, 'fSettings'.
	// Function may fail (HBLDFILE == NO_FILE).
	HBLDFILE AddFile
	(
		HFILESET		hFileSet,				// handle to the fileset
		const CPath *	ppathFile,				// file path
		int				fSettings = 0,			// use default settings(NYI)
		HPROJECT		hBld = ACTIVE_PROJECT,	// builder that contains target? default='active builder'
		HFOLDER			hFolder = NO_FOLDER,		// folder for the file
		BOOL			fDeploy = FALSE,
		BOOL			fNoFilter = FALSE
	);

	//
	// Enumeration and information API
	//
	// WARNING:
	// Currently these enumeration API can only enumerate single project items at a time.
	// o file set enumertion
	// o file enumeration
	//

	void 		InitProjectEnum();
	HPROJECT 	GetNextProject(CString & strProject, BOOL bOnlyLoaded = TRUE);
	
	void 		InitConfigEnum(HPROJECT hPrj = ACTIVE_PROJECT);
	HCONFIGURATION 	GetNextConfig(CString & strConfig, HPROJECT hPrj = ACTIVE_PROJECT); // Returns the name of the target as strConfig.

	void 		InitFileEnum(HPROJECT hProj);
	HBLDFILE 	GetNextFile();

	HFILESET GetFileSet(HPROJECT hPrj, HCONFIGURATION hConfig);

	//
	// Project file section support
	//
	// Provide a callback function that will be called when 
	// a buffer needs to be provided to be written or a 
	// buffer has been read and can be processed.
	//
	// Pls. note that sections are distinguished by name.
	BOOL RegisterSection(CBldrSection * pbldsect);
	BOOL DeregisterSection(const CBldrSection * pbldsect);

	// Enumeration
	void InitSectionEnum();
	CBldrSection * GetNextSection(CString & strSection);

	// Lookup
	CBldrSection * FindSection(const TCHAR * pchName, HPROJECT hPrj = ACTIVE_PROJECT);

	//
	// Project object conversion
	//

	CProject * CnvHProject(HPROJECT hPrj);
	CTargetItem * CnvHConfig(HPROJECT hPrj, HCONFIGURATION hConfig);
	CTargetItem * CnvHFileSet(HPROJECT hPrj, HFILESET hFileSet);

	BOOL GetFlavourFromConfigName
	(
		const TCHAR *	pchConfigname,					// configuration name
		CString &		str							// flavour name (e.g, Debug, Release,..)
	);

	BOOL 	GetProjectToolset( HPROJECT hPrj = ACTIVE_PROJECT );

	// Return the project if there is one, or NO_PROJECT if there isn't
	HPROJECT GetProject(HCONFIGURATION hConfig);
	HPROJECT DeactivateProject(HPROJECT hPrj);

public:
	// Get the config. record for a target, 'hConfig'
	CConfigurationRecord * GetConfigRecFromConfigI
	(
		HCONFIGURATION		hConfig,						// handle to the target
		HPROJECT		hPrj = ACTIVE_PROJECT		// project that contains target? default=('current'==ACTIVE_PROJECT) 
	);
	
private:
	CMapStringToPtr m_mapSections;					// our map of section names to section info.
	POSITION m_posSection;							// section enumeration 

	CStringList m_strlstConfigs;					// used to maintain targets names added so far

	POSITION m_posHFile;							// file enumeration
	CObList m_lstFile;								// FUTURE: make per-fileset

	CVCMapPtrToPtr m_mapPrjConfigs;
};									  

// our 'generic' build system components
// pls. note that the package for the 'generic' components is zero
#define idAddOnGeneric			0
#define szAddOnGeneric			(TCHAR *)NULL

#define BCID_Tool_RcCompiler	1
#define BCID_Tool_RcCompilerNT	2
#define BCID_Tool_Compiler		3
#define BCID_Tool_Linker		4
#define BCID_Tool_LinkerNT		5
#define BCID_Tool_BscMake		6
#define BCID_Tool_MkTypLib		7
#define BCID_Tool_Lib			8
#define BCID_Tool_CustomBuild	9
#define BCID_Tool_SpecialBuild	10

#define BCID_OptHdlr_Compiler		20
#define BCID_OptHdlr_Linker			21
#define BCID_OptHdlr_LinkerNT		22
#define BCID_OptHdlr_RcCompiler		23
#define BCID_OptHdlr_RcCompilerNT	24 
#define BCID_OptHdlr_BscMake		25
#define BCID_OptHdlr_Lib			26
#define BCID_OptHdlr_MkTypLib		27

#define BCID_ProjType_Generic			101

		
extern CBldSysIFace g_BldSysIFace;	// one 'n' only bld system interface

#endif // _INCLUDE_BLDSYSIFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\dirmgr.h ===
// DIRMGR.H
// --------
// Defines the directory manager, which manages the lists
// of directories for:
//
// - Executable files (traditionally the 'PATH' environment variable)
// - Include files ('INCLUDE')
// - Library files ('LIB')
// - Help files
//
// History
// =======
// 27-Aug-93	mattg		Created
// 10-Jan-93	colint		Added CToolset

#ifndef __DIRMGR_H__
#define __DIRMGR_H__

class CDirMgr; // Forward defn.

enum DIRLIST_TYPE	// these MUST start at -1 (with the uninitialized value) and be monotonically increasing
{
	DIRLIST_UNINITIALIZED = -1,
	DIRLIST_PATH = 0,
	DIRLIST_INC,
	DIRLIST_LIB,
    DIRLIST_SOURCE,
	C_DIRLIST_TYPES		// number of elements in the list: keep this last
};

////////////////////////////////////////////////////////////
// CToolset

class CToolset : public CObject
{
	friend class CDirMgr;

protected:
			CObList * m_Dirs[C_DIRLIST_TYPES];

			// Cache of the semi-colon seperated string representation
			// of this path. 
			CString   m_DirString[C_DIRLIST_TYPES];

			VOID RefreshAllCachedStrings( );

public:
			CToolset();
			~CToolset();

			CObList * GetDirList(DIRLIST_TYPE type);
				// Return a list of CDir objects.  The DIRLIST_TYPE argument
				// specifies which kind of list you want (DIRLIST_PATH,
				// DIRLIST_INC, etc.).   
				//
				// The returned list may be empty!
				//
				// PLEASE don't modify the list returned, as it's a pointer to
				// the actual list!

			VOID GetDirListString(CString &str, DIRLIST_TYPE type);

			VOID SetDirList(DIRLIST_TYPE type, CObList * pList);
				// Sets the specified list to the one passed in.  The 'original'
				// (existing) list is discarded, along with its contained objects.
};
 
////////////////////////////////////////////////////////////
// CDirMgr

class CDirMgr : public CObject
{
protected:
			CObList m_Toolsets;
				// List of CToolset objects, which contain arrays of lists of 
				// CDir objects for executable files,  include files, etc.
			INT	m_nCurrentToolset;
				// Index of the current toolset
			CStringList m_ToolsetNames;
				// List of the platform names for each toolset.

			CToolset * GetToolset(INT nToolset);
				// Useful helper function for retrieving a toolset.

public:
					CDirMgr();
	virtual			~CDirMgr();

			INT	GetCurrentToolset(); 
			VOID	SetCurrentToolset(INT nToolset);
				// Get or set the current toolset.

			INT		GetNumberOfToolsets();
				// Returns the number of toolsets currently stored in the
				// directories database

			INT		AddToolset(const CString & strPlatform);
				// Adds a new toolset to the directories database. The toolset
				// corresponds to the environment for a particular
				// platform, which is specified by the strTargetPlatform parameter.
			VOID		DeleteToolset(INT nToolset);
				// Deletes a toolset - this would be useful if the platforms supported
				// can change at run-time.
			
			const CObList * GetDirList(DIRLIST_TYPE type, INT nToolset = -1);
				// Return a list of CDir objects.  The DIRLIST_TYPE argument
				// specifies which kind of list you want (DIRLIST_PATH,
				// DIRLIST_INC, etc.).  The nToolSet argument specifies which list;
				// -1 means the 'current' list and is normally what you want.
				// If nToolSet is not -1, it must be in the range 0..CTOOLSETS-1
				// to specify a particular toolset.
				//
				// The returned list may be empty!
				//
				// PLEASE don't modify the list returned, as it's a pointer to
				// the actual list!

			VOID	GetDirListString(CString & str, DIRLIST_TYPE type, INT nToolset = -1);
				// Similar to GetDirList(), except returns (through the str
				// arg) a concatenated list of paths delimited by semicolon
				// characters (e.g., "C:\FOO;C:\BAR;C:\BIN").

			CObList * CloneDirList(DIRLIST_TYPE type, INT nToolset);
				// Clones the specified list and returns a pointer to the newly
				// created clone.  All CDir objects in the cloned list are also
				// created; that is, they are not simply copied from the 'original'
				// list.  It is the caller's responsibility to delete this list
				// and its contents (i.e., delete each element).  Typically,
				// however, this cloned list will later be used as an argument
				// to SetDirList(), in which case CDirMgr will take care of
				// eventually freeing it.

			VOID	SetDirList(DIRLIST_TYPE type, INT nToolset, CObList * pList);
				// Sets the specified list to the one passed in.  The 'original'
				// (existing) list is discarded, along with its contained objects.

			VOID	SetDirListFromString(DIRLIST_TYPE type, INT nToolset, const TCHAR * sz, BOOL fMustExist = FALSE);
				// Sets the specified list by parsing the string, which must
				// be of the form dir1;dir2;...
				// If 'fMustExist' then don't add a directory in this list if
				// it doesn't exist in the directory's file system.

			INT		GetPlatformToolset(const CString & strPlatform);
				// Returns the toolset number for a particular platform

			CString &	GetToolsetName(INT nToolset);
				// Returns the name of a toolset, this will be the name of a
				// platform that the toolset corresponds to.
};

// retrieve our single-instance of the directory manager for the shell
CDirMgr * GetDirMgr();

#endif // __DIRMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\dirmgr.cpp ===
// DIRMGR.CPP
// ----------
// Implementation of CDirMgr and CToolset class.
//
// History
// =======
// 28-Aug-93	mattg		Created
// 10-Jan-94	colint		Added CToolset class
//
////////////////////////////////////////////////////////////
// Include files

#include "stdafx.h"
#pragma hdrstop

#include "dirmgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

////////////////////////////////////////////////////////////
// Global variables

CDirMgr		g_theDirMgr;	// The one and only CDirMgr

CDirMgr * GetDirMgr() {return &g_theDirMgr;}

////////////////////////////////////////////////////////////
// Helper routines

static VOID DestroyListContents
(
	CObList *	pList
)
{
	POSITION	pos = pList->GetHeadPosition();

	while (pos != NULL)
		delete pList->GetNext(pos);

	pList->RemoveAll();
}

////////////////////////////////////////////////////////////
// CToolset Class

////////////////////////////////////////////////////////////
// Constructors, destructors

CToolset::CToolset
(
)
{
	INT			type;

	for (type=0; type<C_DIRLIST_TYPES ; ++type)
		m_Dirs[type] = new CObList;
}


CToolset::~CToolset
(
)
{
	INT 		type;
	CObList *	pList;

	for (type=0; type<C_DIRLIST_TYPES ; ++type)
	{
		if ((pList = m_Dirs[(DIRLIST_TYPE)type]) != NULL)
		{
			DestroyListContents(pList);
			delete pList;
		}	
	}
}

////////////////////////////////////////////////////////////
// CToolset::GetDirList

CObList * CToolset::GetDirList
(
	DIRLIST_TYPE	type
)
{
	VSASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES), "DirList type out of bounds");

	return (m_Dirs[type]);
}

/////////////////////////////////////////////////////////////
// CToolset::GetDirListString

VOID CToolset::GetDirListString
(
	CString&		str,
	DIRLIST_TYPE	type
)
{
	str.Empty();

	VSASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES), "DirList type out of bounds");
	if (type < DIRLIST_PATH || type >= C_DIRLIST_TYPES)
		return;

	CObList* pList = GetDirList(type);
	if (pList == NULL)
		return;

	POSITION pos = pList->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		if (!str.IsEmpty())
			str += _T(";");

		str += (const TCHAR *)*(CDir *)pList->GetNext(pos);
	}
}

/////////////////////////////////////////////////////////////
// CToolset::RefreshAllCachedStrings

VOID CToolset::RefreshAllCachedStrings
(
)
{
	INT type;

	for ( type = 0; type < C_DIRLIST_TYPES ; ++type )
	{
		CString &str = m_DirString[type];
		CObList *pList = m_Dirs[type];

		str.Empty();

		if ( pList != NULL )
		{
			POSITION pos = pList->GetHeadPosition();
			while ( pos != NULL )
			{
				if (!str.IsEmpty())
					str += _T(';');
				
				str += (const TCHAR *)*(CDir *)pList->GetNext(pos);
			}
		}
	}
}

////////////////////////////////////////////////////////////
// CToolset::SetDirList

VOID CToolset::SetDirList
(
	DIRLIST_TYPE	type,
	CObList *		pListNew
)
{
	VSASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES), "DirList type out of bounds");
	VSASSERT(pListNew != NULL, "Cannot add NULL list");

	if (m_Dirs[type] != NULL)
	{
		DestroyListContents(m_Dirs[type]);
		delete m_Dirs[type];
	}

	m_Dirs[type] = pListNew;
	RefreshAllCachedStrings( );
}

////////////////////////////////////////////////////////////
// CDirMgr Class

////////////////////////////////////////////////////////////
// Constructors, destructors

CDirMgr::CDirMgr
(
)
{
	m_nCurrentToolset = 0;
}

CDirMgr::~CDirMgr
(
)
{
 	POSITION		pos;
	CToolset *		pToolset;

	pos = m_Toolsets.GetHeadPosition();
	while (pos != NULL)
	{
		pToolset = (CToolset *)m_Toolsets.GetNext(pos);
		delete pToolset;
	}
	m_Toolsets.RemoveAll();
}


////////////////////////////////////////////////////////////
// CDirMgr::GetCurrentToolset
//
// This returns the current toolset for the project, if
// one exists. If we don't have a project then we will
// return whatever m_nCurrentToolset was last set to.

INT CDirMgr::GetCurrentToolset
(
)
{
	int nToolset = g_BldSysIFace.GetProjectToolset(ACTIVE_PROJECT);
	if( nToolset == -1 )
		nToolset = m_nCurrentToolset;
	return nToolset;
}
 
////////////////////////////////////////////////////////////
// CDirMgr::SetCurrentToolset
VOID CDirMgr::SetCurrentToolset
(
	INT		nToolset
)
{ 
	if (nToolset >= 0 && nToolset < m_Toolsets.GetCount())
		m_nCurrentToolset = nToolset; 
}

////////////////////////////////////////////////////////////
// CDirMgr::GetNumberOfToolsets

INT CDirMgr::GetNumberOfToolsets
(
)
{
	return (INT)m_Toolsets.GetCount();
}

////////////////////////////////////////////////////////////
// CDirMgr::AddToolset

INT CDirMgr::AddToolset
(
	const CString & strTargetPlatform
)
{
	INT				nToolset;
	CToolset *		pToolset;

	nToolset = (INT)m_Toolsets.GetCount();
	pToolset = new CToolset;
	m_Toolsets.AddTail(pToolset);
	m_ToolsetNames.AddTail(strTargetPlatform);

	return nToolset;
}

////////////////////////////////////////////////////////////
// CDirMgr::DeleteToolset

VOID CDirMgr::DeleteToolset
(
	INT nToolset
)
{
	POSITION 	pos;
	CToolset *	pToolset;

	if (nToolset >= 0 && nToolset < m_Toolsets.GetCount())
	{
		pos = m_Toolsets.FindIndex(nToolset);
		pToolset = (CToolset *)m_Toolsets.GetAt(pos);
		delete pToolset;
		m_Toolsets.RemoveAt(pos);
		m_ToolsetNames.RemoveAt(pos);
	}
}

////////////////////////////////////////////////////////////
// CDirMgr::GetToolset

CToolset * CDirMgr::GetToolset
(
	INT 	nToolset
)
{
	POSITION pos = m_Toolsets.FindIndex(nToolset);
	if (pos != NULL)
		return (CToolset *) (m_Toolsets.GetAt(pos));
	else
		return NULL;

}

////////////////////////////////////////////////////////////
// CDirMgr::GetDirList

const CObList * CDirMgr::GetDirList
(
	DIRLIST_TYPE	type,
	INT		nToolset	/* = -1 */
)
{
	if (nToolset == -1)
		nToolset = GetCurrentToolset();

	VSASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES), "DirList type out of bounds");
	CToolset * pToolset = GetToolset(nToolset);
	if (pToolset != NULL)
		return(pToolset->GetDirList(type));
	else
		return NULL;
}

////////////////////////////////////////////////////////////
// CDirMgr::GetDirListString

VOID CDirMgr::GetDirListString
(
	CString &		strRet,
	DIRLIST_TYPE	type,
	INT				nToolset	/* = -1 */
)
{
	if (nToolset == -1)
		nToolset = GetCurrentToolset();
	
	VSASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES), "DirList type out of bounds");
	CToolset * pToolset = GetToolset(nToolset);
	if (pToolset != NULL)
		pToolset->GetDirListString(strRet, type);
	else
		strRet.Empty();
}

////////////////////////////////////////////////////////////
// CDirMgr::CloneDirList

CObList * CDirMgr::CloneDirList
(
	DIRLIST_TYPE	type,
	INT				nToolset
)
{
	POSITION	pos;
	CObList *	pListSrc;
	CObList *	pListDst;
	CDir *		pDirSrc;
	CDir *		pDirDst;

	VSASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES), "DirList type out of bounds");

	pListSrc = GetToolset(nToolset)->GetDirList(type);
	pListDst = new CObList;

	pos = pListSrc->GetHeadPosition();

	while (pos != NULL)
	{
		pDirSrc = (CDir *)pListSrc->GetNext(pos);
		VSASSERT(pDirSrc->IsKindOf(RUNTIME_CLASS(CDir)), "DirList can only contain CDirs");
		pDirDst = new CDir(*pDirSrc);

		pListDst->AddTail(pDirDst);
	}

	return(pListDst);
}

////////////////////////////////////////////////////////////
// CDirMgr::SetDirList

VOID CDirMgr::SetDirList
(
	DIRLIST_TYPE	type,
	INT				nToolset,
	CObList *		pListNew
)
{
	CObList *		pList;
 
	VSASSERT(pListNew != NULL, "Cannot set NULL list");
	pList = GetToolset(nToolset)->GetDirList(type);
		
	GetToolset(nToolset)->SetDirList(type, pListNew);
}

////////////////////////////////////////////////////////////
// CDirMgr::SetDirListFromString

VOID CDirMgr::SetDirListFromString
(
	DIRLIST_TYPE	type,
	INT				nToolset,
	const TCHAR *	sz,
	BOOL			fMustExist /* FALSE */
)
{
	TCHAR *		pchCopy;
	TCHAR *		pchDir;
	CString		str = sz;
	CObList *	pList;
	CDir *		pDir;

	pList = GetToolset(nToolset)->GetDirList(type);

	if (pList == NULL)
		pList = new CObList;
	else
		DestroyListContents(pList);

	pchCopy = str.GetBuffer(1);
	pchDir = _tcstok(pchCopy, _T(";"));

	while (pchDir != NULL)
	{
		pDir = new CDir;
		if (!pDir->CreateFromString(pchDir))
		{
			VSASSERT(FALSE, "Failed to create directory path!");
			delete pDir;
			pchDir = _tcstok(NULL, _T(";"));

			continue;
		}

		// Check that the directory is not already
		// in the list. We do not add duplicates.
		BOOL fAddDir = TRUE;

 		POSITION pos = pList->GetHeadPosition();
 		while (pos != NULL)
		{
			CDir * pTempDir = (CDir *)pList->GetNext(pos);
			if (*pTempDir == *pDir)
			{
				fAddDir = FALSE;
				break;	// found, break-out
			}
		}

		// If we are to add this and it must exist, make
		// sure it does, otherwise don't add it
		if (fMustExist && fAddDir)
			fAddDir = pDir->ExistsOnDisk();

		// If the directory is not a duplicate then add it,
		// else de-allocate
		if (fAddDir)			
		 	pList->AddTail(pDir);
		else
			delete pDir;

		pchDir = _tcstok(NULL, _T(";"));
	}

	GetToolset(nToolset)->RefreshAllCachedStrings();

	str.ReleaseBuffer();
}

////////////////////////////////////////////////////////////
// CDirMgr::GetPlatformToolset

INT	CDirMgr::GetPlatformToolset
(
	const CString & strPlatform
)
{
	POSITION	pos;
	CString		strToolsetName;
	INT			nToolset = 0;

	pos = m_ToolsetNames.GetHeadPosition();
	while (pos != NULL)
	{
		strToolsetName = m_ToolsetNames.GetNext(pos);
		if (strToolsetName == strPlatform)
			return nToolset;
		nToolset++;
	}

	return -1;
}

////////////////////////////////////////////////////////////
// CDirMgr::GetToolsetName

CString	& CDirMgr::GetToolsetName
(
	INT nToolset
)
{
	POSITION pos = m_ToolsetNames.FindIndex(nToolset);
	VSASSERT (pos != NULL, "Toolset number not found!");
	return m_ToolsetNames.GetAt(pos);
}

BOOL IsFileThere(const CString& strDir, const CString& strFName, CString& strFullPath)
{
	VSASSERT(!strFName.IsEmpty(), "File name is blank!");

	const TCHAR *pch = strFName;
	if ((strFName[0] != _T('\\')) &&
	    ((strFName.GetLength() < 2) || (*_tcsinc(pch) != _T(':'))))
	{
		if (strDir.IsEmpty())
			return FALSE;

		strFullPath = strDir;

		// Add a backslash between path and fname if needed
		// chauv - crystal 1529
		// can't use CString.Right(1).Compare("\\")) since this won't work with trailing backslash char in MBCS
		// if (strFullPath.Right(1).Compare("\\"))
		if ( _tcsrchr(strFullPath, '\\') != strFullPath.Right(1) )
			strFullPath += "\\";
	}

	strFullPath += strFName;

	if (_access(strFullPath, 04) == 0)	// check for read privs
		return TRUE;

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\bldrcvtr.h ===
// 
// CMak* (builder components)
//
// Conversion of old VC++ 1.x builder files (.mak)
//
// [matthewt]
//

#ifndef _INCLUDE_BLDRCVTR_H
#define _INCLUDE_BLDRCVTR_H

// CMak* classes
// These classes represent the various syntactic elements of a
// builder makefile.
class  CMakComment : public CObject
{
	DECLARE_DYNAMIC(CMakComment)

public:
	// constructor + destructor
	CMakComment(const TCHAR *);
	virtual ~CMakComment();

	CString		m_strText;	// text of comment

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
};

class  CMakMacro : public CObject
{
	DECLARE_DYNAMIC(CMakMacro)

public:
  	// constructor + destructor
	CMakMacro(const CString&, const CString &);
	virtual ~CMakMacro();

 	CString		m_strName;		// macro name
	CString		m_strValue;		// macro value
	CString		m_strRawData;	// raw data

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
};

class  CMakDescBlk : public CObject
{
	DECLARE_DYNAMIC(CMakDescBlk)

public:
  	// constructor + destructor
	// Note, the object is initially constructed with the targets
	// and dependencies strings.  Commands are added later
	// via AddCommand().
	CMakDescBlk(const CString &, const CString &);
	virtual ~CMakDescBlk();

	// Add a command to the list of commands.
	void AddCommand(const TCHAR *);

	CString		m_strTargets;	// string representing target(s) (left side of ':')
	CString		m_strDeps;		// string representing dependencies (right side of ':')
	CString		m_strTool;
	CStringList	m_listCommands;	// list of commands
	CString		m_strRawData;

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
};

class  CMakDirective : public CObject
{
	DECLARE_DYNAMIC(CMakDirective)

public:
 	// local type
	enum DTYP
	{
		DTYP_CMDSWITCHES,
		DTYP_ERROR,
		DTYP_MESSAGE,
		DTYP_INCLUDE,
		DTYP_IFNDEF,
		DTYP_IFDEF,
		DTYP_IF,
		DTYP_ELSEIFNDEF,
		DTYP_ELSEIFDEF,
		DTYP_ELSEIF,
		DTYP_ELSE,
		DTYP_ENDIF,
		DTYP_UNDEF
	};

 	// constructor + destructor
	CMakDirective(DTYP, const CString &);
	virtual ~CMakDirective();

	DTYP		m_dtyp;			// directive type.
	CString		m_strRemOfLine;	// string containing remainder of line after directive

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
};

class  CMakError : public CObject
{
	DECLARE_DYNAMIC(CMakError)

public:
  	// constructor + destructor
	CMakError();
	virtual ~CMakError();
};

class  CMakEndOfFile : public CObject
{
	DECLARE_DYNAMIC(CMakEndOfFile)

public:
  	// constructor + destructor
	CMakEndOfFile();
	virtual ~CMakEndOfFile();
};

#endif // _INCLUDE_BLDRCVTR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\intelx86.h ===
//
// Intelx86 C/C++ AddOn
//
// Intelx86 Platform C/C++ Tools Component Add-On 'package'
//
// [matthewt]
//

// platforms, tools, option handlers provided by this module

// add-on's name
#define szAddOnx86 "Microsoft Intelx86 C/C++ v1.0"

// our 'intelx86' build system components

#define BCID_Platform_x86			1

#define BCID_OptHdlr_Compiler_x86	120
#define BCID_OptHdlr_Linker_x86		121

#define BCID_Tool_Compiler_x86		140
#define BCID_Tool_Linker_x86		141

#define BCID_ProjType_x86Exe		160
#define BCID_ProjType_x86Dll		161
#define BCID_ProjType_x86Con		162
#define BCID_ProjType_x86Lib		163

#define BCID_BldrCnvtr_x86VC		180
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\engine.h ===
// CBuildEngine
//
// Build engine.
//
// [matthewt]
//
				   
#ifndef _ENGINE_H_
#define _ENGINE_H_

// definition of the CBuildAction class
class CProjItem;
class CBuildTool;

// definition of the CBuildActionList class
class  CBuildActionList : public CVCPtrList
{
public:
	CBuildActionList() : CVCPtrList(1) {}

	// find a tool and return the postion of the action
	VCPOSITION Find(CBuildTool * pTool);
};

#pragma hdrstop

class  CBuildAction : public CObject
{
	DECLARE_DYNAMIC(CBuildAction)
	
public:
	// Associate this action to a particular project item. This project item's
	// configuration reocrd will be accessed to retrieve configuration specific
	// action information.
	// Associate this action with a particular tool. It will access the CBuildTool's
	// methods in order to modify the action's build information.
	CBuildAction() {}
	CBuildAction(CProjItem *, CBuildTool *, BOOL fBuilder = FALSE, CConfigurationRecord * pcr = (CConfigurationRecord *)NULL );
	~CBuildAction();

	// Binding and un-binding to tools
	void Bind(CBuildTool * pTool);
	void UnBind();

	//
	// Assigning/unassigning of actions to project items (default is active config.)
	//
	static void AssignActions
	(
		CProjItem * pItem,
		CVCPtrList * plstSelectTools = (CVCPtrList *)NULL,
		CConfigurationRecord * pcr = (CConfigurationRecord *)NULL,
		BOOL fAssignContained = TRUE,
		BOOL fAssignContainedOnly = FALSE
	);
	static void UnAssignActions
	(
		CProjItem * pItem,
		CVCPtrList * plstSelectTools = (CVCPtrList *)NULL,
		CConfigurationRecord * pcr = (CConfigurationRecord *)NULL,
		BOOL fUnassignContained = TRUE
	);

	//
	// Adding/removing of actions to/from build instances (default is active config.)
	//
	static void BindActions
	(
		CProjItem * pItem,
		CVCPtrList * plstSelectTools = (CVCPtrList *)NULL,
		CConfigurationRecord * pcr = (CConfigurationRecord *)NULL,
		BOOL fBindContained = TRUE
	);
	static void UnBindActions
	(
		CProjItem * pItem,
		CVCPtrList * plstSelectTools = (CVCPtrList *)NULL,
		CConfigurationRecord * pcr = (CConfigurationRecord *)NULL,
		BOOL fUnbindContained = TRUE
	);

	// serialize/deserialize the action slob
	virtual void Serialize(CArchive & ar);

	__inline CBuildTool * BuildTool()	{return m_pTool;}
	__inline CProjItem * Item()			{return m_pItem;}

	// Internal helper to set tool
	void SetToolI(CBuildTool *);

	// Associated project item and tool (+ tool user-data)
	CProjItem * m_pItem;
	CBuildTool * m_pTool;
	CBuildTool * m_pOldTool;

	// The configuration this action is concerning.
	CConfigurationRecord * m_pcrOur;
};

#endif // _ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\mcdoptn.cpp ===
//
// MERCED Compiler Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "mcdoptn.h"	// our local header file

//----------------------------------------------------------------
// our MERCED compiler option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(CompilerMerced, (UINT)NULL, (UINT)NULL, P_CpuMerced, P_BBThresholdMerced, TRUE)
	IDOPT_CALLCONV_MERCED,	"G%{d}1",		OPTARGS1(P_CallConvMerced),					single,
	IDOPT_BYTE_MERCED,	"Zp%{2|4|8|16|[1]}1",	OPTARGS1(P_ByteAlignMerced),					single,
	IDOPT_THREAD_MERCED,	"M%{L|T|D}1",		OPTARGS1(P_ThreadMerced),						single,
    IDOPT_GTVALUE_MERCED, "Gt%1",     OPTARGS1(P_GtvalueMerced), single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(CompilerMerced)
	OPTDEF_INT(CpuMerced, 1)
	OPTDEF_INT(CallConvMerced, 1)
	OPTDEF_INT(ByteAlignMerced, 3)
	OPTDEF_INT(ThreadMerced, 1)
    OPTDEF_INT(GtvalueMerced, 0)
    OPTDEF_INT(BBThresholdMerced, 2000)
END_OPTDEF_MAP()


//----------------------------------------------------------------
// our MERCED linker option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(LinkerMerced, (UINT)NULL, (UINT)NULL, (UINT)NULL, (UINT)NULL, TRUE)
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerMerced)
END_OPTDEF_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CCCompilerMercedTool, CCCompilerNTTool)
IMPLEMENT_DYNAMIC(CLinkerMercedTool, CLinkerNTTool)

BOOL OLD_OPTION_HANDLER(CompilerMerced)::AlwaysShowDefault(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_GtvalueMerced || idPropL == P_BBThresholdMerced);
}

//////////////////////////////////////////////////////////////////////////////////
// CCompilerMercedTool
//////////////////////////////////////////////////////////////////////////////////
CCCompilerMercedTool::CCCompilerMercedTool() : CCCompilerNTTool()
{
}

//////////////////////////////////////////////////////////////////////////////////
// CLinkerMercedTool
//////////////////////////////////////////////////////////////////////////////////

CLinkerMercedTool::CLinkerMercedTool() : CLinkerNTTool()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\mcdoptn.h ===
//
// Merced Tool Options and Tools
//

#pragma once

#include "merced.h"

//----------------------------------------------------------------
// our MERCED compiler option data
//----------------------------------------------------------------

// MERCED compiler option handler
DEFN_OPTHDLR_PLATFORM
(
	CompilerMerced, /* name */
	szAddOnx86, BCID_OptHdlr_Compiler_Merced, /* Merced compiler option handler */
	szAddOnx86, BCID_Tool_Compiler_Merced, /* Merced compiler tool */
	szAddOnGeneric, BCID_OptHdlr_Compiler /* base generic compiler option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// should this be shown always?
	virtual BOOL AlwaysShowDefault(UINT idProp);

END_OPTHDLR()

// MERCED compiler tool properties
#define P_CpuMerced				 		0x1000
#define P_CallConvMerced				0x1001
#define P_ByteAlignMerced				0x1002
#define P_ThreadMerced				 	0x1003
#define P_GtvalueMerced           		0x1004
#define P_BBThresholdMerced             0x1005

// MERCED compiler tool options (option ids)
#define IDOPT_CPU_MERCED					4000//072199 IDOPT_BASE + 0
#define IDOPT_CALLCONV_MERCED				4001//072199 IDOPT_BASE + 1
#define IDOPT_BYTE_MERCED					4002//072199 IDOPT_BASE + 2
#define IDOPT_THREAD_MERCED					4003//072199 IDOPT_BASE + 3
#define IDOPT_GTVALUE_MERCED				4004//072199 IDOPT_BASE + 4
#define IDOPT_BBTHRESHOLD_MERCED			4005//072199 IDOPT_BASE + 5

//----------------------------------------------------------------
// our MERCED linker option data
//----------------------------------------------------------------

// MERCED compiler option handler
DEFN_OPTHDLR_PLATFORM
(
	LinkerMerced, /* name */
	szAddOnx86, BCID_OptHdlr_Linker_Merced, /* Merced linker option handler */
	szAddOnx86, BCID_Tool_Linker_Merced, /* Merced linker tool */
	szAddOnGeneric, BCID_OptHdlr_LinkerNT /* base NT linker option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:

END_OPTHDLR()

#include "optncplr.h"	// our COMMON compiler tool
class CCCompilerMercedTool : public CCCompilerNTTool
{
	DECLARE_DYNAMIC (CCCompilerMercedTool)

public:
	CCCompilerMercedTool();
};

#include "optnlink.h"	// our COMMON compiler tool
class CLinkerMercedTool : public CLinkerNTTool
{
	DECLARE_DYNAMIC (CLinkerMercedTool)

public:
	CLinkerMercedTool();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\engine.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "engine.h"		// local header
#include "targitem.h"
#include "projdep.h"
#include "project.h"	// CProjTempConfigChange

IMPLEMENT_DYNAMIC(CBuildAction, CObject);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
//
// Class that is used to compare the base configuration of 
// a CConfigurationRecord* or CProjItem*.
//
class BaseConfiguration
{
public:
	BaseConfiguration( const CConfigurationRecord* pcr )
	{
		if ( NULL == pcr )
			m_pBaseRecord = NULL;
		else
			m_pBaseRecord = pcr->m_pBaseRecord;
	}
	BaseConfiguration( CProjItem* pItem )
	{
		if ( NULL == pItem )
			m_pBaseRecord = NULL;
		else
			m_pBaseRecord = pItem->GetActiveConfig()->m_pBaseRecord;
	}

	const CConfigurationRecord* m_pBaseRecord;
};

BOOL SameBaseConfig( BaseConfiguration a, BaseConfiguration b)
{
	//
	// return true if either is NULL since this is usually within an assert.
	// NULL conditions for a ProjItem* or CConfigurationRecord* should use a
	// separate assertion.
	//
	if ( NULL == a.m_pBaseRecord || NULL == b.m_pBaseRecord )
		return TRUE;
	else
		return a.m_pBaseRecord == b.m_pBaseRecord;
}
#endif

// Try to find a tool in an action in our list
VCPOSITION CBuildActionList::Find(CBuildTool * pTool)
{
	VCPOSITION pos = GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
	{
		VCPOSITION posCurr = pos;
		CBuildAction * pAction = (CBuildAction *)GetNext(pos);
		if (pTool == pAction->BuildTool())
			return posCurr;
	}

	return (VCPOSITION)NULL;
}

CBuildAction::CBuildAction(CProjItem * pItem, CBuildTool * pTool, BOOL fBuilder, CConfigurationRecord * pcr)
{
	VSASSERT( SameBaseConfig( pcr, pItem ), "Item and config record don't match!" );

	// associate
	m_pItem = pItem;
	m_pcrOur = pcr;

	m_pTool = m_pOldTool = (CBuildTool *)NULL;

	// bind to our tool?
	if (pTool != (CBuildTool *)NULL)
		Bind(pTool);
}

CBuildAction::~CBuildAction()
{
	// unbind from the tool?
	if (m_pTool != (CBuildTool *)NULL)
		UnBind();
}

// Binding and un-binding to tools
void CBuildAction::Bind(CBuildTool * pTool)
{
	// Set our tool
	SetToolI((CBuildTool *)pTool);
}

void CBuildAction::UnBind()
{
	// set our tool					   
	SetToolI((CBuildTool *)NULL);
}

void CBuildAction::SetToolI(CBuildTool * pTool)
{
	COptionHandler * popthdlr;

	if (m_pTool != (CBuildTool *)NULL)
	{
		// remove ourselves as a dependent of
		// the outputs of this tool
		popthdlr = m_pTool->GetOptionHandler();
		while (popthdlr != (COptionHandler *)NULL)
		{
			CBuildTool * pTool = popthdlr->m_pAssociatedBuildTool;
			if (pTool != (CBuildTool *)NULL)
				pTool->RemoveAction(this);
			popthdlr = popthdlr->GetBaseOptionHandler();
		}
	}
								   
	// add our input for this new tool?
	m_pOldTool = m_pTool;
	m_pTool = pTool;
	if( m_pTool != (CBuildTool *)NULL )
	{
		// make ourselves a dependent on
		// the outputs of this tool
		popthdlr = m_pTool->GetOptionHandler();
		while (popthdlr != (COptionHandler *)NULL)
		{
			CBuildTool * pTool = popthdlr->m_pAssociatedBuildTool;
			if (pTool != (CBuildTool *)NULL)
				pTool->AddAction(this);
			popthdlr = popthdlr->GetBaseOptionHandler();
		}
	}
}


void CBuildAction::Serialize(CArchive & ar)
{
	// don't bother with base-class
	 
	// storing?
	if (!ar.IsStoring())
	{
		// unknown tool?
		BOOL fIsSupported = FALSE;
		ar >> ((BYTE &)fIsSupported);

		// skip can we read this?
		if (!fIsSupported)
		{
			CString strDummy;
			BOOL fDummy = FALSE;

			ar >> ((BYTE &)fDummy);
			ar >> strDummy;
		}
		else if (fIsSupported)
		{
			// dirty command-line?
			BOOL fDirtyCommand = FALSE;
						
			ar >> ((BYTE &)fDirtyCommand);

			if (!fDirtyCommand)
			{
				BOOL fPossibleOptionChange = FALSE;
				ar >> ((BYTE &)fPossibleOptionChange);

				CString strDummy;
				ar >> strDummy;
			}
		}
	}
}

void CBuildAction::BindActions
(
	CProjItem * pTheItem,
	CVCPtrList * plstSelectTools /* = NULL */,
	CConfigurationRecord * pcr /* = (CConfigurationRecord *)NULL */,
	BOOL fBindContained /* = TRUE */
)
{
	VSASSERT(pTheItem != NULL, "Binding to NULL item!");
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProjTempConfigChange projTempConfigChange(pTheItem->GetProject());

	if (pcr != (CConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((CConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else {
		pcr = pTheItem->GetProject()->GetActiveConfig();
	}

	// valid?
	if (pTarget == (CTargetItem *)NULL || pTarget->GetActiveConfig()->IsValid())
	{
		CProjType * pProjType = pTarget->GetProjType();

		// Buildable project type?
		BOOL fBuildableProjType = !pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeUnknown));

		// Get the target type tools list
		CVCPtrList * plstTools = plstSelectTools == (CVCPtrList *)NULL ? pProjType->GetToolsList() : plstSelectTools;

		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups));
		plstContent = &lstContent;

		POSITION posItem = fBindContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;
		while (pItem != (CProjItem *)NULL)
		{
			// don't do this for project dependencies!
			if (!pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			{
				BOOL bItemIgnoreDefaultTool = FALSE;
				BOOL bIsFileItem = pItem->IsKindOf(RUNTIME_CLASS(CFileItem)); // includes (pItem->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem)))); // Hmmmm....
				if (bIsFileItem)
				{
					BOOL fIgnoreTool;
					bItemIgnoreDefaultTool = (pItem->GetIntProp(P_ItemIgnoreDefaultTool, fIgnoreTool) == valid && fIgnoreTool);
				}

				const CPath* pPath = pItem->GetFilePath();

				// Get the list of actions
				// Put these actions on the project if it's a target
				CProjItem * pItemActions = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;
				CBuildActionList * pActions = pItemActions->GetActiveConfig()->GetActionList();
				BOOL fActionsChange = FALSE;

				// Go through them and bind any tools to this item that want to be

				CBuildAction * pAction = NULL;

				CBuildTool * pTool;
				VCPOSITION pos = plstTools->GetHeadPosition();
				while (pos != (VCPOSITION)NULL)
				{
					pTool = (CBuildTool *)plstTools->GetNext (pos);

					// Ignore unknown tools
					if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
						continue;
					
					// skip default action if custom build tool specified
					if (bItemIgnoreDefaultTool && (!pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))))
						continue;

					// Allocate a 'building' action to to list?
					if (pTool->AttachToFile(pPath, pItem))
					{
						// Do we already have an 'old' action for this tool in our list?
						VCPOSITION posAction = pActions->GetHeadPosition();
						BOOL fFound = FALSE;
						while (posAction != (VCPOSITION)NULL)
						{
							pAction = (CBuildAction *)pActions->GetNext(posAction);

							if (pTool == pAction->m_pOldTool)
							{
								fFound = TRUE;
								break;
							}
						}

						// Re-bind?
						if (fFound)
						{
							// Set our config.
							VSASSERT(pAction, "No action?!?");
							pAction->m_pcrOur = pcr;
							VSASSERT( pAction->m_pItem == pItemActions, "Action's item doesn't match!" );
							VSASSERT( SameBaseConfig( pcr, pItemActions ), "Mismatch in config record!" );

							// Re-bind
							pAction->Bind(pTool);
						}
						// Assign!
						else
						{
							// check for multiple assignment
							VSASSERT(!pActions->Find(pTool), "Multiple assignment of tools!  NYI.");

							if(pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
								pItem->SetStrProp(P_ItemBuildTool, pTool->GetToolName());
							pAction = new CBuildAction(pItem, pTool, fBuildableProjType, pcr);
							pActions->AddTail(pAction);
							fActionsChange = TRUE;
						}
					}
					else
						continue;	// ignore
				}
				// Delete any actions not re-bound to
				VCPOSITION posAction = pActions->GetHeadPosition();
				while (posAction != (VCPOSITION)NULL)
				{
					VCPOSITION posActionHere = posAction;
					pAction = (CBuildAction *)pActions->GetNext(posAction);

					// Are we bound to a tool?
					if (pAction->m_pTool == (CBuildTool *)NULL)
					{
						// Remove from list and de-allocate
						pActions->RemoveAt(posActionHere);
						fActionsChange = TRUE;
						delete pAction;
					}
				}

				// Actions changed?
				if (fActionsChange)
				{
					// inform item dependents of output change
					pItem->InformDependants(P_ItemTools);
	#ifdef _DEBUG
					if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
					{
						VSASSERT(pActions->GetCount() <= 1, "Multiple actions for a file.  NYI.");
					}
	#endif
				}
			}

			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!

		}
	}
}

void CBuildAction::UnBindActions
(
	CProjItem * pTheItem,
	CVCPtrList * plstSelectTools /* = NULL */,
	CConfigurationRecord * pcr /* = (CConfigurationRecord *)NULL*/,
	BOOL fUnbindContained /* TRUE */  
)
{
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProjTempConfigChange projTempConfigChange(pTheItem->GetProject());

	if (pcr != (CConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((CConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else
	{
		pcr = pTheItem->GetProject()->GetActiveConfig();
	}

	// valid?
	if (pTarget == (CTargetItem *)NULL || pTarget->GetActiveConfig()->IsValid())
	{
		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups));
		plstContent = &lstContent;

		POSITION posItem = fUnbindContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;
		while (pItem != (CProjItem *)NULL)
		{
			// Get the list of actions
			// Put these actions on the project if it's a target
			CProjItem * pItemActions = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;
			CBuildActionList * pActions = pItemActions->GetActiveConfig()->GetActionList();

			// Go through them and unbind them from the tools
			// for their owner target

			CBuildAction * pAction;

			VCPOSITION pos = pActions->GetHeadPosition();
			while (pos != (VCPOSITION)NULL)
			{
				pAction = (CBuildAction *)pActions->GetNext(pos);

				// Un-bind from the tool?
				if (plstSelectTools != (CVCPtrList *)NULL && !plstSelectTools->Find(pAction->m_pTool))
					continue;	// no, it's not in our list

				pAction->UnBind();

				// Clear our config.
				pAction->m_pcrOur = pcr;
				VSASSERT( pAction->m_pItem == pItemActions, "Action list doesn't match!" );
				VSASSERT( SameBaseConfig( pcr, pItemActions ), "Config record doesn't match!" );
			}
			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
 		}
	}
}
	
void CBuildAction::AssignActions
(
	CProjItem * pTheItem,
	CVCPtrList * plstSelectTools /* = NULL */,
	CConfigurationRecord * pcr /* = NULL */,
	BOOL fAssignContained /* = TRUE */,
	BOOL fAssignContainedOnly /* = FALSE */
)
{
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProject * pProject = pTheItem->GetProject();
	CProjTempConfigChange projTempConfigChange(pProject);
	if (pcr != (CConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((CConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else
	{
		pcr = pProject->GetActiveConfig();
	}

	// valid?
	if (pTarget->GetActiveConfig()->IsValid())
	{
		CProjType * pProjType = pTarget->GetProjType();

		// Buildable project type?
		BOOL fBuildableProjType = !pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeUnknown));

		// Get the target type tools list
		CVCPtrList * plstTools = (plstSelectTools == (CVCPtrList *)NULL) ? pProjType->GetToolsList() : plstSelectTools;

		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups | CProjItem::flt_ExcludeProjDeps));
		plstContent = &lstContent;

		POSITION posItem = fAssignContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;

		if (fAssignContainedOnly)
		{
			//
			// Skip parent item and go to first item in its contents or NULL.
			//
			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
		}

		CBuildTool* pCustomBuildTool = NULL;
		while (pItem != (CProjItem *)NULL)
		{
			// don't do this for project dependencies!
			if (!pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			{
				BOOL bItemIgnoreDefaultTool = FALSE;
				BOOL bIsFileItem = pItem->IsKindOf(RUNTIME_CLASS(CFileItem)); // includes (pItem->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem))));

				if (bIsFileItem)
				{
					BOOL fIgnoreTool;
					bItemIgnoreDefaultTool = (pItem->GetIntProp(P_ItemIgnoreDefaultTool, fIgnoreTool) == valid && fIgnoreTool);
				}

				// stored on the project...even though attach to target
				const CPath* pPath = pItem->GetFilePath();

				// Get the list of actions
				// Put these actions on the project if it's a target
				// or default to the project if no target
				BOOL fTarget = pTarget == (CTargetItem *)NULL || pTarget == pItem;

				CProjItem * pItemActions = fTarget ? pItem->GetProject() : pItem;
				CBuildActionList * pActions = pItemActions->GetActiveConfig()->GetActionList();
				if (pItemActions->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem)))
				{
					if (pCustomBuildTool == NULL)
					{
						CVCPtrList* plstTools = pItem->GetProjType()->GetToolsList();
						VCPOSITION pos = plstTools->GetHeadPosition();
						while (pos != NULL && pCustomBuildTool == NULL)
						{
							CBuildTool* pTool = (CBuildTool*)plstTools->GetNext(pos);
							if (pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
								pCustomBuildTool = pTool;
						}
					}
					if (pCustomBuildTool != NULL)
					{
						CBuildAction* pEventAction = new CBuildAction(pItemActions, pCustomBuildTool, 
							TRUE, pItemActions->GetActiveConfig());
						pActions->AddTail(pEventAction);
					}
				}
				BOOL fActionsChange = FALSE;

				// Go through them and attach any to this item that want to be
				CBuildTool * pTool = NULL;
				VCPOSITION pos = plstTools->GetHeadPosition();

				// 	No need to loop through tools.
				if (pItem->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem)) ||
					(NULL==pPath && !fTarget) || (bIsFileItem && (pActions->GetCount() > 0)))
						pos = NULL;

				// Check to see if forced to a different tool than the default.
				CString strTool;
				{
					while (pos != (VCPOSITION)NULL)
					{
						pTool = (CBuildTool *)plstTools->GetNext (pos);
						

						// Ignore unknown tools
						if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
							continue;

						// skip default action if custom build tool specified
						if (bItemIgnoreDefaultTool && (!pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))))
							continue;

						CBuildAction * pAction;
						// allocate a 'building' + 'option' action to to list?

						// We are in bad shape if the active configuration of pItem doesn't match
						// pcr->m_pBaseRecord.
						VSASSERT( SameBaseConfig( pcr, pItem ), "Config record mismatch!  Deep trouble." );
						if (pTool->AttachToFile(pPath, pItem))
						{
							if(pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
								pItem->SetStrProp(P_ItemBuildTool, pTool->GetToolName());
							pAction = new CBuildAction(pItem, pTool, fBuildableProjType, pcr);
						}
						// allocate an 'option' action if the item is a target?
						else if (fTarget)
						{
							pAction = new CBuildAction(pItem, pTool, FALSE, pcr);
						}
						else
							continue;

						// check for multiple assignment
						VSASSERT(!pActions->Find(pTool), "Multiple tool assignment for file!  NYI.");

						pActions->AddTail(pAction);
						fActionsChange = TRUE;

						// cannot have multiple tools per-file for v3.0
						if (!fTarget && !pItem->IsKindOf(RUNTIME_CLASS(CProject)) )
							break;
					}
				}
				// Actions changed?
				if (fActionsChange)
				{
					// inform item dependents of output change
					pItem->InformDependants(P_ItemTools);
#ifdef _DEBUG
					if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem))) // includes (pItem->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem))))
					{
						VSASSERT(pActions->GetCount() <= 1, "Multiple tool assignment for file!  NYI.");
					}
#endif
				}
			}

			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
		}
	}
}

void CBuildAction::UnAssignActions
(
	CProjItem * pTheItem,
	CVCPtrList * plstSelectTools /* = NULL */,
	CConfigurationRecord * pcr /* = NULL */,
	BOOL fUnassignContained /* = TRUE */
)
{
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProjTempConfigChange projTempConfigChange(pTheItem->GetProject());
	if (pcr != (CConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((CConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else
	{
		pcr = pTheItem->GetProject()->GetActiveConfig();
	}

	// valid?
	if (pTarget == (CTargetItem *)NULL || (pTarget->GetActiveConfig() && pTarget->GetActiveConfig()->IsValid()))
	{
		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups | CProjItem::flt_ExcludeProjDeps));
		plstContent = &lstContent;

		POSITION posItem = fUnassignContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;
		while (pItem != (CProjItem *)NULL)
		{
			// don't do this for project dependencies!
			if (!pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			{
				// Get the list of actions
				// Put these actions on the project if it's a target
				CProjItem * pItemActions = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;
				if (pItemActions->GetActiveConfig())
				{
					CBuildActionList * pActions = pItemActions->GetActiveConfig()->GetActionList();
					BOOL fActionsChange = FALSE;

					// Go through them and detach them 

					CBuildAction * pAction;
					VCPOSITION pos = pActions->GetHeadPosition();
					while (pos != (VCPOSITION)NULL)
					{
						VCPOSITION posAction = pos;
						pAction = (CBuildAction *)pActions->GetNext (pos);

						// Remove from list and de-allocate?
						if (plstSelectTools != (CVCPtrList *)NULL && !plstSelectTools->Find(pAction->m_pTool))
							continue;	// no, it's not in our list
						pActions->RemoveAt(posAction);
						fActionsChange = TRUE;
						delete pAction;
					}

					// Actions changed?
					if (fActionsChange)
					{
						// inform item dependents of output change
						pItem->InformDependants(P_ItemTools);
					}
				}
			}

			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
 		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\makread.cpp ===
//////////////////////////////////////////////////////////////////////
// MAKREAD.CPP
//
// Implementation of CMakFileReader
//
// History
// =======
// Date			Who			What
// ----			---			----
// 30-May-93	mattg		Created
// 07-Jun-93	mattg		Added to VSHELL
// 13-Aug-93	mattg		Handle '\' continuation character
//							for directives
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Include files

#include "stdafx.h"
#pragma hdrstop
#include "makread.h"

//////////////////////////////////////////////////////////////////////
// IMPLEMENT_*
//
// These must be placed BEFORE the #ifdef _DEBUG stuff below

IMPLEMENT_DYNAMIC(CMakComment, CObject)
IMPLEMENT_DYNAMIC(CMakMacro, CObject)
IMPLEMENT_DYNAMIC(CMakDescBlk, CObject)
IMPLEMENT_DYNAMIC(CMakDirective, CObject)
IMPLEMENT_DYNAMIC(CMakError, CObject)
IMPLEMENT_DYNAMIC(CMakEndOfFile, CObject)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define MW_MAXDISPLAYLEN 32

//////////////////////////////////////////////////////////////////////
// Common makefile strings:

const TCHAR *szMkLineIndent = _TEXT ("    ");
const TCHAR cMkContinuation = _T('\\');

//////////////////////////////////////////////////////////////////////
// Helper routines

VOID StripLeadingWhite
(
	CString &	str
)
{
	TCHAR *	pchStart;
	TCHAR *	pchCur;
	int		ich;

	pchCur = pchStart = (TCHAR *)(const TCHAR *)str;

	while ((*pchCur == _T(' ')) || (*pchCur == _T('\t')))
		++pchCur;

	ich = (int)(pchCur - pchStart);

	str = str.Right(str.GetLength() - ich);
}

VOID StripTrailingWhite
(
	CString &	str
)
{
	TCHAR *	pchCur;
	TCHAR *	pchStart;
	TCHAR *	pchWhite = NULL;
	int		ichWhite;

	pchCur = pchStart = (TCHAR *)(const TCHAR *)str;

	while (*pchCur != _T('\0'))
	{
		if ((*pchCur == _T(' ')) || (*pchCur == _T('\t')))
		{
			if (pchWhite == NULL)
				pchWhite = pchCur;

			++pchCur;
		}
		else
		{
			pchCur = _tcsinc(pchCur);

			pchWhite = NULL;
		}
	}

	if (pchWhite != NULL)
	{
		ichWhite = (int)(pchWhite - pchStart);
		str = str.Left(ichWhite);
	}
}

VOID StripLeadingAndTrailingWhite
(
	CString &	str
)
{
	TCHAR *	pchStart;
	TCHAR *	pchCur;
	TCHAR *	pchTemp;
	TCHAR *	pchWhite = NULL;

	pchStart = pchCur = str.GetBuffer(0);

	// first check for leading whitespace and skip
	while ((*pchCur == _T(' ')) || (*pchCur == _T('\t')))
	{
		++pchCur;
	}

	// different code if leading whitespace
	INT_PTR nLeadingWhite = (pchCur - pchStart);
	char c;

	if (nLeadingWhite != 0)
	{
		pchTemp = pchStart;
		while ((c = *pchCur) != _T('\0') )
		{
			if ((c == _T(' ')) || (c == _T('\t')))
			{
				if (pchWhite == NULL)
					pchWhite = pchCur; // we adjust this later
			}
			else
			{
				pchWhite = NULL;
			}
			*(pchTemp++) = *(pchCur++);
		}
	}
	else
	{
		for ( c = *pchCur; c != _T('\0'); c = *++pchCur )
		{
			if ((c == _T(' ')) || (c == _T('\t')))
			{
				if (pchWhite == NULL)
					pchWhite = pchCur;
			}
			else
			{
				pchWhite = NULL;
			}
		}
	}

	if (pchWhite!=NULL)
	{
		pchCur = pchWhite; 	// reset pchCur to actual end of string
		*pchCur = _T('\0'); // and null terminate
	}
	str.ReleaseBuffer((int)((pchCur - pchStart) - nLeadingWhite));
}

VOID SkipWhite
(
	const TCHAR * &	pch
)
{
	while (*pch && ((*pch == _T(' ')) || (*pch == _T('\t'))))
		++pch;
}

VOID SkipNonWhite
(
	const TCHAR * &	pch
)
{
	while (*pch && (*pch != _T(' ')) && (*pch != _T('\t')) )
		++pch;
}

int  GetMakToken(const TCHAR * pBase, const TCHAR *& pTokenEnd)
		// throw CFileException
{
	int r = 0;
	BOOL bInQuotes = FALSE;
	pTokenEnd = pBase;

	// Skip whitespace at beginning:
	while (*pTokenEnd 
			&& 
		   (*pTokenEnd == _T(' ') || *pTokenEnd == _T('\t') )
		   )
	{
		r++;
		pTokenEnd++;
	}
     
	while (*pTokenEnd)
	{
		if (  *pTokenEnd ==  _T('"') ) bInQuotes = ~bInQuotes;
		else if (*pTokenEnd == _T(' ') || *pTokenEnd == _T('\t')
			|| *pTokenEnd == _T('\r')
#ifdef _UNICODE
			|| *pTokenEnd == _T('\n')  // should always get \r before \n unless Unicode
#endif
			 )
		{
			if (!bInQuotes) break;
		}
		r++;

		pTokenEnd = _tcsinc ( (char *) pTokenEnd);
    }  
	#ifdef _DEBUG
	if (bInQuotes && !*pTokenEnd) TRACE ("Unmatched quotes in GetToken\n");
	#endif 

	return r;
}

BOOL GetQuotedString(const TCHAR *& pBase, const TCHAR *& pEnd)
{				
	VSASSERT (pBase, "NULL input parameter!");

	while (*pBase && *pBase != _T('"'))
		 pBase=_tcsinc((TCHAR *)pBase);

	if (*pBase != _T('"'))
		return FALSE;

	pEnd = (pBase =_tcsinc((TCHAR *)pBase));		// Go past quote.

	while (*pEnd && *pEnd != _T('"'))
		pEnd=_tcsinc ( (TCHAR *) pEnd );

	if (pBase == pEnd || *pEnd != _T('"')) 
		return FALSE;

	return TRUE;
} 

//////////////////////////////////////////////////////////////////////
// CNameMunger class

#ifdef _MBCS
#define MAX_EXPANSION 4   
//#define MAX_EXPANSION 4 / 2
#else
#define MAX_EXPANSION 1
#endif

void CNameMunger::MungeName (const TCHAR *pszName, CString &strResult)
{
	// Take a string and convert it to something that can be put in
	// a make file as part of a macro name.  In the sbcs world we,
	// do this by taking the first 5 characters, converting any
	// bad characters to underscores, and then adding characters
	// until we no longer collide.  If we reach the end of the string,
	// we just start adding unique numbers until there's no collision.

	// In the mbcs world, we convert ASCII characters to underscores
	// and double byte charactes to there hex representation.

	TCHAR *pbase, *pcur, *pupcase;
	const TCHAR *pinbase;
	int i;
	void *pdum;
	CString *pcstr;

	// No one should be giving us an empty string:
    VSASSERT ( _tcslen (pszName) > 0, "Empty strings not allowed here!" );

	// Go for quick kill:  Have we seen the name before
	if (m_InMap.Lookup ( pszName, (void *&) pcstr))
	{
		strResult = *pcstr;
		return;
	}

	i = lstrlen (pszName);
	pinbase = pszName;
	// Get a buffer which we know will be big enough to hold the 
	// expanded name:
	pcur = pbase = strResult.GetBuffer 
							( i * MAX_EXPANSION + 9);

	pupcase = new TCHAR [i+1];
	// Try looking up upcased version of supplied string:
	_tcscpy (pupcase, pszName );
	_tcsupr (pupcase);
		if (m_InMap.Lookup ( pbase, (void *&) pcstr))
	{
		strResult = *pcstr;

		// Enter the base string for future reference:
		m_InMap.SetAt (pszName, (void *) pcstr);
		delete [] (pupcase);
		return;
	}
 

	for ( ;*pszName != _T('\0'); pszName = _tcsinc( (TCHAR *) pszName) )
	{
		// Copy the next character out of the source string and tranlate
		// it if nessesary:

		if ( *pszName == _T('_')
			||
			(*pszName >= _T('0') && *pszName <= _T('9'))
			||
			(*pszName >= _T('A') && *pszName <= _T('Z'))
			)
		{
			*pcur++ = *pszName;	
		}
		else if (*pszName >= _T('a') && *pszName <= _T('z'))
		{
			*pcur++ = (TCHAR)(*pszName -  (_T('a') - _T('A')));	// Upcase
		}
#ifdef _MBCS
		else if ( IsDBCSLeadByte ( (BYTE)*pszName))
		{
			_ultoa ( (LONG) *((UNALIGNED DWORD *) pszName), pcur, 16 );
			while (*pcur) pcur++;			 
		}
#endif
		else 
		{
			// Shave off leading weird characters:  Ignore if we haven't
			// advanced in the buffer.
			if (pcur > pbase) *pcur++ = _T('_');	
		}

		*pcur = _T('\0');				
		if ((pcur - pbase) < 5) continue;	// Alway use at least 5 if we can.

		if ( !m_ResMap.Lookup ( pbase, pdum)) break;
	}

	// If we reached the end of the input string and couldn't find an
	// unused name, then default to unique number type scheme.  If there
	// are no valid characters at all, start the name with an "M_":
	if (*pszName == _T('\0'))		    
	{
		if (pcur == pbase )
		{
			_tcscpy (pbase, "M_");
			pcur += 2;
		}

		i = (int)m_InMap.GetCount();
		do 
		{
			_ultoa ( (unsigned long)i, pcur, 16);
			i++;
		} while (m_ResMap.Lookup ( pbase, pdum));
	}

	strResult.ReleaseBuffer ();

	VSASSERT (!m_ResMap.Lookup ( pbase, pdum), "Failed to find what we are looking for!");

	pcstr = m_ResMap.SetAtAndReturnStringAddress (strResult);
	m_InMap.SetAt (pinbase, (void *) pcstr);
	// Also save upcased version:
	m_InMap.SetAt (pupcase, (void *) pcstr);
	delete [] (pupcase);

}
//////////////////////////////////////////////////////////////////////
// Constructors, destructors for CMak* objects

CMakComment::~CMakComment(){}
CMakComment::CMakComment
(
	const TCHAR * pszText
)
{
	m_strText = pszText;
	StripLeadingAndTrailingWhite(m_strText);
}
#ifdef _DEBUG
 void CMakComment::Dump ( CDumpContext& dc ) const
{
	CObject::Dump (dc);
	dc << "m_strText: " << m_strText << "\n";
}
#endif
CMakMacro::~CMakMacro(){}
CMakMacro::CMakMacro
(
	const CString & strMacName,
	const CString & strMacValue
)
{
	m_strName = strMacName;
	m_strValue = strMacValue;
}
#ifdef _DEBUG
 void CMakMacro::Dump ( CDumpContext& dc ) const
{
	CObject::Dump (dc);
	dc << "m_strName: " << m_strName << " m_strValue: " << m_strValue <<"\n";
}
#endif

CMakDescBlk::~CMakDescBlk(){}
CMakDescBlk::CMakDescBlk
(
	const CString & strTargets,
	const CString & strDeps
)
{
	m_strTargets = strTargets;
	m_strDeps = strDeps;
}
#ifdef _DEBUG
 void CMakDescBlk::Dump ( CDumpContext& dc ) const
{
	CObject::Dump (dc);
	dc << "m_strTargets: " << m_strTargets << " m_strDeps: " << m_strDeps <<
			"Commands: \n";
	int n = dc.GetDepth ();
	dc.SetDepth (1);
	dc << m_listCommands;
	dc.SetDepth (n);
}
#endif

#define CDirECTIVES 13

struct
{
	TCHAR *					szDirKeyword;
	int						nByteLen;
	CMakDirective::DTYP		dtyp;
}

#define DIRTEXT(x) _TEXT(x), (sizeof (x)-1) 

//  Note: in this table, longer items must come before items with
//  the same prefix (e.g. IFDEF before IF):

g_rgdirtbl[CDirECTIVES] =
{
	{ DIRTEXT("CMDSWITCHES"),	CMakDirective::DTYP_CMDSWITCHES},
	{ DIRTEXT("ERROR"),			CMakDirective::DTYP_ERROR		},
	{ DIRTEXT("MESSAGE"),		CMakDirective::DTYP_MESSAGE		},
	{ DIRTEXT("INCLUDE"),		CMakDirective::DTYP_INCLUDE		},
	{ DIRTEXT("IFNDEF"),		CMakDirective::DTYP_IFNDEF		},
	{ DIRTEXT("IFDEF"),			CMakDirective::DTYP_IFDEF		},
	{ DIRTEXT("IF"),			CMakDirective::DTYP_IF			},
	{ DIRTEXT("ELSEIFNDEF"),	CMakDirective::DTYP_ELSEIFNDEF	},
	{ DIRTEXT("ELSEIFDEF"),		CMakDirective::DTYP_ELSEIFDEF	},
	{ DIRTEXT("ELSEIF"),		CMakDirective::DTYP_ELSEIF		},
	{ DIRTEXT("ELSE"),			CMakDirective::DTYP_ELSE		},
	{ DIRTEXT("ENDIF"),			CMakDirective::DTYP_ENDIF		},
	{ DIRTEXT("UNDEF"),			CMakDirective::DTYP_UNDEF		}
};

CMakDirective::~CMakDirective(){}
CMakDirective::CMakDirective
(
	DTYP			dtyp,
	const CString & strRemOfLine
)
{
	m_dtyp = dtyp;
	m_strRemOfLine = strRemOfLine;
}
#ifdef _DEBUG
 void CMakDirective::Dump ( CDumpContext& dc ) const
{
	CObject::Dump (dc);
	dc << "m_dtyp " << g_rgdirtbl[m_dtyp].szDirKeyword << 
		" m_strRemOfLine: " << m_strRemOfLine <<"\n";
}
#endif

CMakError::~CMakError(){}
CMakError::CMakError(){}

CMakEndOfFile::~CMakEndOfFile(){}
CMakEndOfFile::CMakEndOfFile(){}

//////////////////////////////////////////////////////////////////////
// Constructors, destructors for CMakFileReader()
// How often to update the status bar:
const int CMakFileReader::nStatusBarUpdate = 16;
CMakFileReader::CMakFileReader() 
{
	m_pUngotElement = NULL;
	m_nFileSize = 0;
	m_nProgressGoal = 0;
}

CMakFileReader::~CMakFileReader()
{
	if (m_pUngotElement) delete (m_pUngotElement);
	if (m_nFileSize && (m_iAttrib & MakRW_ShowStatus))
	{
//		::StatusPercentDone(100);	// Let the user see this.
//		::StatusEndPercentDone();
//		::SetPrompt();
	}
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::Abort
void CMakFileReader::Abort()
{
	m_file.Abort ();
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::Close
void CMakFileReader::Close()
{
	m_file.Close ();
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::FillBuf

VOID CMakFileReader::FillBuf
(
)
{
	UINT	cchRead;

	cchRead = m_file.Read(m_rgchBuf, (CCH_BUF - 1) * sizeof(TCHAR));
	m_cchFile += cchRead;

	if (cchRead == 0)
	{
		/* At end-of-file.  Put a MAK_EOF TCHAR at the first position and
		** set the m_fEOF flag.
		*/

		m_rgchBuf[0] = MAK_EOF;
		m_rgchBuf[1] = _T('\0');
		m_fEOF = TRUE;
	}
	else
	{
		/* Terminate the buffer with a '\0'.
		**
		** Note that in the UNICODE case, cchRead may be odd, in which
		** case the file is bogus (second byte of a UNICODE character
		** is absent).  Anyway, we simply ignore the "half character"
		** at EOF.
		*/

		m_rgchBuf[cchRead / sizeof(TCHAR)] = _T('\0');
	}

	m_ichBuf = 0;
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::GetLine

BOOL CMakFileReader::GetLine
(
	CString &	strRet
)
{
	TCHAR	ch;
	UINT	cch = 0;
	char buf[100000];

	// NOTE: command lines longer than 1 Meg are absurd.
	char * pszRet = buf;

	while (((ch = GetChar()) != _T('\r')) && ((ch != MAK_EOF) || (!m_fEOF)))
	{
		pszRet[cch++] = ch;
		if (cch >= 100000)
		{
			ch = _T('\r');
			break;
		}
	}

	pszRet[cch] = _T('\0'); // ensure nul-terminated

	strRet = buf;	// set data length, and terminate
	
	if (ch == _T('\r'))
	{
		if (PeekChar() == _T('\n'))
			GetChar();

		return(TRUE);
	}

	return(FALSE);
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::ParseDirective

CObject * CMakFileReader::ParseDirective
(
	const CString &	strLine
)
{
	const TCHAR *	pch;
	INT_PTR			idir, cch = 0;
	CString			strRemOfLine, strT;

	VSASSERT(strLine[0] == _T('!'), "Directives must have an '!' in the first column!");

	pch = (const TCHAR *)strLine + 1;

	/* Skip any whitespace following the '!'.
	*/

	SkipWhite(pch);

	if (*pch == _T('\0'))
		return(new CMakError);

	/* Now search for a matching keyword.
	*/

	for (idir=0 ; idir<CDirECTIVES ; ++idir)
		if (_tcsnicmp(	g_rgdirtbl[idir].szDirKeyword,
						pch,
						cch = _tcslen(g_rgdirtbl[idir].szDirKeyword)) == 0)
			break;

	if (idir == CDirECTIVES)
		return(new CMakError);

	strRemOfLine = pch + cch;

	if (!((m_iAttrib & MakR_IgnLineCont) || strRemOfLine.IsEmpty()))
	{
		for (;;)
		{
			pch = strRemOfLine;

			if (*_tcsdec(pch, (TCHAR *)pch + _tcslen(pch)) != cMkContinuation)
				break;

			if (!GetLine(strT))
				return(new CMakError);

			strRemOfLine.SetAt(strRemOfLine.GetLength() - 1, _T(' '));
			strRemOfLine += strT;
		}
	}

	return(new CMakDirective(g_rgdirtbl[idir].dtyp, strRemOfLine));
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::ParseMacro

CObject * CMakFileReader::ParseMacro
(
	const CString &	strLine,
	int				ichEq
)
{
	// UNDONE: requires further optimization for buffer allocation

	int	len;
	const TCHAR *		pch;
	CString				strName, strValue, strT, strRawData;
	CMakMacro * pMacro;
	// alloc buffers to use up-front, this'll save allocs when 
	// we 'strRawData += ch'.  Note: this can be quite large! (4000+)
	strRawData.GetBuffer(4096);
	strValue.GetBuffer(4096);
	strRawData.ReleaseBuffer(0);
	strValue.ReleaseBuffer(0);

	strRawData += strLine;
	strRawData += _T("\r\n");

	/* Everything up to, but not including, the '=' is considered
	** to be the macro name.
	*/

	strName = strLine.Left(ichEq);
	strValue += (LPCTSTR(strLine) + (ichEq + 1));

	/* While the last character of the value string is '\', fetch
	** the next line and append it (line continuation).
	*/

	if (!((m_iAttrib & MakR_IgnLineCont) || strValue.IsEmpty()))
	{
		for (;;)
		{

			len = strValue.GetLength();
			pch = strValue;
			if (*_tcsdec(pch, (TCHAR *)(pch + len)) != cMkContinuation)
				break;

			if (!GetLine(strT))
				return(new CMakError);

			strRawData += strT;
			strRawData += _T("\r\n");

			strValue.SetAt(len-1, _T(' '));
			strValue += strT;
		}
	}

	/* Now strip leading and trailing whitespace from both the macro
	** name and macro value.
	*/

	StripLeadingAndTrailingWhite(strName);
	StripLeadingAndTrailingWhite(strValue);

	/* Return a new CMakMacro object.
	*/

	strValue.FreeExtra();
	strRawData.FreeExtra();
	pMacro = new CMakMacro(strName, strValue);
	pMacro->m_strRawData = strRawData;
	return pMacro;
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::ParseDescBlk

CObject * CMakFileReader::ParseDescBlk
(
	const CString &	strLine,
	int				ichColon,
	BOOL            fHaveDependencies
)
{
	TCHAR			ch;
	const TCHAR *	pch;
	BOOL			fDoubleColon = FALSE, fFirstLine;
	int				ich, ich1;
	CString			strLHS, strRHS, strT, strRawData;
	CMakDescBlk *	pmdb;
	(void)strRHS.GetBuffer(255);
	(void)strRHS.ReleaseBuffer(0);
	(void)strRawData.GetBuffer(511);
	(void)strRawData.ReleaseBuffer(0);

	strRawData += strLine;
	strRawData += _T("\r\n");	// record raw data incase needed later

	/* Split the line into its left-hand side (targets) and
	** right-hand side (dependents).
	*/

	if	(fHaveDependencies && (ichColon != strLine.GetLength() - 1)
		&& (strLine[ichColon + 1] == _T(':')))
		fDoubleColon = TRUE;

	if (fHaveDependencies)
	{
		strLHS = strLine.Left(ichColon);
		StripLeadingAndTrailingWhite(strLHS); // used for unique matches
		strRHS += strLine.Right(strLine.GetLength() - ichColon - (fDoubleColon ? 2 : 1));
	}
	else
	{
		strLHS.Empty();
		strRHS = strLine;
	}

	/* While the last character of the RHS string is '\', fetch
	** the next line and append it (line continuation).
	*/

	if (!strRHS.IsEmpty())
	{
		for (;;)
		{
			pch = strRHS;

			if (*_tcsdec(pch, (TCHAR *)pch + _tcslen(pch)) != cMkContinuation)
				break;

			if (!GetLine(strT))
				return(new CMakError);

			strRawData += strT;
			strRawData += _T("\r\n");
			strRHS.SetAt(strRHS.GetLength() - 1, _T(' '));
			strRHS += strT;
		}
	}

	strRHS.FreeExtra();
	pmdb = new CMakDescBlk(strLHS, strRHS);

	/* Now fetch all subsequent command lines, and add them to the object.
	*/

	fFirstLine = TRUE;

	for (;;)
	{
		/* First peek at the next character.  If it's not whitespace,
		** not a blank line, we'll break out of the loop, since this 
		** will end the list of command lines.
		** Note that this means that a comment will terminate a 
		** descritption block, which is not strictly NMAKE like, but
		** otherwise we will swallow potientially interesting comments:
		*/

		ch = PeekChar();

		if	(
			((ch == MAK_EOF) && (m_fEOF))
			||
				(
				(ch != _T(' '))
				&&
				(ch != _T('\t'))
				&&
				(ch != _T('\r'))
				)
			)
			break;

		if (!fFirstLine || fHaveDependencies)
		{
			/* Now fetch the next line -- but don't do it if this is the first line of
			** of something with no dependencies
			*/

			if (!GetLine(strRHS))
				break;

			strRawData += strRHS;
			strRawData += _T("\r\n");
		}

		/* Check for an empty line.  This is permitted (and ignored)
		** unless it is the first line after the dependency line, in
		** which case it ends the description block.
		*/

		if (strRHS.IsEmpty())
		{
			if (fFirstLine)
				break;
			else
				continue;
		}

		fFirstLine = FALSE;

		/* Check to see if this line is a comment line (possible leading
		** whitespace followed by a comment) or all whitespace.  If so,
		** just ignore it and continue.
		*/

		pch = strRHS;

		SkipWhite(pch);

		if ((*pch == _T('\0')) || (*pch == _T('#')))
			continue;

		/* Check to see if this line contains an inline file specification.
		** If so, accumulate all successive lines up to and including the
		** terminating line.
		*/

		if	(((ich = strRHS.Find(_T('<'))) != -1) &&
			 (ich < strRHS.GetLength() - 1) &&
			 (strRHS[ich+1] == _T('<'))
			)
		{
			for (;;)
			{
				if (!GetLine(strT))
				{
					delete pmdb;
					return(new CMakError);
				}

				strRawData += strT;
				strRawData += _T("\r\n");

				strRHS += _T('\n');
				strRHS += strT;

				if	((strT.GetLength() >= 2) &&
					 (strT[0] == _T('<')) &&
					 (strT[1] == _T('<'))
					)
					break;
			}
		}

		/* Now accumulate command lines while each ends in '\'.
		*/

		if (!(m_iAttrib & MakR_IgnLineCont))
		{
			for (;;)
			{
				pch = strRHS;

				if (*_tcsdec(pch, (TCHAR *)pch + _tcslen(pch)) != cMkContinuation)
					break;

				if (!GetLine(strT))
				{
					delete pmdb;
					return(new CMakError);
				}

				strRawData += strT + _T("\r\n");

				strRHS.SetAt(strRHS.GetLength() - 1, _T(' '));
				strRHS += strT;
			}
		}

		if (pmdb->m_strTool.IsEmpty())
		{
			// if we don't already have a tool, try to find one: $(TOOL)
			ich = strRHS.Find(_T("$("));
			if (ich!=-1)
			{
				ich += 2;
				ich1 = strRHS.Find(_T(')'));
				if (ich < ich1)
				{
					pmdb->m_strTool = strRHS.Mid(ich, (ich1 - ich));
					StripLeadingAndTrailingWhite(pmdb->m_strTool);
				}
			}
		}

		/* Finally, add this string to the list of commands.
		*/

		strRHS.FreeExtra();
		pmdb->m_listCommands.AddTail(strRHS);
	}

	strRawData.FreeExtra();
	pmdb->m_strRawData = strRawData;
	return pmdb;
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::Open

BOOL CMakFileReader::Open
(
	const TCHAR *		szFilename,
	UINT				nOpenFlags,
	CFileException *	exc,
	UINT				iAttrib	/* = MakRW_Default | MakRW_ShowStatus */
)
{
	// preserve our attributes
	m_iAttrib = iAttrib;

	m_nLineNum = 1;
	m_rgchBuf[0] = _T('\0');
	m_ichBuf = 0;
	m_fEOF = FALSE;
	m_cchFile = 0;
	CString str;

	if (m_file.Open(szFilename, nOpenFlags, exc))
	{
		if (m_iAttrib & MakRW_ShowStatus)
		{
			TRY
			{
				m_nFileSize	= m_file.GetLength ();
			}
			CATCH_ALL (e)
			{
				VSASSERT (m_nFileSize == 0, "Something bad happened while we were trying to determine the file length!");
			}
			END_CATCH_ALL	

		}
		return TRUE;
	}
	return FALSE;
}

//////////////////////////////////////////////////////////////////////
// ReOpen

void CMakFileReader::ReOpen()
{
	// seek to beginning of file
	(void)m_file.Seek(0, CFile::begin);

	m_nLineNum = 1;
	m_rgchBuf[0] = _T('\0');
	m_ichBuf = 0;
	m_fEOF = FALSE;
	m_cchFile = 0;

	// reset the number of objects read
	if (m_nFileSize && (m_iAttrib & MakRW_ShowStatus))
		m_nObjectsRead = 0;
}


//////////////////////////////////////////////////////////////////////
// GetNextElement

CObject * CMakFileReader::GetNextElement
(
	BOOL fMustHaveOutputs /* = TRUE */
)
{
	const TCHAR *		pch;
	const TCHAR *		pchT;
	BOOL				fInQuotes;
	CString				strLine;
	BOOL                bLineWithWhiteSpace = FALSE;

	// Return the ungot element if there is one:
	if (m_pUngotElement)
	{
		ASSERT_VALID (m_pUngotElement);

		CObject *pUngotElement = m_pUngotElement;
		m_pUngotElement = NULL;
		return pUngotElement;
	}

	for (;;)
	{
		/* Fetch the next line.
		*/

		if (!GetLine(strLine))
			return(new CMakEndOfFile);

		pch = (const TCHAR *)strLine;

		/* Find the first non-white character on the line, if any.
		*/

		SkipWhite(pch);

		/* Break out of the loop if this line is *not* entirely blank.
		** Otherwise, loop back to fetch another line.
		*/

		if (*pch != _T('\0'))
			break;
	}

	/* Check to see if the next character is '#'.  If so, the entire
	** line is a comment.
	*/

	if (*pch == _T('#'))
		return(new CMakComment(pch + 1));

	/* At this point, if there was any leading whitespace, an error ensues.
	 * Exception: build events go straight into the description block without
	 * any outputs to check for
	*/

	if (pch != (const TCHAR *)strLine)
	{
		if (fMustHaveOutputs)
			return(new CMakError);
		else
			bLineWithWhiteSpace = TRUE;
	}

	/* If the first character is '!', process the directive.
	*/

	if (*pch == _T('!'))
		return(ParseDirective(strLine));

	/* This line must either be a macro definition or a dependency line
	** (the start of a description block).
	**
	** Look for ':' and '=' inside the string, ignoring any occurrences
	** inside double quotes.
	**
	** If a non-quoted '=' is found, this is a macro definition.
	**
	** If a non-quoted ':' is found, this is a dependency line as long
	** as it was preceded by whitespace or at least two non-whitespace
	** characters (this rule is necessary to permit filenames with drive
	** specifications, e.g., "c:\foo\bar\blix.c").
	**
	** If this line is neither a macro definition nor a dependency line,
	** return an error.
	*/

	fInQuotes = FALSE;

	while (*pch != _T('\0'))
	{
		if (*pch == _T('"'))
		{
			fInQuotes = !fInQuotes;
		}
		else if ((*pch == _T('=')) && (!fInQuotes))
		{
			break;
		}
		else if ((*pch == _T(':')) && (!fInQuotes))
		{
			pchT = pch;

			if (pchT == (const TCHAR *)strLine)
			{
				/* We found the ':' at the beginning of the line.
				** This is an error (no targets!).
				*/

				return(new CMakError);
			}

			/* Check previous character.
			*/

			pchT = _tcsdec((const TCHAR *)strLine, (TCHAR *)pchT);

			if ((*pchT == _T(' ')) || (*pchT == _T('\t')))
			{
				/* Previous character was whitespace.  This is a
				** legitimate separator.
				*/

				break;
			}

			/* The previous character was NOT whitespace.
			**
			** Check the character two characters back.  If it's
			** whitespace, or if it doesn't exist (i.e., the character
			** one character back is the first character of the string),
			** then this is NOT a legitimate separator.
			**
			** Thus, this is a legitimate separator only if the
			** previous character exists and is not whitespace.
			*/

			if (pchT != (const TCHAR *)strLine)
			{
				pchT = _tcsdec((const CHAR *)strLine, (TCHAR *)pchT);

				if ((*pchT != _T(' ')) && (*pchT != _T('\t')))
					break;
			}
		}

		++pch;

#ifdef _MBCS
		if (IsDBCSLeadByte(*(pch-1)))
			++pch;
#endif
	}

	if (bLineWithWhiteSpace)
	{
		return ParseDescBlk(strLine, 0, fMustHaveOutputs);
	}
	else if (*pch == _T(':'))
	{
		return(ParseDescBlk(strLine, (int)(pch - (const TCHAR *)strLine), fMustHaveOutputs));
	}
	else if (*pch == _T('='))
	{
		return(ParseMacro(strLine, (int)(pch - (const TCHAR *)strLine)));
	}
	else
		return(new CMakError);
}

void CMakFileReader::UngetElement (CObject *pUngotElement)
{
	// Only single depth:
	ASSERT_VALID (pUngotElement);
	VSASSERT (m_pUngotElement == NULL, "Trying to unget more than one element at a time!" );	
	m_pUngotElement = pUngotElement;
}
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\mcdtooll.cpp ===
//
// MERCED Linker Tool
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "mcdtooll.h"	// our local header file

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CLinkerMercedTool, CLinkerNTTool)

CLinkerMercedTool::CLinkerMercedTool() : CLinkerNTTool()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\makread.h ===
//////////////////////////////////////////////////////////////////////
// MAKREAD.H
//
// Definition of CMakFileReader object.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 30-May-93	mattg		Created
// 07-Jun-93	mattg		Added to VSHELL
// 21-Jul-93    v-danwh     Added CNameMunger and CMakFileWriter
// 23-Sep-99	dianeme		Remove CMakFileWriter
//
// Description
// ===========
// The CMakFileReader object will read in a .MAK file which has been
// written out by the IDE.  It accepts a subset of the NMAKE syntax.
//
// The CMakFileReader will read:
//
// - Blank lines
//		- Ignored
// - Lines containing only whitespace
//		- Ignored
// - Lines containing only a comment, possibly with leading whitespace
//		- Returns text of comment (remainder of line)
// - Macro definitions
//		- Returns name and value
//		- Handles value continuation with trailing '\'
//		- Does NOT handle any other special characters
//		- Does NOT check for invalid characters in macro name
// - Directives
//		- Recognizes all types of directives
//		- Returns type of directive
//		- Returns remainder of directive line
//			- CMakFileReader user is responsible for interpretation
// - Description blocks
//		- Accepts :: dependency lines (although no difference in handling)
//		- Returns left side (targets), right side (deps) and commands
//		- Handles deps continuation with trailing '\'
//		- Handles inline file specifications
//		- Does NOT handle any other special characters
//////////////////////////////////////////////////////////////////////

#ifndef __MAKREAD_H__
#define __MAKREAD_H__

// standard include

//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CMakComment;
	class CMakMacro;
	class CMakDescBlk;
	class CMakDirective;
	class CMakError;
	class CMakEndOfFile;
	class CMakFileReader;
	class CNameMunger;
//////////////////////////////////////////////////////////////////////
// Helper routines

extern VOID		StripLeadingWhite(CString &);
	// Strip leading whitespace from the referenced string IN PLACE
	// (i.e., the string passed in is altered).  Whitespace is considered
	// to consist of spaces and tabs only.

extern VOID		StripTrailingWhite(CString &);
	// Strip trailing whitespace from the referenced string IN PLACE
	// (i.e., the string passed in is altered).  Whitespace is considered
	// to consist of spaces and tabs only.

extern VOID		StripLeadingAndTrailingWhite(CString &);
	// Strip leading AND trailing whitespace from the referenced string
	// IN PLACE (i.e., the string passed in is altered).  Whitespace is
	// considered to consist of spaces and tabs only.

extern VOID		SkipWhite(const TCHAR * &);
	// Skips to the next non-white character, where whitespace considered
	// to consist of tabs and spaces only.  On entry, the pointer points
	// to the first character to test; on exit, it will point to the first
	// non-white character (including possibly the '\0' string terminator).
extern VOID		SkipNonWhite(const TCHAR * &);
	// Opposite of above

extern int  GetMakToken(const TCHAR * pBase, const TCHAR *& pTokenEnd);
	// Fast forward to the end of the next token in the string at pBase.
	// Returns the number of _characters_ in the token.  Tokens are 
	// are delimetered by whitespace unless inside double quotes.  Quotes
	// Routine does not account for quotes inside quotes.

extern BOOL GetQuotedString(const TCHAR *& pBase, const TCHAR *& pEnd); 
	// Look through the string to find a quoted substring. On return
	// pBase points to first char after first pEnd points to last quote.
	// Return FALSE if < 2 quotes or 0 length substring.

//////////////////////////////////////////////////////////////////////
// CNameMunger class
//
// Takes names containing possibly nasty characters and produces
// a nice name (i.e. suitable as an NMAKE macro name) guranteed not
// to collide with any other names it produced/
class CNameMunger : public CObject
{

public:
	CNameMunger() { m_InMap.InitHashTable(179); m_ResMap.InitHashTable(197); }
	void MungeName (const TCHAR *, CString &);
private:

	// Special subclass of CMapStringToPtr  that returns a poitner
	// to the stored value when it sets a new element:
	class CMungeMapStringToPtr : public CMapStringToPtr
	{
	public:
		// Okay, the way this works is that the usua CMapXXXtoXXX
		// [] oparator returns a pointer to the key in the new
		// CAssoc it has created.  We calcualte the offset between
		// the key and the value and use that to get the address
		// of the value itself.  Yes, this is a GIGA-hack, but the
		// CSlob property bag stuff uses the same principle.  So sue me.
		 
		inline CString *GetStringAddressFromPtr ( void *& rvoid )
		{
		return (CString *) ( ( (BYTE *) &rvoid) - 
							 ( (BYTE *) &((CAssoc *) 0)->value )
	 						+( (BYTE *) &((CAssoc *) 0)->key   ) );
		}
		inline CString *SetAtAndReturnStringAddress (	
										const char* key 
										)
		{
		return GetStringAddressFromPtr ((*this)[key]);
		}

	};

	// We store the previosly seen names in a map which maps 
	// strings to pointers to void.  The void pointers are actually
	// pointers to CStrings which are values in anohter map which
	// contains Munged names we've previously used.  This allows
	// to quickly see if there is already a munged name for an
	// input string, and to see if a possible munged name has already
	// been used:
	CMapStringToPtr m_InMap;
	CMungeMapStringToPtr m_ResMap;

};

// CMak* builder component classes are declared here
#include "bldrcvtr.h"

//////////////////////////////////////////////////////////////////////
//
// Attributes of reading and writing of makefiles
#define MakRW_ShowStatus	0x1
#define MakR_IgnLineCont	0x2
#define MakW_Makefile		0x4
#define MakW_Depfile		0x8
#define MakRW_Default		MakRW_ShowStatus

//////////////////////////////////////////////////////////////////////
// CMakFileReader

#define MAK_EOF		((TCHAR)-1)

// Line prefix for indented lines ( e.g. "    " )
extern const TCHAR *szMkLineIndent;
extern const TCHAR cMkContinuation;

class  CMakFileReader : public CObject
{
private:
	// Local types

	enum { CCH_BUF = 512 };
	// Data

			CFile		m_file;
				// Current open file.
			ULONGLONG	m_nFileSize;

			UINT		m_nLineNum;
				// Current line number.

			TCHAR		m_rgchBuf[CCH_BUF];
				// Buffer for buffered I/O.

			UINT		m_ichBuf;
				// Index of next TCHAR in m_rgchBuf[].

			BOOL		m_fEOF;
				// TRUE if end-of-file has been reached, FALSE if not.

			UINT		m_cchFile;
				// Our count of chars through the file so far

			CObject	*	m_pUngotElement;

			int			m_nObjectsRead;

  			UINT		m_iAttrib;	// attributes of makefile reading

			UINT		m_nProgressGoal;
			static const int nStatusBarUpdate;

	// Read/write methods

			VOID		FillBuf();
				// Fills the buffer with up to CCH_BUF - 1 TCHARs from
				// the file.
				//
				// throw(CFileException)

	inline	TCHAR		GetChar()
						{
							if (m_rgchBuf[m_ichBuf] == _T('\0'))
								FillBuf();

							return(m_rgchBuf[m_ichBuf++]);
						}
				// Returns the next TCHAR.  If the TCHAR MAK_EOF is returned,
				// check m_fEOF to ensure an end-of-file condition.
				//
				// throw(CFileException)

	inline	TCHAR		PeekChar()
						{
							if (m_rgchBuf[m_ichBuf] == _T('\0'))
								FillBuf();

							return(m_rgchBuf[m_ichBuf]);
						}
				// Returns the next TCHAR without incrementing the index (i.e.,
				// a subsequent call to GetChar() will return the same TCHAR).
				// If the TCHAR MAK_EOF is returned, check m_fEOF to ensure an
				// end-of-file condition.
				//
				// throw(CFileException)

			BOOL		GetLine(CString &);
				// Fetches the next line into the referenced string.
				//
				// The resulting string does NOT have a trailing
				// carriage-return + linefeed pair.
				//
				// Returns TRUE if successful, FALSE at end-of-file.
				//
				// throw(CFileException)

			CObject *	ParseDirective(const CString &);
				// Parse the specified line as a directive and return
				// one of the following objects:
				//
				// CMakDirective
				// CMakError
				//
				// It is the caller's responsibility to free the object
				// returned.

			CObject *	ParseMacro(const CString &, int);
				// Parse the specified line as a macro definition and
				// return one of the following objects:
				//
				// CMakMacro
				// CMakError
				//
				// The INT parameter specifies the TCHAR offset within
				// the string of the '=' character which was found.
				//
				// The BOOL parameter specifies whether dependencies are
				// expected (yes for most things, no for build events).
				//
				// It is the caller's responsibility to free the object
				// returned.
				//
				// throw(CFileException)

			CObject *	ParseDescBlk(const CString &, int, BOOL);
				// Parse the specified line as the dependency line of a
				// description block and return one of the following
				// objects:
				//
				// CMakDescBlk
				// CMakError
				// CMakEndOfFile
				//
				// The INT parameter specifies the TCHAR offset within
				// the string of the ':' character which was found.
				//
				// It is the caller's responsibility to free the object
				// returned.
				//
				// throw(CFileException)

public:
	// Constructors, destructors

						CMakFileReader();
	virtual				~CMakFileReader();

	// Open and close methods

			BOOL		Open(
							 const TCHAR *, 
							 UINT, 
							 CFileException *,
							 UINT iAttrib = MakRW_Default
							);
				// Open the .MAK file for reading.  The first parameter
				// specifies the filename, and the second parameter specifies
				// the access mode as per the CFile constructor (e.g.,
				// CFile::modeRead).  The third parameter is a pointer to an
				// existing CFileException object, whose contents are meaningful
				// after the call only if this method returns FALSE.

				// Re-open the .MAK file for reading, ie. start reading from
				// beginning of file.
			void		ReOpen();

				// Attributes of makefile reading.
	__inline void		SetAttributes(UINT iAttrib) {m_iAttrib = iAttrib;}

				// Return the current line being read.
	__inline UINT		GetCurrentLine() {return m_nLineNum;}

				//  Abort after an exception:
			void		Abort(); 

			VOID		Close();

			CObject *	GetNextElement(BOOL bMustHaveOutputs = TRUE);
				// Get the next element of the .MAK file.  Returns one of:
				//
				// CMakComment
				// CMakMacro
				// CMakDescBlk
				// CMakDirective
				// CMakError
				// CMakEndOfFile
				//
				// cast to a CObject.  It is the caller's responbility to
				// free the resulting object.
				//
				// throw(CFileException)
			void UngetElement (CObject *);
				// Return an element to the read so that it will be 
				// used for the GetNextElementCall.  Depth is limited
				// to one.
};

#endif // __MAKREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\merced.h ===
//
// Merced (RISC) C/C++ AddOn
//
// Merced (RISC) Platform C/C++ Tools Component Add-On 'package'
//
// [kevinp]
//

#pragma once

// platforms, tools, option handlers provided by this module

// add-on's name
#define szAddOnMerced "Microsoft Merced (RISC) C/C++ v1.0"

// our 'Merced' build system components

#define BCID_Platform_Merced			5

#define BCID_OptHdlr_Compiler_Merced	520
#define BCID_OptHdlr_Linker_Merced	521

#define BCID_Tool_Compiler_Merced	540
#define BCID_Tool_Linker_Merced		541

#define BCID_ProjType_MercedExe		560
#define BCID_ProjType_MercedDll		561
#define BCID_ProjType_MercedCon		562
#define BCID_ProjType_MercedLib		563
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\mcdtoolc.cpp ===
//
// MERCED (RISC) Compiler Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "mcdtoolc.h"	// our local header file

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CCCompilerMercedTool, CCCompilerNTTool)

CCCompilerMercedTool::CCCompilerMercedTool() : CCCompilerNTTool()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\mips.h ===
//
// MIPS (RISC) C/C++ AddOn
//
// MIPS (RISC) Platform C/C++ Tools Component Add-On 'package'
//
// [matthewt]
//

// platforms, tools, option handlers provided by this module

// add-on's name
#define szAddOnMips "Microsoft MIPS C/C++ v1.0"

// our 'Mips' build system components

#define BCID_Platform_Mips			2

#define BCID_OptHdlr_Compiler_Mips	220
#define BCID_OptHdlr_Linker_Mips	221

#define BCID_Tool_Compiler_Mips		240
#define BCID_Tool_Linker_Mips		241

#define BCID_ProjType_MipsExe		260
#define BCID_ProjType_MipsDll		261
#define BCID_ProjType_MipsCon		262
#define BCID_ProjType_MipsLib		263
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnbsc.cpp ===
// 
// Browser Database Make Tool Options and Tool
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop

#include "optnbsc.h"	// our local header file
#include "project.h"

BEGIN_OPTSTR_TABLE(BscMake, P_BscMakeUnknownOption, P_BscMakeUnknownString, P_BscMakeUnknownOption, P_BscMakeNoLogo, TRUE)
	IDOPT_BSCMAKE_NOLOGO,	"nologo%T1",		OPTARGS1(P_BscMakeNoLogo),				single,
	IDOPT_BSCMAKE_INCUNREF,	"Iu%T1",			OPTARGS1(P_InclUnref),					single,
	IDOPT_BSCMAKE_OUTNAME,	"o%1",				OPTARGS1(P_BscMakeOutputFilename),		single,
	IDOPT_UNKNOWN_OPTION,	"",					NO_OPTARGS,								single,
	IDOPT_UNKNOWN_STRING,	"",					NO_OPTARGS,								single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(BscMake)
	OPTDEF_PATH(BscMakeOutputFilename, "")
	OPTDEF_BOOL(InclUnref, FALSE)
	OPTDEF_BOOL(BscMakeNoLogo, FALSE)
END_OPTDEF_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CBscmakeTool, CSchmoozeTool)

// bscmake tool option default map 'faking'

BOOL OLD_OPTION_HANDLER(BscMake)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_BscMakeOutputFilename);
}

UINT OLD_OPTION_HANDLER(BscMake)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_BscMakeOutputFilename)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OLD_OPTION_HANDLER(BscMake)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	VSASSERT(idPropL == P_BscMakeOutputFilename, "Calling FormFakeStrProp with non-fake prop!");

	CString strBase, strOutDir;

    CProjItem * pItem = ((CProjItem *)m_pSlob);
	const CPath * ppathProj = pItem->GetProject()->GetFilePath();
	ppathProj->GetBaseNameString(strBase);

	// which output directory do we want to use?
	UINT idOutDirProp = GetFakePathDirProp(idProp);
	VSASSERT(idOutDirProp != (UINT)-1, "Failed to get proper fake path dir!");

	GPT gptVal = m_pSlob->GetStrProp(idOutDirProp, strOutDir);
	VSASSERT(gptVal == valid, "Failed to pick up idOutDirProp!");

	strVal = "";

	if (!strOutDir.IsEmpty())
	{
		TCHAR * pchStart;
		TCHAR * pchLast;

		strVal = strOutDir;

		// Ensure the copied output directory string ends in a backslash.
		pchStart = (TCHAR *)(const TCHAR *)strVal;
		pchLast = pchStart + strVal.GetLength();
		pchLast = _tcsdec(pchStart, pchLast);

		if (*pchLast != _T('/') && *pchLast != _T('\\'))
			strVal += _T('/');
	}

	strVal += strBase;
	strVal += _T(".bsc");
}

GPT OLD_OPTION_HANDLER(BscMake)::GetDefStrProp(UINT idProp, CString & val)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_BscMakeOutputFilename)
	{
		FormFakeStrProp(idProp, val);
		return valid;
	}

	return COptionHandler::GetDefStrProp(idProp, val);
}

void OLD_OPTION_HANDLER(BscMake)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// do we need special processing?
	if (idPropL == P_BscMakeOutputFilename)
	{
		CProjItem * pItem = (CProjItem *)m_pSlob;

		if (strVal.IsEmpty())
			pItem->GetPropBag()->RemovePropAndInform(idProp, m_pSlob);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CBscmakeTool
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

CBscmakeTool::CBscmakeTool() : CSchmoozeTool()
{
	// tool exe name and input file set
	m_strToolInput = _TEXT("*.sbr");
	m_strToolPrefix = _TEXT("BSC32");
	m_strName = _T("BSC");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnbsc.h ===
//
// Browser Database Make Tool Options and Tool
//

#pragma once

#include "schmztl.h"			// the CSchmoozeTool class

//----------------------------------------------------------------
// our COMMON bscmake option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	BscMake, /* name */
	szAddOnGeneric, BCID_OptHdlr_BscMake, /* generic bscmake option handler */
	szAddOnGeneric, BCID_Tool_BscMake /* generic bscmake tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// return a 'fake' string/int prop
	virtual GPT GetDefStrProp(UINT idProp, CString & val);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// handle setting of option string props
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal);

private:
	// form a 'fake' string prop
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);

END_OPTHDLR()

class CBscmakeTool : public CSchmoozeTool
{
	DECLARE_DYNAMIC (CBscmakeTool)

public:
	CBscmakeTool();
};

// bscmake tool properties
#define P_BscMakeUnknownOption				0x0000
#define P_BscMakeUnknownString				0x0001
#define P_BscMakeOutputFilename				0x0002
#define P_InclUnref							0x0003
#define P_BscMakeNoLogo						0x0004

// bscmake tool options (option ids)
#define IDOPT_BSCMAKE_OUTNAME				IDOPT_BASE + 0
#define IDOPT_BSCMAKE_INCUNREF				IDOPT_BASE + 1
#define IDOPT_BSCMAKE_NOLOGO				IDOPT_BASE + 2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnlib.h ===
//
// Library Manager Tool Options and Tool
//

#pragma once

//----------------------------------------------------------------
// our COMMON lib option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	Lib, /* name */
	szAddOnGeneric, BCID_OptHdlr_Lib, /* generic library manager option handler */
	szAddOnGeneric, BCID_Tool_Lib /* generic library manager tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// return a 'fake' string prop
	virtual GPT GetDefStrProp(UINT idProp, CString & strVal);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

private:
	// called whenever a prop has changed
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal);

	// form a 'fake' string prop
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);

END_OPTHDLR()

// lib tool properties

#include "optnlink.h"

#define P_LibUnknownString				0x0000
#define P_LibUnknownOption				0x0001
#define P_NoLogoLib						0x0002
#define P_OutNameLib					0x0003
#define P_DefNameLib					0x0004
#define P_Lib_Input_Ext					0x0005

// lib tool options (option ids)
#define IDOPT_OUTLIB					IDOPT_BASE + 0
#define IDOPT_DEFLIB					IDOPT_BASE + 1
#define IDOPT_LIBNOLOGO					IDOPT_BASE + 2
#define IDOPT_LIB_INPUT_EXT				IDOPT_BASE + 3

///////////////////////////////////////////////////////////////////////////////
// CLibTool is derived from CLinkerTool. There are only minor differences
// such as different option handler, name of tool etc.
///////////////////////////////////////////////////////////////////////////////

class  CLibTool : public CLinkerTool
{
	DECLARE_DYNAMIC (CLibTool)

public:
	CLibTool();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnlink.cpp ===
// 
// Linker Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop

#include "optnlink.h"	// our local header file
#include "project.h"

BEGIN_OPTSTR_TABLE(LinkerCommon, P_LinkUnknownOption, P_LinkUnknownString, P_LinkNoLogo, P_PreventBind, FALSE)
	IDOPT_UNKNOWN_STRING,	"",							NO_OPTARGS,								single,
	IDOPT_LINKNOLOGO,	"nologo%T1",					OPTARGS1(P_LinkNoLogo),					single,
	IDOPT_DERIVED_OPTHDLR,	"",							NO_OPTARGS,								single,
	IDOPT_LINKVERBOSE,	"verbose%T1",					OPTARGS1(P_LinkVerbose), 				single,
	IDOPT_DLLGEN,		"dll%T1",						OPTARGS1(P_GenDll),						single,
	IDOPT_PROFILE,		"profile%T1",					OPTARGS1(P_Profile),					single,
	IDOPT_USEPDBNONE,	"pdb:none%F1",					OPTARGS1(P_UsePDB),						single,
	IDOPT_INCREMENTALLINK, "incremental:%{no|yes}1",	OPTARGS1(P_IncrementalLink),			single,
	IDOPT_USEPDB,		"pdb:%T1%2",					OPTARGS2(P_UsePDB, P_UsePDBName),		single,
	IDOPT_MAPGEN,		"m[ap]%T1[:%2]",				OPTARGS2(P_GenMap, P_MapName), 			single,
	IDOPT_DEBUG,		"debug%T1",						OPTARGS1(P_GenDebug),					single,
	IDOPT_DEBUGTYPE,	"debugtype:%{cv|coff|both}1",	OPTARGS1(P_DebugType),					single,
	IDOPT_MACHINETYPE, 	"machine:%{I386|IX86|M68K|ALPHA|MPPC}1",	OPTARGS1(P_MachineType),	single,
	IDOPT_NODEFAULTLIB,	"nod[efaultlib]:%1",			OPTARGS1(P_NoDefaultLibs),			multiple,
	IDOPT_EXALLLIB,		"nod[efaultlib]%T1",			OPTARGS1(P_ExAllLibs),				single,
	IDOPT_INCLUDESYM,	"include:%1",					OPTARGS1(P_IncludeSym),					multiple,
	IDOPT_DEFNAME,		"def:%1",						OPTARGS1(P_DefName),					single,
	IDOPT_FORCE,		"force%T1",						OPTARGS1(P_Force),						single,
	IDOPT_OUT,			"out:%1",						OPTARGS1(P_OutName),					single,	
	IDOPT_IMPLIB,		"implib:%1",					OPTARGS1(P_ImpLibName),					single,
	IDOPT_LAZYPDB,		"pdbtype:%{sept|con}1",			OPTARGS1(P_LazyPdb),					single,
	IDOPT_LIBPATH,		"libpath:%1",					OPTARGS1(P_LibPath),					multiple,
	IDOPT_DELAY_NOBIND,	"delay:nobind%T1",				OPTARGS1(P_LinkDelayNoBind),			single,	
	IDOPT_DELAY_UNLOAD,	"delay:unload%T1",				OPTARGS1(P_LinkDelayUnLoad),			single,	
	IDOPT_DELAY_LOAD_DLL,"delayload:%1",				OPTARGS1(P_LinkDelayLoadDLL),			multiple,
	IDOPT_LINKER_INPUT_EXT, "",							OPTARGS1(P_Linker_Input_Ext),			single,	
	IDOPT_RESONLY_DLL,	"noentry%T1",					OPTARGS1(P_ResOnlyDLL),					single,
	IDOPT_VIRTUAL_DEVICE_DRIVER,	"vxd%T1",			OPTARGS1(P_VirtualDeviceDriver),		single,
	IDOPT_EXE_DYNAMIC,	"exetype:dynamic%T1",			OPTARGS1(P_ExeDynamic),					single,
	IDOPT_DRIVER,		"driver%{:junk||:uponly|:wdm}1",OPTARGS1(P_Driver),						single,
	IDOPT_50COMPAT,		"link50compat%T1",				OPTARGS1(P_Link50Compat),				single,
	IDOPT_ALIGN,		"align:%1",						OPTARGS1(P_Align),						single,
	IDOPT_SET_CHECKSUM,	"release%T1",					OPTARGS1(P_SetCheckSum),				single,
	IDOPT_MERGE_SECTIONS,	"merge:%1",					OPTARGS1(P_MergeSections),				single,
	IDOPT_ORDER_FUNCS,	"order:%1",						OPTARGS1(P_OrderFuncs),					single,
	IDOPT_TRIM_PROC_MEM, "ws:aggressive%T1",			OPTARGS1(P_TrimProcMem),				single,
	IDOPT_LARGEADDRESS,	"largeaddressaware%{:no|}1",	OPTARGS1(P_LargeAddress),				single,
	IDOPT_FIXED,		"fixed%{:no|}1",				OPTARGS1(P_Fixed),						single,
	IDOPT_EXE_BASE,		"base:%1",						OPTARGS1(P_BaseAddr),					single,
	IDOPT_PREVENT_BIND,	"allowbind%{|:no}1",			OPTARGS1(P_PreventBind),				single,
	IDOPT_UNKNOWN_OPTION,	"",							NO_OPTARGS,								single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerCommon)
	OPTDEF_BOOL(LinkNoLogo, FALSE)
	OPTDEF_BOOL(LinkVerbose, FALSE)
	OPTDEF_BOOL(GenDll, FALSE)
	OPTDEF_BOOL(GenMap, FALSE)
	OPTDEF_PATH(MapName, "")
	OPTDEF_PATH(OutName, "")
	OPTDEF_BOOL(GenDebug, FALSE)
	OPTDEF_INT(DebugType, 1)
	OPTDEF_BOOL(ExAllLibs, FALSE) 
	OPTDEF_LIST(NoDefaultLibs, "")
	OPTDEF_LIST(IncludeSym, "")
	OPTDEF_PATH(DefName, "")
	OPTDEF_BOOL(UsePDB, TRUE)
	OPTDEF_BOOL(IncrementalLink, TRUE)
	OPTDEF_BOOL(LinkDelayNoBind, FALSE)
	OPTDEF_BOOL(LinkDelayUnLoad, FALSE)
	OPTDEF_LIST(LinkDelayLoadDLL, "")
	OPTDEF_PATH(UsePDBName, "")
	OPTDEF_BOOL(Force, FALSE)
	OPTDEF_PATH(ImpLibName, "")
	OPTDEF_BOOL(Profile, FALSE)
	OPTDEF_INT(MachineType, 2)
	OPTDEF_INT(IgnoreExportLib, 0)
	OPTDEF_LIST(LibPath, "")
	OPTDEF_INT(LazyPdb, 0)
	OPTDEF_STRING(Linker_Input_Ext, "*.obj")
	OPTDEF_BOOL(ResOnlyDLL, FALSE)
	OPTDEF_BOOL(VirtualDeviceDriver, FALSE)
	OPTDEF_BOOL(ExeDynamic, FALSE)
	OPTDEF_INT(Driver, 0)
	OPTDEF_BOOL(Link50Compat, FALSE)
	OPTDEF_INT(Align, 0)
	OPTDEF_BOOL(SetCheckSum, FALSE)
	OPTDEF_STRING(MergeSections, "")
	OPTDEF_STRING(OrderFuncs, "")
	OPTDEF_BOOL(TrimProcMem, FALSE)
	OPTDEF_INT(LargeAddress, 0)
	OPTDEF_INT(Fixed, 0)
	OPTDEF_STRING(BaseAddr, "")
	OPTDEF_BOOL(PreventBind, FALSE)
END_OPTDEF_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CSchmoozeTool, CBuildTool)
IMPLEMENT_DYNAMIC(CLinkerTool, CSchmoozeTool)
IMPLEMENT_DYNAMIC(CLinkerNTTool, CLinkerTool)

// linker tool option default map 'faking'
BOOL OLD_OPTION_HANDLER(LinkerCommon)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_MapName || idPropL == P_OutName ||
			idPropL == P_ImpLibName || idPropL == P_UsePDBName ||
			idPropL == P_IgnoreExportLib || idPropL == P_IncrementalLink || 
			idPropL == P_Linker_Input_Ext);
}

UINT OLD_OPTION_HANDLER(LinkerCommon)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_MapName)
		return P_OutDirs_Intermediate;

	// .exe, .lib, .pdb use the target directory
	else if (idPropL == P_OutName || idPropL == P_ImpLibName || idPropL == P_UsePDBName)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OLD_OPTION_HANDLER(LinkerCommon)::OnOptionIntPropChange(UINT idProp, int nVal)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_GenDll)
		m_pSlob->InformDependants(MapLogical(P_OutName));
}

BOOL OLD_OPTION_HANDLER(LinkerCommon)::AlwaysShowDefault(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_UsePDB || idPropL == P_MachineType);
}

BOOL OLD_OPTION_HANDLER(LinkerCommon)::IsDefaultStringProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_OutName || idPropL == P_ImpLibName)
	{
		CString strFake;
		if (idPropL == P_OutName || idPropL == P_ImpLibName)
		{	// both 'foobar.exe' and 'foobar.dll' are defaults!
			GPT gptVal = m_pSlob->GetIntProp(MapLogical(P_GenDll), m_fProjIsDll);
			VSASSERT(gptVal == valid, "Failed to pick up P_GenDll!");
		}

		FormFakeStrProp(idProp, strFake);
		if (strFake.CompareNoCase(strVal) == 0)
			return TRUE;

		if (idPropL == P_OutName)
		{
			m_fProjIsDll = !m_fProjIsDll;

			FormFakeStrProp(idProp, strFake);
			if (strFake.CompareNoCase(strVal) == 0)
				return TRUE;
		}

		// if we failed to match a faked prop, then is this a default in 
		// the 'default map'?
	}

	return COptionHandler::IsDefaultStringProp(idProp, strVal);
}

void OLD_OPTION_HANDLER(LinkerCommon)::FormFakeIntProp(UINT idProp, int & nVal)
{
	UINT idPropL = MapActual(idProp);

	// should not call this if it is not a fake property
	VSASSERT (IsFakeProp (idProp), "FormFakeIntProp called with non-fake prop!");

	// the default value of Incremental Link depends whether
	// it is a 'debug' or 'release' mode
	if (idPropL == P_IncrementalLink)
		if (m_pSlob->GetIntProp(P_UseDebugLibs, nVal) != valid) 
			nVal = FALSE;

	if (idPropL == P_IgnoreExportLib){
		nVal = TRUE;
		if( m_pSlob->GetIntProp(P_Proj_IgnoreExportLib, nVal) == invalid ){
			if (m_pSlob->GetIntProp(MapLogical(P_GenDll), nVal) == invalid )	// /DLL must be set
				nVal = TRUE;
			else
				nVal = FALSE;
		}
	}
}

GPT OLD_OPTION_HANDLER(LinkerCommon)::GetDefIntProp(UINT idProp, int & nVal)
{
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefIntProp(idProp, nVal);

	FormFakeIntProp(idProp, nVal);
	return valid;
}

void OLD_OPTION_HANDLER(LinkerCommon)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// Assert this a Linker 'fake' string prop?
	VSASSERT(IsFakeProp(idProp), "FormFakeStrProp called with non-fake prop!");

	if (idPropL == P_Linker_Input_Ext)
	{
		strVal = "";	// don't care about this prop during conversion...
		return;
	}

	// form the other fake string props...

	// get the project base-name (ie. without extension)
	CString strBase;

    // If we are faking the output name then we use the projects base-name
    // (without extension) as the basis of the faked name.
    // If we are faking the map name, pdb name, or implib name then we
    // use the base of the output name as the basis of the faked name.
    if (idPropL == P_OutName)
	{
        CProjItem * pItem = ((CProjItem *)m_pSlob);
		const CPath * ppathProj = pItem->GetProject()->GetFilePath();
		ppathProj->GetBaseNameString(strBase);
	}
    else
	{
		CString strPath;
		if (m_pSlob->GetStrProp(MapLogical(P_OutName), strPath) != valid)
			GetDefStrProp(MapLogical(P_OutName), strPath);
	  	
		CPath path;
	 	if (path.Create(strPath))
			path.GetBaseNameString(strBase);
	}

	// which output directory do we want to use?
	UINT idOutDirProp = GetFakePathDirProp(idProp);
	VSASSERT(idOutDirProp != (UINT)-1, "Failed to get proper fake path dir!");

	CString strOut;
	GPT gptVal = m_pSlob->GetStrProp(idOutDirProp, strOut);
	VSASSERT(gptVal == valid, "Failed to pick up idOutDirProp!");

	const TCHAR * pchT;
	strVal = "";

	// If the output directory doesn't end in a forward slash
	// or a backslash, append one.
	if (!strOut.IsEmpty())
	{
		strVal = strOut;

		pchT = (const TCHAR *)strVal + strVal.GetLength();
		pchT = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchT);

		if (*pchT != _T('/') && *pchT != _T('\\'))
			strVal += _T('/');
	}

	// Add the base, and extension prefix
	strVal += strBase;
	strVal += _T('.');

	// Append the extension
	CString strExt;
	if (idPropL == P_MapName)
	{
		strExt = _TEXT("map");
	}
	else if (idPropL == P_OutName || idPropL == P_ImpLibName || idPropL == P_UsePDBName)
	{
		if (idPropL == P_ImpLibName)
		{
			strExt = _TEXT("lib");
		}
		else if (idPropL == P_UsePDBName)
		{
			strExt = _TEXT("pdb");
		}
		else
		{
			// can we get a supplied default target extension?
			if (!m_pSlob->GetStrProp(P_Proj_TargDefExt, strExt))
			{
				BOOL fOldProjIsDll = m_fProjIsDll;
				if (m_pSlob->GetIntProp(MapLogical(P_GenDll), m_fProjIsDll) != valid)
					m_fProjIsDll = fOldProjIsDll;
				strExt = (m_fProjIsDll ? _TEXT("dll") : _TEXT("exe"));	// no
			}
		}
	}
	else	
	{
		VSASSERT(FALSE, "Unhandled FormFakeStrProp case!");
	}

	strVal += strExt;
}

GPT OLD_OPTION_HANDLER(LinkerCommon)::GetDefStrProp(UINT idProp, CString & val)
{
	UINT idPropL = MapActual(idProp);

	BOOL fIgnoreFake = FALSE;

	// we don't have ImpLibName with no /DLL
	if (idPropL == P_ImpLibName)
	{
		int nVal;
		if (m_pSlob->GetIntProp(MapLogical(P_GenDll), nVal) == invalid || !nVal)	// /DLL must be set
			fIgnoreFake = TRUE;	// not a faked prop in this context
	}
	
	// can we ignore the output directories?
	if (fIgnoreFake || !IsFakeProp(idProp))
		return COptionHandler::GetDefStrProp(idProp, val);

	FormFakeStrProp(idProp, val);
	return valid;
}

BOOL OLD_OPTION_HANDLER(LinkerCommon)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	BOOL fValid = TRUE;			// valid by default
	GPT gptVal = valid;
	
	// placeholders for values
	int nVal, nVal2;	
	CPlatform * pPlatform ;

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// Incremental not valid if request to generate a Map
		case P_IncrementalLink:
			pPlatform = g_pActiveProject->GetCurrentPlatform() ;
			if (pPlatform->GetAttributes() & PIA_Supports_IncLink)
			{
				(void) m_pSlob->GetIntProp(MapLogical(P_UsePDB), nVal) ;
				(void) m_pSlob->GetIntProp (MapLogical(P_Profile), nVal2) ;
				fValid = nVal && !nVal2;
			}
			else
				fValid = FALSE ;
			break;
		// Use PDB not valid if Profiling is checked 
		case P_UsePDB:
			(void) m_pSlob->GetIntProp (MapLogical(P_Profile), nVal) ;
			fValid = !nVal ;
			break ;

		// Generate Mapfile must be disabled if Profile is checked
		case P_GenMap:
			//(void)m_pSlob->GetIntProp (MapLogical(P_Profile), nVal) ;
			fValid = TRUE;
			break ;

		// Can only type map-name if generating a mapfile!
		case P_MapName:
			(void) m_pSlob->GetIntProp(MapLogical(P_GenMap), nVal);
			fValid = nVal;
			break;

		// Can't specify the debug info type if not gen. debug info
		case P_DebugType:
			(void) m_pSlob->GetIntProp(MapLogical(P_GenDebug), nVal);
			pPlatform = g_pActiveProject->GetCurrentPlatform() ;
			if (pPlatform->GetAttributes() & PIA_Enable_AllDebugType)
				fValid = nVal;
			else
				 fValid = FALSE;
			break;

		// Not allowed to type in a .PDB name without use PDB file
		case P_UsePDBName:
			gptVal = m_pSlob->GetIntProp(MapLogical(P_UsePDB), nVal);
			VSASSERT(gptVal == valid, "Failed to pick up P_UsePDB!");
			(void) m_pSlob->GetIntProp(MapLogical(P_Profile), nVal2) ;
			fValid = nVal && !nVal2;
			break;
		// not allowed to select lazy pdb unless pdb in use
		case P_LazyPdb:
			gptVal = m_pSlob->GetIntProp(MapLogical(P_UsePDB), nVal);
			VSASSERT(gptVal == valid, "Failed to pick up P_UsePDB!");
			(void) m_pSlob->GetIntProp(MapLogical(P_Profile), nVal2) ;
			fValid = nVal && !nVal2;
			break;
	/*
		case P_StubName:
			pPlatform = g_pActiveProject->GetCurrentPlatform();
			if (pPlatform->GetAttributes() & PIA_Enable_Stub)
				fValid = TRUE;
			else
				fValid = FALSE;
			break;
	*/
		default:
			break;
	}

	return fValid;
}

//------------------------------------------------------
// NT linker option handler
//------------------------------------------------------

BEGIN_OPTSTR_TABLE(LinkerNT, (UINT)NULL, (UINT)NULL, P_VersionMaj, P_HeapCommit, FALSE)
	IDOPT_DERIVED_OPTHDLR,	"",							NO_OPTARGS,								single,
	IDOPT_VERSION,		"version:%1[.%2]",				OPTARGS2(P_VersionMaj, P_VersionMin),	single,
	IDOPT_STACK,		"st[ack]:%1[,%2]",				OPTARGS2(P_StackReserve, P_StackCommit),single,
	IDOPT_ENTRYPOINT,	"entry:%1",						OPTARGS1(P_EntryName),					single,
	IDOPT_SUBSYSTEM,	"subsystem:%{windows|console}1",OPTARGS1(P_SubSystem),					single,
	IDOPT_HEAP,			"heap:%1[,%2]",					OPTARGS2(P_HeapReserve, P_HeapCommit),	single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerNT)
	OPTDEF_INT(VersionMaj, -1)	// no default
	OPTDEF_INT(VersionMin, -1)	// no default
	OPTDEF_HEX(StackReserve, 0)
	OPTDEF_HEX(StackCommit, 0)
	OPTDEF_HEX(HeapReserve, 0)
	OPTDEF_HEX(HeapCommit, 0)
	OPTDEF_STRING(EntryName, "")
	OPTDEF_INT(SubSystem, -1)	// no default
END_OPTDEF_MAP()

BOOL OLD_OPTION_HANDLER(LinkerNT)::AlwaysShowDefault(UINT idProp)
{
	return FALSE;	// none
}

BOOL OLD_OPTION_HANDLER(LinkerNT)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fValid = TRUE;			// valid by default

	// placeholders for values
	int nVal;

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// Stack Commit only enabled if Reserve size set
		case P_StackCommit:
			(void) m_pSlob->GetIntProp(MapLogical(P_StackReserve), nVal);
			fValid = (nVal != 0);	
			break;

		// Version Minor only enabled if Major version set
		case P_VersionMin:
		{
			CString strVal;
			(void) m_pSlob->GetStrProp(MapLogical(P_VersionMaj), strVal);
			fValid = (strVal != "");
			break;
	   	}

		default:
			break;
	}

	return fValid;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// CLinkerTool
///////////////////////////////////////////////////////////////////////////////////////////////////

CLinkerTool::CLinkerTool() : CSchmoozeTool()
{
	m_strToolInput = _TEXT("*.obj;*.res;*.lib;*.rsc");
	m_strToolPrefix = _TEXT("LINK32");
	m_strName = _TEXT("link.exe");
}
///////////////////////////////////////////////////////////////////////////////
BOOL CLinkerTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// CLinkerNTTool
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CLinkerNTTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	COptionHandler * pOptionHandler = GetOptionHandler();
	VSASSERT(pOptionHandler != (COptionHandler *)NULL, "Missing option handler for the linker!");

	CString strLibs; COptionList optlstLibs(_T(' '), FALSE);

	// libraries that are C++ and FORTRAN
	// make sure we add/remove those Core Windows .libs the MFC headers auto-include
	BOOL bOK = strLibs.LoadString(IDS_WIN32_LIBS_CORE);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	optlstLibs.SetString(strLibs);
	VCPOSITION pos = optlstLibs.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
		// add these libs if we are not using MFC
 		pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);	// these libraries are C++ only

	// make sure we add/remove those Windows .libs the MFC headers auto-include
	bOK = strLibs.LoadString(IDS_WIN32_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	optlstLibs.SetString(strLibs);
	pos = optlstLibs.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
		// add these libs if we are not using MFC
 		pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);

	// make sure we add/remove those Windows OLE2 .libs the MFC headers auto-include
	bOK = strLibs.LoadString(IDS_OLE2_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	optlstLibs.SetString(strLibs);
	pos = optlstLibs.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
		// add these libs if we are not using MFC
 		pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos), iUseMFC == NoUseMFC);

	// does this target's platform support ODBC?
	CProjType * pProjType = pProjItem->GetProject()->GetProjType();
	VSASSERT(pProjType != (CProjType *)NULL, "Unsupported projec type!");
	BOOL fSupportsODBC = pProjType->GetPlatform()->SupportsODBC();

	// make sure we add/remove those Windows ODBC .libs the MFC headers auto-include
	bOK = strLibs.LoadString(IDS_ODBC_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	optlstLibs.SetString(strLibs);
	pos = optlstLibs.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
		// add these libs if we are not using MFC
 		pOptionHandler->MungeListStrProp(MapLogical(P_LinkUnknownString), optlstLibs.GetNext(pos),
 										 iUseMFC == NoUseMFC && fSupportsODBC);

	return CLinkerTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnlib.cpp ===
// 
// Library Manager Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop

#include "optnlib.h"	// our local header file
#include "project.h"

BEGIN_OPTSTR_TABLE(Lib, P_LibUnknownOption, P_LibUnknownString, P_LibUnknownString, P_Lib_Input_Ext, FALSE)
	IDOPT_UNKNOWN_STRING,	"",					NO_OPTARGS,								single,
	IDOPT_LIBNOLOGO,		"nologo%T1",		OPTARGS1(P_NoLogoLib),					single,
	IDOPT_DERIVED_OPTHDLR,	"",					NO_OPTARGS,								single,
	IDOPT_DEFLIB,			"def:%1", 			OPTARGS1(P_DefNameLib),					single,
	IDOPT_OUTLIB,			"out:%1",			OPTARGS1(P_OutNameLib),					single,	
	IDOPT_LIB_INPUT_EXT,	"",					OPTARGS1(P_Lib_Input_Ext),				single,	
	IDOPT_UNKNOWN_OPTION,	"",					NO_OPTARGS,								single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(Lib)
	OPTDEF_BOOL(NoLogoLib, FALSE);
	OPTDEF_PATH(DefNameLib, "")
	OPTDEF_PATH(OutNameLib, "")
	OPTDEF_STRING(Lib_Input_Ext, "*.obj")
END_OPTDEF_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CLibTool, CLinkerTool)

void OLD_OPTION_HANDLER(Lib)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_OutNameLib)
	{
 		if (strVal.IsEmpty())
			m_pSlob->GetPropBag()->RemovePropAndInform(MapLogical(P_OutNameLib), m_pSlob);
		m_pSlob->InformDependants(P_ProjItemFullPath);
		m_pSlob->InformDependants(P_TargetName);
	}
}

// lib tool option default map 'faking'

BOOL OLD_OPTION_HANDLER(Lib)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_OutNameLib || idPropL == P_Lib_Input_Ext);
}

UINT OLD_OPTION_HANDLER(Lib)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_OutNameLib)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OLD_OPTION_HANDLER(Lib)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	if (m_pSlob == NULL)
		return;

	UINT idPropL = MapActual(idProp);

	// assert this a Library Manager 'fake' string prop?
	VSASSERT(IsFakeProp(idProp), "FormFakeStrProp called with non-fake prop!");

	// get the project base-name (ie. without extension)
	CString strBase;
    CProjItem * pItem = ((CProjItem *)m_pSlob);

	if (idPropL == P_Lib_Input_Ext)
	{
		// make sure the project is in our config.
		CProjTempConfigChange projTempConfigChange(pItem->GetProject());
		projTempConfigChange.ChangeConfig((CConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord);

		CConfigurationRecord * pcr = (CConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord;
		CString strToolName = _T("lib.exe");
		CString strExtList = _T("");
		pcr->GetExtListFromToolName(strToolName, &strExtList);
		if(strExtList)
		{
			strVal = strExtList;
		}
		return;

	}

	const CPath * ppathProj = pItem->GetProject()->GetFilePath();
	ppathProj->GetBaseNameString(strBase);

	strVal = "";

	// do we need to know about the target directory?
	if (idPropL == P_OutNameLib)
	{
		const TCHAR * pchT;
	 	CString strOut;

		// which output directory do we want to use?
		UINT idOutDirProp = GetFakePathDirProp(idProp);
		VSASSERT(idOutDirProp != (UINT)-1, "Failed to get proper fake path dir!");

		GPT gptVal = m_pSlob->GetStrProp(idOutDirProp, strOut);
		VSASSERT(gptVal == valid, "Failed to pick up idOutDirProp!");

		if (!strOut.IsEmpty())
		{
			strVal = strOut;

			// If the output directory doesn't end in a forward slash
			// or a backslash, append one.

			pchT = (const TCHAR *)strVal + strVal.GetLength();
			pchT = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchT);

			if (*pchT != _T('/') && *pchT != _T('\\'))
				strVal += _T('\\');
		}


		// Add the base, and extension prefix
		strVal += strBase;
		strVal += _T('.');

		// Append the extension
		// can we get a supplied default target extension?
		CString strExt;
		if (!m_pSlob->GetStrProp(P_Proj_TargDefExt, strExt))
			strExt = _TEXT("lib");	// no

		strVal += strExt;
	}
	else
	{
		VSASSERT(FALSE, "Unhandled fake str prop case!");
	}
}

GPT OLD_OPTION_HANDLER(Lib)::GetDefStrProp(UINT idProp, CString & val)
{
	// can we ignore the output directories?
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefStrProp(idProp, val);

	FormFakeStrProp(idProp, val);
	return valid;
}

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------- CLibTool ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////
CLibTool::CLibTool() : CLinkerTool()
{
	// tool input file set
	m_strToolInput = _TEXT("*.obj;*.res;*.lib");
	m_strToolPrefix =  _TEXT ("LIB32");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optncplr.cpp ===
//
// Common Compiler Tool Options and Tool
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop

#include "optncplr.h"	// our local header file
#include "project.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CCCompilerTool, CBuildTool)
IMPLEMENT_DYNAMIC(CCCompilerNTTool, CCCompilerTool)

//----------------------------------------------------------------
// our COMMON compiler option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(CompilerCommon, P_CplrUnknownOption, P_CplrUnknownString, P_CplrNoLogo, P_COM_HresultKnowledge, TRUE)
	IDOPT_CPLRNOLOGO,		"nologo%T1",		OPTARGS1(P_CplrNoLogo),					single,
	IDOPT_DERIVED_OPTHDLR,	"",					NO_OPTARGS,								single,
	IDOPT_MSEXT,		"Z%{e|a}1",				OPTARGS1(P_MSExtension),				single,
	IDOPT_TURN_OFF_WARNINGS,	"w%<1>1",		OPTARGS1(P_WarningLevel),				single,
	IDOPT_WARN,			"W%{0|1|2|3|4}1",		OPTARGS1(P_WarningLevel), 				single,

	IDOPT_WARNASERROR,	"WX%T1",				OPTARGS1(P_WarnAsError),				single,
	IDOPT_ENABLE_MR,	"Gm%{-|}1",				OPTARGS1(P_Enable_MR),					single,
	IDOPT_ENABLE_INCR,	"Gi%{-|}1",				OPTARGS1(P_Enable_Incr),				single,
	IDOPT_PTRMBR1,		"vm%{b|g}1",			OPTARGS1(P_PtrMbr1),					single,
	IDOPT_PTRMBR2,		"vm%{v|s|m}1",			OPTARGS1(P_PtrMbr2),					single,
	IDOPT_VTORDISP,		"vd%{1|0}1",			OPTARGS1(P_VtorDisp),					single,
	IDOPT_ENABLE_RTTI,	"GR%{-|}1",				OPTARGS1(P_Enable_RTTI),				single,
/* temporarily reverse the logic for PDC (BamBam) 'cos the compiler default will be /GX- for this
** release .. ie. we need [X] Enable EH in the options dialog
	IDOPT_DISABLE_EH,	"GX%{|-}1",				OPTARGS1(P_Disable_EH),					single,
*/
	IDOPT_ENABLE_EH,	"GX%{-|}1",				OPTARGS1(P_Enable_EH),					single,
	IDOPT_DEBUGINFO,	"Z%{d|7|i|I}1",			OPTARGS1(P_DebugInfo),					single,
	IDOPT_OPTIMIZE,		"O%{d|2|1}1",			OPTARGS1(P_Optimize),					single,
	IDOPT_OPT_X,		"Ox%T1%<4>2",			OPTARGS2(P_Optimize_X, P_Optimize),		single,
	IDOPT_OPT_T,		"Ot%T1%<4>2",			OPTARGS2(P_Optimize_T, P_Optimize),		single,
	IDOPT_OPT_A,		"Oa%T1%<4>2",			OPTARGS2(P_Optimize_A, P_Optimize),		single,
	IDOPT_OPT_W,		"Ow%T1%<4>2",			OPTARGS2(P_Optimize_W, P_Optimize),		single,
	IDOPT_OPT_G,		"Og%T1%<4>2",			OPTARGS2(P_Optimize_G, P_Optimize),		single,
	IDOPT_OPT_I,		"Oi%T1%<4>2",			OPTARGS2(P_Optimize_I, P_Optimize),		single,
	IDOPT_OPT_S,		"Os%T1%<4>2",			OPTARGS2(P_Optimize_S, P_Optimize),		single,
	IDOPT_OPT_P,		"Op%{-|}1",				OPTARGS1(P_Optimize_P),					single,
	IDOPT_OPT_Y,		"Oy%{-|}1",				OPTARGS1(P_Optimize_Y),					single,
	IDOPT_INLINECTRL,	"Ob%{0|1|2}1",			OPTARGS1(P_InlineControl),				single,
	IDOPT_STRPOOL,		"G%{f|F}1",				OPTARGS1(P_StringPool),					single,
	IDOPT_INCLINK,		"Gy%T1",				OPTARGS1(P_IncLinking),					single,
	IDOPT_CPLRIGNINC,	"X%T1",					OPTARGS1(P_CplrIgnInCPath),				single,
	IDOPT_CPLRINCLUDES,	"I[ ]%1",				OPTARGS1(P_CplrIncludes),				multiple,
	IDOPT_FORCEINCLUDES,	"FI%1",				OPTARGS1(P_ForceIncludes),				multiple,
	IDOPT_UNDEFINE,		"u%T1",					OPTARGS1(P_Undefine),					single,
	IDOPT_MACROS,		"D[ ]%1",				OPTARGS1(P_MacroNames),					multiple,
	IDOPT_UNDEFMACROS,	"U[ ]%1",				OPTARGS1(P_UndefMacros),				multiple,
	IDOPT_LISTASM,		"FA%{%f1%f2|cs%t1%t2|c%t1%f2|s%f1%t2}3",	OPTARGS3(P_AsmListHasMC, P_AsmListHasSrc, P_ListAsm),						single,
	IDOPT_OUTDIR_COD,	"Fa%1",					OPTARGS1(P_OutputDir_Cod),				single,
	IDOPT_LISTBSCNOLCL,	"Fr%T1%t2[%3]",			OPTARGS3(P_GenBrowserInfo, P_GenBrowserInfoNoLcl, P_OutputDir_Sbr),	single,
	IDOPT_LISTBSC,		"FR%T1%f2[%3]",			OPTARGS3(P_GenBrowserInfo, P_GenBrowserInfoNoLcl, P_OutputDir_Sbr),	single,
	IDOPT_PCHNAME,		"Fp%1",					OPTARGS1(P_OutputDir_Pch),				single,
	IDOPT_AUTOPCH,		"YX%T1[%2]",			OPTARGS2(P_AutoPch, P_AutoPchUpTo),				single,
	IDOPT_PCHCREATE,	"Yc%T1[%2]",			OPTARGS2(P_PchCreate, P_PchCreateUptoHeader),	single,
	IDOPT_PCHUSE,		"Yu%T1[%2]",			OPTARGS2(P_PchUse, P_PchUseUptoHeader),			single,
	IDOPT_OUTDIR_OBJ,	"Fo%1",					OPTARGS1(P_OutputDir_Obj),				single,
	IDOPT_OUTDIR_PDB,	"Fd%1",					OPTARGS1(P_OutputDir_Pdb),				single,
	IDOPT_STACK_PROBE,	"Ge%T1",				OPTARGS1(P_StackProbe),					single,
	IDOPT_STACK_PROBE_THOLD,	"Gs%1",			OPTARGS1(P_StackProbeTHold),			single,
	IDOPT_MAXLEN_EXTNAME,		"H%1",			OPTARGS1(P_MaxLenExtNames),				single,
	IDOPT_USECHAR_AS_UNSIGNED,	"J%T1",			OPTARGS1(P_UseChasAsUnsigned),			single,
	IDOPT_EMBED_STRING,			"V%1",			OPTARGS1(P_EmbedString),				single,
	IDOPT_NO_DEFLIB_NAME,		"Zl%T1",		OPTARGS1(P_NoDefLibNameInObj),			single,
	IDOPT_PREP_COMMENTS,		"C%T1",			OPTARGS1(P_PrepPreserveComments),		single,
	IDOPT_PREPROCESS,			"E%T1",			OPTARGS1(P_Preprocess),					single,
	IDOPT_PREPROCESS_WO_LINES,	"EP%T1",		OPTARGS1(P_PreprocessWOLines),			single,
	IDOPT_ENABLE_FD,	"FD%{-|}1",				OPTARGS1(P_Enable_FD),					single,
	IDOPT_ENABLE_FC,	        "FC%T1",		OPTARGS1(P_Enable_FC),					single,
	IDOPT_COM_EmitMergedSource,	"Fx%T1",		OPTARGS1(P_COM_EmitMergedSource),       single,
	IDOPT_STACKSIZE,			"F%1",			OPTARGS1(P_StackSize),					single,
	IDOPT_ENABLE_DLP,			"dlp%{-|}1",	OPTARGS1(P_Enable_dlp),					single,
	IDOPT_PREPROCESS_TO_FILE,	"P%T1",			OPTARGS1(P_PrepprocessToFile),			single,
	IDOPT_GEN_FUNC_PROTO,		"Zg%T1",		OPTARGS1(P_GenFuncProto),				single,
	IDOPT_CHECK_SYNTAX,			"Zs%T1",		OPTARGS1(P_CheckSyntax),				single,
	IDOPT_UNKNOWN_OPTION,	"",					NO_OPTARGS,								single,
	IDOPT_UNKNOWN_STRING,	"",					NO_OPTARGS,								single,
	IDOPT_COMPILE_ONLY,	"c%T1",					OPTARGS1(P_CompileOnly),				single,
	IDOPT_TREATFILEAS_C1,	"Tc%T1",			OPTARGS1(P_TreatFileAsC1),				single,
	IDOPT_TREATFILEAS_C2,	"TC%T1",			OPTARGS1(P_TreatFileAsC2),				single,
	IDOPT_TREATFILEAS_CPP1,	"Tp%T1",			OPTARGS1(P_TreatFileAsCPP1),			single,	
	IDOPT_TREATFILEAS_CPP2,	"TP%T1",			OPTARGS1(P_TreatFileAsCPP2),			single,	
	IDOPT_CPP_INPUT_EXT,		"",				OPTARGS1(P_CPP_Input_Ext),				single,
	IDOPT_COM_HresultKnowledge,	"noHRESULT%{|-}1",	OPTARGS1(P_COM_HresultKnowledge),	single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(CompilerCommon)
	OPTDEF_BOOL(CplrNoLogo, FALSE)
	OPTDEF_BOOL(MSExtension, FALSE)
	OPTDEF_BOOL(IncLinking, FALSE)
	OPTDEF_INT(WarningLevel, 2)
	OPTDEF_BOOL(WarnAsError, FALSE)
	OPTDEF_INT(StringPool, 0)
	OPTDEF_INT(PtrMbr1, 1)
	OPTDEF_INT(PtrMbr2, 1)
	OPTDEF_BOOL(VtorDisp, FALSE)
	OPTDEF_BOOL(Enable_EH, FALSE)
	OPTDEF_BOOL(Enable_MR, FALSE)
	OPTDEF_BOOL(Enable_RTTI, FALSE)
	OPTDEF_BOOL(Enable_Incr, FALSE)
	OPTDEF_INT(DebugInfo, 0)
	OPTDEF_BOOL(AutoPch, FALSE)
	OPTDEF_PATH(AutoPchUpTo, "")
	OPTDEF_INT(Optimize, 0)
	OPTDEF_BOOL(Optimize_A, FALSE)
	OPTDEF_BOOL(Optimize_W, FALSE)
	OPTDEF_BOOL(Optimize_G, FALSE)
	OPTDEF_BOOL(Optimize_I, FALSE)
	OPTDEF_BOOL(Optimize_P, FALSE)
	OPTDEF_BOOL(Optimize_T, FALSE)
	OPTDEF_BOOL(Optimize_S, FALSE)
	OPTDEF_BOOL(Optimize_Y, FALSE)
	OPTDEF_BOOL(Optimize_X, FALSE)
	OPTDEF_INT(InlineControl, 1)
	OPTDEF_BOOL(Undefine, FALSE)
	OPTDEF_INT(ListAsm, 0)
	OPTDEF_BOOL(AsmListHasMC, FALSE)
	OPTDEF_BOOL(AsmListHasSrc, FALSE)
	OPTDEF_BOOL(GenBrowserInfoNoLcl, FALSE)
	OPTDEF_BOOL(GenBrowserInfo, FALSE)
	OPTDEF_BOOL(CplrIgnInCPath, FALSE)
	OPTDEF_LIST(MacroNames, "")
	OPTDEF_LIST(MacroValues, "")
	OPTDEF_LIST(UndefMacros, "")
	OPTDEF_LIST(CplrIncludes, "")
	OPTDEF_LIST(ForceIncludes, "")
	OPTDEF_PATH(OutputDir_Obj, "")
	OPTDEF_PATH(OutputDir_Pch, "")
	OPTDEF_PATH(OutputDir_Pdb, "")
	OPTDEF_PATH(OutputDir_Sbr, "")
	OPTDEF_PATH(OutputDir_Cod, "")
	OPTDEF_BOOL(PchCreate, FALSE)
	OPTDEF_PATH(PchCreateUptoHeader, "")
	OPTDEF_BOOL(PchUse, FALSE)
	OPTDEF_PATH(PchUseUptoHeader, "")
	OPTDEF_BOOL(TreatFileAsC1, FALSE)
	OPTDEF_BOOL(TreatFileAsC2, FALSE)
	OPTDEF_BOOL(TreatFileAsCPP1, FALSE)
	OPTDEF_BOOL(TreatFileAsCPP2, FALSE)
	OPTDEF_BOOL(CompileOnly, FALSE)
	// The following two props are not actually compiler flags, nor are they
	// accessible via the options dialogs.  They are present in the default
	// option table purely so that assumptions about these names are in one
	// place only.
	OPTDEF_PATH(PchDefaultName, "msvc.pch")
	OPTDEF_PATH(PdbDefaultName, "msvc.pdb")
	OPTDEF_BOOL(StackProbe, FALSE)
	OPTDEF_INT(StackProbeTHold, 4096)
	OPTDEF_INT(MaxLenExtNames, -1)
	OPTDEF_BOOL(UseChasAsUnsigned, FALSE)
	OPTDEF_STRING(EmbedString, "")
	OPTDEF_BOOL(NoDefLibNameInObj, FALSE)
	OPTDEF_BOOL(PrepPreserveComments, FALSE)
	OPTDEF_BOOL(Preprocess, FALSE)
	OPTDEF_BOOL(PreprocessWOLines, FALSE)
	OPTDEF_HEX(StackSize, -1)
	OPTDEF_BOOL(PrepprocessToFile, FALSE)
	OPTDEF_BOOL(GenFuncProto, FALSE)
	OPTDEF_BOOL(CheckSyntax, FALSE)
	OPTDEF_INT(PseudoPch, 1)
	OPTDEF_BOOL(Enable_FD, FALSE)
	OPTDEF_BOOL(Enable_FC, FALSE)
	// this option is an internal flag that is incompatible with /ZI
	OPTDEF_BOOL(Enable_dlp, FALSE)
	OPTDEF_STRING(CPP_Input_Ext, "*.cpp;*.c")
	OPTDEF_BOOL(COM_EmitMergedSource, FALSE)
	OPTDEF_BOOL(COM_HresultKnowledge, FALSE)
END_OPTDEF_MAP()

BOOL OLD_OPTION_HANDLER(CompilerCommon)::AlwaysShowDefault(UINT idProp)
{
	return FALSE;
}

// COMMON compiler tool option default map 'faking'

BOOL OLD_OPTION_HANDLER(CompilerCommon)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (
			idPropL == P_OutputDir_Obj ||
			idPropL == P_CPP_Input_Ext	   ||
			idPropL == P_OutputDir_Pch ||
			idPropL == P_OutputDir_Sbr ||
			idPropL == P_OutputDir_Pdb ||
			idPropL == P_OutputDir_Cod ||
			idPropL == P_PchDefaultName ||
			idPropL == P_PseudoPch
		   );
}

BOOL OLD_OPTION_HANDLER(CompilerCommon)::SetsFakePropValue(UINT idProp)
{
	VSASSERT(IsFakeProp(idProp), "Should only be called with fake props!");

	UINT idPropL = MapActual(idProp);
	switch (idPropL)
	{
	case P_PchDefaultName:
	case P_OutputDir_Pch:
		return FALSE;		// never defined at file level (no multiple .pch support)

	case P_OutputDir_Obj:
	case P_CPP_Input_Ext	:
	case P_OutputDir_Sbr:
	case P_OutputDir_Pdb:
	case P_OutputDir_Cod:
		// these are solely dependent on the output/target directory (which is checked
		// separately).
		return FALSE;
	}

	return TRUE;	// we don't know anything about this property
}

UINT OLD_OPTION_HANDLER(CompilerCommon)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	// our .pdb/.icc files are always in the target directory
	if (idPropL == P_OutputDir_Pdb)
		return P_OutDirs_Intermediate;

	// our .PCH files are always in the project-level intermediate directory
	// we'll make sure we use this level in ::FormFakeStrProp()
	else if (idPropL == P_OutputDir_Pch)
		return P_OutDirs_Intermediate;

	// all other files use the intermediate directory
	else if (idPropL == P_OutputDir_Obj || idPropL == P_OutputDir_Sbr || idPropL == P_OutputDir_Cod)
		return P_OutDirs_Intermediate;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OLD_OPTION_HANDLER(CompilerCommon)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	CPath pathFp, path;
	CDir dirFp;
	CString strDefName;

	// assert this is a compiler 'fake' string prop?
	VSASSERT(IsFakeProp(idProp), "FormFakeProp called with non-fake prop ID");

	// handle our default props
	if (idPropL == P_PchDefaultName)
	{
		// do we have /Fp, if so then just return this
		if (m_pSlob->GetStrProp(MapLogical(P_OutputDir_Pch), strVal) == invalid)
			strVal = "";	// dep. check caused invalid, default ""

		// is this empty or a directory?
		if (!strVal.IsEmpty())
		{
			const TCHAR * pchFp = (const TCHAR *)strVal + strVal.GetLength();
			pchFp = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchFp);

			if (*pchFp == _T('/') || *pchFp == _T('\\'))
			{
				if (COptionHandler::GetDefStrProp(idProp, strDefName) == invalid)
					strDefName = "";	// dep. caused invalid, default ""

				strVal += strDefName;
			}
		}

		return;	// we're done
	}


	// make sure the project is in our config.
	CProjItem * pItem = (CProjItem *)m_pSlob;
	CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	projTempConfigChange.ChangeConfig((CConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord);

	if (idPropL == P_CPP_Input_Ext)
	{
		CConfigurationRecord * pcr = (CConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord;
		CString strToolName = _T("cl.exe");
		CString strExtList = _T("");
		pcr->GetExtListFromToolName(strToolName, &strExtList);
		if(strExtList)
		{
			strVal = strExtList;
		}
		return;
	}

	// which output directory do we want to use?
	UINT idOutDirProp = GetFakePathDirProp(idProp);
	VSASSERT(idOutDirProp != (UINT)-1, "Failed to get proper fake path dir!");

	// the rest are output directory related
	// find one somewhere in the hierarchy

	
	// .pch uses project-level intermediate directory...
	// we can't use file-level because we don't have
	// support for multiple .pchs
	if (idPropL == P_OutputDir_Pch)
		pItem = pItem->GetProject();

	GPT gpt = pItem->GetStrProp(idOutDirProp, strVal);
	while (gpt != valid)
	{
		pItem = (CProjItem *)pItem->GetContainer();
		VSASSERT(pItem != (CSlob *)NULL, "Item's container is NULL!!!");
		gpt = pItem->GetStrProp(idOutDirProp, strVal);
	}

	// reset the project config.
	projTempConfigChange.Release();

	// Make sure this ends in a slash.
	if (!strVal.IsEmpty())
	{
		TCHAR * pchStart = strVal.GetBuffer(1);
		TCHAR * pchT;

		pchT = pchStart + _tcslen(pchStart);	// point to nul terminator
		pchT = _tcsdec(pchStart, pchT);			// back up one char, DBCS safe

		if (*pchT != _T('\\') && *pchT != _T('/'))
		{
			strVal.ReleaseBuffer();
			strVal += _T('/');
		}
	}

	// if we are /Fp (.pch) or /Fd (.pdb/.icc) then tag on the basename of the project
	if (idPropL == P_OutputDir_Pch)
	{
		VSASSERT(g_pActiveProject, "Active project not set!");
		CString strBase; 

        CProjItem * pItem = ((CProjItem *)m_pSlob);
		const CPath * ppathProj = pItem->GetProject()->GetFilePath();
		ppathProj->GetBaseNameString(strBase);

		strVal += strBase;
		strVal += _TEXT(".pch");
	}
}

GPT OLD_OPTION_HANDLER(CompilerCommon)::GetDefStrProp(UINT idProp, CString & val)
{
	UINT idPropL = MapActual(idProp);
	BOOL fIgnoreFake = FALSE;

	// we don't have OutputDir_Pdb with no /Zi or /Gi or /FD
	if (idPropL == P_OutputDir_Pdb)
	{
		int nVal;
		// N.B. 3 == /Zi
		if ((m_pSlob->GetIntProp(MapLogical(P_DebugInfo), nVal) == invalid || nVal < DebugInfoPdb) &&
			(m_pSlob->GetIntProp(MapLogical(P_Enable_Incr), nVal) == invalid || !nVal) &&
			(m_pSlob->GetIntProp(MapLogical(P_Enable_FD), nVal) == invalid || !nVal))
		{
			fIgnoreFake = TRUE;	// not a faked prop in this context
		}
	}

	// just return the intermediate output directory for these 'fakes'
	if (IsFakeProp(idProp))
	{
		FormFakeStrProp(idProp, val);
		return valid;
	}

	return COptionHandler::GetDefStrProp(idProp, val);
}

GPT OLD_OPTION_HANDLER(CompilerCommon)::GetDefIntProp(UINT idProp, int & val)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_Optimize_Y)
	{
		// default is /Oy with /Ox or /O2, and /Oy- otherwise
		int nVal;
		val = (m_pSlob->GetIntProp(MapLogical(P_Optimize_X), nVal) == valid && nVal) ||
			  (m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal) == valid && (nVal == 2));
		return valid;
	}
	else if (idPropL == P_Optimize_P)
	{
		// default is /Op with /Za, and /Op- otherwise
		int nVal;
		val = (m_pSlob->GetIntProp(MapLogical(P_MSExtension), nVal) == valid && nVal);
		return valid;
	}
	else if (idPropL == P_InlineControl)
	{
		// default is /Ob1 with /O2, /O1 and /Ox
		int nVal;
		val = (m_pSlob->GetIntProp(MapLogical(P_Optimize_X), nVal) == valid && nVal) ||
			  (m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal) == valid && (nVal == 2 || nVal == 3)) ? 2 : 1;
		return valid;
	}
	else if (idPropL == P_PseudoPch)
	{
		int nVal;
		if (m_pSlob->GetIntProp(MapLogical(P_PchCreate), nVal) == valid && nVal)
			val = 3;
		else if (m_pSlob->GetIntProp(MapLogical(P_PchUse), nVal) == valid && nVal)
			val = 4;
		else if (m_pSlob->GetIntProp(MapLogical(P_AutoPch), nVal) == valid && nVal)
			val = 2;
		else
			val = 1;

		return valid;
	}
	else if (idPropL == P_StringPool || idPropL == P_IncLinking)
	{
		// default is /Gy, /Gf for /O2 and /O1
		int nVal;
		val = (m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal) == valid && (nVal == 2 || nVal == 3));
		return valid;
	}

	return COptionHandler::GetDefIntProp(idProp, val);
}

void OLD_OPTION_HANDLER(CompilerCommon)::OnOptionIntPropChange(UINT idProp, int nVal)
{
	VSASSERT(m_pSlob != (CSlob *)NULL, "No slob associated with this option handler!");

	UINT idPropL = MapActual(idProp);
	int nCurrVal;

	// do we need special processing?
	switch (idPropL)
	{
		case P_ListAsm:
			// handle .asm file combinations
			m_pSlob->SetIntProp(MapLogical(P_AsmListHasMC), nVal == 2 || nVal == 3);
			m_pSlob->SetIntProp(MapLogical(P_AsmListHasSrc), nVal == 2 || nVal == 4);
			break;

		case P_PseudoPch:
			// ignore if the current property bag
			if (((CProjItem *)m_pSlob)->UsePropertyBag() != CurrBag)
			{
				// handle .pch weirdness with our radio group UI (P_PseudoPch)
				if (m_pSlob->GetIntProp(MapLogical(P_AutoPch), nCurrVal) != valid || (nCurrVal != (nVal == 2)))
					m_pSlob->SetIntProp(MapLogical(P_AutoPch), nVal == 2);

				if (m_pSlob->GetIntProp(MapLogical(P_PchCreate), nCurrVal) != valid || (nCurrVal != (nVal == 3)))
					m_pSlob->SetIntProp(MapLogical(P_PchCreate), nVal == 3);
				 
				if (m_pSlob->GetIntProp(MapLogical(P_PchUse), nCurrVal) != valid || (nCurrVal != (nVal == 4)))
					m_pSlob->SetIntProp(MapLogical(P_PchUse), nVal == 4);
			}

			// remove the pseudo-prop from this bag!
			m_pSlob->GetPropBag()->RemoveProp(idProp);
			break;

		default:
			break;
	}

	// DOLPHIN bug fix #12677
	// FUTURE (matthewt): fix this properly by writing individual props. into project file
	// make sure that properties that 'rely' on other
	// prop. values to be shown as an option have the 'other'
	// props. set (no need to do for non-file items)
	if (m_pSlob->GetContainer() != (CSlob *)NULL)
	{
		switch (idPropL)
		{
			case P_GenBrowserInfoNoLcl:
				// make sure we should be able to do this
				if (m_pSlob->GetIntProp(MapLogical(P_GenBrowserInfo), nCurrVal) == valid && nCurrVal)
					m_pSlob->SetIntProp(MapLogical(P_GenBrowserInfo), TRUE);
				break;

			case P_Optimize_X:
			case P_Optimize_T:
			case P_Optimize_A:
			case P_Optimize_W:
			case P_Optimize_G:
			case P_Optimize_I:
			case P_Optimize_S: 
				// make sure we should be able to do this
				if (m_pSlob->GetIntProp(MapLogical(P_Optimize), nCurrVal) == valid && (nCurrVal == 4))
					m_pSlob->SetIntProp(MapLogical(P_Optimize), 4);
				break;

			default:
				break;
		}
	}
}

void OLD_OPTION_HANDLER(CompilerCommon)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// DOLPHIN bug fix #12677
	// FUTURE (matthewt): fix this properly by writing individual props. into project file
	// make sure that properties that 'rely' on other
	// prop. values to be shown as an option have the 'other'
	// props. set (no need to do for non-file items)
	if (m_pSlob->GetContainer() != (CSlob *)NULL)
	{
		switch (idPropL)
		{
			case P_AutoPchUpTo:
				m_pSlob->SetIntProp(MapLogical(P_AutoPch), TRUE);
				break;
 
			case P_PchCreateUptoHeader:
				m_pSlob->SetIntProp(MapLogical(P_PchCreate), TRUE);
				break;

			case P_PchUseUptoHeader:
				m_pSlob->SetIntProp(MapLogical(P_PchUse), TRUE);
				break;

			case P_OutputDir_Sbr:
				m_pSlob->SetIntProp(MapLogical(P_GenBrowserInfo), TRUE);
				break;

			default:
				break;
		}
	}
}

BOOL OLD_OPTION_HANDLER(CompilerCommon)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fValid = TRUE;			// valid by default

	// placeholders for values
	int nVal;	

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// Incr. compilation and RTTI not available on all platforms
		case P_Enable_RTTI:
		{
			CPlatform * pPlatform = ((CProjItem *)m_pSlob)->GetProject()->GetCurrentPlatform();
			fValid = (pPlatform->GetAttributes() & PIA_Supports_RTTI) != 0;
			break;
		}

		case P_Enable_Incr:
		{
			CPlatform * pPlatform = ((CProjItem *)m_pSlob)->GetProject()->GetCurrentPlatform();
			fValid = (pPlatform->GetAttributes() & PIA_Supports_IncCplr) != 0;
			break;
		}

		case P_Enable_MR:
		{
			CPlatform * pPlatform = ((CProjItem *)m_pSlob)->GetProject()->GetCurrentPlatform();
			fValid = (pPlatform->GetAttributes() & PIA_Supports_MinBuild) != 0;

			// only valid for /Zi
			if (fValid)
			{
				(void) m_pSlob->GetIntProp(MapLogical(P_DebugInfo), nVal);
				fValid = (nVal >= DebugInfoPdb);
			}
			break;
		}

		// General-Purpose combo only enabled if PtrMbr1 is
		// 'general' representation
		case P_PtrMbr2:
			(void)m_pSlob->GetIntProp(MapLogical(P_PtrMbr1), nVal);
			fValid = (nVal == 2);	
			break;

		// Can't have these without 'Gen Browser Info' checked
		case P_GenBrowserInfoNoLcl:
		case P_OutputDir_Sbr:
			(void)m_pSlob->GetIntProp(MapLogical(P_GenBrowserInfo), nVal);
			fValid = !!nVal;
			break;

		// Can't name the listfile without setting listfile options
		case P_OutputDir_Cod:
			(void)m_pSlob->GetIntProp(MapLogical(P_ListAsm), nVal);
			fValid = !!nVal;
			break;

		// Can't have any custom optimizations without 'CustomOpt' on
		case P_Optimize_A:
		case P_Optimize_W:
		case P_Optimize_G:
		case P_Optimize_I:
		case P_Optimize_T:
		case P_Optimize_S:
		case P_Optimize_X:
			(void)m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal);
			fValid = (nVal == 4);
			break;

		// These are both enabled given /O2, there is no way to turn-off
		// ie. no /Gf- or /Gy-, on the command-line
		case P_IncLinking:
		case P_StringPool:
			(void)m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal);
			fValid = !(nVal == 2);
			if (fValid) {
				// ZI forces /Gy and /Gf 
				// Let's disable and use helpid to inform user accordingly
				(void) m_pSlob->GetIntProp(MapLogical(P_DebugInfo), nVal);
				fValid = (nVal != DebugInfoENC);
			}
			break;

		// Precompiled headers mondo enable/disable
		case P_OutputDir_Pch:
		{
			// need /YX, /Yc or /Yu
			(void) m_pSlob->GetIntProp(MapLogical(P_AutoPch), nVal);
			if (!nVal)
			{
				(void) m_pSlob->GetIntProp(MapLogical(P_PchCreate), nVal);
				if (!nVal)
				{
					(void) m_pSlob->GetIntProp(MapLogical(P_PchUse), nVal);
					fValid = nVal;
					break;
				}
			}

			fValid = TRUE;
			break;
		}

		// Don't try to rename a .pdb/.icc directory if we are not generating one
		case P_OutputDir_Pdb:
		{
			// do we have /Zi or /Gi or /FD?
			(void) m_pSlob->GetIntProp(MapLogical(P_DebugInfo), nVal);
			fValid = (nVal >= DebugInfoPdb);
			if (!fValid)
			{
				(void) m_pSlob->GetIntProp(MapLogical(P_Enable_Incr), nVal);
				fValid = !!nVal;
				if (!fValid)
				{
					(void) m_pSlob->GetIntProp(MapLogical(P_Enable_FD), nVal);
					fValid = !!nVal;
				}
			}
			break;
		}

		case P_PchCreateUptoHeader:
		{
			UINT idProp = MapLogical(P_PchCreate);
			if (m_pSlob->GetIntProp(idProp, nVal) != valid)
				nVal = FALSE;
			fValid = nVal && CheckDepOK(idProp);
			break;
		}

		case P_PchUseUptoHeader:
		{
			UINT idProp = MapLogical(P_PchUse);
			if (m_pSlob->GetIntProp(idProp, nVal) != valid)
				nVal = FALSE;
			fValid = nVal && CheckDepOK(idProp);
			break;
		}

		case P_AutoPchUpTo:
		{
			UINT idProp = MapLogical(P_AutoPch);
			if (m_pSlob->GetIntProp(idProp, nVal) != valid)
				nVal = FALSE;
			fValid = nVal && CheckDepOK(idProp);
			break;
		}

		case P_PchCreate:
		case P_PchUse:
		case P_AutoPch:
		{
			UINT idPropC = MapLogical(P_PchCreate);
			UINT idPropU = MapLogical(P_PchUse);
			UINT idPropX = MapLogical(P_AutoPch);

			int nPriCreate = 0, nPriUse = 0, nPriAuto = 0;
			int nVal;

			// figure the precedence of these
			// using a value calc'd below
			// /Yc overrides /Yu overrides /YX

			// set initial priorities (use defaults)
			if (m_pSlob->GetIntProp(idPropC, nVal) == valid && nVal)
				nPriCreate = 3;	// /Yc >> /Yu >> /YX

			else if (m_pSlob->GetIntProp(idPropU, nVal) == valid && nVal)
				nPriUse = 2;	// /Yu >> /YX

			else if (m_pSlob->GetIntProp(idPropX, nVal) == valid && nVal)
				nPriAuto = 1;	// /YX >> (nothing)

			// though per-file /Y? overrides project-level /Y?
			if (m_pSlob->GetContainer() != (CSlob *)NULL)
			{
				OptBehaviour optbeh = ((CProjItem *)m_pSlob)->GetOptBehaviour();

				// turn-off inherit for per-file
				((CProjItem *)m_pSlob)->SetOptBehaviour((OptBehaviour)(optbeh & ~OBInherit));

				// get priorities
				if (m_pSlob->GetIntProp(idPropC, nVal) == valid && nVal)
					nPriCreate += 4;

				else if (m_pSlob->GetIntProp(idPropU, nVal) == valid && nVal)
					nPriUse += 4; 

				else if (m_pSlob->GetIntProp(idPropX, nVal) == valid && nVal)
					nPriAuto += 4; 

				// reset option behaviour
				((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh);
			}

			int nOur, nOther1, nOther2;
			if (idPropL == P_PchCreate)
			{
				nOur = nPriCreate;
				nOther1 = nPriUse; nOther2 = nPriAuto;
			}
			else if (idPropL == P_PchUse)
			{
				nOur = nPriUse;
				nOther1 = nPriCreate; nOther2 = nPriAuto;
			}
			else
			{
				nOur = nPriAuto;
				nOther1 = nPriUse; nOther2 = nPriCreate;
			}

			// valid only if our priority is greater or equal to the others
			fValid = nOur >= nOther1 && nOur >= nOther2;
			break;
		}

		default:
			break;
	}

	return fValid;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// CCompilerTool
//////////////////////////////////////////////////////////////////////////////////////////////////
CCCompilerTool::CCCompilerTool() : CBuildTool()
{
	m_strToolInput = _TEXT("*.c;*.cpp;*.cxx");
	m_strToolPrefix = _TEXT("CPP");
	m_strName = _TEXT("cl.exe");
}

///////////////////////////////////////////////////////////////////////////////
// Ensure that this project compiler options are ok to use/not use MFC
BOOL CCCompilerTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	CString strDefine;

	COptionHandler * popthdlr = GetOptionHandler(); VSASSERT(popthdlr != (COptionHandler *)NULL, "Missing option handler for CL!");

	if (iUseMFC != NoUseMFC)
		pProjItem->SetIntProp(MapLogical(P_Enable_EH), TRUE);

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// CCompilerNTTool
/////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CCCompilerNTTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optncplr.h ===
//
// Common Compiler Tool Options
//
// [matthewt]
//

#pragma once

#include "projtool.h"			// the CBuildTool classes

//----------------------------------------------------------------
// our COMMON compiler option data
//----------------------------------------------------------------

// COMMON compiler option handler
DEFN_OPTHDLR_COMMON
(
	CompilerCommon, /* name */
	szAddOnGeneric,	BCID_OptHdlr_Compiler, /* generic compiler option handler */
	szAddOnGeneric, BCID_Tool_Compiler /* generic compiler tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// should this be shown always?
	virtual BOOL AlwaysShowDefault(UINT idProp);

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);
	virtual BOOL SetsFakePropValue(UINT idProp);

 	// return a 'fake' string prop
	virtual GPT GetDefStrProp(UINT idProp, CString & val);
	virtual GPT GetDefIntProp(UINT idProp, int & val);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// handle setting of option int props
	virtual void OnOptionIntPropChange(UINT idProp, int nVal);
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal);

	// provide invalidation of option props
	virtual BOOL CheckDepOK(UINT idProp);

private:
	// form a 'fake' string prop
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);

END_OPTHDLR()

// COMMON compiler tool properties
#define P_CplrNoLogo 					0x0000
#define P_MSExtension				   	0x0001
#define P_IncLinking			   		0x0002
#define P_WarningLevel					0x0003
#define P_WarnAsError					0x0004
#define P_StringPool					0x0005
#define P_PtrMbr1						0x0006
#define P_PtrMbr2						0x0007
#define P_VtorDisp						0x0008
#define P_DebugInfo						0x0009
#define P_AutoPch						0x000a
#define P_AutoPchUpTo					0x000b
#define P_Optimize						0x000c
#define P_Optimize_A					0x000d
#define P_Optimize_W					0x000e
#define P_Optimize_G					0x000f
#define P_Optimize_I					0x0010
#define P_Optimize_P					0x0011
#define P_Optimize_T					0x0012
#define P_Optimize_S					0x0013
#define P_Optimize_Y					0x0014
#define P_Optimize_X					0x0015
#define P_InlineControl					0x0016
#define P_CplrIgnInCPath				0x0017
#define P_Undefine						0x0018
#define P_ListAsm						0x0019
#define P_AsmListHasMC					0x001a
#define P_AsmListHasSrc					0x001b
#define P_GenBrowserInfo				0x001c
#define P_MacroNames					0x001d
#define P_MacroValues					0x0020
#define P_UndefMacros					0x0023
#define P_CplrIncludes					0x0026
#define P_TreatFileAsC1					0x0027
#define P_TreatFileAsC2					0x0028
#define P_TreatFileAsCPP1				0x0029
#define P_TreatFileAsCPP2				0x002a
#define P_PchCreate						0x002b
#define P_PchCreateUptoHeader			0x002c
#define P_PchUse						0x002d
#define P_PchUseUptoHeader				0x002e
#define P_OutputDir_Obj					0x002f
#define P_OutputDir_Pch					0x0030
#define P_OutputDir_Sbr					0x0031
#define P_OutputDir_Pdb					0x0032
#define P_CompileOnly					0x0033
#define P_CplrUnknownOption				0x0034
#define P_CplrUnknownString				0x0035
#define P_PchDefaultName				0x0036
#define P_PdbDefaultName				0x0037
#define P_GenBrowserInfoNoLcl			0x0038
#define P_CPP_Input_Ext					0x0039
#define P_Enable_EH						0x003a
#define P_OutputDir_Cod					0x003b
#define P_StackProbe					0x003c
#define P_StackProbeTHold				0x003d
#define P_MaxLenExtNames				0x003e
#define P_UseChasAsUnsigned				0x003f
#define P_EmbedString					0x0040
#define P_TurnOffWarnings				0x0041 
#define P_NoDefLibNameInObj				0x0042
#define P_PrepPreserveComments			0x0043
#define P_Preprocess					0x0044
#define P_PreprocessWOLines				0x0045
#define P_StackSize						0x0046
#define P_PrepprocessToFile				0x0047
#define P_GenFuncProto					0x0048
#define P_ForceIncludes					0x0049
#define P_CheckSyntax					0x004c
#define P_Enable_MR						0x004d
#define P_Enable_Incr					0x004e
#define P_Enable_RTTI					0x004f
#define P_PseudoPch						0x0050
#define P_Enable_FD						0x0051
#define P_Enable_FC						0x0052
#define P_Enable_dlp					0x0053
#define P_COM_EmitMergedSource          0x0054
#define P_COM_HresultKnowledge          0x0055

// Debug information constants
#define DebugInfoNone					0
#define DebugInfoLine					1
#define DebugInfoC7						2
// WARNING: DebugInfo constants greater than or
// equal to DebugInfoPdb assume the existence
// of a program database
#define DebugInfoPdb					3
#define DebugInfoENC					4

// COMMON compiler tool options (option ids)
#define IDOPT_CPLRNOLOGO				IDOPT_BASE + 0							
#define IDOPT_MSEXT						IDOPT_BASE + 4
#define IDOPT_INCLINK					IDOPT_BASE + 5
#define IDOPT_WARN						IDOPT_BASE + 6
#define IDOPT_WARNASERROR				IDOPT_BASE + 7
#define IDOPT_STRPOOL					IDOPT_BASE + 8
#define IDOPT_PTRMBR1					IDOPT_BASE + 9
#define IDOPT_PTRMBR2					IDOPT_BASE + 10
#define IDOPT_VTORDISP					IDOPT_BASE + 11
#define IDOPT_DEBUGINFO					IDOPT_BASE + 12
#define IDOPT_AUTOPCH					IDOPT_BASE + 13
#define IDOPT_OPTIMIZE					IDOPT_BASE + 14
#define IDOPT_OPT_A						IDOPT_BASE + 15
#define IDOPT_OPT_W						IDOPT_BASE + 16
#define IDOPT_OPT_G						IDOPT_BASE + 17
#define IDOPT_OPT_I						IDOPT_BASE + 18
#define IDOPT_OPT_P						IDOPT_BASE + 19
#define IDOPT_OPT_T						IDOPT_BASE + 20
#define IDOPT_OPT_S						IDOPT_BASE + 21
#define IDOPT_OPT_Y						IDOPT_BASE + 22
#define IDOPT_OPT_X						IDOPT_BASE + 23
#define IDOPT_INLINECTRL				IDOPT_BASE + 24
#define IDOPT_CPLRIGNINC				IDOPT_BASE + 25
#define IDOPT_UNDEFINE					IDOPT_BASE + 26
#define IDOPT_LISTASM					IDOPT_BASE + 27
#define IDOPT_LISTBSC					IDOPT_BASE + 28
#define IDOPT_TREATFILEAS_C1			IDOPT_BASE + 29
#define IDOPT_TREATFILEAS_CPP1			IDOPT_BASE + 30
#define IDOPT_MACROS					IDOPT_BASE + 31
#define IDOPT_UNDEFMACROS				IDOPT_BASE + 32
#define IDOPT_CPLRINCLUDES				IDOPT_BASE + 33
#define IDOPT_TREATFILEAS_C2			IDOPT_BASE + 34
#define IDOPT_TREATFILEAS_CPP2			IDOPT_BASE + 35
#define IDOPT_PCHNAME					IDOPT_BASE + 36
#define IDOPT_PCHCREATE					IDOPT_BASE + 37
#define IDOPT_PCHUSE					IDOPT_BASE + 38
#define IDOPT_OUTDIR_OBJ				IDOPT_BASE + 39
#define IDOPT_OUTDIR_PDB				IDOPT_BASE + 40
#define IDOPT_COMPILE_ONLY				IDOPT_BASE + 41
#define IDOPT_LISTBSCNOLCL				IDOPT_BASE + 42
#define IDOPT_ENABLE_EH					IDOPT_BASE + 43
#define IDOPT_OUTDIR_COD				IDOPT_BASE + 44
#define IDOPT_STACK_PROBE				IDOPT_BASE + 45
#define IDOPT_STACK_PROBE_THOLD			IDOPT_BASE + 46
#define IDOPT_MAXLEN_EXTNAME			IDOPT_BASE + 47
#define IDOPT_USECHAR_AS_UNSIGNED		IDOPT_BASE + 48
#define IDOPT_EMBED_STRING				IDOPT_BASE + 49
#define IDOPT_TURN_OFF_WARNINGS			IDOPT_BASE + 50
#define IDOPT_NO_DEFLIB_NAME			IDOPT_BASE + 51
#define IDOPT_PREP_COMMENTS				IDOPT_BASE + 52
#define IDOPT_PREPROCESS				IDOPT_BASE + 53
#define IDOPT_PREPROCESS_WO_LINES		IDOPT_BASE + 54
#define IDOPT_STACKSIZE					IDOPT_BASE + 55
#define IDOPT_PREPROCESS_TO_FILE		IDOPT_BASE + 56
#define IDOPT_GEN_FUNC_PROTO			IDOPT_BASE + 57
#define IDOPT_FORCEINCLUDES				IDOPT_BASE + 58
#define IDOPT_CHECK_SYNTAX				IDOPT_BASE + 59
#define IDOPT_ENABLE_MR					IDOPT_BASE + 60
#define IDOPT_ENABLE_INCR				IDOPT_BASE + 61
#define IDOPT_ENABLE_RTTI				IDOPT_BASE + 62
#define IDOPT_ENABLE_FD					IDOPT_BASE + 63
#define IDOPT_ENABLE_FC					IDOPT_BASE + 64
#define IDOPT_ENABLE_DLP				IDOPT_BASE + 65
#define IDOPT_CPP_INPUT_EXT				IDOPT_BASE + 66
#define IDOPT_COM_EmitMergedSource      IDOPT_BASE + 67
#define IDOPT_COM_ImplicitErrHandling   IDOPT_BASE + 68
#define IDOPT_COM_HresultKnowledge      IDOPT_BASE + 69

#include "optncplr.h2"	// our option control IDs

class  CCCompilerTool : public CBuildTool
{
	DECLARE_DYNAMIC (CCCompilerTool)
 
	CCCompilerTool();

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};

class  CCCompilerNTTool : public CCCompilerTool
{
	DECLARE_DYNAMIC (CCCompilerNTTool)

public:
	CCCompilerNTTool() : CCCompilerTool() {}

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnlink.h ===
//
// Linker Tool Options and Tool
//

#pragma once

//----------------------------------------------------------------
// our COMMON linker option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	LinkerCommon, /* name */
	szAddOnGeneric, BCID_OptHdlr_Linker, /* generic linker option handler */
	szAddOnGeneric, BCID_Tool_Linker /* generic linker tool tool */
)
	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// is this a default of one of our 'fake' string props?
	// (we need special handling here)
	virtual BOOL IsDefaultStringProp(UINT idProp, CString & strVal);

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// should this be shown always?
	virtual BOOL AlwaysShowDefault(UINT idProp);

	// return a 'fake' string prop
	virtual GPT GetDefStrProp(UINT idProp, CString & strVal);
	virtual GPT GetDefIntProp(UINT idProp, int & nVal);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// provide invalidation of option props
	virtual BOOL CheckDepOK(UINT idProp);

	// called whenever a prop has changed
	// we can use this to delete a prop if we want the fake prop instead
	virtual void OnOptionIntPropChange(UINT idProp, int nVal);

private:
	// form a 'fake' string prop
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);
	virtual void FormFakeIntProp(UINT idProp, int & nVal) ;

	BOOL m_fProjIsDll;	// HACK: for /DLL munging of /OUT:

END_OPTHDLR()

#define P_LinkNoLogo			0x0000
#define P_LinkVerbose			0x0001
#define P_GenMap				0x0002
#define P_MapName				0x0003
#define P_GenDebug				0x0004
#define P_DebugType				0x0005
#define P_NoDefaultLibs			0x0006
// 0x0007 - Add P_NoDefaultLibs
// 0x0008 - Subtract P_NoDefaultLibs
#define P_DefName				0x0009
#define P_Force					0x000b
#define P_OutName				0x000c
#define P_IncludeSym			0x000d
// 0x000e - Add P_IncludeSym
// 0x000f - Subtract P_IncludeSym
#define P_ExAllLibs				0x0010
#define P_ImpLibName			0x0011
#define P_GenDll				0x0012
#define P_IncrementalLink		0x0013
#define P_UsePDB				0x0014
#define P_UsePDBName			0x0015
#define P_Profile				0x0016
#define P_MachineType			0x0017
#define P_IgnoreExportLib		0x0018
#define P_LazyPdb				0x0019
#define P_LibPath				0x001a
// 0x001b - Add P_LibPath				
// 0x001c - Subtract P_LibPath				
#define P_Linker_Input_Ext		0x001d
#define P_LinkDelayLoadDLL		0x001e
// 0x001f - Add P_LinkDelayLoadDLL				
// 0x0020 - Subtract P_LinkDelayLoadDLL				
#define P_LinkDelayNoBind		0x0021
#define P_LinkDelayUnLoad		0x0022
#define P_LinkUnknownOption		0x0023
#define P_LinkUnknownString		0x0024
#define P_ResOnlyDLL			0x0025
#define P_BaseAddress			0x0026
#define P_VirtualDeviceDriver	0x0027
#define P_Link50Compat			0x0028
#define P_Align					0x0029
#define P_SetCheckSum			0x002a
#define P_MergeSections			0x002b
#define P_OrderFuncs			0x002c
#define P_TrimProcMem			0x002d
#define P_LargeAddress			0x002e
#define P_Fixed					0x002f
#define P_BaseAddr				0x0030
#define P_ExeDynamic			0x0031
#define P_Driver				0x0032
#define P_PreventBind			0x0033


// linker tool options (option ids)
#define IDOPT_LINKNOLOGO				IDOPT_BASE + 9
#define IDOPT_LINKVERBOSE				IDOPT_BASE + 26
#define IDOPT_MAPGEN					IDOPT_BASE + 27
#define IDOPT_DEBUG						IDOPT_BASE + 2
#define IDOPT_DEBUGTYPE					IDOPT_BASE + 3
#define IDOPT_EXALLLIB					IDOPT_BASE + 4
#define IDOPT_DEFNAME					IDOPT_BASE + 5
#define IDOPT_LIBPATH					IDOPT_BASE + 6
#define IDOPT_FORCE						IDOPT_BASE + 7
#define IDOPT_OUT						IDOPT_BASE + 8
#define IDOPT_NOLOGO					IDOPT_BASE + 9
#define IDOPT_NODEFAULTLIB				IDOPT_BASE + 10
#define IDOPT_INCLUDESYM				IDOPT_BASE + 11
#define IDOPT_IMPLIB					IDOPT_BASE + 12
#define IDOPT_DLLGEN					IDOPT_BASE + 13
#define IDOPT_INCREMENTALLINK			IDOPT_BASE + 14
#define IDOPT_USEPDB					IDOPT_BASE + 15
#define IDOPT_USEPDBLINK				IDOPT_BASE + 16
#define IDOPT_USEPDBNONE				IDOPT_BASE + 17
#define IDOPT_LAZYPDB					IDOPT_BASE + 18
#define IDOPT_PROFILE					IDOPT_BASE + 19
#define IDOPT_MACHINETYPE				IDOPT_BASE + 20
#define IDOPT_IGNOREEXPORTLIB			IDOPT_BASE + 21
#define IDOPT_LINKER_INPUT_EXT			IDOPT_BASE + 22
#define IDOPT_DELAY_LOAD_DLL			IDOPT_BASE + 23
#define IDOPT_DELAY_NOBIND				IDOPT_BASE + 24
#define IDOPT_DELAY_UNLOAD				IDOPT_BASE + 25
#define IDOPT_RESONLY_DLL				IDOPT_BASE + 28
#define IDOPT_BASE_ADDRESS				IDOPT_BASE + 29
#define IDOPT_VIRTUAL_DEVICE_DRIVER		IDOPT_BASE + 30
#define IDOPT_50COMPAT					IDOPT_BASE + 31
#define IDOPT_ALIGN						IDOPT_BASE + 32
#define IDOPT_SET_CHECKSUM				IDOPT_BASE + 33
#define IDOPT_MERGE_SECTIONS			IDOPT_BASE + 34
#define IDOPT_ORDER_FUNCS				IDOPT_BASE + 35
#define IDOPT_TRIM_PROC_MEM				IDOPT_BASE + 36
#define IDOPT_LARGEADDRESS				IDOPT_BASE + 37
#define IDOPT_FIXED						IDOPT_BASE + 38
#define IDOPT_EXE_BASE					IDOPT_BASE + 39
#define IDOPT_EXE_DYNAMIC				IDOPT_BASE + 40	
#define IDOPT_DRIVER					IDOPT_BASE + 41	
#define IDOPT_PREVENT_BIND				IDOPT_BASE + 42		

//----------------------------------------------------------------
// out NT linker option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_PLATFORM
(
	LinkerNT, /* name */
	szAddOnGeneric, BCID_OptHdlr_LinkerNT, /* generic NT linker option handler */
	szAddOnGeneric, BCID_Tool_LinkerNT, /* generic NT linker tool */
	szAddOnGeneric, BCID_OptHdlr_Linker /* base generic linker option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// should this be shown always?
	virtual BOOL AlwaysShowDefault(UINT idProp);

	// provide invalidation of option props
	virtual BOOL CheckDepOK(UINT idProp);

END_OPTHDLR()

// NT linker tool properties
#define P_VersionMaj			0x1000
#define P_VersionMin			0x1001
#define P_StackReserve			0x1002
#define P_StackCommit			0x1003
#define P_EntryName				0x1004
#define P_SubSystem				0x1005
#define P_HeapReserve			0x1006
#define P_HeapCommit			0x1007

// NT linker tool options (option ids)
#define IDOPT_VERSION					5000
#define IDOPT_STACK						5001
#define IDOPT_ENTRYPOINT				5002
#define IDOPT_SUBSYSTEM					5003
#define IDOPT_HEAP						5004

#include "schmztl.h"			// the CSchmoozeTool class

class  CLinkerTool : public CSchmoozeTool
{
	DECLARE_DYNAMIC (CLinkerTool)

public:
	CLinkerTool();

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};

class  CLinkerNTTool : public CLinkerTool
{
	DECLARE_DYNAMIC (CLinkerNTTool)

public:
	CLinkerNTTool() : CLinkerTool() {}

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnmtl.h ===
// Make Type Library Tool Options and Tool
//

#pragma once

//----------------------------------------------------------------
// our mktyplib option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	MkTypLib, /* name */
	szAddOnGeneric, BCID_OptHdlr_MkTypLib, /* generic mktyplib option handler */
	szAddOnGeneric, BCID_Tool_MkTypLib /* our generic associated mktyplib tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// is this a 'fake' prop?
	virtual BOOL IsFakeProp (UINT idProp);

	// return a 'fake' string prop
	virtual GPT GetDefStrProp (UINT idProp, CString & strVal);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

private:
	// form a 'fake' string prop
	virtual void FormFakeStrProp (UINT idProp, CString & strVal);

END_OPTHDLR()


// MkTypLib properties
#define P_MTLNologo				0x0000
#define P_MTLIncludes			0x0001
#define P_MTLMacros				0x0004
#define P_MTLOutputTlb			0x0007
#define P_MTLOutputInc			0x0008
#define P_MTLOutputUuid			0x0009
#define P_MTLOutputDir			0x000a
#define P_MTLMtlCompatible      0x000b
#define P_MTLStublessProxy    	0x000c
#define P_MTLNoClutter		    0x000d
#define P_MTL_Input_Ext			0x000e
#define P_MTLUnknownOption		0x000f
#define P_MTLUnknownString		0x0010
#define P_MTL_Char              0x0011
#define P_MTLDllData            0x0012
#define P_MTL_Client			0x0013
#define P_MTL_Server			0x0014

// MkTypLib options (option ids)				   
#define IDOPT_MTLNOLOGO				IDOPT_BASE + 0
#define IDOPT_MTLINCLUDES 			IDOPT_BASE + 1
#define IDOPT_MTLIGNINC				IDOPT_BASE + 2
#define IDOPT_MTLMACROS				IDOPT_BASE + 3
#define IDOPT_MTLOUTPUTTLB			IDOPT_BASE + 4
#define IDOPT_MTLOUTPUTINC			IDOPT_BASE + 5
#define IDOPT_MTLOUTPUTUUID			IDOPT_BASE + 6
#define IDOPT_MTLMTLCOMPATIBLE		IDOPT_BASE + 7
#define IDOPT_MTL_STUBLESS_PROXY	IDOPT_BASE + 8
#define IDOPT_MTLOUTPUTDIR			IDOPT_BASE + 9
#define IDOPT_MTLNOCLUTTER   		IDOPT_BASE + 10
#define IDOPT_MTL_INPUT_EXT   		IDOPT_BASE + 11
#define IDOPT_MTL_CHAR				IDOPT_BASE + 12
#define IDOPT_MTLDLLDATA            IDOPT_BASE + 13
#define IDOPT_MTL_CLIENT			IDOPT_BASE + 14
#define IDOPT_MTL_SERVER			IDOPT_BASE + 15

#include "projtool.h"	// where base classes are defined

///////////////////////////////////////////////////////////////////////////////
//
// CBuildTool ----> CMkTypLibTool
//
////////////////////////////////////////////////////////////////////////////////
class CMkTypLibTool : public CBuildTool
{
	DECLARE_DYNAMIC (CMkTypLibTool)

public:
	CMkTypLibTool();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnrc.h ===
//
// Resource Compiler Tool Options and Tool
//

#pragma once

//----------------------------------------------------------------
// our COMMON resource compiler option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	ResCompiler, /* name */
	szAddOnGeneric, BCID_OptHdlr_RcCompiler, /* generic resource compiler option handler */
	szAddOnGeneric, BCID_Tool_RcCompiler /* generic resource compiler tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// check deps.
	virtual BOOL CheckDepOK(UINT idProp);

	// is this a default of one of our 'fake' string props?
	// (we need special handling here)
	virtual BOOL IsDefaultStringProp(UINT idProp, CString & strVal);

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// return a 'fake' string prop
	virtual GPT GetDefStrProp(UINT idProp, CString & strVal);

	// always show this?
	virtual BOOL AlwaysShowDefault(UINT idProp);

	// return a 'fake' int prop
	virtual GPT GetDefIntProp(UINT idProp, int & nVal);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// called whenever a prop has changed
	// we can use this to delete a prop if we want the fake prop instead
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal) ;

	// get the output extension
	const CString *GetOutputExtension();

private:
	// form a 'fake' string prop
	virtual void FormFakeIntProp(UINT idProp, int & nVal);
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);

	BOOL m_fEnableLangID;

END_OPTHDLR()

// resource compiler properties
#define P_ResVerbose					 0x0000
#define P_ResIgnInCPath					 0x0001
#define P_ResIncludes					 0x0002
#define P_OutNameRes					 0x0005
#define P_ResMacroNames					 0x0006
#define P_Res_Input_Ext					 0x0009
#define P_ResLangID						 0x000a
#define P_ResUnknownOption				 0x000b
#define P_ResUnknownString				 0x000c

// resource compiler options (option ids)
#define IDOPT_RESVERBOSE				IDOPT_BASE + 0
#define IDOPT_RESIGNINC					IDOPT_BASE + 1
#define IDOPT_RESMACROS					IDOPT_BASE + 2
#define IDOPT_RESINCLUDES				IDOPT_BASE + 3
#define IDOPT_OUTDIR_RES				IDOPT_BASE + 4
#define IDOPT_RESLANGID					IDOPT_BASE + 5
#define IDOPT_RES_INPUT_EXT				IDOPT_BASE + 6

// option handler
DEFN_OPTHDLR_PLATFORM
(
	ResCompilerNT, /* name */
	szAddOnGeneric, BCID_OptHdlr_RcCompilerNT, /* generic NT resource compiler option handler */
	szAddOnGeneric, BCID_Tool_RcCompilerNT, /* generic NT resource compiler tool */
	szAddOnGeneric, BCID_OptHdlr_RcCompiler /* base generic resource compiler option handler */
)
	
	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()
 
END_OPTHDLR()

#include "projtool.h"		// the CBuildTool classes

class  CRCCompilerTool : public CBuildTool
{
	DECLARE_DYNAMIC (CRCCompilerTool)

public:
	CRCCompilerTool();
};

// NT RC Compiler Tool
class  CRCCompilerNTTool : public CRCCompilerTool 
{
	DECLARE_DYNAMIC (CRCCompilerNTTool)

public:
	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnmtl.cpp ===
//
// MkTypLib Tool Options
//
//

#include "stdafx.h" // standard AFX include
#pragma hdrstop

#include "optnmtl.h" // local header file
#include "project.h"

BEGIN_OPTSTR_TABLE (MkTypLib, P_MTLUnknownOption, P_MTLUnknownString, P_MTLNologo, P_MTL_Server, FALSE)
	IDOPT_MTLNOLOGO,		"nologo%T1",		OPTARGS1(P_MTLNologo),			single,
	IDOPT_MTLINCLUDES,		"I[ ]%1",			OPTARGS1(P_MTLIncludes),		multiple,
	IDOPT_MTLDLLDATA,		"dlldata[ ]%1",		OPTARGS1(P_MTLDllData),			single,
	IDOPT_MTLMACROS,		"D[ ]%1",			OPTARGS1(P_MTLMacros), 			multiple,
	IDOPT_MTLOUTPUTTLB,		"tlb[ ]%1",			OPTARGS1(P_MTLOutputTlb),		single,
	IDOPT_MTLOUTPUTINC,		"h[ ]%1",			OPTARGS1(P_MTLOutputInc),		single,
	IDOPT_MTLOUTPUTUUID,	"iid[ ]%1",			OPTARGS1(P_MTLOutputUuid),		single,
	IDOPT_MTLOUTPUTDIR,		"out[ ]%1",			OPTARGS1(P_MTLOutputDir),		single,
	IDOPT_MTLMTLCOMPATIBLE,	"mktyplib203%T1",	OPTARGS1(P_MTLMtlCompatible), 	single,
	IDOPT_MTL_STUBLESS_PROXY,	"Oicf%T1",		OPTARGS1(P_MTLStublessProxy),	single,
	IDOPT_MTLNOCLUTTER,		"o[ ]%1",			OPTARGS1(P_MTLNoClutter), 		single,
	IDOPT_MTL_INPUT_EXT,	"",					OPTARGS1(P_MTL_Input_Ext),		single,
	IDOPT_UNKNOWN_OPTION,		"",				NO_OPTARGS,						single,
	IDOPT_UNKNOWN_STRING,		"",				NO_OPTARGS,						single,
	IDOPT_MTL_CHAR,			"char %{signed|ascii7|unsigned}1",	OPTARGS1(P_MTL_Char),	single,
	IDOPT_MTL_CLIENT,		"client %{stub|none}1",	OPTARGS1(P_MTL_Client),		single,
	IDOPT_MTL_SERVER,		"server %{stub|none}1",	OPTARGS1(P_MTL_Server),		single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP (MkTypLib)
	OPTDEF_BOOL(MTLNologo, FALSE)
	OPTDEF_LIST(MTLIncludes, "")
	OPTDEF_LIST(MTLMacros, "") 
	OPTDEF_PATH(MTLOutputTlb, "")
	OPTDEF_PATH(MTLOutputInc, "")
	OPTDEF_PATH(MTLOutputUuid, "")
	OPTDEF_PATH(MTLOutputDir, "")
	OPTDEF_BOOL(MTLMtlCompatible, FALSE)
	OPTDEF_BOOL(MTLStublessProxy, FALSE)
	OPTDEF_PATH(MTLNoClutter, "")
	OPTDEF_STRING(MTL_Input_Ext, "*.idl")
	OPTDEF_INT(MTL_Char, 0)
	OPTDEF_PATH(MTLDllData, "")
	OPTDEF_INT(MTL_Client, 0)
	OPTDEF_INT(MTL_Server, 0)
END_OPTDEF_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CMkTypLibTool, CBuildTool)

//////////////////////////////////////////////////////////
BOOL OLD_OPTION_HANDLER(MkTypLib)::IsFakeProp (UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_MTL_Input_Ext || idPropL == P_MTLOutputTlb);
}

//////////////////////////////////////////////////////////////
UINT OLD_OPTION_HANDLER(MkTypLib)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_MTLOutputTlb)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

//////////////////////////////////////////////////////////////
void OLD_OPTION_HANDLER (MkTypLib)::FormFakeStrProp (UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// Assert this is a MkTypLib 'fake' string prop ?
	VSASSERT (IsFakeProp (idProp), "FormFakeStrProp called with non-fake prop!");
	
	// get the project base-name (ie. without extension)
	CString strProj, strBase;
	CPath pathProj;
	const TCHAR * pchT;

	if (idPropL == P_MTL_Input_Ext)
	{
		// make sure the project is in our config.
		CProjItem * pItem = (CProjItem *)m_pSlob;
		CProjTempConfigChange projTempConfigChange(pItem->GetProject());
		projTempConfigChange.ChangeConfig((CConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord);

		CConfigurationRecord * pcr = (CConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord;
		CString strToolName = _T("midl.exe");
		CString strExtList = _T("");
		pcr->GetExtListFromToolName(strToolName, &strExtList);
		if(strExtList)
		{
			strVal = strExtList;
		}
		return;

	}

	if (idPropL == P_MTLOutputTlb)
	{
		GPT gpt = m_pSlob->GetStrProp(P_ProjItemName, strProj);
		strBase.Empty();
		if (gpt == valid && !strProj.IsEmpty())
		{
			BOOL bOK = pathProj.Create(strProj);
			VSASSERT(bOK, "Failed to create project path!");
			pathProj.GetBaseNameString(strBase);
		}

		if (!strBase.IsEmpty())
		{
			// which output directory do we want to use?
			UINT idOutDirProp = GetFakePathDirProp(idProp);
			VSASSERT(idOutDirProp != (UINT)-1, "Failed to get proper fake path dir!");

			CProjItem * pItem = (CProjItem *)m_pSlob;
			GPT gpt = pItem->GetStrProp(idOutDirProp, strVal);
			while (gpt != valid)
			{
				// *chain* the proper. config.
				CProjItem * pItemOld = pItem;
				pItem = (CProjItem *)pItem->GetContainerInSameConfig();
				if (pItemOld != m_pSlob)
					pItemOld->ResetContainerConfig();

				VSASSERT(pItem != (CSlob *)NULL, "Item's container is NULL!!!");
				gpt = pItem->GetStrProp(idOutDirProp, strVal);
			}

			// reset the last container we found
			if (pItem != m_pSlob)
				pItem->ResetContainerConfig();

			if (!strVal.IsEmpty())
			{
				// If the output directory doesn't end in a forward slash
				// or a backslash, append one.
				pchT = (const TCHAR *)strVal + strVal.GetLength();
				pchT = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchT);

				if (*pchT != _T('/') && *pchT != _T('\\'))
					strVal += _T('/');
			}

			strVal += strBase + _TEXT(".tlb") ;
		}
	}
	else
		strVal.Empty() ;
}

/////////////////////////////////////////////////////////////////////////
GPT OLD_OPTION_HANDLER (MkTypLib)::GetDefStrProp(UINT idProp, CString & val)
{
	if (!IsFakeProp (idProp))
		return COptionHandler::GetDefStrProp(idProp, val) ;	

	FormFakeStrProp (idProp, val) ;
	return valid ;
}

///////////////////////////////////////////////////////////////////////////////
// CMkTypLibTool
///////////////////////////////////////////////////////////////////////////////
CMkTypLibTool::CMkTypLibTool() : CBuildTool()
{
	// tool exe name and input file set
	m_strToolInput = _TEXT("*.odl;*.idl");
	m_strToolPrefix = _TEXT("MTL");
	m_strName = _TEXT("midl.exe");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platalf.h ===
//
// Alpha (RISC) Platform
//
// [matthewt]
//
						
#ifndef _INCLUDE_PLATFORM_ALF_H
#define _INCLUDE_PLATFORM_ALF_H

#include "alpha.h"

// declare out platform
extern	PlatformInfo	g_PlatformInfoWin32ALPHA;

// declare our project types
// declare our project types (FOR ALPHA)
class CProjTypeWin32ALPHAExe : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32ALPHAExe)

public:
	CProjTypeWin32ALPHAExe()
		: CProjType(szAddOnx86, BCID_ProjType_AlphaExe, /* id */
					IDS_WIN32EXE_PROJTYPE, CProjType::application, /* props */
					szAddOnx86, BCID_Platform_Alpha) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageExe | SubsystemWindows | TargetIsDebugable;}
};

class CProjTypeWin32ALPHADll : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32ALPHADll)

public:
	CProjTypeWin32ALPHADll()
		: CProjType(szAddOnx86, BCID_ProjType_AlphaDll, /* id */
					IDS_WIN32DLL_PROJTYPE, CProjType::dynamiclib, /* props */
					szAddOnx86, BCID_Platform_Alpha) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageDLL | TargetIsDebugable;}
};

class CProjTypeWin32ALPHACon : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32ALPHACon)

public:
	CProjTypeWin32ALPHACon()
		: CProjType(szAddOnx86, BCID_ProjType_AlphaCon, /* id */
					IDS_WIN32CON_PROJTYPE, CProjType::consoleapp, /* props */
					szAddOnx86, BCID_Platform_Alpha) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageExe | SubsystemConsole | TargetIsDebugable;}
	UINT GetUseMFCDefault() {return NoUseMFC;}
};

class CProjTypeWin32ALPHALib : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32ALPHALib)

public:
	CProjTypeWin32ALPHALib()
		: CProjType(szAddOnx86, BCID_ProjType_AlphaLib, /* id */
					IDS_WIN32LIB_PROJTYPE, CProjType::staticlib, /* props */
					szAddOnx86, BCID_Platform_Alpha) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageStaticLib | TargetIsDebugable;}
};

#endif // _INCLUDE_PLATFORM_ALF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platmip.cpp ===
//
// MIPS (RISC) Platform
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"     // our standard AFX include
#pragma hdrstop
#include "platmip.h"    // our local header file

IMPLEMENT_DYNAMIC(CProjTypeWin32MIPSExe, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32MIPSDll, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32MIPSCon, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32MIPSLib, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// declare our platform
//
// *** DO NOT TRANSLATE (LOCALIZE) THE PLATFORM STRINGS HERE ***

PlatformInfo g_PlatformInfoWin32MIPS =
{
    _T("Win32 (MIPS)"),             // Official platform name -- DO NOT LOCALIZE!
    win32mips,                      // Unique ID
#if defined (_MIPS_)
    IDS_WIN32_PLATFORM,             // Localizable description string
#else
    IDS_WIN32MIPS_PLATFORM,         // Localizable description string
#endif
    IDS_WIN32MIPS_PLATFORM_SHORT,   // Abbreviated localizable description string
    _T("res"),                      // RC extension
#if defined (_MIPS_)
    PIA_Primary_Platform |          // Primary platform
#else
    0 |                             // Not Primary platform
#endif
    PIA_Allow_WorkingDir |          // Can use a working dir. for debugging
    PIA_Supports_RTTI |             // Supports RTTI
    PIA_Supports_IncLink |          // Supports ilink
    PIA_Enable_Language |           // Enable Language for RC option
    PIA_Allow_ProgArgs |            // Executable can use program arguments for Debug etc.
    PIA_Allow_MFCinDLL|             // Allow use of mfc in a dll
    PIA_Allow_ODBC |                // Allow use of mfc ODBC
    PIA_Enable_Stub|                // Allow DOS Stub
    PIA_Enable_AllDebugType,        // Allow Debug Types
    NoUseMFC,                       // Default is not using MFC
    _T("MIPS")                      // Default output directories
};

// implementation

// pre-installed components
#include "optnbsc.h"
#include "optnrc.h"
#include "optnmtl.h"
#include "optnlib.h"

void VPROJDeriveDefaultCplrOptionsMIP(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_CPLR_COMMON, fDebug ? IDS_WIN32_CPLR_DBG : IDS_WIN32_CPLR_REL, nIDOption);
}

// derive the linker options by adding in 'common part' + 'config. part' + 'win32 libraries'
void VPROJDeriveDefaultWin32MIPSLinkOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_LINK_MIPS_COMMON, fDebug ? IDS_WIN32_LINK_DBG : IDS_WIN32_LINK_REL, nIDOption);

    CString strXtraLibs;
    bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS_CORE);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
    bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
    bOK = strXtraLibs.LoadString(IDS_OLE2_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
}

void VPROJDeriveDefaultRcOptionsMIP(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_RC_COMMON, fDebug ? IDS_WIN32_RC_DBG : IDS_WIN32_RC_REL, nIDOption);
}

void VPROJDeriveDefaultBscMakeOptionsMIP(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_BSCMAKE_COMMON, fDebug ? IDS_WIN32_BSCMAKE_DBG : IDS_WIN32_BSCMAKE_REL, nIDOption);
}

void VPROJDeriveDefaultLibOptionsMIP(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    // the library manager options have no common, debug or release parts!
    BOOL bOK = strOption.LoadString(nIDOption);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
}

BOOL CProjTypeWin32MIPSExe::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the 32-bit compiler
            case BCID_Tool_Compiler_Mips:
                VPROJDeriveDefaultCplrOptionsMIP(strOption, fDebug, fDebug ? IDS_WIN32MIPSEXE_CPLR_DBG : IDS_WIN32MIPSEXE_CPLR_REL);
                break;

            // the Mips COFF linker
            case BCID_Tool_Linker_Mips:
                VPROJDeriveDefaultWin32MIPSLinkOptions(strOption, fDebug, IDS_WIN32EXE_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsMIP(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsMIP(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32MIPS_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32MIPSDll::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the 32-bit compiler
            case BCID_Tool_Compiler_Mips:
                VPROJDeriveDefaultCplrOptionsMIP(strOption, fDebug, fDebug ? IDS_WIN32MIPSDLL_CPLR_DBG : IDS_WIN32MIPSDLL_CPLR_REL);
                break;

            // the Mips COFF linker
            case BCID_Tool_Linker_Mips:
                VPROJDeriveDefaultWin32MIPSLinkOptions(strOption, fDebug, IDS_WIN32DLL_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsMIP(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsMIP(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32MIPS_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32MIPSCon::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the 32-bit compiler
            case BCID_Tool_Compiler_Mips:
                VPROJDeriveDefaultCplrOptionsMIP(strOption, fDebug, fDebug ? IDS_WIN32MIPSCON_CPLR_DBG : IDS_WIN32MIPSCON_CPLR_REL);
                break;

            // the Mips COFF linker
            case BCID_Tool_Linker_Mips:
                VPROJDeriveDefaultWin32MIPSLinkOptions(strOption, fDebug, IDS_WIN32CON_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsMIP(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsMIP(strOption, fDebug, UINT(-1));
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32MIPSLib::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the 32-bit compiler
            case BCID_Tool_Compiler_Mips:
                VPROJDeriveDefaultCplrOptionsMIP(strOption, fDebug, fDebug ? IDS_WIN32MIPSLIB_CPLR_DBG : IDS_WIN32MIPSLIB_CPLR_REL);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF library manager
            case BCID_Tool_Lib:
                VPROJDeriveDefaultLibOptionsMIP(strOption, fDebug, IDS_WIN32LIB_LINK);
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsMIP(strOption, fDebug, UINT(-1));
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32MIPSExe::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnx86, BCID_Tool_Linker_Mips);
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnx86, BCID_Tool_Compiler_Mips);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin32MIPSDll::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnx86, BCID_Tool_Linker_Mips);
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnx86, BCID_Tool_Compiler_Mips);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin32MIPSCon::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnx86, BCID_Tool_Linker_Mips);
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnx86, BCID_Tool_Compiler_Mips);

    return TRUE;    // success
}

BOOL CProjTypeWin32MIPSLib::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_Lib);
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Compiler_Mips);

    return TRUE;    // success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platmip.h ===
//
// MIPS (RISC) Platform
//
// [matthewt]
//
						
#ifndef _INCLUDE_PLATFORM_MIPS_H
#define _INCLUDE_PLATFORM_MIPS_H

// declare out platform
extern	PlatformInfo	g_PlatformInfoWin32MIPS;

// declare our project types
class CProjTypeWin32MIPSExe : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32MIPSExe)

public:
	CProjTypeWin32MIPSExe()
		: CProjType(szAddOnx86, BCID_ProjType_MipsExe, /* id */
					IDS_WIN32EXE_PROJTYPE, CProjType::application, /* props */
					szAddOnx86, BCID_Platform_Mips) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageExe | SubsystemWindows | TargetIsDebugable;}
};

class CProjTypeWin32MIPSDll : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32MIPSDll)

public:
	CProjTypeWin32MIPSDll()
		: CProjType(szAddOnx86, BCID_ProjType_MipsDll, /* id */
					IDS_WIN32DLL_PROJTYPE, CProjType::dynamiclib, /* props */
					szAddOnx86, BCID_Platform_Mips) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageDLL | TargetIsDebugable;}
};

class CProjTypeWin32MIPSCon : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32MIPSCon)

public:
	CProjTypeWin32MIPSCon()
		: CProjType(szAddOnx86, BCID_ProjType_MipsCon, /* id */
					IDS_WIN32CON_PROJTYPE, CProjType::consoleapp, /* props */
					szAddOnx86, BCID_Platform_Mips) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageExe | SubsystemConsole | TargetIsDebugable;}
	UINT GetUseMFCDefault() {return NoUseMFC;}
};

class CProjTypeWin32MIPSLib : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32MIPSLib)

public:
	CProjTypeWin32MIPSLib()
		: CProjType(szAddOnx86, BCID_ProjType_MipsLib, /* id */
					IDS_WIN32LIB_PROJTYPE, CProjType::staticlib, /* props */
					szAddOnx86, BCID_Platform_Mips) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageStaticLib | TargetIsDebugable;}
};

#endif // _INCLUDE_PLATFORM_MIPS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\optnrc.cpp ===
// 
// Resource Compiler Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop

#include "optnrc.h"	// our local header file
#include "project.h"

BEGIN_OPTSTR_TABLE(ResCompiler, P_ResUnknownOption, P_ResUnknownString, P_ResVerbose, P_ResUnknownString, FALSE)
	IDOPT_RESLANGID,		"l[ ]%1",	OPTARGS1(P_ResLangID),		single,
	IDOPT_DERIVED_OPTHDLR,		"",		NO_OPTARGS,					single,
	IDOPT_RESVERBOSE,		"v%T1",		OPTARGS1(P_ResVerbose),		single,
	IDOPT_RESIGNINC,		"x%T1",		OPTARGS1(P_ResIgnInCPath), 	single,
	IDOPT_OUTDIR_RES,		"fo%1",		OPTARGS1(P_OutNameRes),		single,
	IDOPT_RESINCLUDES,		"i[ ]%1",	OPTARGS1(P_ResIncludes),	multiple,
	IDOPT_RESMACROS,		"d[ ]%1",	OPTARGS1(P_ResMacroNames),	multiple,
	IDOPT_RES_INPUT_EXT,	"",			OPTARGS1(P_Res_Input_Ext),	single,
	IDOPT_UNKNOWN_OPTION,	"",			NO_OPTARGS,					single,
	IDOPT_UNKNOWN_STRING,	"",			NO_OPTARGS,					single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(ResCompiler)
	OPTDEF_BOOL(ResVerbose, FALSE)
	OPTDEF_BOOL(ResIgnInCPath, FALSE)
	OPTDEF_PATH(OutNameRes, "")
	OPTDEF_DIR_LIST(ResIncludes, "")
	OPTDEF_LIST(ResMacroNames, "")
	OPTDEF_STRING(Res_Input_Ext, "*.rc")
	OPTDEF_HEX(ResLangID, 0x00)
END_OPTDEF_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CRCCompilerTool, CBuildTool)
IMPLEMENT_DYNAMIC(CRCCompilerNTTool, CRCCompilerTool)

////////////////////////////////////////////////////
// GetOutputExtension
//		returns the RC output extension, depending on the platform
//		(ie: MAC's is rsc and NT's is res
////////////////////////////////////////////////////
BOOL OLD_OPTION_HANDLER(ResCompiler)::AlwaysShowDefault(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_ResLangID);
}

BOOL OLD_OPTION_HANDLER(ResCompiler)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fValid = TRUE;			// valid by default

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// only do this if language enabled for the item's platform
		case P_ResLangID:
		{
			CProjType * pProjType = ((CProjItem *)m_pSlob)->GetProjType();
			if (pProjType != (CProjType *)NULL)
			{
				const CPlatform * pPlatform = pProjType->GetPlatform();
				VSASSERT (pPlatform != NULL, "No platform for project type!");

				fValid = ((pPlatform->GetAttributes() & PIA_Enable_Language) != 0);
			}
			break;
		}

		default:
			break;
	}

	return fValid;
}

const CString  * OLD_OPTION_HANDLER(ResCompiler)::GetOutputExtension()
{
	CProjType * pProjType = ((CProjItem *)m_pSlob)->GetProjType();
	if (pProjType != (CProjType *)NULL)
	{
		const CPlatform * pPlatform = pProjType->GetPlatform();
		VSASSERT (pPlatform != NULL, "No platform for project type!");
		return &((pPlatform->GetToolInfo())->strRCExtension);
	}
	else
		return (const CString *)NULL;
}

// resource compiler tool option default map 'faking'
BOOL OLD_OPTION_HANDLER(ResCompiler)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_Res_Input_Ext || idPropL == P_ResIncludes || idPropL == P_ResLangID);
}

UINT OLD_OPTION_HANDLER(ResCompiler)::GetFakePathDirProp(UINT idProp)
{
	return COptionHandler::GetFakePathDirProp(idProp);
} 

BOOL OLD_OPTION_HANDLER(ResCompiler)::IsDefaultStringProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// if we say that a non-empty default resource includes list (caused when the rc file is in a different
	// directory than the dsp file) is the default, we get ourselves into all kinds of trouble.
	// Therefore, when asked about a non-empty res include value, we automagically say that it is *not* the default
	if (idPropL == P_ResIncludes)
		return strVal.IsEmpty();

	return COptionHandler::IsDefaultStringProp(idProp, strVal);
}

void OLD_OPTION_HANDLER(ResCompiler)::FormFakeIntProp(UINT idProp, int & nVal)
{
	// Assert this is a Resource Compiler 'fake' string prop?
	VSASSERT(IsFakeProp(idProp), "FormFakeIntProp called with non-fake prop!");

	nVal = GetUserDefaultLangID();
	return;
}

GPT OLD_OPTION_HANDLER(ResCompiler)::GetDefIntProp(UINT idProp, int & nVal)
{
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefIntProp(idProp, nVal);

	FormFakeIntProp(idProp, nVal);
	return valid;
}

void OLD_OPTION_HANDLER(ResCompiler)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
}

void OLD_OPTION_HANDLER(ResCompiler)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// Assert this a Resource Compiler 'fake' string prop?
	VSASSERT(IsFakeProp(idProp), "FormFakeStrProp called with non-fake prop!");

	if (idPropL == P_Res_Input_Ext)
	{
		// make sure the project is in our config.
		CProjItem * pItem = (CProjItem *)m_pSlob;
		CProjTempConfigChange projTempConfigChange(pItem->GetProject());
		projTempConfigChange.ChangeConfig((CConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord);

		CConfigurationRecord * pcr = (CConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord;
		CString strToolName = _TEXT("rc.exe");
		CString strExtList;
		pcr->GetExtListFromToolName(strToolName, &strExtList);
		if(strExtList)
		{
			strVal = strExtList;
		}
		return;

	}
	else if (idPropL == P_ResIncludes && m_pSlob->IsKindOf (RUNTIME_CLASS(CFileItem)))
	{
		CFileItem * pFileItem = (CFileItem *)m_pSlob;

		const CPath * pPathRC = pFileItem->GetFilePath();
		CDir dirRC; dirRC.CreateFromPath(*pPathRC);

		CDir dirProj = pFileItem->GetProject()->GetWorkspaceDir();

		CString strProj = dirProj;
		strProj += _T('\\');
		
		if (dirRC != dirProj)
			strVal = GetRelativeName(dirRC, strProj);
		else
			strVal.Empty();

		// now we want to add target directory, but iff we've got ODL files to worry about
		CProject* pProject = pFileItem->GetProject();
		if (pProject)
		{
			if (pProject->m_bHaveODLFiles)
			{
				CString strTarget;
				CProjItem * pItem = pFileItem;

				// which output directory do we want to use?
				UINT idOutDirProp = P_OutDirs_Target;	// note: hard-coded

				GPT gpt = pItem->GetStrProp(idOutDirProp, strTarget);
				while (gpt != valid)
				{
					// *chain* the proper. config.
					CProjItem * pItemOld = pItem;
					pItem = (CProjItem *)pItem->GetContainerInSameConfig();
					if (pItemOld != m_pSlob)
						pItemOld->ResetContainerConfig();

					VSASSERT(pItem != (CSlob *)NULL, "Item's container is NULL!!!");
					gpt = pItem->GetStrProp(idOutDirProp, strTarget);
				}

				// reset the last container we found
				if (pItem != m_pSlob)
					pItem->ResetContainerConfig();

				if (gpt == valid)
				{
					if (!strVal.IsEmpty())
						strVal += _T(',');
					strVal += strTarget;
				}
			}
		}
	}

}

GPT OLD_OPTION_HANDLER(ResCompiler)::GetDefStrProp(UINT idProp, CString & val)
{
	// can we ignore the output directories?
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefStrProp(idProp, val);

	FormFakeStrProp(idProp, val);
	return valid;
}

BEGIN_OPTSTR_TABLE(ResCompilerNT, (UINT)NULL, (UINT)NULL, (UINT)NULL, (UINT)NULL, FALSE)
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(ResCompilerNT)
END_OPTDEF_MAP()

///////////////////////////////////////////////////////////////////////////////
//
// ----------------------------- CRCCompilerTool ------------------------------
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
CRCCompilerTool::CRCCompilerTool() : CBuildTool()
{
	m_strToolInput = _TEXT("*.rc");
	m_strToolPrefix = _TEXT("RSC");
	m_strName = _TEXT("rc.exe");
}	

///////////////////////////////////////////////////////////////////////////////
BOOL CRCCompilerNTTool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platalf.cpp ===
//
// Alpha (RISC) Platform
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"     // our standard AFX include
#pragma hdrstop
#include "platalf.h"    // our local header file

IMPLEMENT_DYNAMIC(CProjTypeWin32ALPHAExe, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32ALPHADll, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32ALPHACon, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32ALPHALib, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// declare our platform
//
// *** DO NOT TRANSLATE (LOCALIZE) THE PLATFORM STRINGS HERE ***

PlatformInfo g_PlatformInfoWin32ALPHA =
{
    _T("Win32 (ALPHA)"),            // Official platform name -- DO NOT LOCALIZE!
    win32alpha,                     // Unique ID
#if defined (_ALPHA_)
    IDS_WIN32_PLATFORM,             // Localizable description string
#else
    IDS_WIN32ALPHA_PLATFORM,        // Localizable description string
#endif
    IDS_WIN32ALPHA_PLATFORM_SHORT,  // Abbreviated localizable description string
    _T("res"),                      // RC extension
#if defined (_ALPHA_)
    PIA_Primary_Platform |          // Primary platform
#endif
    PIA_Allow_WorkingDir |          // Can use a working dir. for debugging
    PIA_Supports_RTTI |         // Supports RTTI
    PIA_Enable_Language |               // Enable Language for RC option
    PIA_Supports_IncLink|      		 // Supports ilink
    PIA_Allow_ProgArgs |            // Executable can use program arguments for Debug etc.
    PIA_Allow_MFCinDLL|             // Allow use of mfc in a dll
    PIA_Enable_Stub|                // Allow DOS Stub
    PIA_Supports_RemoteDbg |		// Supports remote debugging
    PIA_Enable_AllDebugType,        // Allow Debug Types
    // Enable this when the platform fully supports edit & continue
    //PIA_Supports_ENC|           // Supports Edit & Continue
    NoUseMFC,                       // Default is not using MFC
    _T("Alpha")                     // Default output directories
};

// implementation

// pre-installed components
#include "optnbsc.h"
#include "optnrc.h"
#include "optnmtl.h"
#include "optnlib.h"

// 'our' components

void VPROJDeriveDefaultCplrOptionsAXP(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_CPLR_COMMON, fDebug ? IDS_WIN32_CPLR_DBG : IDS_WIN32_CPLR_REL, nIDOption);
}

// derive the linker options by adding in 'common part' + 'config. part' + 'win32 libraries'
void VPROJDeriveDefaultWin32ALPHALinkOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_LINK_ALPHA_COMMON, fDebug ? IDS_WIN32_LINK_DBG : IDS_WIN32_LINK_REL, nIDOption);

    CString strXtraLibs;
    BOOL bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS_CORE);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
    bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
    bOK = strXtraLibs.LoadString(IDS_OLE2_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
}

void VPROJDeriveDefaultRcOptionsAXP(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_RC_COMMON, fDebug ? IDS_WIN32_RC_DBG : IDS_WIN32_RC_REL, nIDOption);
}

void VPROJDeriveDefaultBscMakeOptionsAXP(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_BSCMAKE_COMMON, fDebug ? IDS_WIN32_BSCMAKE_DBG : IDS_WIN32_BSCMAKE_REL, nIDOption);
}

void VPROJDeriveDefaultLibOptionsAXP(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    // the library manager options have no common, debug or release parts!
    BOOL bOK = strOption.LoadString(nIDOption);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
}

BOOL CProjTypeWin32ALPHAExe::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
 	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the Alpha compiler
            case BCID_Tool_Compiler_Alpha:
                VPROJDeriveDefaultCplrOptionsAXP(strOption, fDebug, fDebug ? IDS_WIN32ALPHAEXE_CPLR_DBG : IDS_WIN32ALPHAEXE_CPLR_REL);
                break;

            // the Alpha COFF linker
            case BCID_Tool_Linker_Alpha:
                VPROJDeriveDefaultWin32ALPHALinkOptions(strOption, fDebug, IDS_WIN32EXE_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsAXP(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsAXP(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32ALPHA_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32ALPHADll::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the Alpha compiler
            case BCID_Tool_Compiler_Alpha:
                VPROJDeriveDefaultCplrOptionsAXP(strOption, fDebug, fDebug ? IDS_WIN32ALPHADLL_CPLR_DBG : IDS_WIN32ALPHADLL_CPLR_REL);
                break;

            // the Alpha COFF linker
            case BCID_Tool_Linker_Alpha:
                VPROJDeriveDefaultWin32ALPHALinkOptions(strOption, fDebug, IDS_WIN32DLL_LINK);
                break;

             // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32ALPHA_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

           default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsAXP(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsAXP(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32ALPHA_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32ALPHACon::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the Alpha compiler
            case BCID_Tool_Compiler_Alpha:
                VPROJDeriveDefaultCplrOptionsAXP(strOption, fDebug, fDebug ? IDS_WIN32ALPHACON_CPLR_DBG : IDS_WIN32ALPHACON_CPLR_REL);
                break;

            // the Alpha COFF linker
            case BCID_Tool_Linker_Alpha:
                VPROJDeriveDefaultWin32ALPHALinkOptions(strOption, fDebug, IDS_WIN32CON_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsAXP(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsAXP(strOption, fDebug, UINT(-1));
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32ALPHALib::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the Alpha compiler
            case BCID_Tool_Compiler_Alpha:
                VPROJDeriveDefaultCplrOptionsAXP(strOption, fDebug, fDebug ? IDS_WIN32ALPHALIB_CPLR_DBG : IDS_WIN32ALPHALIB_CPLR_REL);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF library manager
            case BCID_Tool_Lib:
                VPROJDeriveDefaultLibOptionsAXP(strOption, fDebug, IDS_WIN32LIB_LINK);
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsAXP(strOption, fDebug, UINT(-1));
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32ALPHAExe::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_Alpha);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin32ALPHADll::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_Alpha);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin32ALPHACon::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_Alpha);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin32ALPHALib::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnGeneric, BCID_Tool_Lib);

    return TRUE;    // success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platmrcd.cpp ===
//
// Merced (RISC) Platform
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"     // our standard AFX include
#pragma hdrstop
#include "platmrcd.h"    // our local header file

IMPLEMENT_DYNAMIC(CProjTypeWin64MERCEDExe, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin64MERCEDDll, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin64MERCEDCon, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin64MERCEDLib, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// declare our platform
//
// *** DO NOT TRANSLATE (LOCALIZE) THE PLATFORM STRINGS HERE ***

PlatformInfo g_PlatformInfoWin64MERCED =
{
    _T("Win64 (MERCED)"),            // Official platform name -- DO NOT LOCALIZE!
    win64merced,                     // Unique ID
#if defined (_MERCED_)
    IDS_WIN64_PLATFORM,             // Localizable description string
#else
    IDS_WIN64MERCED_PLATFORM,        // Localizable description string
#endif
    IDS_WIN64MERCED_PLATFORM_SHORT,  // Abbreviated localizable description string
    _T("res"),                      // RC extension
#if defined (_MERCED_)
    PIA_Primary_Platform |          // Primary platform
#endif
    PIA_Allow_WorkingDir |          // Can use a working dir. for debugging
    PIA_Supports_RTTI |         // Supports RTTI
    PIA_Enable_Language |               // Enable Language for RC option
    PIA_Supports_IncLink|      		 // Supports ilink
    PIA_Allow_ProgArgs |            // Executable can use program arguments for Debug etc.
    PIA_Allow_MFCinDLL|             // Allow use of mfc in a dll
    PIA_Enable_Stub|                // Allow DOS Stub
    PIA_Supports_RemoteDbg |		// Supports remote debugging
    PIA_Enable_AllDebugType,        // Allow Debug Types
    // Enable this when the platform fully supports edit & continue
    //PIA_Supports_ENC|           // Supports Edit & Continue
    NoUseMFC,                       // Default is not using MFC
    _T("Merced")                     // Default output directories
};

// implementation

// pre-installed components
#include "optnbsc.h"
#include "optnrc.h"
#include "optnmtl.h"
#include "optnlib.h"

// 'our' components

void VPROJDeriveDefaultCplrOptionsMERCED(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_CPLR_COMMON, fDebug ? IDS_WIN32_CPLR_DBG : IDS_WIN32_CPLR_REL, nIDOption);
}

// derive the linker options by adding in 'common part' + 'config. part' + 'win32 libraries'
void VPROJDeriveDefaultWIN64MERCEDLinkOptions(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_LINK_MERCED_COMMON, fDebug ? IDS_WIN32_LINK_DBG : IDS_WIN32_LINK_REL, nIDOption);

    CString strXtraLibs;
    BOOL bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS_CORE);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
    bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
    bOK = strXtraLibs.LoadString(IDS_OLE2_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
}

void VPROJDeriveDefaultRcOptionsMERCED(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_RC_COMMON, fDebug ? IDS_WIN32_RC_DBG : IDS_WIN32_RC_REL, nIDOption);
}

void VPROJDeriveDefaultBscMakeOptionsMERCED(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_BSCMAKE_COMMON, fDebug ? IDS_WIN32_BSCMAKE_DBG : IDS_WIN32_BSCMAKE_REL, nIDOption);
}

void VPROJDeriveDefaultLibOptionsMERCED(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    // the library manager options have no common, debug or release parts!
    BOOL bOK = strOption.LoadString(nIDOption);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
}

BOOL CProjTypeWin64MERCEDExe::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the Merced compiler
            case BCID_Tool_Compiler_Merced:
                VPROJDeriveDefaultCplrOptionsMERCED(strOption, fDebug, fDebug ? IDS_WIN64MERCEDEXE_CPLR_DBG : IDS_WIN64MERCEDEXE_CPLR_REL);
                break;

            // the Merced COFF linker
            case BCID_Tool_Linker_Merced:
                VPROJDeriveDefaultWIN64MERCEDLinkOptions(strOption, fDebug, IDS_WIN32EXE_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsMERCED(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsMERCED(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN64MERCED_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin64MERCEDDll::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the Merced compiler
            case BCID_Tool_Compiler_Merced:
                VPROJDeriveDefaultCplrOptionsMERCED(strOption, fDebug, fDebug ? IDS_WIN64MERCEDDLL_CPLR_DBG : IDS_WIN64MERCEDDLL_CPLR_REL);
                break;

            // the Merced COFF linker
            case BCID_Tool_Linker_Merced:
                VPROJDeriveDefaultWIN64MERCEDLinkOptions(strOption, fDebug, IDS_WIN32DLL_LINK);
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN64MERCED_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsMERCED(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsMERCED(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN64MERCED_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin64MERCEDCon::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
