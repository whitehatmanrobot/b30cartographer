;                                              \
} NVDESCRIPTOR;
#endif


/* function NvClose() */
#define NVCLOSE_ERROR_OK                                 (0x0000)
#define NVCLOSE_ERROR_UNSUCCESSFUL                       (0x0001)



 /***************************************************************************\
|*                               NV OS Ioctls                                *|
 \***************************************************************************/


/* ioctl Nv1GetDeviceOsName() */
#define NV0001_ERROR_OK                                  (0x0000)
#define NV0001_ERROR_NONEXISTENT_DEVICE                  (0x0001)
#define NV0001_ERROR_INSUFFICIENT_RESOURCES              (0x0002)
typedef struct 
{
	U016 devInstance;
	U032 nameBuffer;
	U016 maxNameLength;
	U016 nvStatus;
} NV1_GET_DEVICE_OS_NAME_STRUCT;


/* ioctl Nv1FreeMemory() */
#define NV000F_ERROR_OK                                  (0x0000)
#define NV000F_ERROR_INVALID_ADDRESS                     (0x0001)
typedef struct 
{
	U032 pMemory;
	U016 nvStatus;
} NV1_FREE_MEMORY_STRUCT;

/* ioctl Nv1FreeContextDma() */
#define NV0003_ERROR_OK                                  (0x0000)
#define NV0003_ERROR_INVALID_CONTEXT                     (0x0001)
typedef struct 
{
	U032 id;
	U016 nvStatus;
} NV1_FREE_CONTEXT_DMA_STRUCT;

/* ioctl Nv3FreeChannelPio() */
#define NV0009_ERROR_OK                                  (0x0000)
#define NV0009_ERROR_INVALID_CHANNEL                     (0x0001)
typedef struct 
{
	U016 devInstance;
	U032 pChannel;
	U016 nvStatus;
} NV3_FREE_CHANNEL_PIO_STRUCT;

/* ioctl Nv1FreeObject() */
#define NVFFF1_ERROR_OK                                  (0x0000)
#define NVFFF1_ERROR_INVALID_CONTEXT                     (0x0001)
typedef struct 
{
	U032 id;
	U016 nvStatus;
} NV1_FREE_OBJECT_STRUCT;

/* ioctl Nv4FreeChannelDma() */
typedef struct 
{
	U016 devInstance;
	U032 pChannel;
	U016 nvStatus;
} NV3_FREE_CHANNEL_DMA_STRUCT;

/* ioctl Nv4FreeChannelDma() */
typedef struct 
{
	U016 devInstance;
	U032 pChannel;
	U016 nvStatus;
} NV4_FREE_CHANNEL_DMA_STRUCT;

typedef struct 
{
	U032 hCallback;
	U016 nvStatus;
} NV1_FREE_CALLBACK_STRUCT;

typedef struct 
{
	U032 hMessage;
	U016 nvStatus;
} NV1_FREE_WIN32_MESSAGE_STRUCT;


/* ioctl Nv1AllocMemory() */
#define NV000E_ERROR_OK                                  (0x0000)
#define NV000E_ERROR_UNKNOWN_TYPE                        (0x0001)
#define NV000E_ERROR_UNSUCCESSFUL                        (0x0002)
typedef struct 
{
	U032 name;
	U032 pMemory;
	U032 limit;
	U016 nvStatus;
} NV1_ALLOC_MEMORY_STRUCT;


/* ioctl Nv1AllocContextDma() */
#define NV0002_CONTEXT_DMA_LOCK_DOWN                     (0x0000)
#define NV0002_CONTEXT_DMA_IN_TRANSIT                    (0x0001)
#define NV0002_CONTEXT_DMA_CACHED                        (0x0000)
#define NV0002_CONTEXT_DMA_UNCACHED                      (0x0002)
#define NV0002_CONTEXT_DMA_WRITE_COMBINED                (0x0000)
#define NV0002_CONTEXT_DMA_NOT_WRITE_COMBINED            (0x0004)
#define NV0002_ERROR_OK                                  (0x0000)
#define NV0002_ERROR_CREATE                              (0x0001)
#define NV0002_ERROR_INVALID_CLASS                       (0x0002)
#define NV0002_ERROR_INVALID_ID                          (0x0003)
#define NV0002_ERROR_INVALID_LIMIT                       (0x0004)
typedef struct 
{
	U032 id;
	V032 class;
	U032 base;
	U032 limit;
	U016 flags;
	U016 nvStatus;
} NV1_ALLOC_CONTEXT_DMA_STRUCT;


/* ioctl Nv3AllocChannelPio() */
#define NV0008_ERROR_OK                                  (0x0000)
#define NV0008_ERROR_MAPPING                             (0x0001)
#define NV0008_ERROR_MAX_CHANNELS                        (0x0002)
#define NV0008_ERROR_INVALID_CONTEXT                     (0x0003)
#define NV0008_ERROR_UNUSABLE_CONTEXT                    (0x0004)
#define NV0008_ERROR_CONTEXT_ERROR_IN_USE                (0x0005)
typedef struct 
{
	U016 devInstance;
	U032 idDmaContextErrorToMemory;
	U032 pChannel;
	U016 nvStatus;
} NV3_ALLOC_CHANNEL_PIO_STRUCT;


/* ioctl NV1_ALLOC_OBJECT */
#define  NV1_ALLOC_OBJECT                                (0x00000005)
/* parameters */
typedef struct
{
  V032 hObject;
  V032 hChannel;
  V032 hClass;
  V032 status;
} NVOS05_PARAMETERS;
/* parameter values */
#define NVOS05_STATUS_SUCCESS                            (0x00000000)
#define NVOS05_STATUS_ERROR_OPERATING_SYSTEM             (0x00000001)
#define NVOS05_STATUS_ERROR_BAD_OBJECT                   (0x00000002)
#define NVOS05_STATUS_ERROR_BAD_CHANNEL                  (0x00000003)
#define NVOS05_STATUS_ERROR_BAD_CLASS                    (0x00000004)
#define NVOS05_STATUS_ERROR_INSUFFICIENT_RESOURCES       (0x00000005)

/* macro for NT Mini-Port drivers */
#ifdef NTMINIPORT
#define Nv1AllocObject(descriptor, pParameters)                               \
{                                                                             \
    NTSTATUS ioStatus;                                                        \
    PIRP pIrp;                                                                \
    pIrp = IoBuildDeviceIoControlRequest(                                     \
        (ULONG)NV1_ALLOC_OBJECT,                                              \
        (descriptor).pDeviceObject,                                           \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS05_PARAMETERS),                                     \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS05_PARAMETERS),                                     \
        FALSE,                                                                \
        NULL,                                                                 \
        NULL);                                                                \
    if (pIrp!=NULL)                                                           \
        ioStatus = IoCallDriver(                                              \
            (descriptor).pDeviceObject,                                       \
            pIrp);                                                            \
    if (pIrp==NULL || !NT_SUCCESS(ioStatus))                                  \
        (pParameters)->status = NVOS05_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Win32 drivers */
#ifdef WIN32
#include <winbase.h>
#define Nv1AllocObject(descriptor, pParameters)                               \
{                                                                             \
    BOOL ioStatus;                                                            \
    DWORD bytesReturned;                                                      \
    ioStatus = DeviceIoControl(                                               \
        (HANDLE)(descriptor),                                                 \
        (DWORD)NV1_ALLOC_OBJECT,                                              \
        (LPVOID)(pPararmeters));                                              \
        (DWORD)sizeof(NVOS05_PARAMETERS),                                     \
        (LPVOID)(pParameters),                                                \
        (DWORD)sizeof(NVOS05_PARAMETERS),                                     \
        (LPDWORD)&bytesReturned,                                              \
        NULL);                                                                \
    if (ioStatus == FALSE)                                                    \
        (pParameters)->status = NVOS05_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Sun Solaris 1.0 and 2.0 drivers */
#if defined(SUNOS41) || defined(SYSV)
#ifdef SYSV
#include <unistd.h>
#endif
#include <sys/ioctl.h>
#define Nv1AllocObject(descriptor, pParameters)                               \
{                                                                             \
    int ioStatus;                                                             \
    ioStatus = ioctl(                                                         \
        (descriptor),                                                         \
        _IOWR(F, NV1_ALLOC_OBJECT, NVOS05_PARAMETERS),                        \
        (caddr_t)(pPararmeters));                                             \
    if (ioStatus == -1)                                                       \
        (pParameters)->status = NVOS05_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif


typedef struct 
{
	U032 name;
	U032 hCallback;
	U016 nvStatus;
} NV1_ALLOC_CALLBACK_STRUCT;

typedef struct 
{
	U032 name;
	U032 hMessage;
	U016 nvStatus;
} NV1_ALLOC_WIN32_MESSAGE_STRUCT;


/* ioctl NV3_ALLOC_CHANNEL_DMA */
#define  NV3_ALLOC_CHANNEL_DMA                           (0x00000007)
/* parameters */
typedef struct
{
  V032 hObject;
  V032 hDevice;
  V032 hClass;
  V032 hError;
  V032 hBuffer;
  U032 offset;
  P064 pChannel;
  V032 status;
} NVOS07_PARAMETERS;
/* parameter values */
#define NVOS07_STATUS_SUCCESS                            (0x00000000)
#define NVOS07_STATUS_ERROR_OPERATING_SYSTEM             (0x00000001)
#define NVOS07_STATUS_ERROR_BAD_OBJECT                   (0x00000002)
#define NVOS07_STATUS_ERROR_BAD_DEVICE                   (0x00000003)
#define NVOS07_STATUS_ERROR_BAD_CLASS                    (0x00000004)
#define NVOS07_STATUS_ERROR_BAD_ERROR                    (0x00000005)
#define NVOS07_STATUS_ERROR_BAD_BUFFER                   (0x00000006)
#define NVOS07_STATUS_ERROR_BAD_OFFSET                   (0x00000007)
#define NVOS07_STATUS_ERROR_INSUFFICIENT_RESOURCES       (0x00000008)

/* macro for NT Mini-Port drivers */
#ifdef NTMINIPORT
#define Nv3AllocChannelDma(descriptor, pParameters)                           \
{                                                                             \
    NTSTATUS ioStatus;                                                        \
    PIRP pIrp;                                                                \
    pIrp = IoBuildDeviceIoControlRequest(                                     \
        (ULONG)NV3_IOCTL_ALLOC_CHANNEL_DMA,                                         \
        (descriptor).pDeviceObject,                                           \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS07_PARAMETERS),                                     \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS07_PARAMETERS),                                     \
        FALSE,                                                                \
        NULL,                                                                 \
        NULL);                                                                \
    if (pIrp!=NULL)                                                           \
        ioStatus = IoCallDriver(                                              \
            (descriptor).pDeviceObject,                                       \
            pIrp);                                                            \
    if (pIrp==NULL || !NT_SUCCESS(ioStatus))                                  \
        (pParameters)->status = NVOS07_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Win32 drivers */
#ifdef WIN32
#include <winbase.h>
#define Nv3AllocChannelDma(descriptor, pParameters)                           \
{                                                                             \
    BOOL ioStatus;                                                            \
    DWORD bytesReturned;                                                      \
    ioStatus = DeviceIoControl(                                               \
        (HANDLE)(descriptor),                                                 \
        (DWORD)NV3_ALLOC_CHANNEL_DMA,                                         \
        (LPVOID)(pPararmeters));                                              \
        (DWORD)sizeof(NVOS07_PARAMETERS),                                     \
        (LPVOID)(pParameters),                                                \
        (DWORD)sizeof(NVOS07_PARAMETERS),                                     \
        (LPDWORD)&bytesReturned,                                              \
        NULL);                                                                \
    if (ioStatus == FALSE)                                                    \
        (pParameters)->status = NVOS07_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Sun Solaris 1.0 and 2.0 drivers */
#if defined(SUNOS41) || defined(SYSV)
#ifdef SYSV
#include <unistd.h>
#endif
#include <sys/ioctl.h>
#define Nv3AllocChannelDma(descriptor, pParameters)                           \
{                                                                             \
    int ioStatus;                                                             \
    ioStatus = ioctl(                                                         \
        (descriptor),                                                         \
        _IOWR(F, NV3_ALLOC_CHANNEL_DMA, NVOS07_PARAMETERS),                   \
        (caddr_t)(pPararmeters));                                             \
    if (ioStatus == -1)                                                       \
        (pParameters)->status = NVOS07_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif


/* ioctl NV3_DMA_FLOW_CONTROL */
#define  NV3_DMA_FLOW_CONTROL                            (0x00000008)
/* parameters */
typedef struct
{
  V032 hChannel;
  V032 flags;
  U032 put;
  U032 get;
  V032 status;
} NVOS08_PARAMETERS;
/* parameter values */
#define NVOS08_FLAGS_READ_GET                            (0x00000000)
#define NVOS08_FLAGS_WRITE_PUT_READ_GET                  (0x00000001)
#define NVOS08_FLAGS_SET_JUMP_WRITE_PUT_READ_GET         (0x00000002)
#define NVOS08_STATUS_SUCCESS                            (0x00000000)
#define NVOS08_STATUS_ERROR_OPERATING_SYSTEM             (0x00000001)
#define NVOS08_STATUS_ERROR_BAD_CHANNEL                  (0x00000002)
#define NVOS08_STATUS_ERROR_BAD_FLAGS                    (0x00000003)
#define NVOS08_STATUS_ERROR_BAD_JUMP                     (0x00000004)
#define NVOS08_STATUS_ERROR_BAD_PUT                      (0x00000005)
#define NVOS08_STATUS_ERROR_BAD_GET                      (0x00000006)

/* macro for NT Mini-Port drivers */
#ifdef NTMINIPORT
#define Nv3DmaFlowControl(descriptor, pParameters)                            \
{                                                                             \
    NTSTATUS ioStatus;                                                        \
    PIRP pIrp;                                                                \
    pIrp = IoBuildDeviceIoControlRequest(                                     \
        (ULONG)NV3_IOCTL_DMA_FLOW_CONTROL,                                          \
        (descriptor).pDeviceObject,                                           \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS08_PARAMETERS),                                     \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NVOS08_PARAMETERS),                                     \
        FALSE,                                                                \
        NULL,                                                                 \
        NULL);                                                                \
    if (pIrp!=NULL)                                                           \
        ioStatus = IoCallDriver(                                              \
            (descriptor).pDeviceObject,                                       \
            pIrp);                                                            \
    if (pIrp==NULL || !NT_SUCCESS(ioStatus))                                  \
        (pParameters)->status = NVOS08_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Win32 drivers */
#ifdef WIN32
#include <winbase.h>
#define Nv3DmaFlowControl(descriptor, pParameters)                            \
{                                                                             \
    BOOL ioStatus;                                                            \
    DWORD bytesReturned;                                                      \
    ioStatus = DeviceIoControl(                                               \
        (HANDLE)(descriptor),                                                 \
        (DWORD)NV3_DMA_FLOW_CONTROL,                                          \
        (LPVOID)(pPararmeters));                                              \
        (DWORD)sizeof(NVOS08_PARAMETERS),                                     \
        (LPVOID)(pParameters),                                                \
        (DWORD)sizeof(NVOS08_PARAMETERS),                                     \
        (LPDWORD)&bytesReturned,                                              \
        NULL);                                                                \
    if (ioStatus == FALSE)                                                    \
        (pParameters)->status = NVOS08_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* macro for Sun Solaris 1.0 and 2.0 drivers */
#if defined(SUNOS41) || defined(SYSV)
#ifdef SYSV
#include <unistd.h>
#endif
#include <sys/ioctl.h>
#define Nv3DmaFlowControl(descriptor, pParameters)                            \
{                                                                             \
    int ioStatus;                                                             \
    ioStatus = ioctl(                                                         \
        (descriptor),                                                         \
        _IOWR(F, NV3_DMA_FLOW_CONTROL, NVOS08_PARAMETERS),                    \
        (caddr_t)(pPararmeters));                                             \
    if (ioStatus == -1)                                                       \
        (pParameters)->status = NVOS08_STATUS_ERROR_OPERATING_SYSTEM;          \
}
#endif

/* ioctl NV3_DMA_PUSH_MUTEX_STATE */
#define  NV3_DMA_PUSH_MUTEX_STATE                        (0x00000009)
/* parameters */
typedef struct
{
  U032 mutexState;
  U016 nvStatus;
} NV3_DMA_PUSH_MUTEX_STATE_STRUCT;
/* parameter values */
#define NV3_DMA_PUSH_MUTEX_STATE_FALSE                   (0x00000000)
#define NV3_DMA_PUSH_MUTEX_STATE_TRUE                    (0x00000000)
#define NV3_DMA_PUSH_MUTEX_STATE_STATUS_SUCCESS          (0x00000000)

/* only available from the mini-port driver */
/* macro for NT Mini-Port drivers */
#ifdef NTMINIPORT
#define Nv3DmaPushMutexState(descriptor, pParameters)                         \
{                                                                             \
    NTSTATUS ioStatus;                                                        \
    PIRP pIrp;                                                                \
    pIrp = IoBuildDeviceIoControlRequest(                                     \
        (ULONG)NV3_IOCTL_DMA_PUSH_MUTEX_STATE,                                \
        (descriptor).pDeviceObject,                                           \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NV3_DMA_PUSH_MUTEX_STATE),                              \
        (PVOID)(pParameters),                                                 \
        (ULONG)sizeof(NV3_DMA_PUSH_MUTEX_STATE),                              \
        FALSE,                                                                \
        NULL,                                                                 \
        NULL);                                                                \
    if (pIrp!=NULL)                                                           \
        ioStatus = IoCallDriver(                                              \
            (descriptor).pDeviceObject,                                       \
            pIrp);                                                            \
    if (pIrp==NULL || !NT_SUCCESS(ioStatus))                                  \
        (pParameters)->status = NV3_DMA_PUSH_MUTEX_STATE_STATUS_SUCCESS;      \
}
#endif

/* ioctl OS09 */

/* ioctl OS0A */

/* ioctl OS0B */

/* ioctl OS0C */

/* ioctl OS0D */

/* ioctl OS0E */

/* ioctl OS0F */



#ifdef __cplusplus
};
#endif
#endif /* NVOS_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\nv4\inc\nvWin32.h ===
#ifndef NVWIN32_INCLUDED
#define NVWIN32_INCLUDED
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for NvChannel typedef */
#endif

/***************************************************************************
 *                   NVIDIA-supplied routines                              *
 ***************************************************************************/

/***** Hardware access *****/

/*
 * NvOpen() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpen(char *);

/*
 * NvOpenDma() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpenDma(char *, int, int, int);

/*
 * NvClose() closes the channel to the chip and attempts to
 * clean up all objects created in that channel.
 */
extern int                  __stdcall NvClose(NvChannel *);

/***** Operating Environment routines *****/
/*
 * NvWait() waits to be "awakened" after requesting notification with
 * the NV_OS_NOTIFY_WILL_SLEEP style.
 * Note that in Windows 3.1 any Windows message will wake up the
 * application.
 */
extern int  __stdcall NvWait(NvChannel *);

/*
 * NvNotifyEvent() specifies a Windows event for NV to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_EVENT style.
 *    first parameter is the NvChannel
 *    second is the Ring0 Win32 event handle
 */
extern int  __stdcall NvNotifyEvent(NvChannel *, int);

/*
 * NvNotifyMsg() specifies a Windows message for NV1 to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_MESSAGE style.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvNotifyMsg(NvChannel *, int, int);

/*
 * NvAllocEvent() specifies a Windows event or callback for NV to send to the
 * application after requesting notifications with the
 * NV_OS_WRITE_THEN_AWAKEN style.
 *    first parameter is the NvChannel
 *    second is the object name
 *    third is the notify index
 *    fourth is the notify event type (NV_OS_EVENT_*)
 *    fifth is the lower 32bits of the 64bit event data
 *    sixth is the upper 32bits of the 64bit event data
 */
extern int  __stdcall NvAllocEvent(NvChannel *, int, int, int, int, int);

/*
 * NvErrorMsg() specifies a Windows message for NV to send to the
 * application upon detecting an error.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvErrorMsg(NvChannel *, int, int);

/*
 * Although Win32 applications have a flat address space, on the X86 
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
extern int  __stdcall NvGetFlatDataSelector(void);
extern int  __stdcall NvGetFlatCodeSelector(void);

/*
 * NvConfigVersion() returns an NV version number indicating the NV version.
 * The format of this is 0x00010206, where
 *  - 0x0001 is the chip architecture
 *  -   0x02 is the software release
 *  -   0x06 is the minor revision
 */
extern int  __stdcall NvConfigVersion(void);

#define NV_CHIP_ARCH(ver)   ((ver) >> 16)
#define NV_SW_RELEASE(ver)  (((ver) >> 8) & 0xFF)
#define NV_MINOR_REV(ver)   ((ver) & 0xFF)

/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** OS-dependent constants *****/

/* This posts a new architecture event */
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

/* This puts the process to sleep awaiting notification */
#define NV_OS_NOTIFY_WILL_SLEEP	   0x00000003

/* This puts a message in the client's message queue upon notification */
#define NV_OS_NOTIFY_MESSAGE	   0x00000002

/* This posts a Win32 event to the client upon notification */
#define NV_OS_NOTIFY_EVENT  	   0x00000004

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_VM_EVENT  	   0x00000005

/* Event Types */
#define NV_OS_EVENT_VXD_CALLBACK   0x00000000
#define NV_OS_EVENT_WIN32_EVENT    0x00000001
#define NV_OS_EVENT_VM_EVENT       0x00000002
#define NV_OS_EVENT_WIN32_MSG      0x00000003
#define NV_OS_EVENT_WIN16          0x00000004
#define NV_OS_EVENT_INVALID        0xFFFFFFFF


/***************************************************************************
 *                     OS Resource Strings                                 *
 ***************************************************************************/

/* Maximum length of an OS string (conservative, actual is about 24) */
#define NV_OS_MAX_NAME_LENGTH      32

/***** OS resource names for sources and sinks of samples *****/

/* for NV_VIDEO_SINK */
#define NV_OS_VIDEO_MONITOR        "CON:"

/* for NV_IMAGE_TO_VIDEO. The HWND window handle should replace %u */
#define NV_OS_CANVAS_WINDOW        "WND%u:"

/* for NV_AUDIO_SINK */
#define NV_OS_LINE_OUT_LEFT        "LIN:\\LEFT"
#define NV_OS_LINE_OUT_RIGHT       "LIN:\\RIGHT"

/* for NV_AUDIO_SOURCE */
#define NV_OS_LINE_IN_LEFT         "LIN:\\LEFT"
#define NV_OS_LINE_IN_RIGHT        "LIN:\\RIGHT"
#define NV_OS_MIC_IN_LEFT          "MIC:\\LEFT"
#define NV_OS_MIC_IN_RIGHT         "MIC:\\RIGHT"


/***** Many devices can provide samples for NV_GAME_PORT_SOURCE *****/

/* Raw potentiometer data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 8 channels (0-7) replaces %d */
/* NOTE: The NV_OS_POT O/S string changed to "POTA%d:". The 2.0 and higher
 * Resource Manager will generate NV_ERROR1_NO_SUCH_OBJECT if there is no 
 * joystick connected. This string means nothing to the 1.20 Resource Manager.
 * For backwards compatibility, use NV_OS_GAME_PORT ("POT%d:"): both the 2.0 
 * and 1.20 Resource Manager will not generate an error if no joystick is
 * connected.
 */
#define NV_OS_POT                      "POTA%d:"
/* XXX Old name preserved for compatibility, use NV_OS_POT */
#define NV_OS_GAME_PORT                "POT%d:"


/* Calibrated joystick data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_JOYSTICK_BUTTONS         "JOY%d:\\BUTTONS"

#define NV_OS_JOYSTICK_BUTTON_TRIGGER  0x0001
#define NV_OS_JOYSTICK_BUTTON_SELECT   0x0002
#define NV_OS_JOYSTICK_BUTTON_A        0x0004
#define NV_OS_JOYSTICK_BUTTON_B        0x0008

#define NV_OS_JOYSTICK_X_AXIS          "JOY%d:\\X_AXIS"
#define NV_OS_JOYSTICK_Y_AXIS          "JOY%d:\\Y_AXIS"


/* Pedal data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_PEDALS                   "PEDALS%d:"


/* Throttle data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_THROTTLE                 "THROTTLE%d:"


/* 8-button game pad data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_PAD_BUTTONS              "PAD%d:"
/* XXX Old name preserved for compatibility, use NV_OS_PAD_BUTTONS */
#define NV_OS_PAD                      "PAD%d:"

#define NV_OS_PAD_BUTTON_START         0x0001
#define NV_OS_PAD_BUTTON_RIGHT         0x0002
#define NV_OS_PAD_BUTTON_LEFT          0x0004
#define NV_OS_PAD_BUTTON_UP            0x0008
#define NV_OS_PAD_BUTTON_DOWN          0x0010
#define NV_OS_PAD_BUTTON_A             0x0020
#define NV_OS_PAD_BUTTON_B             0x0040
#define NV_OS_PAD_BUTTON_C             0x0080
#define NV_OS_PAD_BUTTON_X             0x0100
#define NV_OS_PAD_BUTTON_Y             0x0200
#define NV_OS_PAD_BUTTON_Z             0x0400
#define NV_OS_PAD_BUTTON_TOP_RIGHT     0x0800
#define NV_OS_PAD_BUTTON_TOP_LEFT      0x1000


/* 3-axis yoke data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_YOKE_BUTTONS             "YOKE%d:\\BUTTONS"

#define NV_OS_YOKE_BUTTON_START        0x0001
#define NV_OS_YOKE_BUTTON_RIGHT        0x0002
#define NV_OS_YOKE_BUTTON_LEFT         0x0004
#define NV_OS_YOKE_BUTTON_UP           0x0008
#define NV_OS_YOKE_BUTTON_DOWN         0x0010
#define NV_OS_YOKE_BUTTON_A            0x0020
#define NV_OS_YOKE_BUTTON_B            0x0040
#define NV_OS_YOKE_BUTTON_C            0x0080
#define NV_OS_YOKE_BUTTON_X            0x0100
#define NV_OS_YOKE_BUTTON_Y            0x0200
#define NV_OS_YOKE_BUTTON_Z            0x0400
#define NV_OS_YOKE_BUTTON_TOP_RIGHT    0x0800
#define NV_OS_YOKE_BUTTON_TOP_LEFT     0x1000

#define NV_OS_YOKE_X_AXIS              "YOKE%d:\\X_AXIS"
#define NV_OS_YOKE_Y_AXIS              "YOKE%d:\\Y_AXIS"
#define NV_OS_YOKE_Z_AXIS              "YOKE%d:\\Z_AXIS"

/* 2-axis gun position data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* The HWND window handle should replace %u */
#define NV_OS_GUN_BUTTONS              "GUN%dWND%u:\\BUTTONS"

#define NV_OS_GUN_BUTTON_START         0x0001
#define NV_OS_GUN_BUTTON_TRIGGER	   0x0002

#define NV_OS_GUN_X_POSITION		   "GUN%dWND%u:\\X_POS"
#define NV_OS_GUN_Y_POSITION		   "GUN%dWND%u:\\Y_POS"

/* Value returned if gun is still determing X/Y coordinate */
#define NV_OS_GUN_POSITION_COUNTING    0xFFFE
/* Value returned if gun is off screen or outside canvas) */
#define NV_OS_GUN_POSITION_OFF_SCREEN  0xFFFF

/***** WATCOM special handling *****/
/* WATCOM 10.0 compiler needs special declaration of these functions */
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvOpen "*";
#pragma aux (__stdcall) NvClose "*";
#pragma aux (__stdcall) NvWait "*";
#pragma aux (__stdcall) NvNotifyMsg "*";
#pragma aux (__stdcall) NvErrorMsg "*";
#pragma aux (__stdcall) NvGetFlatDataSelector "*";
#pragma aux (__stdcall) NvGetFlatCodeSelector "*";
#pragma aux (__stdcall) NvVpeExtras "*";
#pragma aux (__stdcall) NvDmaPushOperation "*";
#ifdef VPE_EXTRAS
#pragma aux (__stdcall) NvOverlayExtras "*";
#endif

#ifdef _WIN32  // don't do this for the DOS compile!!
#pragma aux (__stdcall) NvConfigVersion "*";
#endif
#endif /* __WATCOMC__ */

#ifdef __cplusplus
};
#endif
#endif /* NVWIN32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Basic Rectangles\render.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: render.c
*
*	Description:
*		This program blasts random rectangles to the frame buffer, using the NV SW architecture.
*
*	Basic NV SW architecture procedure:
*		- register the client
*		- allocate a device
*		- allocate a PIO channel
*		- allocate a DMA context for the frame buffer
*		- allocate and initialize a 2D rendering surface object
*		- allocate and initialize a rectangle rendering object
*		- draw rectangles to the screen
*
**************************************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <time.h>

// NV SDK include files
#include <nvos.h>
#include <nv32.h>
#include <nvrmapi.h>
#include <nvMacros.h>

// NV DDK include files
#include "nvcm.h"

#include "render.h"

int main()
{
	NV_STATUS status;
    ULONG hClient;
	Nv04ChannelPio* pChannel;
    SIZE sScreen;

    // register this client with the architecture
    if (NvRmAllocRoot(&hClient) != NV_STATUS_SUCCESS) 
    {
		return 1;
    }

	// initialize the client and draw rectangles
	if ((status = NvInitialize(hClient, "NV4", &pChannel, &sScreen)) == NV_STATUS_SUCCESS)
	{
		// draw rectangles thru the channel, to the screen
		status = NvDrawRectangles(pChannel, sScreen);
	}
	if (status != NV_STATUS_SUCCESS)
	{
		NvReportError(status);
	}

	// free up the client -- this frees all child objects
    NvRmFree(hClient, NV01_NULL_OBJECT, hClient);

	return 0;

} // end of main()

NV_STATUS NvInitialize(ULONG hClient, PUCHAR szDeviceType, Nv04ChannelPio** pChannel, SIZE* psScreen)
{
    CHAR nameBuffer[32];
	Nv04ChannelPio* channel;
	PUCHAR pFrameBuffer;
	ULONG frameBufferSize;
	SIZE screen;
    ULONG depth, pitch;

	// seed the random number generator for later use
	srand(time(NULL));

    // allocate the specified type of device
    if (
    	NvRmAllocDevice(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			NV01_DEVICE_0,              // device class
			(PUCHAR)nameBuffer          // returned device type
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_DEV;
    }
    if ((strcmp(nameBuffer, szDeviceType) != 0)) 
    { 
        return NV_STATUS_ERROR_DEV_TYPE;
    }

	// allocate a PIO channel to the device
    if (
    	NvRmAllocChannelPio(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			OUR_CHANNEL_ID,				// channel handle
			NV04_CHANNEL_PIO,			// channel class
			NV01_NULL_OBJECT,			// error context
			(PVOID*)pChannel,			// returned channel pointer
			0x00000000					// flags
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_CH_PIO;
    }
	channel = *pChannel;

	// create a DMA context that contains the frame buffer
	pFrameBuffer = NULL;
    if (
    	NvRmAllocMemory(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			OUR_FRAME_BUFFER_ID,		// memory handle
			NV01_MEMORY_LOCAL_USER,		// memory class
			0x00000000,					// flags
			(PVOID*)&pFrameBuffer,		// returned frame buffer pointer
			&frameBufferSize			// limit (size - 1) -- returns the frame buffer size
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_MEM;
    }
    if (
    	NvRmAllocContextDma(
    		hClient,					// client handle
			OUR_FRAME_BUFFER_CTX_ID,	// DMA context handle
			NV01_CONTEXT_DMA,			// DMA context class
			NVOS03_FLAGS_ACCESS_READ_WRITE,	// flags
			pFrameBuffer,				// pointer to DMA buffer
			frameBufferSize - 1			// limit (size - 1) of DMA buffer
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_CTX_DMA;
    }

	// allocate a 2D rendering surface
    if (
    	NvRmConfigGet(
			hClient,					// client handle
			OUR_DEVICE_ID,				// device handle
	    	NV_CFG_SCREEN_WIDTH,		// configuration attribute
			(PULONG)&psScreen->cx		// returned attribute value
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	screen.cx = psScreen->cx;
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_SCREEN_HEIGHT, 
			(PULONG)&psScreen->cy
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	screen.cy = psScreen->cy;
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_PIXEL_DEPTH, 
			&depth
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	if (
    	NvRmAllocObject(
    		hClient,					// client handle
			OUR_CHANNEL_ID,				// channel handle
			OUR_2D_RENDERING_SURFACE_ID,// object handle
			NV04_CONTEXT_SURFACES_2D	// object class
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	pitch = screen.cx * (depth / 8);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(WORKING_SUBCH), 5 * 4);	
	NV_SUBCHANNEL(WORKING_SUBCH).SetObject										= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageSource	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageDestin	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetColorFormat			= NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetPitch					= PACK_PITCH(pitch,pitch);

	// allocate a rectangle rendering object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_RECTANGLE_RENDERER_ID,
			NV04_RENDER_SOLID_RECTANGLE
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).SetObject										= OUR_RECTANGLE_RENDERER_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextSurface		= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetColorFormat		= NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;

	return NV_STATUS_SUCCESS;

} // end of NvInitialize()

// blasts rectangles to the entire screen
NV_STATUS NvDrawRectangles(Nv04ChannelPio* channel, SIZE sScreen)
{
	ULONG i, r, g, b;
	POINT org;
	SIZE ext;

	// render many arbitrary rectangles in the window
	for (i = 0; i < RECTANGLE_QTY; i++)
	{
		// get random rectangle parameters
		NvGetRandomRGB24Color(&r, &g, &b);
		org = NvGetRandomPoint(sScreen);
		ext = NvGetRandomExtent(sScreen);

		// send rendering methods thru the channel -- the size() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Color					= PACK_RGB24(r,g,b);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].point	= PACK_XY(org.x,org.y);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].size		= PACK_WH(ext.cx,ext.cy);
	}

	return NV_STATUS_SUCCESS;

} // end of NvDrawRectangles()

// returns random RGB values that define a color
void NvGetRandomRGB24Color(PULONG pr, PULONG pg, PULONG pb)
{
	*pr = rand() % MAX_8BIT_COLOR + 1;
	*pg = rand() % MAX_8BIT_COLOR + 1;
	*pb = rand() % MAX_8BIT_COLOR + 1;

} // end of NvGetRandomRGB24Color()

// returns a random point within the given limits
POINT NvGetRandomPoint(SIZE limit)
{
	POINT pt;
	pt.x = rand() % limit.cx;
	pt.y = rand() % limit.cy;
	return pt;

} // end of NvGetRandomPoint()

// returns a random size of a rectangle within the given limits
SIZE NvGetRandomExtent(SIZE limit)
{
	SIZE s;
	s.cx = rand() % limit.cx + 1;
	s.cy = rand() % limit.cy + 1;
	return s;

} // end of NvGetRandomExtent()

// displays an error string based on its error code
void NvReportError(ULONG errorCode)
{
	char errorText[80];

	switch(errorCode)
	{
		case NV_STATUS_ERROR:
			strcpy(errorText, "general error");
			break;
		case NV_STATUS_ERROR_ALLOC_DEV:
			strcpy(errorText, "cannot allocate device");
			break;
		case NV_STATUS_ERROR_DEV_TYPE:
			strcpy(errorText, "bad device type");
			break;
		case NV_STATUS_ERROR_ALLOC_CTX_DMA:
			strcpy(errorText, "cannot allocate DMA context");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_PIO:
			strcpy(errorText, "cannot allocate PIO channel");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_DMA:
			strcpy(errorText, "cannot allocate DMA channel");
			break;
		case NV_STATUS_ERROR_ALLOC_MEM:
			strcpy(errorText, "cannot allocate memory");
			break;
		case NV_STATUS_ERROR_ALLOC_OBJ:
			strcpy(errorText, "cannot allocate anobject");
			break;
		case NV_STATUS_ERROR_CONFIG_GET:
			strcpy(errorText, "cannot allocate get specified configuration");
			break;
	}
	printf("render: error: %s\n\n", errorText);

} // end of NvReportError()


// end of render.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Basic Rectangles\render.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: render.h
*
*	Description:
*		Definitions and prototypes for render.c.
*
**************************************************************************************************/

// additional SDK macros
#define NV_SUBCHANNEL(n)				(channel->subchannel[n])
#define WAIT_FOR_SUBCHANNEL(psc,nBytes)	while((psc)->control.Free<(nBytes))
#define PACK_PITCH(s,d)					((V032)((((U032)(d))<<16)|(((U032)(s))&0x0000FFFF)))

// 32bit IDs of our choice to track our allocated objects
enum
{
	OUR_DEVICE_ID = 0xBAAD0000,
	OUR_CHANNEL_ID,
	OUR_FRAME_BUFFER_ID,
	OUR_FRAME_BUFFER_CTX_ID,
	OUR_2D_RENDERING_SURFACE_ID,
	OUR_RECTANGLE_RENDERER_ID
};

// subchannel definitions
enum
{
	WORKING_SUBCH = 0,
	RECT_RENDER_SUBCH
};

// errors
typedef ULONG NV_STATUS;
enum 
{
	NV_STATUS_SUCCESS = 0,
	NV_STATUS_ERROR,
	NV_STATUS_ERROR_ALLOC_DEV,
	NV_STATUS_ERROR_DEV_TYPE,
	NV_STATUS_ERROR_ALLOC_CTX_DMA,
	NV_STATUS_ERROR_ALLOC_CH_PIO,
	NV_STATUS_ERROR_ALLOC_CH_DMA,
	NV_STATUS_ERROR_ALLOC_MEM,
	NV_STATUS_ERROR_ALLOC_OBJ,
	NV_STATUS_ERROR_CONFIG_GET
};

// drawing constants
#define MAX_8BIT_COLOR 0xff
#define RECTANGLE_QTY 5000

// rectangle definition consisting of an origin and an extent
struct NV_RECT
{
	POINT org;
	SIZE ext;
};

// prototypes
NV_STATUS NvInitialize(ULONG, PUCHAR, Nv04ChannelPio**, SIZE*);
NV_STATUS NvDrawRectangles(Nv04ChannelPio*, SIZE);
void NvGetRandomRGB24Color(PULONG, PULONG, PULONG);
POINT NvGetRandomPoint(SIZE);
SIZE NvGetRandomExtent(SIZE);
void NvReportError(ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Windowed Rectangles.rc
//
#define IDC_MYICON                      2
#define IDD_WINDOWEDRECTANGLES_DIALOG   102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_WINDOWEDRECTANGLES          107
#define IDI_SMALL                       108
#define IDC_WINDOWEDRECTANGLES          109
#define IDS_RECTANGLE                   111
#define IDR_MAINFRAME                   128
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\DDK32\main.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//
// Sample configuration application.
//
// This simple program is meant to show how to access the NVIDIA configuration interface.
// The NVIDIA configuration interface allows client applications to read and modify select
// operating values within an NV device.
//
// The steps are:
//  1) Open an interface to the resource manager
//  2) Register the calling application by allocating a client
//  3) Find and identify the devices in the system by allocating a device and giving it a name.
//  4) Get and set device attributes, using the device's name.
//
// This program links with a library to provide simple wrapper routines
// for the resource manager's IOCTL interface.  This hides the complexity of 
// the Win32 IOCTL interfaces.
//
// LINKER NOTE:  You must set /nodefaultlib:"LIBC" in the link options, when using VC++.
//
//  NVRMAPI.LIB (SDK Library for Win32 clients)
//
// IMPORTANT: There are currently different libraries and include file versions
// for NV3 and NV4.  Make sure you use the copies meant for the chip you are
// using.
//
#include <windows.h>
#include <stdio.h>
#include <conio.h>

//
// NV SDK include files
//
#include "nvos.h"
#include "nv32.h"
#include "nvrmapi.h"

//
// NV DDK include files
//
#include "nvcm.h"

//
// A 32bit ID of our choice to track our allocated device (SDK)
//
#define OUR_DEVICE_ID	0xBAAD0000

int main()
{

    char            nameBuffer[32];
    unsigned long   hRm, hClient;
    int             val;

    //
    // Open up a connection to the resource manager
    //
    printf("Opening a connection to the resource manager...\n");
    hRm = (unsigned long)NvRmOpen();

    //
    // Register this client with the architecture
    //
    printf("Allocating a client...\n");
    if (NvRmAllocRoot(&hClient) != NVOS01_STATUS_SUCCESS) 
    {
        //
        // oops, an error.  Close it all back down.
        //
        printf("ERROR: Cannot allocate client.\n");
        NvRmClose();
        getch();
        return 1;
    }

    //
    // Allocate a device.  For Microsoft operating systems, the
    // OS notion of a display device is DisplayX, where X is an
    // one-based integer.  Display1 would be considered the
    // primary display in most cases.
    //
    // NV Architecture defines up to 8 devices.  They are defined
    // in the order in which they're initialized by the operating
    // system, starting at zero.  So, DEVICE_0 will usually 
	// correlate to Display1.  And so on.
    //
    // This allocation call is only necessary to determine the
    // exact type of NV device (NV3, NV4, etc).
    //
    // Let's just get the primary device.
    //
    printf("Allocating a device...\n");
    if (
    	NvRmAllocDevice(
    		hClient,                    // client handle
			OUR_DEVICE_ID,              // device name
			NV01_DEVICE_0,              // device class
			(void *)nameBuffer          // returned device type
        ) != NVOS06_STATUS_SUCCESS
    ) 
	{
        //
        // oops, an error.  Close it all back down.
        //
        printf("ERROR: Cannot allocate device.\n");
        NvRmFree(hClient, NV01_NULL_OBJECT, hClient);
        NvRmClose();
        getch();
        return 1;
    }

    //
    // Make sure this is an NV4 device...
    //
    printf("Verifying NV4 device...\n");
    if ((strcmp(nameBuffer, "NV4") != 0)) 
    { 
    	//
    	// oops, an error.  Close it all back down.
    	//
    	printf("ERROR: Not an NV4 device: %s.\n", nameBuffer);
    	NvRmFree(hClient, NV01_NULL_OBJECT, hClient);
        NvRmClose();
    	getch();
        return 1;
    }
    printf("...Found an NV4 device.\n");

    //
    // Config "get" calls are meant to return the current attributes
	// of a specific chip instance.  We've already allocated and named a
	// chip, so we use that name to extract the values.
    //
	// The general form of the NvRmConfigGet() function is as follows:
	//
	// 	NvRmConfigGet(
	// 		client_handle, 
	// 		device_name,   
	// 		attribute_name,
	// 		&returned_value
	// 	);

    //
    // Get some device attributes.
    //
    printf("Getting bus type...\n");
    if (
    	NvRmConfigGet(
			hClient,			  
			OUR_DEVICE_ID,		  
	    	NV_CFG_BUS_TYPE, 	  
			&val				  
	    ) != NVOS13_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not get the bus type.\n");
    }
	else
		printf("Bus Type: %u\n", val);

    printf("Getting current framebuffer size...\n");
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_RAM_SIZE_MB, 
			&val
	    ) != NVOS13_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not get frame buffer size.\n");
    }
	else
		printf("Framebuffer Size: %u MB\n", val);

    printf("Getting current value of CRTC register CR09...\n");
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_CRTC + 0x09, 
			&val
	    ) != NVOS13_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not get current value of CRTC register CR09.\n");
    }
	else
		printf("CR09: %02X\n", val);

    //
    // Config "set" calls are meant to override the current attributes
	// of a specific chip instance.
    //
	// The general form of the NvRmConfigSet() function is as follows:
	//
	// 	NvRmConfigSet(
	// 		client_handle, 
	// 		device_name,   
	// 		attribute_name,
	//		new_value,
	// 		&returned_old_value
	// 	);
	//
    // NvRmConfigSet calls are batched up until a NvRmConfigUpdate() call is made.
    // This allows us to set multiple interdependent values before the
    // override takes place.
    //
    // NvRmConfigUpdate(client_handle, device_name, NV_CFG_PERMANENT);
    //
    // WARNING: Most system settings cannot be overridden.  If a value can
    // be changed, it usually requires coordination with the display
    // driver.  For example, changing the system resolution requires
    // a reenable of the display driver to the new settings.
    //
	
    printf("Setting new refresh rate...\n");
    if (
    	NvRmConfigSet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_VIDEO_REFRESH_RATE, 
			60,
			&val
	    ) != NVOS14_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not set refresh rate.\n");
    }
    printf("Old refresh rate: %d\n", val);
    if (
    	NvRmConfigUpdate(
    		hClient, 
    		OUR_DEVICE_ID, 
    		NV_CFG_PERMANENT
    	) != NVOS15_STATUS_SUCCESS
	)
    { 
    	printf("ERROR: Could not update the device attributes.\n");
    }
	

    //
    // Close everything up
    //
    printf("Freeing the client and device...\n");
    NvRmFree(hClient, NV01_NULL_OBJECT, hClient);
    printf("Disconnecting from the resource manager...\n");
    NvRmClose();

    getch();

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\nvclient.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: nvclient.c
*
*	Description:
*		This program renders random rectangles to a window, using the NV SW architecture.
*	This is the same as the Basic Rectangles project, except that a clip rectangle object is
*	allocated and attached to the rectangle render object, and the functions are rearranged
*	to fit into the windows programming model.
*
*		functions:
*
*			NvCreate():
*				- allocate a client
*				- allocate a device
*				- allocate a PIO channel
*				- allocate a DMA context for the frame buffer
*				- allocate and initialize a 2D rendering surface object
*				- allocate a clip rectangle object
*				- allocate and initialize the rendering objects
*
*			NvDrawRectangles()
*				- set the clip rectangle of the window
*				- draw rectangles by sending appropriate methods to the rectangle renderer
*
*			NvDestroy()
*				- free the client
*
**************************************************************************************************/

#include "stdafx.h"

// globals 
extern TCHAR szTitle[];
Nv04ChannelPio* channel;
ULONG hClient;
SIZE screen;

// creates the client when the window is created
NV_STATUS NvCreate()
{
    CHAR nameBuffer[32];
	PUCHAR pFrameBuffer;
	ULONG frameBufferSize;
    ULONG depth, pitch;

	// seed the random number generator for later use
	srand(time(NULL));

    // register this client with the architecture -- returns a client handle
    if (NvRmAllocRoot(&hClient) != NV_STATUS_SUCCESS) 
    {
        return NV_STATUS_ERROR_ALLOC_CLIENT;
    }

    // allocate the specified type of device
    if (
    	NvRmAllocDevice(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			NV01_DEVICE_0,              // device class
			(PUCHAR)nameBuffer          // returned device type
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_DEV;
    }
    if ((strcmp(nameBuffer, "NV4") != 0)) 
    { 
        return NV_STATUS_ERROR_DEV_TYPE;
    }

	// allocate a PIO channel to the device
    if (
    	NvRmAllocChannelPio(
    		hClient,                    // client handle
			OUR_DEVICE_ID,              // device handle
			OUR_CHANNEL_ID,				// new channel handle
			NV04_CHANNEL_PIO,			// new channel class
			NV01_NULL_OBJECT,			// new channel error context
			(PVOID*)&channel,			// returned channel pointer
			0x00000000					// flags
        ) != NV_STATUS_SUCCESS
	)
	{
        return NV_STATUS_ERROR_ALLOC_CH_PIO;
    }

	// create a DMA context that contains the frame buffer
	pFrameBuffer = NULL;
    if (
    	NvRmAllocMemory(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			OUR_FRAME_BUFFER_ID,		// memory handle
			NV01_MEMORY_LOCAL_USER,		// memory class
			0x00000000,					// flags
			(PVOID*)&pFrameBuffer,		// returned frame buffer pointer
			&frameBufferSize			// limit (size - 1) -- returns the frame buffer size
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_MEM;
    }
    if (
    	NvRmAllocContextDma(
    		hClient,					// client handle
			OUR_FRAME_BUFFER_CTX_ID,	// DMA context handle
			NV01_CONTEXT_DMA,			// DMA context class
			NVOS03_FLAGS_ACCESS_READ_WRITE,	// flags
			pFrameBuffer,				// pointer to DMA buffer
			frameBufferSize - 1			// limit (size - 1) of DMA buffer
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_CTX_DMA;
    }

	// allocate a 2D rendering surface
    if (
    	NvRmConfigGet(
			hClient,					// client handle
			OUR_DEVICE_ID,				// device handle
	    	NV_CFG_SCREEN_WIDTH,		// configuration attribute
			(PULONG)&screen.cx			// returned attribute value
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_SCREEN_HEIGHT, 
			(PULONG)&screen.cy
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_PIXEL_DEPTH, 
			&depth
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	if (
    	NvRmAllocObject(
    		hClient,					// client handle
			OUR_CHANNEL_ID,				// channel handle
			OUR_2D_RENDERING_SURFACE_ID,// object handle
			NV04_CONTEXT_SURFACES_2D	// object class
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	pitch = screen.cx * (depth / 8);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(WORKING_SUBCH), 5 * 4);	
	NV_SUBCHANNEL(WORKING_SUBCH).SetObject										= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageSource	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageDestin	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetColorFormat			= NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetPitch					= PACK_PITCH(pitch,pitch);

	// allocate and initialize a clip rectangle object
	if (
		NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_CLIP_RECTANGLE_ID,
			NV01_CONTEXT_CLIP_RECTANGLE
        ) != NV_STATUS_SUCCESS
	) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 1 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).SetObject = OUR_CLIP_RECTANGLE_ID;

	// allocate a rectangle rendering object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_RECTANGLE_RENDERER_ID,
			NV04_RENDER_SOLID_RECTANGLE
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 4 * 4);	
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).SetObject											= OUR_RECTANGLE_RENDERER_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextSurface			= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextClipRectangle	= OUR_CLIP_RECTANGLE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetColorFormat			= NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;

    return NV_STATUS_SUCCESS;

} // end of NvCreate()

// renders many arbitrary rectangles to the window
NV_STATUS NvDrawRectangles(HWND hWnd)
{
	// set the current clip rectangle to be the same as the window's client
	NV_RECT rClip = NvGetClientNvRect(hWnd);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 2 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetPoint	= PACK_XY(rClip.org.x, rClip.org.y);
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetSize		= PACK_WH(rClip.ext.cx, rClip.ext.cy);

	// render many arbitrary rectangles in the window
	ULONG r, g, b;
	NV_RECT rect;
	for (int i = 0; i < RECTANGLE_QTY; i++)
	{
		// get random rectangle parameters
		NvGetRandomRGB24Color(&r, &g, &b);
		rect.org = NvGetRandomPoint(screen);
		rect.ext = NvGetRandomExtent(screen);

		// send rendering methods thru the channel -- the size() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Color					= PACK_RGB24(r,g,b);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].point	= PACK_XY(rect.org.x,rect.org.y);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].size		= PACK_WH(rect.ext.cx,rect.ext.cy);
	}

    return NV_STATUS_SUCCESS;

} // end of NvDrawRectangles()

void NvDestroy()
{
	// return the client and all child object resources to the system
    NvRmFree(hClient, NV01_NULL_OBJECT, hClient);

} // end of NvDestroy()

// returns an NV rectangle that describes the screen-relative window's client
NV_RECT NvGetClientNvRect(HWND hWnd)
{
	RECT rClient;
	GetClientRect(hWnd, &rClient);
	NvClientToScreenRect(hWnd, &rClient);
	NV_RECT nvrClient;
	nvrClient.org.x = rClient.left;
	nvrClient.org.y = rClient.top;
	nvrClient.ext.cx = rClient.right - rClient.left;
	nvrClient.ext.cy = rClient.bottom - rClient.top;
	return nvrClient;

} // end of NvGetClientNvRect()

// converts a client-relative rectangle to a screen-relative rectangle 
void NvClientToScreenRect(HWND hWnd, RECT* pRect)
{
	POINT ptUpperLeft, ptLowerRight;

	// convert into points
	ptUpperLeft.x	= pRect->left;
	ptUpperLeft.y	= pRect->top;
	ptLowerRight.x	= pRect->right;
	ptLowerRight.y	= pRect->bottom;

	// call windows API to convert from client coords to screen coords
	ClientToScreen(hWnd, &ptUpperLeft);
	ClientToScreen(hWnd, &ptLowerRight);

	// recreate the transformed rectangle
	pRect->left		= ptUpperLeft.x;
	pRect->top		= ptUpperLeft.y;
	pRect->right	= ptLowerRight.x;
	pRect->bottom	= ptLowerRight.y;

} // end of NvClientToScreenRect()

// returns random RGB values that define a color
void NvGetRandomRGB24Color(PULONG pr, PULONG pg, PULONG pb)
{
	*pr = rand() % MAX_8BIT_COLOR + 1;
	*pg = rand() % MAX_8BIT_COLOR + 1;
	*pb = rand() % MAX_8BIT_COLOR + 1;

} // end of NvGetRandomRGB24Color()

// returns a random point within the given limits
POINT NvGetRandomPoint(SIZE limit)
{
	POINT pt;
	pt.x = rand() % limit.cx;
	pt.y = rand() % limit.cy;
	return pt;

} // end of NvGetRandomPoint()

// returns a random size of a rectangle within the given limits
SIZE NvGetRandomExtent(SIZE limit)
{
	SIZE s;
	s.cx = rand() % limit.cx + 1;
	s.cy = rand() % limit.cy + 1;
	return s;

} // end of NvGetRandomExtent()

// displays an error message box based on its error code
void NvReportError(ULONG errorCode)
{
	char errorText[80];

	switch(errorCode)
	{
		case NV_STATUS_ERROR:
			strcpy(errorText, "Error: general error");
			break;
		case NV_STATUS_ERROR_ALLOC_DEV:
			strcpy(errorText, "Error: cannot allocate device");
			break;
		case NV_STATUS_ERROR_DEV_TYPE:
			strcpy(errorText, "Error: unavailable requested NV device type");
			break;
		case NV_STATUS_ERROR_ALLOC_CTX_DMA:
			strcpy(errorText, "Error: cannot allocate DMA context");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_PIO:
			strcpy(errorText, "Error: cannot allocate PIO channel");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_DMA:
			strcpy(errorText, "Error: cannot allocate DMA channel");
			break;
		case NV_STATUS_ERROR_ALLOC_MEM:
			strcpy(errorText, "Error: cannot allocate memory");
			break;
		case NV_STATUS_ERROR_ALLOC_OBJ:
			strcpy(errorText, "Error: cannot allocate anobject");
			break;
		case NV_STATUS_ERROR_CONFIG_GET:
			strcpy(errorText, "Error: cannot allocate get specified configuration");
			break;
	}
	MessageBox(NULL, errorText, szTitle, MB_OK);

} // end of NvReportError()


// end of nvclient.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\StdAfx.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//	Windowed Rectangles.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\nvclient.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: nvclient.h
*
*	Description:
*		Definitions and prototypes for nvclient.cpp.
*
**************************************************************************************************/

// additional SDK macros
#define NV_SUBCHANNEL(n)				(channel->subchannel[n])
#define WAIT_FOR_SUBCHANNEL(psc,nBytes)	while((psc)->control.Free<(nBytes))
#define PACK_PITCH(s,d)					((V032)((((U032)(d))<<16)|(((U032)(s))&0x0000FFFF)) )

// 32bit IDS of our choice to track our allocated objects
enum
{
	OUR_DEVICE_ID = 0xBAAD0000,
	OUR_CHANNEL_ID,
	OUR_FRAME_BUFFER_ID,
	OUR_FRAME_BUFFER_CTX_ID,
	OUR_2D_RENDERING_SURFACE_ID,
	OUR_RECTANGLE_RENDERER_ID,
	OUR_CLIP_RECTANGLE_ID
};

// subchannel definitions
enum
{
	WORKING_SUBCH = 0,
	RECT_RENDER_SUBCH,
	CLIP_RECT_SUBCH,
};

// errors
typedef ULONG NV_STATUS;
enum 
{
	NV_STATUS_SUCCESS = 0,
	NV_STATUS_ERROR,
	NV_STATUS_ERROR_ALLOC_DEV,
	NV_STATUS_ERROR_DEV_TYPE,
	NV_STATUS_ERROR_ALLOC_CTX_DMA,
	NV_STATUS_ERROR_ALLOC_CH_PIO,
	NV_STATUS_ERROR_ALLOC_CH_DMA,
	NV_STATUS_ERROR_ALLOC_MEM,
	NV_STATUS_ERROR_ALLOC_OBJ,
	NV_STATUS_ERROR_CONFIG_GET,
	NV_STATUS_ERROR_ALLOC_CLIENT
};

// drawing constants
#define MAX_8BIT_COLOR 0xff
#define RECTANGLE_QTY 5000

// rectangle definition consisting of an origin and an extent
struct NV_RECT
{
	POINT org;
	SIZE ext;
};

// prototypes
NV_STATUS NvCreate();
NV_STATUS NvDrawRectangles(HWND);
void NvDestroy();
NV_RECT NvGetClientNvRect(HWND);
void NvClientToScreenRect(HWND, RECT*);
void NvGetRandomRGB24Color(PULONG, PULONG, PULONG);
POINT NvGetRandomPoint(SIZE);
SIZE NvGetRandomExtent(SIZE);
void NvReportError(ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\StdAfx.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers


// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files

// TODO: reference additional headers your program requires here
//#include <stdio.h>
//#include <conio.h>
#include <time.h>

//
// NV SDK include files
//
#include <nvos.h>
#include <nv32.h>
#include <nvrmapi.h>
#include <nvMacros.h>

//
// NV DDK include files
//
#include "nvcm.h"

#include "nvclient.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\nvclient.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: nvclient.c
*
*	Description:
*		This program renders random shapes to a window, using the NV SW architecture.
*	This is the same as the Windows Rectangles project, with the addition of being able to
*	draw lines and BLITs.  Drawing is now controled thru the menu.
*
*		functions:
*
*			NvCreate():
*				- allocate a client
*				- allocate a device
*				- allocate a PIO channel
*				- allocate a DMA context for the frame buffer
*				- allocate and initialize a 2D rendering surface object
*				- allocate a clip rectangle object
*				- allocate and initialize the rendering objects
*
*			NvDraw..()
*				- set the clip rectangle of the window
*				- draw rectangles by sending appropriate methods to the rectangle renderer
*
*			NvDestroy()
*				- free the client
*
**************************************************************************************************/

#include "stdafx.h"
#include "resource.h"

// globals 
extern HINSTANCE hInst;
extern TCHAR szTitle[];
Nv04ChannelPio* channel;
ULONG hClient;
SIZE screen;

// creates the client when the window is created
NV_STATUS NvCreate()
{
    CHAR nameBuffer[32];
	PUCHAR pFrameBuffer;
	ULONG frameBufferSize;
    ULONG depth, pitch;

	// seed the random number generator for later use
	srand(time(NULL));

    // register this client with the architecture -- returns a client handle
    if (NvRmAllocRoot(&hClient) != NV_STATUS_SUCCESS) 
    {
        return NV_STATUS_ERROR_ALLOC_CLIENT;
    }

    // allocate the specified type of device
    if (
    	NvRmAllocDevice(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			NV01_DEVICE_0,              // device class
			(PUCHAR)nameBuffer          // returned device type
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_DEV;
    }
    if ((strcmp(nameBuffer, "NV4") != 0)) 
    { 
        return NV_STATUS_ERROR_DEV_TYPE;
    }

	// allocate a PIO channel to the device
    if (
    	NvRmAllocChannelPio(
    		hClient,                    // client handle
			OUR_DEVICE_ID,              // device handle
			OUR_CHANNEL_ID,				// new channel handle
			NV04_CHANNEL_PIO,			// new channel class
			NV01_NULL_OBJECT,			// new channel error context
			(PVOID*)&channel,			// returned channel pointer
			0x00000000					// flags
        ) != NV_STATUS_SUCCESS
	)
	{
        return NV_STATUS_ERROR_ALLOC_CH_PIO;
    }

	// create a DMA context that contains the frame buffer
	pFrameBuffer = NULL;
    if (
    	NvRmAllocMemory(
    		hClient,					// client handle
			OUR_DEVICE_ID,              // device handle
			OUR_FRAME_BUFFER_ID,		// memory handle
			NV01_MEMORY_LOCAL_USER,		// memory class
			0x00000000,					// flags
			(PVOID*)&pFrameBuffer,		// returned frame buffer pointer
			&frameBufferSize			// limit (size - 1) -- returns the frame buffer size
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_MEM;
    }
    if (
    	NvRmAllocContextDma(
    		hClient,					// client handle
			OUR_FRAME_BUFFER_CTX_ID,	// DMA context handle
			NV01_CONTEXT_DMA,			// DMA context class
			NVOS03_FLAGS_ACCESS_READ_WRITE,	// flags
			pFrameBuffer,				// pointer to DMA buffer
			frameBufferSize - 1			// limit (size - 1) of DMA buffer
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_CTX_DMA;
    }

	// allocate a 2D rendering surface
    if (
    	NvRmConfigGet(
			hClient,					// client handle
			OUR_DEVICE_ID,				// device handle
	    	NV_CFG_SCREEN_WIDTH,		// configuration attribute
			(PULONG)&screen.cx			// returned attribute value
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_SCREEN_HEIGHT, 
			(PULONG)&screen.cy
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
    if (
    	NvRmConfigGet(
			hClient,
			OUR_DEVICE_ID,
	    	NV_CFG_PIXEL_DEPTH, 
			&depth
	    ) != NV_STATUS_SUCCESS
	)
    { 
        return NV_STATUS_ERROR_CONFIG_GET;
    }
	if (
    	NvRmAllocObject(
    		hClient,					// client handle
			OUR_CHANNEL_ID,				// channel handle
			OUR_2D_RENDERING_SURFACE_ID,// object handle
			NV04_CONTEXT_SURFACES_2D	// object class
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	pitch = screen.cx * (depth / 8);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(WORKING_SUBCH), 5 * 4);	
	NV_SUBCHANNEL(WORKING_SUBCH).SetObject										= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageSource	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetContextDmaImageDestin	= OUR_FRAME_BUFFER_CTX_ID;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetColorFormat			= NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
	NV_SUBCHANNEL(WORKING_SUBCH).Nv04ContextSurfaces2d.SetPitch					= PACK_PITCH(pitch,pitch);

	// allocate and initialize a clip rectangle object
	if (
		NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_CLIP_RECTANGLE_ID,
			NV01_CONTEXT_CLIP_RECTANGLE
        ) != NV_STATUS_SUCCESS
	) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 1 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).SetObject = OUR_CLIP_RECTANGLE_ID;

	// allocate a rectangle rendering object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_RECTANGLE_RENDERER_ID,
			NV04_RENDER_SOLID_RECTANGLE
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 4 * 4);	
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).SetObject											= OUR_RECTANGLE_RENDERER_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextSurface			= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetContextClipRectangle	= OUR_CLIP_RECTANGLE_ID;
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.SetColorFormat			= NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;

	// allocate and initialize a line rendering object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_LINE_RENDERER_ID,
			NV04_RENDER_SOLID_LIN
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(LINE_RENDER_SUBCH), 4 * 4);	
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).SetObject									= OUR_LINE_RENDERER_ID;
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.SetContextSurface		= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.SetContextClipRectangle	= OUR_CLIP_RECTANGLE_ID;
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.SetColorFormat			= NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8;

	// allocate and initialize a BLIT object
    if (
    	NvRmAllocObject(
    		hClient,
			OUR_CHANNEL_ID,
			OUR_BLIT_ID,
			NV04_IMAGE_BLIT
        ) != NV_STATUS_SUCCESS
    ) 
	{
        return NV_STATUS_ERROR_ALLOC_OBJ;
    }
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(BLIT_SUBCH), 3 * 4);	
	NV_SUBCHANNEL(BLIT_SUBCH).SetObject								= OUR_BLIT_ID;
	NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.SetContextSurfaces		= OUR_2D_RENDERING_SURFACE_ID;
	NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.SetContextClipRectangle	= OUR_CLIP_RECTANGLE_ID;

    return NV_STATUS_SUCCESS;

} // end of NvCreate()

// renders many arbitrary lines to the window
NV_STATUS NvDrawLines(HWND hWnd)
{
	// set the current clip rectangle to be the same as the window's client
	NV_RECT rClip = NvGetClientNvRect(hWnd);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 2 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetPoint	= PACK_XY(rClip.org.x, rClip.org.y);
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetSize		= PACK_WH(rClip.ext.cx, rClip.ext.cy);

	// render many arbitrary lines in the window
	ULONG r, g, b;
	POINT start, end;
	for (int i = 0; i < LINE_QTY; i++)
	{
		// get random line parameters
		NvGetRandomRGB24Color(&r, &g, &b);
		start = NvGetRandomPoint(screen);
		end = NvGetRandomPoint(screen);

		// send rendering methods thru the channel -- the point1() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(LINE_RENDER_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Color			= PACK_RGB24(r,g,b);
		NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point0	= PACK_XY(start.x, start.y);
		NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point1	= PACK_XY(end.x, end.y);

		// display a caption
		NvDisplayCaption(hWnd, IDS_LINE, rClip);
	}

    return NV_STATUS_SUCCESS;

} // end of NvDrawLines()

// renders many arbitrary rectangles to the window
NV_STATUS NvDrawRectangles(HWND hWnd)
{
	// set the current clip rectangle to be the same as the window's client
	NV_RECT rClip = NvGetClientNvRect(hWnd);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 2 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetPoint	= PACK_XY(rClip.org.x, rClip.org.y);
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetSize		= PACK_WH(rClip.ext.cx, rClip.ext.cy);

	// render many arbitrary rectangles in the window
	ULONG r, g, b;
	NV_RECT rect;
	for (int i = 0; i < RECTANGLE_QTY; i++)
	{
		// get random rectangle parameters
		NvGetRandomRGB24Color(&r, &g, &b);
		rect.org = NvGetRandomPoint(screen);
		rect.ext = NvGetRandomExtent(screen);

		// send rendering methods thru the channel -- the size() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Color					= PACK_RGB24(r,g,b);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].point	= PACK_XY(rect.org.x,rect.org.y);
		NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].size		= PACK_WH(rect.ext.cx,rect.ext.cy);

		// display a caption
		NvDisplayCaption(hWnd, IDS_RECTANGLE, rClip);
	}

    return NV_STATUS_SUCCESS;

} // end of NvDrawRectangles()

// bounce a rectangular portion of the window client around the window, to demonstrate BLITs
NV_STATUS NvBlits(HWND hWnd)
{
	// set the current clip rectangle to be the same as the window's client
	NV_RECT rClip = NvGetClientNvRect(hWnd);
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(CLIP_RECT_SUBCH), 2 * 4);	
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetPoint	= PACK_XY(rClip.org.x, rClip.org.y);
	NV_SUBCHANNEL(CLIP_RECT_SUBCH).Nv01ContextClipRectangle.SetSize		= PACK_WH(rClip.ext.cx, rClip.ext.cy);

	// init and render the source of the BLIT
	NV_RECT blitSrc = rClip;
	blitSrc.ext.cx /= 2;
	blitSrc.ext.cy = blitSrc.ext.cy * 2 / 10;
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(RECT_RENDER_SUBCH), 3 * 4);	
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Color					= PACK_RGB24(0xff,0x00,0x00);
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].point	= PACK_XY(blitSrc.org.x + 1,blitSrc.org.y + 1);
	NV_SUBCHANNEL(RECT_RENDER_SUBCH).Nv04RenderSolidRectangle.Rectangle[0].size		= PACK_WH(blitSrc.ext.cx - 2,blitSrc.ext.cy - 2);
	NvDisplayCaption(hWnd, IDS_BLIT_PATTERN, blitSrc);

	// draw a line around and between the source and the display boundary
	WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(LINE_RENDER_SUBCH), 6 * 4);	
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Color			= PACK_RGB24(0x00,0x00,0x00);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point0	= PACK_XY(rClip.org.x, rClip.org.y + blitSrc.ext.cy);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point1	= PACK_XY(rClip.org.x + rClip.ext.cx, rClip.org.y + blitSrc.ext.cy);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Color			= PACK_RGB24(0x00,0x00,0x00);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point0	= PACK_XY(rClip.org.x + blitSrc.ext.cx, rClip.org.y);
	NV_SUBCHANNEL(LINE_RENDER_SUBCH).Nv04RenderSolidLin.Lin[0].point1	= PACK_XY(rClip.org.x + blitSrc.ext.cx, rClip.org.y + blitSrc.ext.cy);

	// define the display boundary
	NV_RECT rDisplayBounds = rClip;
	rDisplayBounds.org.y += blitSrc.ext.cy + 1;
	rDisplayBounds.ext.cy -= blitSrc.ext.cy + 1;

	// initialize the destination of the BLIT
	NV_RECT blitDest = rDisplayBounds;
	blitDest.ext = blitSrc.ext;

	// initialize the movement direction vector
	DIRECTION_VECTOR dir;
	dir.horiz = RIGHT;
	dir.vert = DOWN;

	for (int i = 0; i < BLIT_QTY; i++)
	{
		NvMoveBlitDest(&blitDest, &dir, rDisplayBounds);

		// send rendering methods thru the channel -- the Size() method triggers the rendering
		WAIT_FOR_SUBCHANNEL(&NV_SUBCHANNEL(BLIT_SUBCH), 3 * 4);	
		NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.ControlPointIn	= PACK_XY(blitSrc.org.x,blitSrc.org.y);
		NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.ControlPointOut	= PACK_XY(blitDest.org.x,blitDest.org.y);
		NV_SUBCHANNEL(BLIT_SUBCH).Nv04ImageBlit.Size			= PACK_WH(blitDest.ext.cx,blitDest.ext.cy);

		// frame delay
		for (ULONG y = 0; y < NV_DELAY; y++);

		// display a caption
		NvDisplayCaption(hWnd, IDS_BLIT, rDisplayBounds);
	}

    return NV_STATUS_SUCCESS;

} // end of NvBlits()

void NvDestroy()
{
	// return the client and all child object resources to the system
    NvRmFree(hClient, NV01_NULL_OBJECT, hClient);

} // end of NvDestroy()

// returns an NV rectangle that describes the screen-relative window's client
NV_RECT NvGetClientNvRect(HWND hWnd)
{
	RECT rClient;
	GetClientRect(hWnd, &rClient);
	NvClientToScreenRect(hWnd, &rClient);
	NV_RECT nvrClient;
	nvrClient.org.x = rClient.left;
	nvrClient.org.y = rClient.top;
	nvrClient.ext.cx = rClient.right - rClient.left;
	nvrClient.ext.cy = rClient.bottom - rClient.top;
	return nvrClient;

} // end of NvGetClientNvRect()

// converts a client-relative rectangle to a screen-relative rectangle 
void NvClientToScreenRect(HWND hWnd, RECT* pRect)
{
	POINT ptUpperLeft, ptLowerRight;

	// convert into points
	ptUpperLeft.x	= pRect->left;
	ptUpperLeft.y	= pRect->top;
	ptLowerRight.x	= pRect->right;
	ptLowerRight.y	= pRect->bottom;

	// call windows API to convert from client coords to screen coords
	ClientToScreen(hWnd, &ptUpperLeft);
	ClientToScreen(hWnd, &ptLowerRight);

	// recreate the transformed rectangle
	pRect->left		= ptUpperLeft.x;
	pRect->top		= ptUpperLeft.y;
	pRect->right	= ptLowerRight.x;
	pRect->bottom	= ptLowerRight.y;

} // end of NvClientToScreenRect()

// returns random RGB values that define a color
void NvGetRandomRGB24Color(PULONG pr, PULONG pg, PULONG pb)
{
	*pr = rand() % MAX_8BIT_COLOR + 1;
	*pg = rand() % MAX_8BIT_COLOR + 1;
	*pb = rand() % MAX_8BIT_COLOR + 1;

} // end of NvGetRandomRGB24Color()

// returns a random point within the given limits
POINT NvGetRandomPoint(SIZE limit)
{
	POINT pt;
	pt.x = rand() % limit.cx;
	pt.y = rand() % limit.cy;
	return pt;

} // end of NvGetRandomPoint()

// returns a random size of a rectangle within the given limits
SIZE NvGetRandomExtent(SIZE limit)
{
	SIZE s;
	s.cx = rand() % limit.cx + 1;
	s.cy = rand() % limit.cy + 1;
	return s;

} // end of NvGetRandomExtent()

// displays an error message box based on its error code
void NvReportError(ULONG errorCode)
{
	char errorText[80];

	switch(errorCode)
	{
		case NV_STATUS_ERROR:
			strcpy(errorText, "Error: general error");
			break;
		case NV_STATUS_ERROR_ALLOC_DEV:
			strcpy(errorText, "Error: cannot allocate device");
			break;
		case NV_STATUS_ERROR_DEV_TYPE:
			strcpy(errorText, "Error: unavailable requested NV device type");
			break;
		case NV_STATUS_ERROR_ALLOC_CTX_DMA:
			strcpy(errorText, "Error: cannot allocate DMA context");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_PIO:
			strcpy(errorText, "Error: cannot allocate PIO channel");
			break;
		case NV_STATUS_ERROR_ALLOC_CH_DMA:
			strcpy(errorText, "Error: cannot allocate DMA channel");
			break;
		case NV_STATUS_ERROR_ALLOC_MEM:
			strcpy(errorText, "Error: cannot allocate memory");
			break;
		case NV_STATUS_ERROR_ALLOC_OBJ:
			strcpy(errorText, "Error: cannot allocate anobject");
			break;
		case NV_STATUS_ERROR_CONFIG_GET:
			strcpy(errorText, "Error: cannot allocate get specified configuration");
			break;
	}
	MessageBox(NULL, errorText, szTitle, MB_OK);

} // end of NvReportError()

// display a caption centered horizontally and vertically in the give rectangle
void NvDisplayCaption(HWND hWnd, ULONG captionId, NV_RECT nvrText)
{
	HDC hdc = GetDC(hWnd);
	TCHAR szCaption[MAX_LOADSTRING];
	LoadString(hInst, captionId, szCaption, MAX_LOADSTRING);
	RECT rText = NvRectToWinRect(nvrText);
	NvScreenToClientRect(hWnd, &rText);
	DrawText(hdc, szCaption, strlen(szCaption), &rText, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
}

void NvScreenToClientRect(HWND hWnd, RECT* pRect)
{
	POINT ptUpperLeft, ptLowerRight;

	// convert rectangle to a set of points
	ptUpperLeft.x	= pRect->left;
	ptUpperLeft.y	= pRect->top;
	ptLowerRight.x	= pRect->right;
	ptLowerRight.y	= pRect->bottom;

	// call windows API to convert from screen coords to client coords
	ScreenToClient(hWnd, &ptUpperLeft);
	ScreenToClient(hWnd, &ptUpperLeft);

	// recreate the transformed rectangle
	pRect->left		= ptUpperLeft.x;
	pRect->top		= ptUpperLeft.y;
	pRect->right	= ptLowerRight.x;
	pRect->bottom	= ptLowerRight.y;

} // end of NvScreenRectToClientRect()

RECT NvRectToWinRect(NV_RECT nvRect)
{
	RECT r;
	r.left		= nvRect.org.x;
	r.top		= nvRect.org.y;
	r.right		= nvRect.org.x + nvRect.ext.cx;
	r.bottom	= nvRect.org.y + nvRect.ext.cy;
	return r;
}

void NvMoveBlitDest(NV_RECT* pDest, DIRECTION_VECTOR* pDir, NV_RECT nvrBoundary)
{
	RECT rBoundary = NvRectToWinRect(nvrBoundary);

	// determine the horizontal destination of a BLIT
	if (pDir->horiz == RIGHT)
	{
		if (pDest->org.x + pDest->ext.cx + 1 < rBoundary.right)
		{
			pDest->org.x++;
		}
		else
		{
			pDest->org.x--;
			pDir->horiz = LEFT;
		}
	}
	else
	{
		if (pDest->org.x - 1 > rBoundary.left)
		{
			pDest->org.x--;
		}
		else
		{
			pDest->org.x++;
			pDir->horiz = RIGHT;
		}
	}

	// define the vertical destination of the BLIT
	if (pDir->vert == DOWN)
	{
		if (pDest->org.y + pDest->ext.cy + 1 < rBoundary.bottom)
		{
			pDest->org.y++;
		}
		else
		{
			pDest->org.y--;
			pDir->vert = UP;
		}
	}
	else
	{
		if (pDest->org.y - 1 > rBoundary.top)
		{
			pDest->org.y--;
		}
		else
		{
			pDest->org.y++;
			pDir->vert = DOWN;
		}
	}

} // end of NvMoveBlitDest()


// end of nvclient.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\nvclient.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*************************************************************************************************
*
*	File: nvclient.h
*
*	Description:
*		Definitions and prototypes for nvclient.c.
*
**************************************************************************************************/

// additional SDK macros
#define NV_SUBCHANNEL(n)				(channel->subchannel[n])
#define WAIT_FOR_SUBCHANNEL(psc,nBytes)	while((psc)->control.Free<(nBytes))
#define PACK_PITCH(s,d)					((V032)((((U032)(d))<<16)|(((U032)(s))&0x0000FFFF)) )

// 32-bit handles of our choice to track our allocated objects
enum
{
	OUR_DEVICE_ID = 0xBAAD0000,
	OUR_CHANNEL_ID,
	OUR_FRAME_BUFFER_ID,
	OUR_FRAME_BUFFER_CTX_ID,
	OUR_2D_RENDERING_SURFACE_ID,
	OUR_RECTANGLE_RENDERER_ID,
	OUR_CLIP_RECTANGLE_ID,
	OUR_LINE_RENDERER_ID,
	OUR_BLIT_ID
};

// subchannel definitions
enum
{
	WORKING_SUBCH = 0,
	CLIP_RECT_SUBCH,
	RECT_RENDER_SUBCH,
	LINE_RENDER_SUBCH,
	BLIT_SUBCH
};

// errors
typedef ULONG NV_STATUS;
enum 
{
	NV_STATUS_SUCCESS = 0,
	NV_STATUS_ERROR,
	NV_STATUS_ERROR_ALLOC_DEV,
	NV_STATUS_ERROR_DEV_TYPE,
	NV_STATUS_ERROR_ALLOC_CTX_DMA,
	NV_STATUS_ERROR_ALLOC_CH_PIO,
	NV_STATUS_ERROR_ALLOC_CH_DMA,
	NV_STATUS_ERROR_ALLOC_MEM,
	NV_STATUS_ERROR_ALLOC_OBJ,
	NV_STATUS_ERROR_CONFIG_GET,
	NV_STATUS_ERROR_ALLOC_CLIENT
};

// drawing constants
#define MAX_8BIT_COLOR 0xff
#define RECTANGLE_QTY 5000
#define LINE_QTY 1000
#define BLIT_QTY 5000
#define NV_DELAY 75000

// rectangle definition consisting of an origin and an extent
struct NV_RECT
{
	POINT org;
	SIZE ext;
};

// BLIT movement definitions
enum H_DIR {LEFT, RIGHT};
enum V_DIR {UP, DOWN};
struct DIRECTION_VECTOR
{
	H_DIR horiz;
	V_DIR vert;
};

// prototypes
NV_STATUS NvCreate();
NV_STATUS NvDrawLines(HWND);
NV_STATUS NvDrawRectangles(HWND);
NV_STATUS NvBlits(HWND);
void NvDestroy();
NV_RECT NvGetClientNvRect(HWND);
void NvClientToScreenRect(HWND, RECT*);
void NvGetRandomRGB24Color(PULONG, PULONG, PULONG);
POINT NvGetRandomPoint(SIZE);
SIZE NvGetRandomExtent(SIZE);
void NvReportError(ULONG);
void NvDisplayCaption(HWND, ULONG, NV_RECT);
void NvScreenToClientRect(HWND, RECT*);
RECT NvRectToWinRect(NV_RECT);
void NvMoveBlitDest(NV_RECT*, DIRECTION_VECTOR*, NV_RECT);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\Windowed Rectangles.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


#if !defined(AFX_WINDOWEDRECTANGLES_H__6DEA4A85_77EA_11D3_89A0_00500422D52A__INCLUDED_)
#define AFX_WINDOWEDRECTANGLES_H__6DEA4A85_77EA_11D3_89A0_00500422D52A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_WINDOWEDRECTANGLES_H__6DEA4A85_77EA_11D3_89A0_00500422D52A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Rectangles\Windowed Rectangles.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// Windowed Rectangles.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text

// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_WINDOWEDRECTANGLES, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_WINDOWEDRECTANGLES);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}



//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_WINDOWEDRECTANGLES);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_WINDOWEDRECTANGLES;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
	NV_STATUS status;

	switch (message) 
	{
		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;
				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;
		case WM_CREATE:

			// initialize the NV device
			if ((status = NvCreate()) != NV_STATUS_SUCCESS)
			{
				// if there was an error, display it and shut down the app
				NvReportError(status);
				DestroyWindow(hWnd);
			}

			break;
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);

			// draw rectangles any time the window is repainted
			if ((status = NvDrawRectangles(hWnd)) != NV_STATUS_SUCCESS)
			{
				// if there was an error, display it and shut down the app
				NvReportError(status);
				DestroyWindow(hWnd);
			}

			EndPaint(hWnd, &ps);

			break;
		case WM_DESTROY:

			// free up the client when the app's window is destroyed
			NvDestroy();

			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Windowed Shapes.rc
//
#define IDC_MYICON                      2
#define IDD_WINDOWEDSHAPES_DIALOG       102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_WINDOWEDSHAPES              107
#define IDI_SMALL                       108
#define IDC_WINDOWEDSHAPES              109
#define IDS_RECTANGLE                   112
#define IDS_LINE                        113
#define IDS_BLIT                        115
#define IDS_BLIT_PATTERN                116
#define IDR_MAINFRAME                   128
#define IDM_RENDER                      200
#define ID_RENDER_LINES                 32774
#define ID_RENDER_RECTANGLES            32775
#define ID_RENDER_BLITS                 32777
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32778
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\StdAfx.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//	Windowed Shapes.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#define MAX_LOADSTRING 100

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <time.h>

// Local Header Files

//
// NV SDK include files
//
#include <nvos.h>
#include <nv32.h>
#include <nvrmapi.h>
#include <nvMacros.h>

//
// NV DDK include files
//
#include <nvcm.h>

#include "nvclient.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvBlit.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvBlit.h                                                          *
*    Definition file for:                                                   *
*       Blt832.c, Blt1632.c and Blt3232                                     *
*    Suggested new name for combined file:                                  *
*       nvBlit.c                                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef _NVBLIT_H_
#define _NVBLIT_H_

#ifdef __cplusplus
extern "C" {
#endif

// workspace allocation flags
#define BLTWS_UNINITIALIZED     0x0
#define BLTWS_VIDEO             0x1
#define BLTWS_AGP               0x2
#define BLTWS_SYSTEM            0x4
#define BLTWS_PREFERRED_VIDEO   0x10
#define BLTWS_PREFERRED_AGP     0x20
#define BLTWS_PREFERRED_SYSTEM  0x40
#define BLTWS_REQUIRED_VIDEO    0x100
#define BLTWS_REQUIRED_AGP      0x200
#define BLTWS_REQUIRED_SYSTEM   0x400

// other defines (lore)
#define NV4_BLT_READ_AHEAD_BUFFER_SIZE  4096
#define NV10_BLT_READ_AHEAD_BUFFER_SIZE 8192

// abbreviated surface info
typedef struct tagSurfInfo {
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    LPDDRAWI_DDRAWSURFACE_GBL pGbl;
    CNvObject *pObj;
    DWORD     dwFourCC;
    BOOL      bUseSwizzle;
    BOOL      bIsLocked;
    DWORD     dwCaps;
    DWORD     dwContextDma;
    FLATPTR   fpVidMem;
    DWORD     dwOffset;
    DWORD     dwPitch;
    DWORD     dwWidth;
    DWORD     dwHeight;
    DWORD     dwSubRectX;
    DWORD     dwSubRectY;
    DWORD     dwSubRectWidth;
    DWORD     dwSubRectHeight;
    BOOL      isPotentialFault;
    DWORD     dwBytesPerPixel;
    BOOL      bDefaultBlitChanged;
} SURFINFO, *LPSURFINFO;

// exports
DWORD __stdcall GetBltStatus32(LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus);
DWORD __stdcall Blit32(LPDDHAL_BLTDATA pbd);

// utility functions
void  __stdcall bltInit(void);
DWORD __stdcall bltEarlyErrorCheck(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltUpdateClip(GLOBALDATA *pDriverData);
DWORD __stdcall bltDestroyAllContextDMAs(LPDDRAWI_DIRECTDRAW_GBL lpDD);
DWORD __stdcall bltCreateContextDMA(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf);
DWORD __stdcall bltControlTraffic(LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltAllocWorkSpace(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL lpDD);
DWORD __stdcall bltSetSurfaces2D(LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSetBltState(LPDDHAL_BLTDATA pbd, LPSURFINFO src, LPSURFINFO dst);

// blt functions
DWORD __stdcall bltPotentialFaultHandler(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltTexture(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bStretch);
DWORD __stdcall ScaleZFillDepth(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst);
DWORD __stdcall bltColourFill(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst, DWORD dwFillColour);
DWORD __stdcall blt4CCto4CC(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSimpleCopy(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSlowVtoSBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSlowStoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltSimpleVtoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall blt8bppStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst);
DWORD __stdcall bltStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bFilter);

// internal use blit functions
DWORD __stdcall bltWriteDword(DWORD dwOffset, DWORD dwIndex, DWORD dwData);
DWORD __stdcall bltFillBlock(GLOBALDATA *pDriverData, DWORD dwColour, DWORD dwOffset, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwBytesPerPel);

// old fallback blt code
DWORD __stdcall Blt8bpp32  (LPDDHAL_BLTDATA pbd);
DWORD __stdcall Blt16bpp32 (LPDDHAL_BLTDATA pbd);
DWORD __stdcall Blt32bpp32 (LPDDHAL_BLTDATA pbd);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVBLIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\Windowed Shapes.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


#if !defined(AFX_WINDOWEDSHAPES_H__6912D105_781A_11D3_89A0_00500422D52A__INCLUDED_)
#define AFX_WINDOWEDSHAPES_H__6912D105_781A_11D3_89A0_00500422D52A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_WINDOWEDSHAPES_H__6912D105_781A_11D3_89A0_00500422D52A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\ddProcMan.h ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: ddProcMan.h                                                       *
*    Definition file for:                                                   *
*       ddpm.c                                                              *
*    Suggested new name:                                                    *
*       ddProcMan.c                                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 06/16/99 - created.                              *
*                                                                           *
\***************************************************************************/

#ifndef __DDPROCMAN_H_
#define __DDPROCMAN_H_

#include "CompileControl.h"

#define EVENTNAME_IDLE                  "NV_Idle"
#define EVENTNAME_OVL_FLIP_EVEN         "NV_OvlFlipEven"
#define EVENTNAME_OVL_FLIP_ODD          "NV_OvlFlipOdd"
#define EVENTNAME_DMA_TO_VID            "NV_DMAToVid"
#define EVENTNAME_CONVERT               "NV_Convert"
#define EVENTNAME_SUBPICTURE            "NV_SubPicture"
#define EVENTNAME_PRESCALE              "NV_PreScale"
#define EVENTNAME_COLOURCONTROL         "NV_ColourControl"
#define EVENTNAME_TFILTER               "NV_TFilter"
#define EVENTNAME_DFILTER               "NV_DFilter"
#define EVENTNAME_DISPATCH_GO           "NV_DispatchGo"
#define EVENTNAME_DISPATCH_DONE         "NV_DispatchDone"
#define EVENTNAME_FSMIRROR              "NV_FSMirror"
#define EVENTNAME_PRIMARY0_FLIP_EVEN    "NV_Primary0FlipEven"
#define EVENTNAME_PRIMARY0_FLIP_ODD     "NV_Primary0FlipOdd"
#define EVENTNAME_PRIMARY1_FLIP_EVEN    "NV_Primary1FlipEven"
#define EVENTNAME_PRIMARY1_FLIP_ODD     "NV_Primary1FlipOdd"
#define EVENTNAME_TIMER                 "NV_Timer"

#if IS_WINNT5

#define CREATE_EVENT(pHandle) EngCreateEvent(pHandle)
#define DELETE_EVENT(handle) EngDeleteEvent(handle)
#define HDRVEVENT PEVENT
#define EVENT_ERROR

#elif IS_WINNT4

// TBD - mlavoie: resolve issues with events on NT4

// VERY unsure as to whether the ddraw portion of the display can call these.
//   the miniport can so we may need to find another way -mlavoie
// Also very unsure as to whether these 2 funcs correspond to create & delete
#define CREATE_EVENT(pHandle) KeInitializeEvent(pHandle,NotificationEvent,FALSE)
#define DELETE_EVENT(handle) KeResetEvent(&(handle))
//KeWaitForSingleObject
#define HDRVEVENT NvU32
#define EVENT_ERROR

#elif IS_WIN9X

#define HDRVEVENT HANDLE
#define EVENT_ERROR {   \
    pmDeleteProcess(lpProcInfo->dwProcessID);   \
    pmAddProcess(pDriverData, GetCurrentProcessId());        }

#else
#error Unhandled OS.
#endif

// process manager structure
typedef struct tagProcessInfo {
    unsigned long dwProcessID;
    HDRVEVENT     hIdleSyncEvent0;
    HDRVEVENT     hIdleSyncEvent3;
    HDRVEVENT     hOvlFlipEvenEvent0;
    HDRVEVENT     hOvlFlipEvenEvent3;
    HDRVEVENT     hOvlFlipOddEvent0;
    HDRVEVENT     hOvlFlipOddEvent3;
    HDRVEVENT     hDMABlitToVid0;
    HDRVEVENT     hDMABlitToVid3;
    HDRVEVENT     hConvert0;
    HDRVEVENT     hConvert3;
    HDRVEVENT     hSubPicture0;
    HDRVEVENT     hSubPicture3;
    HDRVEVENT     hColourControl0;
    HDRVEVENT     hColourControl3;
    HDRVEVENT     hTFilter0;
    HDRVEVENT     hTFilter3;
    HDRVEVENT     hDFilter0;
    HDRVEVENT     hDFilter3;
    HDRVEVENT     hFSMirror0;
    HDRVEVENT     hFSMirror3;
    HDRVEVENT     hPrimary0FlipEven0;
    HDRVEVENT     hPrimary0FlipEven3;
    HDRVEVENT     hPrimary0FlipOdd0;
    HDRVEVENT     hPrimary0FlipOdd3;
    HDRVEVENT     hPrimary1FlipEven0;
    HDRVEVENT     hPrimary1FlipEven3;
    HDRVEVENT     hPrimary1FlipOdd0;
    HDRVEVENT     hPrimary1FlipOdd3;
    HDRVEVENT     hTimer0;
    HDRVEVENT     hTimer3;
    struct tagProcessInfo *lpNext;
} PROCESSINFO, *LPPROCESSINFO;

#ifdef __cplusplus
extern "C" {
#endif

// public
#ifndef WINNT
HANDLE        ConvertRing3EventToRing0 (HDRVEVENT hEventRing3);
BOOL          CloseRing0Handle         (HDRVEVENT hEventRing0);
#endif // WINNT
typedef struct _GLOBALDATA GLOBALDATA;
LPPROCESSINFO pmGetProcess             (GLOBALDATA *pDriverData, DWORD processID);
BOOL          pmAddProcess             (GLOBALDATA *pDriverData, DWORD processID);
BOOL          pmDeleteProcess          (DWORD processID);
BOOL          pmDeleteProcessPDD       (GLOBALDATA *pDriverData, DWORD processID);
void          pmDeleteAllProcesses     (GLOBALDATA *pDriverData);

HRESULT NvResetEvent(HDRVEVENT hEvent);
HRESULT NvSetEvent(HDRVEVENT hEvent);
HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DDPROCMAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\sdk\nvidia\samples\SDK Renderer\Windowed Shapes\Windowed Shapes.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

// Windowed Shapes.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
#include "resource.h"

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];								// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];								// The title bar text
UINT renderType;
BOOL renderShapes;


// Foward declarations of functions included in this code module:
ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK	About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_WINDOWEDSHAPES, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_WINDOWEDSHAPES);

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}



//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_WINDOWEDSHAPES);
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= (LPCSTR)IDC_WINDOWEDSHAPES;
	wcex.lpszClassName	= szWindowClass;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   HWND hWnd;

   hInst = hInstance; // Store instance handle in our global variable

   hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
	NV_STATUS status;

	switch (message) 
	{
		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_ABOUT:
				   DialogBox(hInst, (LPCTSTR)IDD_ABOUTBOX, hWnd, (DLGPROC)About);
				   break;
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;

				// draw menu selections
				case ID_RENDER_LINES:
				case ID_RENDER_RECTANGLES:
				case ID_RENDER_BLITS:
				{
					// flag which draw function to execute at paint time
					renderType = wmId;
					renderShapes = true;
					RECT rClient;
					GetClientRect(hWnd, &rClient);
					InvalidateRect(hWnd, &rClient, true);
					UpdateWindow(hWnd);
					break;
				}

				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;
		case WM_CREATE:

			// initialize the NV device
			if ((status = NvCreate()) != NV_STATUS_SUCCESS)
			{
				// if there was an error, display it and shut down the app
				NvReportError(status);
				DestroyWindow(hWnd);
			}

			break;
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);

			// execute the drawing function only once after menu selection
			if (renderShapes)
			{
				switch(renderType)
				{
					case ID_RENDER_LINES:
						status = NvDrawLines(hWnd);
						break;
					case ID_RENDER_RECTANGLES:
						status = NvDrawRectangles(hWnd);
						break;
					case ID_RENDER_BLITS:
						status = NvBlits(hWnd);
						break;
				}
				renderShapes = false;

				// if there was an error, display it and shut down the app
				if (status != NV_STATUS_SUCCESS)
				{
					NvReportError(status);
					DestroyWindow(hWnd);
				}
			}

			EndPaint(hWnd, &ps);

			break;
		case WM_DESTROY:

			// free up the client when the app's window is destroyed
			NvDestroy();

			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

// Mesage handler for about box.
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:
				return TRUE;

		case WM_COMMAND:
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\eewinma2.h ===
//*****************************Module*Header******************************
//
// Module Name: eewinman2.h
//
// WINman display propterty page interface version 2
// for board detection, mode set,...
//
// FNicklisch 09/14/2000: 
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1998-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef _EeWINma2_h_
#define _EeWINma2_h_


/*
** $Header$
**
** MODULE:   EeWINma2.h
**
** AUTHOR:   Torsten Horn, Copyright (c) 1999 ELSA AG, Aachen (Germany)
**
** PROJECT:  ELSA Graphics Software
**
** PURPOSE:  ELSA Escape Windows driver functions for WINman
**
** NOTES:    1998-10-01 THorn: First release.
**           1999-05-04 THorn: Only comment extended/modified.
**           1999-08-03 THorn: New WINMAN_MOD_DFP and comments extended.
**           1999-08-18 THorn: New WINMAN_TIM_... flags.
**           1999-11-12 THorn: ET_WINMAN2_DDC_EDID_GET extended for EDID2.
*/


/*-----------------------------------------------------------------
  For the principle architecture of this kind of ELSA escape functions see 
  the header elsa\ElsaEsc.h (which must be included before this header).

  This header EeWINma2.h defines the escape functions:
    SUBESC_ET_WINMAN2_DATA_GET
    SUBESC_ET_WINMAN2_DATA_SET
    SUBESC_ET_WINMAN2_DDC_EDID_GET
  
  Simplyfied example for getting data from the driver (in case of 16 boards):
    ET_QUERY.dwSubEsc  = SUBESC_ET_WINMAN2_DATA_GET;
    ET_QUERY.dwSize    = sizeof(ET_QUERY);
    ET_QUERY.dwOutSize = sizeof(ET_WINMAN2_DATA_GET) +
                         sizeof(ET_WINMAN2_DATA_BRD_R) * 15;  // when 16 boards
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               ET_QUERY.dwSize,    (LPCSTR)&ET_QUERY,
               ET_QUERY.dwOutSize,  (LPSTR)&ET_WINMAN2_DATA_GET );

  Simplyfied example for setting data to the driver (in case of 16 boards):
    ET_WINMAN2_DATA_SET.hdr.dwSubEsc  = SUBESC_ET_WINMAN2_DATA_SET;
    ET_WINMAN2_DATA_SET.hdr.dwSize    = sizeof(ET_WINMAN2_DATA_SET);
    ET_WINMAN2_DATA_SET.hdr.dwOutSize = sizeof(ET_WINMAN2_DATA_GET) +
                                        sizeof(ET_WINMAN2_DATA_BRD_R) * 15;
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               ET_WINMAN2_DATA_SET.hdr.dwSize,    (LPCSTR)&ET_WINMAN2_DATA_SET,
               ET_WINMAN2_DATA_SET.hdr.dwOutSize,  (LPSTR)&ET_WINMAN2_DATA_GET );

  dwOutSize (in ET_QUERY and ET_WINMAN2_DATA_SET.hdr) must match
    sizeof(ET_WINMAN2_DATA_GET) + sizeof(ET_WINMAN2_DATA_BRD_R) * n;
  where n usually is equal to
    ET_WINMAN2_DATA_GET.dwNumBoardsInstalled - 1
  but n may be less eg. with WINMAN_SET_CHECK, see below.

  The first call usually is a SUBESC_ET_WINMAN2_DATA_GET with a return 
  structure size (dwOutSize) fitting for only one board. If
    ExtEscape() > 0  &&
    lResult == WINMAN_RESULT_ERROR_SIZE  &&
    dwNumBoardsInstalled > 1,
  then the next SUBESC_ET_WINMAN2_DATA_GET call has the correct 
  structure size in dwOutSize for getting the data of all boards.

  SUBESC_ET_WINMAN2_DATA_SET may be called for less than all boards 
  (especially with WINMAN_SET_CHECK). In this case the return structure 
  size (dwOutSize) may fit to this reduced number of boards (what should 
  not produce an error code).
  SUBESC_ET_WINMAN2_DATA_SET must always return either with 
  WINMAN_RESULT_ERROR or with valid and complete data in ET_WINMAN2_DATA_GET.

  You must carefully distinguish between the different return values:
    ExtEscape() must return:
      - zero if the escape function or the subescape is not implemented,
      - less than zero if an error in the escape interface occures (may 
        be ET_QUERY.dwSize is too small),
      - greater than zero if the escape interface is successful, even 
        when another error occures. Other error codes (for problems with 
        the data) are returned in lResult.
    ET_WINMAN2_DATA_GET.lResult must return the fitting WINMAN_RESULT_...
      When the size of the output structure was too small for all needed 
      boards, you must return WINMAN_RESULT_ERROR_SIZE.
      When all data send to the driver are ok, but eg. only the pixel 
      clock (may be of only one board) is too high, you either must return 
      WINMAN_RESULT_ERROR, or better would be, you would return 
      WINMAN_RESULT_MODIFIED and reduce the pixel clock to the max. allowed 
      value.
      With WINMAN_RESULT_ERROR the returned ET_WINMAN2_DATA_GET structure 
      may have invalid data. With WINMAN_RESULT_OK or WINMAN_RESULT_MODIFIED 
      the returned ET_WINMAN2_DATA_GET data must be o.k. and complete for 
      both kind of calls (SUBESC_ET_WINMAN2_DATA_GET and 
      SUBESC_ET_WINMAN2_DATA_SET).
    ET_WINMAN2_DATA_BRD_RW.dwFlags has flags for each board.
      With WINMAN_BRD_MODIFIED you can decide, for which board the data 
      were modified.
    ET_WINMAN2_DATA_GET.dwDrvModFlags returns with the WINMAN_MOD_... flag 
      bits some modification possibilities/capabilities (common for all 
      boards).

  -----------------------------------------------------------------*/


/* #include <elsa\ElsaEsc.h> */


/* Defines for driver result value in lResult
   (used eg. in ET_WINMAN2_DATA_GET and ET_WINMAN2_DDC_EDID_GET). */
#define WINMAN_RESULT_OK          0  /* o.k., no modification */
#define WINMAN_RESULT_ERROR      -1  /* error (returned data invalid) */
#define WINMAN_RESULT_ERROR_SIZE -2  /* error: dwOutSize wrong, 
                                        see comment to dwOutSize in header.
                                        Only the following members of 
                                        ET_WINMAN2_DATA_GET are guaranted to 
                                        be valid: dwSize, lResult, 
                                        dwNumBoardsInstalled, dwNumBoardsActive;
                                        other returned data may be invalid */
#define WINMAN_RESULT_MODIFIED    1  /* data modified;
                                        all data are ok, but only eg. the 
                                        pixel clock was too high; pixel 
                                        clock is reduced to max. allowed 
                                        value */

/* Defines for modification possibilities/capabilities flags in dwDrvModFlags
   (used in ET_WINMAN2_DATA_GET). */
#define WINMAN_MOD_BPP            1  /* bpp changable */
#define WINMAN_MOD_HZ             2  /* new Hz values definable */
#define WINMAN_MOD_TIM            4  /* complete timing definable */
#define WINMAN_MOD_PAN_HOR        8  /* horizontal panning possible */
#define WINMAN_MOD_PAN_VER       16  /* vertical panning possible */
#define WINMAN_MOD_MULTI_HOR     32  /* multiscreen hor. possible */
#define WINMAN_MOD_MULTI_VER     64  /* multiscreen ver. possible */
#define WINMAN_MOD_MULTI_H_V    128  /* multiscreen hor.+ver. both */
#define WINMAN_MOD_RES          256  /* new resolution values definable */
#define WINMAN_MOD_DFP          512  /* DFP Digital Flat Panel (different 
                                        resolutions with one fix timing) */

/* Defines for some board flags in dwFlags
   (used in ET_WINMAN2_DATA_BRD_RW). */
#define WINMAN_BRD_MODIFIED       1  /* data of this board modified */

/* Defines for some timing flags (sync polarity, interlace) in dwTimFlags
   (used in ET_WINMAN2_DATA_BRD_RW). */
#define WINMAN_TIM_HSYNC_POS      8  /* same as GFX_HSYNC_POS */
#define WINMAN_TIM_VSYNC_POS      4  /* same as GFX_VSYNC_POS */
#define WINMAN_TIM_ILC            1  /* same as GFX_ILC */
#define WINMAN_TIM_FIXED_TIMING  16  /* same as GFX_FIXED_TIMING */

/* Defines for action in dwCheckAddRemove
   (used in ET_WINMAN2_DATA_SET). */
#define WINMAN_SET_CHECK          1  /* check (may be modify) this mode */
#define WINMAN_SET_ADD            2  /* add this mode to allowed modes */
#define WINMAN_SET_REMOVE         3  /* remove this mode */
/* The following two are not used till now (for future use): */
#define WINMAN_SET_DO_TEST        4  /* switch only for test screen */
#define WINMAN_SET_DO_PERM        5  /* switch graphics mode permanent */


/* Read/write data of each board
   (used in ET_WINMAN2_DATA_GET and ..._DATA_SET). */
typedef struct tagET_WINMAN2_DATA_BRD_RW
{
  /* These values must always be valid: */
  DWORD dwPanOriginX;            /* panning x-origin */
  DWORD dwPanOriginY;            /* panning y-origin */
  DWORD dwVisOriginX;            /* visible x-origin */
  DWORD dwVisOriginY;            /* visible y-origin */
  DWORD dwPanSizeX;              /* panning x-size */
  DWORD dwPanSizeY;              /* panning y-size */
  DWORD dwVisSizeX;              /* visible x-size */
  DWORD dwVisSizeY;              /* visible y-size */
  DWORD dwBpp;                   /* bpp */
  DWORD dwColorsNum;             /* num. of colors */
  DWORD dwHz;                    /* Hz refresh rate */
  /* These values must be zero if not used: */
  DWORD dwFlags;                 /* flag bits, eg. WINMAN_BRD_MODIFIED */
  DWORD dwTimPixFreq;            /* pixel clock frequency in Hz */
  DWORD dwTimHTot;               /* horizontal total number of pixels */
  DWORD dwTimHFp;                /* horizontal frontporch in pixels */
  DWORD dwTimHSw;                /* horizontal sync width in pixels */
  DWORD dwTimHBp;                /* horizontal backporch in pixels */
  DWORD dwTimVTot;               /* vertical total number of lines */
  DWORD dwTimVFp;                /* vertical frontporch in lines */
  DWORD dwTimVSw;                /* vertical sync width in lines */
  DWORD dwTimVBp;                /* vertical backporch in lines */
  DWORD dwTimFlags;              /* tim. flag bits: WINMAN_TIM_... */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
} ET_WINMAN2_DATA_BRD_RW, *PET_WINMAN2_DATA_BRD_RW;


/* Read-only data of each board
   (used in ET_WINMAN2_DATA_GET). */
typedef struct tagET_WINMAN2_DATA_BRD_R
{
  /* Board data used in ET_WINMAN2_DATA_GET and ..._DATA_SET: */
  ET_WINMAN2_DATA_BRD_RW rw;     /* read/write data */
  /* These values must be zero if not used: */
  DWORD dwPixFreqMax08;          /* max. possible pixel clock (in Hz) at  8bpp */
  DWORD dwPixFreqMax16;          /* max. possible pixel clock (in Hz) at 16bpp */
  DWORD dwPixFreqMax24;          /* max. possible pixel clock (in Hz) at 24bpp */
  DWORD dwPixFreqMax32;          /* max. possible pixel clock (in Hz) at 32bpp */
  DWORD dwMemSizePan;            /* RAM usable for visible and virtual screen */
  DWORD dwMemSizeAll;            /* size of all RAM (e.g. VRAM + DRAM) */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
  char  sBoardname[40];          /* board name */
  char  sSerNum[24];             /* serial number */
} ET_WINMAN2_DATA_BRD_R, *PET_WINMAN2_DATA_BRD_R;


/* Data WINman gets from the Windows driver. */
typedef struct tagET_WINMAN2_DATA_GET
{
  DWORD dwSize;                  /* sizeof this struct with correct num of brd */
  LONG  lResult;                 /* WINMAN_RESULT_OK, ...ERROR..., ...MODIFIED */
  DWORD dwDrvModFlags;           /* driver modify flags WINMAN_MOD_... */
  DWORD dwReserved;              /* == 0 (reserved) */
  DWORD dwNumBoardsInstalled;    /* number of all installed boards */
  DWORD dwNumBoardsActive;       /* number of active used boards */
  /* The following struct as often as dwNumBoardsActive: */
  ET_WINMAN2_DATA_BRD_R brd[1];  /* data of all boards */
} ET_WINMAN2_DATA_GET, *PET_WINMAN2_DATA_GET;


/* Data WINman writes to the Windows driver. */
typedef struct tagET_WINMAN2_DATA_SET
{
  ET_QUERY hdr;
  DWORD dwCheckAddRemove;        /* WINMAN_SET_CHECK, ..._ADD, ..._DO_... */
  DWORD dwReserved1;             /* == 0 (reserved) */
  DWORD dwReserved2;             /* == 0 (reserved) */
  DWORD dwSizeX;                 /* x-size of desktop (over all monitors) */
  DWORD dwSizeY;                 /* y-size of desktop (over all monitors) */
  DWORD dwNumBoardsActive;       /* number of active used boards */
  /* The following struct as often as dwNumBoardsActive: */
  ET_WINMAN2_DATA_BRD_RW brd[1]; /* data of all boards */
} ET_WINMAN2_DATA_SET, *PET_WINMAN2_DATA_SET;


/*-----------------------------------------------------------------
  SUBESC_ET_WINMAN2_DDC_EDID_GET
  
  Example (m=0 for EDID1 and m=1 for EDID2):
    ET_QUERY.dwSubEsc  = SUBESC_ET_WINMAN2_DDC_EDID_GET;
    ET_QUERY.dwSize    = sizeof(ET_QUERY);
    ET_QUERY.dwOutSize = sizeof(ET_WINMAN2_DDC_EDID_GET) + m*128;
    ET_QUERY.dwBoard   = n;
    ExtEscape( hDC, ESC_ELSA_TOOLS,
               sizeof(  ET_QUERY ),
               (LPCSTR)&ET_QUERY,
               sizeof(  ET_WINMAN2_DDC_EDID_GET ) + m*128,
               (LPSTR) &ET_WINMAN2_DDC_EDID_GET );
  -----------------------------------------------------------------*/


/* DDC EDID structure WINman gets from the Windows driver.
   This structure  is for EDID 1.x with 128 bytes 
   of data as well as for EDID 2.x with 256 bytes.
   When WINman querries with wrong ET_QUERY.dwOutSize value, 
   the driver has to return WINMAN_RESULT_ERROR_SIZE. 
   Then WINman must try with another ET_QUERY.dwOutSize. */
typedef struct tagET_WINMAN2_DDC_EDID_GET
{
  DWORD dwSize;                   /* sizeof(ET_WINMAN2_DDC_EDID_GET)+m*128 */
  LONG  lResult;                  /* WINMAN_RESULT_OK, WINMAN_RESULT_ERROR... */
  unsigned char ddcEdid[128][1];  /* VESA DDC EDID structure */
} ET_WINMAN2_DDC_EDID_GET, *PET_WINMAN2_DDC_EDID_GET;


#endif  // #ifndef _EeWINma2_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\ddPriv.h ===
#ifndef _DDPRIV_
#define _DDPRIV_

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       ddpriv.h
 *  Content:    header for ddpriv.cpp
 *
 ***************************************************************************/

typedef struct _MYDCICMD
{
	ULONG	dwCommand;
	ULONG	dwParam1;
	ULONG 	dwParam2;
	ULONG	dwVersion;
	ULONG	dwReserved;
} MYDCICMD;

typedef struct _MYDD32BITDRIVERDATA
{
    UCHAR   szName[260];            // 32-bit driver name
    UCHAR   szEntryPoint[64];       // entry point
    ULONG   dwContext;              // context to pass to entry point
} MYDD32BITDRIVERDATA;

#define DD_VERSION              0x00000200l
#define DDCREATEDRIVEROBJECT    10
#define DDGET32BITDRIVERNAME    11
#define DDNEWCALLBACKFNS        12
#define DDVERSIONINFO           13
#define DDDESTROYDRIVEROBJECT   99

#define MAX_ADAPTERS            9

#ifdef WINNT
#ifndef NV_ESC_DDPRIV_DMABLIT
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88
#endif

#ifndef NV_ESC_DDPRIV_OVERLAYCONTROL
// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89
#endif
#endif // WINNT

// --------------------------------------------------------------------------
// nvOverlayControl
//      Overlay control callback
//
// Command Structure
// -----------------
// NVOCCMD_GETCAPS
//      dwSize
//      dwDevice
//      returns caps
//          dwCaps1
//              NVOCCAPS1_BRIGHTNESS
//              NVOCCAPS1_CONTRAST
//              NVOCCAPS1_HUE
//              NVOCCAPS1_SATURATION
//              NVOCCAPS1_SHARPNESS
//              NVOCCAPS1_GAMMA
//          dwCaps2
//              NVOCCAPS2_HQVUPSCALE
//              NVOCCAPS2_TFILTER
//              NVOCCAPS2_DFILTER
//              NVOCCAPS2_FSMIRROR
//              NVOCCAPS2_OVLZOOM
//          dwCaps3
//              NVOCCAPS3_SUBPICTURE
//              NVOCCAPS3_LATEFLIPSYNC
//              NVOCCAPS3_SPLITVPP
//              NVOCCAPS3_BLTCAPS
//          dwCaps4
//              NVOCCAPS4_SMA
//              NVOCCAPS4_IMB
//              NVOCCAPS4_DEVICEHASOVL
//              NVOCCAPS4_MULTIHEADNUM (number of display heads on this device)
//              NVOCCAPS4_MULTIHEADMODE (0 = single, 1 = span, 2 = clone)
//              NVOCCAPS4_HEAD0_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//              NVOCCAPS4_HEAD1_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//          dwCaps5
//              NVOCCAPS5_BLT_YUV9_2_YUV422
//              NVOCCAPS5_BLT_YUV12_2_YUV422
//              NVOCCAPS5_BLT_YC12_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_RGB8
//              NVOCCAPS5_BLT_YUV422_2_RGB15
//              NVOCCAPS5_BLT_YUV422_2_RGB16
//              NVOCCAPS5_BLT_YUV422_2_RGB32
//              NVOCCAPS5_BLT_SYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2SYUV
//              NVOCCAPS5_BLT_SYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2SRGB
//              NVOCCAPS5_BLT_SRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2SRGB
//              NVOCCAPS5_BLT_2RGBTEX
// NVOCCMD_SETCOLORCONTROL
//      dwSize
//      dwDevice
//      ccData
//          dwEnable (ignored for NV10 and above, always enabled)
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  lBrightness (range is -256 to +255)
//              NVOCCC_CONTRAST
//                  lContrast (range is 0 to 200)
//              NVOCCC_HUE
//                  lHue (range is 0 to 360)
//              NVOCCC_SATURATION
//                  lSaturation (range is 0 to 200)
// NVOCCMD_GETCOLORCONTROL
//      dwSize
//      dwDevice
//      returns ccData
//          returns dwEnable
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          returns dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  returns lBrightness
//              NVOCCC_CONTRAST
//                  returns lContrast
//              NVOCCC_HUE
//                  returns lHue
//              NVOCCC_SATURATION
//                  returns lSaturation
// NVOCCMD_SETFEATURE (enables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE (always enable if enough memory (8M))
//          NVOCF1_TFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[0] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_TF_PRECOPY
//          NVOCF1_DFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[1] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_DF_PRECOPY
//          NVOCF1_FSMIRROR (only enable with dual head and large memory)
//              lCoefficient[4]:
//                  bits 0-3: head number
//                            0 = disable FSVM
//                            1 = display 1
//                            2 = display 2
//                            15 = autoselect display
//                  bits 4-7: aspect ratio
//                            0 = stretch to display full screen
//                            1 = preserve aspect of source (assume square pixels)
//                            3 = force anamorphic 16:9
//                            5 = track overlay aspect
//                            9 = force TV 4:3
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-19: zoom factor, 0 = 1x, 255 = 2x
//                  bit 20: 0 = use current display size
//                          1 = let driver pick the display size
//                  bit 21: 0 = independent FS and overlay zoom
//                          1 = FS zoom tracks overlay zoom controls
//                  bit 22: 0 = disable DVD output to TV
//                          1 = enable DVD output to TV
//          NVOCF1_OVLZOOM
//              lCoefficient[5]:
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-23: zoom factor, 0 = 1x, 255 = 2x
//          NVOCF1_DELIVERYCONTROL
//              lCoefficient[6]: low 32 bits of frame period (in ns)
//              lCoefficient[7]: high 32 bits of frame period (in ns)
//          NVOCF1_LATEFLIPSYNC
//      dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = set to 0, 2, 3, 4, or 6
//              lCoefficient[3] = reserved
// NVOCCMD_RESETFEATURE (disables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//          NVOCF1_DFILTER
//          NVOCF1_FSMIRROR
//          NVOCF1_OVLZOOM
//          NVOCF1_DELIVERYCONTROL
//          NVOCF1_LATEFLIPSYNC
// NVOCCMD_GETFEATURE
//      dwSize
//      dwDevice
//      returns dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//              returns lCoefficient[0]
//          NVOCF1_DFILTER
//              returns lCoefficient[1]
//          NVOCF1_FSMIRROR
//              returns lCoefficient[4]
//          NVOCF1_OVLZOOM
//              returns lCoefficient[5]
//          NVOCF1_DELIVERYCONTROL
//              returns lCoefficient[6]
//                      lCoefficient[7]
//          NVOCF1_LATEFLIPSYNC
//      returns dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = max VPP work surfaces
//              lCoefficient[3] = VPP work surfaces currently allocated
//

#define OVERLAYCONTROLCALLBACK "nvOverlayControl"

typedef enum { 
    NVOCERR_OK              = 0,
    NVOCERR_GENERIC_WARN    = 1,
    NVOCERR_GENERIC_FATAL   = 0x80000001,
    NVOCERR_BAD_COMMAND     = 0x80000002,
    NVOCERR_INVALID_PARMS   = 0x80000003,
    NVOCERR_ALREADY_ACTIVE  = 0x80000004,
    NVOCERR_NOT_SUPPORTED   = 5,
    NVOCERR_BAD_DEVICE      = 0x80000006
} NVOCERROR;

typedef enum {
    NVOCCMD_NOOP            = 0,
    NVOCCMD_GETCAPS         = 1,
    NVOCCMD_SETCOLORCONTROL = 2,
    NVOCCMD_GETCOLORCONTROL = 3,
    NVOCCMD_SETFEATURE      = 4,
    NVOCCMD_RESETFEATURE    = 5,
    NVOCCMD_GETFEATURE      = 6
} NVOCCOMMAND;

typedef struct {
    unsigned long   dwCCFlags;
    unsigned long   dwEnable;
    long            lBrightness;
    long            lContrast;
    long            lHue;
    long            lSaturation;
    long            lSharpness;
    long            lGamma;
} NVOCCCDATA, *LPNVOCCCDATA;

#define NVOCCC_BRIGHTNESS   0x1
#define NVOCCC_CONTRAST     0x2
#define NVOCCC_HUE          0x4
#define NVOCCC_SATURATION   0x8
#define NVOCCC_SHARPNESS    0x10
#define NVOCCC_GAMMA        0x20

typedef struct {
    unsigned long dwCaps1;
    unsigned long dwCaps2;
    unsigned long dwCaps3;
    unsigned long dwCaps4;
    unsigned long dwCaps5;
} NVOCCAPS, *LPNVOCCAPS;

#define NVOCCAPS1_BRIGHTNESS    0x1
#define NVOCCAPS1_CONTRAST      0x2
#define NVOCCAPS1_HUE           0x4
#define NVOCCAPS1_SATURATION    0x8
#define NVOCCAPS1_SHARPNESS     0x10
#define NVOCCAPS1_GAMMA         0x20

#define NVOCCAPS2_HQVUPSCALE    0x1
#define NVOCCAPS2_TFILTER       0x2
#define NVOCCAPS2_DFILTER       0x4
#define NVOCCAPS2_FSMIRROR      0x8
#define NVOCCAPS2_OVLZOOM       0x10

#define NVOCCAPS3_SUBPICTURE        0x1
#define NVOCCAPS3_LATEFLIPSYNC      0x2
#define NVOCCAPS3_SPLITVPP          0x4
#define NVOCCAPS3_DELIVERYCONTROL   0x8
#define NVOCCAPS3_BLTCAPS           0x80000000

#define NVOCCAPS4_IMB           0x1
#define NVOCCAPS4_SMA           0x2
#define NVOCCAPS4_DEVICEHASOVL  0x4
#define NVOCCAPS4_MULTIHEADNUM  0x000F0000
#define NVOCCAPS4_MULTIHEADMODE 0x00F00000
#define NVOCCAPS4_HEAD0_TYPE    0x0F000000
#define NVOCCAPS4_HEAD1_TYPE    0xF0000000

#define NVOCCAPS5_BLT_YUV9_2_YUV422     0x00000001
#define NVOCCAPS5_BLT_YUV12_2_YUV422    0x00000002
#define NVOCCAPS5_BLT_YC12_2_YUV422     0x00000004
#define NVOCCAPS5_BLT_YUV422_2_YUV422   0x00000008
#define NVOCCAPS5_BLT_YUV422_2_RGB8     0x00000100
#define NVOCCAPS5_BLT_YUV422_2_RGB15    0x00000200
#define NVOCCAPS5_BLT_YUV422_2_RGB16    0x00000400
#define NVOCCAPS5_BLT_YUV422_2_RGB32    0x00000800
#define NVOCCAPS5_BLT_SYUV2VYUV         0x00010000
#define NVOCCAPS5_BLT_VYUV2VYUV         0x00020000
#define NVOCCAPS5_BLT_VYUV2SYUV         0x00040000
#define NVOCCAPS5_BLT_SYUV2VRGB         0x00100000
#define NVOCCAPS5_BLT_VYUV2VRGB         0x00200000
#define NVOCCAPS5_BLT_VYUV2SRGB         0x00400000
#define NVOCCAPS5_BLT_SRGB2VRGB         0x01000000
#define NVOCCAPS5_BLT_VRGB2VRGB         0x02000000
#define NVOCCAPS5_BLT_VRGB2SRGB         0x04000000
#define NVOCCAPS5_BLT_2RGBTEX           0x80000000

typedef struct {
    unsigned long dwFeature1;
    unsigned long dwFeature2;
    unsigned long dwFeature3;
    unsigned long dwFeature4;
    long          lCoefficient[16];
} NVOCFEATUREDATA;

#define NVOCF1_HQVUPSCALE       0x1
#define NVOCF1_TFILTER          0x2
#define NVOCF1_LATEFLIPSYNC     0x4
#define NVOCF1_DFILTER          0x8
#define NVOCF1_FSMIRROR         0x10
#define NVOCF1_OVLZOOM          0x20
#define NVOCF1_DELIVERYCONTROL  0x40

#define NVOCF2_VPPMAXSURFACES   0x1

#define NVOCF_TF_PRECOPY   0x00000001
#define NVOCF_DF_PRECOPY   0x00000002

typedef struct {
    unsigned long dwSize;
    unsigned long dwDevice;

    // command
    NVOCCOMMAND cmd;
    unsigned long dwCmdFlags;

    // data
    union {
        NVOCCAPS        caps;
        NVOCCCDATA      ccData;
        NVOCFEATUREDATA featureData;
    };

    unsigned long dwReserved[40];
} NVOCDATATYPE, *LPNVOCDATATYPE;

typedef NVOCERROR (__stdcall *NVOVERLAYCONTROL)(LPNVOCDATATYPE data);


// --------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Obsolete.  Only use with rel3 drivers
//      If lpDDCC is NULL, callback returns caps
//
//      dwDevice            always 1
//      lpDDCC->dwSize      sizeof(DDCOLORCONTROL)
//      lpDDCC->dwFlags     DDCOLOR_CONTRAST | DDCOLOR_BRIGHTNESS | DDCOLOR_HUE | DDCOLOR_SATURATION
//                          determines which members hold valid data
//      lpDDCC->lBrightness range is from -256 to +255
//      lpDDCC->lContrast   range is from 0 to 200
//      lpDDCC->lHue        range is from 0 to 360
//      lpDDCC->lSaturation range is from 0 to 200
//      lpDDCC->dwReserved1 0 = disable colour controls
//                          1 = enable with vertical chroma subsampling
//                          2 = enable with full chroma sampling
#define SETOVERLAYCOLORCONTROLCALLBACK "nvSetOverlayColorControl"

typedef DWORD (__stdcall *NVSETOVERLAYCOLORCONTROL)(DWORD dwDevice, LPDDCOLORCONTROL lpDDCC);


// --------------------------------------------------------------------------
// nvMoComp
//      Backdoor DMA blits and formatting for video
// 
// Command Structure
// -----------------
// NVS2VCMD_INIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV:
//              fpSrc
//          NVS2V_UYVY:
//              fpSrc
//          NVS2V_RGB16:
//              fpSrc
//          NVS2V_RGB32:
//              fpSrc
//          NVS2V_YC12
//              SrcYC12.fpY
//          NVS2V_YUV12
//              SrcYUV12.fpY (points to start of surface)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//      dwDstType (required only if using INDEXED type on BLIT)
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
// NVS2VCMD_RELEASE
//      dwSize
//      dwDevice
//      dwIndex
// NVS2VCMD_BLIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET (only use for V->S blits)
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YC12
//              SrcYC12.fpY
//              SrcYC12.fpC
//          NVS2V_YUV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//          NVS2V_YV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//              dwSrcYV12ChromaPitch
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET (only use for S->V blits)
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//      dwDstType
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
//          NVS2V_INDEXED (uses last YUY2 or UYVY state)
//              dwDstSize
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_QUERY_IDLE
//      dwSize
//      dwDevice
// NVS2VCMD_WAIT_FOR_IDLE
//      dwSize
//      dwDevice
//      dwTimeoutTime
// NVS2VCMD_SET_SUBPICTURE
//      dwSize
//      dwDevice
//      dwSPFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_SP_SUBRECT
//              dwSubRectX
//              dwSubRectY
//              dwSubRectWidth
//              dwSubRectHeight
//      dwSPType
//      dwSPPitch
//      fpSP
// NVS2VCMD_VPP_START
//      dwSize
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//      dwSrcPitch
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_VPP_ODD
//          NVS2VF_VPP_EVEN
//          NVS2VF_VPP_BOB
//          NVS2VF_VPP_INTERLEAVED
// NVS2VCMD_VPP_QUERY
//      dwSize
//      dwDevice
// NVS2VCMD_VPP_FLIP
//      dwSize
//      dwDevice
// NVS2VCMD_4CC_TO_VRGB
//      dwSize
//      dwIndex (0xFFFFFFFF means use video memory)
//      dwCmdFlags (optional)
//          NVS2VF_CRTC_SYNC
//              dwHead
//              dwScanline (blit will not begin until CRTC of specified head reaches this scanline)
//              dwTimeoutTime
//          NVS2VF_USE_DELIVERY_CTL
//              dwTimeoutTime
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_UYVY
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//          NVS2VF_SWIZZLED
//      dwDstType
//          NVS2V_RGB16
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//          NVS2V_RGB32
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_GET_TEXTURE_OFFSET
//      dwSize
//      dwDevice
//      fpTexture
//      returns fpTexture


#define MOCOMPCALLBACK "nvMoComp"

typedef enum {
    NVS2V_YC12      = 1,
    NVS2V_YUV12     = 2,
    NVS2V_YUYV      = 3,
    NVS2V_UYVY      = 4,
    NVS2V_DDSURF    = 5,
    NVS2V_INDEXED   = 6,
    NVS2V_YUVA16    = 7,
    NVS2V_YUVA32    = 8,
    NVS2V_YV12      = 9,
    NVS2V_RGB8      = 0x10,
    NVS2V_RGB16     = 0x11,
    NVS2V_RGB24     = 0x12,
    NVS2V_RGB32     = 0x13
} NVS2VSURFTYPE;

typedef enum {
    NVS2VCMD_NOOP               = 0,
    NVS2VCMD_INIT               = 1,
    NVS2VCMD_RELEASE            = 2,
    NVS2VCMD_BLIT               = 3,
    NVS2VCMD_QUERY_IDLE         = 4,
    NVS2VCMD_WAIT_FOR_IDLE      = 5,
    NVS2VCMD_SET_SUBPICTURE     = 6,
    NVS2VCMD_VPP_START          = 7,
    NVS2VCMD_VPP_QUERY          = 8,
    NVS2VCMD_VPP_FLIP           = 9,
    NVS2VCMD_4CC_TO_VRGB        = 0xA,
    NVS2VCMD_GET_TEXTURE_OFFSET = 0xB
} NVS2VCOMMAND;

typedef enum {
    NVS2VERR_OK             = 0,
    NVS2VERR_GENERIC_WARN   = 1,
    NVS2VERR_GENERIC_FATAL  = 0x80000001,
    NVS2VERR_BAD_COMMAND    = 0x80000002,
    NVS2VERR_INVALID_PARMS  = 0x80000003,
    NVS2VERR_INIT_FAILED    = 0x80000004,
    NVS2VERR_NO_EVENT       = 5,
    NVS2VERR_BUSY           = 6,
    NVS2VERR_TIMEOUT        = 7,
    NVS2VERR_BAD_DEVICE     = 0x80000008
} NVS2VERROR;

#define NVS2VF_OFFSET           0x00000001
#define NVS2VF_SP_SUBRECT       0x00000002
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
#define NVS2VF_VPP_ODD          0x00000010
#define NVS2VF_VPP_EVEN         0x00000020
#define NVS2VF_VPP_BOB          0x00000040
#define NVS2VF_VPP_INTERLEAVED  0x00000080
#define NVS2VF_LOCAL            0x00000100
#define NVS2VF_SYSTEM           0x00000200
#define NVS2VF_SWIZZLED         0x00000400
#define NVS2VF_CRTC_SYNC        0x00000800
#define NVS2VF_USE_DELIVERY_CTL 0x00001000

typedef struct {
    unsigned long dwSize;               // sizeof(NVS2VDATATYPE)
    
    // command data
    NVS2VCOMMAND  dwCmd;
    unsigned long dwCmdFlags;
    BOOL          bWaitForCompletion;
    unsigned long dwTimeoutTime;        // in ms
    unsigned long dwIndex;
    unsigned long dwDevice;
    unsigned long dwHead;
    unsigned long dwScanline;
    unsigned long dwReserved1[55];

    // neutral data
    unsigned long dwWidth;              // in pixels
    unsigned long dwHeight;             // in lines

    // source data
    unsigned long dwSrcFlags;
    NVS2VSURFTYPE dwSrcType;
    unsigned long dwSrcPitch;           // in bytes
    union {
        void  *fpTexture;
        void  *fpSrc;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpSrcDirectDrawSurface;  // used with NVS2V_DDSURF (not implemented)
        unsigned long dwSrcSize;        // used with NVS2V_INDEXED (not implemented)
        struct {
            void  *fpY;
            void  *fpC;
        } SrcYC12;                      // used with NVS2V_YC12 (Y and C must be contiguous)
        struct {
            void  *fpY;
            void  *fpU;
            void  *fpV;
        } SrcYUV12;                     // used with NVS2V_YUV12 (not implemented)
    };

    // destination data
    unsigned long dwDstFlags;
    NVS2VSURFTYPE dwDstType;
    unsigned long dwDstPitch;           // in bytes
    union {
        void  *fpDst;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpDstDirectDrawSurface;  // used with NVS2V_DDSURF
        unsigned long dwDstSize;        // used with NVS2V_INDEXED
        struct {
            void *fpY;
            void *fpC;
        } DstYC12;                      // used with NVS2V_YC12 (not implemented)
        struct {
            void *fpY;
            void *fpU;
            void *fpV;
        } DstYUV12;                     // used with NVS2V_YUV12 (not implemented)
        struct {
            void *fpRGB;
            unsigned long dwDstWidth;
            unsigned long dwDstHeight;
        } DstRGB;                       // used with the RGB surface types
    };

    // subpicture data
    unsigned long dwSPFlags;
    NVS2VSURFTYPE dwSPType;
    unsigned long dwSPPitch;
    unsigned long fpSP;
    unsigned long dwSubRectX;
    unsigned long dwSubRectY;
    unsigned long dwSubRectWidth;
    unsigned long dwSubRectHeight;

    // more source data
    unsigned long dwSrcYV12ChromaPitch;
    unsigned long dwSrcPixelBias;

    // pad
    unsigned long dwReserved2[40];
} NVS2VDATATYPE, *LPNVS2VDATATYPE;

typedef NVS2VERROR (__stdcall *NVMOCOMP)(LPNVS2VDATATYPE data);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\CompileControl.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _COMPILE_CONTROL_H_
#define _COMPILE_CONTROL_H_

// Activate this block to get an idea of what #defs are set if it isn't clear
#if 0
#if defined(_WIN32)
#pragma message("Got _WIN32")
#endif
#if defined(WIN32)
#pragma message("Got WIN32")
#endif
#if defined(WINNT)
#pragma message("Got WINNT")
#else
#pragma message("No WINNT")
#endif
#if defined(_WIN32_WINNT)
#pragma message("Got WIN32 NT version")
#endif
#if (_WIN32_WINNT < 0x0500)
#pragma message("NT VER <500")
#else
#pragma message("NT VER >=500")
#endif
#endif
		
		
#if (defined(WINNT) && (_WIN32_WINNT < 0x0500))
#define IS_WINNT4 1
#else
#undef IS_WINNT4
#endif

#if (defined(WINNT) && (_WIN32_WINNT >= 0x0500))
#define IS_WINNT5 1
#else
#undef IS_WINNT5
#endif

#if (defined (WIN32) && !defined(WINNT))
#define IS_WIN9X 1
#else
#undef IS_WIN9X
#endif

#if 0
#if (IS_WIN9X)
#pragma message("Compiling for OS = WIN9X")
#elif IS_WINNT4
#pragma message("Compiling for OS = WINNT4")
#elif IS_WINNT5
#pragma message("Compiling for OS = WINNT5")
#else
#error Unrecognized OS!
#endif
#endif

#if !(IS_WIN9X || IS_WINNT4 || IS_WINNT5)
#error Unrecognized OS!
#endif

#endif _COMPILE_CONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvioctl.h ===
#ifndef _nvioctl_h_
#define _nvioctl_h_

/*
** Copyright 1991-1999, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Header$
*/

#include <sys/ioctl.h>

/*
** IOCTLs defines and structures common between the kernel and the GL
*/

/* ---  first the defines --- */
#define IOCTL_NV_OPENGL                         1

#define IOCTL_NV_OPENGL_GET_SINGLE_BACK_1       1
#define IOCTL_NV_OPENGL_GET_SINGLE_DEPTH        2
#define IOCTL_NV_OPENGL_FREE_SINGLE_BACK_DEPTH  3

/* --- now the structure definitions --- */

typedef struct NvOpenGLCommandRec {
    int 	command;
    void *      ret;
} NvOpenGLCommand;

#endif /* _nvioctl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\elsaesc.h ===
//*****************************Module*Header******************************
//
// Module Name: elsaesc.h
//
// This file conatins all declarations for the ELSA Escape interface
// used by all tools and applications to access graphic driver data.
//
// FNicklisch 09/14/2000: 
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1998-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef __ELSAESC
#define __ELSAESC

/*
** $Header$
**
** MODULE:   ELSAESC.H
**
** AUTHOR:   Fred Nicklisch
**           Copyright (c) 1991-99 ELSA AG, Aachen (Germany)
**
** PROJECT:  ELSA Graphics Software
**
** PURPOSE:  define Escape interface between Windows 95/NT display driver
**           and tools
**
** DESCR:    All ELSA drivers will provide a escape interface to allow
**           user-applications (tools) to configure the display driver and
**           retrieve information. The application has to use ExtEscape.
**           The implementation depends on one single esc entry and
**           multiple subescapes.
**
**           WARNING: We only allow the basic types
**                    LONG, DWORD and char in all in and out structures!
**                    Don't use Tabs (blanks instead)
**                    Don't use german "Umlaute"
**
** NOTES:    01.12.97 FNicklis: First Release, basic functionality
**           02.12.97 MSuhre  : Added support for Monitor-Key,
**                              changed CHAR to char
**           03.12.97 SKuklik : Added support for DUO Boards
**           03.12.97 SKuklik : Added support for DUO Boards
**           04.12.97 FNicklis: struct packing and basic types
**           04.12.97 MSuhre  : #pragma pack (push/pop,..)
**                              push and pop are not valid for MS-C 1.52
**           06.03.98 tu      : Query and set value for string and dword added
**           06.03.98 FNicklis: Fixed "query and set value" to make it compilable
**           08.03.98 FNicklis: defined ET_SET_VALUE_RET
**           12.03.98 tu      : Added query and set value ID's for WinNT:
**                                HardwareInformation 0x20000500-0x200005ff
**                                Desktop coordinates 0x20000600-0x200006ff
**                                Some Basic/system values 0x20000002-0x20000004
**                              Added dwFlags to ET_VALUE_STRING and ET_VALUE_DWORD;
**                              Added return flags convention
**           12.03.98 THorn   : New grouping of the items in this file,
**                              no compiler relevant change.
**           13.03.98 tu      : Added value ID ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER
**           13.04.98 db      : replaced dwAlign member of ET_QUERY with dwBoard
**                              Somehow we have to know for what board we want to read or write
**           13.04.98 db      : number of dma buffers is not number of subbuffers (used the same ID)
**           12.05.98 THorn   : SUBESC_ET_WINMAN_DDC_EDID_GET added.
**           09.06.98 tu      : Transfer ESCAPE calls from EDDESC.H (SUBESC_ET_EDD_xxx)
**           08.07.98 tu      : Added value ID ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING (0x20000320)
**           14.08.98 FNicklis: Added value IDs ET_VALUE_DW_xx for NT driver
**           16.09.98 THorn   : SUBESC_ET_WINMAN2_... added.
**           25.09.98 tu      : added ET_VALUE_ERROR (0x80000000)
**                              added #pragma warning( disable:4201 ) at struct tagET_VERSION
**           30.09.98 FNicklis: Added version stamp and capabilities to ET_VERSION retrieved with
**                              SUBESC_ET_QUERY_VERSION_INFO
**           21.10.98 FNicklis: Extension to ET_VALUE_xx-interface (ET_VALUE_BLOCKED)
**           23.10.98 FNicklis: NT doesn't know FAR and somtimes doesn't know DWORD
**           25.10.98 FNicklis: Modified ET_VALUE_xx-interface to get reserved bits for OS internals
**           12.11.98 js:       ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER for OpenGL.SupportProDesigner added
**           21.11.98 FNicklis: ET_VALUE_DW_OPENGL_DMAMAXCOUNT, ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT added
**           25.11.98 MPietsch: ET_VALUE_DW_OPENGL_PIXELTUBE added
**                    FNicklis: Added some informational stuff regarding version stamp and version checking
**           02.12.98 FNicklis: New ET_VALUE_TYPE_DWORD_DEFAULT, ...
**           29.01.99 FNicklis: Registry Key-IDs 0x2000032A-0x2000032E
**           29.01.99 SKuklik:  Registry Key-IDs 0x20000069-0x2000006c, 0x20000097, 0x20000129, 0x20000208, 0x20000405 - 406, 0x20000601 - 602
**           03.02.99 CSkopins: Escape-Codes fuer Video-In/-Out hinzugefuegt.
**           11.02.99 SKuklik : Registry Key-ID  0x2000012B (ICDInterface.PFD_SWAP_EXCHANGE)
**           12.02.99 FNicklis: SUBESC_ET_QUERY_ICDCLIENTINFO
**           13.04.99 CSchalle: ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING
**           14.04.99 CSchalle: added ET_VALUE_DW_OPENGL_ALIGNED_SURFACES
**           22.04.99 CSchalle: added ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA
**           11.05.99 JS:       added ET_SUBESC_ET_xxx_VALUE_BINARY, ET_VALUE_BIN_GDI_GAMMARAMP
**                              added SUBESC_ET_EDD_xETGAMMARAMP
**           19.05.99 FNicklis: ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS fixed
**           28.06.99 HHornig : added RES_ESC_ELSA_TOOL call for generic drivers
**           30.06.99 FNicklis: added SUBESC_ET_MULTIBOARDSETUP for internal Display driver vs multiboard driver calls
**           25.08.99 CSkopins: added Capability flags for STEREO and OVERCLOCKING
**           22.09.99 HHornig : added ET_EDD_GETCOLORCAPSLIMITS
**           28.09.99 TU:       added SUBESC_ET_QUERY_TEMPERATURE for temperature and fan status
**           29.09.99 FNicklis: added SUBESC_ET_DPMS and sample code
**           18.10.99 CSkopins: added SUBESC_RMAPI_CONFIGSETGET for ERAZOR X TV-Out
**           20.10.99 CSchalle: added ET_VALUE_BIN_OEM_MODELIST
**           10.02.00 FNicklis: added ET_VALUE_DW_DMA_7DUMMYREADS, ET_VALUE_DW_DMA_DUMMYREADUC, ET_VALUE_DW_DMA_FORCEIOFLUSH
**           10.03.00 HHornig : added SUBESC_GET_OUTPUT_DEVICE_INFO / SUBESC_SET_OUTPUT_DEVICE
**           23.05.00 BSchwall: added ET_VALUE_DW_OPENGL_UNIGRAPHICS_TEXTURE_FIX
*/

// ********************************************************
// ********************************************************
// Basic defines
// -------------

// We need a common alignment for all structures:
// save current packing and switch to 8 byte (64bit)
#ifdef WIN32
#pragma pack (push, fixed_forELSAESC)
#endif
#pragma pack(8)

#define ET_MAX_PATH   260 // MAX_PATH is not available in all environments!
#define ET_MAX_STRING 260


#define ESC_ELSA_TOOLS 0xE15A // Escape for ELSA Tools
// HHORNIG : 28.6.99
// if we build generic drivers some tools are allowed to pop up
// to detect this the tool should use this call combined with
// a special code that is only used for this tool
#define RES_ESC_ELSA_TOOLS 0xE15B // restricted Escape for ELSA Tools

// FNicklis 23.10.98: Need it sometimes ;-)
#ifndef DWORD
typedef unsigned long DWORD;
#endif

// FNicklis 23.10.98: Under NT we don't have FAR and NEAR
#ifndef FAR
#define FAR
#endif

#ifdef NTMINIPORT
// FNicklis 29.01.1999: don't know HWND in NT miniport
#ifndef HWND
#define HWND PVOID
#endif
#endif// NTMINIPORT

// Subescapes: 0x00000000 - 0x0fffffffbasic sub escapes
//             0x10000000 - 0x1fffffff to be defined by Win95
//             0x20000000 - 0x2fffffff to be defined by NT (NTeam)
//             0x30000000 - 0xffffffff unused
// Naming: SUBESC_ET_xxxx, read: Sub escape for ELSA tools
//
// Note: Queries should use the same in structure ET_QUERY but different
//       query subescapes SUBESC_ET_QUERY_yyyy

// ********************************************************
// Sub escapes, common for Windows 95 and Windows NT:
#define SUBESC_ET_QUERY_VERSION_INFO        0x00000000

#define SUBESC_ET_QUERY_VALUE_STRING        0x00000010
#define SUBESC_ET_QUERY_VALUE_DWORD         0x00000011
#define SUBESC_ET_QUERY_VALUE_BINARY        0x00000012

#define SUBESC_ET_SET_VALUE_STRING          0x00000018
#define SUBESC_ET_SET_VALUE_DWORD           0x00000019
#define SUBESC_ET_SET_VALUE_BINARY          0x00000020

// 0x30-0x4F reserved for WINman
#define SUBESC_ET_WINMAN_DATA_GET           0x00000030
#define SUBESC_ET_WINMAN_DATA_SET           0x00000031
#define SUBESC_ET_WINMAN_DDC_EDID_GET       0x00000032
#define SUBESC_ET_WINMAN2_DATA_GET          0x00000035
#define SUBESC_ET_WINMAN2_DATA_SET          0x00000036
#define SUBESC_ET_WINMAN2_DDC_EDID_GET      0x00000037

// 0x50-0x6F reserved for elsa directdraw caps
#define SUBESC_ET_EDD_GETCAPS               0x00000050
#define SUBESC_ET_EDD_GETFEATURES           0x00000051
#define SUBESC_ET_EDD_SETFEATURES           0x00000052
#define SUBESC_ET_EDD_GETVIDMEMINFO         0x00000053
#define SUBESC_ET_EDD_GETCOLORADJUSTMENT    0x00000054
#define SUBESC_ET_EDD_SETCOLORADJUSTMENT    0x00000055
#define SUBESC_ET_EDD_SETGAMMARAMP          0x00000056
#define SUBESC_ET_EDD_GETGAMMARAMP          0x00000057
#define SUBESC_ET_EDD_GETCOLORCAPSLIMITS    0x00000058

// 0x100-0x11F reserved for Video-In / -Out Escapes
//
#define SUBESC_ET_VIDEO_DMACOPYSM           0x00000100
#define SUBESC_ET_VIDEO_OUTCONTROL          0x00000110
#define SUBESC_ET_RMAPI_CONFIGSETGET        0x0000011F

// 0x200-0x21F reserved for all tools to decide if they are
//             allowed to pop up, only to be used in combination
//             with a resctricted call RES_ESC_ELSA_TOOL
//
#define SUBESC_STEREO_TOOL                  0x00000200

// 0x300-0x3FF reserved for hardware status and control
//
#define SUBESC_ET_QUERY_TEMPERATURE         0x00000300

#define SUBESC_ET_GET_OUTPUT_DEVICE_INFO    0x00000310
#define SUBESC_ET_SET_OUTPUT_DEVICE         0x00000311


// ********************************************************
// Windows 95 sub escapes:

#define SUBESC_ET_QUERY_MONITORKEY_REGPATH  0x10000000
#define SUBESC_ET_QUERY_D3DSETTINGS_REGPATH 0x10000001

// ********************************************************
// Windows NT sub escapes:

#define SUBESC_ET_QUERY_OPENGLICD_REGPATH   0x20000000
#define SUBESC_ET_DUO_ESC_GETPANELINFO      0x20000002  //Returns Information on our Panel/PanelCaps
#define SUBESC_ET_DUO_ESC_SETPANELINFO      0x20000004  //Sets Panel Information
#define SUBESC_ET_POWERLIB_START            0x20000008  //Tells driver that one powerlib has started
#define SUBESC_ET_POWERLIB_EXIT             0x20000009  //Tells driver that one powerlib will end

// 0x10-0x2F reserved for driver internal escapes
#define SUBESC_ET_GETREGISTER               0x20000010  // direct hw access
#define SUBESC_ET_SETREGISTER               0x20000011
#define SUBESC_ET_MODIFYREGISTER            0x20000012
#define SUBESC_ET_SCROLL                    0x20000013
#define SUBESC_ET_GFXOPTIONQUERY            0x20000014

#define SUBESC_ET_NOTIFYDRIVER              0x20000015  // special support for video capture driver
#define SUBESC_ET_SAA                       0x20000016
#define SUBESC_ET_DDSURFOVERRIDE            0x20000017

#define SUBESC_ET_MULTIBOARDSETUP           0x20000018 // FNicklis: setup singleboard client with information from multiboard wrapper.
                                                       // IO structures ET_MULTIBOARDSETUP_IN and ET_MULTIBOARDSETUP_OUT are defined in driver code!
#define SUBESC_ET_DPMS                      0x20000019 // FNicklis: set DPMS power save mode; uses ET_DPMS_IN and ET_DPMS_OUT

// 0x30- ... Common driver Escapes
#define SUBESC_ET_SETWINDOW_STEREOMODE      0x20000030 // set the stereo mode of an OpenGL window
#define SUBESC_ET_QUERY_ICDCLIENTINFO       0x20000031 // receive information about OpenGL-Clients


// ********************************************************
// ********************************************************
// In structure (Tool -> driver):
// Input Query structure, common part of all subescape input structures
// --------------------------------------------------------------------
typedef struct tagET_QUERY
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_QUERY)
  DWORD dwSubEsc;  // has to be (SUBESC_ET_QUERY_VERSION_INFO, SUBESC_ET_QUERY_OPENGLICD_REGPATH, ...)
  DWORD dwOutSize; // size of output data structure (if there is such data)
  DWORD dwBoard;   // for registry issues we need to know for what board we have to read/write @@db 130498
                   // Calls that affect all boards use ET_ALL_BOARDS to initialize dwBoard
                   // 0 -> board 0, 1 -> board 1, ET_ALL_BOARDS -> all boards
} ET_QUERY;

#define ET_ALL_BOARDS 0xFFFFFFFF   // FNicklis, 11.03.99 reserved key for all boards

// driver get's PVOIDs but needs a fast access to members
#define ET_QUERY_GET_SUBESC(pv)    (((ET_QUERY*)pv)->dwSubEsc)
#define ET_QUERY_GET_BOARD(pv)     (((ET_QUERY*)pv)->dwBoard)

// ********************************************************
// ********************************************************
// Version info and some other data from driver
// --------------------------------------------

#define MAX_ET_VERSION 64

#define ET_VER_RELEASE_DRIVER    0x0
#define ET_VER_WHQL_DRIVER       0x1 // Release driver for WHQL
#define ET_VER_BETA_DRIVER       0x2 // Beta driver neither release nor WHQL

// Out structure (Driver -> Tool):
// Version information used in ET_VERSION_INFO, retrieved by SUBESC_ET_QUERY_VERSION_INFO

#ifdef WIN32
#pragma warning( disable:4201 ) // nonstandard extension used : nameless struct/union
#endif

// Usage of ET_VERSION_STAMP:
//
// Allowes to check which bits of the capabilities fields are defined.
// You may only test the bits defined in the version matching the version
// stamp.
//
// NOTE: The version stamp is only valid for the ET_VERSION structure!
//   Don't validate other structures with this!
//
// NOTE: A tool may only test the capabilities defined for the version
//   matching the version stamp.
//
// NOTE: Newer versions must support the capabilites of older versions!
//
// NOTE: A tool must check for an equal version stamp as older drivers
//   didn't touch the reserved flags, and leaved them initialized!
//   It isn't allowed to do a greater equal test on the verstion stamp!
//
// example:
/*
// FNicklis 25.11.98 15:30:15: example program
BOOL bIsCVBoard(
  IN const ET_VERSION_INFO *pVersionInfo)  // pointer to version info (read outside)
{
  const ET_VERSION *pVersion;
  BOOL              bRet     = FALSE; // default is no CV board

  assert(NULL!=pVersionInfo);

  pVersion = &(pVersionInfo->Version);

  // as it is a union it must be the same!
  assert(pVersion->dwNTVersionStamp ==pVersion->dwW95VersionStamp);
  assert(pVersion->dwW95Capabilities==pVersion->dwNTCapabilities);

  //Not allowed! if ( pVersion->dwNTVersionStamp>ET_VERSION_STAMP10 )

  // ET_VERSION_STAMP10 was the first version that supported
  // this extenstion

  if ( ET_VERSION_STAMP10==pVersion->dwNTVersionStamp )
  {
    // it's a version 1.0, supported by our app

    // we may test 1.0 features: ET_VERSION_CAPS_CV_PRODUCT and ET_VERSION_CAPS_2D_BOARD_ONLY
    if ( pVersion->dwNTCapabilities & ET_VERSION_CAPS_CV_PRODUCT )
    {
      bRet = TRUE;
    }
  }
  else
  {
    // error, interface not valid
    // older board -> fallback
    // unknown board -> exit

    // .... add code here
  }

  return (bRet);
}
*/
// History:
// ???????? uninitialized and any other value than defined VERSION_STAMPS are
//          invalid and don't support the interface!
// 00000010: First version 1.0 valid and testableET_VERSION_CAPS_xx:
//     xx_CV_PRODUKT
//     xx_2D_BOARD
#define ET_VERSION_STAMP10 0x00000010         // FNicklis 30.09.1998 first version

// please don't use ET_VERSION_STAMP any longer!
#define ET_VERSION_STAMP  ET_VERSION_STAMP10  // Current version stamp is highest available, but better is
                                              // to use the stamp you know you support!
// capabilities
// defined in 1.0:
//                      CH == !CV product
#define ET_VERSION_CAPS_CV_PRODUCT     0x01 // The board is a CV product (GLoria, Synergy, ...)
                                            // GLoria Settings, POWERlib, ... must run
//                      3D == !2D
#define ET_VERSION_CAPS_2D_BOARD_ONLY  0x02 // The board has only 2D and no hardware 3D capabilities (Trio, S3 986,..)

//
#define ET_VERSION_CAPS_DIRECT3DSTEREO 0x04 // Driver supports REVELATOR type Stereo for Direct3D
#define ET_VERSION_CAPS_OPENGLSTEREO   0x08 // Driver supports REVELTAOR type Stereo for OpenGL
#define ET_VERSION_CAPS_OVERCLOCKING   0x10 // Driver supports overclocking
#define ET_VERSION_CAPS_TEMPERATURE    0x20 // Driver supports temperature control

// ... to be continued


// used with SUBESC_ET_QUERY_VERSION_INFO
typedef struct tagET_VERSION
{
  DWORD dwFlags;                     // Flags to define WHQL, BETA, ... driver
  DWORD dwAlign1;                    // needed to align on 8 byte boundaries

  // NT and Win95 version data is different, so use a union to match all
  union
  {
    struct // Windows 95 version information
    {
      DWORD dwW95Major;        //
      DWORD dwW95Minor;        //
      DWORD dwW95BuildMajor;   //
      DWORD dwW95BuildMinor;   //
      DWORD dwW95BuildPrivate; //
      DWORD dwW95Reserved1;    // unused
      DWORD dwW95Capabilities; // bitfield containing capabilities (ET_VERSION_CAPS_xx)
      DWORD dwW95VersionStamp; // == ET_VERSION_STAMP (read comment above!) Has to be verified before reading dwW95Capabilities!
    };
    struct // Windows NT version information
    {           // e.g 5.12.00.345
      DWORD dwNTMajor;      //   5
      DWORD dwNTMinor;      //  12
      DWORD dwNTBuildMajor; //  00
      DWORD dwNTBuildMinor; // 345
      DWORD dwNTReserved0;
      DWORD dwNTReserved1;
      DWORD dwNTCapabilities; // bitfield containing capabilities (ET_VERSION_CAPS_xx)
      DWORD dwNTVersionStamp; // == ET_VERSION_STAMP (read comment above!). Has to be verified before reading dwNTCapabilities!
    };
  };

  char  szVersion[MAX_ET_VERSION]; // Version string (ANSI/ASCCI)

} ET_VERSION;

#ifdef WIN32
#pragma warning( default:4201 ) // nonstandard extension used : nameless struct/union
#endif

// Out structure (Driver -> Tool):
// Structure to retrieve driver version and registry data
typedef struct tagET_VERSION_INFO
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_VERSION_INFO)

  // Driver version information (system dependent!)
  ET_VERSION Version;

  // Complete path to drivers registry (be sure it is defined long enough!)
  char  szRegDriverKey[ET_MAX_PATH]; // e.g. NT:    "\Registry\Machine\System\CurrentControlSet\Services\EGLXLM"
                                 // e.g. Win95: "\Registry\Machine\System\CurrentControlSet\Services\Class\Display\0000"

} ET_VERSION_INFO;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to key where the monitor is defined
typedef struct tagET_MONITORKEY_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_MONITORKEY_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegMonitorKey[ET_MAX_PATH];  // e.g. Win95: "\Registry\Machine\System\CurrentControlSet\Services\Class\Monitor\0000"

} ET_MONITORKEY_REGPATH;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to key where D3DSettings store its settings
typedef struct tagET_D3DSETTINGS_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_D3DSETTINGS_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegD3DSettingsKey[ET_MAX_PATH];  // e.g. Win95: "\Registry\Machine\Software\ELSA\Erazor"

} ET_D3DSETTINGS_REGPATH;


// Out structure (Driver -> Tool):
// Structure to retrieve complete path to Key where the ICD is defined
typedef struct tagET_OPENGLICD_REGPATH
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_OPENGLICD_REGPATH)

  // Complete path to Key where the ICD is defined
  char  szRegICDKey[ET_MAX_PATH];  // e.g. NT: "\Registry\Machine\Software\Microsoft\WindowsNT\OpenGLDrivers\ELSA EGLXLM driver"
  char  szRegICDName[ET_MAX_PATH]; // e.g. NT: "EOGLXL"

} ET_OPENGLICD_REGPATH;




// ET_EDD_GETVIDMEMINFO
// get surface counts
typedef struct tagET_EDD_GETVIDMEMINFODATA
{
  DWORD   dwSize;
  DWORD   dwPrimaryCount;
  DWORD   dwOffscreenCount;
  DWORD   dwOverlayCount;
} ET_EDD_GETVIDMEMINFODATA, FAR* LPET_EDD_GETVIDMEMINFODATA;


#define ET_COLOR_CAPS_CONTRAST    0x01    // driver supports contrast settings and limitations are valid
#define ET_COLOR_CAPS_BRIGHTNESS  0x02    // driver supports brightness settings and limitations are valid
#define ET_COLOR_CAPS_SATURATION  0x04    // driver supports saturation settings and limitations are valid
#define ET_COLOR_CAPS_HUE         0x08    // driver supports hue settings and limitations are valid

// ET_EDD_GETCOLORCAPSLIMITS
// get capability of contrast, brightness saturation and hue
// and their limits. The limits are only valid if the capability
// is set.
typedef struct tagET_EDD_GETCOLORCAPSLIMITS
{
  DWORD   dwSize;
  DWORD   dwColorCaps;
  long    lContrastMin;
  long    lContrastMax;
  long    lBrightnessMin;
  long    lBrightnessMax;
  long    lSaturationMin;
  long    lSaturationMax;
  long    lHueMin;
  long    lHueMax;
  long    reserved[20];     // some spare left for future
} ET_EDD_GETCOLORCAPSLIMITS, FAR* LPET_EDD_GETCOLORCAPSLIMITS;


// ET_EDD_SETCOLORADJUSTMENT
// set contrast, brightness saturation and hue
// values for each item is 0..9999
typedef struct tagET_EDD_SETCOLORADJUSTMENTDATA
{
  ET_QUERY hdr;				// size and subescape SUBESC_ET_EDD_SETCOLORADJUSTMENT
  long   dwContrast;
  long   dwBrightness;
  long   dwSaturation;
  long   dwHue;
} ET_EDD_SETCOLORADJUSTMENTDATA, FAR* LPET_EDD_SETCOLORADJUSTMENTDATA;


// ET_EDD_GETCOLORADJUSTMENT
// get contrast, brightness saturation and hue
// values for each item is 0..9999
typedef struct tagET_EDD_GETCOLORADJUSTMENTDATA
{
  DWORD   dwSize;
  long    dwContrast;
  long    dwBrightness;
  long    dwSaturation;
  long    dwHue;
  DWORD   dwYUVOverlayVisibleCount;
} ET_EDD_GETCOLORADJUSTMENTDATA, FAR* LPET_EDD_GETCOLORADJUSTMENTDATA;


// ET_EDD_SETFEATURES  set ELSA DirectDraw features
typedef struct tagET_EDD_SETFEATURESDATA
{
  ET_QUERY hdr;				// size and subescape SUBESC_ET_EDD_SETFEATURES
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_SETFEATURESDATA, FAR* LPET_EDD_SETFEATURESDATA;


// ET_EDD_GETFEATURES get ELSA DirectDraw features
typedef struct tagET_EDD_GETFEATURESDATA
{
  DWORD   dwSize;
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_GETFEATURESDATA, FAR* LPET_EDD_GETFEATURESDATA;


// ET_EDD_GETCAPS
//   retrieves capabilitie of ELSA DirectDraw features
//   capabilities depends on hardware, resolution and pixel depth
typedef struct tagET_EDD_GETCAPSDATA
{
  DWORD   dwSize;
  DWORD   dwEddCaps0;
  DWORD   dwEddCaps1;
} ET_EDD_GETCAPSDATA, FAR* LPET_EDD_GETCAPSDATA;

// ET_GAMMA_SET
//   _TEMPORARY_ set a gamma table.
//   This escape immediately sets the gamma table to the device. The table
//   is not stored permanently by the device. Means, after reboot, the
//   original 1:1 (or what ever else) table is reloaded by hardware.
//   To store the table, use the ELSA Subescape:
//      SUBESC_ET_SET_VALUE_BINARY::ET_VALUE_BIN_GDI_GAMMARAMP
//
//   Information about the success of the SET call is provided
//   via a ET_SET_VALUE_RET structure
//   If the hardware generally supports gamma ramps, but not in the current
//   mode (256 colors), the flags field in the output structure contains
//   ET_VALUE_BLOCKED.

typedef struct tagET_EDD_SETGAMMARAMP
{
  ET_QUERY hdr;       // size and subescape SUBESC_ET_EDD_SETGAMMARAMP
  WORD     red[256];
  WORD     green[256];
  WORD     blue[256];
} ET_EDD_SETGAMMARAMP, FAR* LPET_EDD_SETGAMMARAMP, * PET_EDD_SETGAMMARAMP;

typedef struct tagET_EDD_GETGAMMARAMP
{
  DWORD   dwSize;
  DWORD   dwResult;		// ET_VALUE_OK if succeeded and ET_VALUE_BLOCKED if Gamma not supported yet
  WORD    red[256];
  WORD    green[256];
  WORD    blue[256];
} ET_EDD_GETGAMMARAMP, FAR* LPET_EDD_GETGAMMARAMP, * PET_EDD_GETGAMMARAMP;

// ET_VIDEO_DMACOPYSM
//   copies video memory to system memory by DMA
typedef struct tagET_VIDEO_DMACOPYSMDATA
{
  ET_QUERY  hdr;

  DWORD     dwDstSel;       // Selector of destination memory (16Bit) / NULL (32Bit)
  DWORD     dwDstOfs;       // Offset of destination memory (16Bit) / Linear Address (32Bit)
  DWORD     dwDstStride;    //

  DWORD     dwSrcSel;       // Selector of source video memory (16Bit) / NULL (32Bit)
                            // The base of the selector points to the start of the video memory
  DWORD     dwSrcOfs;       // Offset of source video memory (16Bit) / Linear Address (32Bit)
                            // This is the offset relative to the beginning of video memory
  DWORD     dwSrcStride;    //

  DWORD     dwWidthBytes;   // Amount of bytes to transfer in one line (must be aligned to 4)
  DWORD     dwHeight;       // Anount of lines to transfer
} ET_VIDEO_DMACOPYSMDATA, FAR* LPET_VIDEO_DMACOPYSMDATA;

// ET_VIDEO_OUTCONTROL
//   controls video-out
typedef struct tagET_VIDEO_OUTCONTROL
{
  ET_QUERY  hdr;

  DWORD     dwEnable;
  DWORD     dwControl;
  DWORD     dwParam1;
  DWORD     dwParam2;
} ET_VIDEO_OUTCONTROL, FAR* LPET_VIDEO_OUTCONTROL, * PET_VIDEO_OUTCONTROL;

// ET_RMAPI_CONFIGSETGET
//   allows escape access to stateConfigGet [...] routines.
typedef struct tagET_RMAPI_CONFIGSETGET
{
  ET_QUERY  hdr;
  DWORD     dwSetGetCommand;
  DWORD     dwIndex;
  DWORD     dwlpParamStruct;
  DWORD     dwParamSize;
  DWORD     dwValue;
  DWORD     dwParam0;
  DWORD     dwParam1;
  DWORD     dwParam2;
} ET_RMAPI_CONFIGSETGET, FAR* LPET_RMAPI_CONFIGSETGET, * PET_RMAPI_CONFIGSETGET;

// Constants for ELSA DirectDraw features:
//
// dwEddCaps0:
#define EDDCAPS_DITHER              0x00000001
#define EDDCAPS_FILTERX             0x00000002
#define EDDCAPS_FILTERY             0x00000004
#define EDDCAPS_FILTERX_LIN02420    0x00000008
#define EDDCAPS_FILTERX_BILINEAR    0x00000010
#define EDDCAPS_FILTERX_LIN12221    0x00000020
#define EDDCAPS_OFFSCREENINHIBIT    0x00000040
#define EDDCAPS_OFFSCREENLINEAR     0x00000080
#define EDDCAPS_COLORADJUSTYUV_CB   0x00000100
#define EDDCAPS_COLORADJUSTYUV_HS   0x00000200
#define EDDCAPS_FILTERXY_BILINEAR   0x00000400
#define EDDCAPS_DITHER_ALWAYS_ON    0x00000800
#define EDDCAPS_ENABLE_332_TEXTURE  0x00001000

// 3D-Features
#define EDDCAPS_INHIBIT_ZBUFFER     0x00010000
#define EDDCAPS_INHIBIT_PERSCORRECT 0x00020000
#define EDDCAPS_INHIBIT_TEXTURE     0x00040000
#define EDDCAPS_INHIBIT_FOG         0x00080000
#define EDDCAPS_INHIBIT_FILTER      0x00100000
#define EDDCAPS_INHIBIT_ALPHA       0x00200000
// ViRGE/DX has a fast bilinear algorithm
#define EDDCAPS_FASTBILINEAR        0x00400000
// emuliere Colorkey for a Texture using texture alpha blending
#define EDDCAPS_EMULATE_TEX_CKEY    0x00800000
#define EDDCAPS_SIMULATE_MIPMAP     0x01000000

// Commands
#define EDDCMD_ALLOCFILTERYBUF      0x80000001

// Bedeutung der einzelnen Bits in dwEddCaps0 beim Aufruf von
// EDDESC_SETFEATURES:
//
// Achtung: Ein Bit darf nur gesetzt werden, wenn das entsprechende Bit
//          vorher bei einem Aufruf von EDD_GETCAPS als gueltig gemeldet
//          wurde.
//
// EDDCAPS_DITHER  : 1=Dithering ein. 0=Dithering aus.
//
// EDDCAPS_FILTERX : 1=Schalte einen Filter ein. Ggf. kann mit anderen
//                   Konstanten eine spezieller Filter definiert werden.
//                   Wird kein spezieller Filter ausgewaehlt (obwohl
//                   es moeglich waere) so sucht der Treiber einen adequaten
//                   Filter aus.
//                   0=Alle Filter aus.
//
// EDDCAPS_FILTERX_xxxxx : Schalte diesen speziellen Filter ein, wenn auch
//                         EDDCAPS_FILTERX gesetzt ist.
//
// EDDCAPS_OFFSCREENLINEAR: Weist den DirectDraw-Treiber an, linearen
//                          Offscreen falls moeglich (!) zu benutzen, um z.B.
//                          eine bessere Speicherausnutzung zu erreichen, oder
//                          die Erzeugung von Offscreen-Surfaces zu ermoeglichen,
//                          deren Breite (in Bytes) groesser ist als die Breite
//                          des Primary-Surface.
//                          Wenn dieses Bit beim Zuruecklesen gesetzt ist,
//                          ist der Offscreen tatsaechlich linear, ansonsten
//                          nicht.
//
//
// EDDCAPS_COLORADJUSTYUV_CB : 0=Kontrast/Helligkeit-Werte ohne Wirkung
//                             1=Kontrast/Helligkeit wird gemaess der per
//                               EDDESC_SETCOLORADJUSTMENT gewaehlten Werte
//                               eingestellt.
//
// EDDCAPS_COLORADJUSTYUV_HS : 0=Phase/Saettigungs-Werte ohne Wirkung
//                             1=Phase/Saettigung wird gemaess der per
//                               EDDESC_SETCOLORADJUSTMENT gewaehlten Werte
//                               eingestellt.

// Bedeutung der einzelnen Bits in dwEddCaps0 beim Aufruf von EDDESC_GETCAPS:
// -------------------------------------------------------------------------
//
// EDDCAPS_DITHER  : Der Treiber beherrscht Dithering zur Verbesserung der
//                   Bildqualitaet.
//
// EDDCAPS_FILTERX : Der Treiber beherrscht eine allgemeine Methode zum
//                   Filtern in X-Richtung. Ueber andere Bits
//                   EDDCAPS_FILTERX_xxxxx KANN der Treiber angeben, welche
//                   speziellen Filterfaehigkeiten er kennt.
//
// EDDCAPS_FILTERY : Der Treiber beherrscht eine allgemeine Methode zum
//                   Filtern in Y-Richtung.
//
// EDDCAPS_FILTERX_LIN02420
// EDDCAPS_FILTERX_BILINEAR
// EDDCAPS_FILTERX_LIN12221 : Der Treiber beherrscht diesen Filter in X-
//                            Richtung. Wenn diese Bit gesetzt ist, wird
//                            auch EDDCAPS_FILTERX gesetzt.
//
// EDDCAPS_OFFSCREENINHIBIT : Der Treiber bietet die Moeglichkeit, die
//                            Erzeugung von Offscreen-Surfaces zu
//                            unterbinden.
//
// EDDCAPS_OFFSCREENLINEAR : Der Treiber bietet die Moeglichkeit, lineare
//                           Offscreenverwaltung zu erwuenschen.
//                           Diesen Wunsch kann der Treiber erfuellen, er
//                           muss es aber nicht.
//
// EDDCAPS_COLORADJUSTYUV_CB : Der Treiber bietet die Moeglichkeit Kontrast
//                             und Helligkeit eines YUV-Videos einzustellen.
//
// EDDCAPS_COLORADJUSTYUV_HS : Der Treiber bietet die Moeglichkeit "Hue" und
//                             Saettigung eines YUV-Videos einzustellen.





// ********************************************************
// ********************************************************
// New *_VALUE_* Interface to replace registry accesses for driver data by escapes
// -------------------------------------------------------------------------------

// In structure (Tool -> driver):
// Input Structure to set a registry string
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_STRING
{
  ET_QUERY hdr;   // size and subescape SUBESC_ET_SET_VALUE_STRING
                  // dwSize parameter of ET_QUERY holds length of this structure
                  //    i.e. hdr.dwSize >= sizeof(ET_SET_VALUE_STRING)
                  //   ET_MAX_STRING is the minimal length of the string!

  DWORD dwID;     // ID of string to set (ET_VALUE_SZ_...)
  char  szValue[ET_MAX_STRING];

} ET_SET_VALUE_STRING, *PET_SET_VALUE_STRING;

// In structure (Tool -> driver):
// Input Structure to set a registry DWORD
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_DWORD
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SET_VALUE_DWORD

  DWORD    dwID;    // ID of dword to set (ET_VALUE_DW_...)
  DWORD    dwValue; // value to set

} ET_SET_VALUE_DWORD, *PET_SET_VALUE_DWORD;

// In structure (Tool -> driver):
// Input Structure to set binary data to registry
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_BINARY
{
  ET_QUERY hdr;       // size and subescape SUBESC_ET_SET_VALUE_DWORD

  DWORD    dwID;      // ID of dword to set (ET_VALUE_DW_...)
  char     ajData[1]; // array of binary data
  // The true size of this array can be re-calculated from hdr.dwSize

} ET_SET_VALUE_BINARY, *PET_SET_VALUE_BINARY;
// Size of the structure without the data array
#define ET_SET_VALUE_BINARY_HDR_SIZE (sizeof(ET_SET_VALUE_BINARY)-sizeof(DWORD))

// use in struct ET_QUERY_VALUE.dwType
#define ET_VALUE_TYPE_DWORD           0x00  // subesc SUBESC_ET_QUERY_VALUE_DWORD
#define ET_VALUE_TYPE_STRING          0x01  // subesc SUBESC_ET_VALUE_TYPE_STRING
#define ET_VALUE_TYPE_BINARY          0x02  // subesc SUBESC_ET_VALUE_TYPE_BINARY

// Query defaults: Same as ET_VALUE_TYPE_xx but driver allways returns the values default.
// If an ESC-error is returned, the driver doesn't support the default query!
#define ET_VALUE_DEFAULT_FLAG         0x80
#define ET_VALUE_TYPE_DEFAULT_DWORD   (ET_VALUE_DEFAULT_FLAG|ET_VALUE_TYPE_DWORD)   // subesc SUBESC_ET_QUERY_VALUE_DWORD
#define ET_VALUE_TYPE_DEFAULT_STRING  (ET_VALUE_DEFAULT_FLAG|ET_VALUE_TYPE_STRING)  // subesc SUBESC_ET_VALUE_TYPE_STRING

// In structure (Tool -> driver):
// Input Structure to query a registry DWORD
// Output data is returned in ET_VALUE_STRING or ET_VALUE_DWORD
typedef struct tagET_QUERY_VALUE
{
  ET_QUERY hdr;    // size and subescapes SUBESC_ET_QUERY_VALUE_STRING or SUBESC_ET_QUERY_VALUE_DWORD
                   // if outsize for strings > sizeof(ET_VALUE_STRING) the buffer can take longer than the
                   // default strings! Only check if the out buffer is to small to fit the data. The bigger
                   // the better!

  DWORD dwID;      // ID of dword to query (ET_VALUE_DW_..., ET_VALUE_SZ_...)
  DWORD dwType;    // This identifies what kind of data is requested (type of output structure) (ET_VALUE_TYPE_DWORD,...)
                   // Allways assign this value and be sure to set all necessary bits too!
} ET_QUERY_VALUE, *PET_QUERY_VALUE;


// Out structure (Driver -> Tool):
// Output Structure used to return a string from the driver in subesc SUBESC_ET_QUERY_VALUE_STRING
// used by input structure ET_QUERY_VALUE and dwType ET_VALUE_TYPE_STRING
typedef struct tagET_VALUE_STRING
{
  DWORD dwSize;    // Length of this structure (should be the same as ET_QUERY_VALUE's outbuffer size)
  DWORD dwID;      // identifier of string to query (additional and as alignment) (ET_VALUE_SZ_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags
  char  szValue[ET_MAX_STRING]; // zero terminated ASCII/ANSI string (no UNICODE!)

} ET_VALUE_STRING, *PET_VALUE_STRING;


// Out structure (Driver -> Tool):
// Structure used to return a DWORD from the driver in subesc SUBESC_ET_QUERY_VALUE_DWORD
// used by input structure ET_QUERY_VALUE and dwType ET_VALUE_TYPE_DWORD
typedef struct tagET_VALUE_DWORD
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_VALUE_DWORD)
                   // (should be the same as ET_QUERY_VALUE's outbuffer size)

  DWORD dwID;      // identifier of queried dword to query (additional and as alignment) (ET_VALUE_DW_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags
  DWORD dwValue;   // return value

} ET_VALUE_DWORD, *PET_VALUE_DWORD;

// Out structure (Driver -> Tool):
// Structure used to return binary data from the driver in subesc
// SUBESC_ET_QUERY_VALUE_BINARY used by input structure ET_QUERY_VALUE
// and dwType ET_VALUE_TYPE_BINARY
typedef struct tagET_VALUE_BINARY
{
  DWORD dwSize;    // Length of this structure, at least ET_QUERY_VALUE_BINARY_HDR_SIZE
                   // (should be the same as ET_QUERY_VALUE's outbuffer size)
  DWORD dwID;      // identifier of binary to query (additional and as alignment) (ET_VALUE_DW_...)
                   // should be the same as in the calling ET_QUERY_VALUE
  DWORD dwFlags;   // return value,
                   // ET_VALUE_OK=value set and all is OK,
                   // ET_VALUE_ERROR_SIZE=structure is too short for all the data,
                   //                     see dwSizeData for the required size
                   // others are error codes or additional information flags
  DWORD dwSizeData; // size of binary data, especially the required size, when
                    // dwFlags return ET_VALUE_ERROR_SIZE

  char  ajData[1]; // dwSizeData bytes of data

} ET_VALUE_BINARY, *PET_VALUE_BINARY;
// Size of the structure without the data array
#define ET_QUERY_VALUE_BINARY_HDR_SIZE (sizeof(ET_VALUE_BINARY)-sizeof(DWORD))


// Flags used in ET_SET_VALUE_RET or ET_VALUE_XXX as return values
//   bit 31 (higest bit) == 0: function was successfull and additional information for values != 0
//   bit 31 (higest bit) == 1: error
#define IsError(Value)      ((Value & 0x80000000)!=0)
#define IsOK(Value)         ((Value & 0x80000000)==0)


//  ET_VALUE_xx return codes used in dwFlags are 32 bit values layed out as follows:

//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-----------------------------------------------------------+
//  |0 r|                                       Bitfield            | success
//  +---+-----------------------------------------------------------+
//  |1 r|                                       ErrorCode           | error
//  +---+-----------------------------------------------------------+
//  r = reserved
//                            bitfield
#define ET_VALUE_OK         0x00000000 // Value function is successfull
#define ET_VALUE_REBOOT     0x00000001 // a reboot is necessary to acivate after value set
#define ET_VALUE_DEFAULT    0x00000002 // Value function had problems and returned defaults
#define ET_VALUE_BLOCKED    0x00000004 // Value is blocked by running application and not set in driver! (e.g. ask user to close application)

//                          Bit   Code
#define ET_VALUE_ERROR		  0x80000000 // application reserved value for ESCAPE failed (not used in driver!)
#define ET_VALUE_UNKNOWN    0x80000001 // Value to get/set is unknown or not supported (e.g. grey button)
#define ET_VALUE_ERROR_SIZE 0x80000002 // returnbuffer is smaller than the value to get

// Out structure (Driver -> Tool):
// structure passed back to caller
typedef struct tagET_SET_VALUE_RET
{
  DWORD dwSize;    // Length of this structure, sizeof(ET_SET_VALUE_RET)

  DWORD dwID;      // identifier of set value (additional and as alignment) (ET_VALUE_DW_...)

  DWORD dwFlags;   // return value, ET_VALUE_OK=value set and all is OK, others as ET_SET_VALUE_REBOOT are
                   // error codes or additional information flags

  DWORD dwAlign;   // unused
} ET_SET_VALUE_RET, *PET_SET_VALUE_RET;


// ********************************************************
// query/set values identifier:
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-------+-------+-----------------------------------------------+
//  |o o o o|r r r r|                                          code |
//  +-------+-------+-----------------------------------------------+
//
//  o = bitfield defining OS dependencies
//    0       = no specific OS
//    0x1     = Win9x
//    0x2     = Win NT
//    0x4,0x8 = unused
//  r = bitfield reserved for driver internal stuff.
//    This field must be 0 in all IDs-codes called via ExtEscape!
//
//    Use this code to check Esc-IDs validity:
//
//    DrvEscape (...)
//    {
//      // check if the caller gives us a valid dwID,
//      // All reserved bits have to be 0!
//      ASSERT( 0==(pEtValue->dwID & ET_VALUE_OS_RESERVED) ); // check the tool which called!
//      ...
//    }
//
//  code = number of identifer, no bitfield.
//    valid range: 0x000000 - 0xffffff (3 Byte)
//    New ID code increments by one.
//
//  Resulting ranges:
//    0x00000000 - 0x00ffffff basic values, common to all operating systems
//    0x10000000 - 0x10ffffff to be defined by Win95
//    0x20000000 - 0x20ffffff to be defined by NT (NTeam)
//    0x40000000 - 0x40ffffff unused
//    0x80000000 - 0x80ffffff unused
// Naming: ET_VALUE_DW_xxxx, read: ELSA tools value dword
//         ET_VALUE_SZ_xxxx, read: ELSA tools value zero terminated string (single byte char)
//

#define ET_VALUE_OS_WIN9x                                   0x10000000 // Bit defining IDs known by Windows 9x driver
#define ET_VALUE_OS_WINNT                                   0x20000000 // Bit defining IDs known by Windows NT driver
#define ET_VALUE_OS_unused0                                 0x40000000 //
#define ET_VALUE_OS_unused1                                 0x80000000 //

#define ET_VALUE_OS_RESERVED                                0x0F000000 // Bits that are reserved for the driver internaly

// Windows 9x
//
#define ET_VALUE_DW_D3DOGL_MCLK                             ( ET_VALUE_OS_WIN9x | 0x00CA0001 )
#define ET_VALUE_DW_D3DOGL_NVCLK                            ( ET_VALUE_OS_WIN9x | 0x00CA0002 )
#define ET_VALUE_DW_D3DOGL_OVERCLOCK_ENABLE                 ( ET_VALUE_OS_WIN9x | 0x00CA0003 )
#define ET_VALUE_DW_D3DOGL_OVERCLOCK_CRASHSTATUS            ( ET_VALUE_OS_WIN9x | 0x00CA0004 )
#define ET_VALUE_DW_D3DOGL_DEFAULT_MCLK                     ( ET_VALUE_OS_WIN9x | 0x00CA0005 )
#define ET_VALUE_DW_D3DOGL_DEFAULT_NVCLK                    ( ET_VALUE_OS_WIN9x | 0x00CA0006 )

// Windows NT
//
// Basic/system 0x20000000-0x200000ff
//#define ET_VALUE_SZ_IMAGEPATH                               0x20000000
//#define ET_VALUE_SZ_INSTALLEDDISPLAYDRIVERS                 0x20000001

#define ET_VALUE_DW_GDI_DESKTOPONMAXIMIZE                   0x20000050 // DesktopOnMaximize
#define ET_VALUE_DW_GDI_ENABLEDEVICEBITMAPS                 0x20000051 // EnableDeviceBitmaps
#define ET_VALUE_DW_GDI_ENABLEPCIDISCONNECT                 0x20000052 // PCIDisconnect
#define ET_VALUE_DW_GDI_EXPORTONLYDOUBLEBUFFERMODES         0x20000053 // ExportOnlyDoubleBufferModes
#define ET_VALUE_DW_GDI_NTEAMPRIVATEKEY                     0x20000054
#define ET_VALUE_DW_GDI_P6ENABLEUSWC                        0x20000055 // DRV_PPRO_ENABLE_WCB
#define ET_VALUE_DW_GDI_REVERSESCREENORDER                  0x20000056 // ReverseScreenOrder
#define ET_VALUE_DW_GDI_USEGETACCESSRANGES                  0x20000057 // UseGetAccessRanges
#define ET_VALUE_DW_GDI_USELCDPANEL                         0x20000058 // UseLCDPanel
#define ET_VALUE_DW_GDI_VERTICALSCREENORDER                 0x20000059 // VerticalScreenOrder
#define ET_VALUE_DW_GDI_WAITFORFIFOS                        0x2000005a // EngineSynchronization
#define ET_VALUE_DW_GDI_DEVICEORIGINX                       0x2000005b
#define ET_VALUE_DW_GDI_DEVICEORIGINY                       0x2000005c
#define ET_VALUE_DW_GDI_DEVICESIZEX                         0x2000005d
#define ET_VALUE_DW_GDI_DEVICESIZEY                         0x2000005e
#define ET_VALUE_DW_GDI_VISUALORIGINX                       0x2000005f
#define ET_VALUE_DW_GDI_VISUALORIGINY                       0x20000060
#define ET_VALUE_DW_GDI_VISUALSIZEX                         0x20000061
#define ET_VALUE_DW_GDI_VISUALSIZEY                         0x20000062
#define ET_VALUE_DW_GDI_DELLXXL                             0x20000063 // DELLXXL
#define ET_VALUE_DW_GDI_PERMEDIACLOCKSPEED                  0x20000064 // PermediaClockSpeed
#define ET_VALUE_DW_GDI_GLINTCLOCKSPEED                     0x20000065 // GlintClockSpeed
#define ET_VALUE_DW_GDI_GLINTGAMMACLOCKSPEED                0x20000066 // GlintGammaClockSpeed
#define ET_VALUE_DW_GDI_GLINTDELTACLOCKSPEED                0x20000067 // GlintDeltaClockSpeed
#define ET_VALUE_DW_GDI_HWLINES                             0x20000068 // TNT: interface to enable nonconformant but faster lines
#define ET_VALUE_DW_GDI_FIFOEXTRA_P2                        0x20000069 // GDI.FifoExtra
#define ET_VALUE_DW_GDI_FIFOEXTRA                           0x2000006a // GDI.FifoExtra
#define ET_VALUE_DW_GDI_FIFOUSAGE                           0x2000006b // GDI.FifoUsage
#define ET_VALUE_DW_GDI_EXPORTMULTIBOARDMODES               0x2000006c // ExportMultiboardModes
#define ET_VALUE_DW_GDI_SURFACESONBANKBOUNDARIES            0x2000006d // boolean
#define ET_VALUE_DW_GDI_DMABUFFERSIZE                       0x2000006e // ulong ( > 8kB)
#define ET_VALUE_DW_GDI_DMAPADDING                          0x2000006f // ulong (ET_VALUE_DW_GDI_DMAPADDING < ET_VALUE_DW_GDI_DMABUFFERSIZE)
#define ET_VALUE_DW_GDI_BOARD_PATTERN                       0x20000070 // binary: defines boards used for the mode (00 01 02,...)
#define ET_VALUE_DW_GDI_AGP_DMA                             0x20000071 // bool: 1=use AGP for display driver DMA, 0=don't use AGP
#define ET_VALUE_DW_GDI_FRAMEBUFFER_DMA                     0x20000072 // bool: 1=use framebuffer DMA for display driver

#define ET_VALUE_DW_MAP_FRAMEBUFFER                         0x20000090 // Map.FrameBuffer
#define ET_VALUE_DW_MAP_GLINTMMIO                           0x20000091 // Map.GLintMmio
#define ET_VALUE_DW_MAP_DELTAMMIO                           0x20000092 // Map.DeltaMmio
#define ET_VALUE_DW_MAP_LOCALBUFFER                         0x20000093 // Map.LocalBuffer

#define ET_VALUE_DW_PPRO_ENABLEWCB                          0x20000095 // PPro.EnableWCB
#define ET_VALUE_DW_ALPHA_MIATA                             0x20000096 // Alpha.Miata
#define ET_VALUE_DW_PRINTANDCHECKRENDERSTATE                0x20000097 //

#define ET_VALUE_BIN_GDI_GAMMARAMP                          0x200000A0 // Gammatable in the same format as in GDI::SetGammaRamp
#define ET_VALUE_BIN_OEM_MODELIST                           0x200000A1 // mode list override string: "bpp#1 width#1 height#1 refresh1#1 refresh2#1... 0 bpp#2 width#2 height#2 refresh1#2 refresh2#2... 0";

// ICDInterface.* 0x20000100-0x200001ff
#define ET_VALUE_DW_ICDINTERFACE_DISABLE                    0x20000100 // ICDInterface.Disable
//#define ET_VALUE_DW_ICDINTERFACE_DOUBLEBUFFER               0x20000101
//#define ET_VALUE_DW_ICDINTERFACE_MAXDOUBLEBUFFER            0x20000102
#define ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS     0x20000101 // ICDInterface.NumberOfDisplayBuffers
#define ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS  0x20000102 // ICDInterface.MaxNumberOfDisplayBuffers
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTSINGLEBUFFEREDGDI   0x20000103 // ICDInterface.SupportSingleBufferedGDI
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTDOUBLEBUFFEREDGDI   0x20000104 // ICDInterface.SupportDoubleBufferedGDI
#define ET_VALUE_DW_ICDINTERFACE_EXPORTALPHA                0x20000105 // ICDInterface.ExportAlpha
#define ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES       0x20000106 // ICDInterface.SupportOverlayPlanes
#define ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT                 0x20000107 // ICDInterface.VBlankWait
#define ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING               0x20000108 // ICDInterface.PageFlipping
#define ET_VALUE_DW_ICDINTERFACE_LBWIDTH                    0x20000109 // ICDInterface.LBWidth
#define ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER               0x2000010A // ICDInterface.SizeOfBuffer

#define ET_VALUE_DW_ICDINTERFACE_DUALTXLBMOVES              0x2000010B // ICDInterface.DualTXLBMoves
#define ET_VALUE_DW_ICDINTERFACE_EXTENDEDPAGEFLIP           0x2000010C // ICDInterface.ExtendedPageFlip
#define ET_VALUE_DW_ICDINTERFACE_FNSENDDATATST              0x2000010D // ICDInterface.FNSendDataTst
#define ET_VALUE_DW_ICDINTERFACE_FULLSCNTOPBORDER           0x2000010E // DoubleBuffer.FullScnTopBorder
#define ET_VALUE_DW_ICDINTERFACE_LBSIZE                     0x2000010F // ICDInterface.LBSize
#define ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSDMA          0x20000110 // ICDInterface.P2EnableBypassDma
#define ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSPATCH        0x20000111 // ICDInterface.P2EnableBypassPatch
#define ET_VALUE_DW_ICDINTERFACE_PAGEFLIPFORCESYNC          0x20000112 // ICDInterface.PageFlipForceSync
#define ET_VALUE_DW_ICDINTERFACE_TEXTURESIZE                0x20000113 // ICDInterface.MaxTextureSize
#define ET_VALUE_DW_ICDINTERFACE_USESOFTWAREWRITEMASK       0x20000114 // ICDInterface.UseSoftwareWriteMask
#define ET_VALUE_DW_ICDINTERFACE_USESINGLETX                0x20000115 // ICDInterface.UseSingleTX

#define ET_VALUE_DW_ICDINTERFACE_EXPORTCOLORINDEX           0x20000116
#define ET_VALUE_DW_ICDINTERFACE_OPENGLICDNAME              0x20000117
#define ET_VALUE_DW_ICDINTERFACE_OPENGLICDELSAOGLNAME       0x20000118
#define ET_VALUE_DW_ICDINTERFACE_PFDREDUCTION               0x20000119 // ICDInterface.PFDReduction
#define ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS         0x2000011A // ICDInterface.StereoForceBuffers
#define ET_VALUE_DW_ICDINTERFACE_STEREOLEFTEYETOP           0x2000011B // ICDInterface.StereoLeftEyeTop
#define ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT              0x2000011C // ICDInterface.StereoSupport
#define ET_VALUE_DW_ICDINTERFACE_TEXTURESMARTCACHE          0x2000011D // ICDInterface.TextureSmartCache
#define ET_VALUE_DW_ICDINTERFACE_TEXTURETRANSIENTONLY       0x2000011E // ICDInterface.TextureTransientOnly

#define ET_VALUE_DW_ICDINTERFACE_MAXTEXTURESIZE             0x2000011F // ICDInterface.MaxTextureSize
#define ET_VALUE_DW_ICDINTERFACE_PFD_TYPE_COLORINDEX        0x20000120 // ICDInterface.PFD_TYPE_COLORINDEX
#define ET_VALUE_DW_ICDINTERFACE_LBPATCHED                  0x20000121 // ICDInterface.LBPatched
#define ET_VALUE_DW_ICDINTERFACE_DUALGLINTWINDOWMOVES       0x20000122 // ICDInterface.DualGlintWindowMoves
#define ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS 0x20000123 // ICDInterface.ForceGdiBroadCastingInOglViews
#define ET_VALUE_DW_ICDINTERFACE_PFD_STEREO                 0x20000124 // ICDInterface.PFD_STEREO
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS     0x20000125 // ICDInterface.PFD_SWAP_LAYER_BUFFERS
#define ET_VALUE_DW_ICDINTERFACE_PFD_SUPPORT_GDI            0x20000126 // ICDInterface.PFD_SUPPORT_GDI

#define ET_VALUE_DW_ICDINTERFACE_FORCE_STENCIL              0x20000127 // ICDInterface.ForceStencil
#define ET_VALUE_DW_ICDINTERFACE_FORCE_MORETHAN16BITZ       0x20000128 // 0=default, else force to this value!
#define ET_VALUE_DW_ICDINTERFACE_TEXTURE_REDUCE_FACTOR      0x20000129 // ICDInterface.TextureReduceFactor
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY              0x2000012A // ICDInterface.PFD_SWAP_COPY
#define ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE          0x2000012B // ICDInterface.PFD_SWAP_EXCHANGE

// GLintDMA.* 0x20000200-0x2000024f
#define ET_VALUE_DW_GLINTDMA_NUMBEROFBUFFERS                0x20000200 // GLintDMA.NumberOfBuffers
#define ET_VALUE_DW_GLINTDMA_NUMBEROFSUBBUFFERS             0x20000201 // GLintDMA.NumberOfSubBuffers
#define ET_VALUE_DW_GLINTDMA_SIZEOFBUFFERS                  0x20000202 // GLintDMA.SizeOfBuffer
#define ET_VALUE_DW_GLINTDMA_CACHEDBUFFERS                  0x20000203 // GLintDMA.CachedBuffers

#define ET_VALUE_DW_GLINTDMA_USEAGP                         0x20000204 // GLintDMA.UseAGP
#define ET_VALUE_DW_GLINTDMA_SUPPORTAGPONBX                 0x20000205 // GLintDMA.SupportAGPonBX

#define ET_VALUE_DW_AGP_ENABLE                              ET_VALUE_DW_GLINTDMA_USEAGP // AGP.Enable:  0, 1
#define ET_VALUE_DW_AGP_RATE                                0x20000206                  // AGP.Rate:    1, 2, 4
#define ET_VALUE_DW_AGP_SIDEBANDADDRESSING                  0x20000207                  // AGP.SBA:     0, 1
#define ET_VALUE_DW_AGP_REQUEST_DEPTH                       0x20000208                  // AGP.RQDepth: 1...255
#define ET_VALUE_DW_AGP_FAST_WRITES                         0x20000209                  // AGP.FW:      0, 1

#define ET_VALUE_DW_DMAWAITFORPOLL                          0x2000020A // DMAWaitForPoll

#define ET_VALUE_DW_AGP_CACHING                             0x2000020B // 0=No, 1=Yes (as used in AgpReservePhysical)
#define ET_VALUE_DW_AGP_MSWORKAROUND                        0x2000020C // 0=No, 1=Yes (to enable workaround for bug in MS W2K videoport.sys AGP mapping)

#define ET_VALUE_DW_DMA_7DUMMYREADS                         0x2000020D // 0=No, 1=Yes (7 dummy reads in dma buffer to flush writecombined caches)
#define ET_VALUE_DW_DMA_DUMMYREADUC                         0x2000020E // 0=No, 1=Yes (Perform a dummy read to the UC system memory but not WC to flush writecombined caches)

#define ET_VALUE_DW_DMA_FORCEIOFLUSH                        0x2000020F // 0=No, 1=Yes (Perform inp and outp to flush io buffers)

// GLintIRQ.* 0x20000250-0x200002ff
#define ET_VALUE_DW_GLINTIRQ_ENABLE                         0x20000250 // GLintIRQ.Enable

// OpenGL.* 0x20000300-0x200003ff
#define ET_VALUE_DW_OPENGL_USEHIQUALITYTEXTURE              0x20000300
#define ET_VALUE_DW_OPENGL_UNIXCONFORM                      0x20000301
#define ET_VALUE_DW_OPENGL_DOUBLEWRITE                      0x20000302
#define ET_VALUE_DW_OPENGL_DISABLEFASTCLEAR                 0x20000303 // OpenGL.DisableFastClear
#define ET_VALUE_DW_OPENGL_DISABLEMIPMAPS                   0x20000304
#define ET_VALUE_DW_OPENGL_TEXTURECOMPRESSION               0x20000305
#define ET_VALUE_DW_OPENGL_ENABLEP2ANTIALIAS                0x20000306
#define ET_VALUE_DW_OPENGL_SUPPORTOPENGLVERSION11           0x20000307
#define ET_VALUE_DW_OPENGL_FORCETRUECOLOR16BIT              0x20000308 // OpenGL.ForceTrueColorTexturesTo16bit
#define ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE                 0x20000309 // OpenGL.SupportSoftimage
#define ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE_351             0x2000030A // OpenGL.SupportSoftimage351

#define ET_VALUE_DW_OPENGL_DRAWLINEENDS                     0x2000030B
#define ET_VALUE_DW_OPENGL_ENABLEFIFOACCESS                 0x2000030C
#define ET_VALUE_DW_OPENGL_DISABLEDELTA                     0x2000030D
#define ET_VALUE_DW_OPENGL_MXDISABLEMIPMAPS                 0x2000030E
#define ET_VALUE_DW_OPENGL_FORCENNTEXFILTER                 0x2000030F
#define ET_VALUE_DW_OPENGL_DISABLEDMAFLUSHES                0x20000310
#define ET_VALUE_DW_OPENGL_DISABLEGXCULL                    0x20000311
#define ET_VALUE_DW_OPENGL_INVERTGXCFORMAT                  0x20000312
#define ET_VALUE_DW_OPENGL_PERSPECTIVECORRECTION            0x20000313
#define ET_VALUE_DW_OPENGL_REALLOCBLOCKSIZE                 0x20000314
#define ET_VALUE_DW_OPENGL_DISABLEDLISTTEXTURES             0x20000315
#define ET_VALUE_DW_OPENGL_DELTANODRAW                      0x20000316
#define ET_VALUE_DW_OPENGL_ENABLEBYPASSPATCH                0x20000317
#define ET_VALUE_DW_OPENGL_ENABLEBYPASSDMA                  0x20000318
#define ET_VALUE_DW_OPENGL_FORCENESTEDDMA                   0x20000319
#define ET_VALUE_DW_OPENGL_DISABLETRIANGLEPACKET            0x2000031A
#define ET_VALUE_DW_OPENGL_PRESERVETRUECOLORTEXTURES        0x2000031B // OpenGL.PreserveTrueColorTextures
#define ET_VALUE_DW_OPENGL_DUALTXPRO                        0x2000031C
#define ET_VALUE_DW_OPENGL_VERTEXCOOPTMAX                   0x2000031D
#define ET_VALUE_DW_OPENGL_NVVVOPTIMIZATION                 0x2000031E
#define ET_VALUE_DW_OPENGL_MIPMAPCONTROL                    0x2000031F
#define ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING           0x20000320 // OpenGL.DisableTexturePatching

#define ET_VALUE_DW_OPENGL_USEGIDCLIPPING                   0x20000321 // OpenGL.UseGidClipping
#define ET_VALUE_DW_OPENGL_PLACEMIPMAPSINALTERNATEBANKS     0x20000322 // OpenGL.PlaceMipMapsInAlternateBanks
#define ET_VALUE_DW_OPENGL_DISABLETEXTUREMANAGERLRU         0x20000323 // OpenGL.DisableTextureManagerLRU
#define ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER               0x20000324 // OpenGL.SupportProDesigner

#define ET_VALUE_DW_OPENGL_DMAMAXCOUNT                      0x20000325 // TNT: OpenGL.DMAMaxCount (size of DMA buffer)
#define ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT                  0x20000326 // TNT: OpenGL.DMAMinPushCount (fill grade of buffer to force flush)
#define ET_VALUE_DW_OPENGL_MAXTEXTURESIZE                   0x20000327
#define ET_VALUE_DW_OPENGL_MINVIDMEMTEXWIDTH                0x20000328
#define ET_VALUE_DW_OPENGL_MAXTEXHEAPSIZE                   0x20000329
#define ET_VALUE_DW_OPENGL_LIGHTINGANALYSIS                 0x2000032A  // BITFIELD
#define ET_VALUE_DW_OPENGL_LIGHTPICKINGOVERRIDE             0x2000032B  // BITFIELD
#define ET_VALUE_DW_OPENGL_STATISTICS                       0x2000032C  // BITFIELD
#define ET_VALUE_DW_OPENGL_BENCHING                         0x2000032D  // OpenGL.Benching
#define ET_VALUE_DW_OPENGL_USEKATMAI                        0x2000032E // BOOLEAN
#define ET_VALUE_DW_OPENGL_VERTEXCACHESIZE                  0x2000032F // DWORD
#define ET_VALUE_DW_OPENGL_PIXELTUBE                        0x20000330 // DWORD

// OpenGL AGP settings
#define ET_VALUE_DW_OPENGL_AGP_DMA                          0x20000331  // OpenGL.AGP.DMA
#define ET_VALUE_DW_OPENGL_AGP_TEXTURES                     0x20000332  // OpenGL.AGP.Textures
#define ET_VALUE_DW_OPENGL_FORCE_AGP_TEXTURES               0x20000333  // OpenGL.ForceAGPTextures

#define ET_VALUE_DW_OPENGL_FORCE_CLIPPING                   0x20000334  // OpenGL.ForceClipping
#define ET_VALUE_DW_OPENGL_ERRORLOG                         0x20000335  // OpenGL.ErrorLog
#define ET_VALUE_DW_OPENGL_DUMPLOG                          0x20000336  // OpenGL.DumpLog
#define ET_VALUE_DW_OPENGL_MCAD_MODE                        0x20000337  // OpenGL.MCAD
#define ET_VALUE_DW_OPENGL_SUPPORT_P2_CI4TEXTURES           0x20000338  // OpenGL.SupportP2CI4Textures
#define ET_VALUE_DW_OPENGL_FORCE_SINGLEBUFFERED             0x20000339  // BOOLEAN
#define ET_VALUE_DW_OPENGL_ALIGNED_SURFACES                 0x2000033A  // ULONG
#define ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA                  0x2000033B  // OpenGL.FramebufferDMA
#define ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS               0x2000033C  // Bitfield enabling Autocad 2000 opengl extensions
#define ET_VALUE_DW_OPENGL_USESENDDATAESCAPE                0x2000033D  // ULONG (0:ICD accesses HW, 1:automatic (ICD or Escape), 2: ICD uses Escape to fire DMA), FNicklis 07.05.1999
#define ET_VALUE_DW_OPENGL_DISABLE_STENCIL                  0x2000033E  // BOOLEAN (0: default, export stencil, 1: remove stencil formats), FNicklis 11.06.199
#define ET_VALUE_DW_OPENGL_DISABLE_ALPHA                    0x2000033F  // BOOLEAN (0: default, export alpha,   1: remove alpha formats), FNicklis 11.06.199
#define ET_VALUE_DW_OPENGL_PREFER_AGP_TEXTURES              0x20000340  // BOOL ('OpenGL.PreferAGPTextures, 0=default)
#define ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT_SENDDATA         0x20000341  // TNT: OpenGL.DMAMinPushCountSendData (fill grade of buffer to force flush)
#define ET_VALUE_DW_OPENGL_MULTIBOARD                       0x20000342  // BOOLEAN (1:default, allow OpenGL; 0:OpenGl not in mulitboard) OpenGL.MultiBoard
#define ET_VALUE_DW_OPENGL_UNIGRAPHICS_TEXTURE_FIX          0x20000343  // Enable bug fix for Unigraphics 15, 16 (border color for texture)
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITCONCEPT          0x20000344  // ULONG  (0:default do not wait 1:allways use DPCs 2:do wait until VBlank occured
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITLINESBEFORE      0x20000345  // ULONG  ( default: 2 ) amount of rasterlines before VBlank until to loop and wait for VBlank 
#define ET_VALUE_DW_ICDINTERFACE_STEREOWAITLINESAFTER       0x20000346  // ULONG  ( default: 1 ) amount of rasterlines after VBlank when to trigger stereo glasses + offsets 

                                                          //0x20000347  ...

// Heidi/Kinetix.* 0x20000400-0x200004ff
#define ET_VALUE_DW_HEIDI_USEEXCLUSIVE                      0x20000400
#define ET_VALUE_DW_HEIDI_USELINEARTEXTUREFILTER            0x20000401
#define ET_VALUE_DW_KTX_BUFFERREGIONS                       0x20000402 // e.g. KTX.BufferRegions
#define ET_VALUE_DW_KTX_SWAPHINTS                           0x20000403 // e.g. KTX.SwapHints
#define ET_VALUE_DW_KTX_ELSABUFFERREGIONS                   0x20000404 // e.g. KTX.ElsaBufferRegions
#define ET_VALUE_DW_KTX_BUFFER_REGIONS_FULL                 0x20000405 // e.g. KTX.BufferRegionsFull
#define ET_VALUE_DW_KTX_BUFFER_REGIONS_FIX                  0x20000406 // e.g. KTX.BufferRegionsFix

// HardwareInformation.* 0x20000500-0x200005ff
#define ET_VALUE_SZ_HARDWAREINFORMATION_ADAPTERSTRING       0x20000500
#define ET_VALUE_SZ_HARDWAREINFORMATION_CHIPTYPE            0x20000501
#define ET_VALUE_SZ_HARDWAREINFORMATION_DACTYPE             0x20000502
#define ET_VALUE_DW_HARDWAREINFORMATION_MEMORYSIZE          0x20000503
#define ET_VALUE_SZ_BOARDNAME                               0x20000504
#define ET_VALUE_SZ_DESCRIPTION                             0x20000505
#define ET_VALUE_SZ_SERNUM                                  0x20000506
#define ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING          0x20000507

// DDraw ids    0x20000600-0x200006ff
#define ET_VALUE_DW_DDRAWMULTIBOARDPRIMARY                  0x20000600 // DirectDraw.MultiboardPrimary
#define ET_VALUE_DW_DDRAWENABLEVIDEOIO                      0x20000601 // EnableVideoIO
#define ET_VALUE_DW_DDRAWMULTIBOARDHW_ENABLE                0x20000602 // DirectDraw.MultiboardEnabled
#define ET_VALUE_DW_DDRAWSUPPORT_OVERLAYSHRINK              0x20000603 // DirectDraw.SupportOverlayshrink

// LCD Panel    0x20000700-0x200007ff
#define ET_VALUE_DW_LCDPANELBORDERLEFTRIGHT                 0x20000700 // DUO.PanningBorderLeftRight
#define ET_VALUE_DW_LCDPANELBORDERTOPBOTTOM                 0x20000701 // DUO.PanningBorderTopBottom
#define ET_VALUE_DW_LCDPANELSTEPLEFTRIGHT                   0x20000702 // DUO.PanningStepLeftRight
#define ET_VALUE_DW_LCDPANELSTEPTOPBOTTOM                   0x20000703 // DUO.PanningStepTopBottom
#define ET_VALUE_DW_LCDPANELPANSTARTXRES                    0x20000704 // DUO.PanningStartXResolution
#define ET_VALUE_DW_LCDPANELSTRETCHXRES                     0x20000705 // DUO.LcdExpand
#define ET_VALUE_DW_LCDPANELSINGLEMODE                      0x20000706 // DUO.SingleControllerMode
#define ET_VALUE_DW_LCDPANELENABLECRT                       0x20000707 // DUO.CrtEnable
#define ET_VALUE_DW_LCDPANELENABLELCD                       0x20000708 // DUO.LcdEnable
#define ET_VALUE_DW_LCDPANELENABLETV                        0x20000709 // DUO.TvEnable
#define ET_VALUE_DW_LCDPANELTRUECOLORDITHER                 0x2000070A // DUO.LcdTruecolorDither
#define ET_VALUE_DW_LCDPANELTVFLICKERFILTER                 0x2000070B // DUO.TvFlickerFilter

// ********************************************************
// ********************************************************
// NV10 / NV 15 boards
// -----------------------------
// #define SUBESC_ET_GET_OUTPUT_DEVICE_INFO    0x00000310
// #define SUBESC_ET_SET_OUTPUT_DEVICE         0x00000311

#define PANEL_RESOLUTION_STRETCHED	0x0001
#define PANEL_RESOLUTION_CENTERED	0x0002
#define PANEL_RESOLUTION_NATIVE	0x0004

#define DEVICE_TYPE_INVALID   0x0000
#define DEVICE_TYPE_CRT       0x0001
#define DEVICE_TYPE_LCD       0x0002
#define DEVICE_TYPE_TV        0x0004

typedef struct tagET_COMMON_OUTPUT_DEVICE_INFO
{
  DWORD   dwDeviceType;         // holds the type of the device (CRT/LCD/TV)
  DWORD   dwDeviceConnected;    // is this device connected to graphics board
  DWORD   dwDeviceOn;           // is the device switched on
  DWORD   dwHorSize;            // horizontal size of the device in pixel
  DWORD   dwVertSize;           // vertical size of the device in pixel
  DWORD   dwDisplayMode;        // display mode of device ( stretched, native, centered )
  DWORD   dwSupportedDisplayModes;   // supported display modes of device ( stretched, native, centered )
}ET_COMMON_OUTPUT_DEVICE_INFO, *PET_COMMON_OUTPUT_DEVICE_INFO;

typedef struct tagET_OUTPUT_DEVICE_INFO
{
  DWORD   dwSize;                   // size of structure
  DWORD   dwDevicesSupported;       // bitfield containing type of supported devices
  DWORD   dwSimultaniousDevices;      // bitfield containing type of devices supported at the same time
  ET_COMMON_OUTPUT_DEVICE_INFO  crt;  // information on the CRT
  ET_COMMON_OUTPUT_DEVICE_INFO  lcd;  // information on the LCD
  ET_COMMON_OUTPUT_DEVICE_INFO  tv;   // information on the tv set
  DWORD   dwNumAdditionalDevices;   // number of additional ET_COMMON_OUTPUT_DEVICE_INFO structures needed
  ET_COMMON_OUTPUT_DEVICE_INFO  *pAdditionalInformation;
} ET_OUTPUT_DEVICE_INFO, *PET_OUTPUT_DEVICE_INFO;

// Structure to set output device
typedef struct tagET_SET_OUTPUT_DEVICE
{
  ET_QUERY                    hdr;

  DWORD                       dwParam1;             //1 saves to registry, 0 for testing
  ET_OUTPUT_DEVICE_INFO       deviceInfo;
} ET_SET_OUTPUT_DEVICE, *PET_SET_OUTPUT_DEVICE;

//Structure to retrieve complete information on the output devices
typedef struct tagET_GET_OUTPUT_DEVICE_INFO
{
  DWORD                       dwSize;
  ET_OUTPUT_DEVICE_INFO       deviceInfo;
} ET_GET_OUTPUT_DEVICE_INFO,*PET_GET_OUTPUT_DEVICE_INFO;


// ********************************************************
// ********************************************************
// LCD panel with WINNER 1000DUO
// -----------------------------

// Common information on actual PANEL settings (used in Get and Set info)
typedef struct tagET_COMMON_PANEL_INFO
{
  LONG        lPanStepLR;           //Panning stepsize right/left panning
  LONG        lPanStepTB;           //Panning stepsize up/down panning
  LONG        lPanBorderLR;         //Area where panning begins before cursor hits panel end left/right
  LONG        lPanBorderTB;         //Area where panning begins before cursor hits panel end top/bottom
  LONG        lPanStartResX;        //We start panning if our Resolution exceeds this value
  LONG        lStretchEndXRes;      //Bitfield to describe the resolutions at which we want to stretch/expand
  DWORD       dwEnablePanel;        //We enable the LCD
  DWORD       dwEnableCrt;          //We enable the CRT
  DWORD       dwEnableTV;           //We enable the TV
  DWORD       dwPanelSingleMode;    //One Controller for both displays
  LONG        lTVFlickerFilter;     //1(disabled),2 or 3 line Flickerfilter
  DWORD       dwLCDTrueColorDither; //True Color dithering or reducing to 18bit
} ET_COMMON_PANEL_INFO, *PET_COMMON_PANEL_INFO;


// In structure (Tool -> driver):
// Structure to set the new Panel settings
typedef struct tagET_SET_PANEL_INFO
{
  ET_QUERY              hdr;

  DWORD                 dwParam1;             //1 saves to registry, 0 for testing
  ET_COMMON_PANEL_INFO  CommonPanelInfo;
} ET_SET_PANEL_INFO, *PET_SET_PANEL_INFO;


// Out structure (Driver -> Tool):
//Structure to retrieve complete information on the actual Panel
typedef struct tagET_GET_PANEL_INFO
{
  DWORD                 dwSize;

  DWORD                 dwPanelSupport;       //Does the Board support a LCD Panel
  LONG                  lXResPanel;           //X-Res of our Panel
  LONG                  lYResPanel;           //Y-Res of our Panel

  ET_COMMON_PANEL_INFO  CommonPanelInfo;

} ET_GET_PANEL_INFO, *PET_GET_PANEL_INFO;

// ********************************************************
// ********************************************************
//NEW: SK 13011999
//Interface for Maxtreme to enable/disable stereo for a given window

//In structure (Tool -> driver )
//Structure to set the Stereomode of a oglwindow. (for Maxtreme)
typedef struct tagET_SET_WINDOW_STEREOMODE
{
  ET_QUERY  hdr;

  PVOID     hwnd;   //Windowhandle // ELSA-FNicklis 27.04.00: not all of our code knows a HWND
  DWORD     dwMode; //STEREOMODE_ENABLE or STEREOMODE_DISABLE
} ET_SET_WINDOW_STEREOMODE, *PET_SET_WINDOW_STEREOMODE;

#define STEREOMODE_DISABLE  0x00000000
#define STEREOMODE_ENABLE   0x00000001

// ********************************************************


//
// NT direct hw access support - development only
//

// SUBESC_ET_GETREGISTER
typedef struct tagET_GETREG
{
  DWORD dwSize;
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
}ET_GETREG, *PET_GETREG, FAR *LPET_GETREG;

// SUBESC_ET_SETREGISTER
typedef struct tagET_SETREG
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SETREGISTER
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
}ET_SETREG, *PET_SETREG, FAR *LPET_SETREG;

// SUBESC_ET_MODIFYREGISTER
typedef struct tagET_MODIFYREG
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_MODIFYREGISTER
  DWORD dwRegister;
  DWORD dwValue;
  DWORD dwFlags;
  DWORD dwMask; // (all bits to modify set to 1)
}ET_MODIFYREG, *PET_MODIFYREG, FAR *LPET_MODIFYREG;

//
// dwFlags values
//
#define MMIO_ACCESS             0x00 << 16  // default: mmio, sync + vblankwait
#define PIO_ACCESS              0x01 << 16
#define NO_SYNC                 0x02 << 16
#define NO_VBLANKWAIT           0x04 << 16
#define NO_FIFOWAIT             0x08 << 16

#define ACCESS_DWORD 0x01 << 0
#define ACCESS_WORD  0x02 << 0
#define ACCESS_BYTE  0x04 << 0



// SUBESC_ET_NOTIFYDRIVER
typedef struct tagET_NOTIFYDRIVER
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_NOTIFYDRIVER
  DWORD dwNotification;
}ET_NOTIFYDRIVER, *PET_NOTIFYDRIVER, FAR *LPET_NOTIFYDRIVER;

// notifications: video capture driver to display driver
#define EDDESC_VIO2DRVNOTIFY_TVOUTON   0x01
#define EDDESC_VIO2DRVNOTIFY_TVOUTOFF  0x02



// SUBESC_ET_SCROLL
// scrolling into offscreen (debug purposes)
typedef struct tagET_SCROLL_DATA
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SCROLL
  LONG  cyLines;            // # of lines vertical panning
}ET_SCROLL_DATA, FAR *LPET_SCROLL_DATA;



// SUBESC_ET_GFXOPTIONQUERY
// GfxOptionQuery support
typedef struct tagET_GFXOPTIONQUERY
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_GFXOPTIONQUERY
  DWORD dwGfxOption;        // in/out parameter
}ET_GFXOPTIONQUERY_DATA, FAR *LPET_GFXOPTIONQUERY_DATA;

// SUBESC_ET_SAA
// video in/out related stuff, used by Windows NT video capture driver for hw access
typedef struct tagET_SAA_DATA
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SAA
  DWORD dwSAACommand;       // = defines below
  DWORD dwData;
  DWORD dwRegister;
  DWORD dwReturn;
}ET_SAA_DATA, FAR *LPET_SAA_DATA;

#define I2COPEN                   1000
#define I2CCLOSE                  1001

#define CHECKSAA7111              1
#define WRITESAA7111              2
#define READSAA7111               3

#define CHECKSAA7125              101
#define WRITESAA7125              102
#define READSAA7125               103

// ********************************************************
// code for SUBESC_ET_QUERY_ICDCLIENTINFO:
// 12.02.1999 FNicklis

// input structure app -> driver
typedef struct tagET_QUERY_ICDCLIENTINFO_IN
{
  ET_QUERY hdr;  // size and subescape ET_QUERY_ICDCLIENTINFO
} ET_QUERY_ICDCLIENTINFO_IN;

typedef struct tagET_ICDCLIENTINFO
{
  DWORD  dwClientID;     // 1 per window
  DWORD  dwContextCount; // n per window > 0; 0==invalid
  DWORD  dwProcessID;    // 0==invalid/unused/unkown
  HANDLE hWnd;           // window handle
  LONG   lPixelFormat;   // used pixelformat number
} ET_ICDCLIENTINFO;

// output structure driver -> app
typedef struct tagET_QUERY_ICDCLIENTINFO_OUT
{
  DWORD  dwSize;          // Length of this out buffer
  DWORD  dwTotalClients;  // Total count of running OpenGL clients
  DWORD  dwReturnClients; // Count of information units returned to app

  ET_ICDCLIENTINFO aClientInfo[1]; // array of 1, ...
} ET_QUERY_ICDCLIENTINFO_OUT;


// ********************************************************
// code for SUBESC_ET_QUERY_TEMPERATURE:
// 28.09.1999 Thorsten Schumann

// bits used as caps and as status
#define ET_TEMPERATURE_FANSLOW     0x00000001   // fan slow or stop
#define ET_TEMPERATURE_FANSHORTVCC 0x00000002   // fan short VCC (only on boot phase available)
#define ET_TEMPERATURE_OVERTEMP    0x00000004   // over temperature
#define ET_TEMPERATURE_VALUE       0x00000008   // for future release, not yet used
                                                //    entry dwTemperatureValue is used

// output structure driver -> app
typedef struct tagET_QUERY_TEMPERATURE
{
  DWORD  dwSize;              // Length of this out buffer
  DWORD  dwTemperatureCaps;    // caps of valid record entries / hardware caps
  DWORD  dwTemperatureStatus; // status of flags
  DWORD  dwTemperatureValue;  // for future release, not yet used
  DWORD  dwReserved1;
  DWORD  dwReserved2;
} ET_QUERY_TEMPERATURE, FAR *LPET_QUERY_TEMPERATURE;


// ********************************************************
// begin of code for SUBESC_ET_DPMS:
//
// Set or query DPMS power save mode. Send ET_DPMS_IN structure
// with wanted DPMS mode to driver and always receive selected
// mode. If Escape fails, the DPMS mode was not set!
//
// FNicklis 29.09.1999: added SUBESC_ET_DPMS and sample code
//
// Sample code to set powersave mode:
//   taken from PowerSaver.scr Screen saver
//
  /*
//
// bSetDPMSMode
//
// enables ELSAESC-ET_DPMS power save mode via Escape call to driver.
//
// return: TRUE  - mode set successfully
//         FALSE - failed to set powersave mode
//
// FNicklis 29.09.1999: New
//
static BOOL bSetDPMSMode(
  IN ET_DPMS_MODE lMode)      // Power save mode to set
{
  BOOL        bRet=FALSE;     // pessimistic
  LONG        lResult;        // return value of extescape
  ET_DPMS_IN  etPowersaveIn;  // App -> Driver
  ET_DPMS_OUT etPowersaveOut; // Driver -> App
  HDC         hDC;            // Desktops HDC (to reach the display driver)

  ZeroMemory(&etPowersaveIn, sizeof(etPowersaveIn));

  etPowersaveIn.hdr.dwSize    = sizeof(etPowersaveIn);
  etPowersaveIn.hdr.dwSubEsc  = SUBESC_ET_DPMS;
  etPowersaveIn.hdr.dwOutSize = sizeof(etPowersaveOut);
  etPowersaveIn.hdr.dwBoard   = 0;
  etPowersaveIn.lMode         = lMode;

  hDC = GetDC(0);

  lResult = ExtEscape(hDC,
    ESC_ELSA_TOOLS,
    sizeof(etPowersaveIn),
    (PVOID)&etPowersaveIn,
    sizeof(etPowersaveOut),
    (PVOID)&etPowersaveOut);

  if (lResult>0)
  {
    assert(sizeof(etPowersaveOut)==etPowersaveOut.dwSize);
    assert((lMode==ET_DPMS_QUERY) || (etPowersaveIn.lMode==etPowersaveOut.lMode));
    bRet=TRUE;
  }
  else
  {
    // error: failed for call SUBESC_ET_DPMS");
  }

  return(bRet);
}
  */

// defines for DPMS-Power save modes
typedef enum tagET_DPMS_MODE
{
  ET_DPMS_ON,      // in/out: default mode, turn on monitor
                // Powersave modes:
  ET_DPMS_STANDBY, // in/out:
  ET_DPMS_SUSPEND, // in/out:
  ET_DPMS_OFF,     // in/out:

  ET_DPMS_QUERY    // in: return current mode in ET_DPMS_OUT. Only used in ET_DPMS_IN.ulMode!
} ET_DPMS_MODE;

// input structure app -> driver
typedef struct tagET_DPMS_IN
{
  ET_QUERY     hdr;    // size and subescape ET_DPMS_IN
  ET_DPMS_MODE lMode;  // type of mode to set or query
} ET_DPMS_IN;

// output structure driver -> app
typedef struct tagET_DPMS_OUT
{
  DWORD        dwSize; // Length of this out buffer
  ET_DPMS_MODE lMode;  // return current mode which is POWERSAVE_DISABLE or POWERSAVE_ENABLE
} ET_DPMS_OUT;

// end of code for SUBESC_ET_DPMS:
// ********************************************************

#ifdef WIN32
#pragma pack (pop, fixed_forELSAESC)
#else
#pragma pack ()
#endif

#endif //__ELSAESC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvOverlay.h ===
#ifndef __gl_nvOverlay_h_
#define __gl_nvOverlay_h_

/*
 * Copyright (c) 2000, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

// RBiermann: add global definitions for OpenGL Overlay Planes here:

// the number of palette entries
#define ICD_PALETTE_ENTRIES 256

// layer palette transparent index
#define ICD_PALETTE_TRANSPARENT_INDEX 0

// the transparent color is black
#define ICD_PALETTE_TRANSPARENT_COLOR 0

#endif  /* __gl_nvOverlay_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvcom.h ===
#ifndef __NV_COM_H
#define __NV_COM_H

#include "nvOverlay.h"

// XXX Having to define this here sucks.  This is in mtexport.h but
// mtexport.h needs NVstate stuff :(   -paul
#ifndef WQ_MAX_THREAD
#define WQ_MAX_THREAD 2
#endif

typedef struct  __GLNVtagInfoRec {
    unsigned int  type;
    void          *address;
} __GLNVtagInfo;    

// Basic element of the pushbuffer
typedef union __GLNVdataRec {
    NvF32 f;
    NvS32 i;
    NvU32 u;
} __GLNVdata;

// Flags passed into the display driver when allocating or requesting
// info regarding the unified buffers.

enum  {
    SBD_BACK_1_OFFSET = 0,
    SBD_BACK_1_PITCH,
    SBD_BACK_2_OFFSET,
    SBD_BACK_2_PITCH,
    SBD_DEPTH_OFFSET,
    SBD_DEPTH_PITCH,
    SBD_FRONT_MAIN_OFFSET,
    SBD_FRONT_MAIN_PITCH,
    SBD_BACK_1_MAIN_OFFSET,
    SBD_BACK_1_MAIN_PITCH,
    SBD_FRONT_OVERLAY_OFFSET,
    SBD_FRONT_OVERLAY_PITCH,
    SBD_BACK_1_OVERLAY_OFFSET,
    SBD_BACK_1_OVERLAY_PITCH
};

typedef struct __GLNVsbdFlagsRec {
    int windowFlipping;  // Enable window flipping
    int overlaySupport;  // Allocate overlay buffers
    int surfaceInfoType;
} __GLNVsbdFlags;


typedef struct __GLNVpaletteDataRec {
  void         *windowHandle;
  unsigned int  entries[ICD_PALETTE_ENTRIES];
  unsigned int  crTransparent;
} __GLNVpaletteData;

typedef struct __GLMergeBlitDataRec
{
    NvU32 PrimaryFrontOffset; // offset of primary buffer (where DAC is working)
    NvU32 PrimaryFrontPitch ;
    NvU32 ScratchOffset     ; // offset of scratch buffer for mergeblit
    NvU32 ScratchPitch      ;

    NvU32 MainFrontOffset   ; // offset of main front plane (where overlay app has its main)
    NvU32 MainFrontPitch    ;
    NvU32 MainBackOffset    ; // offset of main back plane (where overlay app has its main)
    NvU32 MainBackPitch     ;

    NvU32 OverlayFrontOffset; // offset of overlay front plane (where overlay app has its overlay)
    NvU32 OverlayFrontPitch ;
    NvU32 OverlayBackOffset ; // offset of overlay back plane (where overlay app has its overlay)
    NvU32 OverlayBackPitch  ;

    int   colordepth        ; // 16 or 32, color depth of above buffers (UBB)

    NvU32 colorref          ; // colorkey for transparent color

    unsigned int   dwAction ; // NV_OVERLAY_xxx

    __GLregionRect *prclClip; // pointer to list of clip rects
    unsigned int    cClip;    // count of valid rects inside prclClip

    __GLregionRect rclUser  ; // single user clip rect 
} __GLMergeBlitData;


typedef struct __GLNVcmdInfoRec {

    void *state;  // __GLNVstate opaque ptr in case we need it.

    // Channel information for syncing in NTx display driver
    NvU32        maskOtherChannels;
    unsigned int ourChannelId;
    void         *ntOther; // PDEV pointer 
    void         *ntDrawable; // clientDrawableInfo pointer 

    // Number of hardware window clipping rectangles available.
    // Should be 8 for NV10GL and 1 for NV10 geForce.
    int numHWClipRects;

    // Client size view of windowChangedCount at time of kickoff; this is
    // compared with the latest count inside the display driver.  If they
    // are out of sync and flushBetween2D is TRUE then fail the kick off
    // in the display driver.
    int windowChangedCount;
    int flushedBetween2D;

    unsigned char isClipped;
    int serverSwapNT4;

    int nvDebugLevel;
    int nvDebugOptions;
    int nvDebugMask;
    int nvControlOptions;

    int temp0;
    int temp1;
    int temp2;
    int temp3;
    int temp4;
} __GLNVcmdInfo;

//
// NV10 flush information structure
//
typedef struct __GLNVflushInfoRec {
    // flush type, client handle and window handle
//    ULONG        type;
    ULONG        hClient;
#if defined(_WIN32)
    HWND         hWnd;
    HDC          hDC;
#endif

    // clip and mode switch info
    ULONG        localModeSwitchCount;

    __GLNVcmdInfo *cmdInfo;
    
    // Core Clip rectangle computed by wgl in screen coordinates
    __GLregionRect coreClipRect;

    // Tells Display driver that scissor has changed.
    ULONG wndClipRectChanged;
    
    // Clip Changed Count 
    ULONG clipChangedCount;

    // TRUE if rendering to the back buffer
    ULONG backBufferIsEnabled;

    // return status from flush command
    unsigned int retStatus;   // status of flush in display driver
} __GLNVflushInfo;

typedef struct __GLNVswapInfoRec {
    ULONG        hClient;
#if defined(_WIN32)
    HWND         hWnd;
    HDC          hDC;
#endif
    // window info
    __GLNVcmdInfo *cmdInfo;

    // clip and mode switch info
    ULONG        localModeSwitchCount;
    PVOID        drawable;

    // SwapHintRect info
    unsigned int        numSwapHintRects;
    __GLregionRect*     pSwapHintRects;

    // return status
    ULONG        retStatus;
} __GLNVswapInfo;


// probably needs to be removed to better place
// bits used in __glNVOverlayMergeFastLock - dwAction
#define NV_OVERLAY_MERGE_BLIT        0x00000001 // do front overlay + front main -> scratch -> primary
#define NV_OVERLAY_UPDATE_OVERLAY    0x00000010 // overlay back -> overlay front (prior to merge)
#define NV_OVERLAY_UPDATE_MAIN       0x00000020 // main back -> overlay front (prior to merge)
#define NV_OVERLAY_USE_CLIPRECT      0x00000100 // only do mergeblit on given rect (else entire window)
#define NV_OVERLAY_DEFERRED          0x00001000 // defer merge blit (do update later)
#define NV_OVERLAY_RUN_IN_DD         0x00002000 // do mergeblit in display driver
#define NV_OVERLAY_NO_OVERLAY_PLANE  0x00010000 // there is no overlay plane, front main -> primary (will overwrite NV_OVERLAY_MERGE_BLIT)


//
// Derived from __GLNVswapInfo to support overlay merge blit through DD.
// Used with the ESC_NV_OPENGL_OVERLAY_MERGEBLIT escape 
// in __glNVOverlayMergeFastLock.
//
typedef struct __GLNVoverlayMergeBlitInfoRec {
    unsigned int hClient;
#if defined(_WIN32)
    HWND         windowHandle;
    HDC          deviceContext;
#endif
    
    // window info
    __GLNVcmdInfo *cmdInfo;

    // clip and mode switch info
    unsigned int localModeSwitchCount;

    // return status
    unsigned int retStatus;

    unsigned int dwAction; // NV_OVERLAY_xxx

    int          x;        // bounding rectangle if NV_OVERLAY_USE_CLIPRECT is set 
    int          y;
    int          width;
    int          height;

    // SwapHintRect info
    unsigned int numSwapHintRects;
    void *       pSwapHintRects;

} __GLNVoverlayMergeBlitInfo;

//
// These routines live in the shared lib and are called from both the ICD
// and from the display driver side of OGL escape calls.  -paul
//

// nvsharedpushbuf.c
extern void STDCALL __glNVMakeJumpSpaceInPushBuffer(__GLNVcmdInfo *cmdInfo);
extern void STDCALL __glNVSetupAndKickoff(__GLNVcmdInfo *cmdInfo,
                                          unsigned int numInclusiveRects,__GLregionRect *inclusiveRects,
                                          unsigned int numExclusiveRects,__GLregionRect *exclusiveRects);
// nvsharedutils.c
extern void STDCALL __glNVInitSharedFnPtrs(__GLNVcmdInfo *cmdInfo);

// nvsharedswap.c
extern GLboolean STDCALL __glNVSetupSwap (__GLNVcmdInfo *cmdInfo, void * drawable,
                                          unsigned int numRects, __GLregionRect *rects,
                                          int screenWidth, int screenHeight);
extern GLboolean STDCALL __glNVSetupMergeBlit (__GLNVcmdInfo *cmdInfo, 
                                          struct __GLMergeBlitDataRec *pMergeBlitData);

// nv4sharedpushbuf.c
extern void STDCALL __glNV4SetupAndKickoff(__GLNVcmdInfo *cmdInfo,
                                           unsigned int numRects,
                                           __GLregionRect *rects);
#endif  // __NV_COM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvCapture.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//////////////////////////////////////////////////////////////////////////////
// schema history
// 1. original version
// 2. adds CAPTURE_OBJECT_FREE, ANNOTATION, CAPTURE_CONFIG settings
// 3. adds CAPTURE_SYNC3 and obsoletes CAPTURE_SYNC
// 4. adds CAPTURE_LOCK
//////////////////////////////////////////////////////////////////////////////

#ifndef _nvCapture_h
#define _nvCapture_h

#ifdef __cplusplus
extern "C"
{
#endif
#pragma pack(push,1)

//////////////////////////////////////////////////////////////////////////////
// constants
//
#define CAPTURE_JMP_COMMAND             0x20ffffff
#define CAPTURE_EXT_SIGNATURE           0x420352ec

#define CAPTURE_CTXDMA_TYPE_PCI         0x49435920
#define CAPTURE_CTXDMA_TYPE_AGP         0x50474120
#define CAPTURE_CTXDMA_TYPE_VID         0x44495620

#define CAPTURE_SURFACE_TYPE_NORMAL     0x4d524f4e  // 'NORM'  surface goes into normal space (tiled)
#define CAPTURE_SURFACE_TYPE_ZETA       0x4154455a  // 'ZETA'  surface goes into zeta space (tiled)
#define CAPTURE_SURFACE_TYPE_TEXTURE    0x54584554  // 'TEXT'  surface goes into texture space

#define CAPTURE_SURFACE_KIND_TARGET     0x54475254  // 'TRGT'  surface will be used as a render target
#define CAPTURE_SURFACE_KIND_ZETA       0x4154455a  // 'ZETA'  surface will be used as a z buffer
#define CAPTURE_SURFACE_KIND_TEXTURE    0x54584554  // 'TEXT'  surface will be used as a texture
#define CAPTURE_SURFACE_KIND_VERTEX     0x54524556  // 'VERT'  surface will be used as a vertex buffer
#define CAPTURE_SURFACE_KIND_PUSHER     0x48535550  // 'PUSH'  surface will be used as a push buffer
#define CAPTURE_SURFACE_KIND_UNKNOWN    0x4e4b4e55  // 'UNKN'  surface will be used as a push buffer
#define CAPTURE_SURFACE_KIND_COMMAND    0x4d4d4f43  // 'COMM'  surface will be used as a command buffer
#define CAPTURE_SURFACE_KIND_PALETTE    0x434c4150  // 'PALE'  surface will be used as a palette

#define CAPTURE_SURFACE_FORMAT_Y8                0
#define CAPTURE_SURFACE_FORMAT_AY8               1
#define CAPTURE_SURFACE_FORMAT_A1R5G5B5          2
#define CAPTURE_SURFACE_FORMAT_X1R5G5B5          3
#define CAPTURE_SURFACE_FORMAT_A4R4G4B4          4
#define CAPTURE_SURFACE_FORMAT_R5G6B5            5
#define CAPTURE_SURFACE_FORMAT_A8R8G8B8          6
#define CAPTURE_SURFACE_FORMAT_unknown1          7
#define CAPTURE_SURFACE_FORMAT_X8R8G8B8          8
#define CAPTURE_SURFACE_FORMAT_I8_A1R5G5B5       9
#define CAPTURE_SURFACE_FORMAT_I8_R5G6B5        10
#define CAPTURE_SURFACE_FORMAT_I8_A4R4G4B4      11
#define CAPTURE_SURFACE_FORMAT_I8_A8R8G8B8      12
#define CAPTURE_SURFACE_FORMAT_DXT1_A1R5G5B5    13
#define CAPTURE_SURFACE_FORMAT_DXT23_A8R8G8B8   14
#define CAPTURE_SURFACE_FORMAT_DXT45_A8R8G8B8   15
#define CAPTURE_SURFACE_FORMAT_IMAGE_A1R5G5B5   16
#define CAPTURE_SURFACE_FORMAT_IMAGE_R5G6B5     17
#define CAPTURE_SURFACE_FORMAT_IMAGE_A8R8G8B8   18
#define CAPTURE_SURFACE_FORMAT_IMAGE_Y8         19
#define CAPTURE_SURFACE_FORMAT_IMAGE_SY8        20
#define CAPTURE_SURFACE_FORMAT_IMAGE_X7SY9      21
#define CAPTURE_SURFACE_FORMAT_IMAGE_R8B8       22
#define CAPTURE_SURFACE_FORMAT_IMAGE_G8B8       23
#define CAPTURE_SURFACE_FORMAT_IMAGE_SG8SB8     24
#define CAPTURE_SURFACE_FORMAT_unknown2         25
#define CAPTURE_SURFACE_FORMAT_unknown3         26
#define CAPTURE_SURFACE_FORMAT_unknown4         27

#define CAPTURE_LOCK_TYPE_LOCK                   1
#define CAPTURE_LOCK_TYPE_UNLOCK                 2

#define CAPTURE_ANNOTATION_ALLOC4X               0

#define CAPTURE_SYNC_SPECIAL            0xffffffff
#define CAPTURE_SYNC_WAIT_ZEROCOMMANDS  0x00000001  // wait for command buffer to empty (put==get)
#define CAPTURE_SYNC_WAIT_CHIPIDLE      0x00000002  // wait fot call engines to go idle
#define CAPTURE_SYNC_WAIT_CHANNELS      0x00000003  // wait for other channels to complete

#define CAPTURE_SYNC3_TYPE_ZEROCOMMANDS 0x00000001  // wait for command buffer to empty (put==get)
#define CAPTURE_SYNC3_TYPE_CHIPIDLE     0x00000002  // wait fot call engines to go idle
#define CAPTURE_SYNC3_TYPE_CHANNELS     0x00000003  // wait for other channels to complete
#define CAPTURE_SYNC3_TYPE_NOTIFIER     0x00000004  // wait for a notifier
#define CAPTURE_SYNC3_TYPE_REFCOUNT     0x00000005  // wait for a refcount
#define CAPTURE_SYNC3_TYPE_SEMAPHORE    0x00000006  // wait for a semaphore

#define CAPTURE_SCHEMA_1                0x00000001
#define CAPTURE_SCHEMA_2                0x00000002
#define CAPTURE_SCHEMA_3                0x00000003
#define CAPTURE_SCHEMA_4                0x00000004

#ifdef DANIEL
#define CAPTURE_CURRENT_SCHEMA          CAPTURE_SCHEMA_1
#else
#define CAPTURE_CURRENT_SCHEMA          CAPTURE_SCHEMA_4
#endif

//
// INFORMATION
//
#define CAPTURE_XID_INFORMATION             0x4f464e49  // 'INFO'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_INFORMATION
    DWORD dwSchema;                 // file version (CAPTURE_CURRENT_SCHEMA)
    char  szInformation[256];       // creation info
} CAPTURE_INFORMATION;

//
// CTXDMA_CREATE
//
#define CAPTURE_XID_CTXDMA_CREATE           0x52435843  // 'CXCR'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_CTXDMA_CREATE
    DWORD dwHandle;                 // you figure it out, Tex
    DWORD dwType;                   // CAPTURE_CTXDMA_TYPE_xxx
    DWORD dwSize;                   // [bytes]
    DWORD dwBaseAddress;            // application base address
} CAPTURE_CTXDMA_CREATE;

//
// SURFACE_ALLOC
//
#define CAPTURE_XID_SURFACE_ALLOC           0x41465253  // 'SRFA'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SURFACE_ALLOC
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
    DWORD dwSize;                   // size of surface (in bytes)
    DWORD dwAlignment;              // alignment (if known, 0 - let interpreter infer from CTXDMA)
    DWORD dwType;                   // CAPTURE_SURFACE_TYPE_xxx
    DWORD dwKind;                   // usage hint - CAPTURE_SURFACE_KIND_xxx
    DWORD dwSurfaceType;            // CAPTURE_SURFACE_FORMAT_xxx
    DWORD dwIntendedPitch;          // pitch we think we will apply on this surface
    DWORD dwIntendedHeight;         // height we think we will apply on this surface
} CAPTURE_SURFACE_ALLOC;

//
// SURFACE_FREE
//
#define CAPTURE_XID_SURFACE_FREE            0x46465253  // 'SRFF'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SURFACE_FREE
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
} CAPTURE_SURFACE_FREE;

//
// MEMORY_WRITE
//
#define CAPTURE_XID_MEMORY_WRITE            0x574d454d  // 'MEMW'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_MEMORY_WRITE
    DWORD dwCtxDMAHandle;           // you figure it out, Tex
    DWORD dwOffset;                 // offset in CTXDMA
    DWORD dwSize;                   // number of bytes (multiple of 4)
    // [ data goes here ]
} CAPTURE_MEMORY_WRITE;

//
// SYNC - obsoleted in schema 3
//
#define CAPTURE_XID_SYNC                    0x434e5953  // 'SYNC'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SYNC
    DWORD dwCtxDMAHandle;           //                  [ if special, undefined                              ]
    DWORD dwOffset;                 // offset in CTXDMA [ special case when dwOffset == CAPTURE_SYNC_SPECIAL ]
    DWORD dwValue;                  // value to match   [ if special, one of CAPTURE_SYNC_WAIT_xxx           ]
} CAPTURE_SYNC;

//
// SYNC3
//
#define CAPTURE_XID_SYNC3                   0x334e5953  // 'SYN3'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SYNC3
    DWORD dwType;                   // CAPTURE_SYNC3_TYPE_xxx
    DWORD dwCtxDMAHandle;           // valid for type semaphore, else irrelevant
    DWORD dwOffset;                 // offset in CTXDMA, valid for type semaphore, else irrelevant
    DWORD dwValue;                  // value to match
} CAPTURE_SYNC3;

//
// OBJECT_CREATE
//
#define CAPTURE_XID_OBJECT_CREATE           0x5243424f  // 'OBCR'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_OBJECT_CREATE
    DWORD dwClassID;                // actual class this handle maps to
    DWORD dwHandle;                 // handle of the class
} CAPTURE_OBJECT_CREATE;

//
// OBJECT_FREE
//
#define CAPTURE_XID_OBJECT_FREE             0x5246424f  // 'OBFR'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_OBJECT_FREE
    DWORD dwHandle;                 // you figure it out, Tex
} CAPTURE_OBJECT_FREE;

//
// SCENE
//
#define CAPTURE_XID_SCENE                   0x454e4353  // 'SCNE'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_SCENE
} CAPTURE_SCENE;

//
// LOCK / UNLOCK
//
#define CAPTURE_XID_LOCK                    0x4b434f4c  // 'LOCK'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_LOCK
    DWORD dwType;                   // CAPTURE_LOCK_TYPE_xxx
    DWORD dwCtxDMAHandle;
    DWORD dwOffset;
} CAPTURE_LOCK;

//
// ANNOTATION
//
#define CAPTURE_XID_ANNOTATION              0x4f4e4e41  // 'ANNO'
typedef struct
{
    DWORD dwJmpCommand;             // CAPTURE_JMP_COMMAND
    DWORD dwExtensionSignature;     // CAPTURE_EXT_SIGNATURE
    DWORD dwExtensionID;            // CAPTURE_XID_ANNOTATION
    DWORD dwValue;                  // CAPTURE_ANNOTATION_xxx
} CAPTURE_ANNOTATION;


//////////////////////////////////////////////////////////////////////////////
// procedures
//
int captureStartup   (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int captureShutdown  (void);
int captureSetParams (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int captureLog       (void *pBuffer, unsigned uCount);
int captureFileInc   (void);

int capturePlayStartup   (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int capturePlayShutdown  (void);
int capturePlaySetParams (char *szBasePath, char *szBaseFilename, DWORD dwBaseFilenum);
int capturePlay          (void *pRenderTarget, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight);
int capturePlayFileInc   (void);

#pragma pack(pop)
#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvDMAC.h ===
// (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVDMAC.H                                                          *
*   Define various macros used to interact with the hardware                *
*   Please put other more general D3D macros in nvd3dmac or elsewhere!      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       1/26/98 - Created                       *
*                                                                           *
\***************************************************************************/

#ifndef _NV4DMAC_H_
#define _NV4DMAC_H_

#ifdef __cplusplus
extern "C" {
#endif

// NV Reference Manual register access definitions.
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//-------------------------------------------------------------------------
//                 GENERIC DMA PUSH BUFFER OPERATIONS
//-------------------------------------------------------------------------

#define sizeSetObject                       2
#define nvglSetObject(ch, obj)                                              \
{                                                                           \
    nvPushData (0, (0x00040000 | ((ch) << 13)));                            \
    nvPushData (1, obj);                                                    \
    nvPusherAdjust (sizeSetObject);                                         \
}

#define sizeSetStartMethod                  1
#define nvglSetStartMethod(index, ch, method, methodcount)                  \
{                                                                           \
    nvPushData (index, ((((methodcount) << 2) << 16) | ((ch) << 13) | (method))); \
}

#define sizeSetData                         1
#define nvglSetData(index, data)                                            \
{                                                                           \
    nvPushData (index, (data));                                             \
}

#define nvglAdjust(size)                                                    \
{                                                                           \
    nvPusherAdjust (size);                                                  \
}

#define sizeDmaJump         1
#define nvglDmaJump(offset)                                                 \
{                                                                           \
    nvPushData (0, (0x20000000 | (offset)));                                \
    nvPusherAdjust (sizeDmaJump);                                           \
}

//-------------------------------------------------------------------------
//                              NV 002
//                   NV01_CONTEXT_DMA_FROM_MEMORY
//-------------------------------------------------------------------------

#define sizeSetDmaFromMemoryMthdCnt                 3
#define sizeSetDmaFromMemory                        4
#define nvglSetDmaFromMemory(ch, base, selector, limit)                     \
{                                                                           \
    nvPushData (0, (((sizeSetDmaFromMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300)); \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (limit));                                                \
    nvPusherAdjust (sizeSetDmaFromMemory);                                  \
}

#define sizeSetDmaFromMemoryContextNotifyMthdCnt    1
#define sizeSetDmaFromMemoryContextNotify           2
#define nvglSetDmaFromMemoryContextNotify(ch, ctxdmanotify)                 \
{                                                                           \
    nvPushData (0, (((sizeSetDmaFromMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetDmaFromMemoryContextNotify);                     \
}

#define sizeSetDmaFromMemoryNotify                  7
#define nvglSetDmaFromMemoryNotify(ch, base, selector, limit, notify)       \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | 0x300));              \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (((1 << 2) << 16) | ((ch) << 13) | 0x104));              \
    nvPushData (4, (notify));                                               \
    nvPushData (5, (((1 << 2) << 16) | ((ch) << 13) | 0x308));              \
    nvPushData (6, (limit));                                                \
    nvPusherAdjust (sizeSetDmaFromMemoryNotify);                            \
}

//-------------------------------------------------------------------------
//                              NV 003
//                    NV01_CONTEXT_DMA_TO_MEMORY
//-------------------------------------------------------------------------

#define sizeSetDmaToMemoryMthdCnt                 3
#define sizeSetDmaToMemory                        4
#define nvglSetDmaToMemory(ch, base, selector, limit)                       \
{                                                                           \
    nvPushData (0, (((sizeSetDmaToMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300)); \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (limit));                                                \
    nvPusherAdjust (sizeSetDmaToMemory);                                    \
}

#define sizeSetDmaToMemoryContextNotifyMthdCnt    1
#define sizeSetDmaToMemoryContextNotify           2
#define nvglSetDmaToMemoryContextNotify(ch, ctxdmanotify)                   \
{                                                                           \
    nvPushData (0, (((sizeSetDmaToMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetDmaToMemoryContextNotify);                       \
}

#define sizeSetDmaToMemoryNotify                  7
#define nvglSetDmaToMemoryNotify(ch, base, selector, limit, notify)         \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | 0x300));              \
    nvPushData (1, (base));                                                 \
    nvPushData (2, (selector));                                             \
    nvPushData (3, (((1 << 2) << 16) | ((ch) << 13) | 0x104));              \
    nvPushData (4, (notify));                                               \
    nvPushData (5, (((1 << 2) << 16) | ((ch) << 13) | 0x308));              \
    nvPushData (6, (limit));                                                \
    nvPusherAdjust (sizeSetDmaToMemoryNotify);                              \
}

//-------------------------------------------------------------------------
//                              NV 019
//                    NV01_CONTEXT_CLIP_RECTANGLE
//-------------------------------------------------------------------------

#define sizeSetClipMthdCnt                          2
#define sizeSetClip                                 3
#define nvglSetClip(ch, x, y, w, h)                                         \
{                                                                           \
    nvPushData (0, (((sizeSetClipMthdCnt << 2) << 16) | ((ch) << 13) | NV019_SET_POINT)); \
    nvPushData (1, ((DWORD)y << 16) | (DWORD)x);                            \
    nvPushData (2, ((DWORD)h << 16) | (DWORD)w);                            \
    nvPusherAdjust (sizeSetClip);                                           \
}

//-------------------------------------------------------------------------
//                              NV 042
//                     NV04_CONTEXT_SURFACES_2D
//-------------------------------------------------------------------------

#define sizeSet2DSurfacesNoOpMthdCnt    1
#define sizeSet2DSurfacesNoOp           2
#define nvglSet2DSurfacesNoOp(ch)                                           \
{                                                                           \
    nvPushData (0, (((sizeSet2DSurfacesNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV042_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSet2DSurfacesNoOp);                                 \
}

#define sizeSet2DSurfacesContextsMthdCnt            2
#define sizeSet2DSurfacesContexts                   3
#define nvglSet2DSurfacesContexts(ch, ctxsrc, ctxdest)                      \
{                                                                           \
    nvPushData (0, (((sizeSet2DSurfacesContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_CONTEXT_DMA_IMAGE_SOURCE)); \
    nvPushData (1, (ctxsrc));                                               \
    nvPushData (2, (ctxdest));                                              \
    nvPusherAdjust (sizeSet2DSurfacesContexts);                             \
}

#define sizeSet2DSurfacesColorFormatMthdCnt         1
#define sizeSet2DSurfacesColorFormat                2
#define nvglSet2DSurfacesColorFormat(ch, format)                            \
{                                                                           \
    if (pDriverData->bltData.dwLastColourFormat != format) {                \
        nvPushData (0, (((sizeSet2DSurfacesColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_COLOR_FORMAT)); \
        nvPushData (1, (format));                                           \
        nvPusherAdjust (sizeSet2DSurfacesColorFormat);                      \
        pDriverData->bltData.dwLastColourFormat = format;                   \
    }                                                                       \
}

#define sizeSet2DSurfacesPitchMthdCnt               1
#define sizeSet2DSurfacesPitch                      2
#define nvglSet2DSurfacesPitch(ch, srcpitch, dstpitch)                      \
{                                                                           \
DWORD dwCombinedPitch = ((((dstpitch) & 0x0000FFFF) << 16) | ((srcpitch) & 0x0000FFFF));   \
    if (pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch) {      \
        nvPushData (0, (((sizeSet2DSurfacesPitchMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_PITCH)); \
        nvPushData (1, dwCombinedPitch);                                    \
        nvPusherAdjust (sizeSet2DSurfacesPitch);                            \
        pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;         \
    }                                                                       \
}

#define sizeSet2DSurfacesDestinationMthdCnt         1
#define sizeSet2DSurfacesDestination                2
#define nvglSet2DSurfacesDestination(ch, offset)                            \
{                                                                           \
    if (pDriverData->bltData.dwLastDstOffset != offset) {                   \
        nvPushData (0, (((sizeSet2DSurfacesDestinationMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_OFFSET_DESTIN)); \
        nvPushData (1, (offset));                                           \
        nvPusherAdjust (sizeSet2DSurfacesDestination);                      \
        pDriverData->bltData.dwLastDstOffset = offset;                      \
    }                                                                       \
}

//-------------------------------------------------------------------------
//                              NV 043
//                         NV03_CONTEXT_ROP
//-------------------------------------------------------------------------

#define sizeSetRop5MthdCnt                          1
#define sizeSetRop5                                 2
#define nvglSetRop5(ch, rop5)                                               \
{                                                                           \
    if (pDriverData->bltData.dwLastRop != rop5) {                           \
        nvPushData (0, (((sizeSetRop5MthdCnt << 2) << 16) | ((ch) << 13) | NV043_SET_ROP5)); \
        nvPushData (1, (rop5));                                             \
        nvPusherAdjust (sizeSetRop5);                                       \
        pDriverData->bltData.dwLastRop = rop5;                              \
    }                                                                       \
}

//-------------------------------------------------------------------------
//                              NV 044
//                       NV04_CONTEXT_PATTERN
//-------------------------------------------------------------------------

// 0x00000304
#define sizeSetNv4ContextPatternMonochromeFormatMthdCnt  1
#define sizeSetNv4ContextPatternMonochromeFormat         2
#define nvglSetNv4ContextPatternMonochromeFormat(ch, format)                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHROME_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeFormat);              \
}
// 0x00000308
#define sizeSetNv4ContextPatternMonochromeShapeMthdCnt  1
#define sizeSetNv4ContextPatternMonochromeShape         2
#define nvglSetNv4ContextPatternMonochromeShape(ch, shape)                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeShapeMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHROME_SHAPE)); \
    nvPushData (1, (shape));                                                \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeShape);               \
}
// 0x0000030c
#define sizeSetNv4ContextPatternPatternSelectMthdCnt  1
#define sizeSetNv4ContextPatternPatternSelect         2
#define nvglSetNv4ContextPatternPatternSelect(ch, select)                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternPatternSelectMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_PATTERN_SELECT)); \
    nvPushData (1, (select));                                               \
    nvPusherAdjust (sizeSetNv4ContextPatternPatternSelect);                 \
}
// 0x00000310
#define sizeSetNv4ContextPatternMonochromeColorsMthdCnt  2
#define sizeSetNv4ContextPatternMonochromeColors         3
#define nvglSetNv4ContextPatternMonochromeColors(ch, c0, c1)                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromeColorsMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHORME_COLOR0)); \
    nvPushData (1, (c0));                                                   \
    nvPushData (2, (c1));                                                   \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromeColors);              \
}
// 0x00000318
#define sizeSetNv4ContextPatternMonochromePatternsMthdCnt  2
#define sizeSetNv4ContextPatternMonochromePatterns         3
#define nvglSetNv4ContextPatternMonochromePatterns(ch, pattern0, pattern1)  \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ContextPatternMonochromePatternsMthdCnt << 2) << 16) | ((ch) << 13) | NV044_SET_MONOCHORME_PATTERN0)); \
    nvPushData (1, (pattern0));                                             \
    nvPushData (2, (pattern1));                                             \
    nvPusherAdjust (sizeSetNv4ContextPatternMonochromePatterns);            \
}

//-------------------------------------------------------------------------
//                              NV 04A
//                     NV04_GDI_RECTANGLE_TEXT
//-------------------------------------------------------------------------

//0x00000300
#define sizeDrawRopRectAndTextSetColorFormatMthdCnt 1
#define sizeDrawRopRectAndTextSetColorFormat        2
#define nvglDrawRopRectAndTextSetColorFormat(ch, format)                    \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_COLOR_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeDrawRopRectAndTextSetColorFormat);                  \
}

//0x0000018C
#define sizeDrawRopRectAndTextSetROPMthdCnt 1
#define sizeDrawRopRectAndTextSetROP        2
#define nvglDrawRopRectAndTextSetROP(ch, rop)                               \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetROPMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeDrawRopRectAndTextSetROP);                          \
}

//0x00000188
#define sizeDrawPatternRectAndTextSetPatternMthdCnt 1
#define sizeDrawPatternRectAndTextSetPattern        2
#define nvglDrawPatternRectAndTextSetPattern(ch, pattern)                   \
{                                                                           \
    nvPushData (0, (((sizeDrawPatternRectAndTextSetPatternMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeDrawPatternRectAndTextSetPattern);                  \
}

//0x00000198
#define sizeDrawRopRectAndTextSetSurfaceMthdCnt 1
#define sizeDrawRopRectAndTextSetSurface        2
#define nvglDrawRopRectAndTextSetSurface(ch, surface)                       \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeDrawRopRectAndTextSetSurface);                      \
}

//0x000002FC
#define sizeDrawRopRectAndTextSetOperatioonMthdCnt 1
#define sizeDrawRopRectAndTextSetOperation         2
#define nvglDrawRopRectAndTextSetOperation(ch, operation)                   \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextSetOperatioonMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeDrawRopRectAndTextSetOperation);                    \
}

#define sizeDrawRopRectAndTextColor1AMthdCnt        1
#define sizeDrawRopRectAndTextColor1A               2
#define nvglDrawRopRectAndTextColor1A(ch, color)                            \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextColor1AMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_COLOR1_A)); \
    nvPushData (1, (color));                                                \
    nvPusherAdjust (sizeDrawRopRectAndTextColor1A);                         \
}

#define sizeDrawRopRectAndTextPointSizeMthdCnt      2
#define sizeDrawRopRectAndTextPointSize             3
#define nvglDrawRopRectAndTextPointSize(ch, x, y, width, height)            \
{                                                                           \
    nvPushData (0, (((sizeDrawRopRectAndTextPointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_UNCLIPPED_RECTANGLE_POINT(0))); \
    nvPushData (1, ((((x) & 0x0000FFFF) << 16) | ((y) & 0x0000FFFF)));      \
    nvPushData (2, ((((width) & 0x0000FFFF) << 16) | ((height) & 0x0000FFFF))); \
    nvPusherAdjust (sizeDrawRopRectAndTextPointSize);                       \
}

//-------------------------------------------------------------------------
//                              NV 052
//                   NV04_CONTEXT_SURFACE_SWIZZLED
//-------------------------------------------------------------------------

#define sizeSetSwizzledSurfaceContextImageMthdCnt   1
#define sizeSetSwizzledSurfaceContextImage          2
#define nvglSetSwizzledSurfaceContextImage(ch, ctxdmaimage)                 \
{                                                                           \
    nvPushData (0, (((sizeSetSwizzledSurfaceContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_CONTEXT_DMA_IMAGE)); \
    nvPushData (1, (ctxdmaimage));                                          \
    nvPusherAdjust (sizeSetSwizzledSurfaceContextImage);                    \
}

#define sizeSetSwizzledSurfaceMthdCnt        2
#define sizeSetSwizzledSurface               3
#define nvglSetSwizzledSurface(ch, format, offset)                          \
{                                                                           \
    nvPushData (0, (((sizeSetSwizzledSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPushData (2, (offset));                                               \
    nvPusherAdjust (sizeSetSwizzledSurface);                                \
}

//-------------------------------------------------------------------------
//                              NV 053
//                     NV04_CONTEXT_SURFACES_3D
//-------------------------------------------------------------------------

#define sizeSetRenderTargetContextsMthdCnt  2
#define sizeSetRenderTargetContexts         3
#define nvglSetRenderTargetContexts(ch, ctxdmacolor, ctxdmazeta)            \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTargetContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CONTEXT_DMA_COLOR)); \
    nvPushData (1, (ctxdmacolor));                                          \
    nvPushData (2, (ctxdmazeta));                                           \
    nvPusherAdjust (sizeSetRenderTargetContexts);                           \
}

#define sizeSetRenderTarget                 8
#define nvglSetRenderTarget(ch, cliphorizontal, clipvertical, format,       \
                            pitch, coloroffset, zetaoffset)                 \
{                                                                           \
    nvPushData (0, (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL)); \
    nvPushData (1, (cliphorizontal));                                       \
    nvPushData (2, (clipvertical));                                         \
    nvPushData (3, (format));                                               \
    nvPushData (4, (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_PITCH));    \
    nvPushData (5, (pitch));                                                \
    nvPushData (6, (coloroffset));                                          \
    nvPushData (7, (zetaoffset));                                           \
    nvPusherAdjust (sizeSetRenderTarget);                                   \
}

#define sizeSetRenderTarget2MthdCnt         5
#define sizeSetRenderTarget2                6
#define nvglSetRenderTarget2(ch, format, clipsize, pitch,                   \
                             coloroffset, zetaoffset)                       \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTarget2MthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPushData (2, (clipsize));                                             \
    nvPushData (3, (pitch));                                                \
    nvPushData (4, (coloroffset));                                          \
    nvPushData (5, (zetaoffset));                                           \
    nvPusherAdjust (sizeSetRenderTarget2);                                  \
}

#define sizeSetRenderTargetViewportMthdCnt  2
#define sizeSetRenderTargetViewport         3
#define nvglSetRenderTargetViewport(ch, cliphorizontal, clipvertical)       \
{                                                                           \
    nvPushData (0, (((sizeSetRenderTargetViewportMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL)); \
    nvPushData (1, (cliphorizontal));                                       \
    nvPushData (2, (clipvertical));                                         \
    nvPusherAdjust (sizeSetRenderTargetViewport);                           \
}

//-------------------------------------------------------------------------
//                              NV 054
//                     NV04_DX5_TEXTURED_TRIANGLE
//-------------------------------------------------------------------------

#define sizeSetDx5TriangleContextsMthdCnt   2
#define sizeSetDx5TriangleContexts          3
#define nvglSetDx5TriangleContexts(ch, ctxa, ctxb)                          \
{                                                                           \
    nvPushData (0, (((sizeSetDx5TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (ctxa));                                                 \
    nvPushData (2, (ctxb));                                                 \
    nvPusherAdjust (sizeSetDx5TriangleContexts);                            \
}

#define sizeSetDx5TriangleSurfaceMthdCnt    1
#define sizeSetDx5TriangleSurface           2
#define nvglSetDx5TriangleSurface(ch, ctxs)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetDx5TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (ctxs));                                                 \
    nvPusherAdjust (sizeSetDx5TriangleSurface);                             \
}

#define sizeDx5TriangleStateMthdCnt         7
#define sizeDx5TriangleState                8
#define nvglDx5TriangleState(ch, ckey, offset, format, filter,              \
                             blend, control, fogcolor)                      \
{                                                                           \
    nvPushData (0, (((sizeDx5TriangleStateMthdCnt << 2) << 16) | ((ch) << 13) | NV054_COLOR_KEY)); \
    nvPushData (1, (ckey));                                                 \
    nvPushData (2, (offset));                                               \
    nvPushData (3, (format));                                               \
    nvPushData (4, (filter));                                               \
    nvPushData (5, (blend));                                                \
    nvPushData (6, (control));                                              \
    nvPushData (7, (fogcolor));                                             \
    nvPusherAdjust (sizeDx5TriangleState);                                  \
}

#define sizeDx5TriangleDrawPrimitiveMthdCnt 1
#define sizeDx5TriangleDrawPrimitive        2
#define nvglDx5TriangleDrawPrimitive(ch, alias, vertices)                   \
{                                                                           \
    nvPushData (0, (((sizeDx5TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV054_DRAW_PRIMITIVE((alias)))); \
    nvPushData (1, (vertices));                                             \
    nvPusherAdjust (sizeDx5TriangleDrawPrimitive);                          \
}

#define sizeDx5TriangleNotify               4
#define nvglDx5TriangleNotify(ch)                                           \
{                                                                           \
    nvPushData (0, (((1 << 2) << 16) | ((ch) << 13) | NV054_NOTIFY));       \
    nvPushData (1, NV054_NOTIFY_WRITE_ONLY);                                \
    nvPushData (2, (((1 << 2) << 16) | ((ch) << 13) | NV054_NO_OPERATION)); \
    nvPushData (3, 0x00000000);                                             \
    nvPusherAdjust (sizeDx5TriangleNotify);                                 \
}

//-------------------------------------------------------------------------
//                              NV 055
//                   NV04_DX6_MULTI_TEXTURE_TRIANGLE
//-------------------------------------------------------------------------

#define sizeSetDx6TriangleContextsMthdCnt   2
#define sizeSetDx6TriangleContexts          3
#define nvglSetDx6TriangleContexts(ch, ctxa, ctxb)                          \
{                                                                           \
    nvPushData (0, (((sizeSetDx6TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (ctxa));                                                 \
    nvPushData (2, (ctxb));                                                 \
    nvPusherAdjust (sizeSetDx6TriangleContexts);                            \
}

#define sizeSetDx6TriangleSurfaceMthdCnt    1
#define sizeSetDx6TriangleSurface           2
#define nvglSetDx6TriangleSurface(ch, ctxs)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetDx6TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (ctxs));                                                 \
    nvPusherAdjust (sizeSetDx6TriangleSurface);                             \
}

#define sizeDx6TriangleOffsetMthdCnt        1
#define sizeDx6TriangleOffset               2
#define nvglDx6TriangleOffset(ch, offset, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV055_OFFSET(buffer))); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeDx6TriangleOffset);                                 \
}

#define sizeDx6TriangleFormatMthdCnt        1
#define sizeDx6TriangleFormat               2
#define nvglDx6TriangleFormat(ch, format, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FORMAT(buffer))); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeDx6TriangleFormat);                                 \
}

#define sizeDx6TriangleFilterMthdCnt        1
#define sizeDx6TriangleFilter               2
#define nvglDx6TriangleFilter(ch, filter, buffer)                           \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleFilterMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FILTER(buffer))); \
    nvPushData (1, (filter));                                               \
    nvPusherAdjust (sizeDx6TriangleFilter);                                 \
}

#define sizeDx6TriangleStageState           12
#define nvglDx6TriangleStageState(ch, c0alpha, c0color, c1alpha, c1color,   \
                                  factor, blend,                            \
                                  control0, control1, control2,             \
                                  fogcolor)                                 \
{                                                                           \
    nvPushData (0, (((2 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_0_ALPHA)); \
    nvPushData (1, (c0alpha));                                              \
    nvPushData (2, (c0color));                                              \
    nvPushData (3, (((8 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_1_ALPHA)); \
    nvPushData (4, (c1alpha));                                              \
    nvPushData (5, (c1color));                                              \
    nvPushData (6, (factor));                                               \
    nvPushData (7, (blend));                                                \
    nvPushData (8, (control0));                                             \
    nvPushData (9, (control1));                                             \
    nvPushData (10, (control2));                                            \
    nvPushData (11, (fogcolor));                                            \
    nvPusherAdjust (sizeDx6TriangleStageState);                             \
}

#define sizeDX6TriangleState    (((sizeDx6TriangleOffset + sizeDx6TriangleFormat + sizeDx6TriangleFilter) * 2) + sizeDx6TriangleStageState)

#define sizeDx6TriangleTLVertexMthdCnt      10
#define sizeDx6TriangleTLVertex1            11
#define nvglDx6TriangleTLVertex(ch, alias, vd)                              \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV055_TLMTVERTEX((alias)))); \
    nvPushData (1, *(U032 *)&(vd.sx));                                      \
    nvPushData (2, *(U032 *)&(vd.sy));                                      \
    nvPushData (3, *(U032 *)&(vd.sz));                                      \
    nvPushData (4, *(U032 *)&(vd.rhw));                                     \
    nvPushData (5, (vd.color));                                             \
    nvPushData (6, (vd.specular));                                          \
    nvPushData (7, *(U032 *)&(vd.tu));                                      \
    nvPushData (8, *(U032 *)&(vd.tv));                                      \
    nvPushData (9, 0);                                                      \
    nvPushData (10, 0);                                                     \
    nvPusherAdjust (sizeDx6TriangleTLVertex1);                              \
    dbgDisplayVertexData(FALSE, (DWORD *)&(vd.sx));                         \
}

#define sizeDx6TriangleDrawPrimitiveMthdCnt 1
#define sizeDx6TriangleDrawPrimitive        2
#define nvglDx6TriangleDrawPrimitive(ch, alias, vertices)                   \
{                                                                           \
    nvPushData (0, (((sizeDx6TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV055_DRAW_PRIMITIVE((alias)))); \
    nvPushData (1, (vertices));                                             \
    nvPusherAdjust (sizeDx6TriangleDrawPrimitive);                          \
}

//-------------------------------------------------------------------------
//                              NV 056
//                      NV10_CELSIUS_PRIMITIVE
//-------------------------------------------------------------------------
#if (NVARCH >= 0x010)
#define NV056_SET_VERTEX_FORMAT_SHADOW      NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15)

// 0x00000100
#define sizeSetNv10CelsiusNoOpMthdCnt    1
#define sizeSetNv10CelsiusNoOp           2
#define nvglSetNv10CelsiusNoOp(ch)                                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV056_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv10CelsiusNoOp);                                \
}
// 0x00000104
#define sizeSetNv10CelsiusNotifyMthdCnt    1
#define sizeSetNv10CelsiusNotify           2
#define nvglSetNv10CelsiusNotify(ch, type)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNotifyMthdCnt << 2) << 16) | ((ch) << 13) | NV056_NOTIFY)); \
    nvPushData (1, (type));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusNotify);                              \
}
// 0x00000180
#define sizeSetNv10CelsiusContextDMAsMthdCnt    7
#define sizeSetNv10CelsiusContextDMAs           8
#define nvglSetNv10CelsiusContextDMAs(ch, notifies, dmaa, dmab, vertex, state, color, zeta) \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPushData (2, (dmaa));                                                 \
    nvPushData (3, (dmab));                                                 \
    nvPushData (4, (vertex));                                               \
    nvPushData (5, (state));                                                \
    nvPushData (6, (color));                                                \
    nvPushData (7, (zeta));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusContextDMAs);                         \
}
// 0x00000180
#define sizeSetNv10CelsiusNotifierContextDMAMthdCnt    1
#define sizeSetNv10CelsiusNotifierContextDMA           2
#define nvglSetNv10CelsiusNotifierContextDMA(ch, notifies)                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusNotifierContextDMAMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPusherAdjust (sizeSetNv10CelsiusNotifierContextDMA);                  \
}
// 0x00000184
#define sizeSetNv10CelsiusTextureAndVertexContextDMAsMthdCnt    3
#define sizeSetNv10CelsiusTextureAndVertexContextDMAs           4
#define nvglSetNv10CelsiusTextureAndVertexContextDMAs(ch, dmaa, dmab, vertex) \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusTextureAndVertexContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (dmaa));                                                 \
    nvPushData (2, (dmab));                                                 \
    nvPushData (3, (vertex));                                               \
    nvPusherAdjust (sizeSetNv10CelsiusTextureAndVertexContextDMAs);         \
}
// 0x0000072c
#define sizeSetNv10CelsiusEyeDirectionMthdCnt                   3
#define sizeSetNv10CelsiusEyeDirection                          4
#define nvglSetNv10CelsiusEyeDirection(ch, x, y, z)                         \
{                                                                           \
    float x1 = x, y1 = y, z1 = z;                                           \
    nvPushData (0, (((sizeSetNv10CelsiusEyeDirectionMthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_EYE_DIRECTION_SW(0))); \
    nvPushData (1, *(DWORD*)&x1);                                           \
    nvPushData (2, *(DWORD*)&y1);                                           \
    nvPushData (3, *(DWORD*)&z1);                                           \
    nvPusherAdjust (sizeSetNv10CelsiusEyeDirection);                        \
}
// 0x00000cf0
#define sizeSetNv10CelsiusInvalidateVertexCacheMthdCnt    1
#define sizeSetNv10CelsiusInvalidateVertexCache           2
#define nvglSetNv10CelsiusInvalidateVertexCache(ch)                         \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusInvalidateVertexCacheMthdCnt << 2) << 16) | ((ch) << 13) | NV056_INVALIDATE_VERTEX_CACHE_FILE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv10CelsiusInvalidateVertexCache);               \
}
// 0x000010fc
#define sizeSetNv10CelsiusBeginEnd2MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd2           2
#define nvglSetNv10CelsiusBeginEnd2(ch, op)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd2MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END2)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd2);                            \
}
// 0x000013fc
#define sizeSetNv10CelsiusBeginEnd3MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd3           2
#define nvglSetNv10CelsiusBeginEnd3(ch, op)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd3MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END3)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd3);                           \
}
// 0x000017fc
#define sizeSetNv10CelsiusBeginEnd4MthdCnt    1
#define sizeSetNv10CelsiusBeginEnd4           2
#define nvglSetNv10CelsiusBeginEnd4(ch, op)                                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusBeginEnd4MthdCnt << 2) << 16) | ((ch) << 13) | NV056_SET_BEGIN_END4)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv10CelsiusBeginEnd4);                           \
}
// 0x00001400
#define sizeSetNv10CelsiusDrawArraysMthdCnt    1
#define sizeSetNv10CelsiusDrawArrays           2
#define nvglSetNv10CelsiusDrawArrays(ch, data)                              \
{                                                                           \
    nvPushData (0, (((sizeSetNv10CelsiusDrawArraysMthdCnt << 2) << 16) | ((ch) << 13) | NV056_DRAW_ARRAYS(0))); \
    nvPushData (1, (data));                                                 \
    nvPusherAdjust (sizeSetNv10CelsiusDrawArrays);                          \
}
#endif  // NVARCH >= 0x010

//-------------------------------------------------------------------------
//                              NV 097
//                       NV20_KELVIN_PRIMITIVE
//-------------------------------------------------------------------------
#if (NVARCH >= 0x020)
// 0x00000100
#define sizeSetNv20KelvinNoOpMthdCnt    1
#define sizeSetNv20KelvinNoOp           2
#define nvglSetNv20KelvinNoOp(ch)                                           \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV097_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv20KelvinNoOp);                                 \
}
// 0x00000104
#define sizeSetNv20KelvinNotifyMthdCnt    1
#define sizeSetNv20KelvinNotify           2
#define nvglSetNv20KelvinNotify(ch, type)                                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNotifyMthdCnt << 2) << 16) | ((ch) << 13) | NV097_NOTIFY)); \
    nvPushData (1, (type));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinNotify);                               \
}
// 0x00000180
#define sizeSetNv20KelvinNotifierContextDMAMthdCnt    1
#define sizeSetNv20KelvinNotifierContextDMA           2
#define nvglSetNv20KelvinNotifierContextDMA(ch, notifies)                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinNotifierContextDMAMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPusherAdjust (sizeSetNv20KelvinNotifierContextDMA);                   \
}
// 0x00000180
#define sizeSetNv20KelvinContextDMAsMthdCnt1    3
#define sizeSetNv20KelvinContextDMAs1           4
#define sizeSetNv20KelvinContextDMAsMthdCnt2    7
#define sizeSetNv20KelvinContextDMAs2           8
#define nvglSetNv20KelvinContextDMAs(ch, notifies, dmaa, dmab, state, color, zeta, vertexa, vertexb, semaphore, report) \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinContextDMAsMthdCnt1 << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (notifies));                                             \
    nvPushData (2, (dmaa));                                                 \
    nvPushData (3, (dmab));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinContextDMAs1);                         \
    nvPushData (0, (((sizeSetNv20KelvinContextDMAsMthdCnt2 << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_STATE)); \
    nvPushData (1, (state));                                                \
    nvPushData (2, (color));                                                \
    nvPushData (3, (zeta));                                                 \
    nvPushData (4, (vertexa));                                              \
    nvPushData (5, (vertexb));                                              \
    nvPushData (6, (semaphore));                                            \
    nvPushData (7, (report));                                               \
    nvPusherAdjust (sizeSetNv20KelvinContextDMAs2);                         \
}
// 0x00000184
#define sizeSetNv20KelvinTextureContextDMAsMthdCnt    2
#define sizeSetNv20KelvinTextureContextDMAs           3
#define nvglSetNv20KelvinTextureContextDMAs(ch, dmaa, dmab)                 \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinTextureContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_A)); \
    nvPushData (1, (dmaa));                                                 \
    nvPushData (2, (dmab));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinTextureContextDMAs);                   \
}
// 0x0000019c
#define sizeSetNv20KelvinVertexContextDMAsMthdCnt    2
#define sizeSetNv20KelvinVertexContextDMAs           3
#define nvglSetNv20KelvinVertexContextDMAs(ch, vertexa, vertexb)            \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinVertexContextDMAsMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_CONTEXT_DMA_VERTEX_A)); \
    nvPushData (1, (vertexa));                                              \
    nvPushData (2, (vertexb));                                              \
    nvPusherAdjust (sizeSetNv20KelvinVertexContextDMAs);                    \
}
// 0x00001710
#define sizeSetNv20KelvinInvalidateVertexCacheMthdCnt    1
#define sizeSetNv20KelvinInvalidateVertexCache           2
#define nvglSetNv20KelvinInvalidateVertexCache(ch)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinInvalidateVertexCacheMthdCnt << 2) << 16) | ((ch) << 13) | NV097_INVALIDATE_VERTEX_CACHE_FILE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv20KelvinInvalidateVertexCache);                \
}
// 0x000017fc
#define sizeSetNv20KelvinBeginEndMthdCnt    1
#define sizeSetNv20KelvinBeginEnd           2
#define nvglSetNv20KelvinBeginEnd(ch, op)                                   \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((ch) << 13) | NV097_SET_BEGIN_END)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv20KelvinBeginEnd);                             \
}
// 0x00001810
#define sizeSetNv20KelvinDrawArraysMthdCnt    1
#define sizeSetNv20KelvinDrawArrays           2
#define nvglSetNv20KelvinDrawArrays(ch, data)                               \
{                                                                           \
    nvPushData (0, (((sizeSetNv20KelvinDrawArraysMthdCnt << 2) << 16) | ((ch) << 13) | NONINC_METHOD(NV097_DRAW_ARRAYS))); \
    nvPushData (1, (data));                                                 \
    nvPusherAdjust (sizeSetNv20KelvinDrawArrays);                           \
}

#endif // (NVARCH >= 0x020)

//-------------------------------------------------------------------------
//                              NV 05E
//                    NV04_RENDER_SOLID_RECTANGLE
//-------------------------------------------------------------------------

// 0x00000100
#define sizeSetNv4SolidRectangleNoOpMthdCnt    1
#define sizeSetNv4SolidRectangleNoOp           2
#define nvglSetNv4SolidRectangleNoOp(ch)                                    \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleNoOpMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_NO_OPERATION)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv4SolidRectangleNoOp);                          \
}
// 0x00000184
#define sizeSetNv4SolidRectangleClipRectangleMthdCnt  1
#define sizeSetNv4SolidRectangleClipRectangle         2
#define nvglSetNv4SolidRectangleClipRectangle(ch, rect)                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleClipRectangleMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_CLIP_RECTANGLE)); \
    nvPushData (1, (rect));                                                 \
    nvPusherAdjust (sizeSetNv4SolidRectangleClipRectangle);                 \
}
// 0x00000188
#define sizeSetNv4SolidRectanglePatternMthdCnt  1
#define sizeSetNv4SolidRectanglePattern         2
#define nvglSetNv4SolidRectanglePattern(ch, pattern)                        \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectanglePatternMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeSetNv4SolidRectanglePattern);                       \
}
// 0x0000018c
#define sizeSetNv4SolidRectangleRopMthdCnt  1
#define sizeSetNv4SolidRectangleRop         2
#define nvglSetNv4SolidRectangleRop(ch, rop)                                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleRopMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeSetNv4SolidRectangleRop);                           \
}
// 0x00000198
#define sizeSetNv4SolidRectangleSurfaceMthdCnt  1
#define sizeSetNv4SolidRectangleSurface         2
#define nvglSetNv4SolidRectangleSurface(ch, surface)                        \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetNv4SolidRectangleSurface);                       \
}
// 0x000002fc
#define sizeSetNv4SolidRectangleOperationMthdCnt    1
#define sizeSetNv4SolidRectangleOperation           2
#define nvglSetNv4SolidRectangleOperation(ch, op)                           \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_OPERATION)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv4SolidRectangleOperation);                     \
}
// 0x00000300
#define sizeSetNv4SolidRectangleColorFormatMthdCnt  1
#define sizeSetNv4SolidRectangleColorFormat         2
#define nvglSetNv4SolidRectangleColorFormat(ch, cfmt)                       \
{                                                                           \
    nvPushData (0, (((sizeSetNv4SolidRectangleColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_COLOR_FORMAT)); \
    nvPushData (1, (cfmt));                                                 \
    nvPusherAdjust (sizeSetNv4SolidRectangleColorFormat);                   \
}
// 0x00000304
#define sizeNv4SolidRectangleColorMthdCnt           1
#define sizeNv4SolidRectangleColor                  2
#define nvglNv4SolidRectangleColor(ch, color)                               \
{                                                                           \
    nvPushData (0, (((sizeNv4SolidRectangleColorMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_COLOR)); \
    nvPushData (1, (color));                                                \
    nvPusherAdjust (sizeNv4SolidRectangleColor);                            \
}
// 0x00000400
#define sizeNv4SolidRectanglePointSizeMthdCnt       2
#define sizeNv4SolidRectanglePointSize              3
#define nvglNv4SolidRectanglePointSize(ch, x, y, width, height)             \
{                                                                           \
    nvPushData (0, (((sizeNv4SolidRectanglePointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_RECTANGLE(0))); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeNv4SolidRectanglePointSize);                        \
}

//-------------------------------------------------------------------------
//                              NV 05F
//                         NV04_IMAGE_BLIT
//-------------------------------------------------------------------------

// 0x00000188
#define sizeSetNv4ImageBlitClipRectangleMthdCnt     1
#define sizeSetNv4ImageBlitClipRectangle            2
#define nvglSetNv4ImageBlitClipRectangle(ch, rect)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitClipRectangleMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_CLIP_RECTANGLE)); \
    nvPushData (1, (rect));                                                 \
    nvPusherAdjust (sizeSetNv4ImageBlitClipRectangle);                      \
}
// 0x0000018c
#define sizeSetNv4ImageBlitContextPatternMthdCnt     1
#define sizeSetNv4ImageBlitContextPattern            2
#define nvglSetNv4ImageBlitContextPattern(ch, pattern)                      \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextPatternMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_PATTERN)); \
    nvPushData (1, (pattern));                                              \
    nvPusherAdjust (sizeSetNv4ImageBlitContextPattern);                     \
}
// 0x00000190
#define sizeSetNv4ImageBlitContextRopMthdCnt     1
#define sizeSetNv4ImageBlitContextRop            2
#define nvglSetNv4ImageBlitContextRop(ch, rop)                              \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextRopMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_ROP)); \
    nvPushData (1, (rop));                                                  \
    nvPusherAdjust (sizeSetNv4ImageBlitContextRop);                         \
}
// 0x0000019c
#define sizeSetNv4ImageBlitContextSurfacesMthdCnt     1
#define sizeSetNv4ImageBlitContextSurfaces            2
#define nvglSetNv4ImageBlitContextSurfaces(ch, surface)                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitContextSurfacesMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_CONTEXT_SURFACES)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetNv4ImageBlitContextSurfaces);                    \
}
// 0x000002fc
#define sizeSetNv4ImageBlitOperationMthdCnt     1
#define sizeSetNv4ImageBlitOperation            2
#define nvglSetNv4ImageBlitOperation(ch, op)                                \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SET_OPERATION)); \
    nvPushData (1, (op));                                                   \
    nvPusherAdjust (sizeSetNv4ImageBlitOperation);                          \
}
// 0x00000300
#define sizeSetNv4ImageBlitControlPointsMthdCnt     2
#define sizeSetNv4ImageBlitControlPoints            3
#define nvglSetNv4ImageBlitControlPoints(ch, xin, yin, xout, yout)          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitControlPointsMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_CONTROL_POINT_IN)); \
    nvPushData (1, (((xin)  & 0xffff) | ((yin)  << 16)));                   \
    nvPushData (2, (((xout) & 0xffff) | ((yout) << 16)));                   \
    nvPusherAdjust (sizeSetNv4ImageBlitControlPoints);                      \
}
// 0x00000308
#define sizeSetNv4ImageBlitSizeMthdCnt     1
#define sizeSetNv4ImageBlitSize            2
#define nvglSetNv4ImageBlitSize(ch, width, height)                          \
{                                                                           \
    nvPushData (0, (((sizeSetNv4ImageBlitSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05F_SIZE)); \
    nvPushData (1, (((width)  & 0xffff) | ((height)  << 16)));              \
    nvPusherAdjust (sizeSetNv4ImageBlitSize);                               \
}

//-------------------------------------------------------------------------
//                              NV 060
//                    NV04_INDEXED_IMAGE_FROM_CPU
//-------------------------------------------------------------------------

#define sizeSetIndexedImageDmaNotifiesMthdCnt           1
#define sizeSetIndexedImageDmaNotifies                  2
#define nvglSetIndexedImageDmaNotifies(ch, ctxdmanotify)                    \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageDmaNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetIndexedImageDmaNotifies);                        \
}

#define sizeSetIndexedImageContextDmaLUTMthdCnt           1
#define sizeSetIndexedImageContextDmaLUT                  2
#define nvglSetIndexedImageContextDmaLUT(ch, handle)                        \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageContextDmaLUTMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_LUT)); \
    nvPushData (1, (handle));                                               \
    nvPusherAdjust (sizeSetIndexedImageContextDmaLUT);                      \
}

#define sizeSetIndexedImageContextSurfaceMthdCnt        1
#define sizeSetIndexedImageContextSurface               2
#define nvglSetIndexedImageContextSurface(ch, surface)                      \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (surface));                                              \
    nvPusherAdjust (sizeSetIndexedImageContextSurface);                     \
}

#define sizeSetIndexedImageOperationMthdCnt     1
#define sizeSetIndexedImageOperation            2
#define nvglSetIndexedImageOperation(ch, operation)                         \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeSetIndexedImageOperation);                          \
}

#define sizeSetIndexedImageColorFormatMthdCnt   1
#define sizeSetIndexedImageColorFormat          2
#define nvglSetIndexedImageColorFormat(ch, colorformat)                     \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_COLOR_FORMAT)); \
    nvPushData (1, (colorformat));                                          \
    nvPusherAdjust (sizeSetIndexedImageColorFormat);                        \
}

#define sizeSetIndexedImageIndexFormatMthdCnt   1
#define sizeSetIndexedImageIndexFormat          2
#define nvglSetIndexedImageIndexFormat(ch, indexformat)                     \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageIndexFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_INDEX_FORMAT)); \
    nvPushData (1, (indexformat));                                          \
    nvPusherAdjust (sizeSetIndexedImageIndexFormat);                        \
}

#define sizeSetIndexedImageLUTOffsetMthdCnt     1
#define sizeSetIndexedImageLUTOffset            2
#define nvglSetIndexedImageLUTOffset(ch, offset)                            \
{                                                                           \
    nvPushData (0, (((sizeSetIndexedImageLUTOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV060_LUT_OFFSET)); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeSetIndexedImageLUTOffset);                          \
}

//-------------------------------------------------------------------------
//                              NV 077
//                   NV04_SCALED_IMAGE_FROM_MEMORY
//-------------------------------------------------------------------------

#define sizeSetScaledImageContextNotifiesMthdCnt    1
#define sizeSetScaledImageContextNotifies           2
#define nvglSetScaledImageContextNotifies(ch, ctxdmanotify)                 \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_NOTIFIES)); \
    nvPushData (1, (ctxdmanotify));                                         \
    nvPusherAdjust (sizeSetScaledImageContextNotifies);                     \
}

#define sizeSetScaledImageContextImageMthdCnt       1
#define sizeSetScaledImageContextImage              2
#define nvglSetScaledImageContextImage(ch, ctxdmaimage)                     \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_IMAGE)); \
    nvPushData (1, (ctxdmaimage));                                          \
    nvPusherAdjust (sizeSetScaledImageContextImage);                        \
}

#define sizeSetScaledImageContextSurfaceMthdCnt     1
#define sizeSetScaledImageContextSurface            2
#define nvglSetScaledImageContextSurface(ch, ctxdmasurface)                 \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_SURFACE)); \
    nvPushData (1, (ctxdmasurface));                                        \
    nvPusherAdjust (sizeSetScaledImageContextSurface);                      \
}

#define sizeSetScaledImageFormatMthdCnt             1
#define sizeSetScaledImageFormat                    2
#define nvglSetScaledImageFormat(ch, format)                                \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_COLOR_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeSetScaledImageFormat);                              \
}

#define sizeSetScaledImageOperationMthdCnt          1
#define sizeSetScaledImageOperation                 2
#define nvglSetScaledImageOperation(ch, operation)                          \
{                                                                           \
    nvPushData (0, (((sizeSetScaledImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_OPERATION)); \
    nvPushData (1, (operation));                                            \
    nvPusherAdjust (sizeSetScaledImageOperation);                           \
}

#define sizeScaledImageClipMthdCnt                  2
#define sizeScaledImageClip                         3
#define nvglScaledImageClip(ch, x, y, width, height)                        \
{                                                                           \
    nvPushData (0, (((sizeScaledImageClipMthdCnt << 2) << 16) | ((ch) << 13) | NV077_CLIP_POINT)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageClip);                                   \
}

#define sizeScaledImageOutMthdCnt                   2
#define sizeScaledImageOut                          3
#define nvglScaledImageOut(ch, x, y, width, height)                         \
{                                                                           \
    nvPushData (0, (((sizeScaledImageOutMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_OUT_POINT)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)));      \
    nvPushData (2, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageOut);                                    \
}

#define sizeScaledImageDeltaDuDxDvDyMthdCnt         2
#define sizeScaledImageDeltaDuDxDvDy                3
#define nvglScaledImageDeltaDuDxDvDy(ch, dudx, dvdy)                        \
{                                                                           \
    nvPushData (0, (((sizeScaledImageDeltaDuDxDvDyMthdCnt << 2) << 16) | ((ch) << 13) | NV077_DELTA_DU_DX)); \
    nvPushData (1, (dudx));                                                 \
    nvPushData (2, (dvdy));                                                 \
    nvPusherAdjust (sizeScaledImageDeltaDuDxDvDy);                          \
}

#define sizeScaledImageInSizeMthdCnt                1
#define sizeScaledImageInSize                       2
#define nvglScaledImageInSize(ch, width, height)                            \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_SIZE)); \
    nvPushData (1, ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageInSize);                                 \
}

#define sizeScaledImageInFormatMthdCnt              1
#define sizeScaledImageInFormat                     2
#define nvglScaledImageInFormat(ch, format)                                 \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_FORMAT)); \
    nvPushData (1, (format));                                               \
    nvPusherAdjust (sizeScaledImageInFormat);                               \
}

#define sizeScaledImageInOffsetMthdCnt              1
#define sizeScaledImageInOffset                     2
#define nvglScaledImageInOffset(ch, offset)                                 \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_OFFSET)); \
    nvPushData (1, (offset));                                               \
    nvPusherAdjust (sizeScaledImageInOffset);                               \
}

#define sizeScaledImageInPointMthdCnt               1
#define sizeScaledImageInPoint                      2
#define nvglScaledImageInPoint(ch, x, y)                                    \
{                                                                           \
    nvPushData (0, (((sizeScaledImageInPointMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN)); \
    nvPushData (1, ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF))); \
    nvPusherAdjust (sizeScaledImageInPoint); \
}

#define sizeScaledImageNotify                       4
#define nvglScaledImageNotify(ch)                                           \
{                                                                           \
    nvPushData (0, (((1 << 2) << 16) | ((ch) << 13) | NV077_NOTIFY));       \
    nvPushData (1, NV077_NOTIFY_WRITE_ONLY);                                \
    nvPushData (2, (((1 << 2) << 16) | ((ch) << 13) | NV077_NO_OPERATION)); \
    nvPushData (3, 0);                                                      \
    nvPusherAdjust (sizeScaledImageNotify);                                 \
}

//-------------------------------------------------------------------------
//                              NV 07C
//                     NV15_VIDEO_LUT_CURSOR_DAC
//-------------------------------------------------------------------------

// 0x00000300
#define sizeSetNv15VideoLUTCursorDACImageDataMthdCnt   2
#define sizeSetNv15VideoLUTCursorDACImageData          3
#define nvglSetNv15VideoLUTCursorDACImageData(ch, index, offset, format)    \
{                                                                           \
    nvPushData (0, (((sizeSetNv15VideoLUTCursorDACImageDataMthdCnt << 2) << 16) | ((ch) << 13) | NV07C_SET_IMAGE_OFFSET(index))); \
    nvPushData (1, offset);                                                 \
    nvPushData (2, format);                                                 \
    nvPusherAdjust (sizeSetNv15VideoLUTCursorDACImageData);                 \
}

//-------------------------------------------------------------------------
//                              NV 096
//                      NV15_CELSIUS_PRIMITIVE
//-------------------------------------------------------------------------

// 0x00000120
#define sizeSetNv15CelsiusSyncSetRWMMthdCnt        3
#define sizeSetNv15CelsiusSyncSetRWM               4
#define nvglSetNv15CelsiusSyncSetRWM(ch, read, write, modulo)               \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncSetRWMMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_SET_READ)); \
    nvPushData (1, (read));                                                 \
    nvPushData (2, (write));                                                \
    nvPushData (3, (modulo));                                               \
    nvPusherAdjust (sizeSetNv15CelsiusSyncSetRWM);                          \
}
// 0x0000012c
#define sizeSetNv15CelsiusSyncIncWriteMthdCnt      1
#define sizeSetNv15CelsiusSyncIncWrite             2
#define nvglSetNv15CelsiusSyncIncWrite(ch)                                  \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncIncWriteMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_INCREMENT_WRITE)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv15CelsiusSyncIncWrite);                        \
}
// 0x00000130
#define sizeSetNv15CelsiusSyncStallMthdCnt         1
#define sizeSetNv15CelsiusSyncStall                2
#define nvglSetNv15CelsiusSyncStall(ch)                                     \
{                                                                           \
    nvPushData (0, (((sizeSetNv15CelsiusSyncStallMthdCnt << 2) << 16) | ((ch) << 13) | NV096_SYNC_STALL)); \
    nvPushData (1, 0);                                                      \
    nvPusherAdjust (sizeSetNv15CelsiusSyncStall);                           \
}

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NV4DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvFile.h ===
//======================================================================
// Module:		nvFile.cpp
// Description:	Generic file routines that are neutral to the calling OS
// 
//  Copyright (C) 2000 NVidia Corporation.  All Rights Reserved.
//======================================================================

#ifndef NVFILE_H
#define NVFILE_H

#include <nvprecomp.h>

bool NvReadFile(HANDLE hFile,                // handle to file
                LPVOID lpBuffer,             // data buffer
                DWORD nNumberOfBytesToRead,  // number of bytes to read
                LPDWORD lpNumberOfBytesRead, // number of bytes read
                LPOVERLAPPED lpOverlapped    // overlapped buffer
                );

bool NvWriteFile( HANDLE hFile,                    // handle to file
                LPCVOID lpBuffer,                // data buffer
                DWORD nNumberOfBytesToWrite,     // number of bytes to write
                LPDWORD lpNumberOfBytesWritten,  // number of bytes written
                LPOVERLAPPED lpOverlapped        // overlapped buffer
                );

bool NvCloseHandle(HANDLE h);

HANDLE NvCreateFile(LPCTSTR lpFileName,                         // file name
                   DWORD dwDesiredAccess,                      // access mode
                   DWORD dwShareMode,                          // share mode
                   LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
                   DWORD dwCreationDisposition,                // how to create
                   DWORD dwFlagsAndAttributes,                 // file attributes
                   HANDLE hTemplateFile                        // handle to template file
                   );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvEscDef.h ===
/*
 * nvEscDef.h
 *
 * Provides definitions for nVidia ExtEscape calls into display driver.
 *
 * Copyright (c) 1998, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#ifndef NV_ESC_DEF_INCLUDED
#define NV_ESC_DEF_INCLUDED


////////////////////////////////////////////////////////////////////////
// nVidia private escapes

#ifdef UNIX
#define NV_ESC_RM_BASE                  0x0000
#else
#define NV_ESC_RM_BASE                  0x7000
#endif

#define NV_ESC_RM_OPEN                  (NV_ESC_RM_BASE + 0x20)
#define NV_ESC_RM_CLOSE                 (NV_ESC_RM_BASE + 0x21)
#define NV_ESC_RM_ALLOC_ROOT            (NV_ESC_RM_BASE + 0x22)
#define NV_ESC_RM_ALLOC_DEVICE          (NV_ESC_RM_BASE + 0x23)
#define NV_ESC_RM_ALLOC_CONTEXT_DMA     (NV_ESC_RM_BASE + 0x24)
#define NV_ESC_RM_ALLOC_CHANNEL_PIO     (NV_ESC_RM_BASE + 0x25)
#define NV_ESC_RM_ALLOC_CHANNEL_DMA     (NV_ESC_RM_BASE + 0x26)
#define NV_ESC_RM_ALLOC_MEMORY          (NV_ESC_RM_BASE + 0x27)
#define NV_ESC_RM_ALLOC_OBJECT          (NV_ESC_RM_BASE + 0x28)
#define NV_ESC_RM_FREE                  (NV_ESC_RM_BASE + 0x29)
#define NV_ESC_RM_DMA_PUSH_INFO         (NV_ESC_RM_BASE + 0x2A)
#define NV_ESC_RM_ALLOC                 (NV_ESC_RM_BASE + 0x2B)
#define NV_ESC_RM_CONFIG_VERSION        (NV_ESC_RM_BASE + 0x31)
#define NV_ESC_RM_CONFIG_GET            (NV_ESC_RM_BASE + 0x32)
#define NV_ESC_RM_CONFIG_SET            (NV_ESC_RM_BASE + 0x33)
#define NV_ESC_RM_CONFIG_UPDATE         (NV_ESC_RM_BASE + 0x34)
#define NV_ESC_RM_ARCH_HEAP             (NV_ESC_RM_BASE + 0x35)
#define NV_ESC_RM_DEBUG_CONTROL         (NV_ESC_RM_BASE + 0x36)
#define NV_ESC_RM_CONFIG_GET_EX         (NV_ESC_RM_BASE + 0x37)
#define NV_ESC_RM_CONFIG_SET_EX         (NV_ESC_RM_BASE + 0x38)
#define NV_ESC_RM_I2C_ACCESS            (NV_ESC_RM_BASE + 0x39)
#define NV_ESC_RM_POWER_MANAGEMENT      (NV_ESC_RM_BASE + 0x3A)
#define NV_ESC_RM_INTERRUPT             (NV_ESC_RM_BASE + 0x3B)
#define NV_ESC_RM_OS_CONFIG_GET         (NV_ESC_RM_BASE + 0x3C)
#define NV_ESC_RM_OS_CONFIG_SET         (NV_ESC_RM_BASE + 0x3D)
#define NV_ESC_RM_OS_CONFIG_GET_EX      (NV_ESC_RM_BASE + 0x3E)
#define NV_ESC_RM_OS_CONFIG_SET_EX      (NV_ESC_RM_BASE + 0x3F)
#define NV_ESC_RM_NVWATCH               (NV_ESC_RM_BASE + 0x40)

#ifdef UNIX
#define NV_ESC_RM_ALLOC_EVENT           (NV_ESC_RM_BASE + 0x44)
#define NV_ESC_RM_AGP_INIT              (NV_ESC_RM_BASE + 0x45)
#define NV_ESC_RM_AGP_TEARDOWN          (NV_ESC_RM_BASE + 0x46)
#define NV_ESC_RM_IO_FLUSH              (NV_ESC_RM_BASE + 0x47)
#endif

////////////////////////////////////////////////////////////////////////
// Nvidia OpenGL client information.

//
// NOTE: WNDOBJ_SETUP and ESC_NV_OPENGL_CREATE_DRAWABLE perform
// the same function except that the I/O manager in NT responds
// to WNDOBJ_SETUP by calling our DrvClipChanged during the actual
// escape call.  This doesn't happen with ESC_NV_OPENGL_CREATE_DRAWABLE
// so the shared clip list area isn't initialized properly.
//
#define WNDOBJ_SETUP                            4354

#define ESC_NV_OPENGL_DMA_PUSH_GO               0x7001

#define ESC_NV_OPENGL_ESCAPE                    0x7101 // nVidia OpenGL escape
//#define ESC_NV_OPENGL_CREATE_DRAWABLE           0x0001 // create drawable client information
#define ESC_NV_OPENGL_DESTROY_DRAWABLE          0x0002 // destroy drawable client information
#define ESC_NV_OPENGL_CREATE_CONTEXT            0x0003 // create context client information
#define ESC_NV_OPENGL_DESTROY_CONTEXT           0x0004 // destroy context client information
#define ESC_NV_OPENGL_DMA_PUSH_GO_CMD           0x0005 // NV3 DMA push go command
#define ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY     0x0006 // memory to screen copy
#define ESC_NV_OPENGL_SCREEN_TO_SCREEN_SRCCOPY  0x0007 // screen to screen copy
#define ESC_NV_OPENGL_SUPPORT_ENABLED           0x0008 // OpenGL ICD enabled or NOT!
#define ESC_NV_OPENGL_ALLOC_SHARED_MEMORY       0x0009 // create shared memory area
#define ESC_NV_OPENGL_FREE_SHARED_MEMORY        0x000A // free shared memory area
#define ESC_NV_OPENGL_GET_DISPLAY_PITCH         0x000B // return pitch of display
#define ESC_NV4_OPENGL_SWAP_BUFFERS             0x000C // NV4 swap buffers...
#define ESC_NV4_OPENGL_FLUSH                    0x000D // NV4 flush...
#define ESC_NV_OPENGL_PURGE_DEVICE_BITMAP       0x000E // purge GDI device bitmaps...
#define ESC_NV_OPENGL_FLUSH                     0x000F // NV10 and up style flush...
#define ESC_NV_OPENGL_SWAP_BUFFERS              0x0010 // NV10 and up style swap buffers...
#define ESC_NV_OPENGL_CPUBLIT                   0x0011 // Generic CPU blit. Currently used for buffer region Ext.
#define ESC_NV_OPENGL_INIT_STATE                0x0012 // Initialize HW state from the display driver side
#define ESC_NV_OPENGL_ALLOC_UNIFIED_SURFACES    0x0021 // alloc single back/depth in GDI display driver
#define ESC_NV_OPENGL_FREE_UNIFIED_SURFACES     0x0022 // free single back/depth in GDI display driver
#define ESC_NV_OPENGL_GET_SURFACE_INFO          0x0023 // get offset for single back
#define ESC_NV_OPENGL_DID_STATUS_CHANGE         0x0029 // clip list status call
#define ESC_NV_OPENGL_GET_CLIP_LIST_COUNT       0x002A // return count of rectangles in clip list
#define ESC_NV_OPENGL_GET_CLIP_LIST             0x002B // return list of rectangles for window clip
#define ESC_NV_OPENGL_SUPPORT                   0x002C // return TRUE if OpenGL supported...
#define ESC_NV_OPENGL_REGISTER_RM_CLIENT        0x002D // register RM client with display driver
#define ESC_NV_OPENGL_UNREGISTER_RM_CLIENT      0x002E // unregister RM client with display driver
#define ESC_NV_OPENGL_SET_DAC_BASE              0x002F // set the display base offset
#define ESC_NV_OPENGL_SYNC_CHANNEL              0x0030 // wait for FIFO and graphics engine to be !busy
#define ESC_NV_OPENGL_SET_LAYER_PALETTE         0x0031 // Overlay specific: set palette entries in the DD
#define ESC_NV_OPENGL_GET_LAYER_PALETTE         0x0032 // Overlay specific: get palette entries from the DD
#define ESC_NV_OPENGL_OVERLAY_MERGEBLIT         0x0033 // Overlay specific: do the merge blit fm+fo->scratch->primary
#define ESC_NV_OPENGL_OVERLAY_ALLOWED           0x0034 // W2K: DrvDescribePixelformat needs to know is overlay is possible
#define ESC_NV_OPENGL_STEREO_ALLOWED            0x0035 // W2K: DrvDescribePixelformat needs to know is stereo is possible
#define ESC_NV_OPENGL_SHARED_LIBRARY_SIZES      0x0036 // check __GLNVstate and __GLdrawablePrivate sizes

#undef ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY // uses a separate escape...
#define ESC_NV_OPENGL_MEM_TO_SCREEN_SRCCOPY     0x7102


#define ESC_NV_QUERYSET_REGISTRY_KEY              0x7103
#define NV_QUERY_REGISTRY_KEY                     0x0001
#define NV_SET_REGISTRY_KEY                       0x0002
#define NV_QUERY_REGISTRY_BINARY_KEY              0x0004


#define ESC_NV_MAP_USER					0x9000
#define ESC_NV_UNMAP_USER				0x9001

#ifndef NV_SIGNATURE
// This value also is defined in driver.h of display driver
#define NV_SIGNATURE 0x11223344
#endif

#define ESC_NV_QUERY_PCI_SLOT                   0x7105
#define ESC_NV_QUERY_HEAD_REFRESH_RATE          0x7106

#ifndef NV_ESC_PRIMARY_INFO
#define NV_ESC_PRIMARY_INFO 0x7104
typedef struct _NV_PRIMARY_INFO
{
    ULONG  ulNVSignature;   // IN
    ULONG  ulNumDevices;    // IN
    ULONG  ulHeadNum;       // IN
    ULONG  ulReturnCode;    // IN
    ULONG  ulWidth;         // OUT from display driver
    ULONG  ulHeight;        // OUT from display driver
    ULONG  ulDepth;         // OUT from display driver
    ULONG  ulPitch;         // OUT from display driver
    ULONG  ulPrimaryOffset; // OUT from display driver
    ULONG  ulNumDACs;       // OUT from display driver (NT only)
    ULONG  ulNumActiveDACs; // OUT from display driver
    ULONG  ulActiveDACs;    // OUT from display driver (NT only)
    ULONG *ulPanningPtr;    // OUT from display driver (9x only)
    ULONG *ulFullscreenPtr; // OUT from display driver (9x only)
} NV_PRIMARY_INFO;
#endif

#ifdef _WIN32 // rest of this file only needed for win32 interfaces

typedef struct _NV_OPENGL_COMMAND
{
    ULONG       NVSignature;
    ULONG       command;             // Handle to resource manager client used in NvFree
    ULONG       numDevices;          // Number of devices in the system
    HWND        hWnd;                // Window handle
    HDC         hDC;                 // GDI device context handle
    ULONG       hClient;             // Handle to resource manager client
    ULONG       processHandle;       // Process handle from client associated with globalData
    PVOID       globalData;          // Pointer to global shared data for destroy
    PVOID       other;               // Pointer to whatever
} NV_OPENGL_COMMAND;

typedef struct _NV_OPENGL_CLIP_LIST_DATA
{
    int  clipChangedCount;
    int  rgnDataSize;
    void *rgnData;
    void *rect;
} NV_OPENGL_CLIP_LIST_DATA;

typedef struct _NV_OPENGL_GLOBAL_DATA
{
    ULONG oglMutex;
    ULONG oglModeSwitch;
    ULONG oglPFifoAddress;
    ULONG oglSystemMutex;
} NV_OPENGL_GLOBAL_DATA;

typedef struct _NV_WNDOBJ_SETUP
{
    ULONG       NVSignature;
    HWND        hWnd;       /* Handle to window */
    HDC         hDC;        /* handle to GDI device context */
    ULONG       numDevices; /* Number of devices in the system */
    int         overlayMember; // TRUE if part of an overlay
} NV_WNDOBJ_SETUP;

#define NV_CLIP_MUTEX_WAIT_IN_SECONDS       10 // 10 milliseconds
#define NV_WINDOW_CLIP_FULLYVISIBLE         0x0001
#define NV_WINDOW_CLIP_OCCLUDED             0x0002
#define NV_WINDOW_CLIP_SINGLERECTANGLE      0x0004
#define NV_WINDOW_CLIP_COMPLEX              0x0008
#define NV_WINDOW_CLIP_FULLSCREEN           0x0010
#define MAX_OGL_CLIP_RECTS                  250
#define MAX_OGL_CLIENTS                     512

#define NV_CLIP_LIST_FLUSH                  0x0001
#define NV_CLIP_LIST_SWAP                   0x0002
#define NV_CLIP_LIST_DIRTY                  0x0004

typedef struct _NV_OPENGL_DRAWABLE_INFO
{
    ULONG       oglMutexPtr;            // Handle to resource manager client used in NvFree
    PVOID       oglGlobalPagePtr;       // Pointer to shared memory
    ULONG       mutexLock;              // Lock on this data structure
    PVOID       pClientInfoMdl;         // MDL for lock down pages
    PVOID       userVirtualAddress;     // user virtual address for clientInfo
    ULONG       hClient;                // handle to resource manager
    HANDLE      hWnd;                   // Handle to window tracked in DrvClipChanged
    HANDLE      hDC;                    // Handle to GDI device context
    LONG        iPixelFormat;           // pixel format associated with this client
    RECT        rect;                   // rectangle of window on screen
    ULONG       clipChangedCount;       // Number of times clip has changed since client registered
    ULONG       clipFlags;              // Clip status for last clip
    ULONG       numClipRects;           // Number of clip rectangles
    RECTL       windowRect[MAX_OGL_CLIP_RECTS];
                                        // Clip region for client window
    PVOID       origClientDrawableInfoPtr; 
                                        // Original Ptr remembered to free memory

    RECTL       *cachedClipRectList;    // Cache the clip list so that we do not have to merge it
    ULONG       cachedNumClipRects;     // Number of rectangles.
    ULONG       cachedClipListSize;     // Currently allocated size of the clip list.
	ULONG       cachedClipListFlag;     // Flag to determine whether to recompute clip list.
                                        // Values: NV_CLIP_LIST_FLUSH, NV_CLIP_LIST_SWAP, NV_CLIP_LIST_DIRTY
    RECTL       *cachedExclusiveRectList;    // Cache the clip list so that we do not have to merge it
    ULONG       cachedNumExclusiveRects;     // Number of rectangles.
    RECTL       *copyWindowRect;           // Actual clip rectangle pointer used everywhere in NV4+ driver
    ULONG       sizeCopyWindowRectList;    // Size of clip rectangle pointer above.

    RECTL       *translateWindowRectList; // cache for translated clip list
    ULONG       translateNumWindowRects;  // cache count for translate clip list

    ULONG       cxScreen, cyScreen;     // width and height of display
    ULONG       cxcyChanged;

    //
    // The following flag is used when UBB is ON, window flipping is OFF and there are no OGL windows
    // occluding the window this drawable structure references.  This is an optimization for window
    // clipping created for 3D Studio Max.  When 3D Studio Max is in No redraw on expose mode, an expose
    // event will not cause a re-render of the scene.  Compaq workstation did not like this and complained
    // that the image is wrong in comparison to other CAD graphics products.  Since the 3D pixels are 
    // clipped to a GDI window that is occluding our OGL window, it is possible to render those pixels
    // with UBB on without causing scribble.  But for this to work, the occluding window must NOT be a
    // OGL window and window flipping must be off.
    //
    // This flag is computed as part of the DrvClipChanged function.
    //
    ULONG       ubbWindowClipFlag;      // TRUE means use window bounds for clip; otherwise use copyWindowRect list
    ULONG       refCount;               // mainplane+overlay track the same window!, so we need a refCount, to securely destroy the drawable
    // **attention**: - currently sizeof(NV_OPENGL_DRAWABLE_INFO)> 1 page
    //                - only the first page(4096) of NV_OPENGL_DRAWABLE_INFO is visible in the ICD!
    //                - do not place icd-visible members at the end! [and vice versa]
    int         overlayMember;
    } NV_OPENGL_DRAWABLE_INFO;

typedef struct _NV_OPENGL_CONTEXT_INFO
    {
    PVOID       oglGlobalPagePtr;       // Pointer to shared memory
    PVOID       clientPFifoAddress;     // Address of FIFO in client address space
    HWND        hWnd;                   // Window/drawable associated with context
    HDC         hDC;                    // GDI device context
    ULONG       hClient;                // Handle to resource manager client
    PVOID       pClientInfoMdl;         // MDL for lock down pages
    PVOID       userVirtualAddress;     // user virtual address for clientInfo
    PVOID       origClientContextInfoPtr; 

                                        // Original Ptr remembered to free memory
    } NV_OPENGL_CONTEXT_INFO;

// WARNING! This structure is shared with NT display driver in driver.h
#define OGL_ERROR_NO_ERROR             0x0000
#define OGL_ERROR_MODE_SWITCH          0x0001
#define OGL_ERROR_CLIENT_NOT_FOUND     0x0002
#define OGL_ERROR_CLIP_MUTEX_TIMEOUT   0x0003
#define OGL_ERROR_CLIP_LIST_BAD        0x0004
#define OGL_ERROR_LOAD_BUFFER_INFO     0x0005
#define OGL_ERROR_SIMPLE_TO_COMPLEX    0x0006
#define OGL_ERROR_COMPLEX_TO_SIMPLE    0x0007
#define OGL_ERROR_REALLOC_FAILURE      0x0008
#define OGL_ERROR_NO_SWAP              0x0009
#define OGL_ERROR_WINDOW_CHANGED_COUNT 0x000A
#define OGL_ERROR_SURFACE_INVALID      0x000B

typedef struct __GLNVClientSwapHintInfoRec {
    ULONG swapHintRectCount;
    // Swap Hint Rectangle List
    LPRECT swapHintRectList;
} __GLNVClientSwapHintInfo;

typedef struct __GLNVWindowInfoRec {
    // window info
    ULONG left;
    ULONG top;
    ULONG offsetX;
    ULONG offsetY;
    int   winLeft; // window left relative to desktop
    int   winTop;  // window top relative to desktop
    int   devLeft; // device left relative to desktop
    int   devTop;  // device top relative to desktop
    int   clipX;   // drawable clip left value
    int   clipY;   // drawable clip top value
    int   clipW;   // drawable clip width
    int   clipH;   // drawable clip height
} __GLNVWindowInfo;

typedef struct __GLNV4ScissorClipHWInfoRec {
    // scissor clip info
    ULONG set3DSurfaceClipControlWord;
    ULONG size3DSurfacesClip;
} __GLNV4ScissorClipHWInfo;

typedef struct __GLNV4BlitHWInfoRec {
    // BLIT info
    ULONG bltControlWord;
    ULONG bltSizeSet;
} __GLNV4BlitHWInfo;

typedef struct __GLNV4PushBufferHWInfoRec {

    // push buffer info
    ULONG *pClipStart;  // start of clip NOOPs
    ULONG *pBufCur;
    ULONG  dwCmdBufFreeCount;
    PVOID  dmaChannel;
    ULONG *pushBufferBase;
    ULONG *pushBufferEnd;
    ULONG  maskOtherChannels;
    ULONG  ourChannelId;
    ULONG  dwCachedGet;
    ULONG  dwCachedPut;
    ULONG *lastJump;
} __GLNV4PushBufferHWInfo;

typedef struct __GLNV4ClipBufferHWInfoRec {

    // clip buffer info
    void  *tagTable;
    ULONG  tagEnd;
    ULONG *pClipBufBase;
} __GLNV4ClipBufferHWInfo;


typedef struct __GLNV4swapInfoRec {
    ULONG hClient;
    HWND  hWnd;
    HDC   hDC;

    // window info
    __GLNVWindowInfo winInfo;

    // BLIT info
    __GLNV4BlitHWInfo blitInfo;

    // push buffer info
    __GLNV4PushBufferHWInfo pushBufferInfo;

    // clip buffer info
    __GLNV4ClipBufferHWInfo clipBufferInfo;

    // clip and mode switch info
    ULONG localModeSwitchCount;

    __GLNVClientSwapHintInfo clientSwapInfo;

    // swap interval
    ULONG swapInterval;
    ULONG swapCounter;

    // Window Changed Count 
    ULONG windowChangedCount;

    // return status
    ULONG retStatus;
} __GLNV4swapInfo;

#define NV_BLIT_MEM_TO_SCR 1
#define NV_BLIT_SCR_TO_MEM 2
typedef struct {
    HWND        hWnd;
    HDC         hDC;
    ULONG       blitType;
    ULONG       useClipList;
    PVOID       pSrcBase; 
    ULONG       dwSrcByteWidth; 
    ULONG       dwSrcElementSize;
    ULONG       dstOffset; // offset in frame buffer
    PVOID       pDstBase; 
    ULONG       dwDstByteWidth; 
    ULONG       dwDstElementSize;
    ULONG       dwSrcLeft; 
    ULONG       dwSrcTop;
    ULONG       dwDstLeft; 
    ULONG       dwDstTop;
    ULONG       dwWidth; 
    ULONG       dwHeight;
    ULONG       retStatus;
} __GLNvCpuBltData;

typedef struct {
    ULONG       type;
    PCHAR       keyName;
    PVOID       keyVal;
    ULONG       keyValSize;
    ULONG       keyValMaxSize;
    ULONG       retStatus;
} *__PNVRegKeyInfo, __NVRegKeyInfo;


// Desktop Manager private escapes
#define ESC_NV_DESKMGR_ZOOMBLIT         0x7107

#define NVDM_ESC_BLIT_VIDMEM            0x00000000
#define NVDM_ESC_BLIT_SYSMEM            0x00000001
#define NVDM_ESC_BLIT_SMOOTH            0x00000002

typedef struct {
    ULONG flags;
    int scale;
    union {
        RECTL srcRect;
        struct {
            ULONG format;
            int stride;
            PVOID bits;
        } srcMem;
    };
    RECTL dstRect;
    int clips;
    RECTL clipRects[1];
} __NVDMEscapeParams;

#endif // _WIN32

#endif // NV_ESC_DEF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvFourCC.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//  Content:    FOURCC codes used in the nVidia drivers
//
//  Note that this file is meant to be used across ALL operating systems.
//  Do not create any dependency on non-nVidia code.
//
// **************************************************************************
#ifndef _NVFOURCC_H_
#define _NVFOURCC_H_

#include "nvTypes.h"

/* MMIO macros */
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (NvU32)(NvU8)(ch0) | ( (NvU32)(NvU8)(ch1) << 8 ) |    \
                ( (NvU32)(NvU8)(ch2) << 16 ) | ( (NvU32)(NvU8)(ch3) << 24 ) )
#endif // mmioFOURCC

/* FOURCC video formats we support */
#ifndef FOURCC_UYVY
#define FOURCC_UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef FOURCC_YUY2
#define FOURCC_YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef FOURCC_UYNV
#define FOURCC_UYNV                        mmioFOURCC('U','Y','N','V')
#endif
#ifndef FOURCC_YUNV
#define FOURCC_YUNV                        mmioFOURCC('Y','U','N','V')
#endif
#ifndef FOURCC_YV12
#define FOURCC_YV12                        mmioFOURCC('Y','V','1','2')
#endif
#ifndef FOURCC_NVDS
#define FOURCC_NVDS                        mmioFOURCC('N','V','D','S')
#endif
#ifndef FOURCC_NVMC
#define FOURCC_NVMC                        mmioFOURCC('N','V','M','C')
#endif
#ifndef FOURCC_NV12
#define FOURCC_NV12                        mmioFOURCC('N','V','1','2')
#endif
#ifndef FOURCC_NVID
#define FOURCC_NVID                        mmioFOURCC('N','V','I','D')
#endif
#ifndef FOURCC_NVSP
#define FOURCC_NVSP                        mmioFOURCC('N','V','S','P')
#endif
#ifndef FOURCC_420i
#define FOURCC_420i                        mmioFOURCC('4','2','0','i')
#endif
#ifndef FOURCC_IF09
#define FOURCC_IF09                        mmioFOURCC('I','F','0','9')
#endif
#ifndef FOURCC_YVU9
#define FOURCC_YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef FOURCC_IV32
#define FOURCC_IV32                        mmioFOURCC('I','V','3','2')
#endif
#ifndef FOURCC_IV31
#define FOURCC_IV31                        mmioFOURCC('I','V','3','1')
#endif
#ifndef FOURCC_RAW8
#define FOURCC_RAW8                        mmioFOURCC('R','A','W','8')
#endif
#ifndef FOURCC_RGB0
#define FOURCC_RGB0                        0 // ?? @mjl@
#endif
#ifndef FOURCC_UBAD
#define FOURCC_UBAD                        mmioFOURCC('U','B','A','D')
#endif

/* FOURCC formats we support for 3d textures */
#ifndef FOURCC_NVT0
#define FOURCC_NVT0                        mmioFOURCC('N','V','T','0')
#endif
#ifndef FOURCC_NVT1
#define FOURCC_NVT1                        mmioFOURCC('N','V','T','1')
#endif
#ifndef FOURCC_NVT2
#define FOURCC_NVT2                        mmioFOURCC('N','V','T','2')
#endif
#ifndef FOURCC_NVT3
#define FOURCC_NVT3                        mmioFOURCC('N','V','T','3')
#endif
#ifndef FOURCC_NVT4
#define FOURCC_NVT4                        mmioFOURCC('N','V','T','4')
#endif
#ifndef FOURCC_NVT5
#define FOURCC_NVT5                        mmioFOURCC('N','V','T','5')
#endif
#ifndef FOURCC_NVT6
#define FOURCC_NVT6                        mmioFOURCC('N','V','T','6')
#endif
#ifndef FOURCC_NVT7
#define FOURCC_NVT7                        mmioFOURCC('N','V','T','7')
#endif
#ifndef FOURCC_NVT8
#define FOURCC_NVT8                        mmioFOURCC('N','V','T','8')
#endif
#ifndef FOURCC_NVT9
#define FOURCC_NVT9                        mmioFOURCC('N','V','T','9')
#endif
#ifndef FOURCC_NVS0
#define FOURCC_NVS0                        mmioFOURCC('N','V','S','0')
#endif
#ifndef FOURCC_NVS1
#define FOURCC_NVS1                        mmioFOURCC('N','V','S','1')
#endif
#ifndef FOURCC_NVS2
#define FOURCC_NVS2                        mmioFOURCC('N','V','S','2')
#endif
#ifndef FOURCC_NVS3
#define FOURCC_NVS3                        mmioFOURCC('N','V','S','3')
#endif
#ifndef FOURCC_NVS4
#define FOURCC_NVS4                        mmioFOURCC('N','V','S','4')
#endif
#ifndef FOURCC_NVS5
#define FOURCC_NVS5                        mmioFOURCC('N','V','S','5')
#endif
#ifndef FOURCC_NVS6
#define FOURCC_NVS6                        mmioFOURCC('N','V','S','6')
#endif
#ifndef FOURCC_NVS7
#define FOURCC_NVS7                        mmioFOURCC('N','V','S','7')
#endif
#ifndef FOURCC_NVS8
#define FOURCC_NVS8                        mmioFOURCC('N','V','S','8')
#endif
#ifndef FOURCC_NVS9
#define FOURCC_NVS9                        mmioFOURCC('N','V','S','9')
#endif
#ifndef FOURCC_NVHU
#define FOURCC_NVHU                        mmioFOURCC('N','V','H','U')
#endif
#ifndef FOURCC_NVHS
#define FOURCC_NVHS                        mmioFOURCC('N','V','H','S')
#endif
#ifndef FOURCC_DXT1
#define FOURCC_DXT1                        mmioFOURCC('D','X','T','1') // Compressed Texture
#endif
#ifndef FOURCC_DXT2
#define FOURCC_DXT2                        mmioFOURCC('D','X','T','2')
#endif
#ifndef FOURCC_DXT3
#define FOURCC_DXT3                        mmioFOURCC('D','X','T','3')
#endif
#ifndef FOURCC_DXT4
#define FOURCC_DXT4                        mmioFOURCC('D','X','T','4')
#endif
#ifndef FOURCC_DXT5
#define FOURCC_DXT5                        mmioFOURCC('D','X','T','5')
#endif


// Note!! The number below is UNRELATED to the number of fourcc's defined above.  
// This is the number that will be USED by the driver. This should be redone! @mjl@

/* total number of fourcc formats we support */
#define NV_MAX_FOURCC_REGULAR (10 + 12)     // 10 ddraw/video, 12 texture

#ifdef DXT_SUPPORT
#define NV_MAX_FOURCC_COMPRESSED 5          // 5 compressed texture
#else
#define NV_MAX_FOURCC_COMPRESSED 0
#endif

#define NV_MAX_FOURCC                       (NV_MAX_FOURCC_REGULAR+NV_MAX_FOURCC_COMPRESSED)

#endif // _NVFOURCC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvPixelFmt.h ===
#ifndef __gl_nvPixelFmt_h_
#define __gl_nvPixelFmt_h_

/*
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 */

int STDCALL __wglNVDescribePixelFormat(int bpp, int iPixelFormat, UINT nBytes,
                                       PIXELFORMATDESCRIPTOR *ppfd,
                                       int flags);

#define NUM_PIXELFORMATS_16 6
#define NUM_PIXELFORMATS_16_OVERLAY 12
#define NUM_PIXELFORMATS_32 10
#define NUM_PIXELFORMATS_32_OVERLAY 20
#define NUM_NV11_PIXELFORMATS_32 15

extern PIXELFORMATDESCRIPTOR *NV4PixelFormats16[NUM_PIXELFORMATS_16];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32[NUM_PIXELFORMATS_32];
extern PIXELFORMATDESCRIPTOR *NV4PixelFormats32Overlay[NUM_PIXELFORMATS_32_OVERLAY];
extern PIXELFORMATDESCRIPTOR *NV11PixelFormats32[NUM_NV11_PIXELFORMATS_32];

#define NV_PFD_SUPPORTS_COLOR32_DEPTH16 0x00000001 /* nv11 */
#define NV_PFD_SUPPORTS_COLOR16_DEPTH32 0x00000002 /* hopefully, some day */
#define NV_PFD_SUPPORTS_OVERLAYS        0x00000004
#define NV_PFD_SUPPORTS_SWAPCOPYONLY    0x00000008

#endif  /* __gl_nvPixelFmt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvOverlaySurf.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifndef _NVOVERLAYSURF_H_
#define _NVOVERLAYSURF_H_

#ifdef DEBUG
#define NV_DBG_SHOW_FOURCC()                                                    \
    char fourCCStr[5];                                                          \
    fourCCStr[0] = (char)pSurf->lpGbl->ddpfSurface.dwFourCC & 0xFF;             \
    fourCCStr[1] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 8) & 0xFF;      \
    fourCCStr[2] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 16) & 0xFF;     \
    fourCCStr[3] = (char)(pSurf->lpGbl->ddpfSurface.dwFourCC >> 24) & 0xFF;     \
    fourCCStr[4] = 0;                                                           \
    DPF_LEVEL(NVDBG_LEVEL_SURFACE,                                              \
        "FOURCC %s allocation: size=%u bytes", &fourCCStr, dwBlockSize );
#else // NOT DEBUG
#define NV_DBG_SHOW_FOURCC()
#endif // DEBUG

// external functions

extern DWORD VppCreateFourCCSurface(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pSurf, LPDDRAWI_DIRECTDRAW_GBL pDDGbl, DWORD dwExtraSize, DWORD dwExtraNumSurfaces, DWORD dwBlockHeight);
extern void VppCalcExtraSurfaceSpace(Vpp_t *pVpp, LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, DWORD dwRequestedSurfaces, DWORD *dwExtraSize, DWORD *dwExtraNumSurfaces, DWORD *dwBlockHeight);
#endif // _DDSURF4CC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvPatchInterface.h ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPatchInterface.h
//        nvPatchInterface specification to allow for shared ogl/d3d access
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************

// using generic C structs for shared library compatability with OGL.

#ifndef __NV_PATCH_INTERFACE_H
#define __NV_PATCH_INTERFACE_H

/*
** Standard polymorphic data types that are not present in older header files.
*/
#if defined(_WIN32) && (_MSC_VER < 1300)

typedef int            intptr_t;
typedef unsigned int   uintptr_t;

#endif

/*** Global constants ***/

//return codes for EvalPatch
#define NV_PATCH_EVAL_OK                 0x1
#define NV_PATCH_EVAL_ERR_OUT_OF_MEMORY  0x10
#define NV_PATCH_EVAL_ERR_NOT_HANDLED    0x20

// D3D, OGL, and Kelvin all use 16 separate vertex attributes.
#define NV_PATCH_NUMBER_OF_ATTRIBS      16

// D3D supports up to 5, OGL supports up to 8, and Kelvin supports up to 16.
// Note that when computing normal patches, an 8th-order nonrational patch
// becomes a 14th-order rational patch, and an 8th-order rational patch
// exceeds the Kelvin limit easily.
#define NV_PATCH_MAX_ORDER              16

// The maximum size of a swatch is determined by the size of the vertex
// file.   Henry says this is the magic number.  16 might work better, but
// it's not clear.
#define NV_PATCH_KELVIN_SWATCH_SIZE     17


#define NV_PATCH_MAX_TOTAL_STEP 1000    // total steps allowed
#define NV_PATCH_MAX_EVAL_STEP 40       // max steps within a sub-patch

// Matrix structure for matrix math
typedef struct {
    int rows, columns;
    float data[NV_PATCH_MAX_ORDER][NV_PATCH_MAX_ORDER][4]; // [row][col][xyzw]
} FDMatrix;

// For swathing, an array of ptrs to FDMatrices is used to 
// find a pointer to a particular FDMatrix given an attribute number
typedef FDMatrix *FDMatrixAttrSet[NV_PATCH_NUMBER_OF_ATTRIBS];

// Evaluated vertex attributes
typedef struct {
    float vertexAttribs[NV_PATCH_MAX_EVAL_STEP][NV_PATCH_NUMBER_OF_ATTRIBS][4];
} NV_PATCH_EVAL_OUTPUT;


// This is given to beginPrimitive to indicate what type of primitive to draw.
typedef enum {
    NV_PATCH_PRIMITIVE_TSTRIP = 1,
    NV_PATCH_PRIMITIVE_TFAN   = 2,
} NV_PATCH_PRIMITIVE_TYPE;

// Information for forward differencing one curve
typedef float NV_PATCH_CURVE_COEFFS[NV_PATCH_MAX_ORDER][4];
typedef struct {
    int order;
    //fffloat coeffs[NV_PATCH_MAX_ORDER][4];
    NV_PATCH_CURVE_COEFFS coeffs;
} NV_PATCH_CURVE_INFO;

// For swathing, an array of ptrs to NV_PATCH_CURVE_INFOs is used to 
// find a pointer to a particular guard curve given an attribute number
typedef NV_PATCH_CURVE_INFO *FDCurveAttrSet[NV_PATCH_NUMBER_OF_ATTRIBS];

// Enumerant for what basis the patch is defined on
typedef enum {
    NV_PATCH_BASIS_BEZIER      = 0,
    NV_PATCH_BASIS_BSPLINE     = 1,
    NV_PATCH_BASIS_CATMULL_ROM = 2,
} NV_PATCH_BASIS_TYPE;

// Enumerant for the format of the control points
typedef enum {
    NV_PATCH_VERTEX_FORMAT_FLOAT_1 = 0, // Expand to (value,   0.0,   0.0, 1.0) 
    NV_PATCH_VERTEX_FORMAT_FLOAT_2 = 1, // Expand to (value, value,   0.0, 1.0);
    NV_PATCH_VERTEX_FORMAT_FLOAT_3 = 2, // Expand to (value, value, value, 1.0);
    NV_PATCH_VERTEX_FORMAT_FLOAT_4 = 3, // No expansion required                
    NV_PATCH_VERTEX_FORMAT_UBYTE   = 4, // Unpack bytes and remap to [0,1.0]    
} NV_PATCH_VERTEX_FORMAT_TYPE;

// Dirty flags for each map
#define NV_PATCH_DIRTY_NONE             0x00000000
#define NV_PATCH_DIRTY_CONTROL_POINTS   0x00000001
#define NV_PATCH_DIRTY_TESSELLATION     0x00000002

// Enumerant for the type of backend
typedef enum {
    NV_PATCH_BACKEND_IMMEDIATE = 1, // call immediately into a NV_PATCH_BACKEND
    NV_PATCH_BACKEND_CELSIUS   = 2, // write a Celsius pushbuffer
    NV_PATCH_BACKEND_KELVIN    = 3, // write a Kelvin pushbuffer
    NV_PATCH_BACKEND_DP2       = 4, // write a DP2 command stream
} NV_PATCH_BACKEND_TYPE;

#define NV_PATCH_ATTRIB_POSITION            0
#define NV_PATCH_ATTRIB_VERTEX_WEIGHT       1
#define NV_PATCH_ATTRIB_NORMAL              2
#define NV_PATCH_ATTRIB_COLOR               3
#define NV_PATCH_ATTRIB_SECONDARY_COLOR     4
#define NV_PATCH_ATTRIB_FOG_COORD           5
#define NV_PATCH_ATTRIB_UNUSED0             6
#define NV_PATCH_ATTRIB_UNUSED1             7
#define NV_PATCH_ATTRIB_TEXCOORD0           8
#define NV_PATCH_ATTRIB_TEXCOORD1           9
#define NV_PATCH_ATTRIB_TEXCOORD2           10
#define NV_PATCH_ATTRIB_TEXCOORD3           11
#define NV_PATCH_ATTRIB_TEXCOORD4           12
#define NV_PATCH_ATTRIB_TEXCOORD5           13
#define NV_PATCH_ATTRIB_TEXCOORD6           14
#define NV_PATCH_ATTRIB_TEXCOORD7           15

// Guard information for a single subquad within a fractional tesselation                                                
typedef struct {                                //     |              |
    NV_PATCH_CURVE_INFO *guardU0;               //     |              |center
    NV_PATCH_CURVE_INFO *guardV0;               // Vmid*---UCenter----*-----
    NV_PATCH_CURVE_INFO *guardUCenter;          //     |              |
    NV_PATCH_CURVE_INFO *guardVCenter;          //     |    _         |
    float *uMid;                                //     |   _/|      VCenter
    float *vMid;                                //    V0 _/           |
    float *center;                              //     |/             |
} NV_PATCH_FRAC_GUARD_INFO;                     //     +------U0------*------
                                                //                  Umid    

// Guard information for a single attribute for a fractionally tesselated
// tensor product patch
typedef struct {                            //                    u1Mid
    NV_PATCH_CURVE_INFO guardU00;           //       *------U01-----*------U11-----*
    NV_PATCH_CURVE_INFO guardU01;           //       |\_            |            _/|
    NV_PATCH_CURVE_INFO guardU10;           //       |  \_          |          _/  |
    NV_PATCH_CURVE_INFO guardU11;           //      V01  _\| 01    VC1    11 |/_  V11
    NV_PATCH_CURVE_INFO guardV00;           //       |              |              |
    NV_PATCH_CURVE_INFO guardV01;           //       |              |center        |
    NV_PATCH_CURVE_INFO guardV10;           //  v0Mid*------UC0-----*------UC1-----* v1Mid
    NV_PATCH_CURVE_INFO guardV11;           //       |              |              |
    NV_PATCH_CURVE_INFO guardUCenter0;      //       |    _         |         _    |
    NV_PATCH_CURVE_INFO guardUCenter1;      //      V00  _/|  00   VC0    10 |\_  V10
    NV_PATCH_CURVE_INFO guardVCenter0;      //       | _/           |           \_ |
    NV_PATCH_CURVE_INFO guardVCenter1;      //       |/             |             \|
    float u0Mid[4], v0Mid[4], u1Mid[4];     //       *------U00-----*------U10-----*
    float v1Mid[4], center[4];              //                    u0Mid
} NV_PATCH_FRAC_QUAD_GUARD_INFO;


// Guard information for a single attribute for a fractionally tesselated
// triangular patch
typedef struct {                            //                +                -                           
    NV_PATCH_CURVE_INFO guard[3][2];        //               / \               -
    NV_PATCH_CURVE_INFO guardCenter[3];     //              /   \              -   
    float mid[3][4];                        //             /     \             -
    float center[4];                        //           g20     g11           -        
} NV_PATCH_FRAC_TRI_GUARD_INFO;             //           /         \           -
                                            //          /           \          -
                                            //    mid? +             + mid?    -
                                            //        / \_         _/ \        -
                                            //       /    gc?    gc?   \       -
                                            //      /       \_ _/       \      -
                                            //    g21         + center  g10    -
                                            //    /           |           \    -
                                            //   /           gc?           \   -
                                            //  /             |             \  -                             
                                            // +------g00-----+------g01-----+ -
                                            //               mid?


// Guard information for a single attribute for an integrally tesselated
// tensor product patch
typedef struct {                                                //          
    NV_PATCH_CURVE_INFO guardU0;                                //     c01                     c11 
    NV_PATCH_CURVE_INFO guardU1;                                //      *--------gU1------------*     
    NV_PATCH_CURVE_INFO guardV0;                                //      |                     _/|
    NV_PATCH_CURVE_INFO guardV1;                                //      |                   /   |               
    NV_PATCH_CURVE_INFO guardUInner;                            //      +------UInner-------+   |               
    NV_PATCH_CURVE_INFO guardVInner;                            //      |                   |   |               
    // *Begin/End point to guard curves at                      //      |                   |   |               
    //  begin/end of regular grid                               //      |                   |   |               
    NV_PATCH_CURVE_INFO *pGuardUBegin;                          //     gV0              VInner gV1               
    NV_PATCH_CURVE_INFO *pGuardUEnd; // row: U0, U1, UInner     //      |                   |   |               
    NV_PATCH_CURVE_INFO *pGuardVBegin;                          //      |                   |   |               
    NV_PATCH_CURVE_INFO *pGuardVEnd; // col: V0, V1, VInner     //      |                   |   |               
    // corners of the original control points                   //      |                   |   |               
    float corners[2][2][4]; // [v][u][xyzw]                     //      |                   |   |               
    // these cached here to use when dirtyFlags not set         //      +--------gU0--------+---*
    int u0Dir, u1Dir, v0Dir, v1Dir;                             //     c00                 pVB c10

    // *Begin/End point to guard curves at begin/end of regular grid

    // the corners[] are from the original control points
} NV_PATCH_INT_QUAD_GUARD_INFO;


// Information for an integrally tesselated tensor product patch
typedef struct {
    NV_PATCH_INT_QUAD_GUARD_INFO **guard;   // from guardQI or swathing
    int nu0, nv0, nu1, nv1; // actual number of segments along each edge
    int uMaxSegs, vMaxSegs, uMinSegs, vMinSegs; // MIN and MAX comparing nu0:nu1 and nv0:nv1

    // flags for transitions required.
    // Names refer to original LRTB, not flipped versions or anything
    int stitchLeft, stitchRight, stitchTop, stitchBottom;

    // these begin/end's mean in the direction of U (L/R) and V (B/T)
    // XXX FBF I find this confusing, since it doesn't correspond to U0, U1
    // XXX in other words, stitchVBegin means U0/UInner create a stitch (in cononical view)
    // XXX will soon change to make these match
    int stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd;

    int u0Dir, v0Dir, u1Dir, v1Dir; // '1' means normal direction (For u this is L-->R, for v this is B-->T)

    // MaxDir are directions of regular grid
    // XXX REMOVE? MinDir are opposite of MaxDir's. Doesn't appear to be used any more.
    int uMaxDir, vMaxDir, uMinDir, vMinDir;

    float du0, du1, dv0, dv1, duMax, dvMax; // small step size along edges, and for regular grid

    // temp storage allocated in DrawIntPatch() and used by lower routines
    // uGuard and vGuard are for the ending curves in regular grid
    NV_PATCH_CURVE_INFO **uGuard, **vGuard, *tempCurve;
    FDMatrix **ppMatrixSetSS0; // FD matrix for reg grid, small steps in V and U
    FDCurveAttrSet *pCurvesTop, *pCurvesBot;
    NV_PATCH_EVAL_OUTPUT *pOut1, *pOut2;
} NV_PATCH_INT_QUAD_INFO;

// for quadInfo->setGridCorner
#define NV_PATCH_SET_GRID_CORNER00      0x1
#define NV_PATCH_SET_GRID_CORNER10      0x2
#define NV_PATCH_SET_GRID_CORNER01      0x4
#define NV_PATCH_SET_GRID_CORNER11      0x8
#define NV_PATCH_SET_GRID_CORNER_ALL    0xf

// Information for one map within the current patch
typedef struct {
    unsigned int uorder, vorder;
    float *rawData;
    int stride;                       // OGL: stride == type*sizeof(float)
    int pitch;                        // OGL: pitch == uorder
    NV_PATCH_VERTEX_FORMAT_TYPE type; 
    NV_PATCH_VERTEX_FORMAT_TYPE Originaltype; 
    unsigned int dirtyFlags;          // Currently ignored
} NV_PATCH_MAP_INFO;

// Declaration of an immediate-mode-style backend
typedef struct {
    void (*InitBackend)(void *info);
    void (*DestroyBackend)(void *info);
    void (*beginPrimitive)(void *info, NV_PATCH_PRIMITIVE_TYPE primType);
    void (*endPrimitive)(void *info);
    void (*sendVertex)(void *info, NV_PATCH_EVAL_OUTPUT *pData, int index);
    void (*setFrontFace)(void *info, int reversed);
} NV_PATCH_BACKEND;

// These are the callbacks that the shared code needs access to.  It is NOT SAFE
// to call C standard library or Windows API functions from the shared code!
typedef struct {
    void *(*malloc)(void *context, size_t bytes);
    void (*free)(void *context, void *ptr);    
    void (*memcpy)(void *dst, const void *src, size_t bytes);
    void (*flushOutput)(void *context, unsigned int bytesWritten);
} NV_PATCH_DRIVER_CALLBACKS;

/*****************************************************************************/
// eval memory allocation. Avoid seperate malloc for each section of memory.
// allocate a big chunk with EV_ALLOC_INIT 
// and dole it out efficiently with EV_ALLOC
// free it with EV_FREE
// Only one DECL per routine.
// Use EV_ALLOC_INIT to init locally.
// Use EV_ALLOC_RESET to use memory chunk allocated by higher level routine.

typedef struct {
        void *pBase;
        int callerAlloc;    // non-zero if caller does alloc/free
        void *pAvail;
        void *context;
        int bytesAlloc;
        int bytesUsed;
} NV_PATCH_ALLOC_CONTROL;

#define EV_ALLOC_DECL() NV_PATCH_ALLOC_CONTROL evMemory = {NULL, 0}

#define EV_ALLOC_RESET(EVMEMORY, CONTEXT, TOTALBYTES, errorLabel) do { \
        if (&(EVMEMORY) != &evMemory) { \
            evMemory = EVMEMORY; \
        } \
        nvAssert(CONTEXT == evMemory.context); \
        evMemory.pAvail = evMemory.pBase; \
        evMemory.bytesUsed = 0; \
        nvAssert((TOTALBYTES) <= evMemory.bytesAlloc); \
        if (!evMemory.pBase) { \
            retVal |= NV_PATCH_EVAL_ERR_OUT_OF_MEMORY; \
            evMemory.bytesAlloc = 0; \
        } \
        break; \
evAllocError: \
        retVal |= NV_PATCH_EVAL_ERR_OUT_OF_MEMORY; \
        goto errorLabel; \
    } while (0);\

        //ffPrintInt(evMemory.bytesAlloc); \

#define EV_ALLOC_INIT(CONTEXT, TOTALBYTES, errorLabel) { \
        nvAssert(!evMemory.pBase); \
        evMemory.bytesAlloc = (TOTALBYTES); /* assign first to eval expr */ \
        evMemory.pBase = info->callbacks->malloc(CONTEXT, evMemory.bytesAlloc);\
        evMemory.context = CONTEXT; \
        EV_ALLOC_RESET(evMemory, CONTEXT, evMemory.bytesAlloc, errorLabel); \
    }

#define EV_ALLOC(VAR, CONTEXT, BYTES) { \
        int __nBytes; \
        nvAssert(CONTEXT == evMemory.context); \
        evMemory.bytesUsed += (__nBytes = (BYTES)); \
        nvAssert(evMemory.bytesUsed <= evMemory.bytesAlloc); \
        if (evMemory.bytesUsed <= evMemory.bytesAlloc) { \
            *(void **)(&(VAR)) = evMemory.pAvail; \
            evMemory.pAvail = (char *)evMemory.pAvail + __nBytes; \
            nvAssert(!((uintptr_t)evMemory.pAvail & 0x3)); \
        } else { \
            VAR = NULL; \
        } \
        if (!VAR) goto evAllocError; \
    }

#define EV_FREE(VAR, CONTEXT) { \
        nvAssert(CONTEXT == evMemory.context); \
        if (evMemory.pBase && (VAR) && !evMemory.callerAlloc) { \
            info->callbacks->free(CONTEXT, evMemory.pBase); \
            evMemory.pBase = NULL; \
        } \
        VAR = NULL; \
    }

#define EV_ALLOC_FULL(CONTEXT) \
        /* expect equal if pre-calc was accurate */ \
        nvAssert(evMemory.bytesUsed == evMemory.bytesAlloc);

// The above alloc macro's could be redefined to use normal malloc/free,
// with appropriate macro's being null.
// The notion of a global evMemory is more specific to the eval code.
#define EV_ALLOC_GLOBAL(EVMEMORY, CONTEXT, TOTALBYTES, errorLabel) { \
        nvAssert(!EVMEMORY.pBase); \
        EVMEMORY.callerAlloc = 1; \
        EVMEMORY.bytesAlloc = (TOTALBYTES); /* assign first to eval expr */ \
        EVMEMORY.pBase = info->callbacks->malloc(CONTEXT, TOTALBYTES); \
        EVMEMORY.context = CONTEXT; \
        if (EVMEMORY.pBase == NULL) { \
            goto errorLabel; \
        } \
    } 

#define EV_FREE_GLOBAL(EVMEMORY, CONTEXT) { \
        if (EVMEMORY.pBase) info->callbacks->free(CONTEXT, EVMEMORY.pBase); \
        EVMEMORY.pBase = NULL; \
    }


// ***** bits for info->swatchFlags
#define NV_PATCH_SWATCH                 0x00000001      // set when swathing

#define NV_PATCH_SWATCH_FIRST_ROW       0x00000100
#define NV_PATCH_SWATCH_LAST_ROW        0x00000200
#define NV_PATCH_SWATCH_FIRST_COL       0x00000400
#define NV_PATCH_SWATCH_LAST_COL        0x00000800

#define NV_PATCH_SWATCH_SAVE_FIRST_ROW  0x00001000
#define NV_PATCH_SWATCH_SAVE_LAST_ROW   0x00002000
#define NV_PATCH_SWATCH_SAVE_FIRST_COL  0x00004000
#define NV_PATCH_SWATCH_SAVE_LAST_COL   0x00008000

#define NV_PATCH_HAS_NORMAL             0x00010000      // indicates to emit normal guard curves
//#define NV_PATCH_NEW_SWATH              0x00020000    // indicates this is the first swatch in a swath
//#define NV_PATCH_BEGIN_PATCH            0x00040000    // indicates this is the first swatch in a patch     
//#define NV_PATCH_END_PATCH              0x00080000    // indicates this is the last swatch in a patch


/*****************************************************************************/
// Flags for info->flags 
#define NV_PATCH_FLAG_TYPE_MASK         0x00000001
#define NV_PATCH_FLAG_TYPE_TRIANGULAR   0x00000001
#define NV_PATCH_FLAG_TYPE_PATCH        0x00000000

#define NV_PATCH_FLAG_TESS_MASK         0x00000002
#define NV_PATCH_FLAG_TESS_FRACTIONAL   0x00000002
#define NV_PATCH_FLAG_TESS_INTEGER      0x00000000

#define NV_PATCH_FLAG_AUTO_MASK         0x0000000C
#define NV_PATCH_FLAG_AUTO_NORMAL       0x00000004
#define NV_PATCH_FLAG_AUTO_UV           0x00000008
#define NV_PATCH_FLAG_AUTO_NONE         0x00000000

#define NV_PATCH_FLAG_CACHE_MASK        0x00000010
#define NV_PATCH_FLAG_DO_NOT_CACHE      0x00000010

// Information about the current patch
typedef struct {
    // Bitmask of which attributes to evaluate (bits 0..15)
    unsigned int evalEnables;
    int nAttr;                  // number of active attrs
    int maxAttr;                // max attributes required for malloc's
    unsigned int maxOrder;      // max order of all enabled attributes
    int maxSwatch;              // set according to HW or SW swathing
    int nSwatchU, nSwatchV;     // swatches in patch, including Begin/End stitch

    int swatchFlags;            // control during swathing using NV_PATCH_SWATCH_*

    // Evaluation flags
    unsigned int flags;         // NV_PATCH_FLAG_*

    // Description of tesselation factors
    union {
        struct {
            float nu0, nu1, nv0, nv1;
        } tensor;
        struct {
            float n1, n2, n3;
        } tri;
    } tess, originaltess;

    // The basis for the patch
    NV_PATCH_BASIS_TYPE basis;

    // Source and destination of AUTO_NORMAL calculations
    int srcNormal, dstNormal;
    int rational;
    float startu, endu, startv, endv;
    // Destination of AUTO_UV calculations
    int srcUV[8], dstUV[8];         //can have up to 8 sets??

    // Information for each map
    NV_PATCH_MAP_INFO maps[NV_PATCH_NUMBER_OF_ATTRIBS];

    // What type of backend we are writing to or calling to
    NV_PATCH_BACKEND_TYPE backendType;

    // Function pointers for shared code to call into
    NV_PATCH_BACKEND *backend;
    NV_PATCH_DRIVER_CALLBACKS *callbacks;

    // Output buffer (pushbuffer, DP2 stream, ...)
    unsigned char *buffer;
    unsigned int bufferLength; // in bytes
    int vertexSize;            // expected # of dwords to output per vertex

    // Opaque context pointer
    void *context;

    // info for EV_ALLOC in lower level routines
    // for ComputeFDMatrix and ComputeFDCurveCoeffs()
    NV_PATCH_ALLOC_CONTROL evAllocComputeFD;

    // These point to the guard corners of the regular grid. They are in this 
    // top-level structure to be used by all patch types.
    // Instead of fancy attribute arrays, they are simply enumerated for
    // the two attributes which require guard corners: vertex, normal
    // Think of drawing the regular grid from lower-left to upper-right.
    // These names match that orientation so the regular grid routine doesn't
    // need to worry about various orientation flipping and swatching cases.
    // Perhaps LL and LR are not needed for HW, but they're set up for now.
    // Generally these points are the corners of the regular grid,
    // except for LL and LR on the bottom row with a bottom stitch.
    // In this case, they correspond to the swatch corners, and must be stepped
    // up if you want the regular grid.
    //  UL=[0][1]   UR=[1][1]
    //  LL=[0][0]   LR=[0][1]
    float *pSwatchCornerVertex[2][2]; // [v][u]
    float *pSwatchCornerNormal[2][2]; // [v][u]

    // These are available storage for the corners of the regular grid on
    // the outside of all swatches.  
    // Whereas, pSwatchCornerVertex and pSwatchCornerNormal will be 
    // correct per sub-patch, these need only be fully valid
    // after all swatches are done
    // Here, the indices are "absolute" because the stitch code was written
    // to draw stitches on the Left, Right, Bot, Top, not relative to the
    // regular grid.
    float gridCornerVertex[2][2][4]; // [v][u][xyzw]
    float gridCornerNormal[2][2][4]; // [v][u][xyzw]
    int setGridCorner;  // mask indicating which gridCorner to assign

    // CACHED DATA
    // the driver should allocate memory for these data members BEFORE 
    // calling into the shared code.  Shared code should not be responsible 
    // for the life time of these data members.
    FDMatrix *m00[NV_PATCH_NUMBER_OF_ATTRIBS], *m01[NV_PATCH_NUMBER_OF_ATTRIBS],
             *m10[NV_PATCH_NUMBER_OF_ATTRIBS], *m11[NV_PATCH_NUMBER_OF_ATTRIBS];    //[attribute]  (sub-patch index = 0 for bezier types)

    //we should probably union these....
    NV_PATCH_FRAC_QUAD_GUARD_INFO *guardQF[NV_PATCH_NUMBER_OF_ATTRIBS];             //[attribute]  (sub-patch index = 0 bezier types)
    NV_PATCH_FRAC_TRI_GUARD_INFO  *guardTF[NV_PATCH_NUMBER_OF_ATTRIBS];
    NV_PATCH_INT_QUAD_GUARD_INFO  *guardQI[NV_PATCH_NUMBER_OF_ATTRIBS];   

} NV_PATCH_INFO;

unsigned int nvEvalPatch(NV_PATCH_INFO *info);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvPM.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvPM_h
#define _nvPM_h

#ifdef __cplusplus
extern "C"
{
#endif

/*
 * constants
 */

// registry related
#define PM_REGISTRY_SUBKEY          "PerformanceMonitor"

#define PM_REG_LOGFILENAME          "logFileName"
#define PM_REG_CONNECTCOUNT         "connectCount"
#define PM_REG_PMTRIGGER            "trigger"
#define PM_REG_TRIGGERCOUNT         "triggerCount"
#define PM_REG_PROGRAM_SETUP        "programSetup"
#define PM_REG_PROGRAM_START        "programStart"
#define PM_REG_PROGRAM_SAMPLE       "programSample"

#define PM_REG_PMTRIGGER_DISABLED   0                   // disabled
#define PM_REG_PMTRIGGER_ENDSCENE   1                   // emit trigger at end of frame
#define PM_REG_PMTRIGGER_1MS        2                   // emit trigger at 1ms intervals (not exact)
#define PM_REG_PMTRIGGER_RESV00     3
#define PM_REG_PMTRIGGER_CUSTOM0    4
#define PM_REG_PMTRIGGER_CUSTOM1    5
#define PM_REG_PMTRIGGER_CUSTOM2    6
#define PM_REG_PMTRIGGER_CUSTOM3    7
#define PM_REG_PMTRIGGER_MAX        7

#define PM_LOG_ID                   "events \0"
#define PM_PGM_ID                   "program\0"

#define PM_LOG_VERSION              0x00000001
#define PM_PGM_VERSION              0x00000001

#define PM_PGM_MASK_SIZE            0x0000000f
#define PM_PGM_VAL_SIZE_8               0x00000000
#define PM_PGM_VAL_SIZE_16              0x00000001
#define PM_PGM_VAL_SIZE_32              0x00000002
#define PM_PGM_VAL_SIZE_40              0x00000003
#define PM_PGM_FLAG_READ            0x80000000

#define PM_LOG_EVENT_BUFFER_SIZE    (65536 / 8)

/*
 * macros
 */
#define PM_SIGNAL(match)            if (g_dwPMTrigger == (match)) { if (!(--g_dwPMTriggerValue)) { pmSignal(); g_dwPMTriggerValue = g_dwPMTriggerCount; } }

/*
 * structures
 */
#pragma pack(push,1)

//////
// log event
typedef struct
{
    DWORD dwValueLo;
    DWORD dwValueHi;
} PM_LOG_EVENT;

// log header
typedef struct
{
    char         szID[8];
    DWORD        dwVersion;
    PM_LOG_EVENT Event[1];
} PM_LOG_HEADER;

//////
// program entry
typedef struct
{
    DWORD dwFlags;
    DWORD dwOffset;
    DWORD dwValueLo;
    DWORD dwValueHi;
} PM_PGM_ENTRY;

// program header
typedef struct
{
    char         szID[8];
    DWORD        dwVersion;
    DWORD        dwEntryCount;
    PM_PGM_ENTRY Entry[1];
} PM_PGM_HEADER;

#pragma pack(pop)

/*
 * exported globals
 */
extern DWORD g_dwPMTrigger;
extern DWORD g_dwPMTriggerCount;
extern DWORD g_dwPMTriggerValue;

/*
 * public functions
 */
BOOL pmConnect    (HDC hEscapeDC,DWORD dwHWLinearBase,DWORD dwArch);    // arch: nv4 -> 0x04, nv10 -> 0x10
BOOL pmDisconnect (void);
BOOL pmSignal     (void);

#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvPriv.h ===
#ifndef _DDPRIV_
#define _DDPRIV_

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       nvPriv.h
 *  Content:    header for nvPriv.cpp
 *
 ***************************************************************************/

typedef struct _MYDCICMD
{
	ULONG	dwCommand;
	ULONG	dwParam1;
	ULONG 	dwParam2;
	ULONG	dwVersion;
	ULONG	dwReserved;
} MYDCICMD;

typedef struct _MYDD32BITDRIVERDATA
{
    UCHAR   szName[260];            // 32-bit driver name
    UCHAR   szEntryPoint[64];       // entry point
    ULONG   dwContext;              // context to pass to entry point
} MYDD32BITDRIVERDATA;

#define DD_VERSION              0x00000200l
#define DDCREATEDRIVEROBJECT    10
#define DDGET32BITDRIVERNAME    11
#define DDNEWCALLBACKFNS        12
#define DDVERSIONINFO           13
#define DDDESTROYDRIVEROBJECT   99

#define MAX_ADAPTERS            9

#ifdef WINNT
#ifndef NV_ESC_DDPRIV_DMABLIT
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88
#endif

#ifndef NV_ESC_DDPRIV_OVERLAYCONTROL
// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89
#endif
#endif // WINNT

// --------------------------------------------------------------------------
// nvOverlayControl
//      Overlay control callback
//
// Command Structure
// -----------------
// NVOCCMD_GETCAPS
//      dwSize
//      dwDevice
//      returns caps
//          dwCaps1
//              NVOCCAPS1_BRIGHTNESS
//              NVOCCAPS1_CONTRAST
//              NVOCCAPS1_HUE
//              NVOCCAPS1_SATURATION
//              NVOCCAPS1_SHARPNESS
//              NVOCCAPS1_GAMMA
//          dwCaps2
//              NVOCCAPS2_HQVUPSCALE
//              NVOCCAPS2_TFILTER
//              NVOCCAPS2_DFILTER
//              NVOCCAPS2_FSMIRROR
//              NVOCCAPS2_OVLZOOM
//          dwCaps3
//              NVOCCAPS3_SUBPICTURE
//              NVOCCAPS3_LATEFLIPSYNC
//              NVOCCAPS3_SPLITVPP
//              NVOCCAPS3_BLTCAPS
//          dwCaps4
//              NVOCCAPS4_SMA
//              NVOCCAPS4_IMB
//              NVOCCAPS4_DEVICEHASOVL
//              NVOCCAPS4_MULTIHEADNUM (number of display heads on this device)
//              NVOCCAPS4_MULTIHEADMODE (0 = single, 1 = span, 2 = clone)
//              NVOCCAPS4_HEAD0_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//              NVOCCAPS4_HEAD1_TYPE (0 = CRT, 1 = NTSC, 2 = PAL, 3 = DFP, -1 = inactive)
//          dwCaps5
//              NVOCCAPS5_BLT_YUV9_2_YUV422
//              NVOCCAPS5_BLT_YUV12_2_YUV422
//              NVOCCAPS5_BLT_YC12_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_YUV422
//              NVOCCAPS5_BLT_YUV422_2_RGB8
//              NVOCCAPS5_BLT_YUV422_2_RGB15
//              NVOCCAPS5_BLT_YUV422_2_RGB16
//              NVOCCAPS5_BLT_YUV422_2_RGB32
//              NVOCCAPS5_BLT_SYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2VYUV
//              NVOCCAPS5_BLT_VYUV2SYUV
//              NVOCCAPS5_BLT_SYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2VRGB
//              NVOCCAPS5_BLT_VYUV2SRGB
//              NVOCCAPS5_BLT_SRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2VRGB
//              NVOCCAPS5_BLT_VRGB2SRGB
//              NVOCCAPS5_BLT_2RGBTEX
// NVOCCMD_SETCOLORCONTROL
//      dwSize
//      dwDevice
//      ccData
//          dwEnable (ignored for NV10 and above, always enabled)
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  lBrightness (range is -256 to +255)
//              NVOCCC_CONTRAST
//                  lContrast (range is 0 to 200)
//              NVOCCC_HUE
//                  lHue (range is 0 to 360)
//              NVOCCC_SATURATION
//                  lSaturation (range is 0 to 200)
// NVOCCMD_GETCOLORCONTROL
//      dwSize
//      dwDevice
//      returns ccData
//          returns dwEnable
//              0 = disable
//              1 = enable with vertical chroma subsampling
//              2 = enable with full chroma sampling (do not use)
//          returns dwCCFlags
//              NVOCCC_BRIGHTNESS
//                  returns lBrightness
//              NVOCCC_CONTRAST
//                  returns lContrast
//              NVOCCC_HUE
//                  returns lHue
//              NVOCCC_SATURATION
//                  returns lSaturation
// NVOCCMD_SETFEATURE (enables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE (always enable if enough memory (8M))
//          NVOCF1_TFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[0] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_TF_PRECOPY
//          NVOCF1_DFILTER (only enable in BOB mode if enough memory (16M))
//              lCoefficient[1] (recommended value = 0xA4)
//              dwCmdFlags (optional)
//                  NVOCF_DF_PRECOPY
//          NVOCF1_FSMIRROR (only enable with dual head and large memory)
//              lCoefficient[4]:
//                  bits 0-3: head number
//                            0 = disable FSVM
//                            1 = display 1
//                            2 = display 2
//                            15 = autoselect display
//                  bits 4-7: aspect ratio
//                            0 = stretch to display full screen
//                            1 = preserve aspect of source (assume square pixels)
//                            3 = force anamorphic 16:9
//                            5 = track overlay aspect
//                            9 = force TV 4:3
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-19: zoom factor, 0 = 1x, 255 = 2x
//                  bit 20: 0 = use current display size
//                          1 = let driver pick the display size
//                  bit 21: 0 = independent FS and overlay zoom
//                          1 = FS zoom tracks overlay zoom controls
//                  bit 22: 0 = disable DVD output to TV
//                          1 = enable DVD output to TV
//          NVOCF1_OVLZOOM
//              lCoefficient[5]:
//                  bits 8-11: zoom quadrant
//                             0 = disable zoom
//                             1 = top left
//                             2 = top right
//                             3 = bottom left
//                             4 = bottom right
//                             5 = center
//                  bits 12-23: zoom factor, 0 = 1x, 255 = 2x
//          NVOCF1_DELIVERYCONTROL
//              lCoefficient[6]: low 32 bits of frame period (in ns)
//              lCoefficient[7]: high 32 bits of frame period (in ns)
//          NVOCF1_LATEFLIPSYNC
//      dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = set to 0, 2, 3, 4, or 6
//              lCoefficient[3] = reserved
// NVOCCMD_RESETFEATURE (disables feature)
//      dwSize
//      dwDevice
//      dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//          NVOCF1_DFILTER
//          NVOCF1_FSMIRROR
//          NVOCF1_OVLZOOM
//          NVOCF1_DELIVERYCONTROL
//          NVOCF1_LATEFLIPSYNC
// NVOCCMD_GETFEATURE
//      dwSize
//      dwDevice
//      returns dwFeature1
//          NVOCF1_HQVUPSCALE
//          NVOCF1_TFILTER
//              returns lCoefficient[0]
//          NVOCF1_DFILTER
//              returns lCoefficient[1]
//          NVOCF1_FSMIRROR
//              returns lCoefficient[4]
//          NVOCF1_OVLZOOM
//              returns lCoefficient[5]
//          NVOCF1_DELIVERYCONTROL
//              returns lCoefficient[6]
//                      lCoefficient[7]
//          NVOCF1_LATEFLIPSYNC
//      returns dwFeature2
//          NVOCF2_VPPMAXSURFACES
//              lCoefficient[2] = max VPP work surfaces
//              lCoefficient[3] = VPP work surfaces currently allocated
//

#define OVERLAYCONTROLCALLBACK "nvOverlayControl"

typedef enum { 
    NVOCERR_OK              = 0,
    NVOCERR_GENERIC_WARN    = 1,
    NVOCERR_GENERIC_FATAL   = 0x80000001,
    NVOCERR_BAD_COMMAND     = 0x80000002,
    NVOCERR_INVALID_PARMS   = 0x80000003,
    NVOCERR_ALREADY_ACTIVE  = 0x80000004,
    NVOCERR_NOT_SUPPORTED   = 5,
    NVOCERR_BAD_DEVICE      = 0x80000006
} NVOCERROR;

typedef enum {
    NVOCCMD_NOOP            = 0,
    NVOCCMD_GETCAPS         = 1,
    NVOCCMD_SETCOLORCONTROL = 2,
    NVOCCMD_GETCOLORCONTROL = 3,
    NVOCCMD_SETFEATURE      = 4,
    NVOCCMD_RESETFEATURE    = 5,
    NVOCCMD_GETFEATURE      = 6
} NVOCCOMMAND;

typedef struct {
    unsigned long   dwCCFlags;
    unsigned long   dwEnable;
    long            lBrightness;
    long            lContrast;
    long            lHue;
    long            lSaturation;
    long            lSharpness;
    long            lGamma;
} NVOCCCDATA, *LPNVOCCCDATA;

#define NVOCCC_BRIGHTNESS   0x1
#define NVOCCC_CONTRAST     0x2
#define NVOCCC_HUE          0x4
#define NVOCCC_SATURATION   0x8
#define NVOCCC_SHARPNESS    0x10
#define NVOCCC_GAMMA        0x20

typedef struct {
    unsigned long dwCaps1;
    unsigned long dwCaps2;
    unsigned long dwCaps3;
    unsigned long dwCaps4;
    unsigned long dwCaps5;
} NVOCCAPS, *LPNVOCCAPS;

#define NVOCCAPS1_BRIGHTNESS    0x1
#define NVOCCAPS1_CONTRAST      0x2
#define NVOCCAPS1_HUE           0x4
#define NVOCCAPS1_SATURATION    0x8
#define NVOCCAPS1_SHARPNESS     0x10
#define NVOCCAPS1_GAMMA         0x20

#define NVOCCAPS2_HQVUPSCALE    0x1
#define NVOCCAPS2_TFILTER       0x2
#define NVOCCAPS2_DFILTER       0x4
#define NVOCCAPS2_FSMIRROR      0x8
#define NVOCCAPS2_OVLZOOM       0x10

#define NVOCCAPS3_SUBPICTURE        0x1
#define NVOCCAPS3_LATEFLIPSYNC      0x2
#define NVOCCAPS3_SPLITVPP          0x4
#define NVOCCAPS3_DELIVERYCONTROL   0x8
#define NVOCCAPS3_BLTCAPS           0x80000000

#define NVOCCAPS4_IMB           0x1
#define NVOCCAPS4_SMA           0x2
#define NVOCCAPS4_DEVICEHASOVL  0x4
#define NVOCCAPS4_MULTIHEADNUM  0x000F0000
#define NVOCCAPS4_MULTIHEADMODE 0x00F00000
#define NVOCCAPS4_HEAD0_TYPE    0x0F000000
#define NVOCCAPS4_HEAD1_TYPE    0xF0000000

#define NVOCCAPS5_BLT_YUV9_2_YUV422     0x00000001
#define NVOCCAPS5_BLT_YUV12_2_YUV422    0x00000002
#define NVOCCAPS5_BLT_YC12_2_YUV422     0x00000004
#define NVOCCAPS5_BLT_YUV422_2_YUV422   0x00000008
#define NVOCCAPS5_BLT_YUV422_2_RGB8     0x00000100
#define NVOCCAPS5_BLT_YUV422_2_RGB15    0x00000200
#define NVOCCAPS5_BLT_YUV422_2_RGB16    0x00000400
#define NVOCCAPS5_BLT_YUV422_2_RGB32    0x00000800
#define NVOCCAPS5_BLT_SYUV2VYUV         0x00010000
#define NVOCCAPS5_BLT_VYUV2VYUV         0x00020000
#define NVOCCAPS5_BLT_VYUV2SYUV         0x00040000
#define NVOCCAPS5_BLT_SYUV2VRGB         0x00100000
#define NVOCCAPS5_BLT_VYUV2VRGB         0x00200000
#define NVOCCAPS5_BLT_VYUV2SRGB         0x00400000
#define NVOCCAPS5_BLT_SRGB2VRGB         0x01000000
#define NVOCCAPS5_BLT_VRGB2VRGB         0x02000000
#define NVOCCAPS5_BLT_VRGB2SRGB         0x04000000
#define NVOCCAPS5_BLT_2RGBTEX           0x80000000

typedef struct {
    unsigned long dwFeature1;
    unsigned long dwFeature2;
    unsigned long dwFeature3;
    unsigned long dwFeature4;
    long          lCoefficient[16];
} NVOCFEATUREDATA;

#define NVOCF1_HQVUPSCALE       0x1
#define NVOCF1_TFILTER          0x2
#define NVOCF1_LATEFLIPSYNC     0x4
#define NVOCF1_DFILTER          0x8
#define NVOCF1_FSMIRROR         0x10
#define NVOCF1_OVLZOOM          0x20
#define NVOCF1_DELIVERYCONTROL  0x40

#define NVOCF2_VPPMAXSURFACES   0x1

#define NVOCF_TF_PRECOPY   0x00000001
#define NVOCF_DF_PRECOPY   0x00000002

typedef struct {
    unsigned long dwSize;
    unsigned long dwDevice;

    // command
    NVOCCOMMAND cmd;
    unsigned long dwCmdFlags;

    // data
    union {
        NVOCCAPS        caps;
        NVOCCCDATA      ccData;
        NVOCFEATUREDATA featureData;
    };

    unsigned long dwReserved[40];
} NVOCDATATYPE, *LPNVOCDATATYPE;

typedef NVOCERROR (__stdcall *NVOVERLAYCONTROL)(LPNVOCDATATYPE data);


// --------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Obsolete.  Only use with rel3 drivers
//      If lpDDCC is NULL, callback returns caps
//
//      dwDevice            always 1
//      lpDDCC->dwSize      sizeof(DDCOLORCONTROL)
//      lpDDCC->dwFlags     DDCOLOR_CONTRAST | DDCOLOR_BRIGHTNESS | DDCOLOR_HUE | DDCOLOR_SATURATION
//                          determines which members hold valid data
//      lpDDCC->lBrightness range is from -256 to +255
//      lpDDCC->lContrast   range is from 0 to 200
//      lpDDCC->lHue        range is from 0 to 360
//      lpDDCC->lSaturation range is from 0 to 200
//      lpDDCC->dwReserved1 0 = disable colour controls
//                          1 = enable with vertical chroma subsampling
//                          2 = enable with full chroma sampling
#define SETOVERLAYCOLORCONTROLCALLBACK "nvSetOverlayColorControl"

typedef DWORD (__stdcall *NVSETOVERLAYCOLORCONTROL)(DWORD dwDevice, LPDDCOLORCONTROL lpDDCC);


// --------------------------------------------------------------------------
// nvMoComp
//      Backdoor DMA blits and formatting for video
// 
// Command Structure
// -----------------
// NVS2VCMD_INIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV:
//              fpSrc
//          NVS2V_UYVY:
//              fpSrc
//          NVS2V_RGB16:
//              fpSrc
//          NVS2V_RGB32:
//              fpSrc
//          NVS2V_YC12
//              SrcYC12.fpY
//          NVS2V_YUV12
//              SrcYUV12.fpY (points to start of surface)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//      dwDstType (required only if using INDEXED type on BLIT)
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
// NVS2VCMD_RELEASE
//      dwSize
//      dwDevice
//      dwIndex
// NVS2VCMD_BLIT
//      dwSize
//      dwDevice
//      dwIndex
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET (only use for V->S blits)
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YC12
//              SrcYC12.fpY
//              SrcYC12.fpC
//          NVS2V_YUV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//          NVS2V_YV12
//              SrcYUV12.fpY
//              SrcYUV12.fpU
//              SrcYUV12.fpV
//              dwSrcYV12ChromaPitch
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET (only use for S->V blits)
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//      dwDstType
//          NVS2V_YUYV
//              fpDst
//          NVS2V_UYVY
//              fpDst
//          NVS2V_DDSURF
//              lpDstDirectDrawSurface
//          NVS2V_INDEXED (uses last YUY2 or UYVY state)
//              dwDstSize
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_QUERY_IDLE
//      dwSize
//      dwDevice
// NVS2VCMD_WAIT_FOR_IDLE
//      dwSize
//      dwDevice
//      dwTimeoutTime
// NVS2VCMD_SET_SUBPICTURE
//      dwSize
//      dwDevice
//      dwSPFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_SP_SUBRECT
//              dwSubRectX
//              dwSubRectY
//              dwSubRectWidth
//              dwSubRectHeight
//      dwSPType
//      dwSPPitch
//      fpSP
// NVS2VCMD_VPP_START
//      dwSize
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc
//          NVS2V_UYVY
//              fpSrc
//      dwSrcPitch
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_VPP_ODD
//          NVS2VF_VPP_EVEN
//          NVS2VF_VPP_BOB
//          NVS2VF_VPP_INTERLEAVED
// NVS2VCMD_VPP_QUERY
//      dwSize
//      dwDevice
// NVS2VCMD_VPP_FLIP
//      dwSize
//      dwDevice
// NVS2VCMD_4CC_TO_VRGB
//      dwSize
//      dwIndex (0xFFFFFFFF means use video memory)
//      dwCmdFlags (optional)
//          NVS2VF_CRTC_SYNC
//              dwHead
//              dwScanline (blit will not begin until CRTC of specified head reaches this scanline)
//              dwTimeoutTime
//          NVS2VF_USE_DELIVERY_CTL
//              dwTimeoutTime
//      dwDevice
//      dwWidth
//      dwHeight
//      dwSrcFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL
//          NVS2VF_SYSTEM (default)
//      dwSrcType
//          NVS2V_YUYV
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//          NVS2V_UYVY
//              fpSrc (not required if in system memory)
//              dwSrcPixelBias (31:16 is the Y pixel bias in 12.4 fixed point, 15:0 is the X pixel bias in 12.4 fixed point)
//      dwSrcPitch
//      dwDstFlags (optional)
//          NVS2VF_OFFSET
//          NVS2VF_LOCAL (default)
//          NVS2VF_SYSTEM
//          NVS2VF_SWIZZLED
//      dwDstType
//          NVS2V_RGB16
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//          NVS2V_RGB32
//              DstRGB.fpRGB
//              DstRGB.dwDstWidth
//              DstRGB.dwDstHeight
//      dwDstPitch
//      bWaitForCompletion
//          dwTimeoutTime
// NVS2VCMD_GET_TEXTURE_OFFSET
//      dwSize
//      dwDevice
//      fpTexture
//      returns fpTexture


#define MOCOMPCALLBACK "nvMoComp"

typedef enum {
    NVS2V_YC12      = 1,
    NVS2V_YUV12     = 2,
    NVS2V_YUYV      = 3,
    NVS2V_UYVY      = 4,
    NVS2V_DDSURF    = 5,
    NVS2V_INDEXED   = 6,
    NVS2V_YUVA16    = 7,
    NVS2V_YUVA32    = 8,
    NVS2V_YV12      = 9,
    NVS2V_RGB8      = 0x10,
    NVS2V_RGB16     = 0x11,
    NVS2V_RGB24     = 0x12,
    NVS2V_RGB32     = 0x13
} NVS2VSURFTYPE;

typedef enum {
    NVS2VCMD_NOOP               = 0,
    NVS2VCMD_INIT               = 1,
    NVS2VCMD_RELEASE            = 2,
    NVS2VCMD_BLIT               = 3,
    NVS2VCMD_QUERY_IDLE         = 4,
    NVS2VCMD_WAIT_FOR_IDLE      = 5,
    NVS2VCMD_SET_SUBPICTURE     = 6,
    NVS2VCMD_VPP_START          = 7,
    NVS2VCMD_VPP_QUERY          = 8,
    NVS2VCMD_VPP_FLIP           = 9,
    NVS2VCMD_4CC_TO_VRGB        = 0xA,
    NVS2VCMD_GET_TEXTURE_OFFSET = 0xB
} NVS2VCOMMAND;

typedef enum {
    NVS2VERR_OK             = 0,
    NVS2VERR_GENERIC_WARN   = 1,
    NVS2VERR_GENERIC_FATAL  = 0x80000001,
    NVS2VERR_BAD_COMMAND    = 0x80000002,
    NVS2VERR_INVALID_PARMS  = 0x80000003,
    NVS2VERR_INIT_FAILED    = 0x80000004,
    NVS2VERR_NO_EVENT       = 5,
    NVS2VERR_BUSY           = 6,
    NVS2VERR_TIMEOUT        = 7,
    NVS2VERR_BAD_DEVICE     = 0x80000008
} NVS2VERROR;

#define NVS2VF_OFFSET           0x00000001
#define NVS2VF_SP_SUBRECT       0x00000002
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
#define NVS2VF_VPP_ODD          0x00000010
#define NVS2VF_VPP_EVEN         0x00000020
#define NVS2VF_VPP_BOB          0x00000040
#define NVS2VF_VPP_INTERLEAVED  0x00000080
#define NVS2VF_LOCAL            0x00000100
#define NVS2VF_SYSTEM           0x00000200
#define NVS2VF_SWIZZLED         0x00000400
#define NVS2VF_CRTC_SYNC        0x00000800
#define NVS2VF_USE_DELIVERY_CTL 0x00001000

typedef struct {
    unsigned long dwSize;               // sizeof(NVS2VDATATYPE)
    
    // command data
    NVS2VCOMMAND  dwCmd;
    unsigned long dwCmdFlags;
    BOOL          bWaitForCompletion;
    unsigned long dwTimeoutTime;        // in ms
    unsigned long dwIndex;
    unsigned long dwDevice;
    unsigned long dwHead;
    unsigned long dwScanline;
    unsigned long dwReserved1[55];

    // neutral data
    unsigned long dwWidth;              // in pixels
    unsigned long dwHeight;             // in lines

    // source data
    unsigned long dwSrcFlags;
    NVS2VSURFTYPE dwSrcType;
    unsigned long dwSrcPitch;           // in bytes
    union {
        void  *fpTexture;
        void  *fpSrc;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpSrcDirectDrawSurface;  // used with NVS2V_DDSURF (not implemented)
        unsigned long dwSrcSize;        // used with NVS2V_INDEXED (not implemented)
        struct {
            void  *fpY;
            void  *fpC;
        } SrcYC12;                      // used with NVS2V_YC12 (Y and C must be contiguous)
        struct {
            void  *fpY;
            void  *fpU;
            void  *fpV;
        } SrcYUV12;                     // used with NVS2V_YUV12 (not implemented)
    };

    // destination data
    unsigned long dwDstFlags;
    NVS2VSURFTYPE dwDstType;
    unsigned long dwDstPitch;           // in bytes
    union {
        void  *fpDst;                   // used with NVS2V_YUYV or NVS2V_UYVY or NVS2V_RGB32 or NVS2V_RGB16
        void  *lpDstDirectDrawSurface;  // used with NVS2V_DDSURF
        unsigned long dwDstSize;        // used with NVS2V_INDEXED
        struct {
            void *fpY;
            void *fpC;
        } DstYC12;                      // used with NVS2V_YC12 (not implemented)
        struct {
            void *fpY;
            void *fpU;
            void *fpV;
        } DstYUV12;                     // used with NVS2V_YUV12 (not implemented)
        struct {
            void *fpRGB;
            unsigned long dwDstWidth;
            unsigned long dwDstHeight;
        } DstRGB;                       // used with the RGB surface types
    };

    // subpicture data
    unsigned long dwSPFlags;
    NVS2VSURFTYPE dwSPType;
    unsigned long dwSPPitch;
    unsigned long fpSP;
    unsigned long dwSubRectX;
    unsigned long dwSubRectY;
    unsigned long dwSubRectWidth;
    unsigned long dwSubRectHeight;

    // more source data
    unsigned long dwSrcYV12ChromaPitch;
    unsigned long dwSrcPixelBias;

    // pad
    unsigned long dwReserved2[40];
} NVS2VDATATYPE, *LPNVS2VDATATYPE;

typedef NVS2VERROR (__stdcall *NVMOCOMP)(LPNVS2VDATATYPE data);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvMultiMon.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _nvMultiMon_h
#define _nvMultiMon_h

//
// This file contains constants shared between the display and miniport drivers for NT40 and Win2K.
// These are used for the MultiMon modes for NV11 dual head cards.
// This file also contains the TwinView definitions (previously in win9x\inc\escape.h) used by Win9x driver and 
// the NT40/Win2K drivers.
//

#ifdef __cplusplus
extern "C"
{
#endif

// maximum number of heads this driver supports
#define NV_MAX_HEADS   2

// Uncomment this line to enable the new API for assigning devices to heads.
// #define ENABLE_HEAD_API
// Some special bitmask definitions for the new head API of resman.
#define BITMASK_CRT0    0x1
#define BITMASK_INVALID_DEVICE 0x0
#define BITMASK_ALL_CRT 0xff
#define BITMASK_ALL_TV 0xff00
#define BITMASK_ALL_DFP 0xff0000

    
//
// The table entries were taken from the GTF table in the miniport in vesadata.c
// Returns true if the resolution specified by (modeWidth, modeHeight) is a horizontally doubled resolution.
//
#define HORIZONTAL_MODE(modeWidth, modeHeight) \
        (\
            (modeWidth == 2048 * 2 && modeHeight == 1536 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1440 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1200 * 1) ||\
            (modeWidth == 1920 * 2 && modeHeight == 1080 * 1) ||\
            (modeWidth == 1856 * 2 && modeHeight == 1392 * 1) ||\
            (modeWidth == 1800 * 2 && modeHeight == 1440 * 1) ||\
            (modeWidth == 1792 * 2 && modeHeight == 1344 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1200 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 1024 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 900 * 1) ||\
            (modeWidth == 1600 * 2 && modeHeight == 880 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 1024 * 1) ||\
            (modeWidth == 1280 * 2 && modeHeight == 960 * 1) ||\
            (modeWidth == 1152 * 2 && modeHeight == 864 * 1) ||\
            (modeWidth == 1024 * 2 && modeHeight == 768 * 1) ||\
            (modeWidth == 960 * 2 && modeHeight == 720 * 1) ||\
            (modeWidth == 864 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 856 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 852 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 848 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 800 * 2 && modeHeight == 600 * 1) ||\
            (modeWidth == 720 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 640 * 2 && modeHeight == 480 * 1) ||\
            (modeWidth == 640 * 2 && modeHeight == 400 * 1) ||\
            (modeWidth == 512 * 2 && modeHeight == 384 * 1) ||\
            (modeWidth == 480 * 2 && modeHeight == 360 * 1) ||\
            (modeWidth == 400 * 2 && modeHeight == 300 * 1) ||\
            (modeWidth == 320 * 2 && modeHeight == 240 * 1) ||\
            (modeWidth == 320 * 2 && modeHeight == 200 * 1)\
        )

//
// The table entries were taken from the GTF table in the miniport in vesata.c
// Returns true if the resolution specified by (modeWidth, modeHeight) is a vertically doubled resolution.
//
#define VERTICAL_MODE(modeWidth, modeHeight) \
        (\
            (modeWidth == 2048 * 1 && modeHeight == 1536 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1440 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1200 * 2) ||\
            (modeWidth == 1920 * 1 && modeHeight == 1080 * 2) ||\
            (modeWidth == 1856 * 1 && modeHeight == 1392 * 2) ||\
            (modeWidth == 1800 * 1 && modeHeight == 1440 * 2) ||\
            (modeWidth == 1792 * 1 && modeHeight == 1344 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1200 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 1024 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 900 * 2) ||\
            (modeWidth == 1600 * 1 && modeHeight == 880 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 1024 * 2) ||\
            (modeWidth == 1280 * 1 && modeHeight == 960 * 2) ||\
            (modeWidth == 1152 * 1 && modeHeight == 864 * 2) ||\
            (modeWidth == 1024 * 1 && modeHeight == 768 * 2) ||\
            (modeWidth == 960 * 1 && modeHeight == 720 * 2) ||\
            (modeWidth == 864 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 856 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 852 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 848 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 800 * 1 && modeHeight == 600 * 2) ||\
            (modeWidth == 720 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 640 * 1 && modeHeight == 480 * 2) ||\
            (modeWidth == 640 * 1 && modeHeight == 400 * 2) ||\
            (modeWidth == 512 * 1 && modeHeight == 384 * 2) ||\
            (modeWidth == 480 * 1 && modeHeight == 360 * 2) ||\
            (modeWidth == 400 * 1 && modeHeight == 300 * 2) ||\
            (modeWidth == 320 * 1 && modeHeight == 240 * 2) ||\
            (modeWidth == 320 * 1 && modeHeight == 200 * 2)\
        )

//
// Returns TRUE if the mode is a dual screen multi mon mode. It can beeither horizontal or vertical.
//
#define MULTIMON_MODE(modeWidth, modeHeight)\
        (HORIZONTAL_MODE(modeWidth, modeHeight) || VERTICAL_MODE(modeWidth, modeHeight))

//
// Fills in a nvRECTL structure (which is the same structure as RECTL).
//
#define SET_RECT(nvRECTLPtr, leftVal, topVal, rightVal, bottomVal)\
{\
    (nvRECTLPtr)->left = (leftVal);\
    (nvRECTLPtr)->top =  (topVal);\
    (nvRECTLPtr)->right =  (rightVal);\
    (nvRECTLPtr)->bottom =  (bottomVal);\
}



//******************************************************************************
// Bitmask flag for support desktop
// NOTE: These definitions must match those in the NV miniport's 'NV.h'!
//******************************************************************************
//
// 31            24 23           16                               0
// .-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-.
// |  Secondary        Primary             Master Flag             |
// `-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-'
//
// Master Flag            : bit 0 - bit 15
// Primary Display Flag   : bit 16 - bit 23
// Secondary Display Flag : bit 24 - bit 31
//
//******************************************************************************
#define NV_VIRTUAL_DESKTOP_1        0x00010000
#define NV_VIRTUAL_DESKTOP_2        0x01000000

// NV_SPANNING_MODE is virtual desktop (cxScreen, cyScreen) enabled.
// ie, ppdev->ulMode to mode table resolution does not match to (cxScreen, cyScreen)
// additional information for set mode is passed from IOCTL_VIDEO_SET_DESKTOP_INFO_MODE 
// to miniport driver.

#define NV_TWO_DACS                 0x01
#define NV_CLONE_DESKTOP            0x02
#define NV_SPANNING_MODE            0x04
#define NV_ENABLE_CLASS_SET_MODE    0x08

#define NV_ENABLE_VIRTUAL_DESKTOP   (NV_VIRTUAL_DESKTOP_1 | NV_VIRTUAL_DESKTOP_2)
//
// Values for the ppdev->ulDACStatus[NV_NO_DACS]
//
#define DAC_STATUS_ON_BOARD      1   // The DAC is onboard.
#define DAC_STATUS_CONNECTED    2   // The DAC is connected to a device (CRT/DFP/TV).
#define DAC_STATUS_ACTIVE       4   // The DAC is active. For example, in spanning mode and clone mode, both dacs are active.
                                    // In normal mode, only one head is active.



//*****************************************************************************
//
// NV11 TwiNView definitions for controlling dual CRTC functionality
// (previously in Win9x\inc\escape.h).
//
typedef struct  _nvRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
}   nvRECTL;
#define NV_NO_DACS  2

//
// The device scan bit flags. Used in Win2K/NT4.0 only.
// These are used for the "ulHeadDeviceOptions" field in the GET_DEVICE_SCAN_DATA escape call.
//
#define HEAD_DEVICE_OPTION_CRT 0x1
#define HEAD_DEVICE_OPTION_DFP 0x2
#define HEAD_DEVICE_OPTION_TV  0x4

//
// This indicates that nothing is connected on this head
//
#define INVALID_DEVICE_TYPE 0x9999

// - Added escapes for the control panel to Get the deviceOptions matrix and to initiate the device scan. And
// - to set the timing mode override.
// - This is for TwinView for Win2K/NT4.0 only.
#define NV_ESC_GET_DEVICE_SCAN_DATA                 0x6992
#define NV_ESC_INDUCE_DEVICE_SCAN                   0x6993

typedef struct _GET_DEVICE_SCAN_DATA_TYPE {
    unsigned long ulNumberDacsOnBoard;
    unsigned long ulNumberDacsConnected;
    unsigned long ulNumberDacsActive;
    unsigned long ulHeadDeviceOptions[NV_NO_DACS];
} GET_DEVICE_SCAN_DATA_TYPE;




// use these values for the "dwFlag" member of NVTWINVIEWDATA
#define NVTWINVIEW_FLAG_GET                      0
#define NVTWINVIEW_FLAG_SET                      1
// use these values for the "dwAction" member of NVTWINVIEWDATA
#define NVTWINVIEW_ACTION_SETGET_STATE           1
#define NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE     2
#define NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP  3
#define NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN   4
#define NVTWINVIEW_ACTION_SETGET_PRIMARY_CRTC    5
#define NVTWINVIEW_ACTION_SETGET_VIRTUAL_MODE    6
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE   7

// The following actions are applicable only for NT40 and Win2K. Win9X can ignore this.
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODELIST   8
#define NVTWINVIEW_ACTION_SETGET_GDI_MODELIST    9
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_VIRTUAL_MODE     11

#define NVTWINVIEW_ACTION_VALIDATE_VIRTUAL_MODE  20
#define NVTWINVIEW_ACTION_VALIDATE_PHYSICAL_MODE 21
#define NVTWINVIEW_ACTION_SETGET_TIMING_OVERRIDE 22

// These escapes are to support DVD ZOOM under Win9X. (and maybe NT?)
#define NVTWINVIEW_ACTION_LOCK_HWCRTC                       30
#define NVTWINVIEW_ACTION_UNLOCK_HWCRTC                     31
#define NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE    32

// The following is for Win9X. Win2K/NT4.0 can ignore this.
#define NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD   40

#define NVTWINVIEW_ACTION_SETGET_CLONE_GAMMA    41

// use these values for the "dwState" member of NVTWINVIEWDATA
#define NVTWINVIEW_STATE_NORMAL                  0
#define NVTWINVIEW_STATE_MULTIMON                1
#define NVTWINVIEW_STATE_CLONE                   2

// When the NVTWINVIEW_ACTION_SETGET_STATE escape is issued,
// a return of the following values in dwSuccess of NVTINWVIEWDATA
// indicates what is needed to make the state change happen.
#define NVTWINVIEW_STATE_CHANGE_FAILED          0
#define NVTWINVIEW_STATE_CHANGE_DONE            1
#define NVTWINVIEW_STATE_CHANGE_NEEDS_REBOOT    2

// use these values for the "dwAutoPan" member of NVTWINVIEW_AUTOPAN_DATA
#define NVTWINVIEW_VIRTUALDESKTOP_OFF            0
#define NVTWINVIEW_VIRTUALDESKTOP_ON             1

// use these values for the "dwState" member of NVTWINVIEWDATA
#define NVTWINVIEW_STATE_AUTO                    0
#define NVTWINVIEW_STATE_DMT                     1
#define NVTWINVIEW_STATE_GTF                     2

// use these values for the "ulTimingOverRide" field of NVTWINVIEW_DEVICE_TYPE_DATA. Used only in Win2K and NT4.0
#define TIMING_OVERRIDE_AUTO                    0
#define TIMING_OVERRIDE_DMT                     1
#define TIMING_OVERRIDE_GTF                     2

typedef struct {
unsigned long dwDeviceMask;        // A unique bitmask in a 32 bit Dword identifying
                                    // this specific output device. (as defined in NVCM.H)

   unsigned long dwDeviceType;      // Monitor, DFP, TV (as defined in NVCM.H)
   unsigned long dwTVFormat;        // Format for TV    (as defined in NVCM.H)
   unsigned long dwXRes;            // Horizontal resolution of secondary device in clone mode (in pixels). Used only by Win9X.
   unsigned long dwYRes;            // Vertical resolution of secondary device in clone mode (in Pixels). Used only by Win9X.
   unsigned long dwBpp;             // For Win9X: color depth of secondary device in clone mode (in Bits per pixel)
                                    // For Win2K/NT40: color depth of this head. The color depths of both heads will be the same.
   unsigned long dwRefresh;         // For Win9X: refresh rate of secondary device in clone mode (actual rate in Hz or 1 for "optimal" or 0 for "default")
                                    // For Win2K/NT40: refresh rate of this head (actual rate in Hz or 1 for "optimal" or 0 for "default"), the
                                    // refresh rates can be different for each head.

   // The following fields are applicable only for NT40 and Win2K. Win9X can ignore this.
   unsigned long dwNumPhysModes;    // The number of physical modes supported by the device. This list is obtained after
                                    // an intersection of EDID and the registry modes. If the device has no EDID, then this
                                    // list simply equals the registry modelist.
   unsigned long dwNumVirtualModes; // The number of virtual modes supported by the device. This list is obtained after
                                    // an intersection of registry modes and the board frame buffer size. 
   nvRECTL    PhysicalRectl;        // Physical coordinates of the device.
   nvRECTL    VirtualRectl;         // Virtual coordinates of the device.
   unsigned long dwEnableDDC; 
   unsigned long dwEnablePanScan;   // Enables the virtual desktop to let the physical resolution
                                    // to be less than the virtual resolution.
   unsigned long dwFreezePanScan;   // Freeze the pan-scan
   unsigned long dwFreezeOriginX;   // The user specified upper left corner for freezing the pan-scan.
   unsigned long dwFreezeOriginY;   // The user specified upper left corner for freezing the pan-scan.
   unsigned long dwTimingOverRide;  // GTF or DMT preference by the user.


} NVTWINVIEW_DEVICE_TYPE_DATA;

typedef struct {
   unsigned long dwVirtualDesktop;  // Virtual Desktop On/Off (clone mode only)
   unsigned long dwPad;
}  NVTWINVIEW_VIRTUALDESKTOP_DATA;

typedef struct {
   unsigned long dwFreezeOrigin;    // Freeze Origin On/Off (clone mode only)
   unsigned long dwOriginX;         // freeze mode x origin (clone mode only)
   unsigned long dwOriginY;         // freeze mode y origin (clone mode only)
}  NVTWINVIEW_FREEZE_ORIGIN_DATA;

typedef struct {
   unsigned long pHWCrtcCX;
   unsigned long pGNLogdevCX;
   unsigned long dwLogicalCrtcIndex;
   unsigned long dwPad;
}  NVTWINVIEW_LOCK_UNLOCK_HWCRTC_DATA;

typedef struct {
   unsigned long pHWCrtcCX;
   unsigned long pGNLogdevCX;
   unsigned long dwLogicalCrtcIndex;
   unsigned long dwPad;
}  NVTWINVIEW_SETGET_PHYSICAL_MODE_IMMEDIATE;




// The mode_entry structure is copied from miniport\nv_mini\nv.h. Anychanges in one file should be reflected
// in the other.
struct Mode_Entry
   {
   unsigned short  ValidMode;
   unsigned short  Width;
   unsigned short  Height;
   unsigned short  Depth;
   unsigned short  RefreshRate;
#ifndef WINNT
   unsigned short  wPad;
   unsigned long   dwPad;
#endif
   };
typedef struct Mode_Entry *PMODE_ENTRY, MODE_ENTRY;

// This is per head information
typedef struct {
   MODE_ENTRY * PhysModeEntries;         // Pointer to alloced memory for the physical mode list.
   unsigned long dwNumPhysModeEntries;   // The number of mode entries in the alloced memory for the physical mode list.
   MODE_ENTRY * VirtualModeEntries;         // Pointer to alloced memory for the physical mode list.
   unsigned long dwNumVirtualModeEntries;   // The number of mode entries in the alloced memory for the physical mode list.

   unsigned long dwDeviceMask;  // Return the modelist info for this deviceMask

   unsigned long dwDeviceType;  // Return the modelist info for this deviceType on this head
   unsigned long dwTVFormat;    // Return the modelist info for this TV format on this head
}  NVTWINVIEW_MODELIST_DATA;

// Values for the dwOrientation field
#define HORIZONTAL_ORIENTATION  1
#define VERTICAL_ORIENTATION    2


typedef struct {
   unsigned long dwFlag;            // flag indicating GET or SET
   unsigned long dwAction;          // indicates action to be performed
   unsigned long dwState;           // normal, multi-mon, clone
   unsigned long dwCrtc;            // indicates CRT number for which action is performed. Used only by Win9X.
                                    // The actions apply to all the heads in Win2K and NT40.
   unsigned long dwSuccess;         // indicates success of call. Driver should return non-zero in this member
                                    // if the escape is successfully handled, or zero for failure
   nvRECTL    DeskTopRectl;           // The overall desktop rectangle. The (left,top) is always (0, 0).
                                    // Applicable only for Win2K and NT40. Win9X can ignore it.
   unsigned long dwBoard;           // The board number in a multi-adapter system.
                                    // Applicable only for NT40. Win9X and Win2K can ignore it.
   unsigned long dwOrientation;     // Horizontal or vertical. For multi-mon mode only.
                                    // Applicable only for NT4.0 and Win2K. Win9x can ignore this.
   unsigned long dwDeviceDisplay[NV_NO_DACS]; // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
                                    // Applicable only for NT4.0 and Win2K. Win9x can ignore this.

   unsigned long dwAllDeviceMask;  // Bitmask for all the output device connectors in the board. NT4.0/Win2K only.
   unsigned long dwConnectedDeviceMask;  // Bitmask for all the output device connectors in the board. NT4.0/Win2K only.
                                    


   union {
       NVTWINVIEW_DEVICE_TYPE_DATA nvtwdevdata[NV_NO_DACS]; // use with action NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE and NVTWINVIEW_ACTION_SETGET_STATE (if
                                    // dwState == NVTWINVIEW_STATE_CLONE)

       NVTWINVIEW_VIRTUALDESKTOP_DATA    nvtwvirtualdesktopdata;  // use with action NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP

       NVTWINVIEW_FREEZE_ORIGIN_DATA nvtwfreezedata; // use with action NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN
                                      // Note: union is ignored for  and NVTWINVIEW_ACTION_SETGET_PRIMARY_CRTC and
                                      // NVTWINVIEW_ACTION_SETGET_STATE (if dwState != NVTWINVIEW_STATE_CLONE)

       NVTWINVIEW_MODELIST_DATA   nvtwModeListData[NV_NO_DACS]; // Applicable only for Win2K and NT40. Win9X can ignore it.
                                                    // Use with actions NVTWINVIEW_ACTION_SETGET_PHYS_MODELIST and
                                                    // NVTWINVIEW_ACTION_SETGET_GDI_MODELIST.
#ifndef WINNT
        unsigned long adwGammaTable[256];
#endif
   } NVTWINVIEWUNION;

   NVTWINVIEW_LOCK_UNLOCK_HWCRTC_DATA nvtwLockUnlockHwcrtc;
   NVTWINVIEW_SETGET_PHYSICAL_MODE_IMMEDIATE nvtwPhysicalModeImmediate;
} NVTWINVIEWDATA;


#ifdef __cplusplus
}
#endif

#endif // _nvPM_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvPusher.h ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPusher.h
//      routines for creating, destroying, and interacting with a push buffer
//
// **************************************************************************
//
//  History:
//      Ben DeWaal              07Apr1999         original code
//      Craig Duttweiler        05Apr2000         cleanup, consolidation,
//                                                and C++'ification
//
// **************************************************************************

#ifndef _NVPUSHER_H
#define _NVPUSHER_H

#include "nvUniversal.h"
#include "nv32.h"

// Having lots of problems finding a version of assert.h in all builds... so we do this for now. -mlavoie
#ifdef _DEBUG
#define nvAssert(expr) if (expr) _asm {int 3};
#else
#define nvAssert(expr)
#endif

#if (NVARCH < 0x04)

typedef void CPushBuffer;   // Not avail on NV3, but let's compile go through easier

#else // (NVARCH >= 0x04)

//---------------------------------------------------------------------------

// pusher debugging switches (available in retail builds too)

//#define _PC_PRINTPUT                      // print kick-offs (slow)
//#define _PC_PRINT                         // print important pusher transactions
//#define _PC_CHECK                         // check for push buffer problems
//#define _PC_BREAK                         // break at specific class (define CHECK also)
//#define _PC_FLUSH_ON_ADJUST               // force flush on every call to nvPusherAdjust
//#define _PC_CAPTURE_METHOD_DATA           // captures method data and allows you to view it (good to check object state)
//#define _PC_CAPTURE                       // writes contents of the the push buffer to a file

// debug switch logic

// for now we enable push buffer validation for all debug builds
#if defined(DEBUG) || defined(_PC_CAPTURE_METHOD_DATA) || defined(_PC_CAPTURE)
#define _PC_CHECK
#endif

// don't allow inline functions if we have certain other debug bits enabled
#undef _NO_INLINE
#if defined(DEBUG) || defined(_PC_PRINTPUT) || defined(_PC_PRINT) || defined(_PC_CHECK) || defined(_PC_BREAK)
#define _NO_INLINE
#endif
#if defined(_PC_FLUSH_ON_ADJUST) || defined(_PC_CAPTURE_METHOD_DATA) || defined(_PC_CAPTURE)
#define _NO_INLINE
#endif

//---------------------------------------------------------------------------

// pusher constants and macros

#define NVPUSHER_THRESHOLD_SIZE     128     // words of data always available (4 triangles)
#define NVPUSHER_MINIMUM            1024    // bytes of data for option kick-off

#define NVPUSHER_JUMP(offset)       (0x20000000 | (offset))
#define NVPUSHER_NOINC(method)      (0x40000000 | (method))
#define NVPUSHER_CALL(offset)       (0x00000002 | (offset))
#define NVPUSHER_RETURN()           (0x00020000)

//---------------------------------------------------------------------------

#ifdef _PC_CAPTURE

extern HANDLE hPusherFileBinary;
extern HANDLE hPusherFileAscii;
extern BOOL   bPusherCapture;

#define NV_PC_CAPTURE_BEGIN(filename)                                               \
{                                                                                   \
    char fullname[64];                                                              \
    nvSprintf (fullname, "%s.bin", filename);                                       \
    hPusherFileBinary = CreateFile (fullname,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);    \
    if (hPusherFileBinary == INVALID_HANDLE_VALUE) {                                \
        DPF ("NV_PC_CAPTURE_BEGIN: Binary file open failed");                       \
        nvAssert(0);                                                                  \
    }                                                                               \
    SetFilePointer (hPusherFileBinary, 0,0, FILE_END);                              \
    nvSprintf (fullname, "%s.txt", filename);                                       \
    hPusherFileAscii = CreateFile (fullname,GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);     \
    if (hPusherFileAscii == INVALID_HANDLE_VALUE) {                                 \
        DPF ("NV_PC_CAPTURE_BEGIN: Ascii file open failed");                        \
        nvAssert(0);                                                                  \
    }                                                                               \
    SetFilePointer (hPusherFileAscii, 0,0, FILE_END);                               \
    bPusherCapture = TRUE;                                                          \
}

#define NV_PC_CAPTURE_END                                                           \
{                                                                                   \
    if (bPusherCapture) {                                                           \
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);              \
        FlushFileBuffers (hPusherFileBinary);                                       \
        FlushFileBuffers(hPusherFileAscii);                                         \
        CloseHandle (hPusherFileBinary);                                            \
        CloseHandle (hPusherFileAscii);                                             \
        bPusherCapture = FALSE;                                                     \
    }                                                                               \
}

#endif

//---------------------------------------------------------------------------

// pusher aliases
// alias these to point to appropriate data for your particular implementation

// hw get
#define _pdwHWGet       ((volatile DWORD)(((Nv4ControlDma*)m_dwControlDMA)->Get))

// hw put
#define _pdwHWPut       ((volatile DWORD)(((Nv4ControlDma*)m_dwControlDMA)->Put))

// hw reference count
#define _pdwHWRef       ((volatile DWORD)(((Nv10ControlDma*)m_dwControlDMA)->Reference))

// true when HW is busy
#define _pbHWBusy       (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x400700))

// cache1 ownership: bits 0:4 give the channel that currently owns the cache
#define _ffCache1Push1  (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x003204))

// cache1 status: bit 4 is set when the cache is empty
#define _ffCache1Status (*(volatile DWORD *)(pDriverData->NvBaseFlat + 0x003214))

// true if we have KNI support
#define _hasKNI         (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)

// true if we have 3DNOW support
#define _has3DNOW       (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_3DNOW)

// true if we have SFENCE support
#define _hasSFENCE      (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_SFENCE)

//---------------------------------------------------------------------------

// pusher-related macros

// the if is to allow for a string of Function such as Flip(A->B), Clear(A), Blit(C), such that the Blit to C
// does not destroy the pending waitforflip on Clear(A).  We only wait on surfaces that are just becoming a
// target and not an arbitrary surface
#define nvPusherSignalWaitForFlip(fpVidMem, dwDDSFlags)          \
{                                                                \
    if (getDC()->flipPrimaryRecord.fpFlipFrom == (fpVidMem)) {   \
        getDC()->nvPusher.setSyncFlipFlag();                     \
        getDC()->nvPusher.setFlipSurface(fpVidMem);              \
        getDC()->nvPusher.setFlipSurfaceFlags(dwDDSFlags);       \
    }                                                            \
}

// i'd really rather see these eventually just be substituted, but i'll make that mess later
#define nvPushData(a,b)    getDC()->nvPusher.push(a,b)
#define nvPusherAdjust(a)  getDC()->nvPusher.adjust(a)
#define nvPusherStart(a)   getDC()->nvPusher.start(a)
#define nvPusherFlush(a)   getDC()->nvPusher.flush(a,0)     // 0 = FLUSH_WITH_DELAY

//---------------------------------------------------------------------------

#ifdef __cplusplus

// forward definitions

struct  _def_nv_d3d_context;
typedef _def_nv_d3d_context *PNVD3DCONTEXT;


//---------------------------------------------------------------------------


class CPushBuffer
{

private:

    // pusher flags
    const enum {
        PB_FLAG_VALID          = (1 << ( 0)),  // push buffer is allocated, context DMA is allocated, and channel is open
        PB_FLAG_CHANNEL_SYNC   = (1 << ( 1)),  // signal to sync other channels b4 put
        PB_FLAG_FLIP_SYNC      = (1 << ( 2))   // will wait for flip before writing put
    };

public:

    // flush modes
    const enum {
        FLUSH_WITH_DELAY       = 0,            // flush with a delays when polling    (detrimental to CPU performance)
        FLUSH_HEAVY_POLLING    = 1             // flush & poll hw as fast as possible (detrimental to HW performance)
    };

private:

    // members
    DWORD m_dwChannel;          // handle for channel used by this push buffer
    DWORD m_dwContextDMA;       // handle for context DMA
    DWORD m_dwContextDMASize;   // size of context dma allocated for this push buffer
    DWORD m_dwControlDMA;       // controlDMA structure for this channel
    DWORD m_dwPCIHeapHandle;    // pci heap handle (if any)
    DWORD m_dwPCIHeapBase;      // pci heap base (if any)
    DWORD m_dwDDGbl;            // the DDGbl with which allocated AGP memory is associated
    DWORD m_dwHeap;             // heap from which push buffer is allocated
    // bank
    DWORD m_dwBase;             // base of push buffer
    DWORD m_dwSize;             // size of push buffer
    DWORD m_dwPut;              // current put pointer
    DWORD m_dwPutLast;          // last put wrote to HW
    DWORD m_dwGet;              // cached get pointer
    DWORD m_dwThreshold;        // threshold value
    DWORD m_dwWrapCount;        // # of wrap arounds
    DWORD m_dwPad01[1];
    // bank
    DWORD m_dwFlipSurfaceAddr;  // what surface to wait on during getFrameStatus
    DWORD m_dwFlipSurfaceFlags; // DDS caps flags, identifying the type of surface
    DWORD m_dwFlags;            // pusher flags
    DWORD m_dwPad02[5];

public:

    inline DWORD getChannel           (void)            {   return (m_dwChannel);      }
    inline DWORD getContextDMA        (void)            {   return (m_dwContextDMA);   }

    inline DWORD getHeap              (void)            {   return (m_dwHeap);   }
    inline DWORD getBase              (void)            {   return (m_dwBase);   }
    inline DWORD getSize              (void)            {   return (m_dwSize);   }

    inline void  setPut               (DWORD dwPut)     {   m_dwPut = dwPut;    }
    inline DWORD getPut               (void)            {   return (m_dwPut);   }

    inline DWORD getThreshold         (void)            {   return (m_dwThreshold);   }
    inline DWORD getWrapCount         (void)            {   return (m_dwWrapCount);   }
    inline DWORD getRefCount          (void)            {   return (_pdwHWRef);       }

    inline void  setSyncFlipFlag      (void)            {   m_dwFlags |=  PB_FLAG_FLIP_SYNC;    }
    inline void  clearSyncFlipFlag    (void)            {   m_dwFlags &= ~PB_FLAG_FLIP_SYNC;    }
    inline void  setSyncChannelFlag   (void)            {   m_dwFlags |=  PB_FLAG_CHANNEL_SYNC; }
    inline void  clearSyncChannelFlag (void)            {   m_dwFlags &= ~PB_FLAG_CHANNEL_SYNC; }

    inline void  setFlipSurface       (DWORD dwAddr)    {   m_dwFlipSurfaceAddr = dwAddr;   }
    inline void  setFlipSurfaceFlags  (DWORD dwFlags)   {   m_dwFlipSurfaceFlags = dwFlags;   }

    inline BOOL  isValid              (void)            {   return ((m_dwFlags & PB_FLAG_VALID) ? TRUE : FALSE);   }
    inline void  invalidate           (void)            {   m_dwFlags &= ~PB_FLAG_VALID;   }

    // prototypes for functions in nvPusher.cpp

           BOOL  allocate             (DWORD dwChannel, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
           BOOL  free                 (void);

           void  start                (BOOL bRequired);                     // kick off
           void  flush                (BOOL bWaitForHWIdle, DWORD dwMode);  // kick off & wait for idle
           void  resetPut             (void);                               // set put to base & read get
           BOOL  isIdle               (BOOL bCheckHWAlso);                  // check if idle
           void  waitForOtherChannels (void);                               // idle other channels
           void  makeSpace            (DWORD dwCount);                      // makes space for large transfers (use inc instead of adjust)

    #ifdef _NO_INLINE

           void  push                 (DWORD dwOffset, DWORD dwData);
           BOOL  adjust               (DWORD dwCount);
           void  inc                  (DWORD dwCount);

    #else  // !_NO_INLINE

    FORCE_INLINE void  push           (DWORD dwOffset, DWORD dwData)
                {
                    ((DWORD*)m_dwPut)[dwOffset] = dwData;
                };

    FORCE_INLINE BOOL  adjust         (DWORD dwCount)
                {   m_dwPut += ((dwCount) << 2);
                    if (m_dwPut >= m_dwThreshold) {
                        return getSpace();
                    }
                    return FALSE;
                }
    FORCE_INLINE void  inc            (DWORD dwCount)
                {
                    m_dwPut += ((dwCount) << 2);
                }

    #endif  // !_NO_INLINE

    inline void setObject(NvU32 subChannel,NvU32 objId)
    {
        nvAssert((subChannel >= 0) && (subChannel<=7));
        nvAssert(objId != 0);
        push(0, (subChannel << 13) | 0x40000);
        push(1, objId);
        adjust(2);
    }
private:

    // prototypes for functions in nvPusher.cpp

    inline void    setChannel         (DWORD dwChannel)                 {   m_dwChannel    = dwChannel;
                                                                            m_dwContextDMA = dwChannel+1;   }

           void    setBase            (DWORD dwBase);   // set buffer base
           void    setSize            (DWORD dwSize);   // set buffer size

           BOOL    allocateMemory     (LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
           BOOL    freeMemory         (void);
           BOOL    allocateContextDMA (void);
           BOOL    freeContextDMA     (void);
           BOOL    openChannel        (void);
           BOOL    closeChannel       (void);

           FLATPTR getfpVidMem        (void);           // FLATPTR of pusher base

    inline void    syncAndFlushWC     (void);
           void    kickOff            (void);

           BOOL    getSpace           (void);
           BOOL    calcThreshold      (void);           // read get
           void    wrapAround         (void);

    #ifdef _PC_CHECK
           BOOL    validate           (DWORD dwStart, DWORD dwEnd);
    #endif
    #ifdef _PC_CAPTURE_METHOD_DATA
           DWORD   parseMethod        (DWORD dwAddress);
           void    captureState       (DWORD dwSubChannel);
    #endif

public:

    // creation and destruction

    inline         CPushBuffer        (void)            {   memset (this, 0, sizeof(*this));  }
    inline        ~CPushBuffer        (void)            {}

    // friends

    friend void    nvCelsiusILCompile_beginEnd        (DWORD dwPrimType);
    friend DWORD   nvCelsiusILCompile_inline_prim     (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_inline_tri_list (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_super_tri_list  (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvCelsiusILCompile_vb_prim         (PNVD3DCONTEXT pContext, DWORD dwFlags);

    //friend void    nvKelvinILCompile_beginEnd         (DWORD dwPrimType);
    friend DWORD   nvKelvinILCompile_inline_prim      (PNVD3DCONTEXT pContext, DWORD dwFlags);
    //friend DWORD   nvKelvinILCompile_inline_tri_list  (PNVD3DCONTEXT pContext, DWORD dwFlags);
    //friend DWORD   nvKelvinILCompile_super_tri_list   (PNVD3DCONTEXT pContext, DWORD dwFlags);
    friend DWORD   nvKelvinILCompile_vb_prim          (PNVD3DCONTEXT pContext, DWORD dwFlags);

};

#else  // !cplusplus

typedef struct _CPushBuffer
{
    // members
    DWORD m_dwChannel;          // handle for channel used by this push buffer
    DWORD m_dwContextDMA;       // handle for context DMA
    DWORD m_dwContextDMASize;   // size of context dma allocated for this push buffer
    DWORD m_dwControlDMA;       // controlDMA structure for this channel
    DWORD m_dwPCIHeapHandle;    // pci heap handle (if any)
    DWORD m_dwPCIHeapBase;      // pci heap base (if any)
    DWORD m_dwDDGbl;            // the DDGbl with which allocated AGP memory is associated
    DWORD m_dwHeap;             // heap from which push buffer is allocated
    // bank
    DWORD m_dwBase;             // base of push buffer
    DWORD m_dwSize;             // size of push buffer
    DWORD m_dwPut;              // current put pointer
    DWORD m_dwPutLast;          // last put wrote to HW
    DWORD m_dwGet;              // cached get pointer
    DWORD m_dwThreshold;        // threshold value
    DWORD m_dwWrapCount;        // # of wrap arounds
    DWORD m_dwPad01[1];
    // bank
    DWORD m_dwFlipSurfaceAddr;  // what surface to wait on during getFrameStatus
    DWORD m_dwFlipSurfaceFlags; // DDS caps flags, identifying the type of surface
    DWORD m_dwFlags;            // pusher flags
    DWORD m_dwPad02[5];
} CPushBuffer;

#endif  // !cplusplus

#endif  // (NVARCH >= 0x04)

#undef nvAssert

#endif  //!_NVPUSHER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\StereoDDK.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: StereoDDK.h                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/02/00  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef _STEREO_DDK_H_
#define _STEREO_DDK_H_

/*
 * Bit flags defining supported stereo viewing formats.
 */
#define SVF_NONE                0
#define SVF_OVERANDUNDER        0x00000001
#define SVF_FRAMESEQUENTIAL     0x00000002
#define SVF_MULTIMONITOR        0x00000004
#define SVF_LEFTANDRIGHT        0x00000008
#define SVF_LINEINTERLEAVE      0x00000010

/*
 * Activation Methods.
 */
#define SAM_VRAMPATTERN         0x00000001
#define SAM_DDC                 0x00000002
#define SAM_MANUAL              0x00000004

typedef DWORD   (WINAPI *LPDEACTIVATESTEREO)(void);

typedef struct _GraphicsServices_s
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDEACTIVATESTEREO  DeactivateStereo;
} GRAPHICSSERVICES, *LPGRAPHICSSERVICES;

typedef DWORD   (FAR PASCAL *LPONFLIP)(void);

typedef struct _StereoViewerServices_s
{
    DWORD            dwSize;
    DWORD            dwFlags;
    LPONFLIP         OnFlip;
} STEREOVIEWERSERVICES, *LPSTEREOVIEWERSERVICES;

/*
 * Bits defining valid fields in the StereoCaps structure.
 */
#define STEREOCAPS_SUPPORTEDFORMATS     0x00000001
#define STEREOCAPS_PREFERREDFORMAT      0x00000002
#define STEREOCAPS_MINREFRESHRATE       0x00000004
#define STEREOCAPS_MAXREFRESHRATE       0x00000008
#define STEREOCAPS_ACTIVATIONMETHOD     0x00000010
#define STEREOCAPS_SERVICECALLBACKS     0x00000020

typedef struct StereoCaps
{
    DWORD dwSize;               //Indicates the version both ways.
    DWORD dwFlags;              //Indicates the valid fields both ways.
    DWORD dwSupportedFormats;
    DWORD dwPreferredFormat;
    WORD  dwMinRefreshRate;
    WORD  dwMaxRefreshRate;
    DWORD dwActivationMethod;
    union 
    {
        LPGRAPHICSSERVICES       pGraphicsServices;    
        LPSTEREOVIEWERSERVICES   pStereoViewerServices;
    };
} STEREOCAPS, *LPSTEREOCAPS;

#ifdef __cplusplus

typedef class CStereoViewer
{
    /*
     * methods
     */
public:
    virtual DWORD WINAPI DestroyStereoViewer(void);
	virtual DWORD WINAPI GetCaps(LPSTEREOCAPS);
    virtual DWORD WINAPI ActivateStereo(LPDDHALMODEINFO pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
    virtual DWORD WINAPI DeactivateStereo(LPDDHALMODEINFO pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
} STEREOVIEWER, *LPSTEREOVIEWER;

#else   //__cplusplus==0

typedef struct CStereoViewer
{
    struct  CStereoViewerVtbl FAR *lpVtbl;
} STEREOVIEWER, *LPSTEREOVIEWER;

struct  CStereoViewerVtbl {
    DWORD (WINAPI *DestroyStereoViewer)(LPSTEREOVIEWER);
	DWORD (WINAPI *GetCaps)(LPSTEREOVIEWER, LPSTEREOCAPS);
    DWORD (WINAPI *ActivateStereo)(LPSTEREOVIEWER, LPVOID pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
    DWORD (WINAPI *DeactivateStereo)(LPSTEREOVIEWER, LPVOID pVideoMode, LPVOID pScreenAddr, DWORD StereoFormat);
};

#endif  //__cplusplus==0


typedef DWORD (WINAPI *LPCREATESTEREOVIEWER)(LPSTEREOVIEWER *);

#define _FACSTEREO  (*(WORD *)"NV")
#define MAKE_STEREOHRESULT( code )  MAKE_HRESULT( 1, _FACSTEREO, code )

/*
 * Error codes
 */
#define STEREO_OK                               0
#define STEREO_UNSUPPORTED_STEREO_FORMAT        MAKE_STEREOHRESULT(1)
#define STEREO_UNSUPPORTED_VIDEO_MODE           MAKE_STEREOHRESULT(2)
#define STEREO_UNSUPPORTED_REFRESHRATE          MAKE_STEREOHRESULT(3)
#define STEREO_INVALID_PARAMETERS               MAKE_STEREOHRESULT(4)
#define STEREO_HARDWARE_NOT_FOUND               MAKE_STEREOHRESULT(5)
#define STEREO_UNKNOWN_ERROR                    MAKE_STEREOHRESULT(6)

#endif  //_STEREO_DDK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\targa.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: targa.h
//      header files for targa.c
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Jun00         filched from architects
//
// **************************************************************************

#ifndef __TARGA_H
#define __TARGA_H

typedef char int8;
typedef int int16;
typedef int int32;
typedef unsigned char uint8;
typedef unsigned int uint16;
typedef unsigned int uint32;

/* Header definition. */
typedef struct TGA_Header_  {
    unsigned char ImageIDLength;        /* length of Identifier String. */
    unsigned char CoMapType;            /* 0 = no map */
    unsigned char ImgType;              /* image type (see below for values) */
    unsigned char Index_lo, Index_hi;   /* index of first color map entry */
    unsigned char Length_lo, Length_hi; /* number of entries in color map */
    unsigned char CoSize;               /* size of color map entry (15,16,24,32) */
    unsigned char X_org_lo, X_org_hi;   /* x origin of image */
    unsigned char Y_org_lo, Y_org_hi;   /* y origin of image */
    unsigned char Width_lo, Width_hi;   /* width of image */
    unsigned char Height_lo, Height_hi; /* height of image */
    unsigned char PixelSize;            /* pixel size (8,16,24,32) */
    unsigned char Desc;         /* 4 bits, number of attribute bits per pixel */
} TGA_Header;

/* if we create the tga file, we will put the following in the ImageID field */
typedef struct TGA_ImageId_ {
        unsigned char Magic;            /* must be a specific magic value */
        unsigned char ImageFmt;         /* encodes special raster formats */
} TGA_ImageId;

/* Definitions for image types. */
#define TGA_NULL 0
#define TGA_MAP 1
#define TGA_RGB 2
#define TGA_MONO 3
#define TGA_RLEMAP 9
#define TGA_RLERGB 10
#define TGA_RLEMONO 11

#define TGA_DESC_ALPHA_MASK     ((unsigned char)0xF)    /* number of alpha channel bits */
#define TGA_DESC_ORG_MASK       ((unsigned char)0x30)   /* origin mask */
#define TGA_ORG_BOTTOM_LEFT     0x00
#define TGA_ORG_BOTTOM_RIGHT    0x10
#define TGA_ORG_TOP_LEFT        0x20
#define TGA_ORG_TOP_RIGHT       0x30har)0x30)   /* origin mask */
#define TGA_ORG_BOTTOM_LEFT     0x00
#define TGA_ORG_BOTTOM_RIGHT    0x10

#define TGA_NVIDIA_MAGIC        0xAF            /* not an ascii char so unlikely... */

typedef enum RasterFormat_ {
/* WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 * **** The RasterFormat defs _must_ be identical to the defs in vmodels/rasterDefs.vh ***
 * **** Do not change this enum without also updating rasterDefs.vh!                   ***
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING */
        RASTER_A1R5G5B5 = 0,
        RASTER_X1R5G5B5 = 1,
        RASTER_A4R4G4B4 = 2,
        RASTER_R5G6B5 = 3,
        RASTER_A8R8G8B8 = 4,
        RASTER_X8R8G8B8 = 5,
        RASTER_Y8 = 6,
        RASTER_V8YB8U8YA8 = 7,
        RASTER_YB8V8YA8U8 = 8,
        RASTER_A8V8U8Y8 = 9,                    // A8Y8U8V8 was incorrect channel ordering, name changed
        RASTER_A4V6YB6A4U6YA6 = 10,
        RASTER_AY8 = 11,
        RASTER_Z16 = 12,                                // 16 bit Z/W buffer
        RASTER_Z24S8 = 13,                              // 24 bit Z/W plus 8 bit stencil in low 8 bits
// additional non-Nvidia formats for ease of use with tga
        RASTER_VOID32 = 100,                    // generic 32 bits/pixel format
        RASTER_R8G8B8 = 101,                    // 24 bits/pixel
        RASTER_VOID16 = 102,                    // generic 16 bits/pixel format
        RASTER_FORCELONG = 0x7FFFFFFFL  // force this enum to be a long
} RasterFormat;

// Read targa file "filename"
// Put pixels into **xbgr, and set *width and *height
// Pixels are xbgr words on the PC
// This routine copes with raw RGB and run-length encoded RGB targa files only

int read_targa_file(char *filename, unsigned char **xrgb, int *width, int *height);

#endif  // __TARGA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvReg.h ===
/*
 * nvReg.h
 *
 * Registry keys and functions for the NVIDIA drivers
 *
 * Copyright (c) 1997-1999, NVIDIA Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/* Note to OEMs:
   Please leave these strings intact.  There are utilities published on the
   net which let users edit these registry keys, and the utils expect the
   values to be in this location.  It will also allow us to occasionally post
   messages in RIVA-related web sites discussing how these values can affect
   performance and quality.  Thanks!
*/

//*****************************************************************************
// ----------------------------  NOTE  ----------------------------------------
//
// Only #define constants belong in this file.  This file is used for other
// operating systems besides Windows and should be kept clean of Windows
// specific types.
//
// ----------------------------------------------------------------------------
//*****************************************************************************


//-----------------------------------------------------------------------------
// Base
//-----------------------------------------------------------------------------

#define NV_MAX_REG_KEYNAME_LEN 256

#define NV04_REG_PRODUCT_NAME                   "RIVA TNT"
#define NV10_REG_PRODUCT_NAME                   "GeForce 256"
#define NV10GL_REG_PRODUCT_NAME                 "Quadro"

//  There are keys which are global and apply to all NVidia boards in a
//  system and those keys which are board specific. The global keys all
//  use the following path as a base:
#define NV4_REG_GLOBAL_BASE_KEY     HKEY_LOCAL_MACHINE
#define NV4_REG_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global"

//  For each sub-system, the following key should be tacked onto the
//  GLOBAL_BASE_PATH given above and specific registry values for that
// sub-system placed inside the resulting key.
#define NV4_REG_SUBKEY                  "NVidia"
#define NV4_REG_DISPLAY_DRIVER_SUBKEY   "Display"
#define NV4_REG_DIRECT_DRAW_SUBKEY      "DirectDraw"
#define NV4_REG_DIRECT3D_SUBKEY         "Direct3D"
#define NV4_REG_RESOURCE_MANAGER_SUBKEY "System"
#define NV4_REG_OGL_SUBKEY              "OpenGL"
#define NV4_REG_OGL_DEBUG_SUBKEY        "OpenGL\\Debug"
#define NV4_REG_CONTROL_PANEL_SUBKEY    "NVTweak"
#define NV4_REG_DESKTOP_MANAGER_SUBKEY  "NVDesk"
#define NV4_REG_MEDIA_PORT_SUBKEY       "MediaPort"
#define NV4_REG_STEREO_SUBKEY           "Stereo3D"

// For the board specific keys (also called "local" keys), the registry
// path must be run-time determined. An escape has been added to the
// display driver to return a registry path string. Each instance of the
// display driver in a multi-mon system will return a different
// registry path that is specific to the board/slot/device, etc. You
// should use this as the base path for local keys and, as with the
// global keys, tack on one of the above sub-system strings and then
// place your registry values in the resulting key. The escape to
// return the local base path is defined in
// ...drivers\common\win9x\inc\escape.h

//-----------------------------------------------------------------------------
// Display Driver
//-----------------------------------------------------------------------------

// These may be used by many labels
#define NV4_REG_DRV_TRUE                         "1"
#define NV4_REG_DRV_FALSE                        "0"

// This is for QA, so that any mode can be set.
#define NV4_REG_DRV_ALLOW_ALL_MODES             "AllowAllModes"

// This tells what the boot device will be.
#define NV4_REG_DRV_BOOT_DEVICE_TYPE            "ForcedBootDeviceType"

// This tells us whether to use the RM or the reg for getting a
// forced boot device type.
#define NV4_REG_DRV_USE_HW_SELECTED_DEVICE      "UseHwSelectedDevice"

// The physical device attachments are given as PhysicalDevice0,
// PhysicalDevice1, etc. This is the base string.
#define NV4_REG_DRV_PHYSICAL_DEVICE             "PhysicalDevice"

// The following reg keys are string values which always look like
// "xres,yres,bpp"  e.g. "1024,768,16"
#define NV4_REG_DRV_FORCED_DESKTOP_MODE         "ForcedDesktopMode"
#define NV4_REG_DRV_LAST_DESKTOP_MODE           "LastDesktopMode"


// This keeps track of the last tv format
#define NV4_REG_DRV_LAST_TV_FORMAT              "LastTVFormat"

// These are possible values for the LastTVFormat
#define NV4_REG_DRV_NTSCM_TVFORMAT              "NTSCM"
#define NV4_REG_DRV_NTSCJ_TVFORMAT              "NTSCJ"
#define NV4_REG_DRV_PALM_TVFORMAT               "PALM"
#define NV4_REG_DRV_PALA_TVFORMAT               "PALA"
#define NV4_REG_DRV_PALN_TVFORMAT               "PALN"
#define NV4_REG_DRV_PALNC_TVFORMAT              "PALNC"

// The following reg keys are string values which always look like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// These are local keys.
#define NV4_REG_DRV_LAST_CRT_MODE               "LastCRTMode"
#define NV4_REG_DRV_LAST_DFP_MODE               "LastDFPMode"
#define NV4_REG_DRV_LAST_NTSCM_MODE             "LastNTSCMMode"
#define NV4_REG_DRV_LAST_NTSCJ_MODE             "LastNTSCJMode"
#define NV4_REG_DRV_LAST_PALM_MODE              "LastPALMMode"
#define NV4_REG_DRV_LAST_PALA_MODE              "LastPALAMode"
#define NV4_REG_DRV_LAST_PALN_MODE              "LastPALNMode"
#define NV4_REG_DRV_LAST_PALNC_MODE             "LastPALNCMode"

// The following reg keys are string values which always look like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// These are local keys.
#define NV4_REG_DRV_FORCED_MODE                 "ForcedMode"
#define NV4_REG_DRV_LAST_MODE                   "LastMode"

// The following registry values are used when the user requests adapter
// default refresh rate. They are all string values which look like:
// "60" or "75" etc. If the keys do not exist, the adapter default value
// is obtained in another way.
// These are local keys.
#define NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE   "DefaultCRTRefreshRate"
#define NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE   "DefaultDFPRefreshRate"

// The following registry values are used when the user requests optimal
// refresh rate. They are all string values which look like:
// "60" or "75" etc. If the keys do not exist, the optimal refresh value
// is obtained in another way.
// These are local keys.
#define NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE   "OptimalCRTRefreshRate"
#define NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE   "OptimalDFPRefreshRate"

// This registry value is used to override the timing standard used
// for the monitor.
#define NV4_REG_DRV_MONITOR_TIMING                  "MonitorTiming"
#define NV4_REG_DRV_MONITOR_TIMING_DMT              "DMT"
#define NV4_REG_DRV_MONITOR_TIMING_GTF              "GTF"

// This is used for the cursor alpha amount
#define NV4_REG_DRV_CURSOR_ALPHA                    "CursorAlpha"

// The following key is used to indicate that the driver should
// read the EDID and use it. It is a string value and the
// possible options are "0" and "1".
#define NV4_REG_DRV_FORCE_EDID_READ                 "ForceEdidRead"

// The following reg key ius a string value which always looks like
// "xres,yres,bpp,refresh_rate"  e.g. "1024,768,16,75"
// It is a local key. It gives the highest permissable mode when
// their is no EDID and no INF installed for the monitor.
#define NV4_REG_DRV_MONITOR_LIMIT_MODE              "NoEdidNoInfLimitMode"

// The RestrictOptimal key causes the modeset DLL to look for an
// exact Xres,Yres match with an EDID mode. If one exists, then
// that refresh rate will be the one used. If not, then other
// logic determines the refresh rate. The possible values are
// NV4_REG_DRV_TRUE or NV4_REG_DRV_FALSE
#define NV4_REG_DRV_USE_REFRESH_RATE_OF_XYRES_EDID_MODE_MATCH   "RestrictOptimal"

// These are erased by the driver at boot time.
#define POWERUPFLAGS                                "PowerUpFlags"

// These are used by the driver for dual-head support
#define NV4_REG_DRV_VIRTUALDESKTOP                  "VirtualDesktop"
#define NV4_REG_DRV_AUTOPANMODE                     "AutoPanMode"

// This key is read to indicate whether we should run single monitor,
// multimon or clone mode.
#define NV4_REG_DRV_DESKTOPSTATE                    "DesktopState"
#define NV4_REG_DRV_DESKTOP_STATE_NORMAL            "Single"
#define NV4_REG_DRV_DESKTOP_STATE_MULTI_MON         "Multi"
#define NV4_REG_DRV_DESKTOP_STATE_CLONE             "Clone"


//-----------------------------------------------------------------------------
// DirectDraw
//-----------------------------------------------------------------------------

// default is enabled, define and set to zero to disable
#define NV4_REG_VPE_ENABLE              "VPEENABLE"

// EnumDDRefresh (default = 0)
//      0 = do not enumerate refresh rates
//      1 = only enumerate refresh rates of modes above 640x480
//      2 = enumerate all refresh rates
#define NV4_REG_ENUM_REFRESH                "EnumDDRefresh"
#define   NV4_REG_ENUM_REFRESH_DISABLE      0
#define   NV4_REG_ENUM_REFRESH_ENABLEBIG    1
#define   NV4_REG_ENUM_REFRESH_ENABLEALL    2

// all the overlay settings are local

// OverlayMode (default = 0)
//      0 = always use overlay upscale
//      1 = use vertical blt upscale if sufficient resources
//      2 = use temporal filter
//      3 = this is not the first frame (gets autoset after 1 frame)
//      8-15 = temporal filter factor
#define NV4_REG_OVL_MODE                "OverlayMode"
#define   NV4_REG_OVL_MODE_VUPSCALE     0x1
#define   NV4_REG_OVL_MODE_TFILTER      0x2
#define   NV4_REG_OVL_MODE_NOTFIRST     0x4
#define   NV4_REG_OVL_MODE_TF_PRECOPY   0x8
#define   NV4_REG_OVL_MODE_LATEFLIPSYNC 0x10
#define   NV4_REG_OVL_MODE_DFILTER      0x20
#define   NV4_REG_OVL_MODE_DF_PRECOPY   0x40
#define   NV4_REG_OVL_MODE_TFACTOR      15:8
#define   NV4_REG_OVL_MODE_DFACTOR      23:16

// OverlayMode2 (default = 0)
//   bits 0-3 = Full screen mirror device number (1 based, zero means disable)
//      bit 4 = Preserve aspect in full screen mirror mode
//      bit 5 = Fix aspect ratio to 16:9, bit 4 must be set also
//      bit 6 = Track aspect ratio of overlay, bit 4 must be set also
//      bit 7 = Fix aspect ratio to 4:3, bit 4 must also be set
//      bits 8-11 = Video zoom quadrant
//                  0: zoom disabled
//                  1: top left quadrant
//                  2: top right quadrant
//                  3: bottom left quadrant
//                  4: bottom right quadrant
//                  5: center
//      bits 12-23 = Video zoom factor, 0 = 1x, 255 = 2x
//      bit 24 = Let the driver pick the full screen display mode
//      bit 25 = Track overlay zoom
//      bit 26 = Enable TV devices
#define NV4_REG_OVL_MODE2                       "OverlayMode2"
#define     NV4_REG_OVL_MODE2_FSMASK            0x007FFFFF
#define     NV4_REG_OVL_MODE2_FSDEVICEMASK      0x0000000F
#define     NV4_REG_OVL_MODE2_FSASPECTMASK      0x000000F0
#define     NV4_REG_OVL_MODE2_FSZOOMQUADMASK    0x00000F00
#define     NV4_REG_OVL_MODE2_FSZOOMFACTORMASK  0x000FF000
#define     NV4_REG_OVL_MODE2_FSDEVICE          0:3
#define     NV4_REG_OVL_MODE2_FSASPECT          0x00000010
#define     NV4_REG_OVL_MODE2_FSFIXEDANIMORPHIC 0x00000020
#define     NV4_REG_OVL_MODE2_FSTRACKOVLASPECT  0x00000040
#define     NV4_REG_OVL_MODE2_FSFIXEDTV         0x00000080
#define     NV4_REG_OVL_MODE2_FSZOOMQUAD        8:11
#define     NV4_REG_OVL_MODE2_FSZOOMFACTOR      12:23
#define     NV4_REG_OVL_MODE2_FSSETMODE         0x00100000
#define     NV4_REG_OVL_MODE2_FSTRACKOVLZOOM    0x00200000
#define     NV4_REG_OVL_MODE2_FSENABLETV        0x00400000

// OverlayMode3 (default = 0);
//   bits 8-11 = Overlay zoom quadrant
//               0: zoom disabled
//               1: top left quadrant
//               2: top right quadrant
//               3: bottom left quadrant
//               4: bottom right quadrant
//               5: center
//   bits 12-23: Overlay zoom factor, 0 = 1x, 255 = 2x
#define NV4_REG_OVL_MODE3                       "OverlayMode3"
#define     NV4_REG_OVL_MODE3_OVLZOOMMASK       0x000FFF00
#define     NV4_REG_OVL_MODE3_OVLZOOMQUADMASK   0x00000F00
#define     NV4_REG_OVL_MODE3_OVLZOOMFACTORMASK 0x000FF000
#define     NV4_REG_OVL_MODE3_OVLZOOMQUAD       8:11
#define     NV4_REG_OVL_MODE3_OVLZOOMFACTOR     12:23

// VPPInvMask (default = 0)
//      Inverse mask for all VPP function enables.  Should exactly match
//      command flags defined in ddVPP.h
#define NV4_REG_VPP_INV_MASK                "VPPInvMask"
#define   NV4_REG_VPP_INV_MASK_ODD          0x1
#define   NV4_REG_VPP_INV_MASK_EVEN         0x2
#define   NV4_REG_VPP_INV_MASK_BOB          0x4
#define   NV4_REG_VPP_INV_MASK_INTERLEAVED  0x8
#define   NV4_REG_VPP_INV_MASK_VIDEOPORT    0x10
#define   NV4_REG_VPP_INV_MASK_WAIT         0x20
#define   NV4_REG_VPP_SAVE_STATE_DISABLE    0x40
#define   NV4_REG_VPP_RESTORE_STATE_DISABLE 0x80
#define   NV4_REG_VPP_CONVERT_DISABLE       0x100
#define   NV4_REG_VPP_SUBPICTURE_DISABLE    0x200
#define   NV4_REG_VPP_PRESCALE_DISABLE      0x400
#define   NV4_REG_VPP_COLOURCONTROL_DISABLE 0x800
#define   NV4_REG_VPP_TEMPORAL_DISABLE      0x1000
#define   NV4_REG_VPP_OPTIMIZEFLIP_DISABLE  0x2000
#define   NV4_REG_VPP_DEINTERLACE_DISABLE   0x4000
#define   NV4_REG_VPP_FSMIRROR_DISABLE      0x8000
#define   NV4_REG_VPP_DMABLIT_DISABLE       0x10000
#define   NV4_REG_VPP_MASTER_DISABLE        0x80000000

// VPPMaxSurfaces
//      Determines the maximum number of work surfaces VPP is allowed to use.
//      Legal values are:
//          6 - Full functionality and performance
//          4 - Full functionality, no superpipelining
//          3 - One stage allowed, superpipelined
//          2 - One stage allowed, no superpipelining
//          0 - VPP disabled
#define NV4_REG_VPP_MAX_SURFACES            "VPPMaxSurfaces"

// OverlayColorControlEnable (default = 0)
//      0 = disable
//      1 = enable with vertical chroma subsampling enabled (use this one)
//      2 = enable with vertical chroma subsampling disabled
// OverlayBrightness (default = 0)
// OverlayContrast (default = 100)
// OverlayHue (default = 0)
// OverlaySaturation (default = 100)
// OverlayGamma (not implemented)
// OverlaySharpness (not implemented)
#define NV4_REG_OVLCC_ENABLE            "OverlayColorControlEnable"
#define NV4_REG_OVLCC_BRIGHTNESS        "OverlayBrightness"
#define NV4_REG_OVLCC_CONTRAST          "OverlayContrast"
#define NV4_REG_OVLCC_HUE               "OverlayHue"
#define NV4_REG_OVLCC_SATURATION        "OverlaySaturation"
#define NV4_REG_OVLCC_GAMMA             "OverlayGamma"
#define NV4_REG_OVLCC_SHARPNESS         "OverlaySharpness"

#define NV4_REG_OVLCC_BRIGHTNESS_DEFAULT  0
#define NV4_REG_OVLCC_CONTRAST_DEFAULT    100
#define NV4_REG_OVLCC_HUE_DEFAULT         0
#define NV4_REG_OVLCC_SATURATION_DEFAULT  100


// VideoBusMasterMode (default = 0)
//      Determine which hacks to implement for bus mastering TV tuners (will not work on WINNT)
//      0 = No special hacks
//      1 = If no flips detected and 1 overlay surface, force into autoflip mode
//      2 = If 1 overlay surface, force autoflip
//      3 = Force autoflip
#define NV4_REG_VIDEO_BUS_MASTER_MODE   "VideoBusMasterMode"
#define   NV4_REG_VBMM_NOHACK           0
#define   NV4_REG_VBMM_DETECT           1
#define   NV4_REG_VBMM_SINGLEOVL        2
#define   NV4_REG_VBMM_FORCE            3

//-----------------------------------------------------------------------------
// Direct3D
//-----------------------------------------------------------------------------

// To add registry settings:
// 1. choose a category:
//    boolean, enumerated non-boolean, non-enumerated non-boolean, or string
// 2. add definitions as required for that category. make sure to include a definition
//    for the default value (and PLEASE ALPHABETIZE and use the same ordering for ALL
//    OF WHAT FOLLOWS!)
// 3. add a reg_entry to the definition of reg_struc in global.h
// 4. add the string to the initialization of reg_struc in global.cpp
// 5. add the default value to the initializations at the top of D3DReadRegistry()
// 6. add a routine to actually read and cache the registry value in D3DReadRegistry()

// ------------ Boolean enables / disables ------------------------------------

// Each boolean enable gets one bit in a control word.
#define D3D_REG_BIT_ALTERNATEZENABLE                    0
#define D3D_REG_BIT_ANTIALIASENABLE                     1
#define D3D_REG_BIT_ANTIALIASDYNAMICENABLE              2
#define D3D_REG_BIT_ANTIALIASFORCEENABLE                3
#define D3D_REG_BIT_CKCOMPATABILITYENABLE               5
#define D3D_REG_BIT_CONTROLTRAFFICENABLE                6
#define D3D_REG_BIT_DIRECTMAPENABLE                     8
#define D3D_REG_BIT_ENFORCESTRICTTRILINEAR              10
#define D3D_REG_BIT_FLUSHAFTERBLITENABLE                12
#define D3D_REG_BIT_FOGTABLEENABLE                      13
#define D3D_REG_BIT_FORCEBLITWAITFLAGENABLE             14
#define D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE            15
#define D3D_REG_BIT_LOGOENABLE                          17
#define D3D_REG_BIT_PALETTEENABLE                       18
#define D3D_REG_BIT_SQUASHWENABLE                       19
#define D3D_REG_BIT_SSYNCENABLE                         20
#define D3D_REG_BIT_TEXTURECOMPRESSIONENABLE            21
#define D3D_REG_BIT_TEXTUREMANAGEMENTENABLE             23
#define D3D_REG_BIT_TILINGENABLE                        24
#define D3D_REG_BIT_USERMIPMAPENABLE                    26
#define D3D_REG_BIT_VIDEOTEXTUREENABLE                  27
#define D3D_REG_BIT_WBUFFERENABLE                       28
#define D3D_REG_BIT_Z24ENABLE                           30
#define D3D_REG_BIT_ZCOMPRESSENABLE                     31

// ALTERNATEZENABLE
#define D3D_REG_ALTERNATEZENABLE_STRING                 "ALTERNATEZENABLE"
#define D3D_REG_ALTERNATEZENABLE_MASK                   (1 << D3D_REG_BIT_ALTERNATEZENABLE)
#define D3D_REG_ALTERNATEZENABLE_DISABLE                (0 << D3D_REG_BIT_ALTERNATEZENABLE)
#define D3D_REG_ALTERNATEZENABLE_ENABLE                 (1 << D3D_REG_BIT_ALTERNATEZENABLE)

// ANTIALIASENABLE
#define D3D_REG_ANTIALIASENABLE_STRING                  "ANTIALIASENABLE"
#define D3D_REG_ANTIALIASENABLE_MASK                    (1 << D3D_REG_BIT_ANTIALIASENABLE)         // Enable Anti-Aliasing support.
#define D3D_REG_ANTIALIASENABLE_DISABLE                 (0 << D3D_REG_BIT_ANTIALIASENABLE)         // Disable Anti-Aliasing support.
#define D3D_REG_ANTIALIASENABLE_ENABLE                  (1 << D3D_REG_BIT_ANTIALIASENABLE)         // Enable Anti-Aliasing support.

// ANTIALIASDYNAMICENABLE
#define D3D_REG_ANTIALIASDYNAMICENABLE_STRING           "ANTIALIASDYNAMICENABLE"
#define D3D_REG_ANTIALIASDYNAMICENABLE_MASK             (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Enable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE          (0 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Disable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE           (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)  // Enable Dynamic Anti-Aliasing support.

// ANTIALIASFORCEENABLE
#define D3D_REG_ANTIALIASFORCEENABLE_STRING             "ANTIALIASFORCEENABLE"
#define D3D_REG_ANTIALIASFORCEENABLE_MASK               (1 << D3D_REG_BIT_ANTIALIASFORCEENABLE)
#define D3D_REG_ANTIALIASFORCEENABLE_DISABLE            (0 << D3D_REG_BIT_ANTIALIASFORCEENABLE)
#define D3D_REG_ANTIALIASFORCEENABLE_ENABLE             (1 << D3D_REG_BIT_ANTIALIASFORCEENABLE)

// COLORKEYCOMPATIBILITYENABLE
#define D3D_REG_CKCOMPATABILITYENABLE_STRING            "COLORKEYCOMPATABILITYENABLE"
#define D3D_REG_CKCOMPATABILITYENABLE_MASK              (1 << D3D_REG_BIT_CKCOMPATABILITYENABLE)
#define D3D_REG_CKCOMPATABILITYENABLE_DISABLE           (0 << D3D_REG_BIT_CKCOMPATABILITYENABLE)
#define D3D_REG_CKCOMPATABILITYENABLE_ENABLE            (1 << D3D_REG_BIT_CKCOMPATABILITYENABLE)

// CONTROLTRAFFIC
#define D3D_REG_CONTROLTRAFFICENABLE_STRING             "CONTROLTRAFFIC"
#define D3D_REG_CONTROLTRAFFICENABLE_MASK               (1 << D3D_REG_BIT_CONTROLTRAFFICENABLE)
#define D3D_REG_CONTROLTRAFFICENABLE_DISABLE            (0 << D3D_REG_BIT_CONTROLTRAFFICENABLE)
#define D3D_REG_CONTROLTRAFFICENABLE_ENABLE             (1 << D3D_REG_BIT_CONTROLTRAFFICENABLE)

// DIRECTMAPENABLE
#define D3D_REG_DIRECTMAPENABLE_STRING                  "DIRECTMAPENABLE"
#define D3D_REG_DIRECTMAPENABLE_MASK                    (1 << D3D_REG_BIT_DIRECTMAPENABLE)
#define D3D_REG_DIRECTMAPENABLE_DISABLE                 (0 << D3D_REG_BIT_DIRECTMAPENABLE)
#define D3D_REG_DIRECTMAPENABLE_ENABLE                  (1 << D3D_REG_BIT_DIRECTMAPENABLE)

// ENFORCESTRICTTRILINEAR
#define D3D_REG_ENFORCESTRICTTRILINEAR_STRING           "ENFORCESTRICTTRILINEAR"
#define D3D_REG_ENFORCESTRICTTRILINEAR_MASK             (1 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)
#define D3D_REG_ENFORCESTRICTTRILINEAR_DISABLE          (0 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)
#define D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE           (1 << D3D_REG_BIT_ENFORCESTRICTTRILINEAR)

// FLUSHAFTERBLITENABLE
#define D3D_REG_FLUSHAFTERBLITENABLE_STRING              "FLUSHAFTERBLITENABLE"
#define D3D_REG_FLUSHAFTERBLITENABLE_MASK                (1 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)
#define D3D_REG_FLUSHAFTERBLITENABLE_DISABLE             (0 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)
#define D3D_REG_FLUSHAFTERBLITENABLE_ENABLE              (1 << D3D_REG_BIT_FLUSHAFTERBLITENABLE)

// FOGTABLEENABLE
#define D3D_REG_FOGTABLEENABLE_STRING                   "FOGTABLEENABLE"
#define D3D_REG_FOGTABLEENABLE_MASK                     (1 << D3D_REG_BIT_FOGTABLEENABLE)       // Enable Fog Table support
#define D3D_REG_FOGTABLEENABLE_DISABLE                  (0 << D3D_REG_BIT_FOGTABLEENABLE)       // Disable Fog Table support.
#define D3D_REG_FOGTABLEENABLE_ENABLE                   (1 << D3D_REG_BIT_FOGTABLEENABLE)       // Enable Fog Table support

// FORCEBLITWAITFLAGENABLE
#define D3D_REG_FORCEBLITWAITFLAGENABLE_STRING          "FORCEBLITWAITFLAGENABLE"
#define D3D_REG_FORCEBLITWAITFLAGENABLE_MASK            (1 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)
#define D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE         (0 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)
#define D3D_REG_FORCEBLITWAITFLAGENABLE_ENABLE          (1 << D3D_REG_BIT_FORCEBLITWAITFLAGENABLE)

// LIMITQUEUEDFBBLITSENABLE
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_STRING         "LIMITQUEUEDFBBLITSENABLE"
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_MASK           (1 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE        (0 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)
#define D3D_REG_LIMITQUEUEDFBBLITSENABLE_ENABLE         (1 << D3D_REG_BIT_LIMITQUEUEDFBBLITSENABLE)

// LOGOENABLE
#define D3D_REG_LOGOENABLE_STRING                       "LOGOENABLE"
#define D3D_REG_LOGOENABLE_MASK                         (1 << D3D_REG_BIT_LOGOENABLE)            // Enable NVIDIA logo
#define D3D_REG_LOGOENABLE_DISABLE                      (0 << D3D_REG_BIT_LOGOENABLE)            // Disable NVIDIA logo
#define D3D_REG_LOGOENABLE_ENABLE                       (1 << D3D_REG_BIT_LOGOENABLE)            // Enable NVIDIA logo

// PALETTEENABLE
#define D3D_REG_PALETTEENABLE_STRING                    "PALETTEENABLE"
#define D3D_REG_PALETTEENABLE_MASK                      (1 << D3D_REG_BIT_PALETTEENABLE)
#define D3D_REG_PALETTEENABLE_DISABLE                   (0 << D3D_REG_BIT_PALETTEENABLE)
#define D3D_REG_PALETTEENABLE_ENABLE                    (1 << D3D_REG_BIT_PALETTEENABLE)

// SQUASHW
#define D3D_REG_SQUASHW_STRING                          "SQUASHW"
#define D3D_REG_SQUASHW_MASK                            (1 << D3D_REG_BIT_SQUASHWENABLE)
#define D3D_REG_SQUASHW_DISABLE                         (0 << D3D_REG_BIT_SQUASHWENABLE)
#define D3D_REG_SQUASHW_ENABLE                          (1 << D3D_REG_BIT_SQUASHWENABLE)

// SSYNCENABLE
// This is a major hack to work around input lag in stupid applications that
// want to use blits instead of flips to do there screen updates but then don't
// make any getblitstatus calls to see if the blit has completed before beginning
// to render the next frame.
// This is not something that you want to have enabled unless you absolutely need
// to have it enabled.
#define D3D_REG_SSYNCENABLE_STRING                      "SCENESYNCENABLE"
#define D3D_REG_SSYNCENABLE_MASK                        (1 << D3D_REG_BIT_SSYNCENABLE)
#define D3D_REG_SSYNCENABLE_DISABLE                     (0 << D3D_REG_BIT_SSYNCENABLE)
#define D3D_REG_SSYNCENABLE_ENABLE                      (1 << D3D_REG_BIT_SSYNCENABLE)

// TEXTURECOMPRESSIONENABLE
#define D3D_REG_TEXTURECOMPRESSIONENABLE_STRING         "TEXTURECOMPRESSIONENABLE"
#define D3D_REG_TEXTURECOMPRESSIONENABLE_MASK           (1 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#define D3D_REG_TEXTURECOMPRESSIONENABLE_DISABLE        (0 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)
#define D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE         (1 << D3D_REG_BIT_TEXTURECOMPRESSIONENABLE)

// TEXTUREMANAGEMENTENABLE
#define D3D_REG_TEXTUREMANAGEMENTENABLE_STRING          "TEXTUREMANAGEMENTENABLE"
#define D3D_REG_TEXTUREMANAGEMENTENABLE_MASK            (1 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)
#define D3D_REG_TEXTUREMANAGEMENTENABLE_DISABLE         (0 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)
#define D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE          (1 << D3D_REG_BIT_TEXTUREMANAGEMENTENABLE)

// TILINGENABLE
#define D3D_REG_TILINGENABLE_STRING                     "TILINGENABLE"
#define D3D_REG_TILINGENABLE_MASK                       (1 << D3D_REG_BIT_TILINGENABLE)
#define D3D_REG_TILINGENABLE_DISABLE                    (0 << D3D_REG_BIT_TILINGENABLE)
#define D3D_REG_TILINGENABLE_ENABLE                     (1 << D3D_REG_BIT_TILINGENABLE)

// USERMIPMAPENABLE - enable User supplied mipmaps
#define D3D_REG_USERMIPMAPENABLE_STRING                 "USERMIPMAPENABLE"
#define D3D_REG_USERMIPMAPENABLE_MASK                   (1 << D3D_REG_BIT_USERMIPMAPENABLE)
#define D3D_REG_USERMIPMAPENABLE_DISABLE                (0 << D3D_REG_BIT_USERMIPMAPENABLE)
#define D3D_REG_USERMIPMAPENABLE_ENABLE                 (1 << D3D_REG_BIT_USERMIPMAPENABLE)

// VIDEOTEXTUREENABLE - enable texturing from video memory
#define D3D_REG_VIDEOTEXTUREENABLE_STRING               "VIDEOTEXTUREENABLE"
#define D3D_REG_VIDEOTEXTUREENABLE_MASK                 (1 << D3D_REG_BIT_VIDEOTEXTUREENABLE)
#define D3D_REG_VIDEOTEXTUREENABLE_DISABLE              (0 << D3D_REG_BIT_VIDEOTEXTUREENABLE)
#define D3D_REG_VIDEOTEXTUREENABLE_ENABLE               (1 << D3D_REG_BIT_VIDEOTEXTUREENABLE)

// WBUFFERING
#define D3D_REG_WBUFFERENABLE_STRING                    "WENABLE"
#define D3D_REG_WBUFFERENABLE_MASK                      (1 << D3D_REG_BIT_WBUFFERENABLE)
#define D3D_REG_WBUFFERENABLE_DISABLE                   (0 << D3D_REG_BIT_WBUFFERENABLE)
#define D3D_REG_WBUFFERENABLE_ENABLE                    (1 << D3D_REG_BIT_WBUFFERENABLE)

// Z24ENABLE
#define D3D_REG_Z24ENABLE_STRING                        "Z24ENABLE"
#define D3D_REG_Z24ENABLE_MASK                          (1 << D3D_REG_BIT_Z24ENABLE)
#define D3D_REG_Z24ENABLE_DISABLE                       (0 << D3D_REG_BIT_Z24ENABLE)
#define D3D_REG_Z24ENABLE_ENABLE                        (1 << D3D_REG_BIT_Z24ENABLE)

// ZCOMPRESSENABLE
#define D3D_REG_ZCOMPRESSENABLE_STRING                  "ZCOMPRESSENABLE"
#define D3D_REG_ZCOMPRESSENABLE_MASK                    (1 << D3D_REG_BIT_ZCOMPRESSENABLE)
#define D3D_REG_ZCOMPRESSENABLE_DISABLE                 (0 << D3D_REG_BIT_ZCOMPRESSENABLE)
#define D3D_REG_ZCOMPRESSENABLE_ENABLE                  (1 << D3D_REG_BIT_ZCOMPRESSENABLE)

//// not currently in use - rel6 maybe?
// ANTIALIASENABLE
#define D3D_REG_ANTIALIASDYNAMICENABLE_STRING           "ANTIALIASDYNAMICENABLE"
#define D3D_REG_ANTIALIASDYNAMICENABLE_MASK             (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Enable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE          (0 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Disable Dynamic Anti-Aliasing support.
#define D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE           (1 << D3D_REG_BIT_ANTIALIASDYNAMICENABLE)         // Enable Dynamic Anti-Aliasing support.

// Default values for registry configurable driver settings.
#define D3D_REG_DEFAULT_ALTERNATEZENABLE                D3D_REG_ALTERNATEZENABLE_DISABLE
#define D3D_REG_DEFAULT_ANTIALIASENABLE                 D3D_REG_ANTIALIASENABLE_ENABLE            // enable Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASDYNAMICENABLE          D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE     // enable dynamic Anti Aliasing.
#define D3D_REG_DEFAULT_ANTIALIASFORCEENABLE            D3D_REG_ANTIALIASFORCEENABLE_DISABLE      // Disable forced Anti Aliasing.
#define D3D_REG_DEFAULT_CKCOMPATABILITYENABLE           D3D_REG_CKCOMPATABILITYENABLE_ENABLE      // Perform application colorkey fixups.
#define D3D_REG_DEFAULT_CONTROLTRAFFICENABLE            D3D_REG_CONTROLTRAFFICENABLE_ENABLE
#define D3D_REG_DEFAULT_DIRECTMAPENABLE                 D3D_REG_DIRECTMAPENABLE_ENABLE            // Enable Direct Mapping of Texture Combiners by default.
#define D3D_REG_DEFAULT_ENFORCESTRICTTRILINEAR          D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE     // Enforces multitexture-trilinear ot NOT use dithering approximation
#define D3D_REG_DEFAULT_FLUSHAFTERBLITENABLE            D3D_REG_FLUSHAFTERBLITENABLE_DISABLE      // Disable flush after blit on wait flag
#define D3D_REG_DEFAULT_FOGTABLEENABLE                  D3D_REG_FOGTABLEENABLE_ENABLE             // Enable software implemented fog table support.
#define D3D_REG_DEFAULT_FORCEBLITWAITFLAGENABLE         D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE   // Disable force the BLT_WAIT flag
#define D3D_REG_DEFAULT_LIMITQUEUEDFBBLITSENABLE        D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE  // Disable limiting the max number of queued FB blits
#define D3D_REG_DEFAULT_LOGOENABLE                      D3D_REG_LOGOENABLE_DISABLE
#define D3D_REG_DEFAULT_PALETTEENABLE                   D3D_REG_PALETTEENABLE_ENABLE              // Enable 8-bit textures (relevant only >=DX8. always disabled for <=DX7)
#define D3D_REG_DEFAULT_SQUASHW                         D3D_REG_SQUASHW_DISABLE
#define D3D_REG_DEFAULT_SSYNCENABLE                     D3D_REG_SSYNCENABLE_DISABLE               // MAJOR APP HACK should never be enbled by default!!
#define D3D_REG_DEFAULT_TEXTURECOMPRESSIONENABLE        D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE   // Enable Texture compression so we can 'disable' for badly behaving apps
#define D3D_REG_DEFAULT_TEXTUREMANAGEMENTENABLE         D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE    // enable driver-based texture management
#define D3D_REG_DEFAULT_TILINGENABLE                    D3D_REG_TILINGENABLE_ENABLE
#define D3D_REG_DEFAULT_USERMIPMAPENABLE                D3D_REG_USERMIPMAPENABLE_ENABLE           // Enable use of user supplied mip maps
#define D3D_REG_DEFAULT_VIDEOTEXTUREENABLE              D3D_REG_VIDEOTEXTUREENABLE_ENABLE         // Enable texturing from video memory
#define D3D_REG_DEFAULT_WBUFFERENABLE                   D3D_REG_WBUFFERENABLE_ENABLE
#define D3D_REG_DEFAULT_Z24ENABLE                       D3D_REG_Z24ENABLE_ENABLE                  // Enable 24bit z-exports by default
#define D3D_REG_DEFAULT_ZCOMPRESSENABLE                 D3D_REG_ZCOMPRESSENABLE_ENABLE            // Enable z compression by default (applicable to nv20 ff.)

// ----------- Non-boolean settings with enumerated values ------------------

// AntiAliasQuality definitions.
#define D3D_REG_ANTIALIASQUALITY_STRING                 "ANTIALIASQUALITY"
#define D3D_REG_ANTIALIASQUALITY_MIN                    0
#define D3D_REG_ANTIALIASQUALITY_MAX                    7

//// not currently in use - rel6 maybe?
// AntiAliasDynamicFPS definitions.
#define D3D_REG_ANTIALIASDYNAMICFPS_STRING              "ANTIALIASDYNAMICFPS"
#define D3D_REG_ANTIALIASDYNAMICFPS_MIN                 10
#define D3D_REG_ANTIALIASDYNAMICFPS_MAX                 500

// CAPTURE CONFIG
#define D3D_REG_CAPTURECONFIG_STRING                    "CAPTURECONFIG"
#define D3D_REG_CAPTURECONFIG_ALLOC4X                   0x01
#define D3D_REG_CAPTURECONFIG_FORCEPCI                  0x02

// CAPTUREENABLE
#define D3D_REG_CAPTUREENABLE_STRING                    "CAPTUREENABLE"
#define D3D_REG_CAPTUREENABLE_DISABLE                   0x00
#define D3D_REG_CAPTUREENABLE_RECORD                    0x01
#define D3D_REG_CAPTUREENABLE_PLAY                      0x02

// Colorkey Reference Values range.
#define D3D_REG_CKREF_STRING                            "CKREF"
#define D3D_REG_CKREF_MIN                               0x00
#define D3D_REG_CKREF_MAX                               0x7F

// MipMapDitherEnable definitions.
#define D3D_REG_MIPMAPDITHERMODE_STRING                 "ANISOTROPIC4TAP"
#define D3D_REG_MIPMAPDITHERMODE_DISABLE                0           // Disable mipmap dithering (true trilinear)
#define D3D_REG_MIPMAPDITHERMODE_ENABLE                 1           // Enable mipmap dithering (fake trilinear)
#define D3D_REG_MIPMAPDITHERMODE_SMART                  2           // smart dithering (enabled at higher resolutions)
#define D3D_REG_MIPMAPDITHERMODE_MAX                    2

// TexelAlignment definitions.
// Bit flags (bit 0 = ZOH, bit 1 = FOH, bit 2 = Texel Origin)
#define D3D_REG_TEXELALIGNMENT_STRING                  "TEXELALIGNMENT"
#define D3D_REG_TEXELALIGNMENT_ZOH_CENTER               0x00
#define D3D_REG_TEXELALIGNMENT_ZOH_CORNER               0x01
#define D3D_REG_TEXELALIGNMENT_ZOH_MASK                 0x01
#define D3D_REG_TEXELALIGNMENT_FOH_CENTER               0x00
#define D3D_REG_TEXELALIGNMENT_FOH_CORNER               0x02
#define D3D_REG_TEXELALIGNMENT_FOH_MASK                 0x02
#define D3D_REG_TEXELALIGNMENT_TEXEL_CENTER             0x00
#define D3D_REG_TEXELALIGNMENT_TEXEL_CORNER             0x04
#define D3D_REG_TEXELALIGNMENT_TEXEL_MASK               0x04
#define D3D_REG_TEXELALIGNMENT_MAX                      0x07

#define D3D_REG_TEXTUREMANAGESTRATEGY_STRING            "TEXTUREMANAGESTRATEGY"
#define D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE        0x1
#define D3D_REG_TEXTUREMANAGESTRATEGY_LAZY              0x0

// ValidateZMethod definitions.
#define D3D_REG_VALIDATEZMETHOD_STRING                  "VALIDATEZMETHOD"
#define D3D_REG_VALIDATEZMETHOD_FLEXIBLE                0           // Driver will match z-buffer to rendering depth.
#define D3D_REG_VALIDATEZMETHOD_SRTRETURNNOTHANDLED     1           // Same as FLEXIBLE but returns NOTHANDLED from Set Render Target.
#define D3D_REG_VALIDATEZMETHOD_STRICT                  2           // Z-Buffer must always match rendering depth.
#define D3D_REG_VALIDATEZMETHOD_MIXED                   3           // DX6 applications = STRICT, DX5 applications = flexible
#define D3D_REG_VALIDATEZMETHOD_MAX                     3

// V-Sync modes
#define D3D_REG_VSYNCMODE_STRING                        "VSYNCMODE"
#define D3D_REG_VSYNCMODE_PASSIVE                       0           // just do what the app tells us to do
#define D3D_REG_VSYNCMODE_FORCEOFF                      1           // override app and don't vsync
#define D3D_REG_VSYNCMODE_FORCEON                       2           // override app and vsync
#define D3D_REG_VSYNCMODE_MAX                           2

// WFormat definitions.
#define D3D_REG_WFORMAT16_STRING                        "W16FORMAT"
#define D3D_REG_WFORMAT32_STRING                        "W32FORMAT"
#define D3D_REG_WFORMAT_FIXED                           0x1
#define D3D_REG_WFORMAT_FLOAT                           0x2
#define D3D_REG_WFORMAT_MIN                             0x1
#define D3D_REG_WFORMAT_MAX                             0x2

// defaults for the non-boolean enumerated values
#define D3D_REG_DEFAULT_CAPTURCONFIG                    (D3D_REG_CAPTURECONFIG_ALLOC4X | D3D_REG_CAPTURECONFIG_FORCEPCI)
#define D3D_REG_DEFAULT_CAPTURENABLE                    D3D_REG_CAPTUREENABLE_RECORD
#define D3D_REG_DEFAULT_MIPMAPDITHERMODE                D3D_REG_MIPMAPDITHERMODE_SMART          // use true trilinear sometimes
#define D3D_REG_DEFAULT_TEXELALIGNMENT                  (D3D_REG_TEXELALIGNMENT_ZOH_CORNER | D3D_REG_TEXELALIGNMENT_FOH_CORNER | D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
#define D3D_REG_DEFAULT_TEXTUREMANAGESTRATEGY           D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE
#define D3D_REG_DEFAULT_VALIDATEZMETHOD                 D3D_REG_VALIDATEZMETHOD_FLEXIBLE        // D3D_REG_VALIDATEZMETHOD_MIXED
#define D3D_REG_DEFAULT_VSYNCMODE                       D3D_REG_VSYNCMODE_PASSIVE
#define D3D_REG_DEFAULT_W16FORMAT                       D3D_REG_WFORMAT_FIXED
#define D3D_REG_DEFAULT_W32FORMAT                       D3D_REG_WFORMAT_FLOAT

// ------- Non-boolean settings with non-enumerated values ------------------

// Reads nvCelsiusAACompatibility.h
#define D3D_REG_AAREADCOMPATIBILITYFILE_STRING          "AAREADCOMPATIBILITYFILE"

// AntiAliasQuality definitions.
#define D3D_REG_ANTIALIASQUALITY_STRING                 "ANTIALIASQUALITY"
#define D3D_REG_ANTIALIASQUALITY_MIN                    0
#define D3D_REG_ANTIALIASQUALITY_MAX                    7

// AntiAliasDynamicFPS definitions.
#define D3D_REG_ANTIALIASDYNAMICFPS_STRING              "ANTIALIASDYNAMICFPS"
#define D3D_REG_ANTIALIASDYNAMICFPS_MIN                 10
#define D3D_REG_ANTIALIASDYNAMICFPS_MAX                 500

// AGP texture cutoff
#define D3D_REG_AGPTEXCUTOFF_STRING                     "AGPTEXCUTOFF"

// starting number for played capture files
#define D3D_REG_CAPTUREPLAYFILENUM_STRING               "CAPTUREPLAYFILENUM"

// starting number for recorded capture files
#define D3D_REG_CAPTURERECORDFILENUM_STRING             "CAPTURERECORDFILENUM"

// Colorkey Reference Values range.
#define D3D_REG_CKREF_STRING                            "CKREF"
#define D3D_REG_CKREF_MIN                               0x00
#define D3D_REG_CKREF_MAX                               0x7F

// D3D contexts
#define D3D_REG_D3DCONTEXTMAX_STRING                    "D3DCONTEXTMAX"

// D3D contexts
#define D3D_REG_D3DTEXTUREMAX_STRING                    "D3DTEXTUREMAX"

// DPF debug level
#define D3D_REG_DEBUGLEVEL_STRING                       "DEBUGLEVEL"

// LOD bias adjust
#define D3D_REG_LODBIAS_STRING                          "LODBIASADJUST"

// minimum video texture size
#define D3D_REG_MINVIDTEXSIZE_STRING                    "MINVIDEOTEXSIZE"

// size of the pci texture heap. non-zero value will override value determined by the driver
#define D3D_REG_PCITEXHEAPSIZE_STRING                   "PCITEXHEAPSIZE"

// performance strategy
#define D3D_REG_PERFSTRATEGYOR_STRING                   "PSOR"
#define D3D_REG_PERFSTRATEGYAND_STRING                  "PSAND"

// Prerender limits
#define D3D_REG_PRERENDERLIMIT_STRING                   "PRERENDERLIMIT"
#define D3D_REG_PRERENDERLIMIT_MIN                      1
#define D3D_REG_PRERENDERLIMIT_MAX                      1000

// maximum push buffer size
#define D3D_REG_PUSHBUFFERSIZEMAX_STRING                "DMAPUSHBUFFERSIZEMAX"

// WScale 16/24 definitions.
#define D3D_REG_WSCALE16_STRING                         "WSCALE16"
#define D3D_REG_WSCALE24_STRING                         "WSCALE24"
#define D3D_REG_WSCALE16_MAX                            0x00010000
#define D3D_REG_WSCALE24_MAX                            0x01000000

// positively shift z to accomodate apps that give us slightly negtive z
#define D3D_REG_ZBIAS_STRING                            "ZBIAS"

// defaults for the non-boolean, non-enumerated values
#define D3D_REG_DEFAULT_AAREADCOMPATIBILITYFILE         0
#define D3D_REG_DEFAULT_ANTIALIASQUALITY                1
#define D3D_REG_DEFAULT_ANTIALIASDYNAMICFPS             (1000 / 30)
#define D3D_REG_DEFAULT_AGPTEXCUTOFF                    1024
#define D3D_REG_DEFAULT_CAPTUREPLAYFILENUM              0
#define D3D_REG_DEFAULT_CAPTURERECORDFILENUM            0
#define D3D_REG_DEFAULT_CKREF                           D3D_REG_CKREF_MIN
#define D3D_REG_DEFAULT_D3DCONTEXTMAX                   64                  // D3D Context heap allocation max.
#define D3D_REG_DEFAULT_D3DTEXTUREMAX                   1024                // D3D Texture heap allocation max.
#define D3D_REG_DEFAULT_DEBUGLEVEL                      0                   // no debug output
#define D3D_REG_DEFAULT_LODBIASADJUST                   0
#define D3D_REG_DEFAULT_MINVIDEOTEXSIZE                 1                   // minimum texture size to be placed in video memory.
#define D3D_REG_DEFAULT_PCITEXHEAPSIZE                  0                   // size of PCI texture heap. (0 => driver-determined value)
#define D3D_REG_DEFAULT_PRERENDERLIMIT                  3
#define D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX               0x40000             // maximum push buffer size.
#define D3D_REG_DEFAULT_WSCALE16                        D3D_REG_WSCALE16_MAX
#define D3D_REG_DEFAULT_WSCALE24                        D3D_REG_WSCALE24_MAX
#define D3D_REG_DEFAULT_ZBIAS                           0.f

// ------------------------------- Strings ----------------------------------

#define D3D_REG_STRING_LENGTH                           64                  // maximum allowed string length

// push-buffer capture playback file name
#define D3D_REG_CAPTUREPLAYFILENAME_STRING              "CAPTUREPLAYFILENAME"

// push-buffer capture playback path
#define D3D_REG_CAPTUREPLAYPATH_STRING                  "CAPTUREPLAYPATH"

// push-buffer capture recording path
#define D3D_REG_CAPTURERECORDFILENAME_STRING            "CAPTURERECORDFILENAME"

// push-buffer capture recording path
#define D3D_REG_CAPTURERECORDPATH_STRING                "CAPTURERECORDPATH"

// string defaults
#define D3D_REG_DEFAULT_CAPTUREPLAYFILENAME             "capture"
#define D3D_REG_DEFAULT_CAPTUREPLAYPATH                 "c:\\"
#define D3D_REG_DEFAULT_CAPTURERECORDFILENAME           "capture"
#define D3D_REG_DEFAULT_CAPTURERECORDPATH               "c:\\"


//-----------------------------------------------------------------------------
// OpenGL
//-----------------------------------------------------------------------------

#define NV4_REG_OGL_BUFFER_FLIPPING_CONTROL             "FlippingControl"
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_BLIT      0
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_FLIP      1
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_AUTO      2
#define   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_DEFAULT   NV4_REG_OGL_BUFFER_FLIPPING_CONTROL_AUTO

#define NV_REG_OGL_BUFFER_REGION_EXT                    "BufferRegionExt"
#define   NV_REG_OGL_BUFFER_REGION_EXT_OFF              0
#define   NV_REG_OGL_BUFFER_REGION_EXT_ON               1
#define   NV_REG_OGL_BUFFER_REGION_EXT_DEFAULT          NV_REG_OGL_BUFFER_REGION_EXT_ON

#define NV_REG_OGL_BUFFER_REGION_USE_VIDMEM             "BufferRegionUseVidMem"
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_OFF       0
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_ON        1
#define   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_DEFAULT   NV_REG_OGL_BUFFER_REGION_USE_VIDMEM_ON

#define NV_REG_OGL_DEBUG_RENDERER                       "Renderer"
#define   NV_REG_OGL_DEBUG_RENDERER_NVIDIA              0
#define   NV_REG_OGL_DEBUG_RENDERER_SOFTWARE            1
#define   NV_REG_OGL_DEBUG_RENDERER_MICROSOFT           2

#define NV_REG_OGL_DEBUG_PMENABLE                       "PMEnable"
#define   NV_REG_OGL_DEBUG_PMENABLE_ENABLED             1
#define   NV_REG_OGL_DEBUG_PMENABLE_DISABLED            0

#define NV_REG_OGL_DEFAULT_SWAP_INTERVAL                "DefaultSwapInterval"
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_TEAR         0
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_VSYNC        1
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_DISABLE      0xffffffff
#define   NV_REG_OGL_DEFAULT_SWAP_INTERVAL_DEFAULT      NV_REG_OGL_DEFAULT_SWAP_INTERVAL_VSYNC

#define NV_REG_OGL_FORCE_GEFORCE                        "ForceGeForce"
#define NV_REG_OGL_MAX_NVACCEL                          "MaxNVACCEL"

#define NV_REG_OGL_NV15_ALINES                          "NV15Alines"
#define   NV_REG_OGL_NV15_ALINES_ACTUAL                 0
#define   NV_REG_OGL_NV15_ALINES_FORCE                  1
#define   NV_REG_OGL_NV15_ALINES_DISABLE                2

#define NV_REG_OGL_VERTEX_PROGRAM                       "VertexProgram"
#define   NV_REG_OGL_VERTEX_PROGRAM_OPTIMIZE            0
#define   NV_REG_OGL_VERTEX_PROGRAM_NO_LIVEDEAD         1

#define NV_REG_OGL_TRIPLE_BUFFER                        "EnableTripleBuffer"
#define   NV_REG_OGL_TRIPLE_BUFFER_DISABLE              0
#define   NV_REG_OGL_TRIPLE_BUFFER_ENABLE               1
#define   NV_REG_OGL_TRIPLE_BUFFER_DEFAULT              NV_REG_OGL_TRIPLE_BUFFER_DISABLE

#define NV_REG_OGL_WINDOW_FLIPPING                      "EnableWindowFlipping"
#define   NV_REG_OGL_WINDOW_FLIPPING_ENABLE             1
#define   NV_REG_OGL_WINDOW_FLIPPING_DISABLE            0
#define   NV_REG_OGL_WINDOW_FLIPPING_DEFAULT            NV_REG_OGL_WINDOW_FLIPPING_DISABLE

#define NV_REG_OGL_OVERLAY_SUPPORT                      "EnableOverlaySupport"
#define NV_REG_OGL_OVERLAY_SUPPORT_OFF                  0
#define NV_REG_OGL_OVERLAY_SUPPORT_ON                   1
#define NV_REG_OGL_OVERLAY_SUPPORT_DEFAULT              NV_REG_OGL_OVERLAY_SUPPORT_OFF

#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS           "OverlayMergeBlitTimerMs"
#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS_DEFAULT   40 //ms
#define NV_REG_OGL_OVERLAY_MERGEBLIT_TIMER_MS_OFF       0  //0ms => off

// MSchwarzer 9/28/00 these keys are used to enable bundles of bugfixes for special applications
#define NV_REG_OGL_APPLICATION_KEY                      "ApplicationKey"
#define NV_REG_OGL_APPLICATION_KEY_NONE                 0
#define NV_REG_OGL_APPLICATION_KEY_STANDARD             1
#define NV_REG_OGL_APPLICATION_KEY_SOFTIMAGE3D          2
#define NV_REG_OGL_APPLICATION_KEY_3DSMAX               3
#define NV_REG_OGL_APPLICATION_KEY_3DPAINT              4
#define NV_REG_OGL_APPLICATION_KEY_MAYA                 5
#define NV_REG_OGL_APPLICATION_KEY_LIGHTSCAPE           6
#define NV_REG_OGL_APPLICATION_KEY_DEFAULT              NV_REG_OGL_APPLICATION_KEY_NONE

#define NV_REG_OGL_FORCE_16BIT_Z                        "EnableForce16BitZ"
#define NV_REG_OGL_FORCE_16BIT_Z_DISABLE                0
#define NV_REG_OGL_FORCE_16BIT_Z_ENABLE                 1
#define NV_REG_OGL_FORCE_16BIT_Z_DEFAULT                NV_REG_OGL_FORCE_16BIT_Z_DISABLE

#define NV_REG_OGL_ZTRICK                               "EnableZEnhancement"
#define NV_REG_OGL_ZTRICK_DISABLE                       0
#define NV_REG_OGL_ZTRICK_ENABLE                        1
#define NV_REG_OGL_ZTRICK_DEFAULT                       NV_REG_OGL_ZTRICK_ENABLE

#define NV_REG_OGL_DISPLAY_DRIVER                       "EnableDisplayDriver"

#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER              "EnableSingleBackDepthBuffer"
#define NV_REG_OGL_SINGLE_BACKDEPTH_DISABLE             0
#define NV_REG_OGL_SINGLE_BACKDEPTH_ENABLE              1
#define NV_REG_OGL_SINGLE_BACKDEPTH_BUFFER_DEFAULT      NV_REG_OGL_SINGLE_BACKDEPTH_DISABLE

#define NV_REG_OGL_DMAPUSH_BUFSIZE_WORDS                "CmdBufSizeWords"

#define NV_REG_OGL_DMAPUSH_MIN_PUSH_COUNT               "CmdBufMinWords"

#define NV_REG_OGL_DL_STAGING_BUFFER_SIZE_WORDS         "DLStagingBufferSizeWords"
#define NV_REG_OGL_DL_STAGING_BUFFER_SIZE_WORDS_DEFAULT ((9*1024*1024)/4)

#define NV_REG_OGL_TARGET_FLUSHCOUNT                    "TargetFlushCount"

#define NV_REG_OGL_FAST_COPY_PIXELS                     "EnableFastCopyPixels"

#define NV_REG_OGL_FORCE_MULTITEX                       "ForceMultiTexture"

#define NV_REG_OGL_MAX_FRAMES_ALLOWED                   "MaxFramesAllowed"

#define NV_REG_OGL_MAX_TEX_SIZE                         "MaxTexSize"

#define NV_REG_OGL_MIN_VIDMEM_TEX_WIDTH                 "VidMemMinTexWidth"

#define NV_REG_OGL_PCI_TEXHEAP_SIZE                     "MaxPCITexHeapSize"
#define NV_REG_OGL_PCI_TEXHEAP_SIZE_DEFAULT             (5*1024*1024)
#define NV_REG_OGL_PCI_TEXHEAP_SIZE_MAX_NT              (16*1024*1024)

#define NV_REG_MULTI_MONITOR_ADVANCED_ENABLE            "MultiMonAdvEnable"
#define NV_OGL_DEFAULT_MULTI_MONITOR_ADVANCED_ENABLE    0

#define NV_REG_OGL_RENDER_QUALITY_FLAGS                 "RenderQualityFlags"
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_MMDITHER        0x00000001
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_ANISOENABLE     0x00000002

/* Default texel size */
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_MASK     0x0000000c
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_AUTO     0x00000000
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_16       0x00000004
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_32       0x00000008
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_TEXBITS_RESERVED 0x0000000c

/* One Minus Depth Buffering */
#define NV_REG_OGL_RENDER_QUALITY_FLAGS_ONE_MINUS_Z     0x00000010

#define NV_REG_OGL_RENDER_QUALITY_FLAGS_DEFAULT         (0)

#define NV4_REG_OGL_TEX_MEMORY_SPACE_ENABLES            "TexMemorySpaceEnables"

#define NV4_REG_OGL_PALETTED_TEX_IN_VID_MEM             "PalettedTexInVidMem"

#define NV4_REG_OGL_TEX_PRECACHE                        "TexturePrecache"

#define NV4_REG_OGL_TEX_STAGING_BUFFER_SIZE             "TexStagingBufferSize"
#define NV4_REG_OGL_TEX_STAGING_BUFFER_SIZE_DEFAULT     (512*1024)

#define NV4_REG_OGL_TEX_STAGING_BUFFER_MULT_SIZE        "TexStagingBufferMultSize"
#define NV4_REG_OGL_STAGING_BUFFER_MULT_SIZE_DEFAULT    (256*1024)

#define NV_REG_OGL_TEXTURE_QUALITY                      "TextureQuality"

#define NV_REG_OGL_FULLSCENE_ANTIALIASING               "EnableFSAA"
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_ENABLED       1
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_DISABLED      0
#define NV_REG_OGL_FULLSCENE_ANTIALIASING_DEFAULT       NV_REG_OGL_FULLSCENE_ANTIALIASING_DISABLED

#define NV_REG_OGL_FSAA_QUALITY                         "FSAAQuality"
#define NV_REG_OGL_FSAA_QUALITY_15x15                   0 // 1.5x1.5
#define NV_REG_OGL_FSAA_QUALITY_2x2_LODBIAS             1
#define NV_REG_OGL_FSAA_QUALITY_2x2                     2
#define NV_REG_OGL_FSAA_QUALITY_DEFAULT                 NV_REG_OGL_FSAA_QUALITY_15x15
#define NV_REG_OGL_FSAA_QUALITY_MAXIMUM                 2 // clamp to [0,this]

#define NV_REG_OGL_S3TC_QUALITY                         "S3TCQuality"
#define NV_REG_OGL_S3TC_QUALITY_FORCE_DXT3              1
#define NV_REG_OGL_S3TC_QUALITY_Q3_LIGHTMAPS_HACK       2
#define NV_REG_OGL_S3TC_QUALITY_DEFAULT                 0

#define NV_REG_OGL_FORCE_GENERIC_CPU                    "ForceGenericCPU"
#define NV_REG_OGL_FORCE_GENERIC_CPU_ON                 1
#define NV_REG_OGL_FORCE_GENERIC_CPU_OFF                0
#define NV_REG_OGL_FORCE_GENERIC_CPU_DEFAULT            NV_REG_OGL_FORCE_GENERIC_CPU_OFF

#define NV_REG_OGL_APP_SOFTIMAGE                        "App_SoftImage"
#define NV_REG_OGL_APP_SOFTIMAGE_DEFAULT                0
#define NV_REG_OGL_APP_SOFTIMAGE_38                     38
#define NV_REG_OGL_APP_SOFTIMAGE_39                     39

#define NV_REG_OGL_APP_SUPPORTBITS                      "App_SupportBits"
#define NV_REG_OGL_APP_SUPPORTBITS_DEFAULT              0
#define NV_REG_OGL_APP_SUPPORTBITS_SYNCGDI              0x00000001
#define NV_REG_OGL_APP_SUPPORTBITS_PROE_2000I2          0x00000002

#define NV_REG_OGL_NV20_EMULATE                         "NV20Emulate"
#define NV_REG_OGL_NV20_EMULATE_ON                      1
#define NV_REG_OGL_NV20_EMULATE_OFF                     0
#define NV_REG_OGL_NV20_EMULATE_DEFAULT                 NV_REG_OGL_FORCE_GENERIC_CPU_OFF

#define NV_REG_OGL_SERVER_SWAP_NT4                      "ServerSwapNT4"
#define NV_REG_OGL_SERVER_SWAP_NT4_DEFAULT              0

/* OGL Capture file */
#define NV_REG_OGL_CAPTURE_ENABLE                       "CaptureEnable"
#define NV_REG_OGL_CAPTURE_ENABLE_DISABLE               0x00
#define NV_REG_OGL_CAPTURE_ENABLE_RECORD                0x01
#define NV_REG_OGL_CAPTURE_ENABLE_PLAY                  0x02
#define NV_REG_OGL_CAPTURE_ENABLE_DEFAULT               NV_REG_OGL_CAPTURE_ENABLE_RECORD

#define NV_REG_OGL_CAPTURE_RECORD_PATH                  "CaptureRecordPath"
#define NV_REG_OGL_CAPTURE_RECORD_PATH_DEFAULT          "c:\\"
#define NV_REG_OGL_CAPTURE_RECORD_FILENAME              "CaptureRecordFilename"
#define NV_REG_OGL_CAPTURE_RECORD_FILENAME_DEFAULT      "capture"

#define NV_REG_OGL_CAPTURE_PLAY_PATH                    "CapturePlayPath"
#define NV_REG_OGL_CAPTURE_PLAY_PATH_DEFAULT            "c:\\"
#define NV_REG_OGL_CAPTURE_PLAY_FILENAME                "CapturePlayFilename"
#define NV_REG_OGL_CAPTURE_PLAY_FILENAME_DEFAULT        "capture"

#define NV_REG_OGL_CAPTURE_WHEN_FLIP                    1
#define NV_REG_OGL_CAPTURE_WHEN_READPIXELS              2

#define NV_REG_OGL_CAPTURE_RECORD_WHEN                  "CaptureRecordWhen"
#define NV_REG_OGL_CAPTURE_RECORD_WHEN_DEFAULT          NV_REG_OGL_CAPTURE_WHEN_FLIP

#define NV_REG_OGL_CAPTURE_PLAY_WHEN                    "CapturePlayWhen"
#define NV_REG_OGL_CAPTURE_PLAY_WHEN_DEFAULT            NV_REG_OGL_CAPTURE_WHEN_FLIP

#define NV_REG_OGL_CAPTURE_PLAY_WHERE                   "CapturePlayWhere"
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_FRONT             0
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_BACK              1
#define NV_REG_OGL_CAPTURE_PLAY_WHERE_DEFAULT           NV_REG_OGL_CAPTURE_PLAY_WHERE_FRONT



//-----------------------------------------------------------------------------
// ResMan
//-----------------------------------------------------------------------------

#define NV_REG_SYS_SUPER7_COMPATIBILITY                 "Super7Compat"
#define PERSISTENT_AGP_SIZE                             "PersistAGPSize"
#define NV_MAX_AGP_SIZE                                 "MaxAGPSize"
#define NV5_REG_SYS_HSYNC_FLIP                          "FlipOnHSync"
#define MAXREFRESHRATE                                  "MaxRefreshRate"
#define MAXOPTIMALREFRESHRATE                           "MaxOptimalRefreshRate"
#define OPTIMALREFRESHNOTFROMEDID                       "OptimalRefreshNotFromEDID"
#define DMTOVERRIDE                                     "DMTOVERRIDE"
#define MONITORTIMING                                   "MonitorTiming"
#define CURSORCACHE                                     "CursorCache"
#define DISPLAY_TYPE                                    "Display Type"
#define DISPLAY2_TYPE                                   "Display2 Type"
#define TV_TYPE                                         "TV Type"
#define POWERUPFLAGS                                    "PowerUpFlags"
#define TV_OUT                                          "TV Out"
#define NEWSTYLEMODESET                                 "NewStyleModeSet"
#define FLATPANELMODE                                   "FlatPanelMode"
#define RESOURCE_MANAGER_SUBKEY_ADDITION                "NVIDIA"


// Forces the push buffer to reside in a particular location.  Used by ddraw
// and OGL.  This is a local key.  Setting this will override the Super7Compat key
#define NV_REG_SYS_PB_LOCATION                          "PushBufferLocale"
#define   NV_REG_SYS_PB_LOCATION_DEFAULT                0
#define   NV_REG_SYS_PB_LOCATION_SYSTEM                 1
#define   NV_REG_SYS_PB_LOCATION_AGP                    2
#define   NV_REG_SYS_PB_LOCATION_VIDEO                  3

//-----------------------------------------------------------------------------
// Control Panel
//-----------------------------------------------------------------------------

#define NV_REG_CPL_D3D_SETTINGS_SUBKEY                   NV4_REG_DIRECT3D_SUBKEY
#define NV_REG_CPL_OGL_SETTINGS_SUBKEY                   NV4_REG_OGL_SUBKEY

#define NV_REG_CPL_COLOR_SUBKEY                          "Color"
#define NV_REG_CPL_COLOR_VALUE_CURRENT                   "Current"

#define NV_REG_CPL_COLOR_SCHEMES_SUBKEY                  "Schemes"

#define NV_REG_CPL_TV_OUT_SUBKEY                         "TVOut"

#define NV_REG_CPL_OEM_DEFAULTS_SUBKEY                   "Defaults"

#define NV_REG_CPL_DISPLAY_MODES_SUBKEY                  "DisplayModes"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_MONITOR           "Analog Monitor"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_DFP               "Digital Flat Panel"
#define NV_REG_CPL_DISPLAY_MODES_VALUE_TV                "TV"

#define NV_REG_CPL_OVL_SETTINGS_SUBKEY                   "Overlay"

#define NV_REG_CPL_VALUE_UNLOCK_GOODIES                  "CoolBits"
#define NV_REG_CPL_DATA_UNLOCK_GOODIES_VSYNC             0x00000001
#define NV_REG_CPL_DATA_UNLOCK_GOODIES_HWCLOCK           0x00000002

#define NV_REG_HARDWARE_SUBKEY                           "Hardware"
#define NV_REG_HARDWARE_CLOCK_ENABLE                     "Marge"    // overclocking enable
#define NV_REG_HARDWARE_CLOCK_CONTROL_USER               "Krusty"   // user defined clock speeds
#define NV_REG_HARDWARE_CLOCK_CONTROL_DEFAULT            "Bart"     // BIOS default clock speeds
#define NV_REG_HARDWARE_CLOCK_ENCRYPT_FLAGS              "Homer"    // encryption flags
#define NV_REG_HARDWARE_CLOCK_NO_WARN_DLG                "Lisa"     // turn off warning dialog
#define NV_REG_HARDWARE_CLOCK_DETECT_VALUE               "NvHardwareControl"
#define NV_REG_HARDWARE_CLOCK_DETECT_CMD_LINE            "RUNDLL32.EXE NVQTWK.DLL,NvHWCtl"
#define NV_REG_HARDWARE_CLOCK_INIT_VALUE                 "NvInitialize"
#define NV_REG_HARDWARE_CLOCK_INIT_CMD_LINE              "RUNDLL32.EXE NVQTWK.DLL,NvXTInit"

#define NV_REG_DESK_MANAGER_VALUE_NAME                   "DesktopManager"   //XXX deprecated!
#define NV_REG_DESK_MANAGER_HOTKEY_SUBKEY                "HotKeys"  //XXX deprecated!
#define NV_REG_DESK_MANAGER_APPASSOC_SUBKEY              "Apps"
#define NV_REG_DESK_MANAGER_APPASSOC_DESKTOP             "Desktop"
#define NV_REG_DESK_MANAGER_APPASSOC_MONITOR             "StartingMonitor"
#define NV_REG_DESK_MANAGER_APPASSOC_FLAGS               "Flags"
#define NV_REG_DESK_MANAGER_APPASSOC_PLACEMENT           "Placement"
#define NV_REG_DESK_MANAGER_APPASSOC_CLASS               "Class"
#define NV_REG_DESK_MANAGER_GLOBALS_SUBKEY               "Globals"
#define NV_REG_DESK_MANAGER_GLOBALS_FLAGS                "Flags"
#define NV_REG_DESK_MANAGER_GLOBALS_TLSCREEN             "TLScreen"
#define NV_REG_DESK_MANAGER_GLOBALS_HKMOVE               "HKMove"
#define NV_REG_DESK_MANAGER_GLOBALS_HKMOVEALL            "HKMoveAll"
#define NV_REG_DESK_MANAGER_GLOBALS_HKSWITCH             "HKSwitch"
#define NV_REG_DESK_MANAGER_GLOBALS_HKGATHER             "HKGather"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOM               "HKZoom"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOMIN             "HKZoomIn"
#define NV_REG_DESK_MANAGER_GLOBALS_HKZOOMOUT            "HKZoomOut"
#define NV_REG_DESK_MANAGER_GLOBALS_ALTTABMON            "CoolSwitchMon"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMLEVEL            "DefaultZoomLevel"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMREFRESH          "ZoomRefreshRate"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMWKEYS            "ZoomWheelKeys"
#define NV_REG_DESK_MANAGER_GLOBALS_ZOOMDELAY            "ZoomSwitchDelay"
#define NV_REG_DESK_MANAGER_CPLPOS                       "PanelPos"

/////////////////////////////////////
// bit flags for the QuickTweak properties settings

#define NV_REG_CPL_GLOBAL_VALUE_QUICKTWEAK_FLAGS         "QuickTweak"

#define NV_REG_CPL_GLOBAL_DATA_QUICKTWEAK_DEFAULT        0x00010020

#define NV_REG_FLAGS_NOCONFIRM                           0x00000001
#define NV_REG_FLAGS_LBUTTON                             0x00000010
#define NV_REG_FLAGS_RBUTTON                             0x00000020
#define NV_REG_FLAGS_BOTHBUTTONS                         0x00000030
#define NV_REG_FLAGS_COOLMENUS                           0x00000100
#define NV_REG_FLAGS_TASKBAR_LOGO                        0x00010000
#define NV_REG_FLAGS_TASKBAR_BLUE                        0x00020000
#define NV_REG_FLAGS_TASKBAR_RED                         0x00040000
#define NV_REG_FLAGS_DEFAULT                             (NV_REG_FLAGS_RBUTTON | NV_REG_FLAGS_TASKBAR_LOGO)


/////////////////////////////////////
// bit flags for hiding particular property pages or dialogs
#define NV_REG_CPL_HIDE_PROPPAGES          "NoPages"

#define NVCPL_HIDE_COLOR_PAGE              0x00000001
#define NVCPL_HIDE_D3D_PAGE                0x00000002
#define NVCPL_HIDE_OGL_PAGE                0x00000004
#define NVCPL_HIDE_OVERLAY_PAGE            0x00000008
#define NVCPL_HIDE_OPTIONS_PAGE            0x00000010
#define NVCPL_HIDE_TASKBAR_PAGE            NVCPL_HIDE_OPTIONS_PAGE
#define NVCPL_HIDE_OUTPUT_DEVICE_PAGE      0x00000020
#define NVCPL_HIDE_CRT_POSITIONING_DLG     0x00000040
#define NVCPL_HIDE_DFP_POSITIONING_DLG     0x00000080
#define NVCPL_HIDE_TV_POSITIONING_DLG      0x00000100
#define NVCPL_HIDE_INTERNET_OPTIONS        0x00000200
#define NVCPL_HIDE_CRT_TIMING_DLG          0x00000400
#define NVCPL_HIDE_ALL_CRT_SETTINGS        (NVCPL_HIDE_CRT_POSITIONING_DLG | NVCPL_HIDE_CRT_TIMING_DLG)
#define NVCPL_HIDE_SHOW_COMBO_AA_PAGE      0x00000800

#ifdef  STEREO_SUPPORT
//-----------------------------------------------------------------------------
// Registry settings for stereo support. For now are sitting in the Global section.
//-----------------------------------------------------------------------------
#define NV_REG_STEREO_ENABLED                            "StereoEnable"                //Stereo can be potentially activated.
#define NV_REG_STEREO_STEREOVIEWER                       "StereoViewer"                //Defines the name of the stereo viewer driver.
#define NV_REG_STEREO_ADJUSTENABLED                      "StereoAdjustEnable"          //Allow stereo adjustments by hot keys.
#define NV_REG_STEREO_DISABLE_TnL                        "StereoDisableTnL"            //Disables hardware T&L. Allowes to reach more stereo effect.
#define NV_REG_STEREO_SEPARATION                         "StereoSeparation"            //Pre-transformed separation (ProjectMatrix.31).
#define NV_REG_STEREO_CONVERGENCE                        "StereoConvergence"           //Pre-transformed convergence (ProjectMatrix.41).
#define NV_REG_STEREO_CONVERGENCEMULTIPLIER              "StereoConvergenceMultiplier" //Defines correlation between pre and post-transformed convergence.
#define NV_REG_STEREO_RHW2DDETECTIONMIN                  "RHW2DDetectionMin"           //RHW far limit for 2D object detection.
#define NV_REG_STEREO_RHWGREATERATSCREEN                 "RHWGreaterAtScreen"          //Objects closer than this boundary are 2D.
#define NV_REG_STEREO_RHWEQUALATSCREEN                   "RHWEqualAtScreen"            //All objects parallel to screen are 2D.
#define NV_REG_STEREO_RHWLESSATSCREEN                    "RHWLessAtScreen"             //All objects parallel to screen are 2D.
#define NV_REG_STEREO_AUTOCONVERGENCE                    "AutoConvergence"             //Automatically focus on the closest object.
#define NV_REG_STEREO_CONVERGENCEADJUSTPACE              "AutoConvergenceAdjustPace"   //Per frame Convergence adjust pace in AutoConvergence mode.
#define NV_REG_STEREO_HOTKEY_TOGGLE                      "StereoToggle"                //The hot key to toggle stereo.
#define NV_REG_STEREO_HOTKEY_VERTICALADJUST_MORE         "StereoVerticalAdjustMore"    //The hot key to increase the vertical separation.
#define NV_REG_STEREO_HOTKEY_VERTICALADJUST_LESS         "StereoVerticalAdjustLess"    //The hot key to reduce the vertical separation.
#define NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_MORE       "StereoHorizontalAdjustMore"  //The hot key to increase the horizontal separation.
#define NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_LESS       "StereoHorizontalAdjustLess"  //The hot key to reduce the horizontal separation.
#define NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_MORE      "StereoConvergenceAdjustMore" //The hot key to increase the convergence degree.
#define NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_LESS      "StereoConvergenceAdjustLess" //The hot key to reduce the convergence degree.
#define NV_REG_STEREO_FAVORSZ                            "FavorSZ"                     //Rather use SZ in stereo calculations than RHW
#define NV_REG_STEREO_LASERSIGHT                         "LaserSight"                  //Use Nvidia proprietary laser sight.
#define NV_REG_STEREO_DEFAULTON                          "StereoDefaultOn"             //Turn stereo on when the game starts
#define NV_REG_STEREO_FRUSTUMADJUSTMODE                  "FrustumAdjustMode"           //0 - do nothing, 1 - stretch in X, 2 - clear corresponding edges for each eye.

#endif  //STEREO_SUPPORT

//----------------End of file NVREG.H----(do not edit below this line or remove this line) -----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvVPP.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *  File:       nvVPP.h
 *  Content:    Video Post Processing
 *
 ***************************************************************************/

#ifndef _NVVPP_H_
#define _NVVPP_H_

#include "CompileControl.h"

#include "nvTypes.h"
#include "ddProcMan.h"
#include "nvPusher.h"
#include "nvUniversal.h"
#include "nvMultiMon.h" // Need twinview definition

// {BFD51181-16C4-11d4-8E67-00104B9D3738}
static const GUID GUID_NV_OVERLAY_INFO = { 0xbfd51181, 0x16c4, 0x11d4, { 0x8e, 0x67, 0x0, 0x10, 0x4b, 0x9d, 0x37, 0x38 } };

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Objects created and destroyed by the VPP code
//  Note: IID = instance ID
// TBD: lots of the code in ddraw common assumes these objects exist and interact with them
//   directly.  They should be changed to access them only through VPP routines. -mlavoie
#define NV_VPP_SWIZZLE_BLIT_IID                     0xDD00B000
#define NV_VPP_OVERLAY_IID                          0xDD00B010
#define NV_VPP_V2V_FORMAT_Y_IID                     0xDD00B020
#define NV_VPP_ALPHA_BLIT_IID                       0xDD00B030
#define NV_VPP_TIMER_IID                            0xDD00B040


#define NV_VPP_VIDEO_MEMORY_TO_OVERLAY_SHADOW_FORMAT_IID   0xDD003FE4
#define NV_VPP_OVERLAY_SHADOW_TO_VIDEO_MEMORY_FORMAT_IID   0xDD003FE5

#define NV_VPP_MAX_OVERLAY_SURFACES  10
#define NV_VPP_MAX_EXTRA_SURFACES    6
#define NV_VPP_MAX_EXTRA_FS_SURFACES 4


// vppVPPandFlip flags
#define VPP_ODD             NV4_REG_VPP_INV_MASK_ODD
#define VPP_EVEN            NV4_REG_VPP_INV_MASK_EVEN
#define VPP_BOB             NV4_REG_VPP_INV_MASK_BOB
#define VPP_INTERLEAVED     NV4_REG_VPP_INV_MASK_INTERLEAVED
#define VPP_VIDEOPORT       NV4_REG_VPP_INV_MASK_VIDEOPORT
#define VPP_WAIT            NV4_REG_VPP_INV_MASK_WAIT
#define VPP_SAVE_STATE      NV4_REG_VPP_SAVE_STATE_DISABLE
#define VPP_RESTORE_STATE   NV4_REG_VPP_RESTORE_STATE_DISABLE
#define VPP_CONVERT         NV4_REG_VPP_CONVERT_DISABLE
#define VPP_SUBPICTURE      NV4_REG_VPP_SUBPICTURE_DISABLE
#define VPP_PRESCALE        NV4_REG_VPP_PRESCALE_DISABLE
#define VPP_COLOURCONTROL   NV4_REG_VPP_COLOURCONTROL_DISABLE
#define VPP_TEMPORAL        NV4_REG_VPP_TEMPORAL_DISABLE
#define VPP_OPTIMIZEFLIP    NV4_REG_VPP_OPTIMIZEFLIP_DISABLE
#define VPP_DEINTERLACE     NV4_REG_VPP_DEINTERLACE_DISABLE
#define VPP_FSMIRROR        NV4_REG_VPP_FSMIRROR_DISABLE
#define VPP_DMABLIT_DISABLE NV4_REG_VPP_DMABLIT_DISABLE
#define VPP_MASTER_DISABLE  NV4_REG_VPP_MASTER_DISABLE
// TBD: why redefine these?  Note that master disable WAS being used directly anyway. - mlavoie

#define VPP_ALL             (VPP_CONVERT | VPP_SUBPICTURE | VPP_PRESCALE | VPP_COLOURCONTROL | VPP_DEINTERLACE | VPP_TEMPORAL | VPP_FSMIRROR)
#define VPP_STATIC          (VPP_CONVERT | VPP_SUBPICTURE | VPP_PRESCALE | VPP_COLOURCONTROL | VPP_FSMIRROR)
#define VPP_MOCOMP          (VPP_PRESCALE | VPP_FSMIRROR)

#define IS_OVERLAY(caps,fourcc) ((caps & DDSCAPS_OVERLAY) && (fourcc != FOURCC_NVDS) && (fourcc != FOURCC_NVMC))
#define IS_FIELD(f) ((f & (VPP_INTERLEAVED | VPP_BOB)) && (f & (VPP_ODD | VPP_EVEN)))

#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.

// dispatcher commands
#define VPPDISPATCH_NOOP            0x0
#define VPPDISPATCH_DISPATCH        0x1
#define VPPDISPATCH_SETPRIORITY     0x2
#define VPPDISPATCH_RESTOREPRIORITY 0x4
#define VPPDISPATCH_EXIT            0xFFFFFFFF

// dispatcher state
#define VPPDSTATE_WAITING           0x1
#define VPPDSTATE_BUSY              0x2
#define VPPDSTATE_INITERROR         0x10000
#define VPPDSTATE_CMDERROR          0x20000
#define VPPDSTATE_TERMINATED        0x80000000

#endif

#ifdef DEBUG
    // so we know when something is drastically wrong
    #define VPP_TIMEOUT_TIME    250
    // snooping automatically enabled unless we're on NT where it doesn't work
    #ifndef WINNT
    #define VPP_SNOOP           1
    #endif
#else  // !DEBUG
    // maximum time we can spend on a frame
    #define VPP_TIMEOUT_TIME    42
    #ifdef DEVELOP
        #ifndef WINNT
        #define VPP_SNOOP       1
        #endif
    #endif  // DEVELOP
#endif  // !DEBUG

typedef struct {
  NvF32 sx;
  NvF32 sy;
  NvF32 sz;
  NvF32 rhw;
  NvV32 color;
  NvV32 specular;
  NvF32 tu0;
  NvF32 tv0;
  NvF32 tu1;
  NvF32 tv1;
} Tlmtvertex;

typedef struct Vpp_s Vpp_t;

void VppConstructor(GLOBALDATA *pDriverData,Vpp_t *pVpp);
void VppDestructor(Vpp_t *pVpp);

BOOL VppReadRegistry(Vpp_t *pVpp);


// Exported Functions
NvU8 VppPrepareResources(
    Vpp_t           *pVpp,
    CPushBuffer     *pPusher,
    NV_SystemInfo_t *pSysInfo,
    NvU32            hChannel,
    NvU32            hThreeDClass,
    NvU32            threeDClassSubCh,
    NvU8             threeDClassType,
    NvU32            hInVideoMemContextDma,
    NvU32            hFromVideoMemContextDma,
    NvU32            hToVideoMemContextDma,
    NvU32            hLutCursorDac,
    NvU32            hOverlayDmaToMemNotifier,
    NvU32            hOverlayFlipNotifier,
    NvU32            hMiscEventNotifier,
    NvU32            hContextSurfaceSwizzled,
    NvU32            hContextBeta4,
    NvU32            hSurfaces2D,
    NvU32            surfaces2DSubCh,
    NvU32            hVideoMemUtoVideoMemFormat,    // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat,    // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat,    // UV-conversion object
    NvU32            hDvdSubpicture,
    NvU32            hContextPattern,
    NvU32            hContextColorKey,
    NvU32            hGenericScaledImage,
    NvU32            hFloatingContextDmaInOverlayShadow,
    NvNotification  *pFlipOverlayNotifier,  // The above hOverlayFlipNotifier MUST be really wrong! -mlavoie
    NvNotification  *pFlipPrimaryNotifier,  
    NvNotification  *pPusherSyncNotifier,
    NvNotification  *pColorControlNotifier,

    NvU32            hContextSurfacesARGB_ZS,
    NvU32            hDX6MultiTextureTriangle,
    NvU32            hTimer,

    NvU32            ropRectTextSubCh,
    NvU32            ropSubCh,
    NvU32            spareSubCh);


NvU8 VppSetOverlayColourControl(Vpp_t *pVpp);

BOOL VppEnable(Vpp_t *pVpp);
void VppDisable(Vpp_t *pVpp);
BOOL VppEnableFSMirror(Vpp_t *pVpp, DWORD dwWidth, DWORD dwHeight);
void VppDisableFSMirror(Vpp_t *pVpp);
BOOL VppDoFlip(Vpp_t *pVpp,DWORD dwOffset, DWORD dwPitch, DWORD dwWidth,
                   DWORD dwHeight, DWORD dwFourCC, DWORD dwFlags);

#if (IS_WINNT5 | IS_WIN9X)
#define NV_GET_VIDEO_HEAP_FREE() (DWORD)vpp.pDriverData->VideoHeapFree

#elif (IS_WINNT4)
#define NV_GET_VIDEO_HEAP_FREE() (DWORD)vpp.pDriverData->ppdev->VideoHeapFree

#else
#error Unsupported OS.
#endif

/*
 * NV_ColorControl_t
 *    'Derived' from DDCOLORCONTROL for multi-OS compatibility
 */
#define NV_VPP_COLOR_BRIGHTNESS		0x00000001l // Field validity flags
#define NV_VPP_COLOR_CONTRAST		0x00000002l
#define NV_VPP_COLOR_HUE			0x00000004l
#define NV_VPP_COLOR_SATURATION		0x00000008l
#define NV_VPP_COLOR_SHARPNESS		0x00000010l
#define NV_VPP_COLOR_GAMMA			0x00000020l
#define NV_VPP_COLOR_COLORENABLE	0x00000040l

typedef struct {
    NvU32               dwLastFlags;
    NvU32               dwLastExec;
    NvU32               dwMarker1;
    NvU32               dwReserved1;

    LONGLONG            qwCount;    // TBD: what to do with LONGLONG? -mlavoie
    
    LONGLONG            qwInterFrameTime;
    LONGLONG            qwInterFrameAcc;
    LONGLONG            qwInterFramePeak;
    LONGLONG            qwInterFrameDelta;
    LONGLONG            qwInterFrameJitterAcc;
    LONGLONG            qwInterFrameJitterPeak;

    LONGLONG            qwIntraFrameAcc;
    LONGLONG            qwIntraFramePeak;
    LONGLONG            qwIntraFrameDelta;
    LONGLONG            qwIntraFrameJitterAcc;
    LONGLONG            qwIntraFrameJitterPeak;

    LONGLONG            qwMarker2;
    LONGLONG            qwReserved2;
} Vpp_snoop_t;


typedef struct NV_ColorControl_s
{
    NvU32 		dwSize;
    NvU32		dwFlags;
    NvS32		lBrightness;
    NvS32		lContrast;
    NvS32		lHue;
    NvS32 		lSaturation;
    NvS32		lSharpness;
    NvS32		lGamma;
    NvS32		lColorEnable;
    NvU32		dwReserved1;
} Nv_ColorControl_t;

// Experimental struct (may replace overlay corresponding vars with this as well)
typedef struct Nv_Surface_s
{
    NvU32       format; // TBD: enumerate - mlavoie
    NvU32       originX;
    NvU32       originY;
    NvU32       pitch;
    NvU32       width;
    NvU32       height;
    NvU32       offset; // General offset?  Unsure -mlavoie
} Nv_Surface_t;


#define NV_MAX_EXTRA_FS_SURFACES 4

// Copied from DDMINI.H - mlavoie

/* Shared Celsius class usage flags */
#define CELSIUSUSER_NONE                0  // celsius object is untouched and (almost) fully uninitialized
#define CELSIUSUSER_D3D                 1
#define CELSIUSUSER_DDRAW               2
#define CELSIUSUSER_DDRAW_VPP           3

#define VPP_3D_CLASS_IS_UNDEFINED 0
#define VPP_3D_CLASS_IS_CELSIUS   1
#define VPP_3D_CLASS_IS_KELVIN    2

#define VPP_FLAG_CONSTRUCTED    0x00000001 // VPP class has been initialized
#define VPP_FLAG_READY          0x00000002 // Resources have been assigned, and VPP is ready to be enabled
#define VPP_FLAG_ENABLED        0x00000004 // VPP has been enabled and is running
#define VPP_FLAG_CELSIUS_3D     0x00000008 // VPP is using a celsius class as it's 3D object
#define VPP_FLAG_KELVIN_3D      0x00000010 // VPP is using a kelvin class as it's 3D object

typedef struct {
    NvU32               dwOpCount;
    HDRVEVENT           hLastStage;
    NvU8                doLateFlipSync;
    NvU32               dwIndex;
    NvU32               dwSrcOffset;
    NvU32               dwSrcPitch;
    NvU32               dwWidth;
    NvU32               dwHeight;
    NvU32               dwFourCC;
    NvU32               dwFlags;
    NvU32               dwWorkSurfaces;
    NvU32               vppExec;
    LONGLONG            qwTime1;
    LONGLONG            qwTime2;
    LONGLONG            qwDelta;
    LONGLONG            qwJitter;
} Vpp_pipeline_state_t;

// Note: The 3D class object is used for "advanced" blts that are not possible
//  using the normal bltter.  Surfaces are treated as textures and texture ops
//  are applied to get the desired results.
//
// TBD: turn this into a proper class (if we can get away from C enough) - mlavoie
//
typedef struct Vpp_s
{
    NvU32             dwFlags; // General flags detailing state of the VPP object (see VPP_FLAG_*)

    DWORD             dwOverlayEventsAllocated;        // used to keep track of overlay event allocation

    GLOBALDATA      *pDriverData;          // Hope to eliminate this some day. -mlavoie

    CPushBuffer      *pPusher;             // A cmd pusher class attached to a DMA push buffer
    NV_SystemInfo_t  *pSysInfo;  // System Information
    
    NvU32            hChannel;
    NvU32            hThreeDClass;        // Unique object ID for the 3D object to be used
    NvU32            threeDClassSubCh;    // Subchannel that _always_ holds the 3D class object
    NvU32            hInVideoMemContextDma;      // DMA context for V2V 
    NvU32            hFromVideoMemContextDma;    // DMA context for V2S
    NvU32            hToVideoMemContextDma;      // DMA context for S2V
    NvU32            hOverlayDmaToMemNotifier; // must be context DMA to memory type
    NvU32            hOverlayFlipNotifier;       // This appears to be a dma notifier too?!?! -mlavoie

    NvU32            hLutCursorDacBase;   // Base object ID for DACs (1 per head)
    NvU32            hMiscEventNotifier;   // Used as the notifier in many cases
    NvU32            hContextSurfaceSwizzled;
    NvU32            hContextBeta4;
    NvU32            hSurfaces2D;
    NvU32            surfaces2DSubCh;       // May be able to just use spare? -mlavoie

    NvU32            hVideoMemUtoVideoMemFormat;    // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat;    // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat;    // UV-conversion object

    NvU32            hContextPattern;
    NvU32            hContextColorKey;


    NvU32            hDvdSubpicture;
    NvU32            hGenericScaledImage;
    NvU32            hFloatingContextDmaInOverlayShadow;

    NvNotification  *pFlipOverlayNotifier;  // The above hOverlayFlipNotifier MUST be really wrong! -mlavoie
    NvNotification  *pFlipPrimaryNotifier;
    NvNotification  *pPusherSyncNotifier;
    NvNotification  *pColorControlNotifier; // This isn't really for color control! -mlavoie rename

    NvU32            hContextSurfacesARGB_ZS;
    NvU32            hDX6MultiTextureTriangle;
    NvU32            hTimer;

    NvU32            ropRectTextSubCh;
    NvU32            ropSubCh;
    NvU32            spareSubCh;          // General use subchannel (SetObject always done first)

    // TBD:hMiscEventNotifier was using NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER which IS NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER -mlavoie

    NvU32            dwOverlayFSNumSurfaces;
    NvU32            dwOverlayFSHead;    //what head is overlay on over is head on
    NvU32            dwOverlayFSOvlHead; // where mirror is
    NvU32            dwOverlayFSOvlHeadSaved;
    NvU32            dwOverlayFSOvlLost;

    NvU32            dwOverlayFSOldOffset;
    NvU32            dwOverlayFSWidth;
    NvU32            dwOverlayFSHeight;
    NvU32            dwOverlayFSPitch;
    NvU32            dwOverlayFSFormat;
    NvU32            dwOverlayFSOffset[NV_VPP_MAX_EXTRA_FS_SURFACES];

    NvU32   dwOverlayFSIndex;
    NvU32   dwOverlayFSDeltaX;
    NvU32   dwOverlayFSDeltaY;

    // Size & offset of each of the extra surfaces used to run the VPP engine
    NvU32   extraOverlayOffset[NV_VPP_MAX_EXTRA_SURFACES];   // can be up to n "chunks" longer original surface
    NvU32   extraPitch;
    NvU32   extraNumSurfaces;
    NvU32   extraIndex; // Next 'extra' surface to be used

    NvU32   dwOverlaySurfaces;
    NvU32   dwOverlayOwner;
    NvU32   dwOverlaySurfaceLCL[NV_VPP_MAX_OVERLAY_SURFACES];
    NvU32   dwOverlaySrcWidth;
    NvU32   dwOverlaySrcHeight;
    NvU32   dwOverlayDstWidth;
    NvU32   dwOverlayDstHeight;
    NvU32   dwOverlayDeltaX;
    NvU32   dwOverlayDeltaY;

    NvU32   dwOverlaySrcX;          // overlay source starting point
    NvU32   dwOverlaySrcY;
    NvU32   dwOverlayDstX;        // overlay Dst starting point
    NvU32   dwOverlayDstY;
    NvU32   dwOverlaySrcOffset;
    NvU32   dwOverlayFormat;      // current overlay format - used so VDD knows what's up!
    NvU32   dwOverlaySrcPitch;    // current overlay pitch   - used so VDD knows what's up!
///
    NvU32   dwOverlayLastVisibleSurfaceLCL;
    NvU32   dwOverlayLastVisibleFpVidMem;
    NvU32   dwOverlayLastVisiblePitch;
    NvU32   dwOverlayLastVisiblePixelFormat;
    NvU32   dwOverlayFlipCount;
    NvU16   overlayBufferIndex;
    NvU16   overlayRelaxOwnerCheck;
    NvU32   dwOverlaySrcSize;
    NvU32   dwOverlayColorKey;

    NvU32                       dwOverlayCachedFlags;
    NvU32                       dwOverlayFSSrcWidth;
    NvU32                       dwOverlayFSSrcHeight;
    NvU32                       dwOverlayFSSrcMinX;
    NvU32                       dwOverlayFSSrcMinY;
    NVTWINVIEWDATA              dwOverlayFSTwinData;
    NvU32                       fpOverlayShadow;
    NvU32                       dwOverlayMaxDownScale;
    NvU32                       dwOverlayMaxDownScaleX;
    NvU32                       dwOverlayMaxDownScaleY;
    NvU32                       regOverlayColourControlEnable;
    NvU32                       dwOverlayByteAlignmentPad;
    NvU32                       regOverlayMode;
    NvU32                       regOverlayMode2;
    NvU32                       regOverlayMode3;
    NvU32                       regVPPInvMask;
    NvU32                       regVPPMaxSurfaces;

    NvU32                       regRing0ColourCtlInterlockFlags;    // bit0 = 1 -> ring0 should run; bit2 = 1 ring0 in progress
   


    NvU32                       dwOverlayMode;            // used to tell if we're doing interleaved or what...
//    VPPDISPATCH                 vppDispatch;          No longer used.
///

    NvU32                       dwPrevFrameOffset;

    __int64                     llDeliveryPeriod;    // in ns
    __int64                     llDeliveryTime;      // in ns
    __int64                     llDeliveryStart;     // in ns

    Nv_ColorControl_t    colorCtrl;

    Nv_Surface_t         subPicture; // Dvd Subpicture

    Vpp_pipeline_state_t pipeState;

    Vpp_snoop_t          snoop;

} Vpp_t;


#define DEFAULT_FINAL_CW0   (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0 << 24) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0 << 16) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0 << 8) |     \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |    \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |      \
                             NV056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C

#define DEFAULT_KELVIN_FINAL_CW0   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE << 29) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE << 28) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0 << 24) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE << 21) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE << 20) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0 << 16) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE << 13) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE << 12) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0 << 8) |     \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE << 5) |    \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE << 4) |      \
                                    NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C

// TBD: add CELSIUS to the following - mlavoie
#define DEFAULT_FINAL_CW1   (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |     \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |    \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |   \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |      \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C << 8) |     \
                                                                                            \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) | \
                            (NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) | \
                             NV056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE

#define DEFAULT_KELVIN_FINAL_CW1   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE << 29) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE << 28) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0 << 24) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE << 21) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE << 20) |     \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0 << 16) |    \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE << 13) |   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE << 12) |      \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C << 8) |     \
                                                                                                   \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE << 7) | \
                                   (NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE << 6) | \
                                    NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE

#ifdef __cplusplus
}
#endif // __cplusplus

#endif _NVVPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvtracecom.h ===
#ifndef __NV_TRACECOM_H
#define __NV_TRACECOM_H
// This struct is used for debug code.

typedef struct nvFunRec {
    char *uname;
    char *name;
    int class;
    int level;
    struct nvFunRec *next;
    int count;
    struct {
        int msh, lsh;
    } time;
} nvFunRec;

extern int nvDebugOptions;
extern int nvDebugMask;
extern int nvDebugLevel;
extern int nvControlOptions;

#endif __NV_TRACECOM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nv_name.h ===
typedef struct _CHIP_INFO
{
	ULONG   ulDevID;
	PWSTR   pwszChip;
	PWSTR   pwszAdapterString;
} CHIP_INFO;

CHIP_INFO   sChipInfo[] =
{
 // DEVICE ID  Chip ID name              Adapter ID Name
{0x0020,	L"RIVA TNT",		L"RIVA TNT"		},
{0x0028,	L"RIVA TNT2",		L"RIVA TNT2"		},
{0x002C,	L"Vanta",		L"Vanta"		},
{0x0029,	L"RIVA TNT2 Ultra",	L"RIVA TNT2 Ultra"	},
{0x002D,	L"RIVA TNT2 Model 64",	L"RIVA TNT2 Model 64"	},
{0x00A0,	L"Aladdin TNT2",	L"Aladdin TNT2"		},
{0x0100,	L"GeForce 256",		L"GeForce 256"		},
{0x0101,	L"GeForce DDR",		L"GeForce DDR"		},
{0x0103,	L"Quadro",		L"Quadro"		},
{0x0110,	L"GeForce2 MX",		L"GeForce2 MX"		},
{0x0111,	L"GeForce2 MX",		L"GeForce2 MX"		},
{0x0113,	L"Quadro2 MXR",		L"Quadro2 MXR"		},
{0x0150,	L"GeForce2 GTS",	L"GeForce2 GTS"		},
{0x0151,	L"GeForce2 GTS",	L"GeForce2 GTS"		},
{0x0152,	L"GeForce2 Ultra",	L"GeForce2 Ultra"	},
{0x0153,	L"Quadro2 Pro",		L"Quadro2 Pro"		},
{0x0200,	L"NV20",		L"NV20"		}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvVer.h ===
// nvver.h
//      Versions of NV drivers
//
// Copyright (C) Microsoft Corporation 1993.
// Portions Copyright 1993,1996 NVidia Corporation. All Rights Reserved.
//

// The following version numbers are owned by Microsoft.  We have permission
// to change the last 3 digits of each version string but no other digits
// until the next major Microsoft release.
//
// NOTE: This release must be bumped up to 4.10... (0x040A...) when starting
// to build Win98 drivers
//
//
// The following #defines are used for the driver version number. They should be
// updated for each build and they should agree with each other.
//
// Also, because NV_DRIVER_VERSION has a leading 0, it can't be used as a number
// in drivers (it'll be interpretted as octal). And since it does contain non-octal
// values drivers should use NV_DRIVER_VERSION_NUMBER instead.
//
#ifndef WIN31
#define NV_DRIVER_VERSION              0716
#endif
#define NV_DRIVER_VERSION_NUMBER       716
#define NV_VERSION_NUMBER               4,12,01,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_NT4           4,00,1381,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_NT5           5,12,01,NV_DRIVER_VERSION
#define NV_VERSION_NUMBER_DW            (0x0412010 | NV_DRIVER_VERSION)
#define NV_VERSION_STRING              "7.16"
#define NV_VERSION_MS_STRING           "4.12.01.0716\0"
#define NV_VERSION_MS_STRING_NT4       "4.00.1381.0716\0"
#define NV_VERSION_MS_STRING_NT5       "5.12.01.0716\0"

#define NV_COMPANY_NAME_STRING_SHORT    "NVIDIA"
#define NV_COMPANY_NAME_STRING_FULL     "NVIDIA Corporation"
#define NV_COMPANY_NAME_STRING          NV_COMPANY_NAME_STRING_FULL

#define NV04_PART_NAME_STRING           "RIVA TNT"
#define NV05_PART_NAME_STRING           "RIVA TNT2"
#define NV10_PART_NAME_STRING           "GeForce 256"
#define NV10GL_PART_NAME_STRING         "Quadro"
#define NV11_PART_NAME_STRING           "GeForce2 MX"
#define NV11GL_PART_NAME_STRING         "Quadro2 MXR"
#define NV15_PART_NAME_STRING           "GeForce2 GTS"
#define NV15GL_PART_NAME_STRING         "Quadro2 Pro"
#define NV20_PART_NAME_STRING           "NV20"
#define NV04_COMPAT_PART_NAME_STRING    NV_COMPANY_NAME_STRING_SHORT " Compatible"

#define NV_PART_NAME_STRING             NV04_COMPAT_PART_NAME_STRING



// #define MSBLD               // Defined for MS source builds only
                               // comment out for NVidia builds.
#ifndef MSBLD
#ifndef WIN32
#define VERSION                     NV_VERSION_MS_STRING
#endif


#ifndef _WIN32_WINNT
//
// Use NVidia standard version numbers for Win9x builds.
//
#define VER_PRODUCTVERSION_STR      NV_VERSION_MS_STRING
#define VER_PRODUCTVERSION          NV_VERSION_NUMBER
#define VER_PRODUCTVERSION_DW       NV_VERSION_NUMBER_DW
#else

//
// Use "standard" NT version numbers.
//
#include "ntverp.h"
#endif // #ifdef _WIN32_WINNT
#endif // #ifdef MSBLD




//
// NVDISP.drv NVidia Display Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Display driver, Version X.XX\0"
//
#define NV_NVDISPVER95  NV_PART_NAME_STRING " Windows 95/98 Display driver, Version " NV_VERSION_STRING " \0"

//
//

//
// NV.vxd NVidia Display MiniVDD
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Display MiniVDD, Version X.XX\0"
//
#define NV_NVVDDVER     NV_PART_NAME_STRING " Display MiniVDD, Version " NV_VERSION_STRING " \0"
//
//


//
// NVDD32.DLL NVidia Direct Draw Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVDD32VER    NV_PART_NAME_STRING " Direct Draw Driver, Version " NV_VERSION_STRING " \0"
//
//
//
// NVCPL.DLL NVidia Control Panel Extension
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVCPLVER    NV_COMPANY_NAME_STRING_SHORT " Display Properties Extension\0"


// NVQTWK.DLL NVidia Taskbar Utility Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVTASKBARVER   NV_COMPANY_NAME_STRING_SHORT " Taskbar Utility Library\0"


// NVDESK32.DLL NVidia Desktop Manager Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw Driver, Version X.XX\0"
//
#define NV_NVDESKMGRVER   NV_COMPANY_NAME_STRING_SHORT " Desktop Manager Hook Library\0"


//
// NVDCI.drv NVidia DCI Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia DCI driver, Version X.XX\0"
//
#define NV_NVDCIVER     NV_PART_NAME_STRING " DCI driver, Version " NV_VERSION_STRING " \0"
//
//

//
//
//
// NVINST32.DLL NVidia Driver Installation Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Driver Insatllation Library, Version X.XX\0"
//
#define NV_NVINST32VER      NV_PART_NAME_STRING " Driver Install Library, Version " NV_VERSION_STRING " \0"

//
//
//
// NVINSTNT.DLL NVidia Driver Installation Library
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Driver Insatllation Library, Version X.XX\0"
//
#define NV_NVINSTNTVER      NV_PART_NAME_STRING " Driver Install Library, Version " NV_VERSION_STRING " \0"

//
// NVRM NVidia Resource Manager
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Resource Manager DLL, Version X.XX\0"
//
#define NV_NVRMVER      NV_PART_NAME_STRING " Resource Manager, Version " NV_VERSION_STRING " \0"
//
//


//
//
//
// NVDD32.DLL NVidia Direct Draw/Direct 3D Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Direct Draw 2.x Driver, Version X.XX\0"
//
//#define NV_D3D32VER     NV_PART_NAME_STRING " Direct Draw/Direct 3D Driver, Version " NV_VERSION_STRING " \0"
#define NV_DD32VER      NV_PART_NAME_STRING " Direct Draw/Direct 3D Driver, Version " NV_VERSION_STRING " \0"

//
//
//
// NV4_MINI.SYS NVidia Windows NT Miniport Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Windows NT Miniport Driver, Version X.XX\0"
//
#ifdef _WIN32_WINNT
#if (_WIN32_WINNT < 0x0500)
#define NV_NTMINIVER    NV_PART_NAME_STRING " Windows NT 4.0 Miniport Driver, Version " NV_VERSION_STRING " \0"
#else
#define NV_NTMINIVER    NV_PART_NAME_STRING " Windows 2000 Miniport Driver, Version " NV_VERSION_STRING " \0"
#endif // #else
#endif // #ifdef _WIN32_WINNT

//
//
//
// NV4_DISP.DLL NVidia Windows NT Display Driver
//          Please update version in string below, DO NOT change
//          string, just the Number after Version.  It should
//          always look like this
//                  "NVidia Windows NT Display Driver, Version X.XX\0"
//
#ifdef _WIN32_WINNT
#if (_WIN32_WINNT < 0x0500)
#define NV_NTDISPVER    NV_PART_NAME_STRING " Windows NT 4.0 Display driver, Version " NV_VERSION_STRING " \0"
#else
#define NV_NTDISPVER    NV_PART_NAME_STRING " Windows 2000 Display driver, Version " NV_VERSION_STRING " \0"
#endif // #else
#endif // #ifdef _WIN32_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvUniversal.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _NVUNIVERSAL_H_
#define _NVUNIVERSAL_H_

/*==========================================================================;
 *
 *  File:       NvUniversal.h
 *
 *  Content:    Defines, constants, macros, and miscellaneous constructs that
 *              are commonly needed across all operating system platforms.
 *              
 *              If the code is specific to Windows, or Mac, or Linux it doesn't
 *              go here.
 *              
 ***************************************************************************/

#ifndef NVARCH
#error NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

// TBD: have everyone use this from here... -mlavoie
#if 0
#if (NVARCH >= 0x04)
#define NV_IN_PROGRESS          0x8000
#else
#define NV_IN_PROGRESS          0xFF
#endif
#endif

// TBD: combine this with PERFDATA from D3D -mlavoie
// TBD: move device version (and other appropos stuff) into this
typedef struct NV_SystemInfo_s
{
    // 32 byte bank
    NvU32 dwCPUFeatureSet;
    NvU32 dwProcessorSpeed;         // In MHz
    NvU32 dwSystemMemory;           // MB of system memory, rounded to the nearest 8
    NvU32 dwNVClasses;
    NvU32 dwNVClasses1;
    NvU32 dwPad_0[3];
} NV_SystemInfo_t;

// nvD3DPerfData.dwCPUFeatureSet
#define CPU_FS_MMX              0x00000001      // ) do not change - some code
#define CPU_FS_KATMAI           0x00000002      //  )          relies on the macros to match these numbers
#define CPU_FS_3DNOW            0x00000004      // )
#define CPU_FS_HALFFASTWRITE    0x00000008      // camino with agp4x and 1/2 nv fast writes
#define CPU_FS_FULLFASTWRITE    0x00000010      // camino with agp4x and 1/1 nv fast writes
#define CPU_FS_WILLAMETTE       0x00000020      //  Pentium 4 support
#define CPU_FS_ATHLON           0x00000040      // AMD Athlon
#define CPU_FS_PREFETCH         0x00000080      // supports prefetchNTA, prefetchT0, movntq
#define CPU_FS_SFENCE           0x00001000      // has sfence support
#define CPU_FS_64BIT            0x00008000      // 64-bit back end (VANTA)

/* Shared Celsius class usage flags */
#define CELSIUSUSER_NONE                0  // celsius object is untouched and (almost) fully uninitialized
#define CELSIUSUSER_D3D                 1
#define CELSIUSUSER_DDRAW               2
#define CELSIUSUSER_DDRAW_VPP           3

/* Shared Kelvin class usage flags */
#define KELVINUSER_NONE                 0  // kelvin object is untouched and (almost) fully uninitialized
#define KELVINUSER_D3D                  1
#define KELVINUSER_DDRAW                2
#define KELVINUSER_DDRAW_VPP            3

// NV_SYSTEM_INFO.dwNVClasses
// ordered from "worst" to "best" within each class
#define NVCLASS_0055_DX6TRI     0x00000001
#define NVCLASS_0095_DX6TRI     0x00000002

#define NVCLASS_0054_DX5TRI     0x00000004
#define NVCLASS_0094_DX5TRI     0x00000008

#define NVCLASS_0056_CELSIUS    0x00000010
#define NVCLASS_0096_CELSIUS    0x00000020
#define NVCLASS_1196_CELSIUS    0x00000040

#define NVCLASS_0097_KELVIN     0x00000080

#define NVCLASS_0046_DAC        0x00000100
#define NVCLASS_0049_DAC        0x00000200
#define NVCLASS_0067_DAC        0x00000400
#define NVCLASS_007C_DAC        0x00000800

#define NVCLASS_0042_CTXSURF2D  0x00001000
#define NVCLASS_0062_CTXSURF2D  0x00002000

#define NVCLASS_0060_IDXIMAGE   0x00004000
#define NVCLASS_0064_IDXIMAGE   0x00008000

#define NVCLASS_0077_SCALEDIMG  0x00010000
#define NVCLASS_0063_SCALEDIMG  0x00020000
#define NVCLASS_0089_SCALEDIMG  0x00040000

#define NVCLASS_0038_DVDPICT    0x00100000
#define NVCLASS_0088_DVDPICT    0x00200000

#define NVCLASS_007A_OVERLAY    0x00400000

#define NVCLASS_0053_CTXSURF3D  0x01000000
#define NVCLASS_0093_CTXSURF3D  0x02000000

#define NVCLASS_004A_GDIRECT    0x04000000
#define NVCLASS_005E_SOLIDRECT  0x08000000

#define NVCLASS_0052_CTXSURFSWZ 0x10000000
#define NVCLASS_009E_CTXSURFSWZ 0x20000000

// class 0 collectives
#define NVCLASS_FAMILY_DXTRI    (NVCLASS_0094_DX5TRI  | NVCLASS_0054_DX5TRI  | NVCLASS_0095_DX6TRI | NVCLASS_0055_DX6TRI)
#define NVCLASS_FAMILY_CELSIUS  (NVCLASS_0056_CELSIUS | NVCLASS_0096_CELSIUS | NVCLASS_1196_CELSIUS)
#define NVCLASS_FAMILY_KELVIN   (NVCLASS_0097_KELVIN)

// NV_SYSTEM_INFO.dwNVClasses1
// ordered from "worst" to "best" within each class
#define NVCLASS1_006C_CHANNELDMA 0x00000001
#define NVCLASS1_006E_CHANNELDMA 0x00000002
#define NVCLASS1_206E_CHANNELDMA 0x00000004

// class 1 collectives
// none yet

#define SUB_CHANNEL(I) (I * 0x00002000) // Computes subchannel offset given a simple ndx 0-7

// Convert Microsoft Specific modifier (not available on all MS compilers either)
#if defined(__forceinline)
#define FORCE_INLINE __forceinline
#else
#define FORCE_INLINE inline
#endif

#endif // _NVUNIVERSAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\nvUtil.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#ifndef _NVUTIL_H_
#define _NVUTIL_H_

#include "nvTypes.h"

// returns the index of the least significant bit = log2(x) if x=2^n
#define ASM_LOG2(x)     __asm mov eax,[x]   __asm bsf ecx,eax   __asm mov [x],ecx
// returns the index of the most significant bit = log2(x) if x=2^n
#define ASM_LOG2_R(x)   __asm mov eax,[x]   __asm bsr ecx,eax   __asm mov [x],ecx

 /***************************************************************************\
|*                                                                           *|
|*                       General nVidia Utilties                             *|
|*                                                                           *|
|*  These are functions like nvAssert, nvStrLen.                             *|
|*                                                                           *|
|*  Various OSes do not provide these functions (or don't provide them in    *|
|*  the environment in which the driver must run), so we define out own.     *|
|*                                                                           *|
|*  This file is OS independant.  Use ONLY nVidia types and names.           *|
|*                                 [eg. No DWORD, use NvU32]                 *|
|*                                                                           *|
 \***************************************************************************/
NvU32 nvStrLen(char *szStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\vesa\vesadata.h ===
#ifndef _VESADATA_H_
#define _VESADATA_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/


//*****************************************************************************
//
// Definition of display timing terms:
//
//
//  <------------------><--------><-------><------><-------><--------><--------
//
//     Active Display     Border    Porch    Sync    Porch    Border    Active
//
//
//  <---------------------------------------------------------------->
//  Total
//
//  <------------------>
//  Visible
//
//  <---------------------------->
//  Blank Start
//
//  <------------------------------------->
//  Sync Start
//
//  <--------------------------------------------->
//  Sync End
//
//  <------------------------------------------------------>
//  Blank End
//
//*****************************************************************************

#ifndef BUFFER_HSYNC_NEGATIVE
// nvrm.h also defines these. So check if it is already defined.
#define BUFFER_HSYNC_NEGATIVE           1
#define BUFFER_HSYNC_POSITIVE           0
#define BUFFER_VSYNC_NEGATIVE           1
#define BUFFER_VSYNC_POSITIVE           0

#endif

typedef struct _mode_timing_values
{  
    unsigned int HorizontalVisible; 
    unsigned int VerticalVisible;
    unsigned int Refresh;
    unsigned int HorizontalTotal; 
    unsigned int HorizontalBlankStart; 
    unsigned int HorizontalRetraceStart; 
    unsigned int HorizontalRetraceEnd; 
    unsigned int HorizontalBlankEnd;
    unsigned int VerticalTotal; 
    unsigned int VerticalBlankStart; 
    unsigned int VerticalRetraceStart; 
    unsigned int VerticalRetraceEnd; 
    unsigned int VerticalBlankEnd;
    unsigned int PixelClock;
    unsigned int HSyncpolarity; 
    unsigned int VSyncpolarity; 
} MODE_TIMING_VALUES;

unsigned int vesaGetGTFTimings (unsigned int hRes, 
                                unsigned int vRes, 
                                unsigned int refreshRate, 
                                MODE_TIMING_VALUES * timingInfo);
unsigned int vesaGetDMTTimings (unsigned int hRes, 
                                unsigned int vRes, 
                                unsigned int refreshRate, 
                                MODE_TIMING_VALUES * timingInfo);

unsigned int vesaGetNumGTFEntries(void);


#endif // _VESADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv4\nv10.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV10.C
//
// Abstract:
//
//     This is code specific to NV10
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"
#include "vesadata.h"

#include "nvos.h"
#include "rm.h"

#include "nvreg.h"
#include "nvcm.h"

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV10ChipFBPowerSave(PHW_DEVICE_EXTENSION);
VOID NV10ChipFBPowerRestore(PHW_DEVICE_EXTENSION);

//******************************************************************************
// External Declarations
//******************************************************************************

//******************************************************************************
// Hack -> Eventually, we want to include the official
//         NVREF.H file, located in \kernel\resman\inc.
//         However, since this miniport already has an nvref.h file,
//         we'll have to pick and choose.  This will all get
//         overhauled when the miniport is re-architected.
//******************************************************************************

#define NV_PGRAPH_TILE(i)                       (0x00400b00+(i)*16) /* RW-4A */
#define NV_PGRAPH_TLIMIT(i)                     (0x00400b04+(i)*16) /* RW-4A */
#define NV_PGRAPH_TSIZE(i)                      (0x00400b08+(i)*16) /* RW-4A */
#define NV_PBUS_DEBUG_1                                  0x00001084

#define NV_PRAMIN_DATA032(i)                     (0x00700000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                            524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                31:0 /* RWXVF */


#define NV_PFB_TIMING2                                   0x00100228 /* RW-4R */
#define NV_PFB_TIMING2_REFRESH                                 15:5 /* RW-VF */
#define NV_PFB_CFG                                       0x00100200 /* RW-4R */
#define NV_PFB_CSTATUS                                   0x0010020C /* R--4R */
#define NV_PFB_REFCTRL                                   0x00100210 /* RW-4R */
#define NV_PFB_MRS                                       0x001002C0 /* RW-4R */
#define NV_PFB_EMRS                                      0x001002C4 /* RW-4R */
#define NV_PFB_REF                                       0x001002D0 /* -W-4R */

//******************************************************************************
//
// Function:    NV10ChipFBPowerSave()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV10ChipFBPowerSave (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    // power down mode - max out memory refresh value
    HwDeviceExtension->Power_refresh = REG_RD32(NV_PFB_TIMING2);   // refresh
    FLD_WR_DRF_NUM(_PFB, _TIMING2, _REFRESH, 0xFFFFFFFF);       // max refresh
    // Chip has been init'd with the BIOS init tables, unless the BIOS
    // has an incompatible structure and the table was not found, in which case
    // we used a default table, which may not have the correct RAM config, so
    // we save away the current config for restoration above.
    HwDeviceExtension->Power_PfbBoot0     = REG_RD32(NV_PFB_CFG);           // RAM config
    HwDeviceExtension->Power_PfbConfig0   = REG_RD32(NV_PFB_CSTATUS);       // RAM config
    HwDeviceExtension->Power_PfbConfig1   = REG_RD32(NV_PFB_REFCTRL);       // RAM config
    HwDeviceExtension->Power_PfbMrs       = REG_RD32(NV_PFB_MRS);           // RAM config
    HwDeviceExtension->Power_PfbEmrs      = REG_RD32(NV_PFB_EMRS);          // RAM config
    HwDeviceExtension->Power_PfbRef       = REG_RD32(NV_PFB_REF);           // RAM config
    HwDeviceExtension->Power_PbusDebug1   = REG_RD32(NV_PBUS_DEBUG_1);      // RAM config
    HwDeviceExtension->Power_PextdevBoot0 = REG_RD32(NV_PEXTDEV_BOOT_0);    // READ STRAPS
    HwDeviceExtension->Power_PfifoRamHT   = REG_RD32(NV_PFIFO_RAMHT);
    HwDeviceExtension->Power_PfifoRamRO   = REG_RD32(NV_PFIFO_RAMRO);
    HwDeviceExtension->Power_PfifoRamFC   = REG_RD32(NV_PFIFO_RAMFC);

    }



//******************************************************************************
//
// Function:    NV10ChipFBPowerRestore()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV10ChipFBPowerRestore (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 D0_DELAY_RETRIES = 10; 
    U032 retry = 0;             
    U032 i;                     

    // power up mode - restore previous memory config
    REG_WR32(NV_PBUS_DEBUG_1, HwDeviceExtension->Power_PbusDebug1);   // must set FBI differential
    REG_WR32(NV_PFB_TIMING2, HwDeviceExtension->Power_refresh);       // refresh
    REG_WR32(NV_PFB_CFG, HwDeviceExtension->Power_PfbBoot0);          // RAM config
    REG_WR32(NV_PFB_CSTATUS, HwDeviceExtension->Power_PfbConfig0);    // RAM config
    REG_WR32(NV_PFB_REFCTRL, HwDeviceExtension->Power_PfbConfig1);    // RAM config
    REG_WR32(NV_PFB_MRS, HwDeviceExtension->Power_PfbMrs);    		 // RAM config
//  REG_WR32(NV_PFB_EMRS, HwDeviceExtension->Power_PfbEmrs);    		 // RAM config - reset
    REG_WR32(NV_PFB_REF, HwDeviceExtension->Power_PfbRef);    		 // RAM config

//  A delay seems to be necessary for i820 for win9x.
//  Couldn't demonstrate a problem with W2K, so its here for safety.
//  Reading NV_PMC_ENABLE is simply a convenient delay    
    while (REG_RD32(NV_PEXTDEV_BOOT_0) != HwDeviceExtension->Power_PextdevBoot0)
        {
        for (i=0; i<2000; i++)
            {
            REG_RD32(NV_PMC_ENABLE);
            }
        REG_WR32(NV_PEXTDEV_BOOT_0, HwDeviceExtension->Power_PextdevBoot0);    // WRITE STRAP REG
        retry++;
        if (retry == D0_DELAY_RETRIES)
            break;
        }
    REG_WR32(NV_PFIFO_RAMHT, HwDeviceExtension->Power_PfifoRamHT);      
    REG_WR32(NV_PFIFO_RAMRO, HwDeviceExtension->Power_PfifoRamRO);      
    REG_WR32(NV_PFIFO_RAMFC, HwDeviceExtension->Power_PfifoRamFC);      

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\vtxpgmconsts.h ===
/*
** vtxpgmconsts.h
**
** Vertex Program Constant Declarations.
**
** Copyright 2000 NVIDIA, Corporation.  All rights reserved.
** 
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/

#ifndef __gl_vtxpgmconsts_h_
#define __gl_vtxpgmconsts_h_

#pragma warning (disable:4244)  /* Disable bogus VC++ 4.2 conversion warnings. */
#pragma warning (disable:4305)  /* VC++ 5.0 version of above warning. */

/*
** This file is shared between OpenGL and D3D so don't mess with it!
*/

/*
** Constants used for programs:
*/

#define __GL_NUMBER_OF_VERTEX_ATTRIBS       16
#define __GL_NUMBER_OF_PROGRAM_MATRICES     8
#define __GL_NUMBER_OF_TEMPORARY_REGISTERS  12
#define __GL_NUMBER_OF_RESULT_REGISTERS     16
#define __GL_NUMBER_OF_CONSTANT_REGISTERS   96
#define __GL_NUMBER_OF_PADDING_REGISTERS    128
#define __GL_MAX_NUMBER_OF_INSTRUCTIONS     128

#define __GL_KELVIN_FIRST_USER_CONSTANT_REGISTER    96


/*
** Names for each of the vertex attributes
*/

#define __GL_ATTRIB_POSITION            0
#define __GL_ATTRIB_VERTEX_WEIGHT       1
#define __GL_ATTRIB_NORMAL              2
#define __GL_ATTRIB_COLOR               3
#define __GL_ATTRIB_SECONDARY_COLOR     4
#define __GL_ATTRIB_FOG_COORD           5
#define __GL_ATTRIB_UNUSED0             6
#define __GL_ATTRIB_UNUSED1             7
#define __GL_ATTRIB_TEXCOORD0           8
#define __GL_ATTRIB_TEXCOORD1           9
#define __GL_ATTRIB_TEXCOORD2           10
#define __GL_ATTRIB_TEXCOORD3           11
#define __GL_ATTRIB_TEXCOORD4           12
#define __GL_ATTRIB_TEXCOORD5           13
#define __GL_ATTRIB_TEXCOORD6           14
#define __GL_ATTRIB_TEXCOORD7           15

/*
** Names for the output components:
*/

#define __GL_ATTRIB_OUTPUT_HPOS         0
#define __GL_ATTRIB_OUTPUT_COL0         3
#define __GL_ATTRIB_OUTPUT_COL1         4
#define __GL_ATTRIB_OUTPUT_BFC0         7
#define __GL_ATTRIB_OUTPUT_BFC1         8
#define __GL_ATTRIB_OUTPUT_FOGC         5
#define __GL_ATTRIB_OUTPUT_PSIZ         6
#define __GL_ATTRIB_OUTPUT_TEX0         9
#define __GL_ATTRIB_OUTPUT_TEX1         10
#define __GL_ATTRIB_OUTPUT_TEX2         11
#define __GL_ATTRIB_OUTPUT_TEX3         12
#define __GL_ATTRIB_OUTPUT_TEX4         13
#define __GL_ATTRIB_OUTPUT_TEX5         14
#define __GL_ATTRIB_OUTPUT_TEX6         15
#define __GL_ATTRIB_OUTPUT_TEX7         15

/*
** Enable bits tested by compiled x886 code:
*/

#define __GL_PROGRAM_ENABLE_TEXTURE0    1
#define __GL_PROGRAM_ENABLE_TEXTURE1    2

#endif /* __gl_vtxpgmconsts_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\vtxpgmcomp.h ===
/*
** vtxpgmcomp.h
**
** Vertex Program Declarations.
**
** Copyright 2000 NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/

/*
** This file is shared between OpenGL and D3D so don't mess with it!
**
** In particular, don't use any OpenGL or D3D specific types.  There are
** plenty of perfectly good types in the C language itself.
**
*/

#ifndef __gl_vtxpgmcomp_h_
#define __gl_vtxpgmcomp_h_

#include "vtxpgmconsts.h"

#define NV_INTERNAL_OPCODES 1

/*
** Optimization flags:
*/

#define OPT_LIVE_DEAD 1
#define OPT_ALL       1

/*
** Structures for instruction description.
*/

typedef enum OpcodeClasses_Enum {
    CLASS_ARL = 0,
    CLASS_VECTOR,
    CLASS_SCALAR,
    CLASS_BIN,
    CLASS_TRI,
    CLASS_END,
} OpcodeClasses;

typedef enum Opcodes_Enum {

    // END op:

    OP_END = 0,
#if defined(NV_INTERNAL_OPCODES)
    OP_NOP,
#endif

    // ARL op:

    OP_ARL,

    // VECTOR ops:

    OP_LIT, OP_MOV,
#if defined(NV_INTERNAL_OPCODES)
    OP_IMV,
#endif

    // SCALAR ops:

    OP_EXP, OP_LOG, OP_RCP, OP_RSQ,
#if defined(NV_INTERNAL_OPCODES)
    OP_RCC,
#endif

    // BIN ops:

    OP_ADD, OP_DP3, OP_DP4, OP_DST, OP_MAX, OP_MIN, OP_MUL, OP_SGE, OP_SLT,
#if defined(NV_INTERNAL_OPCODES)
    OP_DPH,
#endif

    // TRI op:

    OP_MAD,
} Opcodes;

#define VERTEX_PROGRAM_OPCODE_NAMES                                         \
    "END", "NOP",                                                           \
    "ARL",                                                                  \
    "LIT", "MOV", "IMV",                                                    \
    "EXP", "LOG", "RCP", "RSQ", "RCC",                                      \
    "ADD", "DP3", "DP4", "DST", "MAX", "MIN", "MUL", "SGE", "SLT", "DPH",   \
    "MAD",

typedef enum Component_Enum {
    XX = 0, YY, ZZ, WW,
} Component_t;

typedef enum Component4_Enum {
    XYZW = (XX | YY << 2 | ZZ << 4 | WW << 6),
} Component4;

typedef enum DestMaskBits_Enum {
    DST_NONE_BITS = 0,
    DST_X_BIT = 1, DST_Y_BIT = 2, DST_Z_BIT = 4, DST_W_BIT = 8,
    DST_YZ_BITS = 6,
    DST_XYZ_BITS = 7,
    DST_XYW_BITS = 11,
    DST_XYZW_BITS = 15,
} DestMaskBits;

typedef enum Register_Enum {

    VA_0 = 0,   VA_OPOS = 0,  VA_1 = 1,   VA_WGHT = 1,
    VA_2 = 2,   VA_NRML = 2,  VA_3 = 3,   VA_COL0 = 3,
    VA_4 = 4,   VA_COL1 = 4,  VA_5 = 5,   VA_FOGC = 5,
    VA_6 = 6,                 VA_7 = 7,
    VA_8 = 8,   VA_TEX0 = 8,  VA_9 = 9,   VA_TEX1 = 9,
    VA_10 = 10, VA_TEX2 = 10, VA_11 = 11, VA_TEX3 = 11,
    VA_12 = 12, VA_TEX4 = 12, VA_13 = 13, VA_TEX5 = 13,
    VA_14 = 14, VA_TEX6 = 14, VA_15 = 15, VA_TEX7 = 15,

    VR_0 = 16,  VR_HPOS = VR_0,
    VR_1 = 17,  
    VR_2 = 18,  
    VR_3 = 19,  VR_COL0 = VR_3,
    VR_4 = 20,  VR_COL1 = VR_4,
    VR_5 = 21,  VR_FOGC = VR_5,
    VR_6 = 22,  VR_PSIZ = VR_6,
    VR_7 = 23,  VR_BFC0 = VR_7,
    VR_8 = 24,  VR_BFC1 = VR_8,
    VR_9 = 25,  VR_TEX0 = VR_9,
    VR_10 = 26, VR_TEX1 = VR_10,
    VR_11 = 27, VR_TEX2 = VR_11,
    VR_12 = 28, VR_TEX3 = VR_12,
    VR_13 = 29, VR_TEX4 = VR_13,
    VR_14 = 30, VR_TEX5 = VR_14,
    VR_15 = 31, VR_TEX6 = VR_15, VR_TEX7 = VR_15,

    PR_0 = 32,   PR_1 = 33,   PR_2 = 34,   PR_3 = 35,
    PR_4 = 36,   PR_5 = 37,   PR_6 = 38,   PR_7 = 39,
    PR_8 = 40,   PR_9 = 41,   PR_10 = 42,  PR_11 = 43,
    PR_12 = 44,  PR_13 = 45,  PR_14 = 46,  PR_15 = 47,
    PR_16 = 48,  PR_17 = 49,  PR_18 = 50,  PR_19 = 51,
    PR_20 = 52,  PR_21 = 53,  PR_22 = 54,  PR_23 = 55,
    PR_24 = 56,  PR_25 = 57,  PR_26 = 58,  PR_27 = 59,
    PR_28 = 60,  PR_29 = 61,  PR_30 = 62,  PR_31 = 63,
    PR_32 = 64,  PR_33 = 65,  PR_34 = 66,  PR_35 = 67,
    PR_36 = 68,  PR_37 = 69,  PR_38 = 70,  PR_39 = 71,
    PR_40 = 72,  PR_41 = 73,  PR_42 = 74,  PR_43 = 75,
    PR_44 = 76,  PR_45 = 77,  PR_46 = 78,  PR_47 = 79,
    PR_48 = 80,  PR_49 = 81,  PR_50 = 82,  PR_51 = 83,
    PR_52 = 84,  PR_53 = 85,  PR_54 = 86,  PR_55 = 87,
    PR_56 = 88,  PR_57 = 89,  PR_58 = 90,  PR_59 = 91,
    PR_60 = 92,  PR_61 = 93,  PR_62 = 94,  PR_63 = 95,
    PR_64 = 96,  PR_65 = 97,  PR_66 = 98,  PR_67 = 99,
    PR_68 = 100, PR_69 = 101, PR_70 = 102, PR_71 = 103,
    PR_72 = 104, PR_73 = 105, PR_74 = 106, PR_75 = 107,
    PR_76 = 108, PR_77 = 109, PR_78 = 110, PR_79 = 111,
    PR_80 = 112, PR_81 = 113, PR_82 = 114, PR_83 = 115,
    PR_84 = 116, PR_85 = 117, PR_86 = 118, PR_87 = 119,
    PR_88 = 120, PR_89 = 121, PR_90 = 122, PR_91 = 123,
    PR_92 = 124, PR_93 = 125, PR_94 = 126, PR_95 = 127,

    TR_0 = 128,  TR_1 = 129,  TR_2 = 130,  TR_3 = 131,
    TR_4 = 132,  TR_5 = 133,  TR_6 = 134,  TR_7 = 135,
    TR_8 = 136,  TR_9 = 137,  TR_10 = 138, TR_11 = 139,
    TR_12 = 140, TR_13 = 141, TR_14 = 142, TR_15 = 143,

    ARL = 144,

    ZER = 145,

} Register_t;

typedef struct SrcReg_Rec {
    Register_t reg;
    unsigned char AddrReg;
    int addrRegOffset;
} SrcReg;

typedef struct ScalarSrcReg_Rec {
    SrcReg reg;
    Component_t com;
    unsigned char Signed;
} ScalarSrcReg;

typedef struct SwizzleSrcReg_Rec {
    SrcReg reg;
    unsigned char com4;
    unsigned char Signed;
} SwizzleSrcReg;

typedef struct MaskedDstReg_Rec {
    Register_t reg;
    unsigned char mask;
} MaskedDstReg;

typedef struct Arl_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    ScalarSrcReg src;
} Arl_Instruction;

typedef struct Vector_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg src;
} Vector_Instruction;

typedef struct Scalar_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    ScalarSrcReg src;
} Scalar_Instruction;

typedef struct Bin_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg srcA;
    SwizzleSrcReg srcB;
} Bin_Instruction;

typedef struct Tri_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;

    MaskedDstReg dst;
    SwizzleSrcReg srcA;
    SwizzleSrcReg srcB;
    SwizzleSrcReg srcC;
} Tri_Instruction;

typedef struct End_Instruction_Rec {
    Opcodes opcode;
    OpcodeClasses opclass;
} End_Instruction;

typedef union Instruction_Rec {
    Arl_Instruction arl_op;
    Vector_Instruction vector_op;
    Scalar_Instruction scalar_op;
    Bin_Instruction bin_op;
    Tri_Instruction tri_op;
    End_Instruction end_op;
} Instruction;

typedef struct ParsedProgram_Rec {
    Instruction *firstInstruction;  // Pointer to array of instructions
    unsigned int liveOnEntry;       // Mask of "live" temp registers upon entry
    unsigned char resultRegsWritten[__GL_NUMBER_OF_RESULT_REGISTERS];
                                    // Mask of result registers written
    int IsStateProgram;             // True if this is a state program
    Instruction instArray[1];
} ParsedProgram;

void vp_Optimize(ParsedProgram *parsed, int numInstructions, int optimizeMask);

/*
** Common structure for X86 compilation of vertex programs
*/

#define CALLER_ID_D3D    0xD3D
#define CALLER_ID_OPENGL 0xD4D

typedef struct VtxProgCompileX86_Rec {
    void *(* malloc)(void *tag, size_t size);
    void (* free)(void *tag, void *address);
    void *(* exec_malloc)(void *tag, size_t size);
    void *mallocArg;
    float (* expf)(float f);
    float (* logf)(float f);
    int caller_id;
    int attrib_offset;
    int temp_offset;
    int result_offset;
    int param_offset;
    int float_zero_offset;
    int float_one_offset;
    // Used to compile code to fill pushbuffer directly:
    int channel_number;
    int enables_offset;
} VtxProgCompileX86;

typedef struct VertexProgramOutput_Rec {
    void *residentProgram;
    size_t residentSize;
    int residentNumInstructions;
} VertexProgramOutput;

int vp_CompileX86(VtxProgCompileX86 *, ParsedProgram *, int numInstructions,
                  VertexProgramOutput *);
int vp_OutputCelsiusX86(VtxProgCompileX86 *, ParsedProgram *, int numInstructions,
                  VertexProgramOutput *);

/*
** Common structure for Kelvin compilation of vertex programs
*/

typedef struct vtxpgmInstPacked_Rec {
    unsigned int x, y, z, w;
} vtxpgmInstPacked;

typedef struct VtxProgCompileKelvin_Rec {
    void *(* malloc)(void *tag, size_t size);
    void (* free)(void *tag, void *address);
    void *mallocArg;
    int caller_id;
} VtxProgCompileKelvin;

int vp_CompileKelvin(VtxProgCompileKelvin *, ParsedProgram *, int numInstructions,
                     VertexProgramOutput *);

/*
** Static global data used in shared code to call imported functions:
**
** TEMPORARY!!!!!!!
*/


struct VtxProgImports_Rec {
    float (* expf)(float f);
    float (* logf)(float f);
};


extern struct VtxProgImports_Rec VtxProgImports;

#endif /* __gl_vtxpgmcomp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\inc\x86.h ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: x86.h                                                             *
*   x86 architexture specific macros - used mainly to generate assembly     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 02/10/98 - wrote it.                    *
*                                                                           *
\***************************************************************************/

/*****************************************************************************
 * constants
 *****************************************************************************/

#ifndef _x86_h
#define _x86_h

#ifdef __cplusplus
extern "C" {
#endif

/*
 * registers
 */
#define rEAX            0
#define rECX            1
#define rEDX            2
#define rEBX            3
#define rESP            4
#define rEBP            5
#define rESI            6
#define rEDI            7

#define rAX             0
#define rCX             1
#define rDX             2
#define rBX             3
#define rSP             4
#define rBP             5
#define rSI             6
#define rDI             7

#define rAL             0
#define rCL             1
#define rDL             2
#define rBL             3
#define rAH             4
#define rCH             5
#define rDH             6
#define rBH             7

#define rMM0            0
#define rMM1            1
#define rMM2            2
#define rMM3            3
#define rMM4            4
#define rMM5            5
#define rMM6            6
#define rMM7            7

#define rXMM0           0
#define rXMM1           1
#define rXMM2           2
#define rXMM3           3
#define rXMM4           4
#define rXMM5           5
#define rXMM6           6
#define rXMM7           7

#define rST0            0
#define rST1            1
#define rST2            2
#define rST3            3
#define rST4            4
#define rST5            5
#define rST6            6
#define rST7            7

/*
 * op codes
 *  alphabetically sorted
 */
#define xADC_rEAX_imm(i)        x86s(5) x86b(0x15) x86d(i)
#define xADD_r_rm(r,rm)         x86s(2) x86b(0x03) x86b(mREG(r) | (rm))
#define xADD_r_i32(r,a)         x86s(6) x86b(0x03) x86b(mREG(r) | mOFS32) x86d(a)
#define xADD_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(0) | (rm)) x86b(i)
#define xADD_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(0) | (rm)) x86d(i)
#define xADD_rm_r(rm,r)         x86s(2) x86b(0x01) x86b(mREG(r) | (rm))
#define xADD_i32_r(a,r)         x86s(6) x86b(0x01) x86b(mREG(r) | mOFS32) x86d(a)

#define xAND_r_rm(r,rm)         x86s(2) x86b(0x23) x86b(mREG(r) | (rm))
#define xAND_r_i32(r,a)         x86s(6) x86b(0x23) x86b(mREG(r) | mOFS32) x86d(a)
#define xAND_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(4) | (rm)) x86b(i)
#define xAND_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(4) | (rm)) x86d(i)

#define xCALL_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(2) | (rm))

#define xCMOVA_r_i32(r,a)       x86s(7) x86b(0x0f) x86b(0x47) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMOVA_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x47) x86b(mREG(r) | (rm))
#define xCMOVB_r_i32(r,a)       x86s(7) x86b(0x0f) x86b(0x42) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMOVB_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x42) x86b(mREG(r) | (rm))
#define xCMOVG_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x4f) x86b(mREG(r) | (rm))
#define xCMOVL_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x4c) x86b(mREG(r) | (rm))

#define xCMP_r_rm(r,rm)         x86s(2) x86b(0x3b) x86b(mREG(r) | (rm))
#define xCMP_r_i32(r,a)         x86s(6) x86b(0x3b) x86b(mREG(r) | mOFS32) x86d(a)
#define xCMP_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(7) | (rm)) x86d(i)

#define xDEC_r(r)               x86s(1) x86b(0x48 | (r))
#define xDEC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(1) | (rm))
#define xDEC_i32(a)             x86s(6) x86b(0xff) x86b(mREG(1) | mOFS32) x86d(a)

#define xDIV_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(6) | (rm))

#define xFABS()                 x86s(2) x86b(0xd9) x86b(0xe1)

#define xFADD_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(0) | (rm))
#define xFADD_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(0) | mOFS32) x86d(a)
#define xFADD_st(r)             x86s(2) x86b(0xd8) x86b(0xc0 + (r))
#define xFADDP_st(r)            x86s(2) x86b(0xde) x86b(0xc0 + (r))

#define xFDECSTP                x86s(2) x86b(0xd9) x86b(0xf6)

#define xFCHS                   x86s(2) x86b(0xd9) x86b(0xe0)

#define xFCOM_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(2) | (rm))
#define xFCOM_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(2) | mOFS32) x86d(a)
#define xFCOM_st(r)             x86s(2) x86b(0xd8) x86b(0xd0 + (r))
#define xFCOMI_st(r)            x86s(2) x86b(0xdb) x86b(0xf0 + (r))
#define xFCOMIP_st(r)           x86s(2) x86b(0xdf) x86b(0xf0 + (r))
#define xFCOMP_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(3) | (rm))
#define xFCOMPP()               x86s(2) x86b(0xde) x86b(0xd9)

#define xFDIV_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(6) | (rm))
#define xFDIVR_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(7) | (rm))

#define xFFREE_st(r)            x86s(2) x86b(0xdd) x86b(0xc0 + (r))

#define xFILD_rm(rm)            x86s(2) x86b(0xdb) x86b(mREG(0) | (rm))
#define xFILD_rm16(rm)          x86s(2) x86b(0xdf) x86b(mREG(0) | (rm))
#define xFILD_rm64(rm)          x86s(2) x86b(0xdf) x86b(mREG(5) | (rm))

#define xFINCSTP                x86s(2) x86b(0xd9) x86b(0xf7)

#define xFIST_rm(rm)            x86s(2) x86b(0xdb) x86b(mREG(2) | (rm))
#define xFISTP_rm(rm)           x86s(2) x86b(0xdb) x86b(mREG(3) | (rm))
#define xFISTP_i32(a)           x86s(6) x86b(0xdb) x86b(mREG(3) | mOFS32) x86d(a)

#define xFLD_rm(rm)             x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_rm32(rm)           x86s(2) x86b(0xd9) x86b(mREG(0) | (rm))
#define xFLD_rm64(rm)           x86s(2) x86b(0xdd) x86b(mREG(0) | (rm))
#define xFLD_i32(a)             x86s(6) x86b(0xd9) x86b(mREG(0) | mOFS32) x86d(a)
#define xFLD_st(r)              x86s(2) x86b(0xd9) x86b(0xc0 + (r))
#define xFLD1                   x86s(2) x86b(0xd9) x86b(0xe8)
#define xFLDZ                   x86s(2) x86b(0xd9) x86b(0xee)

#define xFMUL_st(r)             x86s(2) x86b(0xd8) x86b(0xc8 + (r))
#define xFMUL_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(1) | (rm))
#define xFMUL_i32(a)            x86s(6) x86b(0xd8) x86b(mREG(1) | mOFS32) x86d(a)
#define xFMULP_st(r)            x86s(2) x86b(0xde) x86b(0xc8 + (r))
#define xFNSTSW                 x86s(2) x86b(0xdf) x86b(0xe0)

#define xFSQRT()                x86s(2) x86b(0xd9) x86b(0xfa)

#define xFSUB_rm(rm)            x86s(2) x86b(0xd8) x86b(mREG(4) | (rm))
#define xFSUBP_st(r)            x86s(2) x86b(0xde) x86b(0xe8 + (r))
#define xFSUBR_rm(rm)           x86s(2) x86b(0xd8) x86b(mREG(5) | (rm))
#define xFSUBRP_st(r)           x86s(2) x86b(0xde) x86b(0xe0 + (r))

#define xFST_rm(rm)             x86s(2) x86b(0xd9) x86b(mREG(2) | (rm))
#define xFSTP_rm(rm)            x86s(2) x86b(0xd9) x86b(mREG(3) | (rm))
#define xFSTP_i32(a)            x86s(6) x86b(0xd9) x86b(mREG(3) | mOFS32) x86d(a)
#define xFSTP_st(r)             x86s(2) x86b(0xdd) x86b(0xd8 + (r))

#define xFLDCW_rm(rm)           x86s(2) x86b(0xd9) x86b(mREG(5) | (rm))
#define xFSTCW_rm(rm)           x86s(2) x86b(0xd9) x86b(mREG(7) | (rm))


#define xFXCH_st(r)             x86s(2) x86b(0xd9) x86b(0xc8 + (r))

#define xFYL2X()                x86s(2) x86b(0xd9) x86b(0xf1)
#define xF2XM1()                x86s(2) x86b(0xd9) x86b(0xf0)

#define xINC_r(r)               x86s(1) x86b(0x40 | (r))
#define xINC_rm(rm)             x86s(2) x86b(0xff) x86b(mREG(0) | (rm))

#define xIMUL_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | (rm))
#define xIMUL_r_i32(r,a)        x86s(7) x86b(0x0f) x86b(0xaf) x86b(mREG(r) | mOFS32) x86d(a)
#define xIMUL_r_r_imm(r1,r2,i)  x86s(6) x86b(0x69) x86b(0xc0 | ((r1) << 3) | (r2)) x86d(i)

#define xINT3                   x86s(1) x86b(0xcc)

#define xJA(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x77) x86b(_x) }
#define xJA32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x87) x86d(_x) }
#define xJAE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x73) x86b(_x) }
#define xJAE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x83) x86d(_x) }
#define xJB(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x72) x86b(_x) }
#define xJB32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x82) x86d(_x) }
#define xJBE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x76) x86b(_x) }
#define xJBE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x86) x86d(_x) }
#define xJG(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7f) x86b(_x) }
#define xJG32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8f) x86d(_x) }
#define xJGE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7d) x86b(_x) }
#define xJGE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8d) x86d(_x) }
#define xJL(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7c) x86b(_x) }
#define xJL32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8c) x86d(_x) }
#define xJLE(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x7e) x86b(_x) }
#define xJLE32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x8e) x86d(_x) }
#define xJNZ(disp)              { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x75) x86b(_x) }
#define xJNZ32(disp)            { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x85) x86d(_x) }
#define xJZ(disp)               { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0x74) x86b(_x) }
#define xJZ32(disp)             { unsigned int _x = (disp)-(ilcCount+6); x86s(6) x86b(0x0f) x86b(0x84) x86d(_x) }


#define xJMP8(disp)             { unsigned int _x = (disp)-(ilcCount+2); x86s(2) x86b(0xeb) x86b(_x) }
#define xJMP(disp)              { unsigned int _x = (disp)-(ilcCount+5); x86s(5) x86b(0xe9) x86d(_x) }

#define xLEA_r_rm(r,rm)         x86s(2) x86b(0x8d) x86b(mREG(r) | (rm))

#define xMOV_r_rm(r,rm)         x86s(2) x86b(0x8b) x86b(mREG(r) | (rm))                     // mov eax,[ebx]
#define xMOV_r_i32(r,a)         x86s(6) x86b(0x8b) x86b(mREG(r) | mOFS32) x86d(a)           // mov eax,[1234h]
#define xMOV_rm_imm(rm,i)       x86s(6) x86b(0xc7) x86b(mREG(0) | (rm)) x86d(i)             // mov ebp,12345678
#define xMOV_rm_r(rm,r)         x86s(2) x86b(0x89) x86b(mREG(r) | (rm))                     // mov [ebx],eax
#define xMOV_i32_r(a,r)         x86s(6) x86b(0x89) x86b(mREG(r) | mOFS32) x86d(a)           // mov [1234h],eax
#define xMOV_r_rm8(r,rm)        x86s(2) x86b(0x8a) x86b(mREG(r) | (rm))                     // mov al,[ebx]
#define xMOV_rm8_r(rm,r)        x86s(2) x86b(0x88) x86b(mREG(r) | (rm))                     // mov [ebx],al
#define xMOVSB                  x86s(1) x86b(0xa4)
#define xMOVSD                  x86s(1) x86b(0xa5)
#define xMOVSX_r_rm8(r,rm)      x86s(3) x86b(0x0f) x86b(0xbe) x86b(mREG(r) | (rm))
#define xMOVSX_r_rm16(r,rm)     x86s(3) x86b(0x0f) x86b(0xbf) x86b(mREG(r) | (rm))
#define xMOVZX_r_rm8(r,rm)      x86s(3) x86b(0x0f) x86b(0xb6) x86b(mREG(r) | (rm))
#define xMOVZX_r_rm16(r,rm)     x86s(3) x86b(0x0f) x86b(0xb7) x86b(mREG(r) | (rm))

#define xNEG_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(3) | (rm))

#define xNOP                    x86s(1) x86b(0x90)

#define xNOT_rm(rm)             x86s(2) x86b(0xf7) x86b(mREG(2) | (rm))

#define xOR_r_rm(r,rm)          x86s(2) x86b(0x0b) x86b(mREG(r) | (rm))
#define xOR_r_i32(r,a)          x86s(6) x86b(0x0b) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_r(rm,r)          x86s(2) x86b(0x09) x86b(mREG(r) | (rm))
#define xOR_i32_r(a,r)          x86s(6) x86b(0x09) x86b(mREG(r) | mOFS32) x86d(a)
#define xOR_rm_imm(rm,i)        x86s(6) x86b(0x81) x86b(mREG(1) | (rm)) x86d(i)

#define xPOP_r(r)               x86s(1) x86b(0x58 | (r))
#define xPOP_rm(rm)             x86s(2) x86b(0xff) x86b(0x30 | (rm))
#define xPOPAD                  x86s(1) x86b(0x61)

#define xPUSH_r(r)              x86s(1) x86b(0x50 | (r))
#define xPUSH_rm(rm)            x86s(2) x86b(0xff) x86b(mREG(6) | (rm))
#define xPUSH_i32(a)            x86s(6) x86b(0xff) x86b(mREG(6) | mOFS32) x86d(a)
#define xPUSH_imm(i)            x86s(5) x86b(0x68) x86d(i)
#define xPUSHAD                 x86s(1) x86b(0x60)

#define xREP                    x86s(1) x86b(0xf3)
#define xRET                    x86s(1) x86b(0xc3)

#define xSAHF                   x86s(1) x86b(0x9e)

#define xSAL_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)
#define xSAR_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(7) | (rm)) x86b(i)

#define xSBB_r_rm(r,rm)         x86s(2) x86b(0x1b) x86b(mREG(r) | (rm))
#define xSBB_r_i32(r,a)         x86s(6) x86b(0x1b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSBB_rm_r(rm,r)         x86s(2) x86b(0x19) x86b(mREG(r) | (rm))

#define xSETAE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x93) x86b(rm)
#define xSETG_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9f) x86b(rm)
#define xSETGE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9d) x86b(rm)
#define xSETL_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x9c) x86b(rm)
#define xSETLE_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x9e) x86b(rm)
#define xSETNZ_rm8(rm)          x86s(3) x86b(0x0f) x86b(0x95) x86b(rm)
#define xSETZ_rm8(rm)           x86s(3) x86b(0x0f) x86b(0x94) x86b(rm)

#define xSHL_rm_1(rm)           x86s(2) x86b(0xd1) x86b(mREG(4) | (rm))
#define xSHL_rm_CL(rm)          x86s(2) x86b(0xd3) x86b(mREG(4) | (rm))
#define xSHL_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(4) | (rm)) x86b(i)
#define xSHR_rm_1(rm)           x86s(2) x86b(0xd1) x86b(mREG(5) | (rm))
#define xSHR_rm_CL(rm)          x86s(2) x86b(0xd3) x86b(mREG(5) | (rm))
#define xSHR_rm_imm8(rm,i)      x86s(3) x86b(0xc1) x86b(mREG(5) | (rm)) x86b(i)

#define xSTOSD                 x86s(1) x86b(0xab)

#define xSUB_r_rm(r,rm)         x86s(2) x86b(0x2b) x86b(mREG(r) | (rm))
#define xSUB_r_i32(r,a)         x86s(6) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_r(rm,r)         x86s(2) x86b(0x29) x86b(mREG(r) | (rm))
#define xSUB_i32_r(a,r)         x86s(6) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)
#define xSUB_rm_imm8(rm,i)      x86s(3) x86b(0x83) x86b(mREG(5) | (rm)) x86b(i)
#define xSUB_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(5) | (rm)) x86d(i)

#define xTEST_rm_r(rm,r)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_r_rm(r,rm)        x86s(2) x86b(0x85) x86b(mREG(r) | (rm))
#define xTEST_i32_r(a,r)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_r_i32(r,a)        x86s(6) x86b(0x85) x86b(mREG(r) | mOFS32) x86d(a)
#define xTEST_rm_imm8(rm,i)     x86s(3) x86b(0xf6) x86b(mREG(0) | (rm)) x86b(i)
#define xTEST_rm_imm(rm,i)      x86s(6) x86b(0xf7) x86b(mREG(0) | (rm)) x86d(i)

#define xXOR_r_rm(r,rm)         x86s(2) x86b(0x33) x86b(mREG(r) | (rm))
#define xXOR_r_i32(r,a)         x86s(6) x86b(0x33) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_r(rm,r)         x86s(2) x86b(0x31) x86b(mREG(r) | (rm))
#define xXOR_i32_r(a,r)         x86s(6) x86b(0x31) x86b(mREG(r) | mOFS32) x86d(a)
#define xXOR_rm_imm(rm,i)       x86s(6) x86b(0x81) x86b(mREG(6) | (rm)) x86d(i)

/*
 * mmx opcodes
 */
#define xMOVD_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6e) x86b(mREG(r) | (rm))
#define xMOVD_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7e) x86b(mREG(r) | (rm))
#define xMOVNTQ_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0xe7) x86b(mREG(r) | (rm))
#define xMOVQ_r_rm(r,rm)        x86s(3) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | (rm))
#define xMOVQ_rm_r(rm,r)        x86s(3) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | (rm))
#define xMOVQ_i64_r(a,r)        x86s(7) x86b(0x0f) x86b(0x7f) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVQ_r_i64(r,a)        x86s(7) x86b(0x0f) x86b(0x6f) x86b(mREG(r) | mOFS32) x86d(a)
#define xPMOVMSKB_r_r(r1, r2)   x86s(3) x86b(0x0f) x86b(0xd7) x86b(mREG(r1) | rmREG(r2))

#define xEMMS                   x86s(2) x86b(0x0f) x86b(0x77)

/*
 * katmai opcodes
 */
#define xADDPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x58) x86b(mREG(r) | (rm))
#define xADDSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x58) x86b(mREG(r) | (rm))

#define xCOMISS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x2f) x86b(mREG(r) | (rm))
#define xCMPPSZ_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(0)
#define xCMPPSL_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(1)
#define xCMPPSLE_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(2)
#define xCMPPSNZ_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(4)
#define xCMPPSGE_r_rm(r,rm)     x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(5)
#define xCMPPSG_r_rm(r,rm)      x86s(4) x86b(0x0f) x86b(0xc2) x86b(mREG(r) | (rm)) x86b(6)

#define xCVTPS2PI_r_rm(r,rm)    x86s(3) x86b(0x0f) x86b(0x2c) x86b(mREG(r) | (rm))

#define xDIVPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5e) x86b(mREG(r) | (rm))

#define xMAXPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5f) x86b(mREG(r) | (rm))
#define xMAXPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x5f) x86b(mREG(r) | mOFS32) x86d(a)

#define xMINPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5d) x86b(mREG(r) | (rm))
#define xMINPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x5d) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVAPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x28) x86b(mREG(r) | (rm))
#define xMOVAPS_r_i128(r,a)     x86s(7) x86b(0x0f) x86b(0x28) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVAPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x29) x86b(mREG(r) | (rm))
#define xMOVAPS_i128_r(a,r)     x86s(7) x86b(0x0f) x86b(0x29) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVHLPS_r_r(r1,r2)     x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r1) | rmREG(r2)) // special movlps
#define xMOVLHPS_r_r(r1,r2)     x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r1) | rmREG(r2)) // special movhps

#define xMOVHPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x16) x86b(mREG(r) | (rm))
#define xMOVHPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x16) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_i64_r(a,r)      x86s(7) x86b(0x0f) x86b(0x17) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVHPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x17) x86b(mREG(r) | (rm))

#define xMOVLPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x12) x86b(mREG(r) | (rm))
#define xMOVLPS_r_i64(r,a)      x86s(7) x86b(0x0f) x86b(0x12) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_i64_r(a,r)      x86s(7) x86b(0x0f) x86b(0x13) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVLPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x13) x86b(mREG(r) | (rm))

#define xMOVMSKPS_r_r(r1,r2)    x86s(3) x86b(0x0f) x86b(0x50) x86b(mREG(r1) | rmREG(r2))

#define xMOVNTPS_i128_r(a,r)    x86s(7) x86b(0x0f) x86b(0x2b) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVNTPS_rm_r(rm,r)     x86s(3) x86b(0x0f) x86b(0x2b) x86b(mREG(r) | (rm))

#define xMOVUPS_r_rm(r,rm)      x86s(3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVUPS_r_i128(r,a)     x86s(7) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVUPS_rm_r(rm,r)      x86s(3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))
#define xMOVUPS_i128_r(a,r)     x86s(7) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

#define xMOVSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVSS_r_i32(r,a)       x86s(8) x86b(0xf3) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSS_i32_r(a,r)       x86s(8) x86b(0xf3) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

#define xMULPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x59) x86b(mREG(r) | (rm))
#define xMULPS_r_i128(r,a)      x86s(7) x86b(0x0f) x86b(0x59) x86b(mREG(r) | mOFS32) x86d(a)

#define xMULSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x59) x86b(mREG(r) | (rm))

#define xRCPPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x53) x86b(mREG(r) | (rm))

#define xPREFETCH_rm8(h,rm,ofs) x86s(4) x86b(0x0f) x86b(0x18) x86b(mREG(h) | (rm)) x86b(ofs)

#define xSHUFPS_r_i64_imm(r,a,i) x86s(8) x86b(0x0f) x86b(0xc6) x86b(mREG(r) | mOFS32) x86d(a) x86b(i)
#define xSHUFPS_r_rm_imm(r,rm,i) x86s(4) x86b(0x0f) x86b(0xc6) x86b(mREG(r) | (rm)) x86b(i)

#define xSUBPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x5c) x86b(mREG(r) | (rm))
#define xSUBSS_r_rm(r,rm)       x86s(4) x86b(0xf3) x86b(0x0f) x86b(0x5c) x86b(mREG(r) | (rm))
#define xXORPS_r_rm(r,rm)       x86s(3) x86b(0x0f) x86b(0x57) x86b(mREG(r) | (rm))

 /*
 * Pentium 4 opcodes
 */

#define xMOVSD_r_rm(r,rm)      x86s(4) x86b(0xf2) x86b(0x0f) x86b(0x10) x86b(mREG(r) | (rm))
#define xMOVSD_r_i128(r,a)     x86s(8) x86b(0xf2) x86b(0x0f) x86b(0x10) x86b(mREG(r) | mOFS32) x86d(a)
#define xMOVSD_rm_r(rm,r)      x86s(4) x86b(0xf2) x86b(0x0f) x86b(0x11) x86b(mREG(r) | (rm))
#define xMOVSD_i128_r(a,r)     x86s(8) x86b(0xf2) x86b(0x0f) x86b(0x11) x86b(mREG(r) | mOFS32) x86d(a)

 /*
 * 3dnow opcodes
 */
#define xFEMMS                  x86s(2) x86b(0x0f) x86b(0x0e)
#define xPFMUL_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xb4)
#define xPFSUB_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x9a)
#define xPFADD_r_rm(r,rm)       x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x9e)
#define xPUNPCKHDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x6a) x86b(mREG(r) | (rm))
#define xPUNPCKLDQ_r_rm(r,rm)   x86s(3) x86b(0x0f) x86b(0x62) x86b(mREG(r) | (rm))
#define xPFRCP_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x96)
#define xPFRCPIT1_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xa6)
#define xPFRCPIT2_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xb6)
#define xPSWAPD_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0xbb)
#define xPFNACC_r_rm(r,rm) x86s(4) x86b(0x0f) x86b(0x0f) x86b(mREG(r) | (rm)) x86b(0x8a)

/*****************************************************************************
 * macros
 *****************************************************************************/

#if defined(IS_OPENGL)

#define ILC_GROW_TO(x) assert(!"can't grow ilcCount")

#else

/*****************************************************************************
 * externals
 *****************************************************************************/
void ILCGrowTo(unsigned long dwNeed);

#define ILC_GROW_TO(x) ILCGrowTo(x)

#endif

/*
 * emission
 */
#define x86s(x)                 if ((ilcCount+(x)) > ilcMax) ILC_GROW_TO(ilcCount+(x));
#define x86b(x)                 ilcData[ilcCount]=(unsigned char) (x); ilcCount++;
#define x86d(x)                 *(unsigned int *) (ilcData+ilcCount) = (unsigned int) (x); ilcCount+=4;

/*
 * mod r/m
 */
#define mOFS32                  rmIND(rEBP)
#define mREG(x)                 ((x) << 3)

#define rmIND(x)                (0x00 | (x))
#define rmIND8(x)               (0x40 | (x))
#define rmIND32(x)              (0x80 | (x))
#define rmREG(x)                (0xc0 | (x))
#define rmSIB                   rmIND(rESP)
#define rmSIB8                  rmIND8(rESP)
#define rmSIB32                 rmIND32(rESP)

#define times1                  0
#define times2                  1
#define times4                  2
#define times8                  3

#if !defined(IS_OPENGL)
////// Don't use these macro names!  They are used everywhere as vars and members!
#define x1                      times1
#define x2                      times2
#define x4                      times4
#define x8                      times8
#else
////// Don't use these macro names!  They are used everywhere as vars and members!
#endif // !defined(IS_OPENGL)

#define xSIB(r1,r2,s)           x86s(1) x86b((r1) | ((r2)<<3) | ((s)<<6))
#define xSIB32(r1,r2,e)         x86s(1) x86b((r1) | ((r2)<<3) | ((times1)<<6)) xOFS32(e)
#define xSIB_esp                xSIB(rESP, rESP, times1)
#define xSIB8_esp(e)            xSIB_esp xOFS8(e)
#define xSIB32_esp(e)           xSIB_esp xOFS32(e)

#define x16r                    x86s(1) x86b(0x66)
#define x16m                    x86s(1) x86b(0x67)

#define xDS                     x86s(1) x86b(0x3e)

#define xOFS8(e)                x86s(1) x86b(e)
#define xOFS32(e)               x86s(4) x86d(e)

#define mMEM8(x)               ((unsigned int) &(x))
#define mMEM32(x)              ((unsigned int) &(x))
#define mMEM64(x)              ((unsigned int) &(x))
#define mMEM128(x)             ((unsigned int) &(x))

/*
 * jumps * branches
 */
#define xLABEL(x)               (x) = ilcCount;
#define xTARGET_b8(x)           *(unsigned char *) (ilcData + (x) + 1) = (unsigned char) (ilcCount - ((x) + 2));
#define xTARGET_b32(x)          *(unsigned int *) (ilcData + (x) + 2) = (unsigned int) (ilcCount - ((x) + 6));
#define xTARGET_jmp(x)          *(unsigned int *) (ilcData + (x) + 1) = (unsigned int) (ilcCount - ((x) + 5));

/*
 * inline instructions not supported by built-in asm
 */
#define rdtsc  __asm _emit 0x0f __asm _emit 0x31
#define sfence __asm _emit 0x0f __asm _emit 0xae __asm _emit 0xf8

#ifdef __cplusplus
}
#endif

#endif // x86.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\common\vesa\vesadata.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

#include "vesadata.h"
#include "nvMultiMon.h"

//*****************************************************************************
//
// This file contains the display timing tables required for all supported
// VESA (DMT, GTF) modes.
//
// Definition of display timing terms:
//
//
//  <------------------><--------><-------><------><-------><--------><--------
//
//     Active Display     Border    Porch    Sync    Porch    Border    Active
//
//
//  <---------------------------------------------------------------->
//  Total
//
//  <------------------>
//  Visible
//
//  <---------------------------->
//  Blank Start
//
//  <------------------------------------->
//  Sync Start
//
//  <--------------------------------------------->
//  Sync End
//
//  <------------------------------------------------------>
//  Blank End
//
//*****************************************************************************

//*****************************************************************************
//
// GTF Timings 
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use pure floating point).
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Sync Start, Sync End
// Vertical Total, Sync Start, Sync End
// DotClock (MHz * 100)
// HSync polarity 
// VSync polarity 
//
// NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
// Blank End == Total.
//
unsigned int GTFTimingTable[][12] =
{
    // Settings for 2048x1536:
    {2048,1536,6000, 2800,2200,2424,1589,1537,1540,26695,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7000, 2816,2208,2432,1599,1537,1540,31519,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7200, 2816,2208,2432,1600,1537,1540,32440,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7500, 2832,2216,2440,1603,1537,1540,34048,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,8500, 2832,2216,2440,1612,1537,1540,38804,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1920x1440:
    {1920,1440,6000, 2624,2064,2272,1490,1441,1444,23459,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7000, 2640,2072,2280,1499,1441,1444,27702,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7200, 2640,2072,2280,1500,1441,1444,28512,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7500, 2640,2072,2280,1503,1441,1444,29759,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,8500, 2656,2072,2288,1512,1441,1444,34135,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 1920x1200:
    {1920,1200,6000, 2592,2048,2256,1242,1201,1204,19316,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7000, 2608,2056,2264,1249,1201,1204,22802,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7200, 2624,2064,2272,1251,1201,1204,23635,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7500, 2624,2064,2272,1253,1201,1204,24659,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7600, 2624,2064,2272,1253,1201,1204,24988,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,8500, 2640,2072,2280,1260,1201,1204,28274,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,10000,2656,2072,2288,1271,1201,1204,33758,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,12000,2672,2080,2296,1286,1201,1204,41234,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1920x1080:
    {1920,1080,6000, 2576,2040,2248,1118,1081,1084,17280,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7000, 2608,2056,2264,1124,1081,1084,20520,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7200, 2608,2056,2264,1126,1081,1084,21144,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7500, 2608,2056,2264,1128,1081,1084,22064,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,8500, 2624,2064,2272,1134,1081,1084,25293,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,10000,2640,2072,2280,1144,1081,1084,30202,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,12000,2656,2072,2288,1157,1081,1084,36876,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1800x1440:
    {1800,1440,6000, 2456,1928,2128,1490,1441,1444,21957,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7000, 2472,1936,2136,1499,1441,1444,25939,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7200, 2472,1936,2136,1500,1441,1444,26698,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7500, 2472,1936,2136,1503,1441,1444,27866,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,8500, 2488,1944,2144,1512,1441,1444,31976,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,10000,2504,1952,2152,1525,1441,1444,38186,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1600x1200:
    {1600,1200,6000, 2160,1704,1880,1242,1201,1204,16096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7000, 2176,1712,1888,1249,1201,1204,19025,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7200, 2176,1712,1888,1251,1201,1204,19600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7500, 2192,1720,1896,1253,1201,1204,20599,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,8500, 2192,1720,1896,1260,1201,1204,23476,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,10000,2208,1728,1904,1272,1201,1204,28064,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,12000,2224,1736,1912,1286,1201,1204,34321,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,14000,2240,1744,1920,1301,1201,1204,40799,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x1024:
    {1600,1024,6000, 2144,1704,1872,1060,1025,1028,13636,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7000, 2160,1704,1880,1066,1025,1028,16118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7200, 2160,1704,1880,1067,1025,1028,16594,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7500, 2176,1712,1888,1069,1025,1028,17446,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7600, 2176,1712,1888,1070,1025,1028,17695,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,8500, 2176,1712,1888,1075,1025,1028,19883,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,10000,2192,1720,1896,1085,1025,1028,23783,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,12000,2208,1728,1904,1097,1025,1028,29066,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x900:
    {1600,900,6000, 2128,1696,1864,932,901,904,11900,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7000, 2144,1704,1872,937,901,904,14062,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7200, 2144,1704,1872,938,901,904,14480,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7500, 2160,1704,1880,940,901,904,15228,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,8500, 2176,1712,1888,945,901,904,17479,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,10000,2192,1720,1896,953,901,904,20890,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,12000,2208,1728,1904,965,901,904,25569,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,14000,2224,1736,1912,976,901,904,30389,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,14400,2224,1736,1912,978,901,904,31321,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,15000,2224,1736,1912,982,901,904,32760,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,17000,2224,1736,1912,994,901,904,37581,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x880:
    {1600,880,6000, 2112,1688,1856,911,881,884,11544,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7000, 2144,1704,1872,916,881,884,13747,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7200, 2144,1704,1872,917,881,884,14156,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7500, 2144,1704,1872,919,881,884,14778,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,8500, 2160,1704,1880,924,881,884,16965,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,10000,2192,1720,1896,932,881,884,20429,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,12000,2208,1728,1904,943,881,884,24986,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,14000,2208,1728,1904,954,881,884,29490,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,14400,2224,1736,1912,957,881,884,30648,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,15000,2224,1736,1912,960,881,884,32026,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,17000,2224,1736,1912,972,881,884,36749,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1400x1050:
    {1400,1050,6000, 1880,1488,1640,1087,1051,1054,12261,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7000, 1896,1496,1648,1093,1051,1054,14506,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7200, 1896,1496,1648,1094,1051,1054,14934,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7500, 1896,1496,1648,1096,1051,1054,15585,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,8500, 1912,1504,1656,1103,1051,1054,17926,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,10000,1928,1512,1664,1112,1051,1054,21439,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,12000,1944,1520,1672,1125,1051,1054,26244,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,14000,1944,1520,1672,1139,1051,1054,30999,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,14400,1944,1520,1672,1141,1051,1054,31941,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,15000,1944,1520,1572,1146,1051,1054,33417,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    
    // Settings for 1280x1024:
    {1280,1024,6000, 1712,1360,1496,1060,1025,1028,10888,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7000, 1728,1368,1504,1066,1025,1028,12894,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7200, 1728,1368,1504,1067,1025,1028,13275,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7500, 0x6B0,0x550,0x5d8,0x424,0x401,0x404,0x2a88,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,8500, 1744,1376,1512,1075,1025,1028,15936,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,10000,1760,1376,1520,1085,1025,1028,19096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,12000,1776,1384,1528,1097,1025,1028,23379,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,14000,1776,1384,1528,1111,1025,1028,27624,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,14400,1776,1384,1528,1113,1025,1028,28464,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,15000,1776,1384,1528,1117,1025,1028,29757,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,17000,1792,1392,1536,1131,1025,1028,34455,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,20000,1729,1392,1536,1152,1025,1028,41288,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1280x960:
    {1280,960,6000, 1712,1360,1496,994, 961,964,10210,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7000, 1728,1368,1504,999, 961,964,12084,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7200, 1728,1368,1504,1001,961,964,12454,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7500, 1728,1368,1504,1002,961,964,12986,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,8500, 1744,1376,1512,1008,961,964,14943,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,10000,1760,1376,1520,1017,961,964,17899,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,12000,1760,1376,1520,1029,961,964,21732,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,14000,1776,1384,1528,1041,961,964,25883,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,14400,1776,1384,1528,1044,961,964,26700,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,15000,1776,1384,1528,1047,961,964,27892,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,17000,1792,1392,1536,1060,961,964,32292,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,20000,1792,1392,1536,1080,961,964,38707,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1152x864:
    {1152,864,6000, 1520,1216,1336,895,865,868,8162,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7000, 1536,1224,1344,900,865,868,9677,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7200, 1536,1224,1344,901,865,868,9964,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7500, 1552,1224,1352,902,865,868,10499,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,8500, 1552,1224,1352,907,865,868,11965,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,10000,1568,1232,1360,915,865,868,14347,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,12000,1584,1240,1368,926,865,868,17601,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,14000,1600,1248,1376,937,865,868,20989,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,14400,1600,1248,1376,939,865,868,21635,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,15000,1600,1248,1376,943,865,868,22632,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,17000,1600,1248,1376,954,865,868,25949,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,20000,1616,1256,1384,972,865,868,31415,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,24000,1616,1256,1384,997,865,868,38668,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1024x768:
    //Use DMT for 60Hz: 1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {1024,768,6000, 1344,1048,1184,806,771,777,6500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
    {1024,768,7000, 1360,1080,1192,800,769,772,7616,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,7200, 1360,1080,1192,801,769,772,7843,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,7500, 1360,1080,1192,802,769,772,8180,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,8500, 1376,1088,1200,807,769,772,9439,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    //Adjust 100Hz due to DAC feedback
    //1392,1096,1208,814,769,772,11331,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {1024,768,10000,1392,1096,1208,814,769,772,11370,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,12000,1408,1104,1216,823,769,772,13905,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,14000,1408,1104,1216,833,769,772,16420,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,14400,1408,1104,1216,835,769,772,16930,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,15000,1408,1104,1216,838,769,772,17699,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,17000,1424,1112,1224,848,769,772,20528,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,20000,1424,1112,1224,864,769,772,24607,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,24000,1440,1120,1232,886,769,772,30620,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 960x720:
    {960,720,6000, 1248,1008,1104,746,721,724,5586,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7000, 1264,1008,1112,750,721,724,6636,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7200, 1264,1008,1112,751,721,724,6835,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7500, 1280,1016,1120,752,721,724,7219,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,8500, 1280,1016,1120,756,721,724,8225,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,10000,1296,1024,1128,763,721,724,9888,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,12000,1312,1032,1136,772,721,724,12154,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,14000,1312,1032,1136,781,721,724,14345,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,14400,1328,1040,1144,783,721,724,14973,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,15000,1328,1040,1144,786,721,724,15657,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,17000,1328,1040,1144,795,721,724,17948,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,20000,1344,1048,1152,810,721,724,21773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,24000,1344,1048,1152,831,721,724,26805,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 864x480:
    {864,480,6000, 1072,880,968,497,481,484,3197,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7000, 1104,896,984,500,481,484,3864,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7200, 1104,896,984,501,481,484,3982,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7500, 1104,896,984,502,481,484,4157,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,8500, 1120,904,992,505,481,484,4808,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,10000,1136,912,1000,509,481,484,5782,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,12000,1152,912,1008,515,481,484,7119,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,14000,1168,920,1016,521,481,484,8519,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,14400,1168,920,1016,522,481,484,8780,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,15000,1168,920,1016,524,481,484,9180,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,17000,1184,928,1024,531,481,484,10688,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,20000,1184,928,1024,540,481,484,12787,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,24000,1200,936,1032,554,481,484,15955,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 856x480:
    {856,480,6000, 1064,872,960,497,481,484,3173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7000, 1096,888,976,500,481,484,3836,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7200, 1096,888,976,501,481,484,3953,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7500, 1096,888,976,502,481,484,4126,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,8500, 1112,896,984,505,481,484,4773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,10000,1128,904,992,509,481,484,5742,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,12000,1144,912,1000,515,481,484,7070,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,14000,1160,912,1008,521,481,484,8461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,14400,1160,912,1008,522,481,484,8719,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,15000,1160,912,1008,524,481,484,9118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,17000,1160,912,1008,531,481,484,10471,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,20000,1176,920,1016,540,481,484,12701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,24000,1192,928,1024,554,481,484,15849,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 852x480:
    {852,480,6000, 1046,872,960,497,481,484,3173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7000, 1096,888,976,500,481,484,3836,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7200, 1096,888,976,501,481,484,3953,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7500, 1096,888,976,502,481,484,4126,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,8500, 1112,896,984,505,481,484,4773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,10000,1128,904,992,509,481,484,5742,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,12000,1144,912,1000,515,481,484,7070,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,14000,1160,912,1008,521,481,484,8461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,14400,1160,912,1008,522,481,484,8719,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,15000,1160,912,1008,524,481,484,9118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,17000,1160,912,1008,531,481,484,10471,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,20000,1176,920,1016,540,481,484,12701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,24000,1192,928,1024,554,481,484,15849,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 848x480:
    {848,480,6000, 1056,864,952,497,481,484,3149,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7000, 1072,872,960,500,481,484,3752,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7200, 1088,880,968,501,481,484,3925,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7500, 1088,880,968,502,481,484,4096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,8500, 1104,888,976,505,481,484,4739,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,10000,1120,896,984,509,481,484,5701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,12000,1136,904,992,515,481,484,7020,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,14000,1152,904,1000,521,481,484,8403,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,14400,1152,904,1000,522,481,484,8659,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,15000,1152,904,1000,524,481,484,9055,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,17000,1152,904,1000,531,481,484,10399,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,20000,1168,912,1008,540,481,484,12614,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,24000,1168,912,1008,554,481,484,15530,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 800x600:
    // Use DMT for 60: 1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {800,600,6000, 1056,840,968,628,601,605,4000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7000, 1040,840,920,625,601,604,4550,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7200, 1040,840,920,626,601,604,4687,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7500, 1040,840,920,627,601,604,4891,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,8500, 1056,840,928,630,601,604,5655,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,10000,1072,848,936,636,601,604,6818,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,12000,1088,856,944,643,601,604,8395,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,14000,1088,856,944,651,601,604,9916,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,14400,1088,856,944,653,601,604,10231,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,15000,1088,856,944,655,601,604,10690,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,17000,1104,864,952,663,601,604,12443,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,20000,1104,864,952,675,601,604,14904,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,24000,1120,872,960,692,601,604,18601,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 720x480:
    {720,480,6000, 896,736,808,497,481,484,2672,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7000, 912,744,816,500,481,484,3192,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7200, 912,744,816,501,481,484,3290,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7500, 928,752,824,502,481,484,3494,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,8500, 928,752,824,505,481,484,3983,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,10000,944,760,832,509,481,484,4805,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,12000,960,760,840,515,481,484,5933,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,14000,976,768,848,521,481,484,7119,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,14400,976,768,848,522,481,484,7336,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,15000,976,768,848,524,481,484,7671,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,17000,976,768,848,531,481,484,8810,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,20000,992,776,856,540,481,484,10714,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,24000,992,776,856,554,481,484,13190,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 640x480:
    // Use DMT for 60: 800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,480,6000, 800,656,752,525,490,492,2518,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
    {640,480,7000, 816,664,728,500,481,484,2856,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,7200, 816,664,728,501,481,484,2943,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,7500, 816,664,728,502,481,484,3072,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,8500, 832,672,736,505,481,484,3571,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,10000,848,680,744,509,481,484,4316,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,12000,848,680,744,515,481,484,5241,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,14000,864,680,752,521,481,484,6302,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,14400,864,680,752,522,481,484,6495,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,15000,864,680,752,524,481,484,6791,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,17000,880,688,760,531,481,484,7944,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,20000,880,688,760,540,481,484,9504,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,24000,880,688,760,554,481,484,11700,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 640x400:
    //
    // The GTF timings for 640x400 at 70Hz and 72Hz are drastically different than
    // the original VGA timings (which officially only list 85Hz as a support rate
    // at this resolution).  Therefore, when we attempt to set the GTF rates the
    // monitors just aren't happy.
    //
    // Remember that IBM VGA 640x400 starts at 70Hz, not 60Hz.  There is no 60Hz 
    // timings for 640x400 as defined by IBM VGA.
    //
    // Use GTF 75: 784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,6000, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    // Use GTF 75: 800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,7000, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    // Use GTF 75: 800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,7200, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,7500, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,8500, 816,664,728,421,401,404,2920,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,10000,832,672,736,424,401,404,3528,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,12000,848,680,744,429,401,404,4366,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,14000,848,680,744,434,401,404,5152,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,14400,848,680,744,435,401,404,5312,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,15000,864,680,752,437,401,404,5664,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,17000,864,680,752,442,401,404,6492,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,20000,880,688,760,451,401,404,7938,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,24000,880,688,760,462,401,404,9757,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    {512,384,6000, 672,536,592,795,769,772,3205,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {512,384,7000, 672,536,592,800,769,772,3763,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,7200, 688,544,600,801,769,772,3968,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,7500, 688,544,600,802,769,772,4138,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,8500, 688,544,600,807,769,772,4719,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,10000,688,544,600,814,769,772,5600,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,12000,704,552,608,823,769,772,6953,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,14000,704,552,608,833,769,772,8210,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,14400,704,552,608,835,769,772,8465,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,15000,704,552,608,838,769,772,8849,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,17000,704,552,608,848,769,772,10149,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,20000,720,560,616,864,769,772,12442,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,24000,720,560,616,886,769,772,15310,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    {480,360,6000, 624,504,552,746,721,724,2793,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7000, 640,512,560,750,721,724,3360,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7200, 640,512,560,751,721,724,3461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7500, 640,512,560,752,721,724,3610,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,8500, 640,512,560,756,721,724,4113,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,10000,656,512,568,763,721,724,5005,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,12000,656,512,568,772,721,724,6077,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,14000,656,512,568,781,721,724,7173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,14400,656,512,568,783,721,724,7397,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,15000,656,512,568,786,721,724,7734,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,17000,672,520,576,795,721,724,9082,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,20000,672,520,576,810,721,724,10886,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,24000,672,520,576,831,721,724,13402,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    {400,300,6000, 512,416,456,622,601,604,1911,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7000, 528,424,464,625,601,604,2310,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7200, 528,424,464,626,601,604,2380,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7500, 528,424,464,627,601,604,2483,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,8500, 528,424,464,630,601,604,2827,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,10000,528,424,464,636,601,604,3358,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,12000,544,432,472,643,601,604,4198,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,14000,544,432,472,651,601,604,4958,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,14400,544,432,472,653,601,604,5115,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,15000,544,432,472,655,601,604,5345,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,17000,544,432,472,663,601,604,6131,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,20000,560,432,480,675,601,604,7560,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,24000,560,432,480,692,601,604,9300,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    {320,240,6000, 400,328,360,497,481,484,1193,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7000, 400,328,360,500,481,484,1400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7200, 416,336,368,501,481,484,1501,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7500, 416,336,368,502,481,484,1566,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,8500, 416,336,368,505,481,484,1786,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,10000,416,336,368,509,481,484,2117,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,12000,432,344,376,515,481,484,2670,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,14000,432,344,376,521,481,484,3151,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,14400,432,344,376,522,481,484,3247,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,15000,432,344,376,524,481,484,3396,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,17000,432,344,376,531,481,484,3900,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,20000,432,344,376,540,481,484,4666,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,24000,448,352,384,554,481,484,5957,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {320,200,6000, 400,328,360,417,401,404,1168,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7000, 400,328,360,417,401,404,1168,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7200, 400,328,360,418,401,404,1204,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7500, 400,328,360,418,401,404,1254,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,8500, 416,336,368,421,401,404,1489,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,10000,416,336,368,424,401,404,1764,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,12000,416,336,368,429,401,404,2142,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,14000,432,344,376,434,401,404,2625,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,14400,432,344,376,435,401,404,2706,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,15000,432,344,376,437,401,404,2832,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,17000,432,344,376,442,401,404,3246,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,20000,432,344,376,451,401,404,3897,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,24000,448,352,384,462,401,404,4967,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE}
};

//*****************************************************************************
//
// VESA 1.0 rev 0.7 DMT timings
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7 
// Monitor Timing Specifications.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity 
// VSync polarity 
//
// NOTE: Unlike GTF timings, DMT does not dictate zero border widths.
// Therefore we must include blank start and end positions. 
//
unsigned int DMTTimingTableNT[][16] =
{

    // Settings for 320x200 (mode doubled 640x400):
    //  NOTE: There is no 60Hz 320x200, so use 70Hz if anyone wants 60Hz
    {320,200,6000,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {320,200,7000,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {320,200,8500,832/2,640/2,672/2,736/2,832/2,445,400,401,404,445,3150/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 320x240 (mode doubled 640x480):
	{320,240,6000,800/2,648/2,656/2,752/2,792/2,525,488,490,492,517,2518/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,7200,832/2,648/2,664/2,704/2,824/2,520,488,489,492,512,3150/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,7500,840/2,640/2,656/2,720/2,840/2,500,480,481,484,500,3150/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,8500,832/2,640/2,696/2,752/2,832/2,509,480,481,484,509,3600/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 400x300 (mode doubled 800x600):
	{400,300,6000,1056/2,800/2,840/2,968/2,1056/2,628,600,601,605,628,4000/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,7200,1040/2,800/2,856/2,976/2,1040/2,666,600,637,643,666,5000/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,7500,1056/2,800/2,816/2,896/2,1056/2,625,600,601,604,625,4950/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,8500,1048/2,800/2,832/2,896/2,1048/2,631,600,601,604,631,5625/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 512x384 (mode doubled 1024x768):
	{512,384,6000,1344/2,1024/2,1048/2,1184/2,1344/2,806,768,771,777,806,6500/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{512,384,7000,1328/2,1024/2,1048/2,1184/2,1328/2,806,768,771,777,806,7500/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{512,384,7500,1312/2,1024/2,1040/2,1136/2,1312/2,800,768,769,772,800,7875/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{512,384,8500,1376/2,1024/2,1072/2,1168/2,1376/2,808,768,769,772,808,9450/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 640x400:
    //  NOTE: There is no 60Hz 640x400, so use 70Hz if anyone wants 60Hz
    {640,400,6000,800,640,656,752,288,449,400,412,414,449,2518,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {640,400,7000,800,640,656,752,288,449,400,412,414,449,2518,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {640,400,8500,832,640,672,736,832,445,400,401,404,445,3150,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 640x480:
	{640,480,6000,800,648,656,752,792,525,488,490,492,517,2518,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,7200,832,648,664,704,824,520,488,489,492,512,3150,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,7500,840,640,656,720,840,500,480,481,484,500,3150,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,8500,832,640,696,752,832,509,480,481,484,509,3600,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 800x600:
	{800,600,6000,1056,800,840,968,1056,628,600,601,605,628,4000,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,7200,1040,800,856,976,1040,666,600,637,643,666,5000,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,7500,1056,800,816,896,1056,625,600,601,604,625,4950,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,8500,1048,800,832,896,1048,631,600,601,604,631,5625,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1024x768:
	{1024,768,6000,1344,1024,1048,1184,1344,806,768,771,777,806,6500,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{1024,768,7000,1328,1024,1048,1184,1328,806,768,771,777,806,7500,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{1024,768,7500,1312,1024,1040,1136,1312,800,768,769,772,800,7875,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1024,768,8500,1376,1024,1072,1168,1376,808,768,769,772,808,9450,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1152x864:
	{1152,864,7500,1600,1152,1216,1344,1600,900,864,865,868,900,10800,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1280x1024:
	{1280,1024,6000,1688,1280,1328,1440,1688,1066,1024,1025,1028,1066,10800,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1280,1024,7500,1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1280,1024,8500,1728,1280,1344,1504,1728,1072,1024,1025,1028,1072,15750,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1600x1024 (OEM requested version of 76Hz)
    {1600,1024,7600,2096,1600,1632,1792,2096,1070,1024,1027,1030,1070,17045,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 1600x1200:
	{1600,1200,6000,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,16200,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,6500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,17550,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,7000,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,18900,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,7500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,20250,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,8500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,22950,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1920x1200 (OEM requested version of 76Hz)
    {1920,1200,7600,2584,1920,1984,2240,2584,1250,1200,1203,1206,2584,24548,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE}
};

// This function scans the GTF table for the requested resolution/refresh rate
// and returns the timing values for it.
unsigned int vesaGetGTFTimings
(
    unsigned int hRes,
    unsigned int vRes,
    unsigned int refreshRate,
    MODE_TIMING_VALUES * timingInfo
)
{
    unsigned int numEntries;
    unsigned int i;

    // Check for the multi-mon modes.
    if (MULTIMON_MODE(hRes, vRes)) 
       {
       if (HORIZONTAL_MODE(hRes, vRes))
          {
          hRes /= 2;
          }
       else
          {
          if (VERTICAL_MODE(hRes, vRes))
             {
             vRes /= 2;
             }
          }
       }


    // For each mode, there are 12 (unsigned int) timing values
    numEntries = sizeof(GTFTimingTable) / (sizeof(unsigned int) * 12);

    // refresh rate is in terms of Hz * 100 in the table.
    refreshRate *= 100;

    for (i = 0; i < numEntries; i++)
    {
        if (GTFTimingTable[i][0] == hRes &&
            GTFTimingTable[i][1] == vRes &&
            GTFTimingTable[i][2] == refreshRate)
        {
            // Found the mode we want.
            // Copy the timing values.
            // NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
            // Blank End == Total.
            timingInfo->HorizontalVisible       = GTFTimingTable[i][0]; 
            timingInfo->VerticalVisible         = GTFTimingTable[i][1];
            timingInfo->Refresh                 = GTFTimingTable[i][2];
            timingInfo->HorizontalTotal         = GTFTimingTable[i][3]; 
            timingInfo->HorizontalBlankStart    = timingInfo->HorizontalVisible; 
            timingInfo->HorizontalRetraceStart  = GTFTimingTable[i][4]; 
            timingInfo->HorizontalRetraceEnd    = GTFTimingTable[i][5]; 
            timingInfo->HorizontalBlankEnd      = timingInfo->HorizontalTotal;
            timingInfo->VerticalTotal           = GTFTimingTable[i][6]; 
            timingInfo->VerticalBlankStart      = timingInfo->VerticalVisible; 
            timingInfo->VerticalRetraceStart    = GTFTimingTable[i][7]; 
            timingInfo->VerticalRetraceEnd      = GTFTimingTable[i][8]; 
            timingInfo->VerticalBlankEnd        = timingInfo->VerticalTotal;
            timingInfo->PixelClock              = GTFTimingTable[i][9];
            timingInfo->HSyncpolarity           = GTFTimingTable[i][10]; 
            timingInfo->VSyncpolarity           = GTFTimingTable[i][11]; 

            // return success.
            return 0;
        } // found the matching mode
    } // loop over all the modes in the table

    // Did not find the specifed resolution/refresh rate conbination.
    return 1;
} // end of vesaGetGTFTimings

// This function scans the DMT table for the requested resolution/refresh rate
// and returns the timing values for it.
unsigned int vesaGetDMTTimings
(
    unsigned int hRes,
    unsigned int vRes,
    unsigned int refreshRate,
    MODE_TIMING_VALUES * timingInfo
)
{
    unsigned int numEntries;
    unsigned int i;

    // Check for the multi-mon modes.
    if (MULTIMON_MODE(hRes, vRes)) 
       {
       if (HORIZONTAL_MODE(hRes, vRes))
          {
          hRes /= 2;
          }
       else
          {
          if (VERTICAL_MODE(hRes, vRes))
             {
             vRes /= 2;
             }
          }
       }

    // For each mode, there are 16 (unsigned int) timing values
    numEntries = sizeof(DMTTimingTableNT) / (sizeof(unsigned int) * 16);

    // refresh rate is in terms of Hz * 100 in the table.
    refreshRate *= 100;

    for (i = 0; i < numEntries; i++)
    {
        if (DMTTimingTableNT[i][0] == hRes &&
            DMTTimingTableNT[i][1] == vRes &&
            DMTTimingTableNT[i][2] == refreshRate)
        {
            // Found the mode we want.
            // Copy the timing values.
            timingInfo->HorizontalVisible       = DMTTimingTableNT[i][0]; 
            timingInfo->VerticalVisible         = DMTTimingTableNT[i][1];
            timingInfo->Refresh                 = DMTTimingTableNT[i][2];
            timingInfo->HorizontalTotal         = DMTTimingTableNT[i][3]; 
            // timingInfo->HorizontalBlankStart    = DMTTimingTableNT[i][4]; 
            timingInfo->HorizontalBlankStart    = timingInfo->HorizontalVisible; 
            timingInfo->HorizontalRetraceStart  = DMTTimingTableNT[i][5]; 
            timingInfo->HorizontalRetraceEnd    = DMTTimingTableNT[i][6]; 
            // timingInfo->HorizontalBlankEnd      = DMTTimingTableNT[i][7];
            timingInfo->HorizontalBlankEnd      = timingInfo->HorizontalBlankStart
                            + (timingInfo->HorizontalTotal - DMTTimingTableNT[i][7]);
            timingInfo->VerticalTotal           = DMTTimingTableNT[i][8]; 
            // timingInfo->VerticalBlankStart      = DMTTimingTableNT[i][9]; 
            timingInfo->VerticalBlankStart      = timingInfo->VerticalVisible; 
            timingInfo->VerticalRetraceStart    = DMTTimingTableNT[i][10]; 
            timingInfo->VerticalRetraceEnd      = DMTTimingTableNT[i][11]; 
            // timingInfo->VerticalBlankEnd        = DMTTimingTableNT[i][12];
            timingInfo->VerticalBlankEnd        = timingInfo->VerticalBlankStart 
                            + (timingInfo->VerticalTotal - DMTTimingTableNT[i][12]);
            timingInfo->PixelClock              = DMTTimingTableNT[i][13];
            timingInfo->HSyncpolarity           = DMTTimingTableNT[i][14]; 
            timingInfo->VSyncpolarity           = DMTTimingTableNT[i][15]; 

            // success.
            return 0;
        } // found the matching mode
    } // loop over all the modes in the table

    // Did not find the specifed resolution/refresh rate conbination.
    return 1;
} // end of vesaGetDMTTimings


// This function simply returns the number of entries in the GTF table
// 

unsigned int vesaGetNumGTFEntries
(
void
)
{
    unsigned int numEntries;

    // For each mode, there are 12 (unsigned int) timing values
    numEntries = sizeof(GTFTimingTable) / (sizeof(unsigned int) * 12);

    return(numEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\arb_fifo.h ===
#ifndef _ARB_FIFO_H

#define ARB_FIFO_H

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128


typedef struct {
  int gdrain_rate;
  int vdrain_rate;
  int mdrain_rate;

  int gburst_size;
  int vburst_size;
  char vid_en;
  char gr_en;
  int wcmocc, wcgocc, wcvocc, wcvlwm, wcglwm;
  int by_gfacc;
  char vid_only_once;
  char gr_only_once;
  char first_vacc;
  char first_gacc;
  char first_macc;
  int vocc;
  int gocc;
  int mocc;
  char cur;
  char engine_en;
  char converged;
  int priority;
} arb_info;


// the following structures are used by nv3

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;  //Burst size
  int video_burst_size;   // Burst size

  int graphics_hi_priority; // FBI arbitration
  int media_hi_priority;

  int rtl_values;
  int valid;  // good values


} fifo_info;
typedef struct {

  int pix_bpp;          /* 8, 16 or 32 */

  char enable_video; /* Video scalar enabled */
  char gr_during_vid; /* Graphic displays during video */
  char enable_mp; /* Media Port enabled */

  int memory_width;  /* 64 or 128 bits */

  int video_scale; /* video scale factor */

  long pclk_khz; /* Pixel clock, in KHz */
  long mclk_khz; /* Memory clock, in KHz */

  int mem_page_miss; /* Memory page miss penalty */
  int mem_latency;  /* Memory latency */

  char mem_aligned; /* FB is aligned on a 256 byte boundry */
} sim_state;


// the following structures are used by nv4

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;
  int video_burst_size;

  int valid;  // good values

} nv4_fifo_info;

typedef struct {
  int pclk_khz;
  int mclk_khz;
  int nvclk_khz;
  char mem_page_miss;
  char mem_latency; //cas_latency
  int memory_width;
  char enable_video;
  char gr_during_vid;
  char pix_bpp;
  char mem_aligned;
  char enable_mp;
} nv4_sim_state;




#define VIDEO       0
#define GRAPHICS    1
#define MPORT       2
#define ENGINE      3


#define GFIFO_SIZE  320     /* Graphics Fifo Sizes */
#define GFIFO_SIZE_128  256     /* Graphics Fifo Sizes */
#define MFIFO_SIZE  120 /* MP  Fifo Sizes */
#define VFIFO_SIZE  256 /* Video Fifo Sizes */

#define ABS(a)  (a>0?a:-a)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\memstruc.h ===
//****************************Module*Header***********************************
//
// Module Name: memstruc.h
//
//****************************************************************************

/*****************************************************************************
 *                                                                           *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.             *
 *                                                                           *
 ****************************************************************************/

//----------------------------------------------------------------------------
// WARNING:  For now, make sure this structure agrees with the one defined in MCD.H
//           We'll eventually move over to exclusively using THIS file,
//           so that the display driver can also use the memory_t structure.
//----------------------------------------------------------------------------

typedef struct _memory_t
{
    struct _memory_t    *prev;
    struct _memory_t    *next;
    struct _memory_t    *nextEmpty;
    ULONG               blkSize;
    ULONG               memBase;
} memory_t;

#define EMPTY               0x1
#define ALIGN_SIZE          64

#define IS_EMPTY(pBlk)      (((ULONG_PTR)(pBlk)->prev) & EMPTY )
#define SET_EMPTY(pBlk)     (pBlk)->prev = (memory_t *)(((BYTE *)(pBlk)->prev) + EMPTY)
#define SET_BUSY(pBlk)      (pBlk)->prev = (memory_t *)(((BYTE *)(pBlk)->prev) - EMPTY)
#define EMPTY_VALUE(pBlk)   ((memory_t *) (((BYTE *)(pBlk)) + EMPTY))
#define BUSY_VALUE(pBlk)    ((memory_t *) (((BYTE *)(pBlk)) - EMPTY))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv4\ddc.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     DDC.C
//
// Abstract:
//
//     This is code specific to NV4
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"

// MP/RM merge
#include "nvos.h"
#include "rm.h"

extern VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );


//******************************************************************************
// DDC support is only available for NT5 or later
//******************************************************************************


#if (_WIN32_WINNT >= 0x0500)


//******************************************************************************
// Forward Function Declarations
//******************************************************************************

VOID    WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension);
ULONG GetCurrentScanLine(PHW_DEVICE_EXTENSION);

BOOLEAN
GetDdcInformation (
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetDdcInformation)
#endif

//******************************************************************************
//
//  Register Description:
//
//
//        6.24 CR3E DDC Status Register                 0x3X5 Index 3E (R-)
//      
//      #define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
//      
//         Bit 3    SDA pin.  This is the current value of the SDA pin.
//         Bit 2    SCL pin.  This is the current value of the SCL pin.
//      
//      
//        6.23 CR3F DDC Write Register                   0x3X5 Index 3F (RW)
//      #define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
//      
//         Bits 7-6 Reserved
//      
//         Bits 5   Write SCL pin. If 1, this will tri-state the SCL bus.  This will allow
//      	    the value of the SCL pin to reach a 1 since the SCL pin is connected
//      	    to a external pull-up.  A 0 will enable the SCL pin and force
//      	    a 0 onto the SCL signal.
//      
//         Bits 4   Write SDA pin. If 1, this will tri-state the SDA bus.  This will allow
//      	    the value of the SDA pin to reach a 1 since the SDA pin is connected
//      	    to a external pull-up.  A 0 will enable the SDA pin and force
//      	    a 0 onto the SDA signal.
//      
//         Bits 3-2   Reserved. 
//      
//         Bit  1   DDC Write release.  When a 0 is written, it will release the SCL pin
//      	    and allow it to float high.  When a 1 is written, it will latch the 
//      	    SDA value at the next falling edge of SCL and hold the SCL pin low
//      	    until a 0 is written.
//      
//         Bit  0   DDC enable pin.  Enables writes onto the DDC pins.  
//      	    1 indicates writes are enabled. 
//      
//         This register defaults to 0x30 after reset.
//         
//         The DDC is really a I2C interface.  This interface is designed to allow easy
//         software controllability.  
//      
//      None.
//
//******************************************************************************


//******************************************************************************
//
//  Function:   WriteClockLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)

    {
    UCHAR ucPortData;

    //**************************************************************************
    // Read current value then update
    //**************************************************************************
        
    CRTC_RD(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);

    if (ucData)
        ucPortData |= 0x20;
    else        
        ucPortData &= (~0x20);  

    //**************************************************************************
    // Set new value
    //**************************************************************************

    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);   

    }

//******************************************************************************
//
//  Function:   WriteDataLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)

    {
    UCHAR ucPortData;

    //**************************************************************************
    // Read current value then update
    //**************************************************************************
        
    CRTC_RD(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);

    if (ucData)
        ucPortData |= 0x10;
    else        
        ucPortData &= (~0x10);  

    //**************************************************************************
    // Set new value
    //**************************************************************************

    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);   

    }

//******************************************************************************
//
//  Function:   ReadClockLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    UCHAR ucPortData;
    
    //**************************************************************************
    //  Bit 2    SCL pin (current value of the SCL pin)
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX , ucPortData);

    return((BOOLEAN)(ucPortData&4) >> 2);
    }


//******************************************************************************
//
//  Function:   ReadDataLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    UCHAR ucPortData;
    
    //**************************************************************************
    //  Bit 3    SDA pin (current value of the SCL pin)
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX , ucPortData);

    return((BOOLEAN)(ucPortData&8) >> 3);
    }

//******************************************************************************
//
//  Function:   WaitForVsyncActive
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    //**************************************************************************
    // Wait while in vblank
    //**************************************************************************

    while (GetCurrentScanLine(HwDeviceExtension) ==0);

    //**************************************************************************
    // Wait while display is active
    //**************************************************************************

    while (GetCurrentScanLine(HwDeviceExtension) !=0);

    //**************************************************************************
    // Now we're in vblank
    //**************************************************************************

    }


//******************************************************************************
//
//  Function: GetCurrentScanLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG GetCurrentScanLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    ULONG   LoByte, HiByte;
    ULONG   Value;
    
    //**************************************************************************
    // Get current scanline by reading both registers
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_RL1__INDEX , HiByte);
    HiByte <<=8;
    
    CRTC_RD(NV_CIO_CRE_RL0__INDEX , LoByte);
    LoByte &=0xff;
        
    Value = ( (HiByte << 8) | (LoByte&0xff) );
    Value &= 0x7FF;
        
    if (Value == 0)
        {
        //**********************************************************************
        // Double check to fix hw bug. (for NV3)
        //**********************************************************************

        CRTC_RD(NV_CIO_CRE_RL1__INDEX , HiByte);
        HiByte <<=8;
    
        CRTC_RD(NV_CIO_CRE_RL0__INDEX , LoByte);
        LoByte &=0xff;
        
        Value = ( (HiByte << 8) | (LoByte&0xff) );
        Value &= 0x7FF;
        }


    return(Value);
    }


//******************************************************************************
//
//  Function:   GetDdcInformation
//
//  Routine Description:
//
//      Reads the basic EDID structure from the monitor using DDC2.
//
//  Arguments:
//
//      HwDeviceExtension - Points to per-adapter device extension.
//  
//      QueryBuffer       - Buffer where information will be stored.
//  
//      BufferSize        - Size of the buffer to fill.
//
//  Return Value:
//
//      Whether the call succeeded or not.
//
//******************************************************************************


BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize)

    {
    ULONG         i;
    ULONG ulHead;
    NVTWINVIEWDATA TwinViewData;
    VP_STATUS status;


    // This function will be called only for the case of a board with a single head.
    // So we reference the EDID info of the Head 0.
    ulHead = 0;

    //
    // Enable this code once Terry finishes the control panel work of automoatically disabling the system EDID for
    // spanning modes.
    //
#ifdef ENABLE_EXPORTING_EDID_TO_WIN2K

    status = VideoPortGetRegistryParameters(
                                       HwDeviceExtension,
                                       L"TwinviewInfo",
                                       FALSE,
                                       NVReadRegistryTwinViewInfoCallback,
                                       &TwinViewData);
    if (status == NO_ERROR)
    {
        // Extract the primary head. For standard/clone/span modes, we will let the OS manage the properties
        // (refresh rate, color depth, EDID flag) of the primary head.
        // Note: Dependency: The control panel needs to automatically disable the OS EDID if the user wants to switch
        // to spanning mode, otherwise the 'faked' doubled modes will be disallowed by the OS.
        ulHead = TwinViewData.dwDeviceDisplay[0];
        VideoDebugPrint((0,"Exporting EDID of head: 0x%x as the primary head from the TwinViewInfo structure\n", ulHead));
    }
    else
    {
       // BUGBUG: what happens if the display driver uses head1 for normal mode. We don't know yet what head
       // the display driver is going to use since we are still in the very early part of booting before any
       // modeset has happened.
       ulHead = 0;
       VideoDebugPrint((0," TwinViewInfo is absent: Exporting EDID of head: 0x%x as the default primary head\n", ulHead));
    }
#endif


    //**************************************************************************
    // If a flat panel was connected, then just return the EDID buffer
    // (which was obtained in the RM). Do the same for a CRT also.
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

        //**********************************************************************
        // Win2k (as of build 2195) does NOT seem to understand version 2.0 EDIDs.
        // Returning a version 2.0 EDID will cause Win2k to come up in VGA.
        // So for now, if we detect version 2.0, then just return FAILURE, and
        // don't bother returning the EDID.  (Fixes Gateway FPD1500 flat panel)
        //**********************************************************************

    	if (! ((HwDeviceExtension->EDIDBuffer[ulHead][0] == 0)    && 
               (HwDeviceExtension->EDIDBuffer[ulHead][1] == 0xFF) && 
               (HwDeviceExtension->EDIDBuffer[ulHead][7] == 0)) )
            return(FALSE);
        }

    //
    // Return failure if this is a non-DDC device. The whole EDID structure would have been zeroed out in this case.
    // Let us check a few random fields to verify.
    // (18)    EDID Version Number
    // (19)    Revision number
    //
    if (HwDeviceExtension->EDIDBuffer[ulHead][0] == 0    && 
        HwDeviceExtension->EDIDBuffer[ulHead][1] == 0    && 
        HwDeviceExtension->EDIDBuffer[ulHead][7] == 0    && 
        HwDeviceExtension->EDIDBuffer[ulHead][18] == 0   && 
        HwDeviceExtension->EDIDBuffer[ulHead][19] == 0)
        {
            VideoDebugPrint((0,"This is a non-DDC monitor. So not returning any EDID\n"));     
            return(FALSE);
        }

    if (!HwDeviceExtension->EDIDBufferValid[ulHead])
    {
        VideoDebugPrint((0,"This is a non-DDC monitor. So not returning any EDID\n"));     
        return(FALSE);
    }
    

    //**********************************************************************
    // Go ahead and return the EDID
    //**********************************************************************

    for (i=0;i<BufferSize;i++)
        *(QueryBuffer+i) = HwDeviceExtension->EDIDBuffer[ulHead][i];

    //**********************************************************************
    // Return Success.
    //**********************************************************************

    return(TRUE);

    }



#endif // _WIN32_WINNT >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv4\nvdat.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVDAT.C
//
// Abstract:
//
//     This module contains all the global data used by the NV driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "cmdcnst.h"
#include "modes.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//***************************************************************************************
//
// NV4 supported modes,
//
// 8bpp - all modes, all refresh rates supported
// 16bpp - all modes, all refresh rates supported
// 32bpp - 1280x1024 max at 100Hz, 1600x1200 max at 75Hz, 1920x1080 max at 72Hz, 1920x1200 max at 60Hz
//
//***************************************************************************************

U016 fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS][NUM_REFRESHES][NUM_ELEMENTS] =
{
    //**************************************************************************************
    // 640x480 at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 640,480,8, 60},
    {FALSE, 640,480,8, 70},
    {FALSE, 640,480,8, 72},
    {FALSE, 640,480,8, 75},
    {FALSE, 640,480,8, 85},
    {FALSE, 640,480,8, 100},
    {FALSE, 640,480,8, 120}
    },
    {
    {FALSE, 640,480,15, 60},
    {FALSE, 640,480,15, 70},
    {FALSE, 640,480,15, 72},
    {FALSE, 640,480,15, 75},
    {FALSE, 640,480,15, 85},
    {FALSE, 640,480,15, 100},
    {FALSE, 640,480,15, 120}
    },
    {
    {FALSE, 640,480,16, 60},
    {FALSE, 640,480,16, 70},
    {FALSE, 640,480,16, 72},
    {FALSE, 640,480,16, 75},
    {FALSE, 640,480,16, 85},
    {FALSE, 640,480,16, 100},
    {FALSE, 640,480,16, 120}
    },
    {
    {FALSE, 640,480,24, 60},
    {FALSE, 640,480,24, 70},
    {FALSE, 640,480,24, 72},
    {FALSE, 640,480,24, 75},
    {FALSE, 640,480,24, 85},
    {FALSE, 640,480,24, 100},
    {FALSE, 640,480,24, 120}
    },
    {
    {FALSE, 640,480,32, 60},
    {FALSE, 640,480,32, 70},
    {FALSE, 640,480,32, 72},
    {FALSE, 640,480,32, 75},
    {FALSE, 640,480,32, 85},
    {FALSE, 640,480,32, 100},
    {FALSE, 640,480,32, 120}
    },

    //***********************************************************************************
    // 320x240 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,240,8, 60},
    {FALSE, 320,240,8, 70},
    {FALSE, 320,240,8, 72},
    {FALSE, 320,240,8, 75},
    {FALSE, 320,240,8, 85},
    {FALSE, 320,240,8, 100},
    {FALSE, 320,240,8, 120}
    },
    {
    {FALSE, 320,240,15, 60},
    {FALSE, 320,240,15, 70},
    {FALSE, 320,240,15, 72},
    {FALSE, 320,240,15, 75},
    {FALSE, 320,240,15, 85},
    {FALSE, 320,240,15, 100},
    {FALSE, 320,240,15, 120}
    },
    {
    {FALSE, 320,240,16, 60},
    {FALSE, 320,240,16, 70},
    {FALSE, 320,240,16, 72},
    {FALSE, 320,240,16, 75},
    {FALSE, 320,240,16, 85},
    {FALSE, 320,240,16, 100},
    {FALSE, 320,240,16, 120}
    },
    {
    {FALSE, 320,240,24, 60},
    {FALSE, 320,240,24, 70},
    {FALSE, 320,240,24, 72},
    {FALSE, 320,240,24, 75},
    {FALSE, 320,240,24, 85},
    {FALSE, 320,240,24, 100},
    {FALSE, 320,240,24, 120}
    },
    {
    {FALSE, 320,240,32, 60},
    {FALSE, 320,240,32, 70},
    {FALSE, 320,240,32, 72},
    {FALSE, 320,240,32, 75},
    {FALSE, 320,240,32, 85},
    {FALSE, 320,240,32, 100},
    {FALSE, 320,240,32, 120}
    },
    //***********************************************************************************
    // 320x400 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,400,8, 70},
    {FALSE, 320,400,8, 70},
    {FALSE, 320,400,8, 72},
    {FALSE, 320,400,8, 75},
    {FALSE, 320,400,8, 85},
    {FALSE, 320,400,8, 100},
    {FALSE, 320,400,8, 120}
    },
    {
    {FALSE, 320,400,15, 70},
    {FALSE, 320,400,15, 70},
    {FALSE, 320,400,15, 72},
    {FALSE, 320,400,15, 75},
    {FALSE, 320,400,15, 85},
    {FALSE, 320,400,15, 100},
    {FALSE, 320,400,15, 120}
    },
    {
    {FALSE, 320,400,16, 70},
    {FALSE, 320,400,16, 70},
    {FALSE, 320,400,16, 72},
    {FALSE, 320,400,16, 75},
    {FALSE, 320,400,16, 85},
    {FALSE, 320,400,16, 100},
    {FALSE, 320,400,16, 120}
    },
    {
    {FALSE, 320,400,24, 70},
    {FALSE, 320,400,24, 70},
    {FALSE, 320,400,24, 72},
    {FALSE, 320,400,24, 75},
    {FALSE, 320,400,24, 85},
    {FALSE, 320,400,24, 100},
    {FALSE, 320,400,24, 120}
    },
    {
    {FALSE, 320,400,32, 70},
    {FALSE, 320,400,32, 70},
    {FALSE, 320,400,32, 72},
    {FALSE, 320,400,32, 75},
    {FALSE, 320,400,32, 85},
    {FALSE, 320,400,32, 100},
    {FALSE, 320,400,32, 120}
    },
    //***********************************************************************************
    // 400x300 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 400,300,8, 60},
    {FALSE, 400,300,8, 70},
    {FALSE, 400,300,8, 72},
    {FALSE, 400,300,8, 75},
    {FALSE, 400,300,8, 85},
    {FALSE, 400,300,8, 100},
    {FALSE, 400,300,8, 120}
    },
    {
    {FALSE, 400,300,15, 60},
    {FALSE, 400,300,15, 70},
    {FALSE, 400,300,15, 72},
    {FALSE, 400,300,15, 75},
    {FALSE, 400,300,15, 85},
    {FALSE, 400,300,15, 100},
    {FALSE, 400,300,15, 120}
    },
    {
    {FALSE, 400,300,16, 60},
    {FALSE, 400,300,16, 70},
    {FALSE, 400,300,16, 72},
    {FALSE, 400,300,16, 75},
    {FALSE, 400,300,16, 85},
    {FALSE, 400,300,16, 100},
    {FALSE, 400,300,16, 120}
    },
    {
    {FALSE, 400,300,24, 60},
    {FALSE, 400,300,24, 70},
    {FALSE, 400,300,24, 72},
    {FALSE, 400,300,24, 75},
    {FALSE, 400,300,24, 85},
    {FALSE, 400,300,24, 100},
    {FALSE, 400,300,24, 120}
    },
    {
    {FALSE, 400,300,32, 60},
    {FALSE, 400,300,32, 70},
    {FALSE, 400,300,32, 72},
    {FALSE, 400,300,32, 75},
    {FALSE, 400,300,32, 85},
    {FALSE, 400,300,32, 100},
    {FALSE, 400,300,32, 120}
    },
    //***********************************************************************************
    // 480x360 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 480,360,8, 60},
    {FALSE, 480,360,8, 70},
    {FALSE, 480,360,8, 72},
    {FALSE, 480,360,8, 75},
    {FALSE, 480,360,8, 85},
    {FALSE, 480,360,8, 100},
    {FALSE, 480,360,8, 120}
    },
    {
    {FALSE, 480,360,15, 60},
    {FALSE, 480,360,15, 70},
    {FALSE, 480,360,15, 72},
    {FALSE, 480,360,15, 75},
    {FALSE, 480,360,15, 85},
    {FALSE, 480,360,15, 100},
    {FALSE, 480,360,15, 120}
    },
    {
    {FALSE, 480,360,16, 60},
    {FALSE, 480,360,16, 70},
    {FALSE, 480,360,16, 72},
    {FALSE, 480,360,16, 75},
    {FALSE, 480,360,16, 85},
    {FALSE, 480,360,16, 100},
    {FALSE, 480,360,16, 120}
    },
    {
    {FALSE, 480,360,24, 60},
    {FALSE, 480,360,24, 70},
    {FALSE, 480,360,24, 72},
    {FALSE, 480,360,24, 75},
    {FALSE, 480,360,24, 85},
    {FALSE, 480,360,24, 100},
    {FALSE, 480,360,24, 120}
    },
    {
    {FALSE, 480,360,32, 60},
    {FALSE, 480,360,32, 70},
    {FALSE, 480,360,32, 72},
    {FALSE, 480,360,32, 75},
    {FALSE, 480,360,32, 85},
    {FALSE, 480,360,32, 100},
    {FALSE, 480,360,32, 120}
    },

    //***********************************************************************************
    // 512x384. at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 512,384,8, 60},
    {FALSE, 512,384,8, 70},
    {FALSE, 512,384,8, 72},
    {FALSE, 512,384,8, 75},
    {FALSE, 512,384,8, 85},
    {FALSE, 512,384,8, 100},
    {FALSE, 512,384,8, 120},
    },
    {
    {FALSE, 512,384,15, 60},
    {FALSE, 512,384,15, 70},
    {FALSE, 512,384,15, 72},
    {FALSE, 512,384,15, 75},
    {FALSE, 512,384,15, 85},
    {FALSE, 512,384,15, 100},
    {FALSE, 512,384,15, 120},
    },
    {
    {FALSE, 512,384,16, 60},
    {FALSE, 512,384,16, 70},
    {FALSE, 512,384,16, 72},
    {FALSE, 512,384,16, 75},
    {FALSE, 512,384,16, 85},
    {FALSE, 512,384,16, 100},
    {FALSE, 512,384,16, 120},
    },
    {
    {FALSE, 512,384,24, 60},
    {FALSE, 512,384,24, 70},
    {FALSE, 512,384,24, 72},
    {FALSE, 512,384,24, 75},
    {FALSE, 512,384,24, 85},
    {FALSE, 512,384,24, 100},
    {FALSE, 512,384,24, 120},
    },
    {
    {FALSE, 512,384,32, 60},
    {FALSE, 512,384,32, 70},
    {FALSE, 512,384,32, 72},
    {FALSE, 512,384,32, 75},
    {FALSE, 512,384,32, 85},
    {FALSE, 512,384,32, 100},
    {FALSE, 512,384,32, 120},
    },
    //*************************************************************************************
    // 640x400.  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 640,400,8, 70},
    {FALSE, 640,400,8, 70},
    {FALSE, 640,400,8, 72},
    {FALSE, 640,400,8, 75},
    {FALSE, 640,400,8, 85},
    {FALSE, 640,400,8, 100},
    {FALSE, 640,400,8, 120}
    },
    {
    {FALSE, 640,400,15, 70},
    {FALSE, 640,400,15, 70},
    {FALSE, 640,400,15, 72},
    {FALSE, 640,400,15, 75},
    {FALSE, 640,400,15, 85},
    {FALSE, 640,400,15, 100},
    {FALSE, 640,400,15, 120}
    },
    {
    {FALSE, 640,400,16, 70},
    {FALSE, 640,400,16, 70},
    {FALSE, 640,400,16, 72},
    {FALSE, 640,400,16, 75},
    {FALSE, 640,400,16, 85},
    {FALSE, 640,400,16, 100},
    {FALSE, 640,400,16, 120}
    },
    {
    {FALSE, 640,400,24, 70},
    {FALSE, 640,400,24, 70},
    {FALSE, 640,400,24, 72},
    {FALSE, 640,400,24, 75},
    {FALSE, 640,400,24, 85},
    {FALSE, 640,400,24, 100},
    {FALSE, 640,400,24, 120}
    },
    {
    {FALSE, 640,400,32, 70},
    {FALSE, 640,400,32, 70},
    {FALSE, 640,400,32, 72},
    {FALSE, 640,400,32, 75},
    {FALSE, 640,400,32, 85},
    {FALSE, 640,400,32, 100},
    {FALSE, 640,400,32, 120}
    },

    //***********************************************************************************
    // 320x200  at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,200,8, 70},
    {FALSE, 320,200,8, 70},
    {FALSE, 320,200,8, 72},
    {FALSE, 320,200,8, 75},
    {FALSE, 320,200,8, 85},
    {FALSE, 320,200,8, 100},
    {FALSE, 320,200,8, 120}
    },
    {
    {FALSE, 320,200,15, 70},
    {FALSE, 320,200,15, 70},
    {FALSE, 320,200,15, 72},
    {FALSE, 320,200,15, 75},
    {FALSE, 320,200,15, 85},
    {FALSE, 320,200,15, 100},
    {FALSE, 320,200,15, 120}
    },
    {
    {FALSE, 320,200,16, 70},
    {FALSE, 320,200,16, 70},
    {FALSE, 320,200,16, 72},
    {FALSE, 320,200,16, 75},
    {FALSE, 320,200,16, 85},
    {FALSE, 320,200,16, 100},
    {FALSE, 320,200,16, 120}
    },
    {
    {FALSE, 320,200,24, 70},
    {FALSE, 320,200,24, 70},
    {FALSE, 320,200,24, 72},
    {FALSE, 320,200,24, 75},
    {FALSE, 320,200,24, 85},
    {FALSE, 320,200,24, 100},
    {FALSE, 320,200,24, 120}
    },
    {
    {FALSE, 320,200,32, 70},
    {FALSE, 320,200,32, 70},
    {FALSE, 320,200,32, 72},
    {FALSE, 320,200,32, 75},
    {FALSE, 320,200,32, 85},
    {FALSE, 320,200,32, 100},
    {FALSE, 320,200,32, 120}
    },

    //**************************************************************************************
    // 800x600.  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 800,600,8, 60},
    {FALSE, 800,600,8, 70},
    {FALSE, 800,600,8, 72},
    {FALSE, 800,600,8, 75},
    {FALSE, 800,600,8, 85},
    {FALSE, 800,600,8, 100},
    {FALSE, 800,600,8, 120}
    },
    {
    {FALSE, 800,600,15, 60},
    {FALSE, 800,600,15, 70},
    {FALSE, 800,600,15, 72},
    {FALSE, 800,600,15, 75},
    {FALSE, 800,600,15, 85},
    {FALSE, 800,600,15, 100},
    {FALSE, 800,600,15, 120}
    },
    {
    {FALSE, 800,600,16, 60},
    {FALSE, 800,600,16, 70},
    {FALSE, 800,600,16, 72},
    {FALSE, 800,600,16, 75},
    {FALSE, 800,600,16, 85},
    {FALSE, 800,600,16, 100},
    {FALSE, 800,600,16, 120}
    },
    {
    {FALSE, 800,600,24, 60},
    {FALSE, 800,600,24, 70},
    {FALSE, 800,600,24, 72},
    {FALSE, 800,600,24, 75},
    {FALSE, 800,600,24, 85},
    {FALSE, 800,600,24, 100},
    {FALSE, 800,600,24, 120}
    },
    {
    {FALSE, 800,600,32, 60},
    {FALSE, 800,600,32, 70},
    {FALSE, 800,600,32, 72},
    {FALSE, 800,600,32, 75},
    {FALSE, 800,600,32, 85},
    {FALSE, 800,600,32, 100},
    {FALSE, 800,600,32, 120}
    },
    //**************************************************************************************
    // 960x720  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 960,720,8, 60},
    {FALSE, 960,720,8, 70},
    {FALSE, 960,720,8, 72},
    {FALSE, 960,720,8, 75},
    {FALSE, 960,720,8, 85},
    {FALSE, 960,720,8, 100},
    {FALSE, 960,720,8, 120}
    },
    {
    {FALSE, 960,720,15, 60},
    {FALSE, 960,720,15, 70},
    {FALSE, 960,720,15, 72},
    {FALSE, 960,720,15, 75},
    {FALSE, 960,720,15, 85},
    {FALSE, 960,720,15, 100},
    {FALSE, 960,720,15, 120}
    },
    {
    {FALSE, 960,720,16, 60},
    {FALSE, 960,720,16, 70},
    {FALSE, 960,720,16, 72},
    {FALSE, 960,720,16, 75},
    {FALSE, 960,720,16, 85},
    {FALSE, 960,720,16, 100},
    {FALSE, 960,720,16, 120}
    },
    {
    {FALSE, 960,720,24, 60},
    {FALSE, 960,720,24, 70},
    {FALSE, 960,720,24, 72},
    {FALSE, 960,720,24, 75},
    {FALSE, 960,720,24, 85},
    {FALSE, 960,720,24, 100},
    {FALSE, 960,720,24, 120}
    },
    {
    {FALSE, 960,720,32, 60},
    {FALSE, 960,720,32, 70},
    {FALSE, 960,720,32, 72},
    {FALSE, 960,720,32, 75},
    {FALSE, 960,720,32, 85},
    {FALSE, 960,720,32, 100},
    {FALSE, 960,720,32, 120}
    },
    //**************************************************************************************
    // 1024x768  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1024,768,8, 60},
    {FALSE, 1024,768,8, 70},
    {FALSE, 1024,768,8, 72},
    {FALSE, 1024,768,8, 75},
    {FALSE, 1024,768,8, 85},
    {FALSE, 1024,768,8, 100},
    {FALSE, 1024,768,8, 120}
    },
    {
    {FALSE, 1024,768,15, 60},
    {FALSE, 1024,768,15, 70},
    {FALSE, 1024,768,15, 72},
    {FALSE, 1024,768,15, 75},
    {FALSE, 1024,768,15, 85},
    {FALSE, 1024,768,15, 100},
    {FALSE, 1024,768,15, 120}
    },
    {
    {FALSE, 1024,768,16, 60},
    {FALSE, 1024,768,16, 70},
    {FALSE, 1024,768,16, 72},
    {FALSE, 1024,768,16, 75},
    {FALSE, 1024,768,16, 85},
    {FALSE, 1024,768,16, 100},
    {FALSE, 1024,768,16, 120}
    },
    {
    {FALSE, 1024,768,24, 60},
    {FALSE, 1024,768,24, 70},
    {FALSE, 1024,768,24, 72},
    {FALSE, 1024,768,24, 75},
    {FALSE, 1024,768,24, 85},
    {FALSE, 1024,768,24, 100},
    {FALSE, 1024,768,24, 120}
    },
    {
    {FALSE, 1024,768,32, 60},
    {FALSE, 1024,768,32, 70},
    {FALSE, 1024,768,32, 72},
    {FALSE, 1024,768,32, 75},
    {FALSE, 1024,768,32, 85},
    {FALSE, 1024,768,32, 100},
    {FALSE, 1024,768,32, 120}
    },
    //*************************************************************************************
    // 1152x864  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 1152,864,8, 60},
    {FALSE, 1152,864,8, 70},
    {FALSE, 1152,864,8, 72},
    {FALSE, 1152,864,8, 75},
    {FALSE, 1152,864,8, 85},
    {FALSE, 1152,864,8, 100},
    {FALSE, 1152,864,8, 120}
    },
    {
    {FALSE, 1152,864,15, 60},
    {FALSE, 1152,864,15, 70},
    {FALSE, 1152,864,15, 72},
    {FALSE, 1152,864,15, 75},
    {FALSE, 1152,864,15, 85},
    {FALSE, 1152,864,15, 100},
    {FALSE, 1152,864,15, 120}
    },
    {
    {FALSE, 1152,864,16, 60},
    {FALSE, 1152,864,16, 70},
    {FALSE, 1152,864,16, 72},
    {FALSE, 1152,864,16, 75},
    {FALSE, 1152,864,16, 85},
    {FALSE, 1152,864,16, 100},
    {FALSE, 1152,864,16, 120}
    },
    {
    {FALSE, 1152,864,24, 60},
    {FALSE, 1152,864,24, 70},
    {FALSE, 1152,864,24, 72},
    {FALSE, 1152,864,24, 75},
    {FALSE, 1152,864,24, 85},
    {FALSE, 1152,864,24, 100},
    {FALSE, 1152,864,24, 120}
    },
    {
    {FALSE, 1152,864,32, 60},
    {FALSE, 1152,864,32, 70},
    {FALSE, 1152,864,32, 72},
    {FALSE, 1152,864,32, 75},
    {FALSE, 1152,864,32, 85},
    {FALSE, 1152,864,32, 100},
    {FALSE, 1152,864,32, 120}
    },
    //*************************************************************************************
    // 1280x1024  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 1280,1024,8, 60},
    {FALSE, 1280,1024,8, 70},
    {FALSE, 1280,1024,8, 72},
    {FALSE, 1280,1024,8, 75},
    {FALSE, 1280,1024,8, 85},
    {FALSE, 1280,1024,8, 100},
    {FALSE, 1280,1024,8, 120}
    },
    {
    {FALSE, 1280,1024,15, 60},
    {FALSE, 1280,1024,15, 70},
    {FALSE, 1280,1024,15, 72},
    {FALSE, 1280,1024,15, 75},
    {FALSE, 1280,1024,15, 85},
    {FALSE, 1280,1024,15, 100},
    {FALSE, 1280,1024,15, 120}
    },
    {
    {FALSE, 1280,1024,16, 60},
    {FALSE, 1280,1024,16, 70},
    {FALSE, 1280,1024,16, 72},
    {FALSE, 1280,1024,16, 75},
    {FALSE, 1280,1024,16, 85},
    {FALSE, 1280,1024,16, 100},
    {FALSE, 1280,1024,16, 120}
    },
    {
    {FALSE, 1280,1024,24, 60},
    {FALSE, 1280,1024,24, 70},
    {FALSE, 1280,1024,24, 72},
    {FALSE, 1280,1024,24, 75},
    {FALSE, 1280,1024,24, 85},
    {FALSE, 1280,1024,24, 100},
    {FALSE, 1280,1024,24, 100}
    },
    {
    {FALSE, 1280,1024,32, 60},
    {FALSE, 1280,1024,32, 70},
    {FALSE, 1280,1024,32, 72},
    {FALSE, 1280,1024,32, 75},
    {FALSE, 1280,1024,32, 85},
    {FALSE, 1280,1024,32, 100},
    {FALSE, 1280,1024,32, 100}
    },
    //**************************************************************************************
    // 1600x1024  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1600,1024,8, 60},
    {FALSE, 1600,1024,8, 70},
    {FALSE, 1600,1024,8, 72},
    {FALSE, 1600,1024,8, 76},
    {FALSE, 1600,1024,8, 85},
    {FALSE, 1600,1024,8, 85},
    {FALSE, 1600,1024,8, 85}
     },
    {
    {FALSE, 1600,1024,15, 60},
    {FALSE, 1600,1024,15, 70},
    {FALSE, 1600,1024,15, 72},
    {FALSE, 1600,1024,15, 76},
    {FALSE, 1600,1024,15, 85},
    {FALSE, 1600,1024,15, 85},
    {FALSE, 1600,1024,15, 85}
     },
    {
    {FALSE, 1600,1024,16, 60},
    {FALSE, 1600,1024,16, 70},
    {FALSE, 1600,1024,16, 72},
    {FALSE, 1600,1024,16, 76},
    {FALSE, 1600,1024,16, 85},
    {FALSE, 1600,1024,16, 85},
    {FALSE, 1600,1024,16, 85}
     },
    {
    {FALSE, 1600,1024,24, 60},
    {FALSE, 1600,1024,24, 70},
    {FALSE, 1600,1024,24, 72},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76}
     },
    {
    {FALSE, 1600,1024,32, 60},
    {FALSE, 1600,1024,32, 70},
    {FALSE, 1600,1024,32, 72},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76}
     },
    //**************************************************************************************
    // 1600x1200  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1600,1200,8, 60},
    {FALSE, 1600,1200,8, 70},
    {FALSE, 1600,1200,8, 72},
    {FALSE, 1600,1200,8, 75},
    {FALSE, 1600,1200,8, 85},
    {FALSE, 1600,1200,8, 85},
    {FALSE, 1600,1200,8, 85}
     },
    {
    {FALSE, 1600,1200,15, 60},
    {FALSE, 1600,1200,15, 70},
    {FALSE, 1600,1200,15, 72},
    {FALSE, 1600,1200,15, 75},
    {FALSE, 1600,1200,15, 85},
    {FALSE, 1600,1200,15, 85},
    {FALSE, 1600,1200,15, 85}
     },
    {
    {FALSE, 1600,1200,16, 60},
    {FALSE, 1600,1200,16, 70},
    {FALSE, 1600,1200,16, 72},
    {FALSE, 1600,1200,16, 75},
    {FALSE, 1600,1200,16, 85},
    {FALSE, 1600,1200,16, 85},
    {FALSE, 1600,1200,16, 85}
     },
    {
    {FALSE, 1600,1200,24, 60},
    {FALSE, 1600,1200,24, 70},
    {FALSE, 1600,1200,24, 72},
    {FALSE, 1600,1200,24, 75},
    {FALSE, 1600,1200,24, 85},
    {FALSE, 1600,1200,24, 85},
    {FALSE, 1600,1200,24, 85}
     },
    {
    {FALSE, 1600,1200,32, 60},
    {FALSE, 1600,1200,32, 70},
    {FALSE, 1600,1200,32, 72},
    {FALSE, 1600,1200,32, 75},
    {FALSE, 1600,1200,32, 85},
    {FALSE, 1600,1200,32, 85},
    {FALSE, 1600,1200,32, 85}
     },
     //**************************************************************************************
     // 1800x1440  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60}
      },
     {
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60}
      },
     {
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60}
      },
     {
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60}
      },
     {
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60}
      },
     //**************************************************************************************
     // 1920x1080  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1920,1080,8, 60},
     {FALSE, 1920,1080,8, 70},
     {FALSE, 1920,1080,8, 72},
     {FALSE, 1920,1080,8, 75},
     {FALSE, 1920,1080,8, 85},
     {FALSE, 1920,1080,8, 85},
     {FALSE, 1920,1080,8, 85}
      },
     {
     {FALSE, 1920,1080,15, 60},
     {FALSE, 1920,1080,15, 70},
     {FALSE, 1920,1080,15, 72},
     {FALSE, 1920,1080,15, 75},
     {FALSE, 1920,1080,15, 85},
     {FALSE, 1920,1080,15, 85},
     {FALSE, 1920,1080,15, 85}
      },
     {
     {FALSE, 1920,1080,16, 60},
     {FALSE, 1920,1080,16, 70},
     {FALSE, 1920,1080,16, 72},
     {FALSE, 1920,1080,16, 75},
     {FALSE, 1920,1080,16, 85},
     {FALSE, 1920,1080,16, 85},
     {FALSE, 1920,1080,16, 85}
      },
     {
     {FALSE, 1920,1080,24, 60},
     {FALSE, 1920,1080,24, 70},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72}
      },
     {
     {FALSE, 1920,1080,32, 60},
     {FALSE, 1920,1080,32, 70},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72}
      },
     //**************************************************************************************
     // 1920x1200  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1920,1200,8, 60},
     {FALSE, 1920,1200,8, 70},
     {FALSE, 1920,1200,8, 72},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75}
      },
     {
     {FALSE, 1920,1200,15, 60},
     {FALSE, 1920,1200,15, 70},
     {FALSE, 1920,1200,15, 72},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75}
      },
     {
     {FALSE, 1920,1200,16, 60},
     {FALSE, 1920,1200,16, 70},
     {FALSE, 1920,1200,16, 72},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75}
      },
     {
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60}
      },
     {
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60}
      }
};
//******************************************************************************
// Use a slightly different mode table for NV4
//******************************************************************************


MODEDESC mib[] =             // Our Mode List
{
//    +------- vmode                                max DCLK     ------+
//    |      +----- imode                           row offset   -----+|
//    |      |      +----- std_modetbl              y resolution ----+||
//    |      |      |      +----- ext_modetbl       x resolution ---+|||
//    |      |      |      |     +----- tv_modetbl                  ||||
//    |      |      |      |     |     +----- crtc_override         ||||
//    |      |      |      |     |     |     +----- bits per pixel  ||||
//    |      |      |      |     |     |     |    +-----------------+|||
//    |      |      |      |     |     |     |    |     +------------+||
//    |      |      |      |     |     |     |    |     |     +-------+|
//    |      |      |      |     |     |     |    |     |     |    +---+
//    V      V      V      V     V     V     V    V     V     V    V
    {0x100, 0x5B, PACKED, 0x11, 0x05, 0x06,  8,  640,  400,  640, MAX_DCLK},  // Mode 100 - 640x400    8bpp
    {0x101, 0x5F, PACKED, 0x01, 0x06, 0xFF,  8,  640,  480,  640, MAX_DCLK},  // Mode 101 - 640x480    8bpp
    {0x102, 0x58, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode 102 - 800x600    4bpp
    {0x102, 0x6A, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode  6A - 800x600    4bpp
    {0x103, 0x5C, PACKED, 0x03, 0x07, 0x08,  8,  800,  600,  800, MAX_DCLK},  // Mode 103 - 800x600    8bpp
    {0x104, 0x5D, PLANAR, 0x04, 0x03, 0x0A,  4, 1024,  768, 1024, MAX_ATC },  // Mode 104 - 1024x768   4bpp
    {0x105, 0x5E, PACKED, 0x05, 0xff, 0x0B,  8, 1024,  768, 1024, MAX_DCLK},  // Mode 105 - 1024x768   8bpp
    {0x106, 0x5A, PLANAR, 0x06, 0x03, 0x0D,  4, 1280, 1024,  160, MAX_ATC },  // Mode 106 - 1280x1024  4bpp
    {0x107, 0x6B, PACKED, 0x07, 0xff, 0x0E,  8, 1280, 1024, 1280, MAX_DCLK},  // Mode 107 - 1280x1024  8bpp
    {0x10E, 0x78, PACKED, 0x0D, 0x00, 0x00, 16,  320,  200,  640, MAX_DCLK},  // Mode 10E - 320x200   16bpp
    {0x10F, 0x20, PACKED, 0x12, 0x00, 0x00, 32,  320,  200, 1280, MAX_DCLK},  // Mode 10F - 320x200 32bpp
    {0x111, 0x6E, PACKED, 0x0E, 0x06, 0xFF, 16,  640,  480, 1280, MAX_DCLK},  // Mode 111 - 640x480 16bpp
    {0x112, 0x21, PACKED, 0x19, 0x06, 0xFF, 32,  640,  480, 2560, MAX_DCLK},  // Mode 112 - 640x480 32bpp
    {0x114, 0x6F, PACKED, 0x0F, 0x07, 0x08, 16,  800,  600, 1600, MAX_DCLK},  // Mode 114 - 800x600 16bpp
    {0x115, 0x22, PACKED, 0x1A, 0x07, 0x08, 32,  800,  600, 3200, MAX_DCLK},  // Mode 115 - 800x600 32bpp
    {0x117, 0x72, PACKED, 0x10, 0xff, 0x0B, 16, 1024,  768, 2048, MAX_DCLK},  // Mode 117 - 1024x768 16bpp
    {0x118, 0x3F, PACKED, 0x1C, 0xff, 0x0B, 32, 1024,  768, 4096, MAX_DCLK},  // Mode 118 - 1024x768 32bpp
    {0x11A, 0x44, PACKED, 0x2F, 0xff, 0x0E, 16, 1280, 1024, 2560, MAX_DCLK},  // Mode 11A - 1280x1024 16bbp
    {0x130, 0x30, PACKED, 0x1E, 0x00, 0x00,  8,  320,  200,  320, MAX_DCLK},  // Mode 130 - 320x200  8bbp
    {0x131, 0x31, PACKED, 0x1F, 0x02, 0x02,  8,  320,  400,  320, MAX_DCLK},  // Mode 131 - 320x400 8bpp
    {0x132, 0x32, PACKED, 0x27, 0x02, 0x02, 16,  320,  400,  640, MAX_DCLK},  // Mode 132 - 320x400 16bpp
    {0x133, 0x33, PACKED, 0x13, 0x02, 0x02, 32,  320,  400, 1280, MAX_DCLK},  // Mode 133 - 320x400 32bpp
    {0x134, 0x34, PACKED, 0x20, 0x01, 0x01,  8,  320,  240,  320, MAX_DCLK},  // Mode 134 - 320x240 8bpp
    {0x135, 0x35, PACKED, 0x28, 0x01, 0x01, 16,  320,  240,  640, MAX_DCLK},  // Mode 135 - 320x240 16
    {0x136, 0x36, PACKED, 0x14, 0x01, 0x01, 32,  320,  240, 1280, MAX_DCLK},  // Mode 136 - 320x240 32
    {0x137, 0x37, PACKED, 0x21, 0x03, 0x03,  8,  400,  300,  400, MAX_DCLK},  // Mode 137 - 400x300 8
    {0x138, 0x38, PACKED, 0x29, 0x03, 0x03, 16,  400,  300,  800, MAX_DCLK},  // Mode 138 - 400x300 16
    {0x139, 0x39, PACKED, 0x15, 0x03, 0x03, 32,  400,  300, 1600, MAX_DCLK},  // Mode 139 - 400x300 32
    {0x13A, 0x3A, PACKED, 0x23, 0x04, 0x05,  8,  512,  384,  512, MAX_DCLK},  // Mode 13A - 512x384 8
    {0x13B, 0x3B, PACKED, 0x2B, 0x04, 0x05, 16,  512,  384, 1024, MAX_DCLK},  // Mode 13B - 512x384 16
    {0x13C, 0x3C, PACKED, 0x17, 0x04, 0x05, 32,  512,  384, 2048, MAX_DCLK},  // Mode 13C - 512x384 32
    {0x13D, 0x3D, PACKED, 0x2C, 0x05, 0x06, 16,  640,  400, 1280, MAX_DCLK},  // Mode 13D - 640x400 16
    {0x13E, 0x3E, PACKED, 0x18, 0x05, 0x06, 32,  640,  400, 2560, MAX_DCLK},  // Mode 13E - 640x400 32
    {0x141, 0x41, PACKED, 0x25, 0xff, 0x0C,  8, 1152,  864, 1152, MAX_DCLK},  // Mode 141 - 1152x864 8
    {0x142, 0x42, PACKED, 0x2E, 0xff, 0x0C, 16, 1152,  864, 2304, MAX_DCLK},  // Mode 142 - 1152x864 16
    {0x143, 0x43, PACKED, 0x1D, 0xff, 0x0C, 32, 1152,  864, 4608, MAX_DCLK},  // Mode 143 - 1152x864 32
    {0x145, 0x45, PACKED, 0x26, 0xFF, 0x0F,  8, 1600, 1200, 1600, MAX_DCLK},  // Mode 145 - 1600x1200 8
    {0x146, 0x46, PACKED, 0x30, 0xFF, 0x0F, 16, 1600, 1200, 3200, MAX_DCLK},  // Mode 146 - 1600x1200 16
    // more TV modes?
    {0x147, 0x47, PACKED, 0x22, 0xFF, 0x04,  8,  480,  360,  480, MAX_DCLK},  // Mode 147 - 480x360 8
    {0x148, 0x48, PACKED, 0x2A, 0xFF, 0x04, 16,  480,  360,  960, MAX_DCLK},  // Mode 148 - 480x360 16
    {0x149, 0x49, PACKED, 0x16, 0xFF, 0x04, 32,  480,  360, 1920, MAX_DCLK},  // Mode 149 - 480x360 32
    {0x14A, 0x4A, PACKED, 0x24, 0xff, 0x09,  8,  960,  720,  960, MAX_DCLK},  // Mode 14A - 960x720 8
    {0x14B, 0x4B, PACKED, 0x2D, 0xff, 0x09, 16,  960,  720, 1920, MAX_DCLK},  // Mode 14B - 960x720 16
    {0x14C, 0x4C, PACKED, 0x1B, 0xff, 0x09, 32,  960,  720, 3840, MAX_DCLK},  // Mode 14C - 960x720 32
    {0x14D, 0x4D, PACKED, 0x31, 0xff, 0x0E, 32, 1280, 1024, 5120, MAX_DCLK},  // Mode 14D - 1280x1024 32
    {0x14E, 0x4E, PACKED, 0x32, 0xFF, 0x0F, 32, 1600, 1200, 6400, MAX_DCLK},  // Mode 14E - 1600x1200 32

    // JJV - New Modes
    {0x14F, 0x80, PACKED, 0x33, 0xFF, 0x10,  8, 1800, 1440, 1800, MAX_DCLK},    // Mode 14F - 1800x1440 8
    {0x150, 0x81, PACKED, 0x34, 0xFF, 0x11, 16, 1800, 1440, 3600, MAX_DCLK},    // Mode 150 - 1800x1440 16
    {0x151, 0x82, PACKED, 0x35, 0xFF, 0x12,  8, 1920, 1080, 1920, MAX_DCLK},    // Mode 151 - 1920x1080 8
    {0x152, 0x83, PACKED, 0x36, 0xFF, 0x13, 16, 1920, 1080, 3840, MAX_DCLK},    // Mode 152 - 1920x1080 16
    {0x153, 0x84, PACKED, 0x37, 0xFF, 0x14, 32, 1920, 1080, 7680, MAX_DCLK},    // Mode 153 - 1920x1080 32
    {0x154, 0x85, PACKED, 0x38, 0xFF, 0x15,  8, 1920, 1200, 1920, MAX_DCLK},    // Mode 154 - 1920x1200 8
    {0x155, 0x86, PACKED, 0x39, 0xFF, 0x16, 16, 1920, 1200, 3840, MAX_DCLK},    // Mode 155 - 1920x1200 16
    {0x156, 0x87, PACKED, 0x3A, 0xFF, 0x17, 32, 1920, 1200, 7680, MAX_DCLK},    // Mode 156 - 1920x1200 32
    // JJV - New Modes

    // VEL - New Dell Specific Modes
    {0x157, 0x88, PACKED, 0x3B, 0xFF, 0x18,  8, 1600, 1024, 1600, MAX_DCLK},  // Mode 157 - 1600x1024 8
    {0x158, 0x89, PACKED, 0x3C, 0xFF, 0x19, 16, 1600, 1024, 3200, MAX_DCLK},  // Mode 158 - 1600x1024 16
    {0x159, 0x8A, PACKED, 0x3D, 0xFF, 0x1A, 32, 1600, 1024, 6400, MAX_DCLK},  // Mode 159 - 1600x1024 32
    // VEL - New Dell Specific Modes

    {0xFFFF,0xFF, 0xFF,   0xFF, 0xFF, 0xFF,  0,    0,    0,    0, 0}          // List Terminator
};


CRTC_OVERRIDE crt_override[] =       // Mode overide table for CRTC
{
    // 0. Mode 20h, 78h / VESA Mode 10Eh, 10Fh
    //    320x200 16-bit/32-bit color graphics
    { 0x28, 0x18, 0x08, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0xC0, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 1. Mode 34h,35h,36h / VESA Mode 134h,135h,136h
    //       320x240 16-bit Color Graphics (8x8 font, 40x30 "Text")
    { 0x28, 0x1D, 0x08, 0xE3, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0x0B, 0x3E, 0xC0, 0xEA, 0x0C, 0xDF, 0xDF, 0x0C },

    // 2. Mode 31h,32h,33h / VESA Mode 131h,132h,133h
    //    320x400 16-bit Color Graphics (8x16 font, 40x25 "Text")
    { 0x28, 0x18, 0x10, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 3. Mode 37h,38h,39h / VESA Mode 137h,138h,139h
    //       400x300 16-bit Color Graphics (8x8 font, 50x37 "Text")
    { 0x32, 0x24, 0x08, 0x2B, 0x01, 0x3D, 0x31, 0x31, 0x81, 0x35, 0x1D,
      0x72, 0xF0, 0xE0, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 4. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       480x360 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x3C, 0x2C, 0x08, 0xEB, 0x01, 0x49, 0x3B, 0x3B, 0x8D, 0x40, 0x08,
      0xE8, 0xF0, 0xE0, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },

    // 5. Mode 3Ah,3Bh,3Ch / VESA Mode 13Ah,13Bh,13Ch
    //       512x384 16-bit Color Graphics (8x8 font, 64x48 "Text")
    { 0x40, 0x2F, 0x08, 0xEB, 0x01, 0x4F, 0x3F, 0x3F, 0x93, 0x43, 0x0B,
      0x24, 0xF5, 0xE0, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // 6. Mode 5Bh / VESA Mode 100h / Internal Mode 26h
    //       640x400 8-bit Color Graphics (8x16 font, 80x25 "Text")
    { 0x50, 0x18, 0x10, 0x63, 0x01, 0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 7. Internal Mode 9
    // Mode 58 / VESA Mode 6A / VESA Mode 102 800x600x4
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6B, 0x1B,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 8. Mode 6F / VESA Mode 114h / Internal Mode 24h
    //       800x600 16-bit Color Graphics (8x16 font, 100x37 "Text")
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6A, 0x1A,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 9. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       960x720 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x78, 0x2C, 0x10, 0xEB, 0x01, 0x97, 0x77, 0x77, 0x9B, 0x7F, 0x0B,
      0xE8, 0xF0, 0x60, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },

    // A. Mode B
    // Mode 5D / VESA Mode 104 1024x768x4
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x85, 0x96,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // B. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       1024x768 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x84, 0x95,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // C. Mode 41h/42h/43h / VESA Mode 141,142,143
    // 1152x864x16
    { 0x90, 0x35, 0x10, 0x2B, 0x01, 0xB9, 0x8F, 0x8F, 0x9D, 0x9A, 0x89,
      0x7D, 0xFF, 0x60, 0x61, 0x04, 0x5F, 0x5F, 0x7E },

    // D. Internal Mode F
    // Mode 5A / VESA Mode 106 1280x1024x4
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xAA, 0x1A,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },

    // E. Internal Mode 10
    // Mode 6B / VESA Mode 107 1280x1024x8
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xA9, 0x19,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },

    // F. Mode 45h/46h / VESA Mode 145,146
    // 1600x1200x16
    { 0xC8, 0x4A, 0x10, 0x2B, 0x01, 0x03, 0xC7, 0xC7, 0x87, 0xD1, 0x09,
      0xE0, 0x10, 0x40, 0xB1, 0x04, 0xAF, 0xAF, 0xE1 },

    // JJV - Start
    // 10. Mode ?
    // 1880x1440x8
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },

    // 11. Mode ?
    // 1880x1440x16
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },

    // 12. Mode ?
    // 1920x1080x8
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 13. Mode ?
    // 1920x1080x16
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 14. Mode ?
    // 1920x1080x32
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 15. Mode ?
    // 1920x1200x8
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },

    // 16. Mode ?
    // 1920x1200x16
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },

    // 17. Mode ?
    // 1920x1200x32
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
    // JJV - End

    // 18. Mode ?
    // 1600x1024x8
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 },

    // 19. Mode ?
    // 1600x1024x16
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 },

    // 1A. Mode ?
    // 1600x1024x32
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 }
    // VEL - End



};

//******************************************************************************
// NV4 specific data
//******************************************************************************
//
// NV4 Fifo/Watermark settings (100MHz/100MHz operation)
//
MODESET_FIFO DACFifoTable[] =
{
    { 440, 0x20, 0x03, 0x20, 0x04 },
    { 460, 0x21, 0x03, 0x21, 0x04 },
    { 480, 0x23, 0x03, 0x23, 0x04 },
    { 500, 0x26, 0x03, 0x26, 0x04 },
    { 520, 0x27, 0x03, 0x27, 0x04 },
    { 540, 0x27, 0x03, 0x27, 0x04 },
    { 560, 0x29, 0x03, 0x29, 0x04 },
    { 580, 0x2b, 0x03, 0x2b, 0x04 },
    { 600, 0x2e, 0x03, 0x2e, 0x04 },
    { 620, 0x31, 0x03, 0x31, 0x04 },
    { 640, 0x32, 0x02, 0x32, 0x04 },
    { 660, 0x32, 0x02, 0x32, 0x04 },
    { 680, 0x33, 0x02, 0x33, 0x04 },
    { 700, 0x34, 0x02, 0x34, 0x04 },
    { 720, 0x36, 0x02, 0x36, 0x04 },
    { 740, 0x3a, 0x01, 0x3a, 0x04 },
    {0xFFFF, 0x3f, 0x01, 0x3f, 0x04}    // max marker
};


#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv4\nv4.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV4.C
//
// Abstract:
//
//     This is code specific to NV4
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvMultiMon.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"
#include "vesadata.h"

#include "nvos.h"
#include "rm.h"

#include "nvreg.h"
#include "nvcm.h"
#include "nv_name.h"

VOID FlatPanelCrtc(U016);
VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID NV_ReadAndCopyRegistryData(PHW_DEVICE_EXTENSION,WCHAR *,U016 *);
VOID LoadDefaultRegistrySwitchValues(PHW_DEVICE_EXTENSION);
VOID BubbleSort(PHW_DEVICE_EXTENSION,PMODE_ENTRY,ULONG);
VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
VOID NV4ChipFBPowerSave(PHW_DEVICE_EXTENSION);
VOID NV4ChipFBPowerRestore(PHW_DEVICE_EXTENSION);
VOID NV4SaveInstanceMemory(PHW_DEVICE_EXTENSION);
VOID NV4RestoreInstanceMemory(PHW_DEVICE_EXTENSION);
VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension);

//******************************************************************************
// External Declarations
//******************************************************************************

extern U016 ModeSetTable[];
extern U016 DMTOverrideTable[][13];
extern CRTC_OVERRIDE crt_override[];
extern EXTREGS eregs[];
extern U016 tblClockFreq[];
extern U016 VBESetModeEx(PHW_DEVICE_EXTENSION, U016, PGTF_TIMINGS, PDMT_OVERRIDES, U016);
extern VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION pHwDevExt);
extern MODESET_FIFO DACFifoTable[];
extern unsigned int GTFTimingTable[][12];
extern U016 ValidModeTable[];
extern U016 registry_data[];

extern ULONG my_strcmp(PUCHAR ,PUCHAR);
extern VOID my_strupr(PUCHAR);
extern VOID my_strcpy(PUCHAR , PUCHAR);

extern VOID NV10ChipFBPowerSave(PHW_DEVICE_EXTENSION);
extern VOID NV10ChipFBPowerRestore(PHW_DEVICE_EXTENSION);
extern VOID NV10SaveInstanceMemory(PHW_DEVICE_EXTENSION);
extern VOID NV10RestoreInstanceMemory(PHW_DEVICE_EXTENSION);

extern ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);


//******************************************************************************
// Global tables default registry settings
// (Type, ValueName, SwitchIsPresent, Offset of structure member)
//******************************************************************************

NT_NV_REGISTRY_SWITCH_OFFSET Nv_Registry_Switch_Offset_Table[] =
    {


// STUB OUT FOR NOW SINCE \common\NVREG.H is constantly changing 
// and breaking the NT build.  When NVREG.H settles down, then
// we can put this function back in

    { IS_DWORD , "PLACEHOLDER" ,                                offsetof(NT_NV_REGISTRY, Display.DisplayType)                   }

//    //**************************************************************************
//    // Display Registry Switch Names
//    //**************************************************************************
//
//    { IS_STRING , NV4_REG_DRV_LAST_DEVICE ,                   offsetof(NT_NV_REGISTRY, Display.LastDisplayDevice[0])          },
//    { IS_STRING , NV4_REG_DRV_LAST_CRT_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastCRTMode[0])                },
//    { IS_STRING , NV4_REG_DRV_LAST_DFP_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastDFPMode[0])                },
//    { IS_STRING , NV4_REG_DRV_LAST_NTSC_MODE ,                offsetof(NT_NV_REGISTRY, Display.LastNTSCMode[0])               },
//    { IS_STRING , NV4_REG_DRV_LAST_PAL_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastPALMode[0])                },
//    { IS_STRING , NV4_REG_DRV_CRT_MODE ,                      offsetof(NT_NV_REGISTRY, Display.CRTMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_DFP_MODE ,                      offsetof(NT_NV_REGISTRY, Display.DFPMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_NTSC_MODE ,                     offsetof(NT_NV_REGISTRY, Display.NTSCMode[0])                   },
//    { IS_STRING , NV4_REG_DRV_PAL_MODE ,                      offsetof(NT_NV_REGISTRY, Display.PALMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.DefaultCRTRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.DefaultDFPRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.OptimalCRTRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.OptimalDFPRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_DISPLAY_DEVICE_TYPE ,           offsetof(NT_NV_REGISTRY, Display.DisplayDeviceType[0])          },
//    { IS_DWORD , "Display Type" ,                             offsetof(NT_NV_REGISTRY, Display.DisplayType)                   },
//    { IS_DWORD , "TV Type" ,                                  offsetof(NT_NV_REGISTRY, Display.TVType)                        },
//    { IS_DWORD  , NV4_REG_DRV_MONITOR_TIMING ,                offsetof(NT_NV_REGISTRY, Display.MonitorTiming)                 },
//    { IS_DWORD  , NV4_REG_DRV_CURSOR_ALPHA ,                  offsetof(NT_NV_REGISTRY, Display.CursorAlpha)                   },
//
//
//    //**************************************************************************
//    // DirectDraw Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , NV4_REG_VPE_ENABLE ,                         offsetof(NT_NV_REGISTRY, DirectDraw.VPENABLE)                   },
//    { IS_DWORD , NV4_REG_OVL_MODE ,                           offsetof(NT_NV_REGISTRY, DirectDraw.OverlayMode)                },
//    { IS_DWORD , NV4_REG_OVLCC_ENABLE ,                       offsetof(NT_NV_REGISTRY, DirectDraw.OverlayColorControlEnable)  },
//    { IS_DWORD , NV4_REG_OVLCC_BRIGHTNESS ,                   offsetof(NT_NV_REGISTRY, DirectDraw.OverlayBrightness)          },
//    { IS_DWORD , NV4_REG_OVLCC_CONTRAST ,                     offsetof(NT_NV_REGISTRY, DirectDraw.OverlayContrast)            },
//    { IS_DWORD , NV4_REG_OVLCC_HUE ,                          offsetof(NT_NV_REGISTRY, DirectDraw.OverlayHue)                 },
//    { IS_DWORD , NV4_REG_OVLCC_SATURATION ,                   offsetof(NT_NV_REGISTRY, DirectDraw.OverlaySaturation)          },
//    { IS_DWORD , NV4_REG_OVLCC_GAMMA ,                        offsetof(NT_NV_REGISTRY, DirectDraw.OverlayGamma)               },
//    { IS_DWORD , NV4_REG_OVLCC_SHARPNESS ,                    offsetof(NT_NV_REGISTRY, DirectDraw.OverlaySharpness)           },
//
//    //**************************************************************************
//    // Direct3d Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , D3D_REG_ANTIALIASENABLE_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.ANTIALIASENABLE)              },
//    { IS_DWORD , D3D_REG_CKCOMPATABILITYENABLE_STRING ,       offsetof(NT_NV_REGISTRY, Direct3D.COLORKEYCOMPATABILITYENABLE)  },
//    { IS_DWORD , "CONTROLTRAFFIC"                    ,        offsetof(NT_NV_REGISTRY, Direct3D.CONTROLTRAFFIC)               },
//    { IS_DWORD , D3D_REG_DIRECTMAPENABLE_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.DIRECTMAPENABLE)              },
//    { IS_DWORD , D3D_REG_FOGTABLEENABLE_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.FOGTABLENABLE)                },
//    { IS_DWORD , D3D_REG_LOGOENABLE_STRING ,                  offsetof(NT_NV_REGISTRY, Direct3D.LOGOENABLE)                   },
//    { IS_DWORD , D3D_REG_SSYNCENABLE_STRING ,                 offsetof(NT_NV_REGISTRY, Direct3D.SCENESYNCENABLE)              },
//    { IS_DWORD , D3D_REG_TILINGENABLE_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.TILINGENABLE)                 },
//    { IS_DWORD , D3D_REG_USERMIPMAPENABLE_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.USERMIPMAPENABLE)             },
//    { IS_DWORD , D3D_REG_VIDEOTEXTUREENABLE_STRING ,          offsetof(NT_NV_REGISTRY, Direct3D.VIDEOTEXTUREENABLEENABLE)     },
//    { IS_DWORD , D3D_REG_VSYNCENABLE_STRING ,                 offsetof(NT_NV_REGISTRY, Direct3D.VSYNCENABLE)                  },
//    { IS_DWORD , D3D_REG_WBUFFERENABLE_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.WENABLE)                      },
//    { IS_DWORD , D3D_REG_Z24ENABLE_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.Z24ENABLE)                    },
//    { IS_DWORD , D3D_REG_AAMETHOD_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.AAMETHOD)                     },
//    { IS_DWORD , D3D_REG_AUTOMIPMAPMETHOD_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.AUTOMIPMAPMETHOD)             },
//    { IS_DWORD , D3D_REG_CKREF_STRING ,                       offsetof(NT_NV_REGISTRY, Direct3D.CKREF)                        },
//    { IS_DWORD , "DX6ENABLE" ,                                offsetof(NT_NV_REGISTRY, Direct3D.DX6ENABLE)                    },
//    { IS_DWORD , D3D_REG_MIPMAPDITHERMODE_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.ANISOTOPIC4TAP)               },
//    { IS_DWORD , D3D_REG_PAL8TEXCONVERT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.PAL8TEXTURECONVERT)           },
//    { IS_DWORD , "PMTRIGGER" ,                                offsetof(NT_NV_REGISTRY, Direct3D.PMTRIGGER)                    },
//    { IS_DWORD , D3D_REG_TEXELALIGNMENT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.TEXELALIGNMENT)               },
//    { IS_DWORD , D3D_REG_VALIDATEZMETHOD_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.VALIDATEZMETHOD)              },
//    { IS_DWORD , D3D_REG_WFORMAT16_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.W16FORMAT)                    },
//    { IS_DWORD , D3D_REG_WFORMAT32_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.W32FORMAT)                    },
//    { IS_DWORD , D3D_REG_AGPTEXCUTOFF_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.AGPTEXCUTOFF)                 },
//    { IS_DWORD , D3D_REG_D3DCONTEXTMAX_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.D3DCONTEXTMAX)                },
//    { IS_DWORD , D3D_REG_D3DTEXTUREMAX_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.D3DTEXTUREMAX)                },
//    { IS_DWORD , D3D_REG_DMAMINPUSHCOUNT_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.DMAMINPUSHCOUNT)              },
//    { IS_DWORD , D3D_REG_LODBIAS_STRING ,                     offsetof(NT_NV_REGISTRY, Direct3D.LODBIASADJUST)                },
//    { IS_DWORD , D3D_REG_MINVIDTEXSIZE_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.MINVIDEOTEXSIZE)              },
//    { IS_DWORD , D3D_REG_AUTOMIPMAPLEVELS_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.MIPMAPLEVELS)                 },
//    { IS_DWORD , D3D_REG_PERFSTRATEGY_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.PERFSTRATEGY)                 },
//    { IS_DWORD , D3D_REG_PRERENDERLIMIT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.NOVSYNCPREREDNERLIMIT)        },
//    { IS_DWORD , D3D_REG_PUSHBUFFERSIZEMAX_STRING ,           offsetof(NT_NV_REGISTRY, Direct3D.DMAPUSHBUFFERSIZEMAX)         },
//    { IS_DWORD , D3D_REG_TEXHEAPSIZEMAX_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.TEXHEAP)                      },
//    { IS_DWORD , D3D_REG_WSCALE16_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.WSCALE16)                     },
//    { IS_DWORD , D3D_REG_WSCALE24_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.WSCALE24)                     },
//
//    //**************************************************************************
//    // System Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , "Reserved1" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved2" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved3" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved4" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved5" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved6" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved7" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved8" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved9" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved10" ,                               offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved11" ,                               offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },

    };
    

//******************************************************************************
// Global tables for registry mode table data
//******************************************************************************

U016 NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5M64_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5ULTRA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11M_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15BR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_1_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_2_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_3_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];


//******************************************************************************
// Global tables for Monitor restriction mode list data
//******************************************************************************
U016 MonitorRestrictionModeList0_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];  // For head0
U016 MonitorRestrictionModeList1_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];  // For head1

// global device extension pointer - We need it to distinguish between NV3/NV4..
extern PHW_DEVICE_EXTENSION HwDeviceExtension;

extern VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );


extern VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

__inline static size_t cbStrLenW(
    IN UNALIGNED const WCHAR *wsz)
{
    size_t cbWsz = 0;

    for(; *wsz; wsz++)
        cbWsz += sizeof( WCHAR);

    return( cbWsz + sizeof( WCHAR));
}

#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
// Tables used by DPMS_SetPowerState (NT5 only)
//******************************************************************************

UCHAR tblDPMSStates[4]      = { 0, 2, 1, 4 }                    ;   //on, stdby, suspend, off
UCHAR tblDPMSSettings[4]    = { 0x000, 0x080, 0x040, 0x0C0 }    ;

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV_ATCOff(PHW_DEVICE_EXTENSION);
VOID NV_ATCOn(PHW_DEVICE_EXTENSION);
VOID NV_ResetATCFlipFlop(PHW_DEVICE_EXTENSION);

#endif


//******************************************************************************
// Use a slightly different mode timing table for NV4
//******************************************************************************


//
// CRTC Timings modes for 60Hz, 70Hz, 72Hz, 75Hz, 85Hz, 100Hz, 120Hz
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use floating point).
//
// Horizontal Total, Start, End
// Vertical Total, Start, End
// DotClock, Refresh
// HSync polarity
// VSync polarity
//
// Max out all the modes above our pixclk (~250).
//
U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10] =
{
    //0:
    // Settings for 1600x1200:
    2160,1704,1880,1242,1201,1204,16096,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1249,1201,1204,19025,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1251,1201,1204,19600,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1253,1201,1204,20599,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //1:
    // Settings for 1280x1024:
    1712,1360,1496,1060,1025,1028,10888,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1066,1025,1028,12894,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1067,1025,1028,13275,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1069,1025,1028,13854,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1744,1376,1512,1075,1025,1028,15936,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1760,1376,1520,1085,1025,1028,19096,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //2:
    // Settings for 1152x864:
    1520,1216,1336,895,865,868,8162 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,900,865,868,9677 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,901,865,868,9964 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,902,865,868,10499,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,907,865,868,11965,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1568,1232,1360,915,865,868,14347,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1584,1240,1368,926,865,868,17601,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //3:
    // Settings for 1024x768:
    1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,800,769,772,7616 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,801,769,772,7843 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,802,769,772,8180 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1376,1088,1200,807,769,772,9439 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //1392,1096,1208,814,769,772,11331,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1392,1096,1208,814,769,772,11370,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,823,769,772,13905,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //4:
    // Settings for 960x720:
    1248,1008,1104,746,721,724,5586 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,750,721,724,6636 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,751,721,724,6835 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,752,721,724,7219 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,756,721,724,8225 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1296,1024,1128,763,721,724,9888 ,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1312,1032,1136,772,721,724,12154,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //5:
    // Settings for 800x600:
    1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,625,601,604,4550,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,626,601,604,4687,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,627,601,604,4891,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1056,840,928,630,601,604,5655,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1072,848,936,636,601,604,6818,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,643,601,604,8395,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //6:
    // Settings for 640x480:
    800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,500,481,484,2856,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,501,481,484,2943,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,502,481,484,3072,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,505,481,484,3571,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,509,481,484,4316,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,515,481,484,5241,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //7:
    // Settings for 640x400:
    //There is no 60Hz timings for 640x400 as defined by IBM VGA
    //784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2508,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,421,401,404,2920,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,424,401,404,3528,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //8:
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    672,536,592,795,769,772,3205,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    672,536,592,800,769,772,3763,7000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,801,769,772,3968,7200,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,802,769,772,4138,7500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,807,769,772,4719,8500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,814,769,772,5600,10000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,

    //9:
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    624,504,552,746,721,724,2793,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,750,721,724,3360,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,751,721,724,3461,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,752,721,724,3610,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,756,721,724,4113,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,763,721,724,5005,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //10:
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    512,416,456,622,601,604,1911,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,625,601,604,2310,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,626,601,604,2380,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,627,601,604,2483,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,630,601,604,2827,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,636,601,604,3358,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //11:
    // Settings for 320x400:
    //
    // !!! This mode should never be set !!! since DDraw doesn't support it yet
    //
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //12:
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    400,328,360,497,481,484,1193,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,500,481,484,1400,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,501,481,484,1501,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,502,481,484,1566,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,505,481,484,1786,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,509,481,484,2117,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //13:
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //14:
    // Settings for 1920x1200:
    2592,2048,2256,1242,1201,1204,19316,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1249,1201,1204,22802,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1251,1201,1204,23635,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1253,1201,1204,24659,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //15:
    // Settings for 1920x1080:
    2576,2040,2248,1118,1081,1084,17280,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1124,1081,1084,20520,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1126,1081,1084,21144,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1128,1081,1084,22064,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //16:
    // Settings for 1800x1440:
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

//17:
    // Settings for 1600x1024:
    2144,1704,1872,1060,1025,1028,13636,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2160,1704,1880,1066,1025,1028,16118,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2160,1704,1880,1067,1025,1028,16594,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

// An OEM Customer wants a SPECIFIC timing...which is NOT GTF or DMT compliant ...so we'll accomodate them...
// (They're using a widescreen Sony monitor)

// Standard GTF
//    2176,1712,1888,1070,1025,1028,17695,7600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

// OEM requested
    2096,1632,1792,1070,1027,1030,17045,7600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,


    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,


};

//******************************************************************************
// Forward Function Declarations
//******************************************************************************
VP_STATUS
NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

BOOLEAN
NVGetNVInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


VOID NV4_UpdateArbitrationSettings(PHW_DEVICE_EXTENSION);

BOOL NV4SetMode(PHW_DEVICE_EXTENSION,PMODE_ENTRY);
VOID NV_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NV4_InitPalette(PHW_DEVICE_EXTENSION);
ULONG NVMapMemoryRanges(PVOID HwDeviceExtension);
ULONG NVMapFrameBuffer(PVOID HwDeviceExtension);
//BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PULONG);
VOID NV4EnableCursor(PHW_DEVICE_EXTENSION);
ULONG NVMapVgaPaletteRegisters(PHW_DEVICE_EXTENSION);
VOID NV4_ProgramTV( U008 );

//******************************************************************************
//
//  Function: NVSetMode()
//
//  Routine Description:
//
//      This routine sets the adapter into the requested mode.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      Mode - Pointer to the structure containing the information about the
//          font to be set.
//
//      ModeSize - Length of the input buffer supplied by the user.
//
//  Return Value:
//
//      ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
//          for the input data.
//
//      ERROR_INVALID_PARAMETER if the mode number is invalid.
//
//      NO_ERROR if the operation completed successfully.
//
//******************************************************************************

VP_STATUS NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )


    {

    PMODE_ENTRY pRequestedMode;             // NV specific
    VP_STATUS status;
    USHORT usDataSet, usTemp, usDataClr;
    PUSHORT  pBios = NULL;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    ULONG OutData;
    LONG x_inc,y_inc;
    ULONG x,y;
    ULONG i;
    ULONG Data;
    PMODE_ENTRY ModeEntry;

    PHWINFO NVInfo;

    VideoDebugPrint((1, "NVSetMode - entry\n"));

    //**************************************************************************
    // Check if the size of the data in the input buffer is large enough.
    //**************************************************************************

    if (ModeSize < sizeof(VIDEO_MODE))
    {

        VideoDebugPrint((1, "SetMode - ERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //**************************************************************************
    // Init pointer to Mode data (NV3 or NV4)
    //**************************************************************************

    ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);


    //**************************************************************************
    // Check to see if we are requesting a valid mode
    //**************************************************************************

    if ( (Mode->RequestedMode >= HwDeviceExtension->NumRegistryModes)   ||
         (!ModeEntry[Mode->RequestedMode].ValidMode)  )
        {

        VideoDebugPrint((1, "SetMode - ERROR_INVALID_PARAMETER\n"));
        return ERROR_INVALID_PARAMETER;

        }


    //**************************************************************************
    // Our driver maps video memory first, and then sets the mode.
    // However, the Dumb Frame Buffer drivers sets the mode FIRST, and
    // then maps the video memory.  So first check to see if we've
    // got a valid frame buffer ptr, before we clear memory.
    //**************************************************************************

    if (HwDeviceExtension->FrameBufferPtr !=NULL)
        {
        //**********************************************************************
        // Clear the framebuffer prior to setting the video mode.
        // This is for aesthetics only.
        // Back up 1Mb to make absolutely sure we don't walk over any instance memory
        //**********************************************************************
        for (i = 0; i < ( (HwDeviceExtension->AdapterMemorySize-0x100000) >> 2); i++)
            {
            ((PULONG) HwDeviceExtension->FrameBufferPtr)[i] = 0;
            }
        }

    //**************************************************************************
    // Get pointer to the requested mode
    //**************************************************************************
    if(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_VIRTUAL_DESKTOP)
    {
        PMODE_ENTRY pDesktopMode; 
        ULONG ulDac;
        ULONG ulWidth;
        ULONG ulHeight;
        ULONG ulRefresh;
        ULONG ulPixelDepth;

        pDesktopMode = &(ModeEntry[Mode->RequestedMode]);

        // Display driver is setting mode through class for both DAC.
        // Miniport driver set to the primary dac by default;
        ulDac = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[0];
        ulWidth = HwDeviceExtension->DeskTopInfo.ulDisplayWidth[ulDac];
        ulHeight = HwDeviceExtension->DeskTopInfo.ulDisplayHeight[ulDac];
        ulRefresh = HwDeviceExtension->DeskTopInfo.ulDisplayRefresh[ulDac];
        ulPixelDepth = HwDeviceExtension->DeskTopInfo.ulDisplayPixelDepth[ulDac];

        for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)   
        {
            if(!ModeEntry[i].ValidMode)
                continue;

            if( (ModeEntry[i].Depth == ulPixelDepth) &&
                (ModeEntry[i].RefreshRate == ulRefresh) &&
                (ModeEntry[i].Width == ulWidth) &&
                (ModeEntry[i].Height == ulHeight) )
            {
                Mode->RequestedMode = i;
                break;
            }
        }
        if(i == HwDeviceExtension->NumRegistryModes)
            return (ERROR_INVALID_PARAMETER);
    }

    pRequestedMode = &(ModeEntry[Mode->RequestedMode]);

    //**************************************************************************
    // Initialize the Graphics Mode and Engine.
    //**************************************************************************

    if (NV4SetMode(HwDeviceExtension, pRequestedMode) == FALSE)
        return(ERROR_NOT_ENOUGH_MEMORY);

    //**************************************************************************
    // Store the new mode value.
    //**************************************************************************

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    VideoDebugPrint((1, "NVSetMode - exit\n"));
    return NO_ERROR;

    } //end NVSetMode()


//******************************************************************************
//
//  Function:   NVGetNVInfo()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN NVGetNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    PHWINFO NVInfo;
    ULONG refresh;
    ULONG i,j;
    ULONG Size;
    BOOLEAN status=TRUE;
    PWSTR   pwszChip, pwszAdapterString;
    ULONG   cbChip, cbAdapterString;
    ULONG   FullChipId,ChipId;
    U016   rc;

    //**************************************************************************
    // Get ptr to NVInfo structure and clear it out.
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    VideoPortZeroMemory(NVInfo, sizeof(HWINFO));


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // WIN2K:   We need to determine what chip we're running on for Win2K!
    //          This was NOT obtained in NVIsPresent, so we need to
    //          determine it HERE, because we now have access to the
    //          the hardware registers !!
    //**************************************************************************

    ChipId = REG_RD32(NV_PBUS_PCI_NV_0);
    ChipId >>= 16;                              // Get top 16 bits (bits 16 thru 31)
    ChipId &= 0xffff;                           // Just look at 16 bits

    FullChipId = ChipId;                        // Save complete id
    ChipId &= 0xfffc;                           // Ignore Sub Revisions 1 thru 3

    switch (ChipId)
        {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:

            //******************************************************************
            // NV4 (original TNT)
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV4_DEVICE_NV4_ID;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:

            //******************************************************************
            // NV5 (TNT2)   ID = 28
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV5_DEVICE_NV5_ID;

            //******************************************************************
            // NV5 (TNT2 ULTRA)  ID = 29
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1)
                HwDeviceExtension->ulChipID     = NV5ULTRA_DEVICE_NV5ULTRA_ID;


            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0:

            //******************************************************************
            // VANTA (ID = 2C)
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV5VANTA_DEVICE_NV5VANTA_ID;

            //******************************************************************
            // (TNT2 Model 64) (ID = 2D)
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1)
                HwDeviceExtension->ulChipID     = NV5MODEL64_DEVICE_NV5MODEL64_ID;

            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:

            //******************************************************************
            // NV0A
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV0A_DEVICE_NV0A_ID;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:

            //******************************************************************
            // NV10
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV10_DEVICE_NV10_ID;

            //******************************************************************
            // NV10DDR (NV10 DDR)  ID = 101
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1)
                HwDeviceExtension->ulChipID     = NV10DDR_DEVICE_NV10DDR_ID;

            //******************************************************************
            // NV10GL (NV10 GL)  ID = 103
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3)
                HwDeviceExtension->ulChipID     = NV10GL_DEVICE_NV10GL_ID;


            break;


        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID0:

            //******************************************************************
            // NV11 ID = 110
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV11_DEVICE_NV11_ID;

            //******************************************************************
            // NV11DDR (NV11 DDR)  ID = 111
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID1)
                HwDeviceExtension->ulChipID     = NV11DDR_DEVICE_NV11DDR_ID;

            //******************************************************************
            // NV11M (NV11 Mobile)  ID = 112
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID2)
                HwDeviceExtension->ulChipID     = NV11M_DEVICE_NV11M_ID;

            //******************************************************************
            // NV11GL (NV11 GL)  ID = 113
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID3)
                HwDeviceExtension->ulChipID     = NV11GL_DEVICE_NV11GL_ID;

            break;


        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:

            //******************************************************************
            // NV15 ID = 150
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV15_DEVICE_NV15_ID;

            //******************************************************************
            // NV15DDR (NV15 DDR)  ID = 151
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1)
                HwDeviceExtension->ulChipID     = NV15DDR_DEVICE_NV15DDR_ID;

            //******************************************************************
            // NV15BR (NV15 BR)  ID = 152
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2)
                HwDeviceExtension->ulChipID     = NV15BR_DEVICE_NV15BR_ID;


            //******************************************************************
            // NV15GL (NV15 GL)  ID = 153
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3)
                HwDeviceExtension->ulChipID     = NV15GL_DEVICE_NV15GL_ID;


            break;

        
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID0:

            //******************************************************************
            // NV20 ID = 200
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_ID;

            //******************************************************************
            // NV20 ID = 201
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID1)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_1_ID;

            //******************************************************************
            // NV20 ID = 202
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID2)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_2_ID;

            //******************************************************************
            // NV20 ID = 203
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID3)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_3_ID;

            break;


        default:

            //******************************************************************
            // Unsupported Chip
            //******************************************************************
            status=FALSE;
            return(status);
        }
#endif


    //**************************************************************************
    // Now that we're using a Resource Manager, the majority of the
    // NVInfo structure fields are no longer used (These values were used
    // in the older 1.00 driver).  Since they're no longer used, just
    // zero them out.
    //**************************************************************************

    NVInfo->Pram.CurrentSize        = 0;
    NVInfo->Pram.HashTableAddr      = 0;
    NVInfo->Pram.HashDepth          = 0;
    NVInfo->Pram.FifoRunoutAddr     = 0;
    NVInfo->Pram.RunOutMask         = 0;
    NVInfo->Pram.FifoContextAddr    = 0;
    NVInfo->Pram.FreeInstSize       = 0;
    NVInfo->Pram.FreeInstBase       = 0;
    NVInfo->Dac.CursorImageInstance = 0;


    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID))
    {
        switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_CFG,_BUS))
        {
            case NV_PFB_CFG_BUS_64:
                NVInfo->Dac.InputWidth = 64;
                break;
            case NV_PFB_CFG_BUS_128:
                NVInfo->Dac.InputWidth = 128;
                break;
            case NV_PFB_CFG_BUS_32:
                NVInfo->Dac.InputWidth = 32;
                break;
        }
    }
    else if ((HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
    {
        NVInfo->Dac.InputWidth = 128;
    }
    else
    {
        switch (PFB_REG_RD_DRF(PFB_Base, _PFB, _BOOT_0, _RAM_WIDTH_128))
        {
            case NV_PFB_BOOT_0_RAM_WIDTH_128_OFF:
                NVInfo->Dac.InputWidth = 64;
                break;
            case NV_PFB_BOOT_0_RAM_WIDTH_128_ON:
                NVInfo->Dac.InputWidth = 128;
                break;
        }
    }

    //**************************************************************************
    // Get Chip revision and implementation
    //**************************************************************************

//    NVInfo->Chip.Implementation = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_IMPLEMENTATION);
//    NVInfo->Chip.Revision = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_FIB_REVISION);
//    NVInfo->Chip.Architecture = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_ARCHITECTURE);
//    NVInfo->Chip.Manufacturer = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_MANUFACTURER);

    //**************************************************************************
    // Get memory type
    //**************************************************************************

//    NVInfo->Framebuffer.RamType = PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV,_BOOT_0,_STRAP_RAM_TYPE) ==
//                            NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO ? BUFFER_DRAM : BUFFER_VRAM;

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)         ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)         ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)       ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)         ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)     ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)         ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))

    {
        NVInfo->Framebuffer.RamSize = PFB_REG_RD32(PFB_Base,NV_PFB_CSTATUS);
        NVInfo->Framebuffer.RamSizeMb = NVInfo->Framebuffer.RamSize >> 20;
    }
    else
    {
        //**************************************************************************
        // Get amount of VRAM
        // NOTE: These values are DIFFERENT from those defined in NV3 !!
        //**************************************************************************

        switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0, _RAM_AMOUNT))
            {
            case NV_PFB_BOOT_0_RAM_AMOUNT_32MB:
                NVInfo->Framebuffer.RamSizeMb = 32;
                NVInfo->Framebuffer.RamSize   = 0x02000000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
                NVInfo->Framebuffer.RamSizeMb = 4;
                NVInfo->Framebuffer.RamSize   = 0x00400000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
                NVInfo->Framebuffer.RamSizeMb = 8;
                NVInfo->Framebuffer.RamSize   = 0x00800000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
                NVInfo->Framebuffer.RamSizeMb = 16;
                NVInfo->Framebuffer.RamSize   = 0x01000000;
                break;
            default:
                //******************************************************************
                // Invalid memory configuration
                //******************************************************************
                status=FALSE;
                return(status);
            }


        //**************************************************************************
        // Check for UMA usage
        //
        // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
        // bit fields to zero.
        //**************************************************************************

        if (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
            switch (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA_SIZE))
            {
                case NV_PFB_BOOT_0_UMA_SIZE_2M:
                    NVInfo->Framebuffer.RamSizeMb = 2;
                    NVInfo->Framebuffer.RamSize   = 0x00200000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_4M:
                    NVInfo->Framebuffer.RamSizeMb = 4;
                    NVInfo->Framebuffer.RamSize   = 0x00400000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_6M:
                    NVInfo->Framebuffer.RamSizeMb = 6;
                    NVInfo->Framebuffer.RamSize   = 0x00600000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_8M:
                    NVInfo->Framebuffer.RamSizeMb = 8;
                    NVInfo->Framebuffer.RamSize   = 0x00800000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_10M:
                    NVInfo->Framebuffer.RamSizeMb = 10;
                    NVInfo->Framebuffer.RamSize   = 0x00A00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_12M:
                    NVInfo->Framebuffer.RamSizeMb = 12;
                    NVInfo->Framebuffer.RamSize   = 0x00C00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_14M:
                    NVInfo->Framebuffer.RamSizeMb = 14;
                    NVInfo->Framebuffer.RamSize   = 0x00E00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_16M:
                    NVInfo->Framebuffer.RamSizeMb = 16;
                    NVInfo->Framebuffer.RamSize   = 0x01000000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_18M:
                    NVInfo->Framebuffer.RamSizeMb = 18;
                    NVInfo->Framebuffer.RamSize   = 0x01200000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_20M:
                    NVInfo->Framebuffer.RamSizeMb = 20;
                    NVInfo->Framebuffer.RamSize   = 0x01400000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_22M:
                    NVInfo->Framebuffer.RamSizeMb = 22;
                    NVInfo->Framebuffer.RamSize   = 0x01600000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_24M:
                    NVInfo->Framebuffer.RamSizeMb = 24;
                    NVInfo->Framebuffer.RamSize   = 0x01800000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_26M:
                    NVInfo->Framebuffer.RamSizeMb = 26;
                    NVInfo->Framebuffer.RamSize   = 0x01A00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_28M:
                    NVInfo->Framebuffer.RamSizeMb = 28;
                    NVInfo->Framebuffer.RamSize   = 0x01C00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_30M:
                    NVInfo->Framebuffer.RamSizeMb = 30;
                    NVInfo->Framebuffer.RamSize   = 0x01E00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_32M:
                    NVInfo->Framebuffer.RamSizeMb = 32;
                    NVInfo->Framebuffer.RamSize   = 0x02000000;
                    break;
                default:
                    //******************************************************************
                    // Invalid memory configuration
                    //******************************************************************
                    status=FALSE;
                    return(status);
            }
    }

    pwszChip = L"NVxx";
    cbChip = sizeof(L"NVxx");
    pwszAdapterString = L"NVxx";
    cbAdapterString = sizeof(L"NVxx");

    for(i = 0; i < sizeof(sChipInfo) / sizeof(CHIP_INFO); i++)
    {
        if (HwDeviceExtension->ulChipID == sChipInfo[i].ulDevID)
        {
            pwszChip = sChipInfo[i].pwszChip;
            cbChip = cbStrLenW(pwszChip);
            pwszAdapterString = sChipInfo[i].pwszAdapterString; 
            cbAdapterString = cbStrLenW(pwszAdapterString);
            break;
        }
    }

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                               L"HardwareInformation.DacType",
                               L"Integrated RAMDAC",
                               sizeof(L"Integrated RAMDAC") );


    //**************************************************************************
    // Default to 640x480x16x1 framebuffer with VGA timing
    //**************************************************************************

    NVInfo->Framebuffer.DpmLevel          = 0;
    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.Depth             = 16;
    NVInfo->Framebuffer.RefreshRate       = 60;
    NVInfo->Framebuffer.Count             = 1;
    NVInfo->Framebuffer.ActiveCount       = 1;
    NVInfo->Framebuffer.ActiveMask        = 1;
    NVInfo->Framebuffer.Current           = 0;
    NVInfo->Framebuffer.FlipUsageCount    = 0;
    NVInfo->Framebuffer.FlipTo            = 0;
    NVInfo->Framebuffer.FlipFrom          = 0;
    NVInfo->Framebuffer.UpdateFlags       = 0;
    NVInfo->Framebuffer.HorizFrontPorch   = 0;
    NVInfo->Framebuffer.HorizSyncWidth    = 0;
    NVInfo->Framebuffer.HorizBackPorch    = 0;
    NVInfo->Framebuffer.HorizDisplayWidth = 0;
    NVInfo->Framebuffer.VertFrontPorch    = 0;
    NVInfo->Framebuffer.VertSyncWidth     = 0;
    NVInfo->Framebuffer.VertBackPorch     = 0;
    NVInfo->Framebuffer.VertDisplayWidth  = 0;
    NVInfo->Framebuffer.HSyncPolarity     = 0;
    NVInfo->Framebuffer.VSyncPolarity     = 0;
    NVInfo->Framebuffer.CSync             = 0;
    NVInfo->Framebuffer.ConfigPageHeight  = 0;
    NVInfo->Pram.CurrentSize              = 0;
    NVInfo->Pram.AvailableSize[0]         =  NV_PRAM_DEVICE_SIZE_5_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[1]         =  NV_PRAM_DEVICE_SIZE_9_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[2]         =  NV_PRAM_DEVICE_SIZE_17_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[3]         =  NV_PRAM_DEVICE_SIZE_33_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;

    //**************************************************************************
    // Default Refresh Rate
    //**************************************************************************

    NVInfo->Framebuffer.RefreshRate = 60;
    NVInfo->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    NVInfo->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;

    //**************************************************************************
    // Default resolution
    //**************************************************************************

    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.HorizDisplayWidth = 640;
    NVInfo->Framebuffer.VertDisplayWidth  = 480;
    NVInfo->Framebuffer.Depth             = 16;

    //**************************************************************************
    // Determine refresh rate
    //**************************************************************************

    if (NVInfo->Framebuffer.RefreshRate < 70)
       refresh = 0;
    if (NVInfo->Framebuffer.RefreshRate < 72)
        refresh = 1;
    else if (NVInfo->Framebuffer.RefreshRate < 75)
        refresh = 2;
    else if (NVInfo->Framebuffer.RefreshRate < 85)
        refresh = 3;
    else if (NVInfo->Framebuffer.RefreshRate < 100)
        refresh = 4;
    else if (NVInfo->Framebuffer.RefreshRate < 120)
        refresh = 5;
    else
        refresh = 6;

    //**************************************************************************
    // Update the DAC flags and types
    //**************************************************************************

    NVInfo->Dac.UpdateFlags = 0;
    NVInfo->Dac.FinishFlags = 0;

    //**************************************************************************
    // Initialize the cursor data (transparent)
    //**************************************************************************

//    NVInfo->Dac.CursorType = DAC_CURSOR_TWO_COLOR_XOR;
    NVInfo->Dac.CursorEmulation = FALSE;
    NVInfo->Dac.CursorExclude= FALSE;
    NVInfo->Dac.CursorColor1 = 0x00000000;
    NVInfo->Dac.CursorColor2 = 0x00ffffff;
    NVInfo->Dac.CursorColor3 = 0x00000000;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[0][i] = 0x00;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[1][i] = 0xff;

    for (i=0;i<32;i++)
        for (j=0;j<32;j++)
            NVInfo->Dac.CursorColorImage[i][j]= 0x00000000;

    //**************************************************************************
    // Initialize palette to gray scale
    //**************************************************************************

    for (i=0;i<256;i++)
        NVInfo->Dac.Palette[i] = (i<<16) | (i<<8) | i;

    //**************************************************************************
    // Initialize Power Management state
    //**************************************************************************

    NVInfo->Dac.DpmLevel = 0;

    //**************************************************************************
    // Initialize Video Clock
    //**************************************************************************

    NVInfo->Dac.VClk= 0;

    //**************************************************************************
    // return success
    //**************************************************************************

    return(status);
    }



//******************************************************************************
//
//  Function:   NV4SetMode
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************

BOOL NV4SetMode(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        PMODE_ENTRY RequestedMode  )
    {
    PHWINFO NVInfo;
    PUCHAR crtc;
    ULONG OffScreenMemory;
    ULONG OnScreenMemory;
    UCHAR  mode, bitdepth, doubled;
    USHORT vesaMode;
    VIDEO_REQUEST_PACKET requestPacket;
    STATUS_BLOCK statusblock;
    PDMT_OVERRIDES pDMTOverrides;
    U016   UseDMTFlag;
    ULONG CurrentValue;
    BOOLEAN bRefreshRateDefault;
    MODE_TIMING_VALUES timingInfo;
    GTF_TIMINGS vbe_timings;
    unsigned int vesaStatus;
    ULONG result;
    
    //**************************************************************************
    //    Current Issues with New Style Modeset Code:
    //
    //    1) NT 3.51 will no longer work with new style modeset code, because
    //       RmSetMode calls RmUnloadState and RmLoadState.
    //       (NT 3.51 does not work with a Resource Manager to my knowledge).
    //
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    NVInfo->Framebuffer.HorizDisplayWidth   = RequestedMode->Width;
    NVInfo->Framebuffer.VertDisplayWidth    = RequestedMode->Height;
    NVInfo->Framebuffer.Depth               = RequestedMode->Depth;
    NVInfo->Framebuffer.RefreshRate         = RequestedMode->RefreshRate;

    if ( !(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
    {

        // Added to support GTF or DMT method selection under WinNT4 and Win2K
        if (HwDeviceExtension->bUseGTF)
        {

            //**********************************************************************
            // Here we use GTF timings as requested by the user
            //**********************************************************************

            vesaStatus = vesaGetGTFTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                           NVInfo->Framebuffer.VertDisplayWidth,    
                                           NVInfo->Framebuffer.RefreshRate,
                                           &timingInfo);

            if (vesaStatus)
            {
                // Could not find a GTF timing for this mode
                return(FALSE);
            }

        }
        else
        {

            //**************************************************************************
            // Here we use DMT timings  (instead of GTF timings)
            //**************************************************************************

            vesaStatus = vesaGetDMTTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                           NVInfo->Framebuffer.VertDisplayWidth,    
                                           NVInfo->Framebuffer.RefreshRate,
                                           &timingInfo);

            //**************************************************************************
            // If DMT timings don't exist for this mode, use the GTF timings
            //**************************************************************************

            if (vesaStatus)
            {

                //**********************************************************************
                // Set mode using GTF timings if DMT timings don't exist
                //**********************************************************************

                vesaStatus = vesaGetGTFTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                               NVInfo->Framebuffer.VertDisplayWidth,    
                                               NVInfo->Framebuffer.RefreshRate,
                                               &timingInfo);

                if (vesaStatus)
                {
                    // Could not find a DMT / GTF timing for this mode
                    return(FALSE);
                }
            }
        }
    }




    //**************************************************************************
    // Still need to make sure the 'global' hwdevice variable is in sync.
    // (We need to eventually get rid of this global hwdev variable !!!)
    //**************************************************************************

    SetGlobalHwDev(HwDeviceExtension);

    //**************************************************************************
    // Unlock the registers
    //**************************************************************************

    NV_OEMEnableExtensions(HwDeviceExtension);          

    //**************************************************************************
    // Determine which modes are 'doubled'
    //**************************************************************************

    doubled = 0;  

    if ((NVInfo->Framebuffer.VertDisplayWidth == 384 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 360 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 300 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 240 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 200 ))   
        {
        doubled = 1;
        }
        
    if( !(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
    {
        //**************************************************************************
        // Pass the timings to the RM and let it set the mode (via DacProgramCRTC)
        // as well as fixup the modeset arbitration.
        //**************************************************************************


        if (RmSetMode(HwDeviceExtension->DeviceReference,
                  timingInfo.HorizontalVisible,
                  timingInfo.HorizontalBlankStart,
                  timingInfo.HorizontalRetraceStart,
                  timingInfo.HorizontalRetraceEnd,
                  timingInfo.HorizontalBlankEnd,
                  timingInfo.HorizontalTotal,
                  timingInfo.VerticalVisible,
                  timingInfo.VerticalBlankStart,
                  timingInfo.VerticalRetraceStart,
                  timingInfo.VerticalRetraceEnd,
                  timingInfo.VerticalBlankEnd,
                  timingInfo.VerticalTotal,
                  NVInfo->Framebuffer.Depth,
                  NVInfo->Framebuffer.RefreshRate,
                  NVInfo->Framebuffer.HorizDisplayWidth ,
                  NVInfo->Framebuffer.VertDisplayWidth,  
                  timingInfo.PixelClock,
                  timingInfo.HSyncpolarity,
                  timingInfo.VSyncpolarity,
                  doubled) != TRUE)
        {
        return(FALSE);
        }
    }
    //**************************************************************************
    // Save these values off so when we come back from hibernation,
    // we'll know what values to restore
    //**************************************************************************

    HwDeviceExtension->LastWidth        = NVInfo->Framebuffer.HorizDisplayWidth; 
    HwDeviceExtension->LastHeight       = NVInfo->Framebuffer.VertDisplayWidth;
    HwDeviceExtension->LastDepth        = NVInfo->Framebuffer.Depth;
    HwDeviceExtension->LastRefreshRate  = NVInfo->Framebuffer.RefreshRate;


    //**************************************************************************
    // Ask the RM if overlay is allowed at this resolution
    //**************************************************************************

    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_OVERLAY_ALLOWED,&result) ;

    if (result)
        HwDeviceExtension->bHwVidOvl = TRUE;
    else        
        HwDeviceExtension->bHwVidOvl = FALSE;

    //**************************************************************************
    // TV cursor adjust code
    //**************************************************************************

    if (HwDeviceExtension->TvIsPresent)
        {
        U008  ht,hrs,hbs,tvhbe,tvhbs;

        //**********************************************************************
        // Unlock the registers
        //**********************************************************************

        NV_OEMEnableExtensions(HwDeviceExtension);          

        //**********************************************************************
        // Calculate cursor min and max values (in pixels) for TV.
        //**********************************************************************

        CRTC_RD(NV_CIO_CR_HDT_INDEX, ht);   // h total
        CRTC_RD(NV_CIO_CR_HRS_INDEX, hrs);  // h retrace start
        CRTC_RD(NV_CIO_CR_HBS_INDEX, hbs);  // h blank start
        tvhbe = (U008) PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_TV_HBLANK_END);
        tvhbs = (U008) PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_TV_HBLANK_START);

        NVInfo->Dac.TVCursorMin = (ht+5-(hrs-2))*8 - tvhbe;
        NVInfo->Dac.TVCursorMax = (ht+5-((hrs-2)+hbs+1))*8 - tvhbs;
//        NVInfo->Dac.TVCursorMin += 20; // What should these values actually be?
//        NVInfo->Dac.TVCursorMax += 20; // What should these values actually be?
        NVInfo->Dac.TVCursorMin = 0;     // Set to zero for now   
        NVInfo->Dac.TVCursorMax = 0;     // Set to zero for now


        }
        

    //**************************************************************************
    // WHQL fixup code:
    //
    // The following code should probably be removed, and is leftover
    // code from the OLD style modeset code.  But we NEED to check
    // that the NEW style modeset code (ie RmSetMode) does indeed set
    // the following registers correctly.  Otherwise, this could cause
    // various WHQL tests to fail.  So for now, leave this code INTACT!
    //**************************************************************************

    {
    //**************************************************************************
    // Specify 5:5:5 or 5:6:5 format
    // ModeSet code currently defaults to 5:6:5 (in OEMSetRegs)
    //**************************************************************************

    if (RequestedMode->Depth == 16)
        {
        //**********************************************************************
        // Currently the display driver only handles 5:5:5 format...
        // So for now, just specify 5:5:5 always until we add the 5:6:5 specific modes
        //**********************************************************************
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,
            (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _16)) |
               (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)));
        }

    else if (RequestedMode->Depth == 8)
        {
        // if 8 bit mode, make sure we're using an 8bit palette
        //if (pDev.Framebuffer.Depth == 8)
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,
                (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)) );
        }

    //**************************************************************************
    // Make sure Bit 20 is always set for 32bpp modes
    //**************************************************************************

    if (RequestedMode->Depth == 32)
        {
        CurrentValue = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_GENERAL_CONTROL);
        CurrentValue |= (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)) ;
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,CurrentValue);
        }


    //**************************************************************************
    // Make sure to turn off 2D dithering.  Otherwise, HCT tests will fail!
    //**************************************************************************

    CurrentValue = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_DEBUG_3);

    //**************************************************************************
    // Mask off the 2d dither bits
    //**************************************************************************

    CurrentValue &= (~ ( (DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_2D, _ENABLED )) |
                         (DRF_DEF(_PGRAPH, _DEBUG_3, _PREDITHER_2D, _ENABLED )) ));


    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_3,CurrentValue);

    }
    

    //**************************************************************************
    // If flat panel is present, make sure to clear out the following registers
    // because video bios's after 09/02/99 may touch these registers.
    // These registers should probably get cleared in dacSetFlatPanelMode in the RM
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {
        REG_WR32(NV_PRAMDAC_FP_DEBUG_1, 0x00000000);
        REG_WR32(NV_PRAMDAC_FP_DEBUG_2, 0x00000000);
        }


    //**************************************************************************
    // Another ALI 1541 workaround fix
    //**************************************************************************


    if (HwDeviceExtension->AliChipset_Problem_Found==TRUE)
    
        {

        //**********************************************************************
        //
        // This chipset has another bug, confirmed by ALI, where it cannot
        // accept fast DEVSEL# at 100MHz bus speeds.  We cannot adjust our
        // DEVSEL# speeds, but we can delay our TRDY by one clock cycle, which
        // should have the same effect.
        //
        // Note that we (NV) have seen no improvement in any of the ALI1541
        // issues with this change, but ALI is adament there is a bug in the 1541
        // having to do with this logic.  Better safe than sorry.
        //
        // This bit is present in NV4, NV5, and NV10.
        //
        //**********************************************************************

        CurrentValue = REG_RD32(NV_PBUS_DEBUG_1);
        CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_DEBUG_1_PCIS_WRITE));
        REG_WR32(NV_PBUS_DEBUG_1,  CurrentValue);

        }
               

    return(TRUE);
    } // end NVSetMode()

//******************************************************************************
//
// Function: NV_SetColorLookup()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )
    {
    ULONG i;

    //**************************************************************************
    // wait for vblank
    //**************************************************************************
    if(HwDeviceExtension->curPowerState == VideoPowerOn)
    {
        while (!(PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08));
    }

    //**************************************************************************
    //  Specify first palette register
    //**************************************************************************
    USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_WRITE_MODE_ADDRESS, (UCHAR) ClutBuffer->FirstEntry);

    //**************************************************************************
    //  Set CLUT registers directly on the hardware
    //**************************************************************************

    for (i = 0; i < ClutBuffer->NumEntries; i++)
        {
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Red);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Green);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Blue);
        }

    }

//******************************************************************************
//
// Function: NV4_SetPixMixBits()
//
// Routine Description: Set the NV_PRAMDAC_GENERAL_CONTROL_PIXMIX to 
//                      NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_SetPixMixBits(
    PHW_DEVICE_EXTENSION    HwDeviceExtension
)
{
    ULONG   ulGeneralCtrl;

    ulGeneralCtrl = PRAMDAC_REG_RD32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL);

    //
    //  Set NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON
    //

    ulGeneralCtrl |= 0x30;
    PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,ulGeneralCtrl);
}

//******************************************************************************
//
// Function: NV4_InitPalette()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_InitPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
    {
    USHORT i;

    //**************************************************************************
    // Blast out our palette values.  First Init to index 0
    //**************************************************************************
    USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_WRITE_MODE_ADDRESS, (UCHAR) 0);

    //**************************************************************************
    // Init to a gray scale so something will appear instead of just black
    // 256 * 3 (for each R,G, and B component)
    //**************************************************************************

    for (i = 0; i < 256; i++)
        {
        //**********************************************************************
        // Just initialize to a gray scale for now.
        //**********************************************************************
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        }

    return;


    }


//******************************************************************************
//
// Function:    NVMapMemoryRanges()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NVMapMemoryRanges(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PHYSICAL_ADDRESS CrtcRange;
    PHYSICAL_ADDRESS TimerRange;
    PHYSICAL_ADDRESS NV_PhysBaseAddress;
    PHYSICAL_ADDRESS NV_PhysFBAddress;
    ULONG CrtcLength;
    ULONG TimerLength;
    ULONG NV_RegisterLength;
    ULONG NV_FrameBufferLength;
    PHWREG CrtcAddress;
    PHWREG TimerAddress;
    PHWREG NV_LinearBaseAddress;
    PHWREG NV_LinearFBAddress;
    PHYSICAL_ADDRESS ConfigPciRange;
    ULONG ConfigPciLength;
    PHWREG ConfigPciAddress;
    ULONG CurrentValue;

    //**************************************************************************
    // Make SURE to always ENABLE bus mastering!  Our chip needs it ENABLED !!
    // (Some DELL Bios's disable bus mastering on our card)
    //**************************************************************************

    //**************************************************************************
    // First get access to the CONFIG_PCI_NV1 register
    //**************************************************************************

    ConfigPciRange.HighPart  = 0x00000000;
    ConfigPciRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    ConfigPciRange.LowPart   += NV_PBUS_PCI_NV_1;
    ConfigPciLength          = 0x1000;   // Arbitrary 4k length

    ConfigPciAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         ConfigPciRange,
                                         ConfigPciLength, FALSE);
    if (ConfigPciAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Config PCI Reg\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Make sure bus mastering is always ENABLED !!  (Bit 2)
    // Read current value then enable the bus_master bit.
    //**************************************************************************

    CurrentValue = TEMP_REG_RD32(ConfigPciAddress);
    CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_PCI_NV_1_BUS_MASTER));
    TEMP_REG_WR32(ConfigPciAddress,  CurrentValue);

    //**************************************************************************
    // Free up this temporary range
    //**************************************************************************

    VideoPortFreeDeviceBase(hwDeviceExtension, ConfigPciAddress);


    //**************************************************************************
    // Make SURE to disable VBLANK and TIMER interrupts on startup!
    // (Some COMPAQ systems do not reset the chip, so these interrupts
    // may inadvertently get left enabled.  These interrupts (vblank/timer) then
    // enter our interrupt handler before its ready to accept them)
    //**************************************************************************

    //**************************************************************************
    // First get access to VBLANK interrupt enable register
    //**************************************************************************

    CrtcRange.HighPart  = 0x00000000;
    CrtcRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    CrtcRange.LowPart   += NV_PCRTC_INTR_EN_0;
    CrtcLength          = 0x1000;   // Arbitrary 4k length

    CrtcAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         CrtcRange,
                                         CrtcLength, FALSE);
    if (CrtcAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Crtc Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Get access to TIMER interrupt enable register
    //**************************************************************************

    TimerRange.HighPart  = 0x00000000;
    TimerRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    TimerRange.LowPart   += NV_PTIMER_INTR_EN_0 ;
    TimerLength          = 0x1000;   // Arbitrary 4k length

    TimerAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         TimerRange,
                                         TimerLength, FALSE);
    if (TimerAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Timer Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Make sure these interrupts are always DISABLED initially!
    //**************************************************************************

    TEMP_REG_WR32(CrtcAddress,  0x00000000);
    TEMP_REG_WR32(TimerAddress, 0x00000000);

    //**************************************************************************
    // Free up these temporary ranges
    //**************************************************************************

    VideoPortFreeDeviceBase(hwDeviceExtension, CrtcAddress);
    VideoPortFreeDeviceBase(hwDeviceExtension, TimerAddress);

    //**************************************************************************
    // Map entire NV register space
    //**************************************************************************

    NV_PhysBaseAddress.HighPart = 0x00000000;
    NV_PhysBaseAddress.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    NV_RegisterLength           = 0x1000000;    // 16M

    if ( (  NV_LinearBaseAddress = VideoPortGetDeviceBase(hwDeviceExtension,
                                                          NV_PhysBaseAddress,
                                                          NV_RegisterLength, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PGRAPH Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }
    hwDeviceExtension->NvRegisterBase = NV_LinearBaseAddress;

    //**************************************************************************
    // Initialize the 'individual' memory ranges
    //**************************************************************************

    hwDeviceExtension->NV1_Lin_PMC_Registers    = NV_LinearBaseAddress + (DEVICE_BASE(NV_PMC)/4);
    hwDeviceExtension->NV1_Lin_PFB_Registers    = NV_LinearBaseAddress + (DEVICE_BASE(NV_PFB)/4);
    hwDeviceExtension->NV1_Lin_PFIFO_Registers  = NV_LinearBaseAddress + (DEVICE_BASE(NV_PFIFO)/4);
    hwDeviceExtension->NV1_Lin_PBUS_Registers   = NV_LinearBaseAddress + (DEVICE_BASE(NV_PBUS)/4);
    hwDeviceExtension->NV1_Lin_PGRAPH_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PGRAPH)/4);
    hwDeviceExtension->NV1_Lin_PEXTDEV_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_PEXTDEV)/4);
    hwDeviceExtension->NV3_Lin_PRMVIO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PRMVIO)/4);
    hwDeviceExtension->NV3_Lin_PRMCIO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PRMCIO)/4);
    hwDeviceExtension->NV3_Lin_PRAMDAC_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_PRAMDAC)/4);
    hwDeviceExtension->NV3_Lin_USERDAC_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_USER_DAC)/4);
    hwDeviceExtension->NV3_Lin_PVIDEO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PVIDEO)/4);
    hwDeviceExtension->NV1_Lin_USER_Registers   = NV_LinearBaseAddress + (DEVICE_BASE(NV_USER)/4);
    hwDeviceExtension->pBios = (PUCHAR)(&((hwDeviceExtension->NvRegisterBase)->Reg008[DEVICE_BASE(NV_PRAMIN)]));

    //**************************************************************************
    // Return successful
    //**************************************************************************

    return(NO_ERROR);

    } // NVMapMemoryRanges()

//******************************************************************************
//
// Function:    NVMapFrameBuffer()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NVMapFrameBuffer(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VIDEO_MEMORY_INFORMATION memoryInformation;
    PHWINFO NVInfo;
    PHYSICAL_ADDRESS NVFrameBuffer;
    ULONG inIoSpace;
    ULONG status;
    ULONG MapMemoryAdjust;

    //**************************************************************************
    // Get the amount of memory available on the card
    // (Determined in GetNVInfo)
    //**************************************************************************

    NVInfo = &(hwDeviceExtension->NvInfo);
    memoryInformation.VideoRamLength = NVInfo->Framebuffer.RamSize;

    //**************************************************************************
    // Set VideoRamBase to zero, to map range at any location in the
    // logical address space of the current process
    //**************************************************************************

    memoryInformation.VideoRamBase = 0;

    //**************************************************************************
    // Get the physical address of the frame buffer
    //**************************************************************************

    NVFrameBuffer.HighPart = 0x00000000;
    NVFrameBuffer.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
    NVFrameBuffer.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;

    //**************************************************************************
    // Always set write combining for NT4.0 or later
    // Do NOT set it for NT 3.51 !!!!
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0400)
    inIoSpace = VIDEO_MEMORY_SPACE_P6CACHE;
#else
    inIoSpace = 0;
#endif

    //**************************************************************************
    // When calling RmPostNvDevice, and passing in our ptr to the frame buffer,
    // RmPostNvDevice needs to read and write a little bit PAST the end
    // of video memory in order to size it.  
    // 
    // So, in order to accomodate this and prevent a fatal exception error, 
    // we'll allocate just a little bit more memory than the actual amount needed. 
    // (Only necessary for Win2k or better)
    //**************************************************************************

    MapMemoryAdjust = memoryInformation.VideoRamLength;

#if (_WIN32_WINNT >= 0x0500)
    MapMemoryAdjust += BIOS_MEM_SIZE_ADJUST_FACTOR;
#endif


    status = VideoPortMapMemory(hwDeviceExtension,
                                 NVFrameBuffer,
                                 &(MapMemoryAdjust),
                                 &(inIoSpace),
                                 &(memoryInformation.VideoRamBase));


#if _WIN32_WINNT < 0x0500

    //**************************************************************************
    // Special Case unattended setup issue:
    //
    //      Normally, a 32Mb video card will install successfully on a system 
    //      with 32Mb of system memory, when the display driver is installed manually.
    //
    //      However, UNATTENDED setup of a 32Mb video card on a system with 32Mb
    //      may fail.  And what makes matters worse is that during unattended setup,
    //      the driver is usually installed BEFORE the service packs are applied.
    //      (Display driver should REALLY be installed AFTER the service pack is applied)
    //
    //      To alleviate this situation and allow a 32Mb video card to be installed
    //      via unattended setup, we'll try just allocating 16Mb if the above VideoPortMapMemory 
    //      call fails.  This is REALLY not valid (and may result in the driver
    //      not working correctly), but it will allow the driver to install
    //      and get past unattended setup.
    //
    //      After the service pack is applied, subsequent VideoPortMapMemory calls should 
    //      then succeed with no problem.    
    //       
    //**************************************************************************

    if (status != NO_ERROR)
        {

        NVInfo->Framebuffer.RamSizeMb = 16;
        NVInfo->Framebuffer.RamSize   = 0x01000000;

        memoryInformation.VideoRamLength = NVInfo->Framebuffer.RamSize;
        memoryInformation.VideoRamBase = 0;


        status = VideoPortMapMemory(hwDeviceExtension,
                                     NVFrameBuffer,
                                     &(memoryInformation.VideoRamLength),
                                     &(inIoSpace),
                                     &(memoryInformation.VideoRamBase));
        }
#endif



    hwDeviceExtension->FrameBufferPtr = memoryInformation.VideoRamBase;
    hwDeviceExtension->FrameBufferBase= memoryInformation.VideoRamBase;

    //**************************************************************************
    // If this call fails, driver should revert back to standard VGA
    //**************************************************************************

    return(status);



    }


//******************************************************************************
//
// Function: NVIsPresent()
//
// Routine Description:
//
// Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//
//******************************************************************************


BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      PULONG NV1Slot)

    {
    USHORT  usVendorId;
    USHORT  usDeviceId;
    ULONG   ulSlot     = 0;
    ULONG   i;
    BOOL    FoundNV4=FALSE;
    BOOL    FoundNV5=FALSE;
    BOOL    FoundNV5VANTA=FALSE;
    BOOL    FoundNV5ULTRA=FALSE;
    BOOL    FoundNV5MODEL64=FALSE;
    BOOL    FoundNV0A=FALSE;
    BOOL    FoundNV10=FALSE;
    BOOL    FoundNV10DDR=FALSE;
    BOOL    FoundNV10GL=FALSE;
    BOOL    FoundNV11=FALSE;
    BOOL    FoundNV11DDR=FALSE;
    BOOL    FoundNV11M=FALSE;
    BOOL    FoundNV11GL=FALSE;
    BOOL    FoundNV15=FALSE;
    BOOL    FoundNV15DDR=FALSE;
    BOOL    FoundNV15BR=FALSE;
    BOOL    FoundNV15GL=FALSE;
    BOOL    FoundNV20=FALSE;
    BOOL    FoundNV20_1=FALSE;
    BOOL    FoundNV20_2=FALSE;
    BOOL    FoundNV20_3=FALSE;

    //**************************************************************************
    // VideoPortGetAccessRanges calls the PCI Bios to determine
    //    if the specified device is present or not.  This appears
    //    to be the equivalent call to the PCI Bios FIND_PCI_DEVICE call.
    //
    // Specify NumRequestedResources = 0
    //         RequestedResources = NULL
    //         NumAccessRanges = 1
    //         TempAccessRanges = Bus relative memory ranges for device (returned)
    //         VendorID = ID which identifies manufacturer
    //         DeviceID = ID which identifies device
    //         Slot = Specifies the Nth device of this type.
    //                Specify 0 to find the first (zero'th) occurence of device)
    //**************************************************************************

    //**************************************************************************
    // First, check and see if NV4 is present
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0500)

    // NT5 version uses Plug-n-Play, i.e. no VID and DID required
    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 3,
                                 HwDeviceExtension->NVAccessRanges,
                                 NULL,
                                 NULL,
                                 &ulSlot) == NO_ERROR)

#else

    //**************************************************************************
    // Look for genuine NV4 (TNT)
    //**************************************************************************

    ulSlot     = 0;
    usVendorId = NV4_VENDOR_ID;
    usDeviceId = NV4_DEVICE_NV4_ID;

    // other NT versions must specify VID and DID
    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 2,
                                 HwDeviceExtension->NVAccessRanges,
                                 &usVendorId,
                                 &usDeviceId,
                                 &ulSlot) == NO_ERROR)

        {
        FoundNV4=TRUE;
        }

    else

        {

        //**********************************************************************
        // Look for NV5 (TNT2), backwards compatible with NV4
        //**********************************************************************

        ulSlot     = 0;
        usVendorId = NV4_VENDOR_ID;
        usDeviceId = NV5_DEVICE_NV5_ID;

        // other NT versions must specify VID and DID
        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 2,
                                 HwDeviceExtension->NVAccessRanges,
                                 &usVendorId,
                                 &usDeviceId,
                                 &ulSlot) == NO_ERROR)

            {
            FoundNV5=TRUE;
            }

        else

            {


            //******************************************************************
            // Look for ULTRA, backwards compatible with NV4
            //******************************************************************

            ulSlot     = 0;
            usVendorId = NV4_VENDOR_ID;
            usDeviceId = NV5ULTRA_DEVICE_NV5ULTRA_ID;

            // other NT versions must specify VID and DID
            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                     0,
                                     NULL,
                                     2,
                                     HwDeviceExtension->NVAccessRanges,
                                     &usVendorId,
                                     &usDeviceId,
                                     &ulSlot) == NO_ERROR)

                {
                FoundNV5ULTRA=TRUE;
                }


            else

                {


                //**************************************************************
                // Look for VANTA, backwards compatible with NV4
                //**************************************************************

                ulSlot     = 0;
                usVendorId = NV4_VENDOR_ID;
                usDeviceId = NV5VANTA_DEVICE_NV5VANTA_ID;

                // other NT versions must specify VID and DID
                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                         0,
                                         NULL,
                                         2,
                                         HwDeviceExtension->NVAccessRanges,
                                         &usVendorId,
                                         &usDeviceId,
                                         &ulSlot) == NO_ERROR)

                    {
                    FoundNV5VANTA=TRUE;
                    }


                else


                    {

                    //**************************************************************
                    // Look for TNT2 Model 64 backwards compatible with NV4
                    //**************************************************************

                    ulSlot     = 0;
                    usVendorId = NV4_VENDOR_ID;
                    usDeviceId = NV5MODEL64_DEVICE_NV5MODEL64_ID;

                    // other NT versions must specify VID and DID
                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                             0,
                                             NULL,
                                             2,
                                             HwDeviceExtension->NVAccessRanges,
                                             &usVendorId,
                                             &usDeviceId,
                                             &ulSlot) == NO_ERROR)

                        {
                        FoundNV5MODEL64=TRUE;
                        }


                    else


                        {
    
    
                        //**********************************************************
                        // Look for NV0A, backwards compatible with NV4
                        //**********************************************************
    
                        ulSlot     = 0;
                        usVendorId = NV4_VENDOR_ID;
                        usDeviceId = NV0A_DEVICE_NV0A_ID;
    
                        // other NT versions must specify VID and DID
                        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                 0,
                                                 NULL,
                                                 2,
                                                 HwDeviceExtension->NVAccessRanges,
                                                 &usVendorId,
                                                 &usDeviceId,
                                                 &ulSlot) == NO_ERROR)
    
                            {
                            FoundNV0A=TRUE;
                            }
    
    
                        else
    
                            {
    
                            //******************************************************
                            // Look for NV10, backwards compatible with NV4
                            //******************************************************
    
                            ulSlot     = 0;
                            usVendorId = NV4_VENDOR_ID;
                            usDeviceId = NV10_DEVICE_NV10_ID;
    
                            // other NT versions must specify VID and DID
                            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                 0,
                                                 NULL,
                                                 2,
                                                 HwDeviceExtension->NVAccessRanges,
                                                 &usVendorId,
                                                 &usDeviceId,
                                                 &ulSlot) == NO_ERROR)
    
                                {
                                FoundNV10=TRUE;
                                }


                            else
                            
                                {
                                
                                
                                //******************************************************
                                // Look for NV10DDR, backwards compatible with NV4
                                //******************************************************
    
                                ulSlot     = 0;
                                usVendorId = NV4_VENDOR_ID;
                                usDeviceId = NV10DDR_DEVICE_NV10DDR_ID;
    
                                // other NT versions must specify VID and DID
                                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                     0,
                                                     NULL,
                                                     2,
                                                     HwDeviceExtension->NVAccessRanges,
                                                     &usVendorId,
                                                     &usDeviceId,
                                                     &ulSlot) == NO_ERROR)
    
                                    {
                                    FoundNV10DDR=TRUE;
                                    }


                                else
                                
                                    {
                                    

                                    //******************************************************
                                    // Look for NV10GL, backwards compatible with NV4
                                    //******************************************************
    
                                    ulSlot     = 0;
                                    usVendorId = NV4_VENDOR_ID;
                                    usDeviceId = NV10GL_DEVICE_NV10GL_ID;
    
                                    // other NT versions must specify VID and DID
                                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                         0,
                                                         NULL,
                                                         2,
                                                         HwDeviceExtension->NVAccessRanges,
                                                         &usVendorId,
                                                         &usDeviceId,
                                                         &ulSlot) == NO_ERROR)
        
                                        {
                                        FoundNV10GL=TRUE;
                                        }

                                    else
                                    
                                        {

                                        //******************************************************
                                        // Look for NV11, backwards compatible with NV4
                                        //******************************************************
    
                                        ulSlot     = 0;
                                        usVendorId = NV4_VENDOR_ID;
                                        usDeviceId = NV11_DEVICE_NV11_ID;
    
                                        // other NT versions must specify VID and DID
                                        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                         0,
                                                         NULL,
                                                         2,
                                                         HwDeviceExtension->NVAccessRanges,
                                                         &usVendorId,
                                                         &usDeviceId,
                                                         &ulSlot) == NO_ERROR)
        
                                            {
                                            FoundNV11=TRUE;
                                            }


                                        else
                                        
                                            {

    
                                            //******************************************************
                                            // Look for NV11DDR, backwards compatible with NV4
                                            //******************************************************
    
                                            ulSlot     = 0;
                                            usVendorId = NV4_VENDOR_ID;
                                            usDeviceId = NV11DDR_DEVICE_NV11DDR_ID;
    
                                            // other NT versions must specify VID and DID
                                            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                         0,
                                                         NULL,
                                                         2,
                                                         HwDeviceExtension->NVAccessRanges,
                                                         &usVendorId,
                                                         &usDeviceId,
                                                         &ulSlot) == NO_ERROR)
        
                                                {
                                                FoundNV11DDR=TRUE;
                                                }


                                            else
 
                                                {


                                                //******************************************************
                                                // Look for NV11M, backwards compatible with NV4
                                                //******************************************************

                                                ulSlot     = 0;
                                                usVendorId = NV4_VENDOR_ID;
                                                usDeviceId = NV11M_DEVICE_NV11M_ID;

                                                // other NT versions must specify VID and DID
                                                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                             0,
                                                             NULL,
                                                             2,
                                                             HwDeviceExtension->NVAccessRanges,
                                                             &usVendorId,
                                                             &usDeviceId,
                                                             &ulSlot) == NO_ERROR)

                                                    {
                                                    FoundNV11M=TRUE;
                                                    }


                                                else
                                    
                                                    {

                                                    //******************************************************
                                                    // Look for NV11GL, backwards compatible with NV4
                                                    //******************************************************
        
                                                    ulSlot     = 0;
                                                    usVendorId = NV4_VENDOR_ID;
                                                    usDeviceId = NV11GL_DEVICE_NV11GL_ID;
        
                                                    // other NT versions must specify VID and DID
                                                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                 0,
                                                                 NULL,
                                                                 2,
                                                                 HwDeviceExtension->NVAccessRanges,
                                                                 &usVendorId,
                                                                 &usDeviceId,
                                                                 &ulSlot) == NO_ERROR)
            
                                                    {
                                                    FoundNV11GL=TRUE;
                                                    }

                                                    else
                                        
                                                        {


                                                        //******************************************************
                                                        // Look for NV15, backwards compatible with NV4
                                                        //******************************************************
            
                                                        ulSlot     = 0;
                                                        usVendorId = NV4_VENDOR_ID;
                                                        usDeviceId = NV15_DEVICE_NV15_ID;
            
                                                        // other NT versions must specify VID and DID
                                                        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                     0,
                                                                     NULL,
                                                                     2,
                                                                     HwDeviceExtension->NVAccessRanges,
                                                                     &usVendorId,
                                                                     &usDeviceId,
                                                                     &ulSlot) == NO_ERROR)
                
                                                            {
                                                            FoundNV15=TRUE;
                                                            }


                                                        else
                                    
                                                            {

                                                        //******************************************************
                                                        // Look for NV15DDR, backwards compatible with NV4
                                                        //******************************************************
                
                                                            ulSlot     = 0;
                                                            usVendorId = NV4_VENDOR_ID;
                                                            usDeviceId = NV15DDR_DEVICE_NV15DDR_ID;
                
                                                        // other NT versions must specify VID and DID
                                                            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                         0,
                                                                         NULL,
                                                                         2,
                                                                         HwDeviceExtension->NVAccessRanges,
                                                                         &usVendorId,
                                                                         &usDeviceId,
                                                                         &ulSlot) == NO_ERROR)
                    
                                                                {
                                                                FoundNV15DDR=TRUE;
                                                                }



                                                            else
                                    
                                                                {

                                                            //******************************************************
                                                            // Look for NV15BR, backwards compatible with NV4
                                                            //******************************************************
                
                                                                ulSlot     = 0;
                                                                usVendorId = NV4_VENDOR_ID;
                                                                usDeviceId = NV15BR_DEVICE_NV15BR_ID;
                
                                                            // other NT versions must specify VID and DID
                                                                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                             0,
                                                                             NULL,
                                                                             2,
                                                                             HwDeviceExtension->NVAccessRanges,
                                                                             &usVendorId,
                                                                             &usDeviceId,
                                                                             &ulSlot) == NO_ERROR)
                    
                                                                    {
                                                                    FoundNV15BR=TRUE;
                                                                    }



                                                                else
                                            
                                                                    {

                                                                //******************************************************
                                                                // Look for NV15GL backwards compatible with NV4
                                                                //******************************************************
                    
                                                                    ulSlot     = 0;
                                                                    usVendorId = NV4_VENDOR_ID;
                                                                    usDeviceId = NV15GL_DEVICE_NV15GL_ID;
                    
                                                                // other NT versions must specify VID and DID
                                                                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                 0,
                                                                                 NULL,
                                                                                 2,
                                                                                 HwDeviceExtension->NVAccessRanges,
                                                                                 &usVendorId,
                                                                                 &usDeviceId,
                                                                                 &ulSlot) == NO_ERROR)
                            
                                                                        {
                                                                        FoundNV15GL=TRUE;
                                                                        }
    
    
                                                                    else

                                                                        {


                                                                        //******************************************************
                                                                        // Look for NV20 (note: NV20 has 3 BAR's)
                                                                        //******************************************************

                                                                        ulSlot     = 0;
                                                                        usVendorId = NV4_VENDOR_ID;
                                                                        usDeviceId = NV20_DEVICE_NV20_ID;

                                                                        // other NT versions must specify VID and DID
                                                                        if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                     0,
                                                                                     NULL,
                                                                                     3,
                                                                                     HwDeviceExtension->NVAccessRanges,
                                                                                     &usVendorId,
                                                                                     &usDeviceId,
                                                                                     &ulSlot) == NO_ERROR)

                                                                            {
                                                                            FoundNV20=TRUE;
                                                                            }


                                                                        else

                                                                            {


                                                                            //******************************************************
                                                                            // Look for NV20 (note: NV20 has 3 BAR's)
                                                                            //******************************************************

                                                                            ulSlot     = 0;
                                                                            usVendorId = NV4_VENDOR_ID;
                                                                            usDeviceId = NV20_DEVICE_NV20_1_ID;

                                                                            // other NT versions must specify VID and DID
                                                                            if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                         0,
                                                                                         NULL,
                                                                                         3,
                                                                                         HwDeviceExtension->NVAccessRanges,
                                                                                         &usVendorId,
                                                                                         &usDeviceId,
                                                                                         &ulSlot) == NO_ERROR)

                                                                                {
                                                                                FoundNV20_1=TRUE;
                                                                                }


                                                                            else

                                                                                {


                                                                                //******************************************************
                                                                                // Look for NV20 (note: NV20 has 3 BAR's)
                                                                                //******************************************************

                                                                                ulSlot     = 0;
                                                                                usVendorId = NV4_VENDOR_ID;
                                                                                usDeviceId = NV20_DEVICE_NV20_2_ID;

                                                                                // other NT versions must specify VID and DID
                                                                                if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                             0,
                                                                                             NULL,
                                                                                             3,
                                                                                             HwDeviceExtension->NVAccessRanges,
                                                                                             &usVendorId,
                                                                                             &usDeviceId,
                                                                                             &ulSlot) == NO_ERROR)

                                                                                    {
                                                                                    FoundNV20_2=TRUE;
                                                                                    }


                                                                                else

                                                                                    {


                                                                                    //******************************************************
                                                                                    // Look for NV20 (note: NV20 has 3 BAR's)
                                                                                    //******************************************************

                                                                                    ulSlot     = 0;
                                                                                    usVendorId = NV4_VENDOR_ID;
                                                                                    usDeviceId = NV20_DEVICE_NV20_3_ID;

                                                                                    // other NT versions must specify VID and DID
                                                                                    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                                                                                 0,
                                                                                                 NULL,
                                                                                                 3,
                                                                                                 HwDeviceExtension->NVAccessRanges,
                                                                                                 &usVendorId,
                                                                                                 &usDeviceId,
                                                                                                 &ulSlot) == NO_ERROR)

                                                                                        {
                                                                                        FoundNV20_3=TRUE;
                                                                                        }


                                                                                    } // Look for NV20 ID 203

                                                                                } // Look for NV20 ID 202

                                                                            } // Look for NV20 ID 201

                                                                        } // Look for NV20

                                                                    } // Look for NV15 GL


                                                                } // Look for NV15 BR


                                                            } // Look for NV 15 DDR

                                        
                                                        } // Look for NV15

                                        
                                                    } // Look for NV11 GL


                                                } // Look for NV11M

                                            
                                            } // Look for NV11 DDR


                                        } // Look for NV11


                                    } // Look for NV10 GL

                                
                                } // Look for NV10 ULTRA
                                
    
                            } // Look for NV10
    
    
                        } // Look for NV0A


                    } // Look for TNT2 Model 64


                } // Look for VANTA 


            }  // Look for ULTRA (TNT2 ULTRA)


        } // Look for NV5 (TNT2)

    //**************************************************************************
    // Look for an NV4 compatible chip
    //**************************************************************************

    if ( (FoundNV4)  || 
         (FoundNV5)  || (FoundNV5ULTRA) || (FoundNV5VANTA) || (FoundNV5MODEL64) || 
         (FoundNV0A) || 
         (FoundNV10) || (FoundNV10DDR) || (FoundNV10GL) ||
         (FoundNV11) || (FoundNV11DDR) || (FoundNV11M)  || (FoundNV11GL) ||
         (FoundNV15) || (FoundNV15DDR) || (FoundNV15BR) || (FoundNV15GL) ||
         (FoundNV20) || (FoundNV20_1)  || (FoundNV20_2) || (FoundNV20_3))


#endif // _WIN32_WINNT >= 0x0500

        {
        VideoDebugPrint((1,"Found an NV4 (or better) in pci slot %d\n", ulSlot));

        //**********************************************************************
        //  At this point we have identified an NV4 on the PCI bus by using
        //  the vendor and device id.
        //**********************************************************************

        HwDeviceExtension->ulSlot       = ulSlot;
        HwDeviceExtension->ulChipID     = NV4_DEVICE_NV4_ID;
        HwDeviceExtension->ulRevLevel   = REV_UNDEF;
        HwDeviceExtension->BoardID      = NV4_VENDOR_ID;


        //**********************************************************************
        // Check for NV5, NV5 ULTRA, NV5 VANTA, NV5 Model 64, NV0A, or NV10 (all NV4 compatible)
        // and assign a unique chip ID
        //**********************************************************************

        if (FoundNV5)
            HwDeviceExtension->ulChipID     = NV5_DEVICE_NV5_ID;
        else if (FoundNV5ULTRA)
            HwDeviceExtension->ulChipID     = NV5ULTRA_DEVICE_NV5ULTRA_ID;
        else if (FoundNV5VANTA)
            HwDeviceExtension->ulChipID     = NV5VANTA_DEVICE_NV5VANTA_ID;
        else if (FoundNV5MODEL64)
            HwDeviceExtension->ulChipID     = NV5MODEL64_DEVICE_NV5MODEL64_ID;
        else if (FoundNV0A)
            HwDeviceExtension->ulChipID     = NV0A_DEVICE_NV0A_ID;

        else if (FoundNV10)
            HwDeviceExtension->ulChipID     = NV10_DEVICE_NV10_ID;
        else if (FoundNV10DDR)
            HwDeviceExtension->ulChipID     = NV10DDR_DEVICE_NV10DDR_ID;
        else if (FoundNV10GL)
            HwDeviceExtension->ulChipID     = NV10GL_DEVICE_NV10GL_ID;

        else if (FoundNV11)
            HwDeviceExtension->ulChipID     = NV11_DEVICE_NV11_ID;
        else if (FoundNV11DDR)
            HwDeviceExtension->ulChipID     = NV11DDR_DEVICE_NV11DDR_ID;
        else if (FoundNV11M)
            HwDeviceExtension->ulChipID     = NV11M_DEVICE_NV11M_ID;
        else if (FoundNV11GL)
            HwDeviceExtension->ulChipID     = NV11GL_DEVICE_NV11GL_ID;

        else if (FoundNV15)
            HwDeviceExtension->ulChipID     = NV15_DEVICE_NV15_ID;
        else if (FoundNV15DDR)
            HwDeviceExtension->ulChipID     = NV15DDR_DEVICE_NV15DDR_ID;
        else if (FoundNV15BR)
            HwDeviceExtension->ulChipID     = NV15BR_DEVICE_NV15BR_ID;
        else if (FoundNV15GL)
            HwDeviceExtension->ulChipID     = NV15GL_DEVICE_NV15GL_ID;
        
        else if (FoundNV20)
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_ID;
        else if (FoundNV20_1)
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_1_ID;
        else if (FoundNV20_2)
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_2_ID;
        else if (FoundNV20_3)
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_3_ID;


        //**********************************************************************
        // NOTE: For Win2K, device IDs are in the INF, so we don't
        //       know what chip we're running on.  So for Win2k, we actually
        //       determine the chip ID just a little bit later in NVGetNVInfo !!.
        //**********************************************************************

        //**********************************************************************
        // Save the slot number of later (for VideoPortSetBusData)
        //**********************************************************************

        *NV1Slot = ulSlot;

        //**********************************************************************
        // QUERY_PUBLIC_ACCESS_RANGES will use the following values to properly map
        // in the public access ranges.  For our display driver, we're going
        // to declare public access ranges:     1) NV User Channel containing subchannels
        //                                      2) Graphics Status Register
        //                                      3) Frame buffer VBLANK register
        //                                      4) Frame buffer START register
        //                                      5) CRTC regs, etc....
        // Only the miniport will have access to all of the other privileged
        // graphics registers.
        //**********************************************************************

        //**********************************************************************
        // Init NV memory range offset values to zero
        //**********************************************************************

        for (i=0 ; i<NV_NUM_RANGES ;i++)
          {
          RangeOffsets[i].ulOffset = 0;
          RangeOffsets[i].ulLength = 0;
          }

        //**********************************************************************
        // Initialize the actual offset values
        //**********************************************************************

        RangeOffsets[NV_PMC_INDEX].ulOffset = DEVICE_BASE(NV_PMC);
        RangeOffsets[NV_PMC_INDEX].ulLength = DEVICE_EXTENT(NV_PMC);

        RangeOffsets[NV_PFB_INDEX].ulOffset = DEVICE_BASE(NV_PFB);
        RangeOffsets[NV_PFB_INDEX].ulLength = DEVICE_EXTENT(NV_PFB);

        RangeOffsets[NV_PFIFO_INDEX].ulOffset = DEVICE_BASE(NV_PFIFO);
        RangeOffsets[NV_PFIFO_INDEX].ulLength = DEVICE_EXTENT(NV_PFIFO);

        RangeOffsets[NV_PBUS_INDEX].ulOffset = DEVICE_BASE(NV_PBUS);
        RangeOffsets[NV_PBUS_INDEX].ulLength = DEVICE_EXTENT(NV_PBUS);

        RangeOffsets[NV_PGRAPH_INDEX].ulOffset = DEVICE_BASE(NV_PGRAPH);
        RangeOffsets[NV_PGRAPH_INDEX].ulLength = DEVICE_EXTENT(NV_PGRAPH);

        RangeOffsets[NV_PEXTDEV_INDEX].ulOffset = DEVICE_BASE(NV_PEXTDEV);
        RangeOffsets[NV_PEXTDEV_INDEX].ulLength = DEVICE_EXTENT(NV_PEXTDEV);

        RangeOffsets[NV_PRMVIO_INDEX].ulOffset = DEVICE_BASE(NV_PRMVIO);
        RangeOffsets[NV_PRMVIO_INDEX].ulLength = DEVICE_EXTENT(NV_PRMVIO);

        RangeOffsets[NV_PRMCIO_INDEX].ulOffset = DEVICE_BASE(NV_PRMCIO);
        RangeOffsets[NV_PRMCIO_INDEX].ulLength = DEVICE_EXTENT(NV_PRMCIO);

        RangeOffsets[NV_PRAMDAC_INDEX].ulOffset = DEVICE_BASE(NV_PRAMDAC);
        RangeOffsets[NV_PRAMDAC_INDEX].ulLength = DEVICE_EXTENT(NV_PRAMDAC);

        RangeOffsets[NV_USERDAC_INDEX].ulOffset = DEVICE_BASE(NV_USER_DAC);
        RangeOffsets[NV_USERDAC_INDEX].ulLength = DEVICE_EXTENT(NV_USER_DAC);

        RangeOffsets[NV_PVIDEO_INDEX].ulOffset = DEVICE_BASE(NV_PVIDEO);
        RangeOffsets[NV_PVIDEO_INDEX].ulLength = DEVICE_EXTENT(NV_PVIDEO);

        //**********************************************************************
        // Currently allows us to write to 64k of PRAMIN memory
        //**********************************************************************

        RangeOffsets[NV_PRAMIN_INDEX].ulOffset = (ULONG) (DEVICE_BASE(NV_PRAMIN) - DEVICE_BASE(NV_PDFB));
        RangeOffsets[NV_PRAMIN_INDEX].ulLength = 0x10000;

        RangeOffsets[NV_USER_INDEX].ulOffset = DEVICE_BASE(NV_USER);
        RangeOffsets[NV_USER_INDEX].ulLength = 0x10000;

        //**********************************************************************
        // Just allocate memory for the GRAPHICS STATUS register
        // Allocate minimal 16 bytes because we're only mapping 1 register
        //**********************************************************************

        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset = NV_PGRAPH_STATUS;
        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulLength = 16;

        //**********************************************************************
        // Setmode still uses PFB_CONFIG
        //**********************************************************************

        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset = NV_PFB_CONFIG_0;
        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulLength = 16;

        //**********************************************************************
        // DUMB FRAME BUFFER location
        // The actual amount of memory is determined later in NV_GetNVInfo,
        // but for now, just default to 4Mb.  This value will be fixed up
        // in NV_GetNVInfo so that IOCTL_VIDEO_MAP_MEMORY will subsequently
        // map in the correct number of bytes.
        //**********************************************************************

        RangeOffsets[NV_PDFB_INDEX].ulOffset = 0x0;
        RangeOffsets[NV_PDFB_INDEX].ulLength =  0x400000;

        return(TRUE);
        }
    else
        return(FALSE);
    }



//******************************************************************************
//
// Function:    MiniportGetRegistryValue
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

BOOL MiniportGetRegistryValue
    (PHW_DEVICE_EXTENSION HwDeviceExtension,
     U032 Type,
     char *Node,
     char *Name,
     VOID *pData)

    {
    ULONG NumRegValueEntries = sizeof(Nv_Registry_Switch_Offset_Table) / sizeof(NT_NV_REGISTRY_SWITCH_OFFSET);    
    ULONG i=0;   
    BOOL FoundFlag = FALSE;
    ULONG FoundIndex;
    BOOL status;
    char *RegValuePtr;
    char TempNameString[REG_STRING_DATA_MAX];
    WCHAR parameterName[80];
    

    //**************************************************************************
    // This function is called by the RM to get registry switch values.
    // Normally, the RM expects a 'Win9x' type registry, with various levels
    // of keys.  But with WinNT, all our registry switches must fit in
    // ONE key (ie. a flat structure).
    //
    // This routine attempts to find the registry switch name in our
    // registry switch table.  If it's present, we return the value (or string) back.
    // Otherwise, we return false   
    //**************************************************************************

    //**************************************************************************
    // First convert the registry value name string, and
    // convert to all upper case
    //**************************************************************************
    
    my_strcpy(TempNameString,Name);
    my_strupr(TempNameString);
    
    //**************************************************************************
    // Next, Search our registry table to see if this registry switch exists
    // in our 'local' registry structure.
    //**************************************************************************
        
    while ( (i < NumRegValueEntries) && (FoundFlag == FALSE) )
        {
        //**********************************************************************
        // Convert the registry switch names in our local registry table to upper case
        //**********************************************************************

        my_strupr(&Nv_Registry_Switch_Offset_Table[i].RegName[0]);

        //**********************************************************************
        // Now compare and see if this registry switch exists in our table
        // If so, then get the index into our registry switch table.
        //**********************************************************************
        
        status = my_strcmp(&Nv_Registry_Switch_Offset_Table[i].RegName[0], TempNameString);
        if (status == 0)
            {
            FoundFlag = TRUE;
            FoundIndex = i;
            }
                        
        i++;                
        }


    //**************************************************************************
    // If the registry switch was found in our table, then
    // get the corresponding value from our RegistrySwitch structure 
    // in our HwDeviceExtension.  Otherwise, return FALSE. 
    //**************************************************************************

    if (FoundFlag==TRUE)

        {

        if (Type == IS_STRING)

            {
            //******************************************************************
            // Copy the String value
            //******************************************************************

            RegValuePtr = (CHAR *) ((PUCHAR)&HwDeviceExtension->NV_Registry_Table + Nv_Registry_Switch_Offset_Table[FoundIndex].Offset); 
            my_strcpy(pData, RegValuePtr);
            }

        else if (Type == IS_DWORD)

            {
            //******************************************************************
            // Return the DWORD value
            //******************************************************************

            RegValuePtr = (CHAR *) ((PUCHAR)&HwDeviceExtension->NV_Registry_Table + Nv_Registry_Switch_Offset_Table[FoundIndex].Offset); 
            *(ULONG *)pData = *(ULONG *)RegValuePtr;
            

            //******************************************************************
            // Check if we should IGNORE the registry value
            //******************************************************************

            if ( *(ULONG *)pData == IGNORE_REGISTRY_SWITCH)
                return(FALSE);



            }
                
        return(TRUE);
        }
                
          
    else

        {

        //**********************************************************************
        // Unknown registry switch encountered.
        // This may happen if the RM is looking at a Win9x registry switch
        // and it hasn't been added to the NT registry switch table.
        // 
        // In that case, just read the registry switch as a normal
        // value entry (instead of inside our own local NT registry structure)
        // First, convert the parameter into a unicode string
        //**********************************************************************


        for (i = 0; Name[i]; i++)
            {
            parameterName[i] = Name[i];
            }
        parameterName[i] = (WCHAR)NULL;


        status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       parameterName,
                                       FALSE,
                                       NVReadRegistrySwitchesCallback,
                                       (ULONG *)pData);

        if (status == NO_ERROR)
            return(TRUE);
        else
            return(FALSE);            

        }
        
                    
       
    }
    

//******************************************************************************
//
// Function:    LoadRegistrySettings
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID LoadRegistrySettings(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG status;

    //**************************************************************************
    // There are 2 ways we can store registry switches for our NT driver:
    // 
    //   1) Store each registry switch in its own value entry
    //
    //      Advantages:     Easy to edit individual entries with RegEdit
    //      Disadvantages:  Lots of value entries are created which clutter
    //                      up the registry key.  If we need to delete them,
    //                      we may have to delete the entries one by one.
    //
    //   2) Store ALL the registry switches as a chunk in one value entry
    //         
    //      Advantages:     All the registry switches are in one place, not as unwieldly
    //      Disadvantes:    Not as easy to edit individual entries with RegEdit.
    //                          
    // 
    //   For now, we'll go with option 2) and store the switches as
    //   one chunk in a Value Entry.
    //**************************************************************************

    //**************************************************************************
    // First, check and see if our NT registry value entry (which contains our
    // local registry switches) is present or not.  If it's present, then
    // just read it straight into our registry structure.
    //**************************************************************************

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"NVREGSWITCHES",
                                       FALSE,
                                       NVReadRegistrySwitchesCallback,
                                       &(HwDeviceExtension->NV_Registry_Table));

    if (status == NO_ERROR)
        {
        return;
        }
        
    else
    
        {
        //**********************************************************************
        // If the registry value entry was NOT present, then
        //   1) Load up our registry structure with default values, then
        //   2) Write the registry structure to the registry.   
        //**********************************************************************

        LoadDefaultRegistrySwitchValues(HwDeviceExtension);
                
        //**********************************************************************
        // Write the registry switches to the registry as one binary chunk (a structure)
        //**********************************************************************

        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"NVREGSWITCHES",
                                       &(HwDeviceExtension->NV_Registry_Table),
                                       sizeof(HwDeviceExtension->NV_Registry_Table));

        return;        
        }

    }
    

//******************************************************************************
//
// Function:    LoadDefaultRegistrySwitchValues
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID LoadDefaultRegistrySwitchValues(
    PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG status;

// STUB OUT FOR NOW SINCE \common\NVREG.H is constantly changing 
// and breaking the NT build.  When NVREG.H settles down, then
// we can put this function back in

//    //**************************************************************************
//    // Default DISPLAY registry switch values        
//    //**************************************************************************
//
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastDisplayDevice[0]),     NV4_REG_DRV_LAST_DEVICE_CRT );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastCRTMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastDFPMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastNTSCMode[0]),          "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastPALMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.CRTMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DFPMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.NTSCMode[0]),              "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.PALMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DefaultCRTRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DefaultDFPRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.OptimalCRTRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.OptimalDFPRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.MonitorTiming[0]),          NV4_REG_DRV_MONITOR_TIMING_DMT);
//
//    HwDeviceExtension->NV_Registry_Table.Display.DisplayType =                           DISPLAY_TYPE_MONITOR;
//    HwDeviceExtension->NV_Registry_Table.Display.TVType =                                DISPLAY_TYPE_MONITOR;
//    HwDeviceExtension->NV_Registry_Table.Display.CursorAlpha =                           0;
//
//    //**************************************************************************
//    // Default DIRECTDRAW registry switch values        
//    //**************************************************************************
//
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.VPENABLE                    = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayMode                 = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayColorControlEnable   = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayBrightness           = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayContrast             = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayHue                  = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlaySaturation           = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayGamma                = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlaySharpness            = 0;
//
//    //**************************************************************************
//    // Default DIRECT3D registry switch values        
//    //**************************************************************************
//
//    HwDeviceExtension->NV_Registry_Table.Direct3D.ANTIALIASENABLE               = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.COLORKEYCOMPATABILITYENABLE   = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.CONTROLTRAFFIC                = 0;             
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DIRECTMAPENABLE               = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.FOGTABLENABLE                 = 0;              
//    HwDeviceExtension->NV_Registry_Table.Direct3D.LOGOENABLE                    = 0;                 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.SCENESYNCENABLE               = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TILINGENABLE                  = 0;                
//    HwDeviceExtension->NV_Registry_Table.Direct3D.USERMIPMAPENABLE              = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VIDEOTEXTUREENABLEENABLE      = 0;    
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VSYNCENABLE                   = 0;                 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WENABLE                       = 0;                     
//    HwDeviceExtension->NV_Registry_Table.Direct3D.Z24ENABLE                     = 0;                   
//
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AAMETHOD                      = D3D_REG_AAMETHOD_MIN;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AUTOMIPMAPMETHOD              = D3D_REG_AUTOMIPMAPMETHOD_BILINEAR; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.CKREF                         = D3D_REG_CKREF_MIN;                       
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DX6ENABLE                     = 0;                   
//    HwDeviceExtension->NV_Registry_Table.Direct3D.ANISOTOPIC4TAP                = D3D_REG_MIPMAPDITHERMODE_DISABLE;  
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PAL8TEXTURECONVERT            = D3D_REG_PAL8TEXCONVERT_NONE; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PMTRIGGER                     = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TEXELALIGNMENT                = D3D_REG_TEXELALIGNMENT_ZOH_CENTER;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VALIDATEZMETHOD               = D3D_REG_VALIDATEZMETHOD_FLEXIBLE;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.W16FORMAT                     = D3D_REG_WFORMAT_FIXED;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.W32FORMAT                     = D3D_REG_WFORMAT_FIXED;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AGPTEXCUTOFF                  = D3D_REG_DEFAULT_AGPTEXCUTOFF;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.D3DCONTEXTMAX                 = D3D_REG_DEFAULT_D3DCONTEXTMAX; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.D3DTEXTUREMAX                 = D3D_REG_DEFAULT_D3DTEXTUREMAX;  
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DMAMINPUSHCOUNT               = D3D_REG_DEFAULT_DMAMINPUSHCOUNT;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.LODBIASADJUST                 = D3D_REG_DEFAULT_LODBIASADJUST;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.MINVIDEOTEXSIZE               = D3D_REG_DEFAULT_MINVIDEOTEXSIZE;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.MIPMAPLEVELS                  = D3D_REG_DEFAULT_MIPMAPLEVELS;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PERFSTRATEGY                  = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.NOVSYNCPREREDNERLIMIT         = D3D_REG_DEFAULT_PRERENDERLIMIT;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DMAPUSHBUFFERSIZEMAX          = D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TEXHEAP                       = D3D_REG_DEFAULT_TEXHEAPSIZEMAX;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WSCALE16                      = D3D_REG_DEFAULT_WSCALE16;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WSCALE24                      = D3D_REG_DEFAULT_WSCALE24;
//
//    //**************************************************************************
//    // Default SYSTEM registry switch values        
//    //**************************************************************************
//                    
//    HwDeviceExtension->NV_Registry_Table.System.Super7Compat                    = 0;    
//    HwDeviceExtension->NV_Registry_Table.System.FlipOnHSync                     = 0;     
//    HwDeviceExtension->NV_Registry_Table.System.FilterOverride                  = 0;  
//    HwDeviceExtension->NV_Registry_Table.System.NoNT4AGP                        = 0;        
//    HwDeviceExtension->NV_Registry_Table.System.George                          = IGNORE_REGISTRY_SWITCH;          
//    HwDeviceExtension->NV_Registry_Table.System.Gracie                          = IGNORE_REGISTRY_SWITCH;          
//    HwDeviceExtension->NV_Registry_Table.System.TVOutOnPrimary                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.Enable256Burst                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.DisableMPCDetect                = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.MemoryOverride                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.RTLOverride                     = IGNORE_REGISTRY_SWITCH;  
//
//    //**************************************************************************
//    // Default NVTWEAK Control Panel registry switch values ?       
//    //**************************************************************************

    }
    
//******************************************************************************
//
// Function:   BuildAvailableModesTable
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID BuildAvailableModesTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {

    U016 i;
    U016 NumGTFModes;    
    U016 GTFWidth,GTFHeight,GTFDepth,GTFRefresh;
    U016 RegWidth,RegHeight,RegDepth,RegRefresh;
    U032 *GTFModePtr;
    U016 *RegDataPtr;
    U016 *ValidModePtr, *BaseOfValidModeTable;
    BOOL FoundRefreshFlag;
    ULONG status;
    PMODE_ENTRY PModePtr;            
    ULONG widthDivide = 1, heightDivide = 1; // For NV11 MultiHead support.
    
    //**************************************************************************
    // The NVx_MODES modetable entries for each chip type will always be stored 
    // in the \device0 key, since the INF doesn't appear to be able to store them
    // in device1,device2, etc...   As a result, we always store and get modetable
    // registry data from the \device0 key for ALL chip types, and then save them
    // off in global mode tables. Essentially, all modetable registry data will
    // only be read when the FIRST nv device is found.   
    //    
    // That is, VideoPortGetRegistryParameters() will SUCCEED when reading the
    // mode table value entries from \device0, but will FAIL when it tries 
    // to read them from \device1\2\3...because the modetable entries won't be present!
    //
    // We use global modedata tables, so that we can copy modetable data
    // into the hwdeviceextension of each device found.
    //
    // The following is a simplified explanation:
    //
    // 1) hkey_local_machine\system\currentcontrolset\services\nv4\device0\
    //      
    //       nv4_modes      -> This value entry contains mode data for nv4
    //       nv5_modes      -> This value entry contains mode data for nv5
    //       nv5m64_modes   -> This value entry contains mode data for nv5m64
    //       nvvanta_modes  -> This value entry contains mode data for nvvanta
    //       etc...
    //
    // 2) When ..\NVx\device0 is found, all the mode data will be read from the
    //    registry into the global mode data tables:
    //
    //       NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       etc....
    //
    // 3) For each device, the mode data for the corresponding chip
    //    type is copied into the ValidModeData in the device's
    //    hwDeviceExtension->ValidModeTable[]
    //  
    //**************************************************************************
                    
    //**************************************************************************
    // Init the global modedata tables with an 0xFFFF terminator.
    // That way, we can tell if the mode registry data was sucessfully copied.
    // (This could happen if the driver was not properly installed, using an
    // INF without mode table data)
    //
    // We ONLY initialize these mode tables the first time the driver is initialized.
    // We can tell by looking at the first entry, which should be 8bpp, width=640,
    // height=480).
    //**************************************************************************

    if ( !( (NV4_registry_data[0] == 8) && (NV4_registry_data[1] == 640) && (NV4_registry_data[2] == 480) && (NV4_registry_data[3] == 60)) )
        {    
        NV4_registry_data[0]        = 0xFFFF ;
        NV5_registry_data[0]        = 0xFFFF ;
        NV0A_registry_data[0]       = 0xFFFF ;
        NVVANTA_registry_data[0]    = 0xFFFF ; 
        NV5M64_registry_data[0]     = 0xFFFF ;
        NV5ULTRA_registry_data[0]   = 0xFFFF ; 
        NV10_registry_data[0]       = 0xFFFF ;
        NV10DDR_registry_data[0]    = 0xFFFF ;
        NV10GL_registry_data[0]     = 0xFFFF ;

        NV11_registry_data[0]       = 0xFFFF ;
        NV11DDR_registry_data[0]    = 0xFFFF ;
        NV11M_registry_data[0]      = 0xFFFF ;
        NV11GL_registry_data[0]     = 0xFFFF ;

        NV15_registry_data[0]       = 0xFFFF ;
        NV15DDR_registry_data[0]    = 0xFFFF ;
        NV15BR_registry_data[0]     = 0xFFFF ;
        NV15GL_registry_data[0]     = 0xFFFF ;

        NV20_registry_data[0]       = 0xFFFF ;
        NV20_1_registry_data[0]     = 0xFFFF ;
        NV20_2_registry_data[0]     = 0xFFFF ;
        NV20_3_registry_data[0]     = 0xFFFF ;

            
        //*********************************************************************
        // Now copy the registry data per each specific chip type
        // and copy it into our mode tables
        //*********************************************************************

        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV4_MODES",         &(NV4_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5_MODES",         &(NV5_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV0A_MODES",        &(NV0A_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NVVANTA_MODES",     &(NVVANTA_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5M64_MODES",      &(NV5M64_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5ULTRA_MODES",    &(NV5ULTRA_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10_MODES",        &(NV10_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10DDR_MODES",     &(NV10DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10GL_MODES",      &(NV10GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11_MODES",        &(NV11_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11DDR_MODES",     &(NV11DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11M_MODES",       &(NV11M_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11GL_MODES",      &(NV11GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15_MODES",        &(NV15_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15DDR_MODES",     &(NV15DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15BR_MODES",      &(NV15BR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15GL_MODES",      &(NV15GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_MODES",        &(NV20_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_1_MODES",      &(NV20_1_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_2_MODES",      &(NV20_2_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_3_MODES",      &(NV20_3_registry_data[0] ));



        }
    
    //**************************************************************************
    // 
    // GTFTimingTable Format in vesadata.c (ulong values):
    //
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //
    // Registry Data Format (word values)
    //
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  etc...    
    //  0,
    //
    // ValidModeTable[]  (2 bytes each data item)
    //
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  ..
    //  ..
    //   
    //**************************************************************************

    //**************************************************************************
    // This variable is used to keep track of how many modes
    // are initially specified in the REGISTRY.  These modes will 
    // be trimmed down further according to the amount of video memory on the card.
    // The final number of modes available will be stored in 
    //
    //  hwDeviceExtension->NumAvailableModes;
    //
    //**************************************************************************

    HwDeviceExtension->NumRegistryModes=0;

    //**************************************************************************
    // We allow modes according to the following:
    //
    //    1) What modes are actually available in vesadata.c (in the GTFTimingTable)
    //       We use the GTF table because it's a superset of the DMT table,
    //       in terms of the modes which are supported
    //    2) What modes are specified in the registry
    // 
    //**************************************************************************

    NumGTFModes =  (USHORT)vesaGetNumGTFEntries();

    //**************************************************************************
    // Get ptr to valid mode table (which we build here)
    //**************************************************************************

    ValidModePtr            = &(HwDeviceExtension->ValidModeTable[0]);
    BaseOfValidModeTable    = &(HwDeviceExtension->ValidModeTable[0]);

    //**************************************************************************
    // Build the ValidModeTable.  
    //
    // We allow modes which are:
    //
    //      1) Available in the GTFTimingTable    AND 
    //      2) Specified in the registry
    //
    // The GTF table does NOT specify depths.  The registry data DOES specify bit depths.
    // 
    // NOTE: If for some reason, the mode table was NOT initialized
    //       (ie...the mode table was not found in the registry), we'll
    //       default to ALL modes specified in the GTFTimingTable
    //
    //**************************************************************************

    //**************************************************************************
    // Determine which mode table to use
    //**************************************************************************

    switch (HwDeviceExtension->ulChipID)

        {
        case NV4_DEVICE_NV4_ID:

            RegDataPtr = &NV4_registry_data[0];                                    
            break;

        case NV5_DEVICE_NV5_ID:

            RegDataPtr = &NV5_registry_data[0];                                    
            break;

        case NV0A_DEVICE_NV0A_ID:

            RegDataPtr = &NV0A_registry_data[0];                                    
            break;

        case NV5VANTA_DEVICE_NV5VANTA_ID:

            RegDataPtr = &NVVANTA_registry_data[0];                                    
            break;

        case NV5MODEL64_DEVICE_NV5MODEL64_ID:

            RegDataPtr = &NV5M64_registry_data[0];                                    
            break;

        case NV5ULTRA_DEVICE_NV5ULTRA_ID:

            RegDataPtr = &NV5ULTRA_registry_data[0];                                    
            break;

        case NV10_DEVICE_NV10_ID:

            RegDataPtr = &NV10_registry_data[0];                                    
            break;

        case NV10DDR_DEVICE_NV10DDR_ID:

            RegDataPtr = &NV10DDR_registry_data[0];                                    
            break;

        case NV10GL_DEVICE_NV10GL_ID:

            RegDataPtr = &NV10GL_registry_data[0];                                    
            break;

        case NV11_DEVICE_NV11_ID:

            RegDataPtr = &NV11_registry_data[0];                                    
            break;

        case NV11DDR_DEVICE_NV11DDR_ID:

            RegDataPtr = &NV11DDR_registry_data[0];                                    
            break;

        case NV11M_DEVICE_NV11M_ID:

            RegDataPtr = &NV11M_registry_data[0];                                    
            break;

        case NV11GL_DEVICE_NV11GL_ID:

            RegDataPtr = &NV11GL_registry_data[0];                                    
            break;


        case NV15_DEVICE_NV15_ID:

            RegDataPtr = &NV15_registry_data[0];                                    
            break;

        case NV15DDR_DEVICE_NV15DDR_ID:

            RegDataPtr = &NV15DDR_registry_data[0];                                    
            break;

        case NV15BR_DEVICE_NV15BR_ID:

            RegDataPtr = &NV15BR_registry_data[0];                                    
            break;


        case NV15GL_DEVICE_NV15GL_ID:

            RegDataPtr = &NV15GL_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_ID:

            RegDataPtr = &NV20_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_1_ID:

            RegDataPtr = &NV20_1_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_2_ID:

            RegDataPtr = &NV20_2_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_3_ID:

            RegDataPtr = &NV20_3_registry_data[0];                                    
            break;

        default:

            RegDataPtr = &NV4_registry_data[0];                                    
            break;

        }

    #ifndef ENABLE_COMMON_MODESET_CODE
    //**************************************************************************
    // Check if the registry data was never read in
    // (i.e...the modetable wasn't installed in the registry for some reason)
    //**************************************************************************

    if (*RegDataPtr == 0xffff)
    
        {
        //**********************************************************************
        // Default to allowing ALL MODES specified in the vesa GTF timing table
        //**********************************************************************

        i=0;
        GTFModePtr = &(GTFTimingTable[i][0]);

        //**********************************************************************
        // But first, we need to make sure 640x480 8bpp 60Hz mode is specified first
        // (At some point in time, it seemed that this was a requirement)
        //**********************************************************************

        *ValidModePtr      = TRUE;              // Force first mode to be
        *(ValidModePtr+1)  = 640;               // 640x480x8bpp 60Hz
        *(ValidModePtr+2)  = 480;               //
        *(ValidModePtr+3)  = 8;                 //
        *(ValidModePtr+4)  = 60;                //
        ValidModePtr +=5;                       

        *ValidModePtr      = TRUE;              // Force first mode to be
        *(ValidModePtr+1)  = 640;               // 640x480x8bpp 60Hz
        *(ValidModePtr+2)  = 480;               //
        *(ValidModePtr+3)  = 16;                 //
        *(ValidModePtr+4)  = 60;                //
        ValidModePtr +=5;                       

        *ValidModePtr      = TRUE;              // Force first mode to be
        *(ValidModePtr+1)  = 640;               // 640x480x8bpp 60Hz
        *(ValidModePtr+2)  = 480;               //
        *(ValidModePtr+3)  = 32;                 //
        *(ValidModePtr+4)  = 60;                //
        ValidModePtr +=5;                       

        HwDeviceExtension->NumRegistryModes+=3;
    
        //**********************************************************************
        // Specify all modes from GTF table
        //**********************************************************************

        while ( i < NumGTFModes) 
            {                                                       
            //******************************************************************
            // Get width,height,refresh from GTF table
            //******************************************************************

            GTFWidth = (U016)(*(GTFModePtr));           // Get Width from GTF
            GTFHeight = (U016)(*(GTFModePtr+1));        // Get Height from GTF
            GTFRefresh = (U016)(*(GTFModePtr+2));       // Get Refresh*100
            GTFRefresh /= 100;                          // Normalize the value
                                   
            //******************************************************************
            // Skip the first mode (640x480 8bpp 60hz)
            //
            // Also, NT4 can only handle a max of about 295 modes.
            // So, if the registry mode table was NOT found, then
            // we specify a default list of available modes.
            // (This is the lowest common denominator of modes supported for NV4)
            //******************************************************************

            if (  !((GTFWidth == 640) && (GTFHeight == 480) && (GTFRefresh == 60))  &&
                   (  ((GTFWidth == 640)  &&  (GTFHeight == 480)  && (GTFRefresh >  60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 320)  &&  (GTFHeight == 200)  && (GTFRefresh >  60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 320)  &&  (GTFHeight == 240)  && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 400)  &&  (GTFHeight == 300)  && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 480)  &&  (GTFHeight == 360)  && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 512)  &&  (GTFHeight == 384)  && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 640)  &&  (GTFHeight == 400)  && (GTFRefresh >  60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 800)  &&  (GTFHeight == 600)  && (GTFRefresh >= 60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 1024) &&  (GTFHeight == 768)  && (GTFRefresh >= 60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 1152) &&  (GTFHeight == 864)  && (GTFRefresh >= 60) && (GTFRefresh <= 120))  ||
                      ((GTFWidth == 1280) &&  (GTFHeight == 1024) && (GTFRefresh >= 60) && (GTFRefresh <= 100))  ||
                      ((GTFWidth == 1600) &&  (GTFHeight == 1200) && (GTFRefresh >= 60) && (GTFRefresh <= 75))   ||
                      ((GTFWidth == 1920) &&  (GTFHeight == 1080) && (GTFRefresh >= 60) && (GTFRefresh <= 72))   ||
                      ((GTFWidth == 1920) &&  (GTFHeight == 1200) && (GTFRefresh >= 60) && (GTFRefresh <= 60))  )    )
                {
            
                //**************************************************************
                // Generate 8bpp entry for this refresh rate
                //**************************************************************
    
                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = GTFWidth;          // Width
                *(ValidModePtr+2)  = GTFHeight;         // Height
                *(ValidModePtr+3)  = 8;                 // Depth                                                                 
                *(ValidModePtr+4)  = GTFRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode
    
                HwDeviceExtension->NumRegistryModes++;
    
                //**************************************************************
                // Generate 16bpp entry for this refresh rate
                //**************************************************************
    
                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = GTFWidth;          // Width
                *(ValidModePtr+2)  = GTFHeight;         // Height
                *(ValidModePtr+3)  = 16;                // Depth                                                                 
                *(ValidModePtr+4)  = GTFRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode
    
                HwDeviceExtension->NumRegistryModes++;
    
                //**************************************************************
                // Generate 32bpp entry for this refresh rate
                //**************************************************************
    
                RegDepth = 32;
                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = GTFWidth;          // Width
                *(ValidModePtr+2)  = GTFHeight;         // Height
                *(ValidModePtr+3)  = 32;                // Depth                                                                 
                *(ValidModePtr+4)  = GTFRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode
    
                HwDeviceExtension->NumRegistryModes++;
    
    
                //**************************************************************
                // DEBUG safety check
                // Make sure we never go past the end of the
                // allocated valid mode table. (back off 30 words from end of table)
                //**************************************************************
    
                if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2)) )
                    {
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                    }
                }
                
                   
            //******************************************************************
            // Advance to next GTF entry
            // (12 items per each mode entry in the GTF timing table)
            //******************************************************************

            GTFModePtr += 12;
            i++;

            }


        //**********************************************************************
        // Now sort the valid modes...(we'll use a simple bubble sort routine)
        //**********************************************************************

        PModePtr = (PMODE_ENTRY)BaseOfValidModeTable;

        //**********************************************************************
        // Skip the first 640x480 mode, we always want it to be first
        //**********************************************************************

        PModePtr++;                         

        //**********************************************************************
        // Sort the modes from smallest height to largest height
        // Skip the first (640x480 mode), keep it at the beginning.
        //**********************************************************************

        BubbleSort(HwDeviceExtension, PModePtr , HwDeviceExtension->NumRegistryModes - 1);

        

        
        }
    #endif ENABLE_COMMON_MODESET_CODE
        

    //**************************************************************************
    // Parse each line from the registry.
    // For each refresh rate (of each mode), check if the refresh is present in the
    // vesa data table.  If so, then it's a valid mode. 
    // Registry data is terminated with 0xffff
    //**************************************************************************

    while (*RegDataPtr != 0xffff)
        {
        RegDepth   = *(RegDataPtr);             // Get Depth from registry
        RegWidth   = *(RegDataPtr+1);           // Get Width from registry
        RegHeight  = *(RegDataPtr+2);           // Get Height from registry

        //**********************************************************************
        // Advance to the registry refresh rates for this particular mode
        //**********************************************************************

        RegDataPtr+=3;

        //**********************************************************************
        // Each mode entry in the registry data is NULL terminated.
        // Parse all refresh rates for this mode, and see if they're
        // also present in the vesadata GTF timing table
        //**********************************************************************

        while (*RegDataPtr !=0)
            {        
            RegRefresh  = *(RegDataPtr++);      // Get Refresh from registry data

            //******************************************************************
            // Search the vesa GTF table to see if this mode is supported
            //******************************************************************

            i=0;
            GTFModePtr = &(GTFTimingTable[i][0]);
            FoundRefreshFlag = FALSE;              

            while ( (i<NumGTFModes) && (FoundRefreshFlag == FALSE) )
                {                                                       
                //**************************************************************
                // Get width,height,refresh from GTF table
                //**************************************************************

                GTFWidth = (U016)(*(GTFModePtr));           // Get Width from GTF
                GTFHeight = (U016)(*(GTFModePtr+1));        // Get Height from GTF
                GTFRefresh = (U016)(*(GTFModePtr+2));       // Get Refresh*100
                GTFRefresh /= 100;                          // Normalize the value
                                   
                //**************************************************************
                // See if we found a match in the GTF table
                //**************************************************************

                if (MULTIMON_MODE(RegWidth, RegHeight)) 
                    {
                    if (HORIZONTAL_MODE(RegWidth, RegHeight))
                        {
                            widthDivide = 2;
                            heightDivide = 1;
                        }
                    else
                        {
                        if (VERTICAL_MODE(RegWidth, RegHeight))
                            {
                            widthDivide = 1;
                            heightDivide = 2;
                            }
                        }
                    }
                        
#ifndef ENABLE_COMMON_MODESET_CODE
                if ( (GTFWidth == RegWidth/widthDivide) && (GTFHeight == RegHeight/heightDivide) && (GTFRefresh == RegRefresh) &&
                     ((RegDepth == 8) || (RegDepth == 16) || (RegDepth == 32)) )
#endif
            
                    {
                    //**********************************************************
                    // Generate 8bpp entry for this refresh rate
                    //**********************************************************

                    *ValidModePtr      = TRUE;              // Valid Flag
                    *(ValidModePtr+1)  = RegWidth;          // Width
                    *(ValidModePtr+2)  = RegHeight;         // Height
                    *(ValidModePtr+3)  = RegDepth;          // Depth                                                                 
                    *(ValidModePtr+4)  = RegRefresh;        // Refresh                                                               
                    ValidModePtr +=5;                       // Next Valid Mode

                    //**********************************************************
                    // Keep track of how many modes have currently been specified
                    //**********************************************************

                    HwDeviceExtension->NumRegistryModes++;

                    //**********************************************************
                    // DEBUG safety check
                    // Make sure we never go past the end of the
                    // allocated valid mode table. (back off 30 words from end of table)
                    //**********************************************************

                    if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2) ))
                        {
                        VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                        }
                
                    FoundRefreshFlag = TRUE;
                    }
                
                //**************************************************************
                // Advance to next GTF entry
                // (12 items per each mode entry in the GTF timing table)
                //**************************************************************

                GTFModePtr += 12;
                i++;


                } // while (i < NumGTFModes)...
                
            } // while (*RegDataPtr !=0)...


        //**********************************************************************
        // Skip past null terminator
        //**********************************************************************

        RegDataPtr++;
                
        } // while (*RegDataPtr != 0xffff)...

    
    // Print the master mode list for debugging purposes.
    {
        MODE_ENTRY *PModeEntry;
        VideoDebugPrint((7,"buildAvailableModes(): Printing Master Mode List: NumRegstryModes: %d\n", HwDeviceExtension->NumRegistryModes));
        RegDataPtr = &HwDeviceExtension->ValidModeTable[0];
    
         
        for (i=0; i < HwDeviceExtension->NumRegistryModes; i++)
        {
            VideoDebugPrint((7,"%d, (%d, %d), %d bpp, %d HZ\n",
                            *(RegDataPtr + 0),
                            *(RegDataPtr + 1),
                            *(RegDataPtr + 2),
                            *(RegDataPtr + 3),
                            *(RegDataPtr + 4)));
           RegDataPtr += 5;
        }
        VideoDebugPrint((7,"End.................\n"));
    }

#ifdef ENABLE_COMMON_MODESET_CODE
        // Read in the Monitor restriction mode lists for each head.
        ReadMonitorRestrictionModeList (HwDeviceExtension);
#endif

                
    }




//******************************************************************************
//
// Function:   NV_ReadAndCopyRegistryData
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_ReadAndCopyRegistryData(
PHW_DEVICE_EXTENSION HwDeviceExtension,
WCHAR *ModeDataNameStr,
U016 *DstRegDataPtr)

    {
    U016 *SrcRegDataPtr;
    ULONG status;
        
    //**************************************************************************
    // Parse INF and determine which modes to support
    //
    // WARNING:  When reading modetable registry data, the registry callback
    //           routine gets called SEVERAL times for each modetable. That is,
    //           it does NOT get called once for each table as one would expect.
    //           Instead, the registry callback routine gets called for EACH line
    //           appended to the string.  But the CONTEXT ptr does NOT automatically
    //           get incremented.  So we'll have to keep track of it MANUALLY,
    //           so we can continue storing data from where we last left off.
    //           See the registry callback function for more information.
    //**************************************************************************

    HwDeviceExtension->RegistryDataOffset = 0;

    //**************************************************************************
    // The NVx_MODES modetable entries for each chip type will always be stored 
    // in the \device0 key, since the INF doesn't appear to be able to store them
    // in device1,device2, etc...   As a result, we always store and get modetable
    // registry data from the \device0 key for ALL chip types, and then save them
    // off in global mode tables. Essentially, all modetable registry data will
    // only be read when the FIRST nv device is found.   
    //    
    // That is, VideoPortGetRegistryParameters() will SUCCEED when reading the
    // mode table value entries from \device0, but will FAIL when it tries 
    // to read them from \device1\2\3...because the modetable entries won't be present!
    //
    // We use global modedata tables, so that we can copy modetable data
    // into the hwdeviceextension of each device found.
    //
    // The following is a simplified explanation:
    //
    // 1) hkey_local_machine\system\currentcontrolset\services\nv4\device0\
    //      
    //       nv4_modes      -> This value entry contains mode data for nv4
    //       nv5_modes      -> This value entry contains mode data for nv5
    //       nv5m64_modes   -> This value entry contains mode data for nv5m64
    //       nvvanta_modes  -> This value entry contains mode data for nvvanta
    //       etc...
    //
    // 2) When nvx\device0 is found, all the mode data will be read from the
    //    registry into the global mode data tables:
    //
    //       NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       etc....
    //
    // 3) For each device, the mode data for the corresponding chip
    //    type is copied into the ValidModeData in the device's
    //    hwDeviceExtension->ValidModeTable[]
    //  
    //**************************************************************************

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       ModeDataNameStr,
                                       FALSE,
                                       NVRegistryCallback,
                                       &registry_data[0]);

    if (status == NO_ERROR)
        {
        //**********************************************************************
        // Terminate the temporary registry data buffer with 0xffff !
        //**********************************************************************

        registry_data[HwDeviceExtension->RegistryDataOffset / 2] = 0xffff;

        //**********************************************************************
        // Now copy the registry data per specific chip type
        //**********************************************************************
        
        SrcRegDataPtr= &(registry_data[0]);
        
        while (*SrcRegDataPtr != 0xffff)
            {
            *DstRegDataPtr = *SrcRegDataPtr;// Copy the data
            
            DstRegDataPtr++;
            SrcRegDataPtr++;            
            }
    
        *DstRegDataPtr = 0xffff;           // Null terminate the list

        }
    else
        {
        //**********************************************************************
        // Error Case (when VideoPortGetRegistryParameters fails because
        // the ValueEntry for the mode data is NOT present)
        //
        // The NVx_MODES keys are only located in the \device0 key.
        // That is, ALL the registry mode data tables are copied when the FIRST
        // device is installed.  When additional instances of the adapter
        // are found, we don't no need to do anything since we've already
        // copied the data.
        //**********************************************************************
        
        }


    }
                                




//******************************************************************************
//
// Function:   BubbleSort
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID BubbleSort(
PHW_DEVICE_EXTENSION HwDeviceExtension,
PMODE_ENTRY BaseModePtr,
ULONG NumModes)

    {

    ULONG i,j;
    PMODE_ENTRY LeftModePtr, RightModePtr;
    MODE_ENTRY TempMode;


    //**************************************************************************
    // Sort by height
    //**************************************************************************

    for (i=0; i < NumModes; i++)
        {
        for (j=NumModes-1; j > i; j--)
            {
            LeftModePtr  = &BaseModePtr[j-1];
            RightModePtr = &BaseModePtr[j];                

            if (LeftModePtr->Height > RightModePtr->Height)
                {
                //**************************************************************
                // Swap mode entries, smaller modes first
                //**************************************************************
                
                TempMode = (*LeftModePtr);
                (*LeftModePtr)  = (*RightModePtr);
                (*RightModePtr) = TempMode;
                
                }

            }
            
        }


    //**************************************************************************
    // Sort by depth
    //**************************************************************************

    for (i=0; i < NumModes; i++)
        {
        for (j=NumModes-1; j > i; j--)
            {
            LeftModePtr  = &BaseModePtr[j-1];
            RightModePtr = &BaseModePtr[j];                

            if (LeftModePtr->Depth > RightModePtr->Depth)
                {
                //**************************************************************
                // Swap mode entries, smaller depths first
                //**************************************************************
                
                TempMode = (*LeftModePtr);
                (*LeftModePtr)  = (*RightModePtr);
                (*RightModePtr) = TempMode;
                
                }

            }
            
        }
        
        
        
    }
    

//******************************************************************************
//
// Function:   NV_OEMEnableExtensions
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    U008 lock;

    //**************************************************************************
    // For NV4, registers are locked using the NV_CIO_SR_LOCK register
    // (That is,the locking mechanism has been moved to CRTC register space,
    // where it should have been in the first place).  We need to
    // use the NV4_REF header file, so this function is locatedin NV4.C
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);


    }


//******************************************************************************
//
// Function:   NV4 OEMDisableExtensions
//
// Routine Description:
//
//    Lock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_OEMDisableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    U008 lock;

    //**************************************************************************
    // For NV4, registers are locked using the NV_CIO_SR_LOCK register
    // (That is,the locking mechanism has been moved to CRTC register space,
    // where it should have been in the first place).  We need to
    // use the NV4_REF header file, so this function is locatedin NV4.C
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);

    }


//******************************************************************************
//
// Function:   NV4_OEMSetRegs
//
// Routine Description:
//
//       OEMSetRegs - Set extended registers (standard VGA has been set)
//
//       Entry:  ES:DI = Standard VGA parameter pointer
//               DS = Seg0
//       Exit:   None
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_OEMSetRegs(MODEDESC *mi)
{
    U016  wv;                     // Write value{
    U016  i, c;
    U032   lwv;
    U032   lrv;
    U008   cv;

    //*************************************************************************
    // NV4 version of this function is slightly different than
    // the NV3 version. (565 mode and TV stuff)
    //*************************************************************************

    if (mi->mdCMode != 0xFF)        // Do we have a CRTC Override Table?
    {
        // Yep - program it
        WritePriv08(NV_PRMVIO_MISC__WRITE, crt_override[mi->mdCMode].CO_Misc);

        wv = crt_override[mi->mdCMode].CO_ClockMode;
        wv <<= 8;
        wv |= 0x01;
        WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01

        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);    // Read CR11
        wv &= 0x7FFF;               // Unlock CR0-7
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR11

        // Do CR0-CR8 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, 8, (U008 *)&(crt_override[mi->mdCMode].HTotal));

        wv = crt_override[mi->mdCMode].CO_CellHeight;
        wv <<= 8;
        wv |= 0x09;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR09

        // Do CR10-CR12 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x10, 0x03, (U008 *)&(crt_override[mi->mdCMode].CO_VSyncStart));

        // Do CR15-CR16 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x15, 0x02, (U008 *)&(crt_override[mi->mdCMode].CO_VBlankStart));
    }

    // Program Extended Registers

    wv = eregs[mi->mdEMode].xrOffset;
    wv <<= 13;
    wv &= 0xE000;                   // Clear start address bits
    wv |= 0x19;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR19

    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    wv &= 0xC0FF;                   // Preserve sync disables
    wv |= 0x3800;                   // Set reserved bits and text mode

    c = (eregs[mi->mdEMode].xrFlags);

    if (c & 0x01)
        wv |= 0x0100;               // Set address wrap

    i = (eregs[mi->mdEMode].xrVOver);
    i &= 0x20;
    i >>= 0x03;
    wv |= (i << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A

    // Default Fifo
    wv = 0x011B;                    // Default CR1B value for VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A

    wv = c;
    wv &= 0x06;
    wv <<= 8;
    wv |= 0x1C;                     // CR1C

    i = (eregs[mi->mdEMode].xrPixFmt);
    i &= 0x30;                      // Mask off chain-4 optimize bits
    i >>= 1;            // (shr 4-3?)

    wv |= (i << 8);                 // Set chain 4 optimize bits
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A


    wv = 0x001D;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1D

    wv = 0x001E;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1E

    wv = 0x1020;                    // Fifo Setting for Standar VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set low water mark at CR20

    c = (eregs[mi->mdEMode].xrVOver); // Vertical Overflow
    c &= 0x1F;                      // Mask our bits

    i = (eregs[mi->mdEMode].xrOffset);
    i &= 0x08;                      // Bit 3
    i <<= 2;                        // Move to bit 5
    c |= i;
    wv =  (c << 8) | 0x25;          // Write data to CR25
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR25


    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv &= 0xF8FF;                   // Preserve sync disables

    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0x07;                      // Set bits [2:0] - clear rest
    wv |= (c << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR28

    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0xC0;
    c >>= 6;

    i = eregs[mi->mdEMode].xrVOver;
    i &= 0xC0;
    i >>= 4;
    c |= i;
    wv = ((c << 8) | 0x2D);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR2D

    wv = 0x29;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
    wv = 0x2A;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);


    //**************************************************************************
    // Don't touch CR33 if we're on a flat panel
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

        // Do CR29-32
        for (i = 0x30; i <= 0x32; i++)
            {
            wv = (U016)i;
            WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
            }

        }

    else

        {


        // Do CR29-33
        for (i = 0x30; i <= 0x33; i++)
            {
            wv = (U016)i;
            WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
            }

        }


    wv = (((eregs[mi->mdEMode].xrIntlace) << 8) | 0x39);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

    //**************************************************************************
    // Don't set clock if we're on a flat panel
    //**************************************************************************

    //OEMSetClock(eregs[mi->mdEMode].xrClkSel);
    if (HwDeviceExtension->FlatPanelIsPresent != TRUE)
        OEMSetClock(tblClockFreq[eregs[mi->mdEMode].xrClkSel]);

    wv = (((eregs[mi->mdEMode].xrVOffset) << 8) | 0x13);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

    //**************************************************************************
    // No TV support yet for NV class chips
    //**************************************************************************

//    if (isTV())

    if (HwDeviceExtension->TvIsPresent)

        {
            NV4_ProgramTV( mi->mdTVMode );
        }

#if 0
    //
    // Set VCLK divide by 2 setting
    //
    wv = (eregs[mi->mdEMode].xrPixFmt);
    lwv = (U032)(wv & 0x08);

    lwv <<= (DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO) - 3);

    // Read current coefficient
    //
    // Note that this code preserves the VPLL_BYBASS bit which is nessesary for TV
    lrv = ReadPriv32(NV_PRAMDAC_PLL_COEFF_SELECT);

    // Mask off the bits we'll use.
    //
    // NOTE: Careful: the BIT definitions have CHANGED from NV3 to NV4 !!!!
    //
    lrv &= (U032)(((U032)(1L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO)) |
           ((U032)(1L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE))) |
           ((U032)(7L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE)))) ^ -1L);

    lrv |= lwv;         // Set the VCLK Ratio

    // Now we have to set to programmed VPLL based on XTAL
    //
    // NOTE: Careful: the BIT definitions have CHANGED from NV3 to NV4 !!!!
    //
    lrv |= (U032)(2L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE));

    WritePriv32(lrv, NV_PRAMDAC_PLL_COEFF_SELECT);
#endif


    //**************************************************************************
    // If flat panel, we may need to adjust CRTC's
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)

        FlatPanelCrtc(mi->mdXRes);

    else

        WritePriv32(0x10000700, NV_PRAMDAC_PLL_COEFF_SELECT);

    //**************************************************************************
    // If flat panel, leave DAC alone
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent != TRUE)

        {

        lrv = ReadPriv32(NV_PRAMDAC_GENERAL_CONTROL);

        lrv &= (U032)(((1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE)) |
                 (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE)) |
                 (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC))) ^ -1L);

        lrv |= (U032)(1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE));

        wv = (eregs[mi->mdEMode].xrOffset);
        lwv = (U032)(wv & 0x80);       // Set 565 Mode

        lwv <<= (DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE) - 7L);

        lrv |= lwv;

        cv = (eregs[mi->mdEMode].xrFlags);
        cv ^= (U008)-1;
        cv &= 0x08;                 // Isolate DAC width

        lwv = (U032)(cv);          // Dac Width
        lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC) - 3L);

        lrv |= lwv;

        cv = (eregs[mi->mdEMode].xrPixFmt);
        cv ^= (U008)-1;                   // Invert
        cv &= 0x02;                 // Isolate index/gamma bit

        lwv = (U032)(cv);

        //KJK lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE) - 1L);
        lrv |= lwv;

        WritePriv32(lrv, NV_PRAMDAC_GENERAL_CONTROL);

        // Disable tiling
        lrv = ReadPriv32(NV_PFB_CONFIG_0);
        lrv &= (U032)((1L << DRF_SHIFT(NV_PFB_CONFIG_0_TILING)) ^ -1L);
        lrv |= (NV_PFB_CONFIG_0_TILING_DISABLED << DRF_SHIFT(NV_PFB_CONFIG_0_TILING));

        //**********************************************************************
        // Do NOT touch this register for NV10 !!
        //**********************************************************************

        if ( !((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
               (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
               (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
               (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
               (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
               (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID)))

            {
               WritePriv32(lrv, NV_PFB_CONFIG_0);
            }
            

        }


    WritePriv08(NV_PRMCIO_CRX__COLOR, 0x18);    // Select CR18 (why?)


}



//******************************************************************************
//
// Function:   NV4_ProgramTV
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_ProgramTV(U008 tvmode)

    {
    // TODO:
    }


//******************************************************************************
//
// Function:   NVGetMonitorType
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVGetMonitorType(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG result;
    PHWINFO NVInfo;
    NV_CFGEX_GET_EDID_PARAMS EdidParams;
    ULONG EdidBufferSize;
    
        
    //**************************************************************************
    // Get ptr to NVInfo structure 
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    
    //**************************************************************************
    // Ask the RM what's attached to the card (Flat Panel/Monitor/ or TV)
    //**************************************************************************

    HwDeviceExtension->TvIsPresent              = FALSE;
    HwDeviceExtension->FlatPanelIsPresent       = FALSE; 

    //**************************************************************************
    // By default, a standard VGA monitor is attached.
    // Check if either a Flat Panel or TV is attached
    //**************************************************************************

    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_MONITOR_TYPE ,&result) ;

    if (result == MONITOR_TYPE_FLAT_PANEL)
        {
        HwDeviceExtension->FlatPanelIsPresent   = TRUE;

        //**********************************************************************
        // Get max resolution supported by this display type
        //**********************************************************************

        RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_SCREEN_MAX_WIDTH ,&HwDeviceExtension->MaxFlatPanelWidth) ;

        RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_SCREEN_MAX_HEIGHT ,&HwDeviceExtension->MaxFlatPanelHeight) ;

        }

    // GK: HACKHACK: Temporary. Once we verify the EDID info per head, we don't need any of this MaxFlatPanelWidth stuff.
    if (HwDeviceExtension->MaxFlatPanelWidth == 0)
    {
        HwDeviceExtension->MaxFlatPanelWidth = 1024;
    }
    if (HwDeviceExtension->MaxFlatPanelHeight == 0)
    {
        HwDeviceExtension->MaxFlatPanelHeight = 768;
    }


    if ((result == MONITOR_TYPE_NTSC) || (result == MONITOR_TYPE_PAL))
        HwDeviceExtension->TvIsPresent          = TRUE;

    //**************************************************************************
    // This TV code used to work on NV3.. Need to test on NV4 or better...
    //**************************************************************************

   if (HwDeviceExtension->TvIsPresent)                // NO TV support yet !
       {
       // don't diff between NTSC & PAL for now
       NVInfo->Framebuffer.MonitorType = NV_MONITOR_NTSC;

       // Preset the default values
       NVInfo->Framebuffer.Underscan_x = DST_X_RES;
       NVInfo->Framebuffer.Scale_x = X_RES << 20;
       NVInfo->Framebuffer.Scale_x /= NVInfo->Framebuffer.Underscan_x;

       NVInfo->Framebuffer.Underscan_y = DST_Y_RES;
       NVInfo->Framebuffer.Scale_y = Y_RES << 20;
       NVInfo->Framebuffer.Scale_y /= NVInfo->Framebuffer.Underscan_y;

       // No filtering needed for NV5 or better
       NVInfo->Framebuffer.FilterEnable = 0;
       }
    else
       {
       NVInfo->Framebuffer.MonitorType = NV_MONITOR_VGA;

       // If filtering gets enabled for VGA, assume 1:1 scaling
       NVInfo->Framebuffer.Underscan_x = X_RES;
       NVInfo->Framebuffer.Scale_x = (1 << 20);        // default to 1:1

       NVInfo->Framebuffer.Underscan_y = Y_RES;
       NVInfo->Framebuffer.Scale_y = (1 << 20);

       // Assume filtering is disabled
       NVInfo->Framebuffer.FilterEnable = 0;
       }



    }

//******************************************************************************
//
// Function:   NV_FixLowWaterMark
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_FixLowWaterMark(U016 clock)

    {
    U016  wv;
    U032   lwv;
    U016  i;
    U032  clockMHz;

    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv >>= 8;
    wv &= 0x03;       // mask pixel format bits

    // Check dac format
    if (wv)
        {
        wv--;
        clockMHz = clock;
        clockMHz <<= (U008)wv;
        clockMHz /= 100;

        for (i = 0; clockMHz > DACFifoTable[i].Freq ; i++)
            ;   // Find the proper FIFO value
        
        if  ( (HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
              (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
              (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
              (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
              (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
              (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        
            {
            // for NV10, bit 4 is the 128-bit bit.
            lwv = ReadPriv32(NV_PFB_CFG) & 0x00000010L;
            }
        else
            {
            // Bit 2 is the 128-bit bit.
            lwv = ReadPriv32(NV_PFB_BOOT_0) & 0x00000004L;
            }

        if (lwv)
            {
            // 128 bit
            // Do WV first, as I get's blown away
            wv = ((DACFifoTable[i].LowWaterMark128) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize128) << 8) | 0x1B;

            }
        else
            {
            // 64 bit
            wv = ((DACFifoTable[i].LowWaterMark64) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize64) << 8) | 0x1B;
            }

        WriteIndexed(NV_PRMCIO_CRX__COLOR, i);
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
        }
    }





//******************************************************************************
//
// Function:   NV_OEMGetMemSize
//
// Routine Description:
//
//
//       OEMGetMemSize - Return the pre-calculated memory size
//
//       Entry:  None
//       Exit:   AX = Number of 64K blocks
//
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

U016 NV_OEMGetMemSize(VOID)
{
    U032 msize;
    U016 ms;


    if  ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
         (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
         (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
         (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
         (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
         (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
    {
        ms = (U016)(PFB_REG_RD32(PFB_Base,NV_PFB_CSTATUS) >> 16);
    }
    else
    {
        //*************************************************************************
        // NV4 version of this function is slightly different than
        // the NV3 version. (We want to use #DEFINES from NV4_REF for NV4,
        // and #DEFINES from NV3_REF for NV3)
        //*************************************************************************

        msize = ReadPriv32(NV_PFB_BOOT_0) & 0x00000003;
        ms = (U016)msize;

        if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_4MB)
            ms = 64;            // 4MB
        else if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_8MB)
            ms = 128;           // 8MB
        else if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_16MB)
            ms = 256;           // 16MB
        else
            ms = 512;           // 32Mb

        //**************************************************************************
        // Check for UMA usage
        //
        // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
        // bit fields to zero.
        //**************************************************************************

        if (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
        {
            switch (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA_SIZE))
            {
                case NV_PFB_BOOT_0_UMA_SIZE_2M:
                    ms = 2 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_4M:
                    ms = 4 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_6M:
                    ms = 6 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_8M:
                    ms = 8 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_10M:
                    ms = 10 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_12M:
                    ms = 12 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_14M:
                    ms = 14 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_16M:
                    ms = 16 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_18M:
                    ms = 18 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_20M:
                    ms = 20 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_22M:
                    ms = 22 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_24M:
                    ms = 24 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_26M:
                    ms = 26 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_28M:
                    ms = 28 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_30M:
                    ms = 30 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_32M:
                    ms = 32 << 4;
                    break;
            }
        }
    }

    return ms;

}




//******************************************************************************
//
// Function:   NV4_dacCalculateArbitration
//
// Routine Description:
//
//      Calculate the closest arbitration values for a given system configuration
//
//      NOTE: Please excuse this code.  In comes from the hardware group...
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4_dacCalculateArbitration
(
           nv4_fifo_info *fifo,
           nv4_sim_state  *arb
)
{
  int data, m,n,p, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int found, mclk_extra, mclk_loop, cbs, m1, p1;
  int xtal_freq, mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
  int craw, vraw;
  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width >> 6;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 0;
  cbs = 128;
  pclks = 2; // lwm detect.

  nvclks = 2; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)
  nvclks += 1; // fbi reqsync

  mclks = 5; // Fifo
  mclks += 3; // MA0 -> MA2
  mclks += 1; // pad->out
  mclks += cas; // Cas Latency.
  mclks += 1; // pad in
  mclks += 1; // latch data
  mclks += 1; // fifo load
  mclks += 1; // fifo write
  mclk_extra = 3; // Margin of error

  nvclks += 2; // fifo sync
  nvclks += 1; // read data
  nvclks += 1; // fbi_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
    if(video_enable) {
      video_drain_rate = pclk_freq * 2; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 2; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
      else
    video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;

      us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

      vlwm = us_video * video_drain_rate/(1000*1000);
      vlwm++; // fixed point <= float_point - 1.  Fixes that
      vbs = 128;

      if(vlwm > 128) vbs = 64;
      if(vlwm > (256-64)) vbs = 32;

      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
      else
    video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
    us_video  // Wait for video
    +video_fill_us // Wait for video to fill up
    +cpm_us // CRT Page miss
    +us_m + us_n +us_p // other latency
    ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 2; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    }
    /*
      Overfill check:

      */

    m1 = clwm + cbs - 512; /* Amount of overfill */
    p1 = m1 * pclk_freq / mclk_freq; /* pclk cycles to drain */
    p1 = p1 * bpp / 8; // bytes drained.

    if((p1 < m1) && (m1 > 0)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
    }
    else if(video_enable){
      if((clwm > 511) || (vlwm > 255)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    } else {
      if(clwm > 519){ // Have some margin
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    }
    craw = clwm;
    vraw = vlwm;
    if(clwm < 384) clwm = 384;
    if(vlwm < 128) vlwm = 128;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->graphics_lwm = data;   fifo->graphics_burst_size = 128;
    //    fifo->craw = craw;

    data = (int)((vlwm+15));
    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = data;  fifo->video_burst_size = vbs;
  }
}



//******************************************************************************
//
// Function:   NV4_UpdateArbitrationSettings
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_UpdateArbitrationSettings
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{

    nv4_fifo_info fifo_data;
    nv4_sim_state sim_data;
    U008 i, lock;
    U032 M, N, O, P , crystal , NVClk, VClk;

    //
    // Determine current strap crystal frequency (in Hz)
    //
    if (PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
        crystal = 13500000;
    else if (PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
        crystal = 14318180;



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _PDIV);
    O = 1;

    HwDeviceExtension->NvInfo.Dac.MPllM = M;
    HwDeviceExtension->NvInfo.Dac.MPllN = N;
    HwDeviceExtension->NvInfo.Dac.MPllO = O;
    HwDeviceExtension->NvInfo.Dac.MPllP = P;
    if ( (!P) && (HwDeviceExtension->ulChipID == NV4_DEVICE_NV4_ID))
        P = 1;      // never really zero
    HwDeviceExtension->NvInfo.Dac.MClk  = (N * crystal / (1 << P) / M);



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;

    HwDeviceExtension->NvInfo.Dac.VPllM = M;
    HwDeviceExtension->NvInfo.Dac.VPllN = N;
    HwDeviceExtension->NvInfo.Dac.VPllO = O;
    HwDeviceExtension->NvInfo.Dac.VPllP = P;
    VClk = HwDeviceExtension->NvInfo.Dac.VClk  = (N * crystal / (1 << P) / M);



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _PDIV);
    O = 1;

    NVClk  = (N * crystal / (1 << P) / M);

    //
    // Last minute kludge to work around bug in NV4 arbitration
    // algorithm.
    //

    if (((HwDeviceExtension->NvInfo.Framebuffer.Depth < 16) && (VClk > 180000000)) ||
        ((HwDeviceExtension->NvInfo.Framebuffer.Depth == 16) && (VClk > 130000000)) ||
        ((HwDeviceExtension->NvInfo.Framebuffer.Depth > 16) && (VClk > 80000000)))
       HwDeviceExtension->bHwVidOvl = FALSE;
    else
        {
        //
        // Build the sim table as if hw video overlay was enabled
        //
        sim_data.pix_bpp        = (UCHAR)HwDeviceExtension->NvInfo.Framebuffer.Depth;
        sim_data.enable_video   = 1;
        sim_data.enable_mp      = 0;
        sim_data.memory_width   = HwDeviceExtension->NvInfo.Dac.InputWidth;;
        sim_data.mem_latency    = 3;
        sim_data.mem_aligned    = 1;
        sim_data.mem_page_miss  = 10;
        sim_data.gr_during_vid  = 0;
        sim_data.pclk_khz       = HwDeviceExtension->NvInfo.Dac.VClk / 1000;    // in kHz, not MHz
        sim_data.mclk_khz       = HwDeviceExtension->NvInfo.Dac.MClk / 1000;    // in kHz, not MHz
        sim_data.nvclk_khz      = NVClk / 1000;                                 // in kHz, not MHz

        //
        // Get those new numbers
        //
        NV4_dacCalculateArbitration(&fifo_data, &sim_data);
        HwDeviceExtension->bHwVidOvl = (fifo_data.valid != 0);
        }

    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (UCHAR)HwDeviceExtension->NvInfo.Framebuffer.Depth;
    sim_data.enable_video   = 0;
    sim_data.enable_mp      = 0;
    sim_data.memory_width   = HwDeviceExtension->NvInfo.Dac.InputWidth;;
    sim_data.mem_latency    = (char)PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _CAS_LATENCY); // 3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char)(PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _RAS_RAS)  +  PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _READ_TO_PCHG)); // 10
    sim_data.gr_during_vid  = 0;
    sim_data.pclk_khz       = HwDeviceExtension->NvInfo.Dac.VClk / 1000;    // in kHz, not MHz
    sim_data.mclk_khz       = HwDeviceExtension->NvInfo.Dac.MClk / 1000;    // in kHz, not MHz
    sim_data.nvclk_khz      = NVClk / 1000;                                 // in kHz, not MHz


    //
    // Get those new numbers
    //
    NV4_dacCalculateArbitration(&fifo_data, &sim_data);

    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size
        //
        PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
        switch (fifo_data.video_burst_size)
        {
            case 128:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 3);
                break;

            case 64:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 2);
                break;

            case 32:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 1);
                break;
        }


        //
        // Update the CRTC watermarks
        //
        // Unlock CRTC extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);

        //
        // Set the CRTC watermarks and burst size
        //
        CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.graphics_lwm >> 3);

        switch (fifo_data.graphics_burst_size)
        {
            case 256:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 4);
                break;

            case 128:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 3);
                break;

            case 64:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 2);
                break;

            case 32:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 1);
                break;

            case 16:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 0);
                break;
        }

        //
        // Relock if necessary
        //
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE);

        return;
    }
    else
        //
        // No valid setting was found!!!  Either we fail this configuration
        // or we live with the current default settings for this mode.
        //
        return;

}


//******************************************************************************
//
// Function:    NVEnableBusMastering()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVEnableBusMastering(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;

    //**************************************************************************
    // Make sure bus mastering is always ENABLED !!  (Bit 2)
    // Read current value then enable the bus_master bit.
    //**************************************************************************

    CurrentValue = REG_RD32(NV_PBUS_PCI_NV_1);
    CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_PCI_NV_1_BUS_MASTER));
    REG_WR32(NV_PBUS_PCI_NV_1,  CurrentValue);

    }

//******************************************************************************
//
// Function:    NVSaveSpecificRegistersForPwrMgmt()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;

    //**************************************************************************
    // This code was copied from ..\nvalloc\win9x\vxd\osapi.c 
    // for the case NVRM_API_POWER_DOWN:
    //**************************************************************************

    //**************************************************************************
    // Save off instance memory, mainly because the Win9x DX7 driver
    // allocates DMA contexts, but doesn't free them up. (One time init)
    // If we lose power , then all instance memory associated with those
    // DMA contexts are gone.  So we need to save instance mem here before we power down.
    //**************************************************************************
    NV4SaveInstanceMemory(HwDeviceExtension);

    //**************************************************************************
    // Save off miscellaneous registers not reloaded by RmLoadState
    //**************************************************************************

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        {
        NV10ChipFBPowerSave(HwDeviceExtension);
        }
                
    else

        {
        NV4ChipFBPowerSave(HwDeviceExtension);
        }

    }


//******************************************************************************
//
// Function:    NVRestoreSpecificRegistersForPwrMgmt()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;


    //**************************************************************************
    // Restore chip dependent FB power registers
    //**************************************************************************

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        {
        NV10ChipFBPowerRestore(HwDeviceExtension);
        }

    else
                    
        {
        NV4ChipFBPowerRestore(HwDeviceExtension);
        }


    //**************************************************************************
    // Save off instance memory, mainly because Win9x DX7 driver
    // allocates DMA contexts, but doesn't free them up.
    // If we lose power , then all instance memory associated with those
    // DMA contexts are gone.  So we need to save them here before we power down.
    //**************************************************************************
    NV4RestoreInstanceMemory(HwDeviceExtension);

    }


//******************************************************************************
//
// Function:    NV4ChipFBPowerSave()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4ChipFBPowerSave (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    // power down mode - max out memory refresh value
    HwDeviceExtension->Power_refresh = REG_RD32(NV_PFB_DEBUG_0);               // refresh
    FLD_WR_DRF_NUM(_PFB, _DEBUG_0, _REFRESH_COUNTX64, 0x01);       // max refresh
    // Chip has been init'd with the BIOS init tables, unless the BIOS
    // has an incompatible structure and the table was not found, in which case
    // we used a default table, which may not have the correct RAM config, so
    // we save away the current config for restoration above.
    HwDeviceExtension->Power_PfbBoot0     = REG_RD32(NV_PFB_BOOT_0);               // RAM config
    HwDeviceExtension->Power_PfbConfig0   = REG_RD32(NV_PFB_CONFIG_0);           // RAM config
    HwDeviceExtension->Power_PfbConfig1   = REG_RD32(NV_PFB_CONFIG_1);           // RAM config
    HwDeviceExtension->Power_PextdevBoot0 = REG_RD32(NV_PEXTDEV_BOOT_0);       // READ STRAP REG
    HwDeviceExtension->Power_PfifoRamHT   = REG_RD32(NV_PFIFO_RAMHT);
    HwDeviceExtension->Power_PfifoRamRO   = REG_RD32(NV_PFIFO_RAMRO);
    HwDeviceExtension->Power_PfifoRamFC   = REG_RD32(NV_PFIFO_RAMFC);
    }
    
 
//******************************************************************************
//
// Function:    NV4ChipFBPowerRestore()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4ChipFBPowerRestore (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    // power up mode - restore previous refresh value
    U032 D0_DELAY_RETRIES = 10; 
    U032 retry = 0;             
    U032 i;                     

    REG_WR32(NV_PFB_DEBUG_0, HwDeviceExtension->Power_refresh);          // refresh
    REG_WR32(NV_PFB_BOOT_0,  HwDeviceExtension->Power_PfbBoot0);         // RAM config
    REG_WR32(NV_PFB_CONFIG_0, HwDeviceExtension->Power_PfbConfig0);      // RAM config
    REG_WR32(NV_PFB_CONFIG_1, HwDeviceExtension->Power_PfbConfig1);      // RAM config

//  A delay seems to be necessary for i820 on Win9x.
//  The problem hasn't been demonstrated on W2K, but its here for safety
//  Reading NV_PMC_ENABLE is simply a convenient delay    
    while (REG_RD32(NV_PEXTDEV_BOOT_0) != HwDeviceExtension->Power_PextdevBoot0) 
    {
        for (i=0; i<2000; i++) 
        {
            REG_RD32(NV_PMC_ENABLE);
        }
        REG_WR32(NV_PEXTDEV_BOOT_0, HwDeviceExtension->Power_PextdevBoot0);    // WRITE STRAP REG
        retry++;
        if (retry == D0_DELAY_RETRIES) 
            break;
    }

    REG_WR32(NV_PFIFO_RAMHT, HwDeviceExtension->Power_PfifoRamHT);      
    REG_WR32(NV_PFIFO_RAMRO, HwDeviceExtension->Power_PfifoRamRO);      
    REG_WR32(NV_PFIFO_RAMFC, HwDeviceExtension->Power_PfifoRamFC);      

    // Touching the CONFIG_0 register messes up the VGA text screen.
    // Unfortunately, SetMode doesn't occur for a while, so this garbage text screen
    // may linger for a while,  so we'll blank the screen to hide it.
    // (SetMode will turn it back on)
    
    REG_RD32(NV_PRMCIO_INP0__COLOR);  // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);    // Turn off screen at AR
    REG_RD32(NV_PRMCIO_INP0__COLOR);  // Reset ATC FlipFlop
    }
    

//******************************************************************************
//
// Function:    NV4SaveInstanceMemory()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4SaveInstanceMemory(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 *fb_sv;
    U032 i;
                
    fb_sv = (U032 *)&(HwDeviceExtension->SavedInstanceMemory[0]);
    
    for(i=0; i < ((HwDeviceExtension->TotalInstanceMemory)/4); i++)
         *fb_sv++ = REG_RD32(NV_PRAMIN_DATA032(i));   // from the top--64k BIOS + instance memory
                                                      // this actually decrements from the top
    }

//******************************************************************************
//
// Function:    NV4RestoreInstanceMemory()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4RestoreInstanceMemory(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 *fb_sv;
    U032 data;
    U032 i;
                    
    fb_sv = (U032 *)&(HwDeviceExtension->SavedInstanceMemory[0]);
    
    for(i=0; i < ((HwDeviceExtension->TotalInstanceMemory)/4); i++)
       {
       data = *fb_sv++;
       REG_WR32(NV_PRAMIN_DATA032(i), data);
       }            

    }


//******************************************************************************
//
// Function:    NVEnableVGASubsystem()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVEnableVGASubsystem(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {


    //**************************************************************************
    // Make sure VGA IO subsystem is alive !!!
    //**************************************************************************

    REG_WR08(NV_PRMVIO_VSE2,  1);


    }

//******************************************************************************
//
// Function:    NVClearMutexPmeAudBuff0()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVClearMutexPmeAudBuff0(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    // Do nothing, this function is only used by NV3
    }


//******************************************************************************
//
// Function:    NVExtractBiosImage()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVExtractBiosImage(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR *buffer;
    UCHAR char1,char2;
    U032 CurrentValue;
    U032 i;
    
    //**************************************************************************
    // Get ptr to buffer where we'll store the bios image
    //**************************************************************************

    buffer = (UCHAR *)(&(HwDeviceExtension->SavedBiosImageArray[0]));

    char1 = REG_RD08(DEVICE_BASE(NV_PROM) + 0);
    char2 = REG_RD08(DEVICE_BASE(NV_PROM) + 1);

    //**************************************************************************
    // First attempt to get the BIOS image from PROM
    // (Look for the 55,AA signature)
    //**************************************************************************
    
    if ((char1 == 0x55) && (char2 == 0xAA))
    {
        //**********************************************************************
        // Read BIOS image via PROM
        //**********************************************************************
        for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
        {
            buffer[i] = REG_RD08(DEVICE_BASE(NV_PROM) + i);
        }
    }
    else
    {
#if 0
#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
        UCHAR *pVideoRomData;
        pVideoRomData = VideoPortGetRomImage(HwDeviceExtension, NULL, 0, SAVED_BIOS_IMAGE_SIZE);

        if(pVideoRomData != NULL)
        {
            char1 = pVideoRomData[0];
            char2 = pVideoRomData[1];
        }

        if ((char1 == 0x55) && (char2 == 0xAA))
        {
            for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
            {
                buffer[i] = pVideoRomData[i];
            }
        }
        else
#endif // WINN32_WINNT >= 0x0500 NT5 only
#endif
        {
            //**********************************************************************
            // Otherwise, get BIOS image from PRAMIN
            //**********************************************************************

            for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
            {
                buffer[i] = REG_RD08(DEVICE_BASE(NV_PRAMIN) + i);
            }
        }
    }            
}

//******************************************************************************
//
// Function:    FlatPanelCrtc
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

// some CRTC bit definitions
// CR07
#define VT08    1
#define VT09    0x20
#define VRS08   0x04
#define VRS09   0x80
#define EXT_VRS 0x84
#define VDE08   0x02
#define VDE09   0x40
#define VBS08   0x08
// CR09
#define VBS09   0x20
// CR25
#define VT10    0x01
#define VDE10   0x02
#define VRS10   0x04
#define VBS10   0x08

VOID FlatPanelCrtc( U016 XRes )
{
U032    DacHcrtc, DacHt, Ht, Hrs, Hre, DacVcrtc, DacVt, Vt, Vrs, Vre, Vbs, data32;
U016    Attr, Seq;
U008    Cr07, Cr09, Cr11, Cr25;

    // Make sure to always default to centered mode for now
    // Read the current control register value, and force it to be centered
    
    data32 = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_FP_TG_CONTROL);

    // Clear out all the bits

    data32 &= (~ ((DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _NATIVE )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _HORIZ )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _VERT  )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _BOTH  ))   ));

    // Force it to be centered (automatic centering)
    data32 |= (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER ));
    
    PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_FP_TG_CONTROL,data32);


    // check for pixel doubled modes
    if (XRes < 640)
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }

    // Make sure attr is set correctly
    Cr07 = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    Ht = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x00)>>8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)((Ht-3)<<8 | 0x04));   // HRS
    Hre = ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05)>>8) & 0xe0);    // read CR05 and mask 4:0
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(((Ht-2) | Hre)<<8 | 0x05));   // HRE = Ht - 2, CR04[4:0]

    // gather VT bits
    Vt = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x06)>>8);
    Cr07 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07)>>8);
    Cr25 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25)>>8);
    if (Cr07 & VT08)
        Vt |= 0x0100;
    if (Cr07 & VT09)
        Vt |= 0x0200;
    if (Cr25 & VT10)
        Vt |= 0x0400;

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vrs<<8 | 0x10));
    Cr07 &= ~EXT_VRS;
    if (Vrs & 0x100) Cr07 |= VRS08;
    if (Vrs & 0x200) Cr07 |= VRS09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    if (Vrs & 0x400) Cr25 |= VRS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));

    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    Cr11 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11)>>8);
    Vre |= (Cr11 & 0xf0);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vre<<8 | 0x11));

    // VBS = VRS
    Cr09 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09)>>8);
    Vbs = Vrs;

    // write VBS
    Cr07 &= ~VBS08;
    if (Vbs & 0x100) Cr07 |= VBS08;
    Cr09 &= ~VBS09;
    if (Vbs & 0x200) Cr09 |= VBS09;
    Cr25 &= ~VBS10;
    if (Vbs & 0x400) Cr25 |= VBS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vbs<<8 | 0x15));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr09<<8 | 0x09));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));

    // wait for vsync

    while (PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
    while (!(PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start

    data32 = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_FP_DEBUG_0);           // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    PRAMDAC_REG_WR32(PRAMDAC_Base,NV_PRAMDAC_FP_DEBUG_0, data32);
}




//******************************************************************************
//
// Function:    Disable Interrupt
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_DisableNVInterrupts
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{

    ULONG CurrentValue;

    //**************************************************************************
    // Make sure that we're not currently in an interrupt routine first
    // If interrupts are disabled, then someone is currently handling
    // the interrupts.  Wait for Interrupts to get re-activated.
    //**************************************************************************

    CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);
    while (CurrentValue == 0)
        CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);

    //**************************************************************************
    // Save off current value of PMC_INTR_EN_0
    //**************************************************************************
    
    CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);

    HwDeviceExtension->SavedPMCState = CurrentValue;

    //**************************************************************************
    // Disable NV Interrupts
    //**************************************************************************

    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, 0x00000000);


}


//******************************************************************************
//
// Function:    Re-Enable Interrupt
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ReEnableNVInterrupts
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, HwDeviceExtension->SavedPMCState);

}


//******************************************************************************
//
// Function:    ManualTextModeSet
//
// Routine Description:
//
//              This code was ported from the BIOS
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ManualTextModeSet
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    U008 byteValue;
    U032 dwordValue;
    U008 savedCrtcIndex;
    U008 savedLockValue;
    U008 initialLockValue;
            
    //**************************************************************************
    // Unlock extended registers
    //**************************************************************************
                    
    savedCrtcIndex = REG_RD08(NV_PRMCIO_CRX__COLOR); // 3d4

    CRTC_RD(NV_CIO_SR_LOCK_INDEX , savedLockValue);  // 1f lock index
    initialLockValue = savedLockValue;
    savedLockValue &=1;

    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    byteValue &=0xfe;
    byteValue |=savedLockValue;
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    
    CRTC_WR(NV_CIO_SR_LOCK_INDEX , NV_CIO_SR_UNLOCK_RW_VALUE ); // 0x57 unlock value

    //**************************************************************************
    // OEMPreSetMode
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent)      // Flat panel is present
        {
        CRTC_WR(0x21, 0xba);
        }
    else if (HwDeviceExtension->TvIsPresent)        // TV is present
        {
        ;       // Do nothing
        }
    else
        {
        CRTC_WR(0x21, 0xfa);                        // CRT present
        }
                             
    //**************************************************************************
    // ATCOFF
    //**************************************************************************

// cli
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
    REG_WR08(NV_PRMCIO_ARX, 0);                     // 3c0
// sti

    //**************************************************************************
    // OEMPreSetRegs
    //**************************************************************************
    
    CRTC_RD(0x28, byteValue);                       // 3d4
    byteValue &=0xf8;
    CRTC_WR(0x28, byteValue);
    
    CRTC_RD(0x1a, byteValue);                       // 3d4
    byteValue |=2;
    CRTC_WR(0x1a, byteValue);

    //**************************************************************************
    // SetRegs
    //**************************************************************************
    
    REG_WR08(NV_PRMVIO_SRX, 0);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 1);                // 3c5
    
    REG_WR08(NV_PRMVIO_MISC__WRITE , 0x67);         // 3c2
                               

    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 0);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 2);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 3);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 3);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 0);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 4);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 2);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 0);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 3);                // 3c5

    //**************************************************************************
    // CRTC Regs
    //**************************************************************************

    CRTC_WR(0x11, 0x20);                            // 3d4
    CRTC_WR(0x00, 0x5f);
    CRTC_WR(0x01, 0x4f);
    CRTC_WR(0x02, 0x50);
    CRTC_WR(0x03, 0x82);
    CRTC_WR(0x04, 0x55);
    CRTC_WR(0x05, 0x81);
    CRTC_WR(0x06, 0xbf);
    CRTC_WR(0x07, 0x1f);
    CRTC_WR(0x08, 0x00);
    CRTC_WR(0x09, 0x4f);
    CRTC_WR(0x0a, 0x0d);
    CRTC_WR(0x0b, 0x0e);
    CRTC_WR(0x0c, 0x00);
    CRTC_WR(0x0d, 0x00);
    CRTC_WR(0x0e, 0x00);
    CRTC_WR(0x0f, 0x00);
    CRTC_WR(0x10, 0x9c);
    CRTC_WR(0x11, 0x8e);
    CRTC_WR(0x12, 0x8f);
    CRTC_WR(0x13, 0x28);
    CRTC_WR(0x14, 0x1f);
    CRTC_WR(0x15, 0x96);
    CRTC_WR(0x16, 0xb9);
    CRTC_WR(0x17, 0xa3);
    CRTC_WR(0x18, 0xff);

    //**************************************************************************
    // GDC Regs
    //**************************************************************************

    REG_WR08(NV_PRMVIO_GRX,   0x0);                 // 3ce
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x1);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x2);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x3);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x4);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x5);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x10);            

    REG_WR08(NV_PRMVIO_GRX,   0x6);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0e);            

    REG_WR08(NV_PRMVIO_GRX,   0x7);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x8);            
    REG_WR08(NV_PRMVIO_GX_SR, 0xff);            

    //**************************************************************************
    // Full Cpu ON
    //**************************************************************************
    
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
    byteValue |=0x20;
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET,byteValue  );       // 3c5

    //**************************************************************************
    // OEMSetRegs
    //**************************************************************************

    CRTC_WR(0x19, 0x0);

    CRTC_RD(0x1a,byteValue);
    byteValue &=0xc0;
    byteValue |=0x38;
    byteValue |=1;
    byteValue |=4;
    CRTC_WR(0x1a, byteValue);

    CRTC_WR(0x1b, 0x3);
    CRTC_WR(0x1c, 0x18);
    CRTC_WR(0x1d, 0x0);
    CRTC_WR(0x1e, 0x0);

    CRTC_WR(0x20, 0x20);
    CRTC_WR(0x25, 0x0);

    CRTC_RD(0x28,byteValue);
    byteValue &=0xf8;
    CRTC_WR(0x28, byteValue);


    CRTC_WR(0x2d, 0x0);
    CRTC_WR(0x29, 0x0);
    CRTC_WR(0x2a, 0x0);
    CRTC_WR(0x30, 0x0);
    CRTC_WR(0x31, 0x0);
    CRTC_WR(0x32, 0x0);

    CRTC_RD(0x33,byteValue);
    byteValue &= 0x7f;
    CRTC_WR(0x33, byteValue);

    CRTC_WR(0x39, 0xff);


    dwordValue = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
    dwordValue &=0xeffffdfe;
    if (HwDeviceExtension->FlatPanelIsPresent)      // Flat panel is present
        dwordValue |= 0x00000200;
    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT,dwordValue);

    dwordValue = REG_RD32(NV_PRAMDAC_GENERAL_CONTROL);
    dwordValue &= 0xffefeeef;
    dwordValue |= 0x00000100;
    dwordValue |= 0x00000010;
    REG_WR32(NV_PRAMDAC_GENERAL_CONTROL,dwordValue);

    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x18);                    

    //**************************************************************************
    // Skip Load Palette and LoadSysfont
    //**************************************************************************

    //**************************************************************************
    // Skip OemFixupSetMode/ FPEndSetMode for now    (Flat panel only)
    //**************************************************************************

//    FPEndSetMode();

    //**************************************************************************
    // SetDPMSOff
    // Turn off DPMS on CRT only
    //**************************************************************************

    if ((!(HwDeviceExtension->FlatPanelIsPresent)) &&   // Flat panel not present
        (!(HwDeviceExtension->TvIsPresent)) )           // TV not present
        {    
        CRTC_RD(0x1a, byteValue);
        byteValue&=0x3f;
        CRTC_WR(0x1a, byteValue);

        //**********************************************************************
        // Full CPU Off
        //**********************************************************************
    
        REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
        byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
        byteValue &=0xdf;
        REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
        REG_WR08(NV_PRMVIO_SR_RESET,byteValue);         // 3c5
    
        //**********************************************************************
        // ATCON
        //**********************************************************************
// cli    
        byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
        byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
        REG_WR08(NV_PRMCIO_ARX, 0x20);                  // 3c0
        byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
        byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
// sti
        }
            
    //**************************************************************************
    // Full CPU Off
    //**************************************************************************

    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
    byteValue &=0xdf;
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET,byteValue);         // 3c5

    //**************************************************************************
    // ATCON
    //**************************************************************************

//cli
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
    REG_WR08(NV_PRMCIO_ARX, 0x20);                  // 3c0
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
//sti

    //**************************************************************************
    // Skip OEMPostSetMode  (TV only)
    //**************************************************************************

    //**************************************************************************
    // Restore / Lock extended registers if necessary
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    byteValue &=0xfe;                                // remove bit 0
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c

    if (initialLockValue == 0)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);
        }
    else if (initialLockValue == 1)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RO_VALUE);
        }
    else if (initialLockValue == 3)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);
        }

    //**************************************************************************
    // Restore the original CRTC index register
    //**************************************************************************

    REG_WR08(NV_PRMCIO_CRX__COLOR, savedCrtcIndex); // 3d4

    }



#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
//
// Function:    NV_VBE_DPMS_GetPowerState()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

BOOLEAN NV_VBE_DPMS_GetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG *CurrentPowerState)

    {
    UCHAR lock;
    UCHAR cr1a;
    UCHAR result;

    //**************************************************************************
    // Save off original lock value, then unlock extended registers
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);

    //**************************************************************************
    // Read CR1A
    //
    //   Bit 7 Hsync Toggle disable.  When set to a 1, this bit forces the Hsync to
    //            inactive state (high or low as programmed in the bit-6 of the
    //            Miscellaneous output register).
    //
    //   Bit 6 Vsync Toggle disable.  When set to a 1, this bit forces the Vsync to
    //            inactive state (high or low as programmed in the bit-7 of the
    //            Miscellaneous output register).
    //
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, cr1a);

    //**************************************************************************
    // Isolate DPMS bits (CR1A bits 7 & 6)
    //**************************************************************************

    cr1a >>=14;
    *CurrentPowerState = tblDPMSStates[cr1a];

    //**************************************************************************
    // Relock the extended registers, if necessary
    //**************************************************************************

    //**************************************************************************
    // Relock the extended registers, if necessary
    //**************************************************************************

    if (lock == 0)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);
        }
    else if (lock == 1)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RO_VALUE);
        }
    else if (lock == 3)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);
        }


    return(TRUE);
    }


//******************************************************************************
//
// Function:    NV_VBE_DPMS_SetPowerState()
//
// Routine Description:
//
//       VBE Function 10h
//       VBE_DPMS - Display Power Management Signaling functions (DPMS).
//
//       Entry:  AX = 4F10h
//               BL = Subfunction
//               ES:DI = Null pointer
//               DS = Seg0
//
//               Other registers dependent on subfunction
//               Subfunction 0:
//                       None
//               Subfunction 1:
//                       BH = Requested power state
//                            0 = On
//                            1 = Stand by
//                            2 = Suspend
//                            4 = Off
//                            8 = Reduced on
//               Subfunction 2:
//                       None
//
//       Exit:   AX = VBE return status
//               Other registers dependent on subfunction:
//               Subfunction 0:
//                       BH = States supported:
//                            bit 0      Stand by
//                            bit 1      Suspend
//                            bit 2      Off
//                            bit 3      Reduced on
//                            bits 4-7   Reserved
//                       BL = VBE/PM Version number:
//                            bits 0-3   Minor version number (0)
//                            bits 4-7   Major version number (1)
//               Subfunction 1:
//                       None
//               Subfunction 2:
//                       BH = Power state currently requested by controller
//                            0 = On
//                            1 = Stand by
//                            2 = Suspend
//                            4 = Off
//                            8 = Reduced on
//
//       The VESA committee defined a method of signalling a monitor
//       to shutdown or to go into standby mode. The sync signals are
//       used in the following manner:
//
//       H Sync  V Sync  Result
//       ======  ======  ======
//       Pulses  Pulses  Monitor is active
//       None    Pulses  Monitor is in "stand-by" mode
//       Pulses  None    Monitor is in "suspend" mode
//       None    None    Monitor is in "shut down" mode
//
//       Note: ES, DS, SI have been pushed on the stack already
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
BOOLEAN NV_VBE_DPMS_SetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PowerState)
{
    BOOLEAN bRet = 0;
    ULONG i;

    for(i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
    {
        
        switch (PowerState)
        {

            case VideoPowerOn:
            case VideoPowerHibernate:
                bRet |= 
                    RmSetDisplayPowerState
                    (
                        HwDeviceExtension->DeviceReference,
                        HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i],
                        TRUE
                    );
                HwDeviceExtension->ulRmTurnedOffMonitor = FALSE;
                break;

            case VideoPowerStandBy:
                    //RmSetDisplayPowerState...
                    break;

            case VideoPowerSuspend:
                    //RmSetDisplayPowerState...
                    break;

            case VideoPowerOff:
                bRet |= 
                    RmSetDisplayPowerState
                    (
                        HwDeviceExtension->DeviceReference,
                        HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i],
                        FALSE
                    );
                HwDeviceExtension->ulRmTurnedOffMonitor = TRUE;
                break;
        }
    }    

    return(bRet);

}

//******************************************************************************
//
// Function:    GetCurrentDPMSState(HwDeviceExtension)
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

U032 GetCurrentDPMSState(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    U032 Value;
    
    
    Value = hwDeviceExtension->CurrentDPMSState;
    return(Value);
    }


//******************************************************************************
//
// Function:    NV_ATCOff()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ATCOff(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    NV_ResetATCFlipFlop(HwDeviceExtension);        // Reset ATC to index state

    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x0);

    }


//******************************************************************************
//
// Function:    NV_ATCOn()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ATCOn(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    NV_ResetATCFlipFlop(HwDeviceExtension);    // Reset ATC to index state

    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x20);

    NV_ResetATCFlipFlop(HwDeviceExtension);    // For compatibility with DOS EDIT

    }


//******************************************************************************
//
// Function:    NV_ResetATCFlipFlop()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ResetATCFlipFlop(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    volatile U008 value;

    value = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR);
    value = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__MONO);

    }


#endif // WINN32_WINNT >= 0x0500 NT5 only



//******************************************************************************
//
//  Function: NVGetTimingForDac()
//
//  Routine Description:
//
//      This routine get timing values for dac at giving mode.
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//
//  Return Value:
//      TRUE - successful; FALSE - failed
//
//******************************************************************************
BOOL NVGetTimingForDac(PHW_DEVICE_EXTENSION hwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo)
{

    ULONG ulDisplayWidth;
    ULONG ulDisplayHeight;
    ULONG ulDisplayRefresh;
    ULONG ulDisplayPixelDepth;

    MODE_TIMING_VALUES timingInfo;
    unsigned int vesaStatus;

#ifdef ENABLE_COMMON_MODESET_CODE
    GetTimingDacCommonModesetCode(hwDeviceExtension, pResolution, pTimingInfo);
    return (TRUE);
#endif


    ulDisplayWidth      = pResolution->ulDisplayWidth;   
    ulDisplayHeight     = pResolution->ulDisplayHeight;  
    ulDisplayRefresh    = pResolution->ulDisplayRefresh; 
    ulDisplayPixelDepth = pResolution->ulDisplayPixelDepth;

    if(hwDeviceExtension->bUseGTF) {

        //**********************************************************************
        // Here we use GTF timings as requested by the user
        //**********************************************************************

        vesaStatus = vesaGetGTFTimings(ulDisplayWidth,
                                       ulDisplayHeight, 
                                       ulDisplayRefresh,
                                       (MODE_TIMING_VALUES *)pTimingInfo);
                                   
        if (vesaStatus)
            {
            // Could not find a GTF timing for this mode
            return(FALSE);
            }

        return(TRUE);
    }


    //**************************************************************************
    // By default, we use DMT timings  (instead of GTF timings)
    //**************************************************************************

    vesaStatus = vesaGetDMTTimings(ulDisplayWidth,
                                   ulDisplayHeight, 
                                   ulDisplayRefresh,
                                   (MODE_TIMING_VALUES *)pTimingInfo);
                                   
    //**************************************************************************
    // If DMT timings don't exist for this mode, use the GTF timings
    //**************************************************************************

    if (vesaStatus)
    {
        //**********************************************************************
        // Set mode using GTF timings if DMT timings don't exist
        //**********************************************************************
        vesaStatus = vesaGetGTFTimings(ulDisplayWidth,
                                       ulDisplayHeight, 
                                       ulDisplayRefresh,
                                       (MODE_TIMING_VALUES *)pTimingInfo);
        if (vesaStatus)
    
        {
            // Could not find a DMT / GTF timing for this mode
            return(FALSE);
        }
                                    
    }

    return(TRUE);
}

//
// Read in the monitor restriction mode list per head from the registry.
//
VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    U016 *ValidModePtr;
    U016 *RegDataPtr;
    ULONG NumRegistryModes;
    U016  *BaseOfValidModeTable;
    ULONG i;
    U016 RegWidth,RegHeight,RegDepth,RegRefresh;
    
    // init the Monitor restriction mode tables.
    MonitorRestrictionModeList0_registry_data[0]     = 0xFFFF ;
    MonitorRestrictionModeList1_registry_data[0]     = 0xFFFF ;
    HwDeviceExtension->NumRestrictionModes0 = 0;
    HwDeviceExtension->NumRestrictionModes1 = 0;
    // copy the monitor restriction modelists for both heads.
    NV_ReadAndCopyRegistryData(HwDeviceExtension, L"MonitorModeList0",      &(MonitorRestrictionModeList0_registry_data[0] ));
    NV_ReadAndCopyRegistryData(HwDeviceExtension, L"MonitorModeList1",      &(MonitorRestrictionModeList1_registry_data[0] ));

    for (i=0; i < NV_NO_DACS; i++)
    {
        RegDataPtr = (i ? (U016 *)&MonitorRestrictionModeList1_registry_data[0] : (U016 *)&MonitorRestrictionModeList0_registry_data[0]);
        ValidModePtr = (i ? (U016 *)&HwDeviceExtension->RestrictionModeTable1[0] : (U016 *)&HwDeviceExtension->RestrictionModeTable0[0]);
        BaseOfValidModeTable = ValidModePtr;
        NumRegistryModes = 0;
    
        //**************************************************************************
        // Parse each line from the registry.
        // For each refresh rate (of each mode), check if the refresh is present in the
        // vesa data table.  If so, then it's a valid mode. 
        // Registry data is terminated with 0xffff
        //**************************************************************************

        while (*RegDataPtr != 0xffff)
            {
            RegDepth   = *(RegDataPtr);             // Get Depth from registry
            RegWidth   = *(RegDataPtr+1);           // Get Width from registry
            RegHeight  = *(RegDataPtr+2);           // Get Height from registry

            //**********************************************************************
            // Advance to the registry refresh rates for this particular mode
            //**********************************************************************

            RegDataPtr+=3;

            //**********************************************************************
            // Each mode entry in the registry data is NULL terminated.
            // Parse all refresh rates for this mode
            //**********************************************************************

            while (*RegDataPtr !=0)
            {        
                RegRefresh  = *(RegDataPtr++);      // Get Refresh from registry data

                //**********************************************************
                // Generate 8bpp entry for this refresh rate
                //**********************************************************

                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = RegWidth;          // Width
                *(ValidModePtr+2)  = RegHeight;         // Height
                *(ValidModePtr+3)  = RegDepth;          // Depth                                                                 
                *(ValidModePtr+4)  = RegRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode

                //**********************************************************
                // Keep track of how many modes have currently been specified
                //**********************************************************

                NumRegistryModes++;

                //**********************************************************
                // DEBUG safety check
                // Make sure we never go past the end of the
                // allocated valid mode table. (back off 30 words from end of table)
                //**********************************************************

                if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2) ))
                {
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                }
            } // while (*RegDataPtr !=0)...

            //**********************************************************************
            // Skip past null terminator
            //**********************************************************************

            RegDataPtr++;
                
        } // while (*RegDataPtr != 0xffff)...

        //
        // Save the number of restriction modes for each head
        //
        if (i == 0) 
        {
            HwDeviceExtension->NumRestrictionModes0 = NumRegistryModes;
        }
        else
        {
            HwDeviceExtension->NumRestrictionModes1 = NumRegistryModes;
        }
    } // for each head
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modedefs.h ===
//******************************************************************************
//
// Copyright (c) 1998  NVidia Corporation
//
// Module Name:
//
//     modedefs.h
//
// Abstract:
//
// Environment:
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1998 NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#define NUMBER_OF_MODES 18
#define NUMBER_OF_DEPTHS 4
#define NUMBER_OF_RATES  7
#define MODE_TABLE_LENGTH (NUMBER_OF_MODES * NUMBER_OF_DEPTHS * sizeof(U016))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modehw.h ===
//
// MODEHW.H - Header file for OS specific portions of mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines for accessing NV registers in the 'C' based modeset code.
//
//
VOID WriteFb32(U032 datum, U032 addr);
U032 ReadFb32(U032 addr);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WriteIndexed(U032 addr, U016 datum);
VOID WritePriv08(U032 addr, U008 datum);
U016 ReadIndexed(U032 addr, U008 reg);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\monitor.h ===
//******************************************************************************
// 
// Copyright (c) 1998  NVidia Corporation
// 
// Module Name:
// 
//     monitor.h
// 
// Environment:
// 
// Revision History:
// 
//******************************************************************************

//******************************************************************************
// 
// Copyright (c) 1998  NVidia Corporation. All Rights Reserved
// 
//******************************************************************************

#define NV_MONITOR_VGA  0
#define NV_MONITOR_NTSC 2
#define NV_MONITOR_PAL  3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\ddminint.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995,1997 NVidia Corporation. All Rights Reserved.
 *
 *  File:       ddmini.h
 *  Content:    header for Windows95 Direct Draw driver
 *
 *  Files:
 *           ddmini16.c
 *           ddddrv16.c
 *           ddmode.c
 *
 *           dddrv32.c
 *           blt832.c
 *           blt1632.c
 *           blt3232.c
 *
 ***************************************************************************/
#ifndef _DDMININT_H_
#define _DDMININT_H_

// Note:

// From NT4 DDK (Graphics System Overview)
//    The display driver is in the same privileged kernel-mode address space as the 
//    rest of the Windows NT Executive. Faults in the display driver will cause GDI 
//    and the rest of the system to fault.

#ifndef NVD3D
#include "nvFourCC.h"

#undef NV_MAX_FOURCC
#define NV_MAX_FOURCC 7

#endif

// This came from dx95types.h which is not in the dx path being used for NT4
typedef PDD_DIRECTDRAW_GLOBAL           LPDDRAWI_DIRECTDRAW_GBL;

#include "CompileControl.h"

#if IS_WINNT4
#include "nvPusher.h"
#include "nvVPP.h"
#endif

#define NV_MAX_EXTRA_FS_SURFACES 4
#define NV_MAX_EXTRA_SURFACES    6

//  Remove double-defintion warning
#ifdef  DIRECTDRAW_DLLNAME
#undef  DIRECTDRAW_DLLNAME
#endif
#define DIRECTDRAW_DLLNAME "NV3DD32.DLL"
//#else
//#define DIRECTDRAW_DLLNAME "NVD3D32.DLL"
//#endif

#ifndef _WIN32
#define NOUSER
#define NOGDI
#define NOGDIOBJ
#define NOGDICAPMASKS
#include <windows.h>
#define NOPTRC
#define PTTYPE POINT
#include <nvgdi.inc>
#define NVFAR FAR
#include <nvdib.inc>
typedef struct tagPALETTEENTRY FAR* LPPALETTEENTRY;
typedef struct tagRGNDATA      FAR* LPRGNDATA;
#include <ddrawi.h>
#endif

#define FAST register

//  Remove double-definition warning
#ifdef  asmMergeCoords
#undef  asmMergeCoords
#endif
#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)

// Probably should move these up to a more general level -@mjl@

/* Other NV specific defines */
#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L

/* Surface Alignment */
#if (NVARCH >= 0x010)
#define NV_BYTE_ALIGNMENT_PAD           63L
#define NV_BYTE_ALIGNMENT               64L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#elif (NVARCH >= 0x04)
#define NV_BYTE_ALIGNMENT_PAD           31L
#define NV_BYTE_ALIGNMENT               32L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#else /* NVARCH < 0x04 */
#define NV_BYTE_ALIGNMENT_PAD           15L
#define NV_BYTE_ALIGNMENT               16L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      128
#define NV_BIT_ALIGNMENT                128
#endif  /* !(NV10 || NV4) */


//************************************************************************************
// Entry/exit macros used by the ddraw driver to acquire the rendering semaphore from the
// This notifies the OGL ICD that we need to touch the fifo
//************************************************************************************
#define START_DMA_PUSH_SYNC()           \
{ \
    ppdev->pfnAcquireOglMutex(ppdev); \
    ppdev->NVFreeCount = 0; \
    releaseOpenglSemaphore = TRUE; \
}

#define ENTER_DMA_PUSH_SYNC()           \
    if (OglIsEnabled(ppdev))       \
        {                               \
        START_DMA_PUSH_SYNC(); \
        }

#define END_DMA_PUSH_SYNC() \
    if (releaseOpenglSemaphore == TRUE) \
        {                               \
        ppdev->pfnReleaseOglMutex(ppdev); \
        }

#define EXIT_DMA_PUSH_SYNC(exitcode)    \
{ \
    END_DMA_PUSH_SYNC();            \
    return(exitcode); \
}

#define NV_VPP_CHANNEL_IID  0xDD115020   // Special version for NT4

#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017 // Was coming from win9x header!

// Not sure this is the best approach to accessing this object methods. -@mjl@
#define BETA4_SET_BETA_FACTOR_OFFSET                            NV072_SET_BETA_FACTOR
#define SURFACES_2D_PITCH_OFFSET                                NV042_SET_PITCH
#define BLIT_POINT_IN_OFFSET                                    NV05F_CONTROL_POINT_IN
#define MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET                      NV039_OFFSET_IN
#define SET_ROP_OFFSET                                          NV043_SET_ROP5
#define SET_TRANSCOLOR_OFFSET                                   NV057_SET_COLOR
#define SURFACES_2D_SET_COLOR_FORMAT_OFFSET                     NV042_SET_COLOR_FORMAT
#define SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET                   NV077_SET_CONTEXT_DMA_IMAGE
#define SCALED_IMAGE_CONTEXT_SURFACE_OFFSET                     NV077_SET_CONTEXT_SURFACE
#define SCALED_IMAGE_SET_COLOR_FORMAT                           NV077_SET_COLOR_FORMAT
#define SCALED_IMAGE_CLIPPOINT_OFFSET                           NV077_CLIP_POINT
#define SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET                       NV077_IMAGE_IN_SIZE
#define SCALED_IMAGE_NOTIFY_OFFSET                              NV077_NOTIFY

//---------------------------------------------------------------------------
// blit data, including cached values and other control parameters
// 
// Used to allow sharing of several objects (ROP, 2D SURFACE, ...?)
//  by multiple users within the same context (may not need in NT4) -@mjl@

typedef struct BltData_s {
    NvU32               dwStatusReferenceCount;
    NvU32               dwSystemSurfaceContextDMAIndex;
    NvU32               dwMTMFIndex;     // alternating odd or even, does not need to be initialized
    NvU32               dwLastRop;
    NvU32               dwLastColourKey;
    NvU32               dwLastColourFormat;
    NvU32               dwLastCombinedPitch;
    NvU32               dwLastSrcOffset;
    NvU32               dwLastDstOffset;
    NvU32               dwSystemBltFallback;
    NvU32               dwLetItThrash;
    NvU32               dwQueuedPrimaryBlitCount;
} BltData_t;


/***************************************************************************
 *
 * DriverData
 *
 * this structure contains all the globals of the driver, it is shared
 * between the 16 and 32bit side of the driver.
 *
 ***************************************************************************/

//  Remove double-definition warning
#ifdef  DDMINI_VERSION
#undef  DDMINI_VERSION
#endif
#define DDMINI_VERSION  0x0300



typedef DWORD  (FAR PASCAL *LPDDHALSURFCB_GETSURFACEINFO)(LPDDRAWI_DDRAWSURFACE_LCL);

#ifndef NVD3D
typedef struct {
    short   x;
    short   y;
} NVXY;

typedef struct {
    short   y;
    short   x;
} NVYX;

typedef struct {
    unsigned short w;
    unsigned short h;
} NVWH;

typedef struct {
    unsigned short h;
    unsigned short w;
} NVHW;

typedef union {
    long xy;
    long yx;
    unsigned long wh;
    unsigned long hw;
    NVXY xy16;
    NVYX yx16;
    NVWH wh16;
    NVHW hw16;
} NVCOORD;

typedef struct {
    DWORD               fpFlipFrom;
    DWORD               dwFlipDuration;
    DWORD               bFlipFlag;
    DWORD               bIsD3DSurface;
    DWORD               fpFlipTo;
    DWORD               fpPreviousFlipFrom;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    LONGLONG            llFlipTime;
    LONGLONG            llPreviousFlipTime;
} FLIPRECORD;

// I think these are mocomp... why are they used in VPP? -@mjl@
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
typedef struct tagNVMCSURFACEFLAGS {
  DWORD dwMCSurfaceBase;
  DWORD dwMCSurface422Offset;
  DWORD dwMCMotionCompReferenceCount;
  DWORD dwMCFormatCnvReferenceCount;
  DWORD dwMCCompositeReferenceCount;
  DWORD dwMCTemporalFilterReferenceCount;
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
  BYTE  bMCFrameIsFiltered;
  BYTE  bMCFrameIsComposited;
  BYTE  bMCFrameAlreadyFormatConverted;
} NVMCSURFACEFLAGS, *LPNVMCSURFACEFLAGS;


typedef struct _GLOBALDATA
{
    // lpPDevice *must* be first (DIBLINK.ASM) uses it.
#ifdef _WIN32
    DWORD                       lpPDevice;
#else
    DIBENGINE FAR *             lpPDevice;
#endif


    DWORD                       dwVersion;
    DWORD                       fIsDisplay;

    // flags
    DWORD                       DDrawVideoSurfaceCount; // *MUST* start at 0xC offset from beginning of struct (cursor code and realizeObject checks it)
    WORD                        fDmaPusherActive;   // *MUST* start at 0x10 offset from beginning of struct (both display driver and direct draw check it)
    WORD                        fFullScreenDosOccurred; // *MUST* start at 0x12 offset from beginning of struct (both display driver and direct draw check it)
    WORD                        fVidMemLocked;
    WORD                        fActiveExternalUser; // NVLIB, NVDDX, etc
    WORD                        fNvActiveFloatingContexts;
    WORD                        OverlayBufferIndex;

    // info about the current mode
    DWORD                       ModeNumber;
    DWORD                       TotalVRAM;          // total VRAM on card
    DWORD                       ScreenSel;          // selector to screen
    DWORD                       maxOffScreenY;      // maximum screen pitch width Y at current resolution
    DWORD                       BaseAddress;        // base addess of accessable video memory.
    long                        VideoHeapBase;      // start of video heap
    long                        VideoHeapEnd;       // end of video heap
    DWORD                       GARTLinearBase;     // linear base address of AGP GART memory
    DWORD                       GARTPhysicalBase;   // physical base address of AGP GART memory
    WORD                        OverlaySrcX;        // overlay source starting point
    WORD                        OverlaySrcY;

    // bitmapinfo for current mode
    BITMAPINFOHEADER            bi;
    DWORD                       color_table[256];

    PDEV *                      ppdev;  // A pointer back to the physical device
    NvU32                       dwRootHandle;       
    NvU32                       dwDeviceHandle;
    NvU32                       dwSurfaceAlignPad;
    NvU32                       dwMostRecentCelsiusUser;
    BltData_t                   bltData;
    CPushBuffer                 nvPusher;

    // TBD: port the process manager to NT4 -@mjl@
    PROCESSINFO                 procInfo;           // statically created for NT

    Vpp_t                       vpp;
    NV_SystemInfo_t             sysInfo;     // TBD: duplicates most of D3dPerf -- fix that - @mjl@


    // TBD: vpp makes ref to these! -@mjl@
    // TBD: make sure this are initialized properly -@mjl@
    DWORD                       dwDXVAFlags; // Unused (in WinNT4) except for reference in VPP code -- must be zero. @mjl@
    DWORD                       dwSharedClipChangeCount; // TBD: vpp makes global ref to these! -@mjl@
    FLIPRECORD                  flipPrimaryRecord;
    FLIPRECORD                  flipOverlayRecord;
    NVMCSURFACEFLAGS            nvMCSurfaceFlags[9];
    NvU8                        bMCOverlaySrcIsSingleField1080i;
    BYTE                        bMCHorizontallyDownscale1080i;
    DWORD                       dwMCNV12Surface[8];
    DWORD                       dwMCDestinationSurface;
    DWORD                       dwMCNVMCSurface;
    BYTE                        bMCTemporalFilterDisabled;
    BYTE                        bMCPercentCurrentField;
    DWORD                       dwMCNVDSSurfaceBase;
    DWORD                       dwMCMostRecentlyDecodedSurfaceBase;
    DWORD                       dwMCNVSPSurface;
    DWORD                       dwMCIDCTAGPSurfaceBase[4];
    DWORD                       dwMCCurrentCelsiusIDCTCtxDma;
    DWORD                       dwMCIDCTAGPCtxDmaSize[4];
    DWORD                       dwMCNVIDSurface[4];
    DWORD                       dwMCNVIDSurfaceReferenceCount[4];

    NvU32                       dwTVTunerFlipCount;
    NvU32                       dwOverlayFlipCount;
    NvU32                       dwHeads;            // number of heads (DACs) on this device
    NvU32                       dwDesktopState;
    NvU32                       regOverlayColourControlEnable;
    NvU16                       NvDeviceVersion;
    NvU16                       unused_01;



    // NV stuff
    DWORD                       lpNvDev;
    DWORD                       lpNvDmaBuffer;
    DWORD                       NvDevFlat;
    DWORD                       NvDevFlatVPE; // Vpe channel
    DWORD                       NvDmaBufferFlat;
    DWORD                       NvDummyNotifierFlat;
    DWORD                       NvFlipPrimaryNotifierFlat;
    DWORD                       NvFlipOverlayNotifierFlat;
    DWORD                       NvFlipVportNotifierFlat;
    DWORD                       NvDmaToMemNotifierFlat;
    DWORD                       NvDmaFromMemNotifierFlat;
    DWORD                       NvDmaFromMemBaseAddress;
    DWORD                       NvDmaFromMemSurfaceMem;
    DWORD                       NvPusherSyncNotifierFlat;
    DWORD                       NvScanlineBufferFlat;
    DWORD                       NvFloating0UYVYSurfaceMem;
    DWORD                       NvFloating1UYVYSurfaceMem;
    DWORD                       NvFloating0YUYVSurfaceMem;
    DWORD                       NvFloating1YUYVSurfaceMem;
    DWORD                       NvFloatingMem2MemFormatBaseAddress;
    DWORD                       NvYUY2Surface0Mem;
    DWORD                       NvYUY2Surface1Mem;
    DWORD                       NvFloatingMem2MemFormatMemoryHandle;
    DWORD                       NvWinDmaPusherNotifierFlat;
    DWORD                       dwVideoPortsAvailable;
    DWORD                       NvFloatingTexture;
    DWORD                       CurrentVisibleSurfaceAddress;
    DWORD                       dDrawSpareSubchannelObject;
    DWORD                       lpLast3DSurfaceRendered;
    DWORD                       NvBaseFlat;
//    DWORD                       dwOverlaySurfaces;
//    DWORD                       dwOverlayOwner;

//    DWORD                       dwOverlaySrcHeight;
//    DWORD                       dwOverlayDstHeight;
    DWORD                       dwModeIndex;
    DWORD                       dwUseRefreshRate;
    DWORD                       NvFloatingMem2MemFormatNextAddress;
    DWORD                       NvYUY2Surface2Mem;
    DWORD                       dwDDPad0; /* unused */
    DWORD                       dwDDPad1; /* unused */
    DWORD                       ddClipUpdate;
    DWORD                       physicalColorMask;
    WORD                        flatSelector;
    WORD                        NvFreeCount;
    BYTE                        NvFirstCall;
    BYTE                        NvPrevDepth;
    BYTE                        TwoDRenderingOccurred;
    BYTE                        ThreeDRenderingOccurred;
    DWORD                       fourCC[16];    // leave some empty locations so we can add more without rereleasing 16 bit portion of driver

    // D3D stuff
    DWORD                       dwCurrentContextHandle;
    DWORD                       dwCurrentContextPtr;
    DWORD                       dwCurrentTextureHandle;
    DWORD                       dwCurrentTexturePtr;
    DWORD                       dwD3DContextCount;
    DWORD                       dwZBufferContextAddr;
    DWORD                       dwTriangleContextHandle;
    DWORD                       dwTriangleContextAddr;
    DWORD                       dwD3DTextureCount;
    DWORD                       dwDMAPushContext;
    DWORD                       dwDmaPushBufferSize;
    DWORD                       hContexts_gbl;
    DWORD                       hTextures_gbl;
    DWORD                       hAGPList_gbl;
    DWORD                       hTextureHeap;
    DWORD                       hPipelines_gbl;
    DWORD                       hMaterials_gbl;
    DWORD                       dwDmaMaxPushCount;
    DWORD                       regD3DEnableBits1;
    DWORD                       regDmaPushBufferSizeMax;
    DWORD                       regMipMapLevels;
    DWORD                       regZOHMode;
    DWORD                       regTexHeap;
    DWORD                       regMinVideoTextureSize;
    DWORD                       regFilterControl;
    DWORD                       regDmaMinPushCount;
    DWORD                       regD3DContextMax;
    DWORD                       regD3DTextureMax;
    DWORD                       dwContextListHead;
    DWORD                       dwDmaFifoAddr;
    DWORD                       dwDmaFifoOffset;
    DWORD                       dwDmaFifoCurrentBuffer;
    DWORD                       dwDmaCount;

    // DirectDraw stuff
    DWORD                       fReset;
    DD_HALINFO                  HALInfo;
    DD_CALLBACKS                DDCallbacks;
    DD_SURFACECALLBACKS         DDSurfaceCallbacks;
    DD_PALETTECALLBACKS         DDPaletteCallbacks;

} GLOBALDATA;
#endif // #ifndef NVD3D

/***************************************************************************
 ***************************************************************************/
#ifdef _WIN32

/* Ternary raster operation indexes */

#define BLACKNESSINDEX      0x00000000L
#define NOTSRCERASEINDEX    0x00000011L
#define NOTSRCCOPYINDEX     0x00000033L
#define SRCERASEINDEX       0x00000044L
#define PATINVERTINDEX      0x0000005AL
#define SRCINVERTINDEX      0x00000066L
#define SRCANDINDEX         0x00000088L
#define MERGEPAINTINDEX     0x000000BBL
#define SRCCOPYINDEX        0x000000CCL
#define SRCPAINTINDEX       0x000000EEL
#define PATCOPYINDEX        0x000000F0L
#define WHITENESSINDEX      0x000000FFL


#else  // _WIN32

/* Ternary raster operations */
#define BLACKNESS           0x00000042L
#define SRCCOPY             0x00CC0020L
#define PATCOPY             0x00F00021L
#define WHITENESS           0x00FF0062L

/***************************************************************************
 *
 * global driver data
 *
 ***************************************************************************/

extern GLOBALDATA           DriverData;     // in ddmini16.c

/***************************************************************************
 *
 * functions in ddmini.c
 *
 ***************************************************************************/

void FAR PASCAL _loadds BeginAccess(DIBENGINE FAR *pde, int left, int top, int right, int bottom, UINT flags);
void FAR PASCAL _loadds EndAccess(DIBENGINE FAR *pde, UINT flags);

/***************************************************************************
 *
 * functions in setmode.c
 *
 ***************************************************************************/

BOOL HWSetMode();
BOOL HWTestMode(int ModeNumber);
void FAR PASCAL HWBeginAccess(DIBENGINE FAR *,short,short,DWORD,DWORD);
void HWEndAccess(void);
BOOL HWSetPalette(int start, int count, DWORD FAR *colors);


/***************************************************************************
 *
 * functions in DIBENG
 *
 ***************************************************************************/

extern DWORD FAR PASCAL CreateDIBPDevice    (LPBITMAPINFOHEADER lpbi, DIBENGINE FAR *lpDevice, LPVOID lpBits, WORD dwFlags);
extern UINT  FAR PASCAL DIB_Enable          (LPVOID, UINT, LPSTR, LPSTR, LPVOID);
extern UINT  FAR PASCAL DIB_Disable         (DIBENGINE FAR *);
extern LONG  FAR PASCAL DIB_Control         (DIBENGINE FAR *, UINT, LPVOID, LPVOID);
extern UINT  FAR PASCAL DIB_BeginAccess     (DIBENGINE FAR *, int left, int top, int right, int bottom, WORD flags);
extern UINT  FAR PASCAL DIB_EndAccess       (DIBENGINE FAR *, WORD flags);
extern UINT  FAR PASCAL DIB_SetPaletteExt   (UINT start, UINT count, DWORD FAR *lpPalette, DIBENGINE FAR * pde);
extern UINT  FAR PASCAL DIB_BitBlt          (DIBENGINE FAR *, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *);
extern UINT  FAR PASCAL DIB_StretchBlt      (DIBENGINE FAR *, int, int, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_StretchDIBits   (DIBENGINE FAR *, int, int, int, int, int, int, int, int, LPVOID, BITMAPINFO FAR *, LPVOID, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_DibToDevice     (DIBENGINE FAR *, int, int, int, int, RECT FAR *, DRAWMODE FAR *, LPVOID, BITMAPINFO FAR *, LPVOID);
extern UINT  FAR PASCAL DIB_Output          (DIBENGINE FAR *, int, int, POINT FAR *, DIB_Pen FAR *, DIB_Brush8 FAR *, DRAWMODE FAR *, RECT FAR *);
extern UINT  FAR PASCAL DIB_ExtTextOutExt   (DIBENGINE FAR *pde, int x, int y, RECT FAR *Clip, LPSTR sz, UINT cb, LPVOID lpFont, DRAWMODE FAR *pdm, LPVOID xform, int FAR *pdx, RECT FAR *lpORect, UINT f, LPVOID DrawBitmap, LPVOID DrawRect);
// extern UINT  FAR PASCAL DIB_SetCursorExt    (CURSORSHAPE FAR *lpCursor, DIBENGINE FAR *pde);
extern UINT  FAR PASCAL DIB_MoveCursorExt   (int x, int y, DIBENGINE FAR * pde);

#endif // _WIN32

/* Escape functions */
#define MOUSETRAILS         39
#define DCICOMMAND          3075
#define GETSURFINFO         0x6979
#define GETNVCHANNELPTR     0x6980
#define RECONFIGNVOFFSCREEN 0x6981
#define NVSETDDRAWMODE      0x6982


#ifndef DX7   // For DX7, this is defined in ddmini.h.
/* AGP stuff */
#define NV_MAX_AGP_MEMORY_LIMIT 0x1FFFFFF
#endif

/* Dma flags */
#define NV_WIN_DMA_PUSHER_IS_ACTIVE  1
#define NV_DD_DMA_PUSHER_IS_ACTIVE   2

/* Floating system memory context in use flags */
#define NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        1
#define NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        2
#define NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        4
#define NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        8
#define NV_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY       16

/* Other NV specific defines. NV3 and NV4 surface alignments have
   been changed since NV10 video scaler only supports 64 byte aligned
   surfaces. Note that changing these #defines causes ALL vidmem surfaces
   to be 64 byte aligned.
 */
#define NV3_BYTE_ALIGNMENT_PAD   15L
#define NV3_BIT_ALIGNMENT        128
#define NV4_BYTE_ALIGNMENT_PAD   31L
#define NV4_BIT_ALIGNMENT        256
#define NV10_BYTE_ALIGNMENT_PAD  63L
#define NV10_BIT_ALIGNMENT       512

#define NV10_INITIAL_PITCH    64
#define NV4_INITIAL_PITCH     32

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010

#ifndef NVD3D

#if _WIN32_WINNT < 0x0500
//*************************************************************************
// Misc stuff which changed between dx3 and dx5, Win95 and WinNT
//*************************************************************************
#define DDSCAPS_LOCALVIDMEM DDSCAPS_VIDEOMEMORY
#ifndef NV_AGP
// BUGBUG need to undefine this when AGP support arrives
#define DDSCAPS_NONLOCALVIDMEM DDSCAPS_SYSTEMMEMORY
#endif
#endif // #if _WIN32_WINNT < 0x0500
#endif  // #ifndef NVD3D

/***************************************************************************
 *
 * DEBUG stuff
 *
 ***************************************************************************/
#ifdef IS_32
#ifdef DEBUG
#if defined(_WIN32_WINNT)
#define DPF(a) DISPDBG((0, (a))
#define BREAK() EngDebugBreak();
#else
    extern void __cdecl DPF(LPSTR szFormat, ...);
    #define BREAK() DebugBreak();
#endif
#else
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif
#else
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif

#define DDRAW_SET_PRIMARY(ppdev, Offset, Stride)        \
       if (Stride < 32)                                 \
           ppdev->DdCurrentDestPitch = 32;              \
       else                                             \
           {                                            \
           ppdev->DdCurrentDestPitch = ((Stride + ppdev->ulSurfaceAlign ) & ~ppdev->ulSurfaceAlign);          \
           }                                            \
                                                        \
       ppdev->DdCurrentDestOffset = Offset;             \
       while (freeCount < 3*4)                          \
           freeCount = NvGetFreeCount(npDev, NV_DD_PRIMARY);    \
       freeCount -= 3*4;                                \
                                                        \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = ((ppdev->DdCurrentDestPitch << 16) | (ppdev->DdCurrentSourcePitch));  \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource = ppdev->DdCurrentSourceOffset;  \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = Offset

#define DDRAW_SET_SOURCE(ppdev, Offset, Stride)         \
    if (Stride < 32)                                    \
        ppdev->DdCurrentSourcePitch = 32;               \
    else                                                \
        {                                               \
        ppdev->DdCurrentSourcePitch = ((Stride + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);          \
        }                                               \
    ppdev->DdCurrentSourceOffset = Offset;              \
    while (freeCount < 3*4)                             \
        freeCount = NvGetFreeCount(npDev, NV_DD_PRIMARY);    \
    freeCount -= 3*4;                                   \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = ((ppdev->DdCurrentDestPitch <<16) | (ppdev->DdCurrentSourcePitch));    \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource = Offset;  \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = ppdev->DdCurrentDestOffset

#if (_WIN32_WINNT >= 0x0500) && defined(NV3) && !defined(DISPDRV)
#ifdef RM_HEAPMGR
#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define MEM_TYPE_PRIMARY                     8
#define MEM_TYPE_IMAGE_TILED                 9

extern BOOL __fastcall bMoveAllDfbsFromOffscreenToDibs(PDEV *);

// TBD: create a better way of allocating and freeing memory - huge macro!  Baaaadddd. -@mjl@
#define NVHEAP_ALLOC(pvm,sz,tp)             \
{                                           \
    NVOS11_PARAMETERS   HeapParams;         \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
                                            \
    if (!PPDEV()->DDrawVideoSurfaceCount)     \
    {                                       \
        PPDEV()->cbGdiHeap = PPDEV()->VideoHeapTotal -   \
        PPDEV()->VideoHeapFree;                      \
                                                                    \
    }                                       \
                                                    \
    HeapParams.hRoot = PPDEV()->hClient;  \
    HeapParams.hObjectParent = PPDEV()->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                         \
        PPDEV()->hDriver,            \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    if (!(pvm))                                                 \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(PPDEV());    \
        HeapParams.hRoot = PPDEV()->hClient;  \
        HeapParams.hObjectParent = PPDEV()->hDevice;                  \
        HeapParams.function = HEAP_ALLOC_SIZE;                      \
        HeapParams.owner    = 'NVDD';                               \
        HeapParams.type     = (tp);                                 \
        HeapParams.size     = (sz);                                 \
        EngDeviceIoControl(                         \
            PPDEV()->hDriver,            \
            (DWORD)IOCTL_NV01_ARCH_HEAP,            \
            (&pParms),                              \
            sizeof(PVOID),                          \
            pParms,                                 \
            sizeof(NVOS11_PARAMETERS),              \
            &cbReturned                             \
        );                                          \
        (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    }                                               \
    if (pvm)                                        \
        PPDEV()->VideoHeapFree = HeapParams.free;    \
}

#define NVHEAP_FREE(pvm)                    \
{                                           \
    NVOS11_PARAMETERS HeapParams;           \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
    HeapParams.hRoot = PPDEV()->hClient;      \
    HeapParams.hObjectParent = PPDEV()->hDevice; \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.owner    = 'NVDD';         \
    HeapParams.offset   = (U032)(pvm);      \
    EngDeviceIoControl(                         \
        PPDEV()->hDriver,                                \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    PPDEV()->VideoHeapFree = HeapParams.free;              \
}
#else // !RM_HEAPMGR
#define NVHEAP_INIT(strt, end, heap)  \
    heap_init((strt), (end), heap)
#define NVHEAP_INFO()
#define NVHEAP_CLEAR(heap)  \
    heap_clear(heap)
#define NVHEAP_ALLOC(pvm,sz,tp)             \
    (pvm) = heap_alloc(sz, (memory_t *) (ppdev)->heap.heap_2d_ptr);
#define NVHEAP_FREE(pvm)             \
    heap_free((pvm), (memory_t *) (ppdev)->heap.heap_2d_ptr);
#endif // !RM_HEAPMGR
#endif // NV3

//**************************************************************************************
// Common ddraw fct prototypes.
//**************************************************************************************
DWORD Nv3Blt(PDD_BLTDATA pbd);
DWORD Nv4Blt(PDD_BLTDATA pbd);
DWORD __stdcall DdCanCreateSurface(PDD_CANCREATESURFACEDATA lpCanCreateSurface );
DWORD DdCreateSurface(PDD_CREATESURFACEDATA lpCreateSurface);
DWORD __stdcall Nv3DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface );
DWORD __stdcall Nv4DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface );
DWORD __stdcall Nv3Flip(PDD_FLIPDATA pfd);
DWORD __stdcall Nv4Flip(PDD_FLIPDATA pfd);
DWORD Nv3GetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD Nv4GetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD WINAPI DdGetDriverInfo(struct _DD_GETDRIVERINFODATA *lpData);
DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD Nv3Lock(PDD_LOCKDATA lpLockData);
DWORD Nv4Lock(PDD_LOCKDATA lpLockData);
DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory);
DWORD __stdcall DdSetColorKey(PDD_SETCOLORKEYDATA lpSetColorKey);
DWORD __stdcall DdSetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
DWORD __stdcall Nv3Unlock( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv4Unlock( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv3UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData );
DWORD __stdcall Nv4UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData );
DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
#ifdef NVD3D
DWORD WINAPI GetAvailDriverMemory (PDD_GETAVAILDRIVERMEMORYDATA  pDmd);
#endif
DWORD GetScanLine32(PDD_GETSCANLINEDATA lpGetScanLine );
HRESULT Nv3UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem );
HRESULT Nv4UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem );
DWORD __stdcall Nv3UnlockOverlay( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv4UnlockOverlay( PDD_UNLOCKDATA lpUnlockData );
BOOLEAN bCreateNV4DDPatchPio(PDEV *ppdev);
BOOLEAN bDestroyNV4DDPatchPio(PDEV *ppdev);
DWORD Nv3GetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD Nv4GetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD __stdcall Nv3SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
DWORD __stdcall Nv4SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
extern DWORD __stdcall Nv3Blt8( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv3Blt16( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv3Blt32( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt8( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt16( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt32( PDD_BLTDATA pbd );

//------------------------------------------------------------------------------
// The minimum depth of the NV chip's FIFO -- never wait for the free count
// to reach a value greater than NV_GUARANTEED_FIFO_SIZE (124 bytes)!
//------------------------------------------------------------------------------

#define NV_GUARANTEED_FIFO_SIZE                 (0x007C)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\minii2c.c ===
/*----------------------------------------------------------------------------*/
/*
 * minii2c.c
 *
 *  I2C functionality for the miniport
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#ifdef NVPE

//#define INITGUID     // Instantiate GUID_I2C_INTERFACE

#include <ntstatus.h>
#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
typedef unsigned int    UINT;

#include "nv.h"
#include "nv32.h"
#include "nvos.h"

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif
#define PDEVICE_OBJECT  PVOID
#include "i2cgpio.h"

#define WDM_TO_VPE_COMMAND_MASK 0xdead0000

// backdoor VPE command functions
ULONG nvVPECommand(PHW_DEVICE_EXTENSION pHwDevExt, ULONG cmd, PVOID pData);
U032 vddWriteVPEPrescale(PHW_DEVICE_EXTENSION pHwDevExt, U032 ulX, U032 ulY, 
                         U032 ulCap, U032 ulVPUseOverlay, U032 ulFlag);

////////////////////////
// BUGBUG: The following section is extracted from nvmisc.h.
//         The miniport has no access to the nvidia\sdk directory !!!
//
//#include "nvmisc.h"
//
// control struct and defines for NvRmI2CAccess()
//
typedef struct
{
    unsigned long   token;
    unsigned long   cmd;
    unsigned long   port;
    unsigned long   flags;
    unsigned long   data;
    unsigned long   status;
} NVRM_I2C_ACCESS_CONTROL;

// commands
#define NVRM_I2C_ACCESS_ACQUIRE         1
#define NVRM_I2C_ACCESS_RELEASE         2
#define NVRM_I2C_ACCESS_WRITE_BYTE      3
#define NVRM_I2C_ACCESS_READ_BYTE       4
#define NVRM_I2C_ACCESS_NULL            5
#define NVRM_I2C_ACCESS_RESET           6

// flags
#define NVRM_I2C_ACCESS_START_FLAG      0x1
#define NVRM_I2C_ACCESS_STOP_FLAG       0x2
#define NVRM_I2C_ACCESS_ACK_FLAG        0x4

// port
#define NVRM_I2C_ACCESS_PRIMARY_PORT    1
#define NVRM_I2C_ACCESS_SECONDARY_PORT  2

// End of extracted section
//////////////////////////////////////////////

/*----------------------------------------------------------------------------*/
/*
 * misc defines and prototypes
 */

#define MINI_I2C_UNINITIALIZED  0
#define MINI_I2C_INITIALIZED    1
#define MINI_I2C_ACQUIRED   2

#define MINI_I2C_BASE_INST  0xa50f0001

extern ULONG i2cAccess(PVOID, U032, NVRM_I2C_ACCESS_CONTROL *);

/*----------------------------------------------------------------------------*/
/*
 * globals
 *
 */

static UINT     miniI2Cstate = MINI_I2C_UNINITIALIZED;
extern PHWINFO NvDBPtr_Table[];
static NVRM_I2C_ACCESS_CONTROL  rmI2CCtrl;


/*----------------------------------------------------------------------------*/
/*
 * miniI2COpen() - NV version of I2COpen()
 */

NTSTATUS miniI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT        acquire,
    PI2CControl     pI2CCtrl )
{

    UINT            rc;
    NTSTATUS            result = STATUS_SUCCESS;    /* just to be safe */
    PHWINFO         pNvInfo;
    PHW_DEVICE_EXTENSION pHwDevExt;
    ULONG           head = 0;

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));

    pNvInfo = NvDBPtr_Table[pHwDevExt->DeviceReference];

     /*
     * check for WDM backdoor to VPE request  (This is allow WDM drivers to set
     * some VPE parameters that aren't or can't be set by WDM's overlay mixer.)
     */

    if ( (pI2CCtrl->Command & 0xffff0000) == WDM_TO_VPE_COMMAND_MASK ) {
        rc = nvVPECommand (pHwDevExt, (pI2CCtrl->Command & 0x0000ffff), (void*) pI2CCtrl);
        pI2CCtrl->Status = rc;
        return rc;
    }

    /*
     * acquire/release I2C service
     */

    if ( acquire == TRUE ) {

    if ( miniI2Cstate == MINI_I2C_ACQUIRED ) {

        /* 
         * I2C has already been acquired, return error 
         */

        pI2CCtrl->dwCookie = 0;
        pI2CCtrl->Status = I2C_STATUS_BUSY;

        result = STATUS_OPEN_FAILED;

    }
    else {

        /* 
         * I2C is available so attempt to acquire it 
         */

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_ACQUIRE;
        rmI2CCtrl.port = NVRM_I2C_ACCESS_SECONDARY_PORT;
        rmI2CCtrl.flags = 0;

        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

        if ( rc != 0 ) {

        /* unable to get I2C service */
        pI2CCtrl->dwCookie = 0;
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_OPEN_FAILED;

        }
        else {

        /* I2C service was obtained */
        pI2CCtrl->dwCookie = MINI_I2C_BASE_INST; /* for lack of better cookie */
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        miniI2Cstate = MINI_I2C_ACQUIRED;
        result = STATUS_SUCCESS;

        }

    }

    }
    else {

    if ( (miniI2Cstate != MINI_I2C_ACQUIRED) || (pI2CCtrl->dwCookie != MINI_I2C_BASE_INST) ) {

        /* 
         * I2C has not been previously "acquired" or cookie is wrong 
         */

        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_INVALID_HANDLE;

    }
    else {

        /* 
         * I2C was previously acquired and cookie is valid, so ok to "release" 
         */

        rmI2CCtrl.cmd = NVRM_I2C_ACCESS_RELEASE;
        rmI2CCtrl.port = NVRM_I2C_ACCESS_SECONDARY_PORT;
        rmI2CCtrl.flags = 0;

        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

        if ( rc != 0 ) {

        /* error in releasing I2C */
        pI2CCtrl->dwCookie = 0;
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_OPEN_FAILED;

        }
        else {

        /* I2C released */
        pI2CCtrl->dwCookie = 0;
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
        miniI2Cstate = MINI_I2C_INITIALIZED;  /* ready to be acquired again */

        }

    }

    }

    return(result);

}

/*----------------------------------------------------------------------------*/
/*
 * miniI2CAccess - NV version of I2CAccess()
 */

NTSTATUS miniI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{
    UINT            rc;
    ULONG           startFlag;
    ULONG           stopFlag;
    ULONG           ackFlag;
    NTSTATUS            result = STATUS_SUCCESS;
    ULONG           readData = 0;
    //NVRM_I2C_ACCESS_CONTROL   rmI2CCtrl;
    PHWINFO         pNvInfo;
    PHW_DEVICE_EXTENSION pHwDevExt;
    ULONG           head = 0;

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));
    pNvInfo = NvDBPtr_Table[pHwDevExt->DeviceReference];

    /*
     * make sure I2C has been acquired
     */

    if ( (miniI2Cstate == MINI_I2C_UNINITIALIZED) || 
     (miniI2Cstate == MINI_I2C_INITIALIZED) ||
     (pI2CCtrl->dwCookie != MINI_I2C_BASE_INST) ) {

        pI2CCtrl->Status = I2C_STATUS_ERROR;
    return(STATUS_INVALID_HANDLE);

    }

    /*
     * retrieve the flags we can deal with
     */

    startFlag = pI2CCtrl->Flags & I2C_FLAGS_START;
    stopFlag = pI2CCtrl->Flags & I2C_FLAGS_STOP;
    ackFlag = pI2CCtrl->Flags & I2C_FLAGS_ACK;

    rmI2CCtrl.flags = 0;

    if ( startFlag ) {
    rmI2CCtrl.flags |= NVRM_I2C_ACCESS_START_FLAG;
    }

    if ( stopFlag ) {
    rmI2CCtrl.flags |= NVRM_I2C_ACCESS_STOP_FLAG;
    }

    if ( ackFlag ) {
    rmI2CCtrl.flags |= NVRM_I2C_ACCESS_ACK_FLAG;
    }

    /*
     * handle the command
     */

    rmI2CCtrl.port = NVRM_I2C_ACCESS_SECONDARY_PORT;

    switch ( pI2CCtrl->Command ) {

      case I2C_COMMAND_WRITE:

    rmI2CCtrl.cmd = NVRM_I2C_ACCESS_WRITE_BYTE;
    rmI2CCtrl.data = pI2CCtrl->Data;
        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

    if ( rc == 0 ) {
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_ADAPTER_HARDWARE_ERROR;
    }

        break;

      case I2C_COMMAND_READ:

    rmI2CCtrl.cmd = NVRM_I2C_ACCESS_READ_BYTE;
        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

    if ( rc == 0 ) {
        pI2CCtrl->Data = (BYTE) (rmI2CCtrl.data & 0xFF);             // returned byte
        pI2CCtrl->Reserved[0] = (BYTE)((rmI2CCtrl.data >> 8) & 0xFF);
        pI2CCtrl->Reserved[1] = (BYTE)((rmI2CCtrl.data >> 16) & 0xFF);
        pI2CCtrl->Reserved[2] = (BYTE)((rmI2CCtrl.data >> 24) & 0xFF);
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_ADAPTER_HARDWARE_ERROR;
    }

        break;

      case I2C_COMMAND_NULL:

    rmI2CCtrl.cmd = NVRM_I2C_ACCESS_NULL;
        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

    if ( rc == 0 ) {
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_ADAPTER_HARDWARE_ERROR;
    }

        break;

      case I2C_COMMAND_STATUS:

    if ( miniI2Cstate == MINI_I2C_ACQUIRED ) {
        /* nothing is going on just return success */
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        /* not applicable since we're synchronous but return something reasonable just in case */
        pI2CCtrl->Status = I2C_STATUS_BUSY;
        result = STATUS_DEVICE_BUSY;
    }

        break;

      case I2C_COMMAND_RESET:

    rmI2CCtrl.cmd = NVRM_I2C_ACCESS_NULL;
        rc = i2cAccess(pNvInfo, head, &rmI2CCtrl);

    if ( rc == 0 ) {
        pI2CCtrl->Status = I2C_STATUS_NOERROR;
        result = STATUS_SUCCESS;
    }
    else {
        pI2CCtrl->Status = I2C_STATUS_ERROR;
        result = STATUS_ADAPTER_HARDWARE_ERROR;
    }

        break;

      default:
    
    pI2CCtrl->Status = I2C_STATUS_ERROR;
    result = STATUS_INVALID_PARAMETER;

        break;

    }

    return(result);

}

/*
 * nvVPECommand() is a backdoor function to allow other Ring0 programs (like WDM)
 * to change or request various VPE functions.
 */

#define NV_VPE_CMD_SET_PRESCALE_MODE    1
#define NV_VPE_CMD_SET_CROP_MODE        2

ULONG nvVPECommand (
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG cmd,
    PVOID pData )
{

    switch ( cmd ) {

    case NV_VPE_CMD_SET_PRESCALE_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to prescale
         * as oppose to cropping.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * set prescale flag and size
             */
            //Data(lower nibble)    =   0   not capturing
            //                          1   capturing
            //Data(upper nibble)    =   2   X scale
            //                          4   Y scale
            //Status    =   prescale/height * 1000
            if((pI2CCtrl->Data)& 0x40){
                vddWriteVPEPrescale(pHwDevExt,
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Status,//set Y-prescale 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    6);                             //prog. y-pre & cap. flag
            }else if((pI2CCtrl->Data)& 0x20){
                vddWriteVPEPrescale(pHwDevExt,
                                    ((PI2CControl)pI2CCtrl)->Status,//set X-prescale
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    0xa);                           //prog. x-pre & cap.flag
            }else if(!((pI2CCtrl->Data)& 0x1)){
                vddWriteVPEPrescale(pHwDevExt,
                                    0,
                                    0, 
                                    0,  //capture flag=0 (not capturing)
                                    0, 
                                    0x2);   
            }
        }
        break;

    case NV_VPE_CMD_SET_CROP_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to crop
         * as oppose to prescaling.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * turn off prescale flag
             */

        }
        break;

    default:
        return 1;   
    }

    return 0;
}

void nvpeVDDInit(PHW_DEVICE_EXTENSION pHwDevExt)
{
    //Initialize VPE capture hack for WDM
    vddWriteVPEPrescale(pHwDevExt,
                        1000,   //setting ME X-prescale factor. 1000=no scale
                        1000,   //setting ME Y-prescale factor. 1000=no scale
                        0,      //set to not vpe capture mode 
                        0,      //set default VP surf type = overlay 
                        0xf);   //use all values

}

// A mechanism to populate the WDM prescale values
// This is a back door mechanism and should not really be in this module.
U032 vddWriteVPEPrescale(PHW_DEVICE_EXTENSION pHwDevExt, U032 ulX, U032 ulY, 
                         U032 ulCap, U032 ulVPNotUseOverlay, U032 ulFlag)
{
    PNVP_CONTEXT pVPEContext;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "nvpekmvt: vddWriteVPEPrescale()\n");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    
    if(ulFlag & 0x8){
        pVPEContext->ulVPECapturePrescaleXFactor=ulX;
    }

    if(ulFlag & 0x4){
        pVPEContext->ulVPECapturePrescaleYFactor=ulY;
    }

    if(ulFlag & 0x2){
        pVPEContext->ulVPECaptureFlag=ulCap;
    }

    if(ulFlag & 0x1){
        pVPEContext->ulVPNotUseOverSurf=ulVPNotUseOverlay;
    }


    return 0;
}

#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modehw.c ===
//
// modehw.c -  OS specific NV register access routines for mode set code.
//
// These Win NT specific routines access the NV3 through a series of NV
// engine pointers contained in the global HwDeviceExtension and frame
// buffer pointer, fbAddr.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"
#include "nv3a_ref.h"

#include "modes.h"

PHW_DEVICE_EXTENSION HwDeviceExtension;
PHWREG fbAddr;

//******************************************************************************
// External function declarations
//******************************************************************************

// write a dword value to a fb address
VOID WriteFb32(U032 datum, U032 addr)
{
    MEM_WR32(addr, datum);
}


// read a dword value from a fb address
U032 ReadFb32(U032 addr)
{
    return MEM_RD32(addr);
}


// write a dword value to an NV register
// assume extended CRTC registers are unlocked
VOID WritePriv32(U032 datum, U032 addr)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR32(PRMVIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR32(PRMCIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRAMDAC) && addr < DEVICE_BASE(NV_PRAMDAC) + DEVICE_EXTENT(NV_PRAMDAC))
    {
        PRAMDAC_REG_WR32(PRAMDAC_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PFB) && addr < DEVICE_BASE(NV_PFB) + DEVICE_EXTENT(NV_PFB))
    {
        PFB_REG_WR32(PFB_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PMC) && addr < DEVICE_BASE(NV_PMC) + DEVICE_EXTENT(NV_PMC))
    {
        PMC_REG_WR32(PMC_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PEXTDEV) && addr < DEVICE_BASE(NV_PEXTDEV) + DEVICE_EXTENT(NV_PEXTDEV))
    {
        PEXTDEV_REG_WR32(PEXTDEV_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PBUS) && addr < DEVICE_BASE(NV_PBUS) + DEVICE_EXTENT(NV_PBUS))
    {
        PBUS_REG_WR32(PBUS_Base, addr, datum);
        return;
    }

    // catch bad ranges
    //DebugBreakPoint();
}


// read a dword value from an NV register
U032 ReadPriv32(U032 addr)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        return PRMVIO_REG_RD32(PRMVIO_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        return PRMCIO_REG_RD32(PRMCIO_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PRAMDAC) && addr < DEVICE_BASE(NV_PRAMDAC) + DEVICE_EXTENT(NV_PRAMDAC))
    {
        return PRAMDAC_REG_RD32(PRAMDAC_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PFB) && addr < DEVICE_BASE(NV_PFB) + DEVICE_EXTENT(NV_PFB))
    {
        return PFB_REG_RD32(PFB_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PMC) && addr < DEVICE_BASE(NV_PMC) + DEVICE_EXTENT(NV_PMC))
    {
        return PMC_REG_RD32(PMC_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PEXTDEV) && addr < DEVICE_BASE(NV_PEXTDEV) + DEVICE_EXTENT(NV_PEXTDEV))
    {
        return PEXTDEV_REG_RD32(PEXTDEV_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PBUS) && addr < DEVICE_BASE(NV_PBUS) + DEVICE_EXTENT(NV_PBUS))
    {
        return PBUS_REG_RD32(PBUS_Base, addr);
    }

    // catch bad ranges
    //DbgBreakPoint();

	return(0);
}

// write a data word to Priveledged IO
VOID WriteIndexed(U032 addr, U016 datum)
{
    //
    // Keep it 8bit to be safe; index in lower byte, data in upper
    //
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, datum & 0xFF);
        PRMVIO_REG_WR08(PRMVIO_Base, addr+1, (datum >> 8) & 0xFF);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, datum & 0xFF);
        PRMCIO_REG_WR08(PRMCIO_Base, addr+1, (datum >> 8) & 0xFF);
        return;
    }

    // catch bad ranges
    //DbgBreakPoint();

}


// write a data byte to Priveledged IO
VOID WritePriv08(U032 addr, U008 datum)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_USER_DAC) && addr < DEVICE_BASE(NV_USER_DAC) + DEVICE_EXTENT(NV_USER_DAC))
    {
        USERDAC_REG_WR08(USERDAC_Base, addr, datum);
        return;
    }

    // catch bad ranges
    //DbgBreakPoint();

}

// read a data word from Priveledged IO
U016 ReadIndexed(U032 addr, U008 reg)
{
    U016   datum;

    //
    // Return the data in the upper byte, index in the lower
    //
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, reg);
        datum = (PRMVIO_REG_RD08(PRMVIO_Base, addr+1) << 8) & 0xFF00;
        datum |= reg;
        return datum;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, reg);
        datum = (PRMCIO_REG_RD08(PRMCIO_Base, addr+1) << 8) & 0xFF00;
        datum |= reg;
        return datum;
    }

    // catch bad ranges
    //DbgBreakPoint();

	return(0);
}


// end of modehw.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modedata.c ===
//
// modedata.c - Data tables used for setting extended VESA modes.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    "modes.h"
#endif // DOS_COMPILE
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"

#define POLAR_NEG_NEG        0x0c0
#define POLAR_POS_NEG        0x040
#define POLAR_NEG_POS        0x080
#define POLAR_POS_POS        0x000




VGATBL   vga_tbl[] =
{
    // Basic CRTC Table for Packed Pixel Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
     0x05, 0x0F, 0xFF}
    },

    // Basic CRTC Table for Planar Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xA000,
    {0x01, 0x0F, 0x00, 0x06},
     0xE3,
    {0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C,
     0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B,
     0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x05, 0x0F, 0xFF}
    }
};

EXTREGS eregs[] =    // Extended Register Tables
{
    {0x49, 0x00, 0x20, 0x30, 0xFF, 0xFF, 0x0000, CLKID_25_175}, // 00: VGA Modes      00:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 08: Mode 5F/101    01:
    {0x48, 0x00, 0x20, 0x30, 0x32, 0xFF, 0xFA00, CLKID_40},     // 09: Mode 58/6A/102 02:
    {0x4C, 0x00, 0x20, 0x39, 0x64, 0xFF, 0xFFFF, CLKID_40},     // 0A: Mode 5C/103    03:
    {0x48, 0x00, 0x20, 0x30, 0x40, 0xFF, 0xFFFF, CLKID_65},     // 0B: Mode 5D/104    04:
    {0x4C, 0x00, 0x20, 0x39, 0x80, 0xFF, 0xFFFF, CLKID_65},     // 0C: Mode 5E/105    05:
    {0x08, 0x00, 0x15, 0x30, 0x50, 0xFF, 0xFFFF, CLKID_108_5},  // 0F: Mode 5A/106    06:
    {0x0C, 0x00, 0x15, 0x39, 0xA0, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    07:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 08:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 09:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0A:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0B:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0C:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 22: Mode 78        0D:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 23: Mode 6E        0E:
    {0x44, 0x80, 0x20, 0x3A, 0xC8, 0xFF, 0xFFFF, CLKID_40},     // 24: Mode 6F        0F:
    {0x54, 0x81, 0x20, 0x3A, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72        10:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        11:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        12:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        13:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        14:
    {0x44, 0x00, 0x20, 0x3B, 0xC8, 0xFF, 0xFFFF, CLKID_20},     // 27: Mode 20        15:
    {0x44, 0x00, 0x20, 0x3B, 0xF0, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72        16:
    {0x54, 0x01, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72        17:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        18:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 28: Mode 21        19:
    {0x54, 0x01, 0x20, 0x3B, 0x90, 0xFF, 0xFFFF, CLKID_40},     // 29: Mode 22        1A:
    {0x54, 0x01, 0x20, 0x3B, 0xE0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72        1B:
    {0x64, 0x02, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72        1C:
    {0x24, 0x02, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        1D:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x4000, CLKID_12_588}, // 27: Mode 20        1E:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x8000, CLKID_12_588}, // 27: Mode 20        1F:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x5000, CLKID_12_588}, // 27: Mode 20        20:
    {0x4C, 0x00, 0x20, 0x39, 0x32, 0xFF, 0x8000, CLKID_20},     // 27: Mode 20        21:
    {0x4C, 0x00, 0x20, 0x39, 0x3C, 0xFF, 0xB000, CLKID_27_93},  // 25: Mode 72        22:
    {0x4C, 0x00, 0x20, 0x39, 0x40, 0xFF, 0xD000, CLKID_32_5},   // 25: Mode 72        23:
    {0x4C, 0x00, 0x20, 0x39, 0x78, 0xFF, 0xFFFF, CLKID_55_86},  // 0C: Mode 5E/105    24:
    {0x0C, 0x00, 0x20, 0x39, 0x90, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        25:
    {0x0C, 0x00, 0x0F, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        26:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        27:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xA000, CLKID_12_588}, // 27: Mode 20        28:
    {0x44, 0x80, 0x20, 0x3A, 0x64, 0xFF, 0xF000, CLKID_20},     // 27: Mode 20        29:
    {0x44, 0x80, 0x20, 0x3A, 0x78, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72        2A:
    {0x44, 0x80, 0x20, 0x3A, 0x80, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72        2B:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        2C:
    {0x44, 0x80, 0x20, 0x3A, 0xF0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72        2D:
    {0x14, 0x81, 0x20, 0x3A, 0x20, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        2E:
    {0x14, 0x81, 0x15, 0x3A, 0x40, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    2F:
    {0x14, 0x81, 0x0F, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        30:
    {0x24, 0x02, 0x15, 0x3B, 0x80, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    31:
    {0x24, 0x03, 0x0F, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        32:

    // JJV - New Modes (I think this starts at 0x33 ??)
    {0x0C, 0x40, 0x0F, 0x79, 0xE1, 0xFF, 0xFFFF, CLKID_219_566}, // 33: 1800X1440X8
    {0x0C, 0x41, 0x0F, 0x7A, 0xC2, 0xFF, 0xFFFF, CLKID_219_566}, // 34: 1800X1440X16
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_172_798}, // 35: 1920X1080X8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_172_798}, // 36: 1920X1080X16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_172_798}, // 37: 1920X1080X32
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_193_156}, // 38: 1920X1200X8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_193_156}, // 39: 1920X1200X16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_193_156},  // 3A: 1920X1200X32
    // JJV - New Modes

    // VEL - New Dell Modes
    {0x0C, 0x40, 0x05, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_136_36},  // 3B: 1600x1024x8      
    {0x0C, 0x41, 0x05, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_136_36},  // 3C: 1600x1024x16     
    {0x0C, 0x43, 0x05, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_136_36}   // 3D: 1600x1024x32     
    // VEL - New Dell Modes

};

TVREGS tvregs[] =    // TV Timing Tables
{
    {0x60, 0x00, 0x67, 0x5B, 0x31, 0x2E, 0xDE, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 0 - VGA Mode 3
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xA9, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 1 - VGA Mode 11/12
    {0x60, 0x00, 0x68, 0x5B, 0x23, 0x3E, 0xDE, 0x4F, 0x4F, 0x8B, 0x85, 0x38, 0x8F, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0xA1, 0xBA, 0x30, 0x4F, 0x50, 0x00, 0x85, 0x05, 0x7F, 0xE0, 0x0D },   // TV Mode 2 - VGA Mode 13
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xD0, 0xFF, 0x0D,
     0x06, 0x82, 0x70, 0x81, 0xF8, 0x30, 0x63, 0x63, 0x8B, 0x85, 0x05, 0x00, 0xE0, 0x0D },   // TV Mode 3 - VGA Modes > 640x480
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0x90, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 4 - 640x400 Extended Modes
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D }   // TV Mode 5 - 640x480 Extended Modes
};

//
// Mode clock frequencies
//
U016 tblClockFreq[] =
{
    5035,       // 00: 50.350
    5664,       // 01: 56.644
    3325,       // 02: 33.250
    5200,       // 03: 52.000
    8000,       // 04: 80.000
    6300,       // 05: 63.000
    0000,       // 06: Ext
    7500,       // 07: 75.000 (1024x768@70)
    2518,       // 08: 25.175 (VGA)
    2832,       // 09: 28.322 (VGA)
    3150,       // 0A: 31.500 (640x480@72)
    3600,       // 0B: 36.000 (800x600@56)
    4000,       // 0C: 40.000 (800x600@60)
    4490,       // 0D: 44.900 (1024x768@87i)
    5000,       // 0E: 50.000 (800x600@72)
    6500,       // 0F: 65.000 (1024x768@60)
    10800,      // 10: 108.000/2 (1280x1024@60) use clock doubler
    13500,      // 11: 135.000/2 (1280x1024@75) use clock doubler
    4950,       // 12: 49.500
    5625,       // 13: 56.250
    7875,       // 14: 78.750
    9450,       // 15: 94.500
    10850,      // 16: 108.500/2 use clock doubler
    3550,       // 17: 35.500
    15800,      // 18: 158.000/2 use clock doubler
    5586,       // 19: 55.860
    2000,       // 1A: 20.000
    2793,       // 1B: 27.930
    3250,       // 1C: 32.500
    1259,       // 1D: 12.588 (VGA/2)
    8162,       // 1E: 81.624
    21957,      // 1F: 219.566
    17280,      // 20: 172.798
    19316,      // 21: 193.156
    22950,      // 22: 229.50 (for max dot clock)
    13636       // 23: 136.36
};

U016 DMTOverrideTable[NUMBER_OF_MODES*NUMBER_OF_RATES][13] =
{
    //0:
    // Settings for 1600x1200:
    16200, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    18900, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    20250, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    22950, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    //1:
    // Settings for 1280x1024:
    10800, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a7, 0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    13500, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a3,   0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    15750, POLAR_POS_POS, 0x0d3, 0x09f, 0x097, 0x0a9,   0x01d, 0x02e, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x02f,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    //2:
    // Settings for 1152x864:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    10800, POLAR_POS_POS, 0x0c3, 0x08f, 0x087, 0x099, 0x009, 0x082, 0x0ff, (0x061-1), (0x024-1) | 0x080, 0x05f, 0x083,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //3:
    // Settings for 1024x768:
    6500 , POLAR_NEG_NEG, 0x0a3, 0x07f, 0x087, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7500 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
// 72Hz does not appear in DMT, so this is a fudge of the GTF's
    7843 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x085, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7875 , POLAR_POS_POS, 0x09f, 0x07f, 0x083, 0x083, 0x08f, 0x01e, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x01f,
    9450 , POLAR_POS_POS, 0x0a7, 0x07f, 0x08b, 0x087, 0x093, 0x026, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x027,
// 100Hz does not appear in DMT, so this is a fudge of the GTF's
    11370, POLAR_POS_POS, 0x0a9, 0x07f, 0x08D, 0x086, 0x098, 0x02C, 0x0f5, (0x002-1), (0x024-1) | 0x080, 0x0ff, 0x027,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //4:
    // Settings for 960x720:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //5:
    // Settings for 800x600:
    4000 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x06a, 0x01a, 0x072, 0x0f0, (0x059-1), (0x02d-1) | 0x080, 0x057, 0x073,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    5000 , POLAR_POS_POS, 0x07d, 0x063, 0x081, 0x06c, 0x01b, 0x098, 0x0f0, (0x07d-1), (0x023-1) | 0x080, 0x057, 0x099,
    4950 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x067, 0x011, 0x06f, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x070,
    5625 , POLAR_POS_POS, 0x07e, 0x063, 0x082, 0x069, 0x011, 0x075, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x076,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //6:
    // Settings for 640x480:
    2517 , POLAR_NEG_NEG, 0x05f, 0x04f, 0x083, 0x053, 0x09f, 0x00b, 0x03e, (0x0ea-1), (0x02c-1) | 0x080, 0x0df, 0x00c,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    3150 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x054, 0x099, 0x006, 0x03e, (0x0e9-1), (0x02c-1) | 0x080, 0x0df, 0x007,
    3150 , POLAR_NEG_NEG, 0x064, 0x04f, 0x088, 0x053, 0x09b, 0x0f2, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0f3,
    3600 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x058, 0x09f, 0x0fb, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0fc,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //7:
    // Settings for 640x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //8:
    // Settings for 512x384:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //9:
    // Settings for 480x360:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //10:
    // Settings for 400x300:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //11:
    // Settings for 320x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //12:
    // Settings for 320x240:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //13:
    // Settings for 320x200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //14:
    // Settings for 1920x1200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //15:
    // Settings for 1920x1080:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //16:
    // Settings for 1800x1440:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //17:
    // Settings for 1600x1024:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

};

//  this table translates resolutions into their VESA BIOS mode equivalents
U016 ModeSetTable[NUMBER_OF_MODES*NUMBER_OF_DEPTHS] =
{
    // depths: 4 (planar modes), 8, 16, 24/32
    //0:
    // 1600 x 1200
    0xff, 0x145, 0x146, 0x14E,
    //1:
    // 1280 x 1024
    0x106, 0x107, 0x11a, 0x14D,
    //2:
    // 1152 x 864
    0xff, 0x141, 0x142, 0x143,
    //3:
    // 1024 x 768
    0x104, 0x105, 0x117, 0x118,
    //4:
    // 960 x 720
    0xff, 0x14a, 0x14b, 0x14c,
    //5:
    // 800 x 600
    0x102, 0x103, 0x114, 0x115,
    //6:
    // 640 x 480
    0xff, 0x101, 0x111, 0x112,
    //7:
    // 640 x 400
    0xff, 0x100, 0x13d, 0x13e,
    //8:
    // 512 x 384
    0xff, 0x13a, 0x13b, 0x13c,
    //9:
    // 480 x 360
    0xff, 0x147, 0x148, 0x149,
    //10:
    // 400 x 300
    0xff, 0x137, 0x138, 0x139,
    //11:
    // 320 x 400
    0xff, 0x131, 0x132, 0x133,
    //12:
    // 320 x 240
    0xff, 0x134, 0x135, 0x136,
    //13:
    // 320 x 200
    0xff, 0x130, 0x10e, 0x10f,

    //14:
    // 1920 x 1200
    0xff, 0x154, 0x155, 0x156,
    //15:
    // 1920 x 1080
    0xff, 0x151, 0x152, 0x153,
    //16:
    // 1800 x 1440
    0xff, 0x14f, 0x150, 0xff,

    //17:
    // 1600 x 1024
    0xff, 0x157, 0x158, 0x159


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\dspioctl.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     dspioctl.h
//
// Abstract:
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "nvMultiMon.h"
//******************************************************************************
// Number of dacs
//******************************************************************************
#define NV_NO_DACS                  2

//******************************************************************************
// Private IOCTL info - Used by all components of the display driver
//******************************************************************************

#define IOCTL_VIDEO_GET_VIDEO_CARD_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_RESTORE_DISPLAY_PATCH    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2050, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2051, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2052, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2053, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_VBLANK_FLAG    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2054, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_NV_PFIFO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2055, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_WRITE_COMBINING \
        CTL_CODE (FILE_DEVICE_VIDEO, 2056, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2057, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT \
        CTL_CODE (FILE_DEVICE_VIDEO, 2058, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SYSMEM_SHARE_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2059, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2060, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_LOCK_DOWN_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2061, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNLOCK_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2062, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_TO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2063, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNMAP_FROM_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2064, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_DEVICE_REF \
        CTL_CODE (FILE_DEVICE_VIDEO, 2065, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ALLOC_AGP_MEM \
        CTL_CODE (FILE_DEVICE_VIDEO, 2066, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_FREE_AGP_MEM  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2067, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_PIXMIX_INDEX \
                CTL_CODE (FILE_DEVICE_VIDEO, 2068, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_VPE_COMMAND \
        CTL_CODE (FILE_DEVICE_VIDEO, 2069, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_VAL  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2071, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_REGISTRY_VALUE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2072, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2073, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_DISPLAY_DEVICE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2075, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_DISPLAY_DEVICE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2076, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VALIDATE_DEVICE_MODE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2077, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2078, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_GAMMA_CLUT  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2079, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_MAP_PHYS_ADDR  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2080, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_PHYS_ADDR  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2081, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_SYSTEM_MEMORY_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2082, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2083, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_STOP_TIMER_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2084, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2085, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_DESKTOP_INFO_MODE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2086, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TIMING_DAC \
        CTL_CODE (FILE_DEVICE_VIDEO, 2087, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_PREMODE_SET \
        CTL_CODE (FILE_DEVICE_VIDEO, 2088, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_POSTMODE_SET \
        CTL_CODE (FILE_DEVICE_VIDEO, 2089, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TWINVIEW_STATE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2090, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_TWINVIEW_STATE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2091, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_NUMBER_DACS \
        CTL_CODE (FILE_DEVICE_VIDEO, 2092, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING \
        CTL_CODE (FILE_DEVICE_VIDEO, 2093, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SAVE_GAMMA_VALUES \
        CTL_CODE (FILE_DEVICE_VIDEO, 2094, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESTORE_GAMMA_VALUES \
        CTL_CODE (FILE_DEVICE_VIDEO, 2095, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_PCI_SLOT  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2096, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2097, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _GET_NUMBER_DACS
{
    ULONG ulNumberDacsOnBoard;          // Number of heads on the board.
    ULONG ulNumberDacsConnected;        // Number of heads connected to any device.
    ULONG ulAllDeviceMask;              // Bitmask for all connectors in the board.
    ULONG ulConnectedDeviceMask;        // Bitmask for all connected devices in the system.
    ULONG ulDeviceMask[NV_NO_DACS];     // The bitmask of device connected to the head.
                                       // defined in nvcm.h
    ULONG ulDeviceType[NV_NO_DACS];     // The type of device connected to the head viz., CRT, TV, FlatPanel
                                       // defined in nvcm.h
    ULONG ulTVFormat[NV_NO_DACS];       // The TV type: defined in nvcm.h
    ULONG ulHeadDeviceOptions[NV_NO_DACS]; // A matrix of possible device options for each head.

} GET_NUMBER_DACS;

typedef struct _HEAD_MODE_LIST_INFO
{
    ULONG ulHead;
    ULONG ulEnableDDC;
    ULONG ulDeviceMask;
    ULONG ulDeviceType;
    ULONG ulTVType;
    ULONG ulNumVirtualModes;
    MODE_ENTRY *pVirtualModeList;
    MODE_ENTRY *pPhysicalModeList;    // Caller should have allocated this memory. It is assumed that this
                                      // PhysicalModeList is atleast as big as the VirtualModeList.
} HEAD_MODE_LIST_INFO;

typedef struct _NV_DESKTOP_INFO
{
    ULONG ulDesktopMode;                // 0x0000 -> Single Monitor
    ULONG ulDesktopModeIndex;           // Display driver set the requested mode index  
    ULONG ulDesktopWidth;               // Miniport driver return the width based on the mode index
    ULONG ulDesktopHeight;              // Miniport driver return the height based on the mode index
    ULONG ulDisplayWidth[NV_NO_DACS];   // Display driver set these values; 
    ULONG ulDisplayHeight[NV_NO_DACS];  // control panel should give it to display driver
    ULONG ulDisplayRefresh[NV_NO_DACS]; // refresh rate 
    ULONG ulDisplayPixelDepth[NV_NO_DACS]; // Color Depth
    ULONG ulNumberDacsOnBoard;          // Number of DACs on the board
    ULONG ulNumberDacsConnected;        // Number of DACs which have a device (CRT/DFP/TV) connected to them
    ULONG ulNumberDacsActive;           // Number of DACs which are currently active. For example, in the Normal
                                        // mode, this value will be 1.
    ULONG ulAllDeviceMask;              // Bitmask of all output connectors in the board.
    ULONG ulConnectedDeviceMask;        // Bitmask for all connected devices in the system.
    ULONG ulDeviceMask[NV_NO_DACS];     // The bitmask of device connected to the head.
                                        // defined in nvcm.h
    ULONG ulDeviceType[NV_NO_DACS];     // The type of device connected to the head viz., CRT, TV, FlatPanel
                                        // defined in nvcm.h
    ULONG ulTVFormat[NV_NO_DACS];       // The TV type: defined in nvcm.h
    ULONG ulDeviceDisplay[NV_NO_DACS];  // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
    ULONG ulHeadDeviceOptions[NV_NO_DACS];    // A matrix of possible device options for each head. Defined in nvMultiMon.h.
                                                // This info is used mainly by the NV control panel and gets scanned in after each
                                                // modeset since this matrix can be changed by the RM after a modeset.
                                                // This is a static entity as opposed to ulDeviceType[NV_NO_DACS] which specifies
                                                // the currently selected device type for this head.

} NV_DESKTOP_INFO;

typedef struct _NV_CURSOR_INFO
{
    LONG    lCursorX;
    LONG    lCursorY;
    LONG    lCursorWidth;
    LONG    lCursorHeight;
    LONG    lScreenStride;
    LONG    lScreenPixelDepth;
    ULONG   ulHwCursorWidth;
    ULONG   ulOriginalImageMemOffset;
    ULONG   ulCursorMemOffset;
} NV_CURSOR_INFO;

typedef struct _NV_SYSMEM_SHARE_MEMORY
    {
    PVOID pSystemMdl;           // MDL for locked down memory
    PVOID userVirtualAddress;   // user virtual address
    PVOID ddVirtualAddress;     // display driver virtual address
    ULONG physicalAddress;      // physical address of memory
    ULONG byteLength;           // byte length of data to lock down
    } NV_SYSMEM_SHARE_MEMORY;


typedef struct _NV_LOCK_DOWN_MEMORY
    {
    PVOID virtualAddress; // display driver virtual address
    ULONG byteLength;     // byte length of data to lock down
    PVOID pMdl;           // MDL for locked down memory
    } NV_LOCK_DOWN_MEMORY;

typedef struct _NV_UNLOCK_MEMORY
    {
    PVOID pMdl;           // MDL for memory to unlock
    } NV_UNLOCK_MEMORY;

//
// AGP memory block node structure.
//
typedef struct _AGP_MEM
    {
    ULONG   hContext;       // Addr context of process
    ULONG   cb;             // Size of memory region in bytes
    PVOID   VirtualAddress; // Based address of Virtual AGP buffer
    } *PAGP_MEM, AGP_MEM;

//
// Registry set structure
//
typedef struct _NV_REGISTRY_STRUCT
    {
    PWSTR keyName;          // Name of key in unicode string format
    PVOID keyVal;           // pointer to key value
    ULONG keyValSize;       // Size of Key Value;
    } *PNV_REGISTRY_STRUCT, NV_REGISTRY_STRUCT;

#if _WIN32_WINNT >= 0x0500
//
// System Memory Information structure
//
typedef struct _NV_SYSMEM_INFO
    {
    ULONGLONG SystemMemorySize;      // Physical memory size in bytes
    ULONGLONG AgpAllocationLimit;    // Max recommended size in bytes for committed AGP meme
    } *PNV_SYSMEM_INFO, NV_SYSMEM_INFO;
#endif // _WIN32_WINNT >= 0x0500


typedef struct _RESOLUTION_INFO
{
    ULONG ulDisplayWidth; 			// width  
    ULONG ulDisplayHeight;  		// Height
    ULONG ulDisplayRefresh;  		// refresh rate 
    ULONG ulDisplayPixelDepth; // Color Depth
} RESOLUTION_INFO;

typedef struct _HEAD_RESOLUTION_INFO
{
    ULONG ulDisplayWidth; 			// width  
    ULONG ulDisplayHeight;  		// Height
    ULONG ulDisplayRefresh;  		// refresh rate 
    ULONG ulDisplayPixelDepth;      // Color Depth
    ULONG ulHead;                     // Whether 0 or 1. This is the physical head number
    ULONG ulDeviceMask;             // Bitmask of Device.
    ULONG ulDeviceType;             // Device type of the head.
    ULONG ulTVFormat;
} HEAD_RESOLUTION_INFO;


typedef struct _dac_timing_values
{  
    unsigned int HorizontalVisible; 
    unsigned int VerticalVisible;
    unsigned int Refresh;
    unsigned int HorizontalTotal; 
    unsigned int HorizontalBlankStart; 
    unsigned int HorizontalRetraceStart; 
    unsigned int HorizontalRetraceEnd; 
    unsigned int HorizontalBlankEnd;
    unsigned int VerticalTotal; 
    unsigned int VerticalBlankStart; 
    unsigned int VerticalRetraceStart; 
    unsigned int VerticalRetraceEnd; 
    unsigned int VerticalBlankEnd;
    unsigned int PixelClock;
    unsigned int HSyncpolarity; 
    unsigned int VSyncpolarity; 
} DAC_TIMING_VALUES;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modesetNT.c ===
//
// modeset.c -  Program to set a VESA mode. Assumes the controller is
//              already initialized.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifndef NTMINIPORT

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    <stdlib.h>
#else
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <vga.h>
#endif // DOS_COMPILE

#include    "modes.h"
#include    "modedata.c"
#include    "modehw.h"
#include "nvhw.h"

#else

//*****************************************************************************
//
// NV1/NV3/NV4 conventions...
//
//       This modeset code was originally designed to be compiled for each
//       version of the chip (NV1/NV3/NV4).  However, this miniport was designed
//       to work with ALL versions of the chip.  That is, the original modeset
//       code had to be compiled for each chip.  But since this miniport
//       determines which chip it's running on at RUN time (i.e. we don't
//       compile several versions of the miniport) we need to use the following
//       convention:
//
//          THIS MODULE SHOULD ONLY CONTAIN NV3 SPECIFIC CODE
//          (OR CODE THAT HAS NOT CHANGED ACROSS CHIPS) !!
//
//       Mainly because NV_REF.H already includes NV3_REF.H.
//       For code which is different from NV3, that code
//       should exist separately in NV4.C/NV5.C/...etc...
//
//       We'll follow the convention that the Miniport decides at runtime
//       which chip it's running on (i.e. only ONE miniport instead of
//       compiling several versions for each type of chip).
//
//*****************************************************************************

//*****************************************************************************
//
// ModeSet Code differences between chips:
//
//       NV3:   - CRTC registers are locked using NV_PRMVIO_SR_LOCK
//                (See OEMEnableExtension/OEMDisableExtension)
//
//              - 565 mode is set with PRAMDAC_GENERAL_CONTROL_565_MODE
//                (See OEMSetRegs)
//
//              - PRAMDAC_PLL_COEFF_SELECT and PRAMDAC_PLL_SETUP_CONTROL
//                bit definitions are different than NV4
//
//              - FixLowWaterMark is different than NV4 version
//
//              - OEMGetMemSize
//
//       NV4:   - CRTC registers are locked using NV_CIO_SR_LOCK_INDEX.
//                (See NV4_OEMEnableExtenions/NV4_OEMDisableExtension)
//
//              - 565 mode is set with NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE
//                (See NV4_OEMSetRegs)
//
//              - PRAMDAC_PLL_COEFF_SELECT and PRAMDAC_PLL_SETUP_CONTROL
//                bit definitions are different than NV3
//
//              - TV functionality has changed
//
//              - FixLowWaterMark is different than NV3 version
//
//              - NV4_OEMGetMemSize
//
//*****************************************************************************


#include <miniport.h>
#include <nv_ref.h>
#include <ntddvdeo.h>
#include <video.h>
#include "nv.h"
#include "modes.h"
#include "modedata.c"
#include "modehw.h"

// Debug level values and output macro
#define DEBUGLEVEL_TRACEINFO    0     // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO    1     // For informational debug setup info
#define DEBUGLEVEL_USERERRORS   2     // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS     3     // For debug warning info
#define DEBUGLEVEL_ERRORS       4     // For debug error info
#define DBG_PRINT_STRING_VALUE(l, s, v) VideoDebugPrint(((l), s ## " 0x%x\n", (v)))

#endif // NTMINIPORT

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID ProgramTV( U008 tvmode );
VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides);

//******************************************************************************
// External variables
//******************************************************************************

// global device extension pointer - We need it to distinguish between NV3/NV4..
extern PHW_DEVICE_EXTENSION HwDeviceExtension;
extern CRTC_OVERRIDE crt_override[];
extern MODEDESC mib[];            // Our Mode List

//******************************************************************************
// External functions
//******************************************************************************

extern VOID NV_OEMSetRegs(MODEDESC *);
extern VOID NV_FixLowWaterMark(U016);
extern U016 NV_OEMGetMemSize(VOID);
extern VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION);
extern VOID NV_OEMDisableExtensions(PHW_DEVICE_EXTENSION);

U016 VBESetModeEx(PHW_DEVICE_EXTENSION pHwDevExt, U016 vbeMode, PGTF_TIMINGS pVbeTimings, PDMT_OVERRIDES pDMTOverrides, U016 UseDMTFlag)
{
    HwDeviceExtension = pHwDevExt;
    return VBESetMode(vbeMode, pVbeTimings, pDMTOverrides, UseDMTFlag);
}

VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION pHwDevExt)
{
    HwDeviceExtension = pHwDevExt;
}



//******************************************************************************
//
// Function: WakeUpCard
//
// Description:
//
//           NV4 or better:
//
//           When RmInitNvDevice() is called during NVInitialize(),
//           it tries to detect if a monitor, flat panel, or TV is connected.
//           It does this when InitDac() calls dacMonitorConnectStatus(). 
//
//           However, dacMonitorConnectStatus() seems to fail on some cards
//           if the card is secondary and the monitor is not 'alive'
//           The end result is that dacMonitorConnectStatus() incorrectly identifies
//           the secondary card. This results in the secondary monitor coming up blank.
//
//           This does NOT happen on Win9x, since by that time, the secondary monitor
//           is already 'alive' and in text mode.  But under WinNT, the secondary
//           monitor has not yet been initialized.
//          
//           Aos, this does NOT happen on all cards (ie...my TNT2 works without this workaround)
//           but DOES happen on my NV4.    
//
//           So, under NT, to make sure that dacMonitorConnectStatus correctly identifies 
//           the monitor and that the 'monitor' is awake, we'll touch just enough registers
//           on the card to make sure it's alive.
//                   
//*****************************************************************************


VOID WakeUpCard(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    MODEDESC    *minfo;             

    //*************************************************************************
    // Mib[1] is the entry for 640x480
    //*************************************************************************

    minfo = &mib[1];

    //*************************************************************************
    // NV3 still uses the OLD style modeset code, and does NOT go thru
    // the RM to set the mode.  Only do this for NV4 or better.
    //*************************************************************************

    if  (HwDeviceExtension->ulChipID != NV3_DEVICE_NV3_ID)
        {
        //**********************************************************************
        // Make sure card is 'active'.  This code doesn't completely set a mode,
        // but it touches enough registers to make sure that dacMonitorConnectStatus()
        // in the RM will succeed, and correctly detect the monitor.
        //**********************************************************************

        SetGlobalHwDev(HwDeviceExtension);
        NV_OEMEnableExtensions(HwDeviceExtension);        
        SetRegs(minfo);             
        }
        
    }



//
// VBE Function 02h - Vesa SetMode routine.
//
// Used to set a VESA mode. This routine will not accept standard
// VGA Mode numbers, nor will it load/support fonts. This means that
// TTY output is DISABLED.
//
// Entry:   U016 mode             // VESA mode to be set
//
//          +------------------ Don't clear screen (1=Save Screen)
//          |+----------------- Linear Frame Buffer (1=Enable)
//          ||++--------------- Reserved for VBE/AF
//          ||||+-------------- User Refresh (1=User Specified)
//          |||||++------------ Reserved
//          |||||||+-++++++++-- Mode Number
//          VVVVVVVV VVVVVVVV
//          00000000 00000000
//
//          111111
//          54321098 76543210
//
//          CRTCInfoBlk *cib        // Pointer to CRTCInfoBlock Structure
//
// Exit:    U016 rc               // VESA Error Status
//


U016 VBESetMode(U016 mode, PGTF_TIMINGS timings, PDMT_OVERRIDES pDMTOverrides, U016 UseDmtFlag)
{
    MODEDESC    *minfo;             // Mode Information
    U016        wv;
    U016        rc = 0x014F;        // Default to FAIL
    U032        data32;
    U016        data,shadow;    


    NV_OEMEnableExtensions(HwDeviceExtension);          // Unlock the registers

    //**************************************************************************
    // Do this for flat panel only
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

#define NV_PRAMDAC_FP_DEBUG_0                            0x00680880 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX                0x00000002 /* RWI-V */

        // de-couple vertical sync from flat panel while setting mode
        data32 = ReadPriv32(NV_PRAMDAC_FP_DEBUG_0); 
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
        WritePriv32(data32, NV_PRAMDAC_FP_DEBUG_0 );
        }



    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {
    
        shadow = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x21);        // read shadow lock (is there really no define for this reg?)

        data = shadow | 0xC800;         // Enable loading of CRTC's: bit 7 Horiz shadow, bit 3 Vert shadow
                                    // bit 6 = scanline doubling shadow
        WriteIndexed(NV_PRMCIO_CRX__COLOR, data);


        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        data = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09);         // read scanline double
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (data &= ~0x8000));   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        while (PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
        while (!(PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start
    
        // shadow = CR21
        shadow &= ~0x4000;  // shadow the scanline double bit
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (shadow |= 0x8800)); // allow horiz & vert write-thru
        }    


    if ((minfo = ValidateMode((U016) (mode & 0x1FF))) != (MODEDESC *) NULL)
    {
        // Mode is maintained here, for the linear/regen flags
        // minfo now points to everything we need to program the mode.

        // Set the mode
        // SetBIOSVariables(minfo); // Set low memory variables from parms.
        ATCOff();                   // Screen off
        OEMPreSetRegs();            // Set up DAC for programming palette.

        SetRegs(minfo);             // Set the VGA Registers
        FullCpuOn();

        NV_OEMSetRegs(minfo);          // Set the OEM Registers
        LoadPalette(minfo);

        // Not in VESA modes...
        /*
        LoadSysFont(minfo);      // Not in these VESA modes...

        if (!(mode & 0x8000))     // Save the screen?
          OEMClearScreen();       // Clear the buffer

        if (mode & 0x4000)
          VBESetLinearFB();
        */

        // Use DMT override values instead of GTF timings
        if (UseDmtFlag)
            {
            // Mode now successfully set .. Set DMT override values
            SetDMTOverrideValues(pDMTOverrides);
            }

        else
            {

            // Mode now successfully set .. Set GTF timings
            if ((mode & 0x0800) && timings)  // See if bit 11 is set for VBE Refresh
              VBESetRefresh(timings);        // Set the VBE 3.0 Refresh
            }


        FullCpuOff();
        ATCOn();

        // Clear the DPMS State
        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
        wv &= 0x3FFF;                   // Strip to standard DAC settings
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

        // if (isTV())
        //    fixup_tv();          // Only required on Mode 13h

        rc &= 0x00FF;               // Clear error status
    }
    NV_OEMDisableExtensions(HwDeviceExtension);         // Unlock the registers

    return(rc);                     // Mode Not Supported
}

//
// Program the CRTC timing values given by the GTF parameters
//
// WARNING: This is not going to be pretty!!
// TODO: Clean the code to be more straightforward.
//
U016 VBESetRefresh(PGTF_TIMINGS timings)
{

    U032 val32;
    U016 val16, val16b, val16c;
    U008 val08;
    U016 pixperclk;
    U016 border;
    U008 ov07, ov25, ov2D;
    U016 horiz_total;
    U016 hbe;


    //
    // Program the new clocks
    //
    OEMSetClock((U016)(timings->dot_clock / 10000));

    /*
        ; Program new horizontal sync polarity
        mov     bl, [edi].CRTCInfoBlock.HorizontalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 040h
@@:
        ; Program new vertical sync polarity
        mov     bl, [edi].CRTCInfoBlock.VerticalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 080h
@@:
        mov     dx, MISC_OUTPUT
        LOG_GO  dx, al
    */
    //
    // Program the sync polarities
    //
    val32 = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    if (timings->flags & GTF_FLAGS_HSYNC_NEGATIVE)
        val32 |= 0x40;
    if (timings->flags & GTF_FLAGS_VSYNC_NEGATIVE)
        val32 |= 0x80;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: PRMVIO_MISC=",(U008)val32);

    /*
        ;---------------------------------------------------------
        ; Compute CRTC settings
        call    PixPerCharClk
        mov     si, ax
    */
    //
    // Get the pixels per char settings
    //
    if (ReadIndexed(NV_PRMVIO_SRX, NV_PRMVIO_SR_CLOCK_INDEX) & 0x0100)
        pixperclk = 8;
    else
        pixperclk = 9;

    /*
        ; Another way to compute vertical border would be to
        ; subtract current CR12 (VDE[0:7]) from CR15 (VBS[0:7])
        call    GetCRTCAddr
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bh, ah
        mov     al, 015h
        call    GetIndexRegister        ; VBS[7:0]
        sub     ah, bh
        ;add    ah, 1-1                 ; VGA adjustments cancel
        xor     al, al
        or      ah, ah
        jz      @f
        inc     al                      ; 1 character horizontal
@@:
        mov     bx, [edi].CRTCInfoBlock.RefreshRate
        cmp     bx, 7200
        jle     @f
        xor     ax,ax                   ; No boarder for refresh above 72Hz
@@:
        mov     bp, ax                  ; Save boarders in bp
    */
    //
    // Get the border setting
    //
    border = (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x15) & 0xFF00;
    border -= (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) & 0xFF00;
    border &= 0xFF00;
    if (border & 0xFF00)
        border++;
    if (timings->refresh > 7200)
        border = 0;

    /*
        ;---------------------------------------------------------
        ; Store CRTC settings
        ; Get overflow values to accumulate
        mov     al, 007h
        call    GetIndexRegister
        mov     ch, ah                  ; Save off overflow register
        and     ch, 01010010b           ; Mask bits to save
        mov     al, 025h
        call    GetIndexRegister
        mov     cl, ah                  ; Save off extra bits screen register
        and     cl, 11100010b           ; Mask bits to save
IFDEF NVIDIA_SPECIFIC
        ; Load original 02Dh
        mov     al,02Dh
        call    GetIndexRegister
        and     ah,0E2h         ; Save unused bits and HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Get the overflow bits
    //
    ov07 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07) >> 8;
    ov07 &= 0x52;
    ov25 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25) >> 8;
    ov25 &= 0xE2;
    ov2D = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x2D) >> 8;
    ov2D &= 0xE2;

    /*
        ; cl = CRTC[25] overflow
        ; ch = CRTC[07] overflow
        ; upper cl = CRTC[2D] overflow
        ; dx = CRTC I/O address
        ; si = pixels per character
        ; es:di = pointer to CRTCInfoBlock
        ; ds = seg0
        ; bp = boarder
        mov     ax, [edi].CRTCInfoBlock.HorizontalTotal
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax                  ; Save original
        sub     ax, 5                   ; VGA HT adjustment
IFDEF NVIDIA_SPECIFIC
        ; Do bit 8 of HT
        and     ah,1            ; mask out bit 8
        ;shl     ah,0-0          ; already in position 0
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        ; CRTC[00]
        mov     ah, al
        mov     al, 000h
        LOG_GO  dx, ax
    */
    //
    // Calculate and program horizontal total (CR00)
    //
    horiz_total = timings->horiz_total / pixperclk;
    val16 = horiz_total - 5;
    val16 &= 0x01FF;
    ov2D |= (U008)(val16 >> 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((val16 << 8) & 0xFF00));

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR00=",(U008)val16);

    /*
IFDEF NVIDIA_SPECIFIC
        ; CRTC[39]
        ; Note, we are assuming that the 9th bit of interlace half field start is always 0
        mov     ax, bx
        shr     ax, 1           ; Compute horizontal total divided by 2
        mov     ah, [edi].CRTCInfoBlock.Flags
        and     ah,00000010b    ; ?Interlaced mode
        jnz     @f              ; Y: Leave ah at 1/2 HT
        mov     al, 0FFh        ; N: Disable interlace
@@:
        mov     ah, al
        mov     al, 039h
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program interlace half-field value (CR39)
    //
    if (timings->flags & GTF_FLAGS_INTERLACED)
        val16 = (((horiz_total >> 1) << 8) & 0xFF00) | 0x39;
    else
        val16 = 0xFF39;   // disabled
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR39=",(U008)(val16>>8));

    /*
        mov     ax, bp
        xor     ah, ah                  ; Make into word
        sub     bx, ax                  ; Subtract boarder from HT
        ; CRTC[03]
        mov     al, 003h
        call    GetIndexRegister
        and     ah, 11100000b
        dec     bl                      ; VGA HBE Adjustment
        mov     bh, bl                  ; save HBE
        and     bl, 00011111b           ; HBE[4:0]
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking end (CR03)
    //
    val16 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x03);
    val16 &= 0xE0FF;
    hbe = horiz_total - (border & 0xFF) - 1;
    val16 |= ((hbe & 0x1F) << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR03=",(U008)(val16>>8));

    /*
        ; CRTC[05]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncEnd
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bl, al
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bl              ; VGA HSE adjustment is +2
        .endif
        inc     bl                      ; Native HSE adjustment is +1
        mov     al, 005h
        call    GetIndexRegister
        and     ah, 01100000b
        and     bl, 00011111b           ; HSE[4:0]
        or      ah, bl
        mov     bl, bh                  ; restore HBE
        and     bl, 00100000b           ; HBE[5]
        shl     bl, 7-5                 ; Move from bit 5 to bit 7
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace end (CR05)
    //
    val16 = timings->horiz_end / pixperclk;
    val16++;    // always native mode
    val16 &= 0x1F;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05);
    val16b &= 0x60FF;
    val16b |= (val16 << 8);
    val16 = (hbe & 0x20) << 2;
    val16b |= (val16 << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR05=",(U008)(val16b>>8));

    /*
IFDEF NVIDIA_SPECIFIC
        and     bh, 01000000b
        shr     bh, 6-4
        ; MSK - Assume HBE[6] can always be set, but only takes effect if LC ignore flag is set
        or      cl, bh                  ; HBE[6]
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Modify overflow25
    //
    ov25 |= ((hbe & 0x40) >> 2);

    /*
        ; CRTC[02]
        mov     al, 001h
        call    GetIndexRegister        ; HDE[0:7]
        mov     al, ah
IFDEF NVIDIA_SPECIFIC
        ; Get bit 8 of HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah, cl
        ror     ecx,16          ; switch back to lower part of ECX
        and     ah, 2           ; mask out bit 1
        shr     ah, 1-0         ; shift into position 0
ELSE ; NVIDIA_SPECIFIC
        xor     ah, ah
ENDIF ; NVIDIA_SPECIFIC
        ;
        inc     ax                      ; VGA HDE adjustment
        mov     bx, bp
        xor     bh, bh
        add     ax, bx
        dec     ax                      ; VGA HBS Adjustment
IFDEF NVIDIA_SPECIFIC
        ; Store bit 8 of HBS
        and     ah,1            ; mask out bit 8
        shl     ah,2-0          ; shift into position 2
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, al
        mov     al, 002h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking start (CR02)
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x01) >> 8) & 0x00FF;
    val16 |= ((U016)(ov2D & 2) << 7) & 0xFF00;
    val16++;
    val16 += (border & 0xFF);
    val16--;
    val08 = ((val16 >> 8) & 1) << 2;
    ov2D |= (U016)val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR02=",(U008)(val16>>8));

    /*
        ; CRTC[04]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncStart
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bx              ; VGA HSS adjustment is +2
        .endif
        inc     bx                      ; Native HSS adjustment is +1
IFDEF NVIDIA_SPECIFIC
        ; do bit 8 of HRS
        and     bh,1            ; mask out bit 8
        shl     bh,3-0          ; shift into position 3
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,bh
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, bl
        mov     al, 004h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace start (CR04)
    //
    val16 = timings->horiz_start / pixperclk;
    val16++;    // always native mode
    val08 = ((val16 >> 8) & 1) << 3;
    ov2D |= val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR04=",(U008)(val16>>8));

    /*
IFDEF NVIDIA_SPECIFIC
        ; CRTC[2D]
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah,cl
        ror     ecx,16          ; switch back to lower part of ECX
        mov     al,02Dh
        SIM_NO  dx,ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program CR2D
    //
    val16 = ((((U016)ov2D) << 8) & 0xFF00) | 0x2D;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR2D=",(U008)(val16>>8));

    /*
        ; CRTC[16]
        mov     bx, [edi].CRTCInfoBlock.VerticalTotal
        mov     ax, bp
        mov     al, ah
        xor     ah, ah
        sub     ax, bx
        neg     ax
        mov     ah, al
        mov     al, 016h
        dec     ah                      ; VGA VBE Adjustment
        LOG_GO  dx, ax                  ; VBE[0:7]
    */
    //
    // Program vertical blanking end (CR16)
    //
    val16 = (border >> 8) - timings->vertical_total;
    val16 = -val16;
    val16--;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR16=",(U008)(val16>>8));

    /*
        ; CRTC[06]
        mov     al, 006h
        sub     bx, 2                   ; VGA VT Adjustement
        mov     ah, bl
        LOG_GO  dx, ax                  ; VT[0:7]
    */
    //
    // Program the vertical total (CR06)
    //
    val16 = timings->vertical_total - 2;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR06=",(U008)(val16>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        ;shl    0-(8-8)
        or      ch, bl                  ; VT[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ch, bl                  ; VT[9]
        and     bh, 00000100b
        shr     bh, (10-8)-0
        or      cl, bh                  ; VT[10]
        ; CRTC[15]
        mov     ah, cl                  ; CRTC[25]
        and     ah, 00000010b
        shl     ah, (10-8)-1
        mov     bh, ah                  ; VDE[10]
        mov     al, ch                  ; CRTC[7]
        and     al, 01000000b
        shr     al, 6-(9-8)
        or      bh, al                  ; VDE[9]
        mov     ah, ch                  ; CRTC[7]
        and     ah, 00000010b
        shr     ah, 1-(8-8)
        or      bh, ah                  ; VDE[8]
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bl, ah
        inc     bx                      ; VGA VDE adjustment
        mov     ax, bp                  ; Adjust boarder
        mov     al, ah
        xor     ah, ah
        add     bx, ax
        mov     al, 015h
        dec     bx                      ; VGA VBS adjustment
        mov     ah, bl
        LOG_GO  dx, ax                  ; VBS[0:7]
    */
    //
    // Program vertical blanking start (CR15)
    //
    val16 = timings->vertical_total - 2;
    val08 = (val16 >> 8) & 0x01;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x02;
    val08 <<= 4;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x04;
    val08 >>= 2;
    ov25 |= (U016)val08;

    val08 = (ov25 & 0x02) << 1;
    val16 = (U016)val08 << 8;
    val08 = (ov07 & 0x40) >> 5;
    val16 |= (U016)val08 << 8;
    val08 = (ov07 & 0x02) >> 1;
    val16 |= (U016)val08 << 8;

    val16 &= 0xFF00;
    val16 |= (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
    val16++;
    val16 += (border >> 8);
    val16--;
    val16c = val16;                     // save for later
    val16b = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR15=",(U008)(val16b>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 3-(8-8)
        or      ch, bl                  ; VBS[8]
    */
    val08 = ((val16 >> 8) & 1) << 3;
    ov07 |= val08;

    /*
        ; CRTC[09]
        ; MSK - 5/15/97
        ; To allow a double scan mode to be non double scanned, we need to preserve the
        ; double scan bit so we can check it later
        ; We need to adjust VDE based on the old and new double scan bits
        ; We also need the original VDE
        ; NOTE: alternate way would be to get the value from the mode tables

        mov     al, 009h
        call    GetIndexRegister
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     ah,10000000b    ; Old double scan mode
        shr     ah,7-0
        and     bl,00000001b    ; ?Double scan mode
        cmp     bl, ah
        .if     (!zero?)        ; Mismatch
    */
    //
    // Is the current doublescan status different from the requested flag?
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16 >>= 7;
    // this takes advantage that the flag is 0x01
    if ((timings->flags & GTF_FLAGS_DOUBLE_SCANNED) != (U008)val16)
    {

        /*
                ; New mode had different double scan setting from old mode
                ; We have to multiply or divide VDE by 2

                mov     bl, ch          ; CR[7].1
                and     bl, 00000010b
                shr     bl, 1-0         ; move to bit 0

                mov     ah, ch          ; CR[7].6
                and     ah, 01000000b
                shr     ah, 6-1         ; move to bit 1
                or      bl, ah

                mov     ah, cl          ; CR[25].1
                and     ah, 00000010b
                shl     ah, 2-1         ; Move to bit 2
                or      bl, ah
        */
        //
        // Adjust VDE
        //
        val08 = (ov07 & 0x02) >> 1;
        val08 |= (ov07 & 0x40) >> 5;
        val08 |= (ov25 & 0x02) << 1;

        /*
                mov     al, 012h
                call    GetIndexRegister
                mov     al, [edi].CRTCInfoBlock.Flags
                and     al, 00000001b   ; Is new mode a double scan mode?
                .if (zero?)
                        ; was double scan, now is not, so divide by 2
                        shr     bl, 1           ; Divide by 2
                        rcr     ah, 1
                .else
                        ; was not double scan, now is, so multiply by 2
                        shl     ah, 1           ; Multiply by 2
        BUG? =>         rcr     bl, 1
                        inc     ah              ; Make lsb set

                .endif
                mov     al, 012h

                LOG_GO  dx, ax          ; VDE[0:7]
        */

        val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
        val16 |= (U016)val08 << 8;
        if (!(timings->flags & GTF_FLAGS_DOUBLE_SCANNED))
        {
            val16 >>= 1;
        }
        else
        {
            val16 <<= 1;
            val16++;
        }
        val16b = ((val16 << 8) & 0xFF00) | 0x12;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR12=",(U008)(val16b>>8));

        /*
                and     ch, NOT 01000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000001b
                shl     al, 1-0         ; move to bit 1
                or      ch, al          ; CR[7].1
                mov     al, bl
                and     al, 00000010b
                shl     al, 6-1         ; move to bit 6
                or      ch, al          ; CR[7].1

                and     cl, NOT 00000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000100b
                shr     al, 2-1         ; move to bit 1
                or      cl, al          ; CR[25].1

        .endif
        ; End MSK - 5/15/97
        */
        //
        // Adjust the overflows based on the new VDE
        //
        ov07 &= 0xBD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x01) << 1;
        ov07 |= val08;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x02) << 5;
        ov07 |= val08;
        ov25 &= 0xFD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x04) >> 1;
        ov25 |= val08;
    }

    /*
        mov     al, 009h
        call    GetIndexRegister
        and     ah, NOT 10100000b
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     bl,00000001b    ; ?Double scan mode
        jz      @f              ; N: Leave clear
        or      ah, 10000000b   ; Y: Set double scan
@@:
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ah, bl                  ; VBS[9]
        LOG_GO  dx, ax
    */
    //
    //
    val16b = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16b &= 0x5F;
    if (timings->flags & GTF_FLAGS_DOUBLE_SCANNED)
        val16b |= 0x80;
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x02) << 4;
    val16b |= (U016)val08;
    val16 = ((val16b << 8) & 0xFF00) | 0x09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR09=",(U008)(val16>>8));

    /*
        and     bh, 00000100b
        shl     bh, 3-(10-8)
        or      cl, bh                  ; VBS[10]
        ; CRTC[10]
        mov     al, 010h
        mov     bx, [edi].CRTCInfoBlock.VerticalSyncStart
        mov     ah, bl
        LOG_GO  dx, ax                  ; VSS[0:7]
    */
    //
    //
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x04) << 1;
    ov25 |= val08;
    val16 = timings->vertical_start;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR10=",(U008)(val16>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 2-(8-8)
        or      ch, bl                  ; VSS[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 7-(9-8)
        or      ch, bl                  ; VSS[9]
        and     bh, 00000100b
        ;shl     bh, 2-(10-8)
        or      cl, bh                  ; VSS[10]
        ; CRTC[11]
        mov     al, 011h
        call    GetIndexRegister
        and     ah, 11110000b
        mov     bl, byte ptr [edi].CRTCInfoBlock.VerticalSyncEnd
        and     bl, 00001111b
        or      ah, bl
        LOG_GO  dx, ax                  ; VSE[0:3]
    */
    //
    //
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x01) << 2;
    ov07 |= val08;
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x02) << 6;
    ov07 |= val08;
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = val08 & 0x04;
    ov25 |= val08;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);
    val16b &= 0xF0FF;
    val16b |= (timings->vertical_end & 0x000F) << 8;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR11=",(U008)(val16b>>8));

    /*
        ; Store overflow registers
        ; CRTC[7]
        mov     al, 007h
        mov     ah, ch
        LOG_GO  dx, ax
    */
    val16 = ((((U016)ov07) << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR07=",(U008)(val16>>8));

    /*
        ; CRTC[25]
IFDEF NVIDIA_SPECIFIC
        mov     al, 025h
        mov     ah, cl
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    val16 = ((((U016)ov25) << 8) & 0xFF00) | 0x25;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR25=",(U008)(val16>>8));

    return(0);
}


//*****************************************************************************
//
// Function: SetDMTOverrideValues()
//
// Description:
//
//      Do VESA 1.0 rev 0.7 DMT timings for the following modes:
//
//      DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7
//      Monitor Timing Specifications and D.Reed's NV3 CRTC spreadsheet.
//
//           1600 x 1200 @ 60,70,75,85
//           1280 x 1024 @ 60,75,85
//           1152 x  864 @ 75
//           1024 x  768 @ 60,70,75,85
//            800 x  600 @ 60,72,75,85
//            640 x  480 @ 60,72,75,85
//
//      DMT_Overrides_structure
//
//          U016    DotClock;
//          U016    Polarity;
//          U016    CR0;
//          U016    CR2;
//          U016    CR3;
//          U016    CR4;
//          U016    CR5;
//          U016    CR6;
//          U016    CR7;
//          U016    CR10;
//          U016    CR11;
//          U016    CR15;
//          U016    CR16;
//
//*****************************************************************************


VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides)

{

    U032 val32;
    U016 val16;
    U016  wv;

    //
    // Program the new clocks
    //

    OEMSetClock((U016)(pDMTOverrides->DotClock));

    //
    // Program the sync polarity
    //

    val32   = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    val32  &= 0xf3;
    val32  |= 0x8;
    val32  |= pDMTOverrides->Polarity;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    //
    // Clear the crtc protection bit.
    //

    val16 = 0x0011;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR0
    //

    val16 = pDMTOverrides->CR0;
    val16 = ((val16 << 8) & 0xFF00) | 0x00;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR2
    //

    val16 = pDMTOverrides->CR2;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR3
    //

    val16 = pDMTOverrides->CR3;
    val16 = ((val16 << 8) & 0xFF00) | 0x03;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR4
    //

    val16 = pDMTOverrides->CR4;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR5
    //

    val16 = pDMTOverrides->CR5;
    val16 = ((val16 << 8) & 0xFF00) | 0x05;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR6
    //

    val16 = pDMTOverrides->CR6;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR7
    //

    val16 = pDMTOverrides->CR7;
    val16 = ((val16 << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR10
    //

    val16 = pDMTOverrides->CR10;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    //
    // Update CR11
    //

    val16 = pDMTOverrides->CR11;
    val16 = ((val16 << 8) & 0xFF00) | 0x11;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR15
    //

    val16 = pDMTOverrides->CR15;
    val16 = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR16
    //

    val16 = pDMTOverrides->CR16;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    }

#define COMBINE_INDEX_DATA(i, d) ((U016)((((U016)(d)) << 8 & 0xff00) + (i)))
#define EXTRACT_DATA(x) (x) >> 8 & 0x00ff
VOID ProgramTV
(
    U008    tvmode
)
{
    U016    data;

    // 11-07-97 wk. Note that either the commented out tvreg table for CRTC[12] is
    //              wrong or the BIOS CRTC[12] programming code is wrong. The BIOS doesn't
    //              have tvreg tables for TV modes 4 and 5. The C code will use the tvreg
    //              table, so if the bug is in the table then make the correction there.

    WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_ILACE__INDEX, tvregs[tvmode].tvIntlace));        // CRTC[39]

    // Un-write protect CR0-7 registers.
    data = ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_VRE_INDEX);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(data & 0x7fff));

    // Check for NTSC or PAL.
    data = EXTRACT_DATA(ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CRE_PIXEL_INDEX));
    if(( data & 0xc0 ) == 0x80 )
    {
        // NTSC
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_DEC__INDEX, tvregs[ tvmode ].tvDecimate_NTSC ));      // CR[29]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDT_INDEX,   tvregs[ tvmode ].tvHT_NTSC       ));      // CR[00]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRS_INDEX,   tvregs[ tvmode ].tvHRS_NTSC      ));      // CR[04]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDT_INDEX,   tvregs[ tvmode ].tvVT_NTSC       ));      // CR[06]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_OVL_INDEX,   tvregs[ tvmode ].tvVO_NTSC       ));      // CR[07]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRS_INDEX,   tvregs[ tvmode ].tvVRS_NTSC      ));      // CR[10]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDE_INDEX,   tvregs[ tvmode ].tvHDE_NTSC      ));      // CR[01]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBS_INDEX,   tvregs[ tvmode ].tvHBS_NTSC      ));      // CR[02]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBE_INDEX,   tvregs[ tvmode ].tvHBE_NTSC      ));      // CR[03]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRE_INDEX,   tvregs[ tvmode ].tvHRE_NTSC      ));      // CR[05]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRE_INDEX,   tvregs[ tvmode ].tvVRE_NTSC      ));      // CR[11]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDE_INDEX,   tvregs[ tvmode ].tvVDE_NTSC      ));      // CR[12]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBS_INDEX,   tvregs[ tvmode ].tvVBS_NTSC      ));      // CR[15]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBE_INDEX,   tvregs[ tvmode ].tvVBE_NTSC      ));      // CR[16]
    }
    else
    {
        // PAL
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_DEC__INDEX, tvregs[ tvmode ].tvDecimate_PAL ));      // CR[29]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDT_INDEX,   tvregs[ tvmode ].tvHT_PAL       ));      // CR[00]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRS_INDEX,   tvregs[ tvmode ].tvHRS_PAL      ));      // CR[04]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDT_INDEX,   tvregs[ tvmode ].tvVT_PAL       ));      // CR[06]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_OVL_INDEX,   tvregs[ tvmode ].tvVO_PAL       ));      // CR[07]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRS_INDEX,   tvregs[ tvmode ].tvVRS_PAL      ));      // CR[10]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDE_INDEX,   tvregs[ tvmode ].tvHDE_PAL      ));      // CR[01]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBS_INDEX,   tvregs[ tvmode ].tvHBS_PAL      ));      // CR[02]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBE_INDEX,   tvregs[ tvmode ].tvHBE_PAL      ));      // CR[03]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRE_INDEX,   tvregs[ tvmode ].tvHRE_PAL      ));      // CR[05]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRE_INDEX,   tvregs[ tvmode ].tvVRE_PAL      ));      // CR[11]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDE_INDEX,   tvregs[ tvmode ].tvVDE_PAL      ));      // CR[12]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBS_INDEX,   tvregs[ tvmode ].tvVBS_PAL      ));      // CR[15]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBE_INDEX,   tvregs[ tvmode ].tvVBE_PAL      ));      // CR[16]

        // PAL Fix up.

        // 11-07-97 wk. mighty suspect bios code (or documentation)!
        //
        // mov     al,1                    ; Look at value in CR01
        // SIM_GET_INDEX_REGISTER_NV       ; Read CR01
        // cmp     ah,4Fh                  ; Is it > 4Fh? (800 s/b 63h)
        //
        // jbe     @low_pal                ; it's a 640x480 or less mode... jump!

        //CRTC_RD( NV_CIO_CR_HDE_INDEX, data );      // CRTC[01]
        data = EXTRACT_DATA(ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_HDE_INDEX));
        if( data > 0x4f )
        {
            // PAL timings for modes 800x600 or more.

            // set VPLL to SOURCE
            WritePriv32(0x00010100, NV_PRAMDAC_PLL_COEFF_SELECT );
            WritePriv32(0x00035A09, NV_PRAMDAC_VPLL_COEFF       );

            // tblPALTimingsHi
            WritePriv32(0x0000004F, NV_PRAMDAC_HSYNC_WIDTH      );
            WritePriv32(0x0000005F, NV_PRAMDAC_HBURST_START     );
            WritePriv32(0x000003FF, NV_PRAMDAC_HBLANK_START     );
            WritePriv32(0x00000438, NV_PRAMDAC_HTOTAL           );
            WritePriv32(0x00000027, NV_PRAMDAC_HEQU_WIDTH       );
            WritePriv32(0x000001CA, NV_PRAMDAC_HSERR_WIDTH      );
        }
        else
        {
            // PAL timings for modes less then 800x600.

            // set VPLL to SOURCE
            WritePriv32(0x02010100, NV_PRAMDAC_PLL_COEFF_SELECT );
            WritePriv32(0x00034709, NV_PRAMDAC_VPLL_COEFF       );

            // tblPALTimingsLo
            WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH      );
            WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START     );
            WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START     );
            WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL           );
            WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH       );
            WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH      );
        }
    }

    // write protect CR0-7 registers.
    data = ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_VRE_INDEX);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(data & 0x7fff));
}



//
//       LoadPalette - Load the system palette and the user defined palette if there is one
//
//       Entry:  DS = Seg0
//               ES:DI = Pointer to parameter entry
//       Exit:   None
VOID LoadPalette(MODEDESC *mi)
{
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    //
    // Load default internal palette
    //
    LoadDefaultATCAndSavePtr((vga_tbl[mi->mdIMode].PT_ATC));

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop

    WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!

    //
    // Load default external palette
    //
    LoadDefaultRAMDAC(mi);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif

}

//
//       LoadDefaultATCAndSavePtr - Load a the default ATC registers and store them in the saveptr area if necessary
//
//       Entry:  ES:SI = Pointer to palette data
//               DX = I/O Address of Input Status Register
//               DS = Seg0
//       Exit:   None
//
//       AX, CX, SI are trashed
//       DX is preserved
//
VOID LoadDefaultATCAndSavePtr(U008 *pal)
{
    U008  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop

    for (i = 0; i < 20; i++)
    {
        WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//
//       LoadDefaultRAMDAC - Load the default palette
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed
//

// #define DAC_MASK 0x3C6

VOID LoadDefaultRAMDAC(MODEDESC *mi)
{
    WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask
    // outp(DAC_MASK, 0xFFh);

    switch(mi->mdBPP)
    {
    case    4:          // 4bpp - Planar
        LoadColorDACTable();
        break;

    case    8:          // 8bpp - Packed
        LoadColor256DAC();
        break;

    case    16:         // 16bpp - Packed
    case    32:         // 16bpp - Packed
    default:
        LoadIdentityDAC();
        break;
    }
}

//
//       LoadColorDACTable - Load the DAC for the 16-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       WARNING! This routine must follow "LoadColorTextDACTable"!
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadColorDACTable(VOID)
{
    U008  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        WriteColor(i);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//
//       LoadColor256DAC - Load the DAC for the 256-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
// These tables are defined in Resman code in DACMODE.C
//
extern U008 CompatColors[];

//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
extern U008 GrayColors[];

//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
extern U008 FixupColors[];

//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
extern U008 IntenseTable[];

VOID LoadColor256DAC(VOID)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        WriteColor(CompatColors[i]);

    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }

    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //

    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {

        // I know these could probably be a function, but for now...
        // (this is getting tedious).

        // Traverse(blue, red);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            red++;
        } while (red < blue);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            blue--;
        } while (blue);

        // Traverse(red, green);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            green++;
        } while (green < red);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            red--;
        } while (red);


        // Traverse(green, blue);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            blue++;
        } while (blue < green);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            green--;
        } while (green);
    }

    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif

}

//
//       WriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               BL = 6 bit color (R'G'B'RGB)
//       Exit:   None
//
//       AX is trashed
//
VOID WriteColor(U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write

    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component

        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;

        WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}

//
//       WriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               CS:BX points to intensity table
//               SI = Red index (0 to 4)
//               DI = Green index (0 to 4)
//               CX = Blue index (0 to 4)
//
//       Exit:   None
//
//       AL is trashed
//
VOID WriteColor2(U016 red, U016 green, U016 blue, U016 tblidx)
{
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       LoadIdentityDAC - Load the DAC with a gamma ramp
//
//       Entry:  DS = Seg0
//               ES = _TEXT
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadIdentityDAC(VOID)
{
    U016  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    for (i = 0; i < 256; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
    }

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//       OEMSetClock - Set the clock chip to the requested frequency
//
//       Entry:  AL = Clock select index
//       Exit:   None
//
//       All registers are preserved.
VOID OEMSetClock(U016 clock)
{
    U032   mnp;

    //clock = tblClockFreq[csel];         // Get selected clock value
    NV_FixLowWaterMark(clock);             // Set low water mark.
    mnp = CalcMNP(&clock);              // Get the MNP of frequency

    // mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM

//  AL = M parameter
//  AH = N parameter
//  DL = P parameter

    SetDACClock(mnp);
}

//       SetDACClock - Set the VPLL parameters in the NVidia DAC
//
//  Entry:  mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
//       Entry:  AL = M parameter
//               AH = N parameter
//               DL = P parameter
//       Exit:   None
//
VOID SetDACClock(U032 mnp)
{
    // NOTE: if we need to support divide by two, use msb of p parameter
    // Set the MNP VPLL parameters in the DAC
    WritePriv32(mnp, NV_PRAMDAC_VPLL_COEFF);
}



//       CalcMNP - Set the clock chip to the requested frequency
//
//       Entry:  AX = Clock frequency in 100 kHz
//       Exit:   AL = M parameter
//               AH = N parameter
//               DL = P parameter
//               BX = Closest clock frequency in 100 kHz
//
//      Returns: long lwv = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
U032 CalcMNP(U016 *clock)
{
    U016  crystalFreq;
    U032   vclk;
    U016  vclkClosest;
    U016  deltaOld;
    U016  bestM;
    U016  bestP;
    U016  bestN;
    U016  lowM;
    U016  highM;

    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032   lwv;

    U032   edx;
    U016  dx, cx, bx;
    U016  lwvs, vclks;
    U016  t;

    vclk = (U032)(*clock * 10);     // Make KHz

    deltaOld = 0xFFFF;

    lwv = ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040;

    if (lwv)
    {
        // 14.3Khz
        dx = CRYSTAL_FREQ143KHZ;
        cx = 8;
        bx = 14;
    }
    else
    {
        // 13.5Khz
        dx = CRYSTAL_FREQ135KHZ;
        cx = 7;
        bx = 13;
    }

    lowM = cx;
    highM = bx;
    crystalFreq = dx;

    // Register usage below
    // eax = scratch
    // ebx = scratch
    // edx = scratch
    // si = m
    // di = n

    // P Loop
    for (powerP = 0; powerP <= 4; powerP++) // Init Power of P
    {
        // M Loop
        for (m = lowM; m <= highM; m++)
        {
            lwv = vclk << powerP;   // vclk * P

            // Compare with internal range of DAC
            if ((lwv >= 128000) && (lwv <= 256000))
            {
                lwv *= (U032)m;    // vclk * P * M

                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);

                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);

                lwv *= crystalFreq; // N * crystal

                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2

                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P

                i = m;
                j = m;

                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M


//                   ; upper part of ebx should still be 0
//                   mov     bx, m
//                   ; Note: edx should be zero from multiply above
//                   mov     dx, bx
//                   shr     dx, 1           ; m / 2
//                   add     eax, edx        ; This will round better
//                   xor     dx, dx
//                   div     ebx             ; Freq=N*crystal/P/M
//
//                   mov     edx, eax        ; Save a copy

                edx = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta

                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);

                if (lwvs < vclks)
                {
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }

                lwvs -= vclks;      // ABS(Freq-Vclk);

                // lwvs is ax
                // vclks is bx

                if (lwvs < deltaOld)
                {
                    // Closer match
                    deltaOld = lwvs;

                    bestP = powerP;
                    bestM = m;
                    bestN = n;

                    //         mov     deltaOld, ax
                    //         mov     bestP, powerP
                    //         mov     ax, m
                    //         mov     bestM, al
                    //         mov     ax, n
                    //         mov     bestN, al

                    edx /= 10;

                    //         mov     eax,edx
                    //         xor     edx,edx
                    //         mov     ebx,10
                    //         div     ebx             ; Convert
                    //         mov     vclkClosest,ax
                    vclkClosest = (U016)(edx & 0xFFFF);
                }
            }
        }
    }

  //  lwv = ((bestP << 16) | (bestN << 8) | (bestM));
    lwv = bestP;
    lwv <<= 16;
    lwv |= ((bestN << 8) | (bestM));


    // mov     bx, vclkClosest
    *clock = vclkClosest;

    return(lwv);
}

//       FullCpuOn - Give the CPU full bandwidth to video memory
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOn(VOID)
{
    U016  datum;

    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum |= 0x2000;                            // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
}

//       FullCpuOff - Share the CPU bandwidth with the CRTC
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOff(VOID)
{
    U016  datum;

    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum &= 0xDFFF;                            // Full Bandwidth bit OFF
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
}

//
//       SetRegs - Set VGA registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID SetRegs(MODEDESC *mi)
{
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset

    WritePriv08(NV_PRMVIO_MISC__WRITE, vga_tbl[mi->mdIMode].PT_Misc);

    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    LoadIndexRange(NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(vga_tbl[mi->mdIMode].seq_regs));

    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset

    // Load CRTC's
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x2011);  // Unlock CR0-7

    // Load CRTC, beginning at CR0, for all CR's (CR0-18), from the mode table
    LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, sizeof(CRTC), (U008 *)&(vga_tbl[mi->mdIMode].crtc_regs));

    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    LoadIndexRange(NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(vga_tbl[mi->mdIMode].gr_regs));
}

VOID LoadIndexRange(U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;

    // Program SR1-4
    for (i = 0; i < count; i++)
    {
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }
}

//       OEMPreSetRegs - Make special preparations to load registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID OEMPreSetRegs(VOID)
{
    U016  rc;

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    rc &= 0xF8FF;                   // Strip to standard DAC settings
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    rc |= 0x0200;                   // Use 6-bit DAC
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);
}

//
//       ATCOff - Turn off Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOff(VOID)
{
    U016  flags = 0;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax            // Save flags
    _asm    cli;                    // No interrupts during this!
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Turn off screen at AR

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf
#endif
}

//
//       ATCOn - Turn on Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOn(VOID)
{
    U016  flags;

#ifdef DOS_COMPILE
    _asm
    {
        pushf
        pop ax
        mov flags,ax
        cli
    }
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x20);   // Turn off screen at AR
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE
    _asm
    {
        mov ax,flags
        push ax
        popf
    }
#endif
}

//
// ValidateMode - Validate the passed mode is valid, and if it is,
//                return the pointer to the mode information block.
//
//  Entry:  U016  mode            // VESA Mode Number to validate
//
//  Exit:   MODEDESC *mi            // Mode Information Block Pointer
//                                  // NULL if error (invalid mode)
//  NOTES:  This function must also verify the operational mode,
//          and return failure status if not valid on TV
//

MODEDESC *ValidateMode(U016 mode)
{
    MODEDESC    *mi;

    for (mi = &mib[0]; mi->mdVMode != 0xFFFF; mi++)
    {
        if (mi->mdVMode == mode)
        {
            if (OEMValidateMode(mi))
                return(mi);
            break;      // Out of the for - report error
        }
    }
    return(NULL);
}

// From OEMIsModeAvailable - validate the mode from the OEM perspective.
//
U008 OEMValidateMode(MODEDESC *m)
{
    U032   memory;

    // Are we running tv mode? If so, we need an additional filter

    // For now, NV5 or better only supports Flat Panel
    // We don't support TV yet 

    if  ( (HwDeviceExtension->ulChipID == NV3_DEVICE_NV3_ID) &&
          (isTV()) )       

    {
        if (m->mdTVMode == 0xFF)
            return((U008)0);
    }

    // Validate we have enough memory
    // (XRes * YRes * Bpp)/8
    //           +--- XRes / 8
    //           V
    memory = (((m->mdXRes >> 3) * m->mdBPP) * m->mdYRes);
    memory += 0xFFFF;               // Take to next 64K bank size
    memory >>= 16;                  // Divide by 64K for number of banks

    // memory now has the 64K blocks necessary for this mode.

    if (((U016)memory) > NV_OEMGetMemSize())
        return((U008)0);
    return((U008)1);
}

// Returns 1 if the TV is active
//
U008 isTV(VOID)
{
    U016   rc;

    // WARNING: This code was ONLY valid on NV3.
    //          It's no longer adequate for NV5 or better !!

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    return((U008)((rc >> 8) & 0x80));
}





/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

// And the following routines will become "throwaway" code, as they
// deal with the saving and restoring of the IO state during the
// accesses to the PRIV_IO.

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
//       SaveNVAccessState - Save the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//       Exit:   cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//               Real mode access registers set to address
VOID SaveNVAccessState(ACCESS_STATE *as)
{
    U008   rc;

    U016  wval;
    U032   dval;

/*
    as->crtc_addr = 0x3D4;           // Set 3D4 by default
    as->access_reg = 0x38;           // Set CR38

    // rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x38);
    dval = NV_PRMCIO_CRX__COLOR;

    // Output the MSW of the address
    outpw(0x3D2, (U016)((dval >> 16) & 0xFFFF));

    // and the LSW of the address
    outpw(0x3D0, (U016)(dval & 0xFFFF));

    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));

    outp(0x3D0, 0x38);              // Select the register
    wval = inpw(0x3D0);             // This data is Byte/Word accessable

    as->access_reg = (U008)(wval & 0xFF);
    as->access_bits = (U008)((wval >> 8) & 0xFF);

    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));

    as->data_low = inpw(0x3D0);      // Save lsw of 32-bit data

    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));

    as->nv_address = inpw(0x3D2);    // Read MSW of address
    as->nv_address <<= 16;           // Put in high word.
    as->nv_address |= inpw(0x3D0);   // Read LSW of address
*/

}


//       RestoreNVAccessState - Restore the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//               cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//       Exit:   none
VOID RestoreNVAccessState(ACCESS_STATE *as)
{
/*
    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));
    outpw(0x3D2, (U016)(as->nv_address >> 16));       // MSW of address
    outpw(0x3D0, (U016)(as->nv_address & 0xFFFF));    // LSW of address

    // Select the buffered data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA32) << 8) | (as->access_reg)));

    outpw(0x3D0, as->data_low);     // LSW of address

    outpw(as->crtc_addr, (((as->access_bits) << 8) | (as->access_reg)));
*/
}

/**********************************************************************/
/**********************************************************************/

//
// POST the chip, just like the BIOS normally does
//
VOID NvPost()
{
    U032 memconfig;
    U032 val32;

    //////////////////////////////////////////////
    //
    // Taken from BIOS POST sequence
    //

    //
    // Enable requisite engines
    //
    WritePriv32(0x11111111, NV_PMC_ENABLE);

    //
    // Program 100MHz MPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
    else
        WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    //
    // Program PFB Config to defaults
    //
    WritePriv32( DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED), NV_PFB_CONFIG_0);

    //
    // Program VPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x00028D0E, NV_PRAMDAC_MPLL_COEFF);
    else
        WritePriv32(0x0001400C, NV_PRAMDAC_MPLL_COEFF);

    //
    // Program PFB Power control
    //
    WritePriv32(DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED), NV_PFB_GREEN_0);

    //
    // Program memory timings based on framebuffer size
    //
    //

    //
    // Determine how wide/deep is the framebuffer
    //
    /*
     Memory layout:

           4mb 128-bit     33221100 77665544 bbaa9988 ffeeddcc
           2mb 128-bit     33221100 77665544 xxxxxxxx xxxxxxxx

           128-bit covers address 0-3fffff in both 2mb and 4mb configs,
           but the second 2 dwords are garbage on 2mb boards.

           4mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc
           2mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc

           64-bit covers address 0-3fffff in 4mb configs, while
           64-bit covers address 0-1fffff in 2mb configs. All bytes are
           addressed.
    */

    memconfig = ReadPriv32(NV_PFB_BOOT_0);
    memconfig &= 0xFFFFFFFC;
    memconfig |= DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _DEFAULT); // mask to 4meg, keep bus width

    //
    // Poke the framebuffer based on bus width
    //
    if (memconfig & DRF_DEF(_PFB, _BOOT_0, _RAM_WIDTH_128, _ON))
    {
        //
        // 128bit test
        //
        WriteFb32('NV3A', 0x00200008);  // 2meg+8

        //
        // 4meg?
        //
        if (ReadFb32(0x00200008) != 'NV3A')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);

    } else {

        //
        // 64bit test
        //
        WriteFb32('NV3A', 0x00100000);  // 1meg
        WriteFb32('NV3B', 0x00300000);  // 3meg

        //
        // 4meg?
        //
        if (ReadFb32(0x00300000) != 'NV3B')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);

            //
            // 2meg?
            //
            if (ReadFb32(0x00100000) != 'NV3A')
                //
                // Assume 1meg
                //
                ;//memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _1MB);

    }

    //
    // Write the memory config
    //
    WritePriv32(memconfig, NV_PFB_BOOT_0);

    //
    // Now program the appropriate memory timings
    //
    if ((memconfig & 3) == DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB))
    {
        //
        // 2meg timings
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);

        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);

        WritePriv32((ULONG) (DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON)), NV_PFB_CONFIG_1);

        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);

        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    } else {
        //
        // 4meg
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);

        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);

        WritePriv32((ULONG) (DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON)), NV_PFB_CONFIG_1);

        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);

        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    }

    //
    // Enable clocking
    //
    WritePriv32(DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_DLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_SOURCE,_PROG)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_SOURCE,_DEFAULT)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_PCLK_SOURCE,_VPLL)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VCLK_RATIO,_DB1), NV_PRAMDAC_PLL_COEFF_SELECT);

    //
    // Setup optimal PCI interface
    //
    WritePriv32(DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP)
              | DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO), NV_PBUS_DEBUG_1);


    //
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A) & 0x3FFF) | 0x0000));

    //
    // Boot with TV off, and set for NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28) & 0x00FF) | 0x0000));

    //
    // Float DDC pins high (not touched during a mode set or save/restore state)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3300));

    //
    // Disable DDC
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3200));

    //
    // Program NTSC TV settings
    //
    WritePriv32(0x00000006, NV_PRAMDAC_VSERR_WIDTH);
    WritePriv32(0x0000000C, NV_PRAMDAC_VEQU_END);
    WritePriv32(0x0000000C, NV_PRAMDAC_VBBLANK_END);
    WritePriv32(0x00000024, NV_PRAMDAC_VBLANK_END);
    WritePriv32(0x0000020C, NV_PRAMDAC_VBLANK_START);
    WritePriv32(0x00000206, NV_PRAMDAC_VBBLANK_START);
    WritePriv32(0x00000207, NV_PRAMDAC_VEQU_START);
    WritePriv32(0x0000020D, NV_PRAMDAC_VTOTAL);
    WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
    WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
    WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
    WritePriv32(0x0000034A, NV_PRAMDAC_HBLANK_START);
    WritePriv32(0x00000088, NV_PRAMDAC_HBLANK_END);
    WritePriv32(0x0000035A, NV_PRAMDAC_HTOTAL);
    WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
    WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);

    //
    // If strapped to PAL, program PAL TV settings
    //
    if ((ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000180) == 0x00000100)
    {

        WritePriv32(0x00000005, NV_PRAMDAC_VSERR_WIDTH);
        WritePriv32(0x0000000A, NV_PRAMDAC_VEQU_END);
        WritePriv32(0x0000000A, NV_PRAMDAC_VBBLANK_END);
        WritePriv32(0x0000002C, NV_PRAMDAC_VBLANK_END);
        WritePriv32(0x0000026C, NV_PRAMDAC_VBLANK_START);
        WritePriv32(0x00000269, NV_PRAMDAC_VBBLANK_START);
        WritePriv32(0x0000026C, NV_PRAMDAC_VEQU_START);
        WritePriv32(0x00000271, NV_PRAMDAC_VTOTAL);
        WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
        WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
        WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
        WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START);
        WritePriv32(0x00000092, NV_PRAMDAC_HBLANK_END);
        WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL);
        WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
        WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);
    }

}

/**********************************************************************/
/**********************************************************************/


//
// The following MAIN() routine is only used for standalone DOS compiles
//
#ifdef DOS_COMPILE
VOID main(U016 ac, U008 **av)
{
    U016  mode;                   // Mode to be set
    U016  rc;                     // Return code

    printf("NVIDIA MODESET V1.00\n\n");

    if (ac < 2)
    {
        printf("Usage: modeset vmode\n");
        printf("       vmode - Vesa Mode Number\n");
        exit(1);
    }

    if ((mode = h2i(*(++av))) == 0xFFFF)
    {
        printf("Error! Bad Vesa Mode Number\n");
        exit(2);
    }

    printf("Setting Mode 0x%02X\n", mode);
    getchar();

    rc = VBESetMode(mode);

    if (((rc & 0xFF) != 0x4F) || ((rc & 0xFF00) >> 8))
    {
        printf("Error! Could Not Set Mode 0x%02X [rc=%04X]\n", mode, rc);
        exit(3);
    }

    exit(0);
}

//
// h2i - convert Hex string to an Unsigned Integer
U016 h2i(U008 *str)
{
    U016  sus = 0;                // Starting unsigned short
    U016  i;
    U016  val;                    // Conversion value

    // Since we only do U016's, we have a max of 0xFFFF-1
    if ((i = strlen(str)) > 4)
        return(0xFFFF);

    while (i--)
    {
        val = toupper(*str) - 0x30;  // Convert Hex 0-9
        if (val > 9)
        {
            val -= 7;               // Take 7 more to convert A-F
            if (val < 0x0A || val > 0x0F)
                return(0xFFFF);     // Error!
        }
        sus *= 16;                  // Shift by 4
        sus += val;
        str++;
    }
    return(sus);
}
#endif // DOS_COMPILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\modes.h ===
//
// MODES.H - Header file for mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines and structures for use with the 'C' based modeset code.
//
//

#ifdef DOS_COMPILE
typedef unsigned long U032;
typedef unsigned short U016;
typedef unsigned char U008;
#define VOID void
#endif


#define PACKED  0
#define PLANAR  1

#define NVRM_ACCESS         0x38
#define NVRM_ACCESS_MASK    0x01
#define NVRM_IDENT          0x00
#define NVRM_ADDRESS        0x02
#define NVRM_DATA           0x04
#define NVRM_DATA32         0x06
#define NVRM_SELECT_MASK    0x06    // Mask for decode bits
#define NVRM_SELECT         0x01    // Least signifcant bit is 1

#ifdef DOS_COMPILE
//
// These defines are the standard NV defines... the appropriate include
// file should be utilized, rather than these values.
//
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB       0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB       0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB       0x00000002 /* RW--V */
#define NV_PRMVIO_MISC__WRITE              0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                      0x000C03c4 /* RW-1R */
#define NV_PRMVIO_GRX                      0x000C03ce /* RW-1R */
#define NV_PFB_BOOT_0                      0x00100000 /* RW-4R */
#define NV_PFB_CONFIG_0                    0x00100200 /* RW-4R */
#define NV_PRMCIO_ARX                      0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ         0x006013c1 /* R--1R */
#define NV_PRMCIO_CRX__COLOR               0x006013d4 /* RW-1R */
#define NV_PRMCIO_INP0__COLOR              0x006013da /* R--1R */
#define NV_PRAMDAC_VPLL_COEFF              0x00680508 /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT        0x0068050C /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL         0x00680600 /* RW-4R */
#define NV_USER_DAC_PIXEL_MASK             0x006813C6 /* RWI1R */
#define NV_USER_DAC_READ_MODE_ADDRESS      0x006813C7 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS     0x006813C8 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA           0x006813C9 /* RW-1R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO  28    /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE 16    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE     12    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE      4    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE     8    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC          20    /* RWIVF */
#define NV_PFB_CONFIG_0_TILING                  12    /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DISABLED    0x00000001 /* RWI-V */
#endif // DOS_COMPILE


#define CRYSTAL_FREQ143         14318180           // 14.318,180 MHz
#define CRYSTAL_FREQ135         13500000           // 13.500,180 MHz
#define CRYSTAL_FREQ143KHZ      14318              // 14318 kHz
#define CRYSTAL_FREQ135KHZ      13500              // 13500 kHz

//
// VBE3.0-based CRTC Timings Table
//
typedef struct gtf_timings_structure
{
    U016    horiz_total;
    U016    horiz_start;
    U016    horiz_end;
    U016    vertical_total;
    U016    vertical_start;
    U016    vertical_end;
    U008    flags;
    U032    dot_clock;
    U016    refresh;
} GTF_TIMINGS, *PGTF_TIMINGS;

//
// DMT Override Table
//
typedef struct DMT_Overrides_structure
{
    U016    DotClock;
    U016    Polarity;
    U016    CR0;
    U016    CR2;
    U016    CR3;
    U016    CR4;
    U016    CR5;
    U016    CR6;
    U016    CR7;
    U016    CR10;
    U016    CR11;
    U016    CR15;
    U016    CR16;

} DMT_OVERRIDES, *PDMT_OVERRIDES;

//
// State flags for GTF structure
//
#define GTF_FLAGS_SINGLE_SCANNED    0x00
#define GTF_FLAGS_DOUBLE_SCANNED    0x01
#define GTF_FLAGS_NON_INTERLACED    0x00
#define GTF_FLAGS_INTERLACED        0x02
#define GTF_FLAGS_HSYNC_POSITIVE    0x00
#define GTF_FLAGS_HSYNC_NEGATIVE    0x04
#define GTF_FLAGS_VSYNC_POSITIVE    0x00
#define GTF_FLAGS_VSYNC_NEGATIVE    0x08


// Standard VGA Mode Table Structure
typedef struct _seq_
{
    U008 ClockMode;
    U008 MapMask;
    U008 FontAddr;
    U008 MemMode;
} SEQ;

typedef struct  _crtc_
{
    U008   HTotal;
    U008   HDispEnd;
    U008   HBlankS;
    U008   HBlankE;
    U008   HSyncS;
    U008   HSyncE;
    U008   VTotal;
    U008   Overflow;
    U008   PresetRowScan;
    U008   CellHeight;
    U008   CursorS;
    U008   CursorE;
    U008   RegenSHigh;
    U008   RegenSLow;
    U008   CursorPosHigh;
    U008   CursorPosLow;
    U008   VSyncS;
    U008   VSyncE;
    U008   VDispE;
    U008   RowOffset;
    U008   ULineRow;
    U008   VBlankS;
    U008   VBlandE;
    U008   Mode;
    U008   LineCompare;
} CRTC;

typedef struct  _gr_
{
    U008   SetReset;
    U008   EnableSetReset;
    U008   ColorCmp;
    U008   ROP;
    U008   ReadMap;
    U008   Mode;
    U008   Misc;
    U008   CDC;
    U008   BitMask;
} GR;

// Standard VGA Mode Table format.
typedef struct _vga_mode_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U016  RegenLenght;
    SEQ     seq_regs;              // SR1-4
    U008   PT_Misc;               // Misc Register
    CRTC    crtc_regs;             // CR0-18
    U008   PT_ATC[20];            // Attribute Controller
    GR      gr_regs;               // GR0-8
} VGATBL;

// Indexes into the clock table
#define MAX_DCLK    0x1F            // 229.50 Mhz
#define MAX_ATC     0x16            // 108 Mhz

#define    CLKID_50_35     0x00
#define    CLKID_56_64     0x01
#define    CLKID_33_25     0x02
#define    CLKID_52        0x03
#define    CLKID_80        0x04
#define    CLKID_63        0x05
#define    CLKID_EXT       0x06
#define    CLKID_75        0x07
#define    CLKID_25_175    0x08
#define    CLKID_28_322    0x09
#define    CLKID_31_5      0x0A
#define    CLKID_36        0x0B
#define    CLKID_40        0x0C
#define    CLKID_44_9      0x0D
#define    CLKID_50        0x0E
#define    CLKID_65        0x0F
#define    CLKID_108       0x10        // Requires clock doubler
#define    CLKID_135       0x11        // Requires clock doubler
#define    CLKID_49_5      0x12
#define    CLKID_56_25     0x13
#define    CLKID_78_75     0x14
#define    CLKID_94_5      0x15
#define    CLKID_108_5     0x16        // Requires clock doubler
#define    CLKID_35_5      0x17
#define    CLKID_158       0x18        // Requires clock doubler
#define    CLKID_55_86     0x19
#define    CLKID_20        0x1A
#define    CLKID_27_93     0x1B
#define    CLKID_32_5      0x1C
#define    CLKID_12_588    0x1D
#define    CLKID_81_62     0x1E
#define    CLKID_219_566   0x1F
#define    CLKID_172_798   0x20
#define    CLKID_193_156   0x21
#define    CLKID_229_5     0x22
#define    CLKID_136_36    0x23

// Video Mode Control Structure
typedef struct _vmode_
{
    U016  mdVMode;                // Mode Number of this mode
    U008   mdMode;                 // Internal Mode Number
    U008   mdIMode;                // Standard Mode Table Index
    U008   mdEMode;                // Extended Mode Table Index
    U008   mdTVMode;               // TV Mode Table Index
    U008   mdCMode;                // Extended CRTC Override Index
    U008   mdBPP;                  // Bits per Pixel
    U016  mdXRes;                 // X resolutio
    U016  mdYRes;                 // Y resolutionn
    U016  mdRowOff;               // Scanline Row Offset
    U016  mdMaxDotClock;          // Maximum DCLK

} MODEDESC;


typedef struct _ext_regs_
{
                            // ++++------- Reserved
                            // |||| +----- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| |+---- CR1C[2] - Sequential Chain 4
                            // |||| ||+--- CR1C[1] - Page Select Control
                            // |||| |||+-- CR1A[0] - Address Wrap
    U008   xrFlags;         // VVVV VVVV
                            // 7654 3210

                            // +---------- NV_PRAMDAC_GENERAL_CONTROL[12] - 565_MODE
                            // |+++------- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| +----- CR25[5] - Bit 11 of offset
                            // |||| |+++-- CR19[7:5] - Bits 8->10 of Offset
    U008   xrOffset;        // VVVV VVVV
                            // 7654 3210

                            // ++--------- CR2D[3:2] - Bit 8 of HRetrace & HBlank Starts
                            // ||+-------- CR1A[2] - Large Screen bit
                            // |||+------- CR25[4] - Bit 6 of HBlank End
                            // |||| ++---- Bit 10 of VBlank & VRetrace Start
                            // |||| ||++-- VDisp End, VTotal
    U008   xrVOver;         // VVVV VVVV
                            // 7654 3210

                            // ++--------- CR2D[1:0] - Bit 8 of DHisp End and HTotoal
                            // ||++------- CR1C[4:3] - Optimized chain-4 write/read access
                            // |||| +----- CR28[3] - NV_PRAMDAC_PLL_COEFF_SELECT[28]
                            // |||| |                VCLK Divide by 1 or 2
                            // |||| |+---- CR28[2] - Linear/Tile mode
                            // |||| ||++-- CR28[1:0] - Pixel Format
    U008   xrPixFmt;        // VVVV VVVV
                            // 7654 3210

    U008   xrVOffset;      // CR13 - VGA Offset register
    U008   xrIntlace;      // CR39 - Interlace Half Field Start
    U016  xrRegenLength;   // Override of PT_RegenLength (res+color depth specific)
    U008   xrClkSel;       // Pixel Clock Select

} EXTREGS;

typedef struct _tv_regs_
{
    U008   tvIntlace;              // CRTC[39] (Interlace Half Field Start)
    U008   tvDecimate_NTSC;        // CRTC[29] (Decimate for TV)
    U008   tvHT_NTSC;              // CRTC[00] (Horiztonal total for NTSC)
    U008   tvHRS_NTSC;             // CRTC[04] (Horizontal retrace start for NTSC)
    U008   tvVT_NTSC;              // CRTC[06] (Vertical total for NTSC)
    U008   tvVO_NTSC;              // CRTC[07] (Vertical overflow for NTSC)
    U008   tvVRS_NTSC;             // CRTC[10] (Vertical retrace start for NTSC)
    U008   tvHDE_NTSC;             // CRTC[01] (Horizontal Display End)
    U008   tvHBS_NTSC;             // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_NTSC;             // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_NTSC;             // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_NTSC;             // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_NTSC;             // CRTC[12] (Vertical Display End)
    U008   tvVBS_NTSC;             // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_NTSC;             // CRTC[16] (Vertical Blank End)
    U008   tvDecimate_PAL;         // CRTC[29] (Decimate for TV)
    U008   tvHT_PAL;               // CRTC[00] (Horiztonal total for PAL)
    U008   tvHRS_PAL;              // CRTC[04] (Horizontal retrace start for PAL)
    U008   tvVT_PAL;               // CRTC[06] (Vertical total for PAL)
    U008   tvVO_PAL;               // CRTC[07] (Vertical overflow for PAL)
    U008   tvVRS_PAL;              // CRTC[10] (Vertical retrace start for PAL)
    U008   tvHDE_PAL;              // CRTC[01] (Horizontal Display End)
    U008   tvHBS_PAL;              // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_PAL;              // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_PAL;              // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_PAL;              // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_PAL;              // CRTC[12] (Vertical Display End)
    U008   tvVBS_PAL;              // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_PAL;              // CRTC[16] (Vertical Blank End)

} TVREGS;

// CRTC Override Structure. This structure overrides the settings selected
// from the standard modeset mode table.
//
typedef struct _crtc_ovr_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U008   CO_Misc;                // Misc Register
    U008   CO_ClockMode;           // SR1
    U008   HTotal;                 // CR00
    U008   HDispEnd;               // CR01
    U008   HBlankS;                // CR02
    U008   HBlankE;                // CR03
    U008   HSyncS;                 // CR04
    U008   HSyncE;                 // CR05
    U008   VTotal;                 // CR06
    U008   Overflow;               // CR07
    U008   CO_CellHeight;          // CR09
    U008   CO_VSyncStart;          // CR10
    U008   VSyncE;                 // CR11
    U008   VDispE;                 // CR12
    U008   CO_VBlankStart;         // CR15
    U008   VBlandE;                // CR16

}CRTC_OVERRIDE;

//
// Fifo settings
//
typedef struct _modeset_fifo_
{
    U016  Freq;                   // Maximum frequency for these water marks
    U008   LowWaterMark64;         // Low water mark for 64 bit bus
    U008   BurstSize64;            // Burst size for 64 bit bus
    U008   LowWaterMark128;        // Low water mark for 128 bit bus
    U008   BurstSize128;           // Burst size for 128 bit bus

} MODESET_FIFO;

//
// CRTC access state (for dos compile)
//
typedef struct _save_astate_
{
    U016   crtc_addr;          // CRTC Address
    U032   nv_address;         // 32-bit NV address
    U008   access_bits;        // Access Control Bits
    U008   access_reg;         // Access Register (NVRM_ACCESS)
    U016   data_low;           // Low 32-bits of data register
} ACCESS_STATE;


//
// Modeset function prototypes
//
VOID NvPost(VOID);
U016 VBESetMode(U016, PGTF_TIMINGS,PDMT_OVERRIDES,U016);         // VESA SetMode
U016 VBESetRefresh(PGTF_TIMINGS);
MODEDESC *ValidateMode(U016 );    // Validate VESA Mode
U008 isTV(VOID);
U008 OEMValidateMode(MODEDESC *);
U016 OEMGetMemSize(VOID);
VOID SaveNVAccessState(ACCESS_STATE *);
VOID RestoreNVAccessState(ACCESS_STATE *);
U032 ReadPriv32(U032 );
U016 ReadIndexed(U032 , U008 );
VOID WriteIndexed(U032, U016);
VOID OEMPreSetRegs(VOID);
VOID SetRegs(MODEDESC *);
VOID LoadIndexRange(U032, U008, U008, U008 *);
VOID ATCOff(VOID);
VOID ATCOn(VOID);
VOID OEMSetRegs(MODEDESC *);
VOID FullCpuOn(VOID);
VOID FullCpuOff(VOID);
U032 CalcMNP(U016 *);
VOID OEMSetClock(U016 );
VOID WritePriv32(U032 , U032 );
VOID LoadDefaultATCAndSavePtr(U008 *);
VOID LoadDefaultRAMDAC(MODEDESC *);
VOID LoadPalette(MODEDESC *);
VOID LoadColorDACTable(VOID);
VOID LoadColor256DAC(VOID);
VOID LoadIdentityDAC(VOID);
VOID WriteColor(U008 );
VOID WriteColor2(U016 , U016 , U016 , U016 );
VOID FixLowWaterMark(U016 );
VOID SetDACClock(U032 );
VOID WritePriv08(U032 , U008 );
U016 h2i(U008 *);                // Hex 2 Integer
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\nv.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV.C
//
// Abstract:
//
//     This is the miniport driver for NV Adapters.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the ET4000 Miniport driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvapi.h"

#include "modedefs.h"

#include "nvMultiMon.h"

#ifdef PC98
#include "modes.h"
#endif // PC98

#include "rm.h"
#include "nvcm.h"

#if NVDLL == 0
LONG
MxInitSystem(
    IN PVOID Argument1
    );
#endif



// To get the twinview definitions
#include "nvMultiMon.h"

// modeset DLL definitions                    
#include "modeext.h"
extern int FindModeEntry (LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew);

#if (_WIN32_WINNT >= 0x0500)

// Normally we would include #ntddk.h, but that would include a bunch
// of other structures that would cause redefinitions / errors.  We just
// want the definition for HalGetBusData so we can workaround the ALI 1541 chipset bugs

extern ULONG HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

extern ULONG HalGetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern ULONG HalSetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

#endif

extern InitializeCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension);
extern VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension);


VP_STATUS
NVGetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
NVReadMonitorTimingModeCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
VP_STATUS
NVReadRegistryBinaryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

BOOLEAN  GetHeadPhysicalModeList(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    HEAD_MODE_LIST_INFO * pInput,
    ULONG * pRetSize);

ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);

ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask);

VOID InitializeACPIStates(
    PHW_DEVICE_EXTENSION hwDeviceExtension);

//******************************************************************************
// The following declarations are needed to use the memory manager functions
//******************************************************************************
#define NV_PWR_MGMT
#define SYSMEM_FUDGE    (0x1000)

#define NTKERNELAPI DECLSPEC_IMPORT


extern VOID NVEnableBusMastering(PHW_DEVICE_EXTENSION);
extern VOID NVEnableVGASubsystem(PHW_DEVICE_EXTENSION);
extern VOID NVExtractBiosImage(PHW_DEVICE_EXTENSION);
extern VOID NVClearMutexPmeAudBuff0(PHW_DEVICE_EXTENSION);
extern U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10];
extern VOID NV_DisableNVInterrupts(PHW_DEVICE_EXTENSION);
extern VOID NV_ReEnableNVInterrupts(PHW_DEVICE_EXTENSION);
extern VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION);
extern VOID BuildAvailableModesTable(PHW_DEVICE_EXTENSION);
extern VOID LoadRegistrySettings(PHW_DEVICE_EXTENSION);
extern VOID WakeUpCard(PHW_DEVICE_EXTENSION);
extern VOID NV_SetPixMixBits(PHW_DEVICE_EXTENSION);
extern VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
extern VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
extern VOID NV_ManualTextModeSet(PHW_DEVICE_EXTENSION);


extern void NVMapPhysIntoUserSpace(
        PHYSICAL_ADDRESS pa,
        LONG byteLength,
        PVOID *userVirtualAddress);

extern void NvMapIntoUserSpace(
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
        );

extern void NvUnmapFromUserSpace(
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
        );

extern void
NvLockdownMemory(
    NV_LOCK_DOWN_MEMORY *pLockdownMemory
    );

extern void
NvUnlockMemory(
    NV_UNLOCK_MEMORY *pUnlockMemory
    );

extern void
NvSystemMemoryShare(
    NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
    );

extern void
NvSystemMemoryUnShare(
    NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
    );

NTKERNELAPI PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    IN PVOID BaseAddress
    );

typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmCachingTypeDoNotUse1,
    MmCachingTypeDoNotUse2,
    MmMaximumCacheType
} MEMORY_CACHING_TYPE;

NTKERNELAPI
PVOID
MmMapIoSpace (
    IN ULONG PhysicalAddress,
    IN size_t NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

NTKERNELAPI
VOID
MmUnmapIoSpace (
    IN PVOID BaseAddress,
    IN size_t NumberOfBytes
    );


//******************************************************************************
//
// Function declarations
//
//******************************************************************************
BOOLEAN bScanHeadDeviceOptions(PHW_DEVICE_EXTENSION HwDeviceExtension);

SHORT GetNextWordFromRegistry(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR *SrcStrPtr
    );

SHORT my_wtoi(
    PUCHAR *SrcStrPtr
    );

VP_STATUS
NVFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
NVInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
NVInitialize_DacsAndEDID(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
NVOneTimeInit_TwinView(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
NVInterrupt(
    PVOID HwDeviceExtension
    );

VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );



#if (_WIN32_WINNT >= 0x0500)

ULONG
NVGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );

#ifdef NV_PWR_MGMT
VP_STATUS
NVGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

VP_STATUS
NVSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

VOID
NVAMD751ChipsetSaveHibernationRegisters(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
NVAMD751ChipsetRestoreHibernationRegisters(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

extern BOOLEAN NV_VBE_DPMS_SetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PowerState);
extern BOOLEAN NV_VBE_DPMS_GetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG *CurrentPowerState);

#endif // #ifdef NV_PWR_MGMT

BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR QueryBuffer,
    ULONG BufferSize);
#endif // if (_WIN32_WINNT >= 0x0500)

// Support to validate a mode on a particular display device for control panel
BOOL NVValidateDeviceMode(PHW_DEVICE_EXTENSION HwDeviceExtension, VALMODEXTR *vmx);

//******************************************************************************
// Global variable used to detect if the ALI 1541 chipset is found.
// It needs to be global since the hwDeviceExtension is not preserved.
//******************************************************************************

ULONG Ali_1541_Chipset_Found = FALSE;

//******************************************************************************
// Value of VIA GA Translation Table Base register (offset 88)
//******************************************************************************

ULONG   ViaAgpRegister;


//******************************************************************************
// Global variable used to detect if several adapters are present
//******************************************************************************

ULONG MultiAdaptersPresent = FALSE;

//******************************************************************************
// Static area buffer used to read information from the registry
//******************************************************************************

U016 registry_data[MAX_STRING_REGISTRY_DATA_WORDS];

//
//  Global flag to ensure RmInitRm() to be called only once.
//

BOOLEAN g_bIsRmInitRmCalled = FALSE;

//******************************************************************************
//
// Private function prototypes.
//
//******************************************************************************

VP_STATUS
NVQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

BOOLEAN
NVIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    //PVIDEO_ACCESS_RANGE pAccessRange,
    PULONG NV1Slot
    );

VP_STATUS
NVSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VOID
NVValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VOID NV10CursorTimer(
    PVOID HwDeviceExtension
);

BOOL NVGetTimingForDac(PHW_DEVICE_EXTENSION hwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);

//////// H.AZAR
#ifdef NVPE
VP_STATUS NVQueryInterface( PVOID HwDeviceExtension, PQUERY_INTERFACE QueryInterface);
VP_STATUS NVPEProcessCommand(PVOID pHwDeviceExtension, PVIDEO_REQUEST_PACKET pRequestPacket);
VP_STATUS NVRegistryCallbackPnpId(PVOID HwDeviceExtension, PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength);
#endif

#ifdef PC98

// global device extension pointer and frame buffer pointer
// used for local POST and mode sets
extern PHW_DEVICE_EXTENSION HwDeviceExtension;
extern PHWREG fbAddr;
VOID NvPostEx(PHW_DEVICE_EXTENSION pHwDevExt)
{
    PHYSICAL_ADDRESS physFbAddr;
    ULONG length, inIoSpace;

    // init global device extension for local POST
    HwDeviceExtension = pHwDevExt;

    // map the frame buffer
    physFbAddr.HighPart = 0x00000000;
    physFbAddr.LowPart = NVAccessRange[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
    physFbAddr.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;
    length = 0x400000;
    inIoSpace = FALSE;
    fbAddr = 0;
    VideoPortMapMemory(
        pHwDevExt,
        physFbAddr,
        &length,
        &inIoSpace,
        &fbAddr
    );

    // perform the POST based on global fbAddr and addresses in the device extension
    NvPost();

    // unmap the frame buffer
    VideoPortUnmapMemory(
        pHwDevExt,
        fbAddr,
        0
    );
}

#endif // PC98

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344
#define DISPLAY_ADAPTER_HW_ID           0xFFFFFFFF

//******************************************************************************
// The functions listed below are pageable
//******************************************************************************

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,NVFindAdapter)
#pragma alloc_text(PAGE,NVInitialize)
#pragma alloc_text(PAGE,NVStartIO)
#pragma alloc_text(PAGE,NVIsPresent)
#pragma alloc_text(PAGE,NVSetColorLookup)

#if (_WIN32_WINNT >= 0x500)
#pragma alloc_text(PAGE, NVGetChildDescriptor)
#pragma alloc_text(PAGE, NVGetPowerState)
#pragma alloc_text(PAGE, NVSetPowerState)
#endif  // #if (_WIN32_WINNT >= 0x500)

#endif  // #if defined(ALLOC_PRAGMA)

//******************************************************************************
//
// Function: DriverEntry()
//
// Routine Description:
//
//     Installable driver initialization entry point.
//     This entry point is called directly by the I/O system.
//
// Arguments:
//
//     Context1 - First context value passed by the operating system. This is
//         the value with which the miniport driver calls VideoPortInitialize().
//
//     Context2 - Second context value passed by the operating system. This is
//         the value with which the miniport driver calls VideoPortInitialize().
//
// Return Value:
//
//     Status from VideoPortInitialize()
//
//******************************************************************************


ULONG DriverEntry(
    PVOID Context1
    )


    {

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;

#if NVDLL == 0

    return MxInitSystem(Context1);

#endif


    //**************************************************************************
    // Zero out structure.
    //**************************************************************************

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //**************************************************************************
    // Specify sizes of structure and extension.
    //**************************************************************************

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //**************************************************************************
    // Set entry points.
    //**************************************************************************

    hwInitData.HwFindAdapter = NVFindAdapter;
    hwInitData.HwInitialize = NVInitialize;
    hwInitData.HwStartIO = NVStartIO;
    hwInitData.HwInterrupt = NVInterrupt;
    // This timer is only enabled on NV10 and alpha cursor blending.
    hwInitData.HwTimer = NV10CursorTimer;

    //**************************************************************************
    // New NT 5.0 EntryPoint
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0500)

    hwInitData.HwGetVideoChildDescriptor = NVGetChildDescriptor;

#ifdef NV_PWR_MGMT
    hwInitData.HwGetPowerState = NVGetPowerState;
    hwInitData.HwSetPowerState = NVSetPowerState;
#endif // #ifdef NV_PWR_MGMT

#ifdef NVPE
    hwInitData.HwQueryInterface = NVQueryInterface;

#endif

#endif

    //**************************************************************************
    // Determine the size we require for the device extension.
    //**************************************************************************

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //**************************************************************************
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //**************************************************************************

//    hwInitData.StartingDeviceNumber = 0;

    //**************************************************************************
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and MCA.
    // We will return the minimum of all return values.
    //
    //
    // NOTE: For NV, we must be running on a PCI Bus
    //
    //**************************************************************************

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               NULL,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
       {
       return initializationStatus;
       }


    //**************************************************************************
    // We didn't find the card on any bus type, so lets
    // return the last error.
    //**************************************************************************

    return initializationStatus;

    } // end DriverEntry()



//**************************************************************************
// NT 5.0 specific entry points.
//**************************************************************************


#if (_WIN32_WINNT >= 0x0500)
ULONG
NVGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )

/*++

Routine Description:

    Enumerate all devices controlled by the ATI graphics chip.
    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    ChildIndex        - Index of the child the system wants informaion for.

    pChildType        - Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor  - Identification structure of the device (EDID, string)

    ppHwId            - Private unique 32 bit ID to passed back to the miniport

    pMoreChildren     - Should the miniport be called

Return Value:

    TRUE if the child device existed, FALSE if it did not.

Note:

    In the event of a failure return, none of the fields are valid except for
    the return value and the pMoreChildren field.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG                Status;
    ULONG                ulDacs;

    switch (ChildEnumInfo->ChildIndex) {

    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;


    case 1:

        //
        // This is the last device we enumerate.  Tell the system we don't
        // have any more.
        //

        *pChildType = Monitor;

        //**********************************************************************
        // Unattended install with Intel 810 present:
        // Make sure to SKIP this call, if the device has NOT been mapped!!!
        // (Skip this function if currently running unattended install with
        // an Intel 810)
        //**********************************************************************

#ifndef ENABLE_EXPORTING_EDID_TO_WIN2K
        //
        // Obtain the EDID structure via DDC.
        //

        RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_NUMBER_OF_HEADS, &ulDacs);
        // Supports more than one monitors
        if(ulDacs > 1)
        {
            *pHwId = QUERY_NONDDC_MONITOR_ID;
            Status = ERROR_MORE_DATA;
            break;
        } 
#endif

        if ( (hwDeviceExtension->DeviceMappingFailed == FALSE) &&
             (GetDdcInformation(HwDeviceExtension,
                              (PUCHAR) pvChildDescriptor,
                              ChildEnumInfo->ChildDescriptorSize))    )
        {
            *pHwId = QUERY_MONITOR_ID;

            VideoDebugPrint((1, "NvGetChildDescriptor - successfully read EDID structure\n"));

        } else {

            //
            // Alway return TRUE, since we always have a monitor output
            // on the card and it just may not be a detectable device.
            //

            *pHwId = QUERY_NONDDC_MONITOR_ID;

            VideoDebugPrint((1, "NvGetChildDescriptor - DDC not supported\n"));

        }

        Status = ERROR_MORE_DATA;
        break;

#ifdef NVPE
        case 2:
#define NVCAP_I2C_DEVICE_ID     0xCA000002

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_cap",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVCAP_I2C_DEVICE_ID;
                    *pChildType = Other;
                    //VideoPortMoveMemory(pvChildDescriptor, L"nvcap", sizeof(L"nvcap")); //strPnpId, wcslen(strPnpId));
                    Status = ERROR_MORE_DATA;  // we want to be called again...
                }
                else
                    Status = ERROR_INVALID_NAME;

                break;

        case 3:
#define NVXBAR_I2C_DEVICE_ID    0xCA000003

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_xbar",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVXBAR_I2C_DEVICE_ID;
                    *pChildType = Other;
                    Status = ERROR_MORE_DATA;  // we want to be called again...
                }
                else
                    Status = ERROR_INVALID_NAME;

                break;

        case 4:
#define NVTUNER_I2C_DEVICE_ID   0xCA000004

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_tuner",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVTUNER_I2C_DEVICE_ID;
                    *pChildType = Other;
                    Status = ERROR_MORE_DATA;  // we want to be called again...
                }
                else
                    Status = ERROR_INVALID_NAME;

                break;
#endif  // #ifdef NVPE


    case DISPLAY_ADAPTER_HW_ID:

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        Status = ERROR_MORE_DATA;
        break;


    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }


    return Status;
}

#ifdef NV_PWR_MGMT

#ifdef ENABLE_RESMAN_ACPI_CODE

VP_STATUS
NVGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    This function is called to see if a given device can go into a given
    power state.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.


    HwDeviceId           - Private unique 32 bit ID identifing the device.
                           0xFFFFFFFF indicates the NV card itself.

    VideoPowerManagement - Pointer to the power management structure which
                           indicates the power state in question.

Return Value:

    NO_ERROR if the device can go into the requested power state,
    otherwise an appropriate error code is returned.

--*/
{
ULONG CurrentPowerState;

    //*************************************************************************
    // Unattended install with Intel 810 present:
    // Make sure to SKIP this call, if the device has NOT been mapped!!!
    // (Skip this function if currently running unattended install with
    // an Intel 810)
    //*************************************************************************

    if (HwDeviceExtension->DeviceMappingFailed == TRUE)
        return NO_ERROR;


    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {
    
        // We deal with only the head0 since the Win2K OS is aware of only head0.
        ULONG ulPrimaryHead;
        BOOL bRet;
        ulPrimaryHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[0];
        switch (VideoPowerManagement->PowerState)
        {
        case VideoPowerOn:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerOn])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerOff:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerOff])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerHibernate:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerHibernate])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerSuspend:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerSuspend])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerStandBy:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerStandBy])
            {
                return(NO_ERROR);
            }
            break;
        default:
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }

        // The requested monitor power state is not supported by ResMan.
        VideoDebugPrint((0,"Oops! NVGetPowerState for Monitor, QueriedState: 0x%x not supported\n",
                        VideoPowerManagement->PowerState));
        return(ERROR_INVALID_PARAMETER);

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) 

    {
        BOOL bRet;
        
        //
        // We are querying power support for the graphics card.
        //


        switch (VideoPowerManagement->PowerState)
        {
        
        case VideoPowerOn:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn])
            {
                return(NO_ERROR);
            }
            break;
            
        case VideoPowerHibernate:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerStandBy:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerSuspend:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerOff:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff])
            {
                return(NO_ERROR);
            }
            break;

        default:
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }
        // The requested monitor power state is not supported by ResMan.
        VideoDebugPrint((0,"Oops! NVGetPowerState for Adapter, QueriedState: 0x%x not supported\n",
                        VideoPowerManagement->PowerState));
        return(ERROR_INVALID_PARAMETER);

    } else {

        VideoDebugPrint((0, "Unknown HwDeviceId\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}



VP_STATUS
NVSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{

    //*************************************************************************
    // Unattended install with Intel 810 present:
    // Make sure to SKIP this call, if the device has NOT been mapped!!!
    // (Skip this function if currently running unattended install with
    // an Intel 810)
    //*************************************************************************

    if (HwDeviceExtension->DeviceMappingFailed == TRUE)
        return NO_ERROR;



    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID))
    {

        ULONG i, ulHead, State;
        BOOL bRet;

        for (i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
        {
            ulHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];

            switch (VideoPowerManagement->PowerState)
            {
            
            case VideoPowerOn:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOn];
                break;
            case VideoPowerHibernate:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerHibernate];
                break;

            case VideoPowerStandBy:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerStandBy];
                break;
            case VideoPowerSuspend:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerSuspend];
                break;
            case VideoPowerOff:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOff];
                break;
            default:
                VideoDebugPrint((0, "Unknown power state.\n"));
                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
            }
            bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, ulHead, State);
            if (bRet == FALSE)
            {
                VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for monitor %d, for State: 0x%x\n",
                                 ulHead, State));
            }

        }
        return(TRUE);
    }

    if (HwDeviceId == DISPLAY_ADAPTER_HW_ID)
    {


        switch (VideoPowerManagement->PowerState)
        {
        case VideoPowerOn:
            {
                ULONG State;
                BOOL bRet;


                //
                // If the device was previously turned off, we need to reinitialize it.
                //


                if ( (HwDeviceExtension->curPowerState == VideoPowerHibernate)  ||
                     (HwDeviceExtension->curPowerState == VideoPowerStandBy)    ||
                     (HwDeviceExtension->curPowerState == VideoPowerSuspend)    ||
                     (HwDeviceExtension->curPowerState == VideoPowerOff))
                {
                    VIDEO_REQUEST_PACKET requestPacket;
                    STATUS_BLOCK statusblock;


                    if (HwDeviceExtension->CurrentMode==NULL)
                    {
                        //
                        //  If CurrentMode is not initialized, we know that our chip is
                        //  never initialized at all therefore, we must exit immediately.
                        //  And we should return no error. (configuration: ATI on motherboard
                        //  primary, NV3 as secondary, not posted)

                        //  NOTE:  Keep this fix here for now, until we can verify that
                        //  we can write to hardware registers in RmLoadState().
                        //  i.e....If this device was NOT posted, I'm not convinced that
                        //  we'll be able to touch the hardware registers (device is NOT on).
                        //  We should be able to delete this check once BIOS post code is added here.
                        //
                        return(NO_ERROR);
                    }


#ifndef IA64
                    //**********************************************************
                    // If the Via chipset is found, then we need to
                    // fixup one of the THEIR registers in order for AGP to work.
                    // Somewhat dangerous, but hibernation won't resume in
                    // AGP mode unless this register is programmed correctly.
                    //**********************************************************

                    if (HwDeviceExtension->Via694ChipsetFound == TRUE)
                    {

                        //******************************************************
                        // Save the value of this VIA AGP register
                        //******************************************************

                        /*
                        _asm {
                             mov    eax,0x80000088
                             mov    dx,0xcf8
                             out    dx,eax
    
                             mov    dx,0xcfc
                             mov    eax,ViaAgpRegister
                             out    dx,eax
                             }
                        */

                        HalSetBusDataByOffset(PCIConfiguration,
                                              0,    //  Bus 0
                                              0,    //  Slot 0
                                              &ViaAgpRegister,
                                              (0x88 >> 2),  //  Offset in byte
                                              sizeof(ULONG));   //  Size in byte
                    }

                    //**********************************************************
                    // If the AMD 751 chipset is found, then we need to 
                    // fixup two of THEIR registers in order for the AGP to work.
                    //**********************************************************
                    if (HwDeviceExtension->AMD751ChipsetFound == TRUE)
                    {
                        NVAMD751ChipsetRestoreHibernationRegisters(HwDeviceExtension);
                    }
#endif // IA64
                }

                // Call the resman to set to PowerOn state
                State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn];
                bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, 0, State);
                if (bRet == FALSE)
                {
                    VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for adapter for State: 0x%x\n",
                                     State));
                }

                HwDeviceExtension->curPowerState = VideoPowerManagement->PowerState;
                return(TRUE);
            }


            break;


        case VideoPowerHibernate:

        case VideoPowerStandBy:

        case VideoPowerSuspend:


        case VideoPowerOff:


            {
                VIDEO_REQUEST_PACKET requestPacket;
                STATUS_BLOCK statusblock;
                ULONG State;
                BOOL bRet;


                HwDeviceExtension->curPowerState = VideoPowerManagement->PowerState;

#ifndef IA64
                //**************************************************************
                // If the Via chipset is found, then we need to
                // fixup one of the THEIR registers in order for AGP to work.
                // Somewhat dangerous, but hibernation won't resume in
                // AGP mode unless this register is programmed correctly.
                //**************************************************************

                if (HwDeviceExtension->Via694ChipsetFound == TRUE)
                {

                    //**********************************************************
                    // Save the value of this VIA AGP register
                    //**********************************************************

                    /*
                    _asm {
                         mov    eax,0x80000088
                         mov    dx,0xcf8
                         out    dx,eax

                         mov    dx,0xcfc
                         in     eax,dx
                         mov    ViaAgpRegister,eax
                         }
                    */

                    HalGetBusDataByOffset(PCIConfiguration,
                                          0,    //  Bus 0
                                          0,    //  Slot 0
                                          &ViaAgpRegister,
                                          (0x88 >> 2),  //  Offset in bytes
                                          sizeof(ULONG));   //  Size in bytes
                }

                //**********************************************************
                // If the AMD 751 chipset is found, then we need to 
                // fixup two of THEIR registers in order for the AGP to work.
                //**********************************************************
                if (HwDeviceExtension->AMD751ChipsetFound == TRUE)
                {
                    NVAMD751ChipsetSaveHibernationRegisters(HwDeviceExtension);
                }
#endif // IA64

                switch (  VideoPowerManagement->PowerState)
                {
                
                case VideoPowerHibernate:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate];
                    break;
                case VideoPowerStandBy:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy];
                    break;
                case VideoPowerSuspend:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend];
                    break;
                case VideoPowerOff:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff];
                    break;
                default:
                    VideoDebugPrint((0,"Oops! NvSetPowerState(): some invalid PowerState: 0x%x, line: %d\n",
                                     VideoPowerManagement->PowerState, __LINE__));
                    // use some safe off value.
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff];
                    break;
                }

                // Call the ResMan to set the adapter power down to the required state
                // The 'head' arguement is irrelevant since we are setting the adapter power state.
                bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, 0, State);
                if (bRet == FALSE)
                {
                    VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for adapter for State: 0x%x\n",
                                 State));
                }

                return(TRUE);

            }


            break;




        default:
            //
            // Unrecognized power state.
            //
            VideoDebugPrint((0,"Oops! NvSetPowerState(): some invalid PowerState: 0x%x, line: %d\n",
                                     VideoPowerManagement->PowerState, __LINE__));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }
        return(TRUE);
    }

    VideoDebugPrint((0, "Unknown HwDeviceId\n"));
    ASSERT(FALSE);
    return ERROR_INVALID_PARAMETER;

}



#else  ENABLE_RESMAN_ACPI_CODE
VP_STATUS
NVGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    This function is called to see if a given device can go into a given
    power state.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.


    HwDeviceId           - Private unique 32 bit ID identifing the device.
                           0xFFFFFFFF indicates the NV card itself.

    VideoPowerManagement - Pointer to the power management structure which
                           indicates the power state in question.

Return Value:

    NO_ERROR if the device can go into the requested power state,
    otherwise an appropriate error code is returned.

--*/
{
ULONG CurrentPowerState;

    //*************************************************************************
    // Unattended install with Intel 810 present:
    // Make sure to SKIP this call, if the device has NOT been mapped!!!
    // (Skip this function if currently running unattended install with
    // an Intel 810)
    //*************************************************************************

    if (HwDeviceExtension->DeviceMappingFailed == TRUE)
        return NO_ERROR;


    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        //
        // We are querying the power support for the monitor.
        //

        if ((VideoPowerManagement->PowerState == VideoPowerOn) ||
            (VideoPowerManagement->PowerState == VideoPowerHibernate)) {

            return NO_ERROR;
        }

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_GET_POWER_FUNC;

        //**********************************************************************
        // For multi-monitor, we're not allowed to call the BIOS.
        // So we'll handle Power Management ourselves in the miniport.
        //**********************************************************************

//        VideoPortInt10(HwDeviceExtension, &biosArguments);
//
//        if ((biosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS) {
//
//            switch (VideoPowerManagement->PowerState) {
//
//            case VideoPowerOn:
//            case VideoPowerHibernate:
//                return NO_ERROR;
//
//            case VideoPowerStandBy:
//                return (biosArguments.Ebx & VESA_POWER_STANDBY) ?
//                       NO_ERROR : ERROR_DEVICE_REINITIALIZATION_NEEDED;
//
//            case VideoPowerSuspend:
//                return (biosArguments.Ebx & VESA_POWER_SUSPEND) ?
//                       NO_ERROR : ERROR_DEVICE_REINITIALIZATION_NEEDED;
//
//            case VideoPowerOff:
//                return (biosArguments.Ebx & VESA_POWER_OFF) ?
//                       NO_ERROR : ERROR_DEVICE_REINITIALIZATION_NEEDED;
//
//            default:
//                return ERROR_INVALID_PARAMETER;
//            }
//
//        } else {
//
//            VideoDebugPrint((1, "This device does not support Power Management.\n"));
//            return ERROR_DEVICE_REINITIALIZATION_NEEDED;
//        }


        //**********************************************************************
        // This call probably isn't necessary since we support all power states
        //**********************************************************************

        if (NV_VBE_DPMS_GetPowerState(HwDeviceExtension, &CurrentPowerState)== FALSE)
            {
            VideoDebugPrint((0, "Failed DPMS call.\n"));
            ASSERT(FALSE);
            return ERROR_DEVICE_REINITIALIZATION_NEEDED;
            }

        return NO_ERROR;



    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        //
        // We are querying power support for the graphics card.
        //

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:
            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:
                return NO_ERROR;
                break;




            default:
                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
                break;
        }

    } else {

        VideoDebugPrint((0, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}



VP_STATUS
NVSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{

    //*************************************************************************
    // Unattended install with Intel 810 present:
    // Make sure to SKIP this call, if the device has NOT been mapped!!!
    // (Skip this function if currently running unattended install with
    // an Intel 810)
    //*************************************************************************

    if (HwDeviceExtension->DeviceMappingFailed == TRUE)
        return NO_ERROR;



    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_SET_POWER_FUNC;

        switch (VideoPowerManagement->PowerState) {

        case VideoPowerOn:
        case VideoPowerHibernate:
            biosArguments.Ebx |= VESA_POWER_ON;
            break;

        case VideoPowerStandBy:
            biosArguments.Ebx |= VESA_POWER_STANDBY;
            break;

        case VideoPowerSuspend:
            biosArguments.Ebx |= VESA_POWER_SUSPEND;
            break;

        case VideoPowerOff:
            biosArguments.Ebx |= VESA_POWER_OFF;
            break;

        default:
            VideoDebugPrint((0, "Unknown power state.\n"));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        //**********************************************************************
        // For multi-monitor, we're not allowed to call the BIOS.
        // So we'll handle Power Management ourselves in the miniport.
        //**********************************************************************

//        VideoPortInt10(HwDeviceExtension, &biosArguments);

        if (NV_VBE_DPMS_SetPowerState(HwDeviceExtension, VideoPowerManagement->PowerState)== FALSE)
            {
            VideoDebugPrint((0, "Failed DPMS call.\n"));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            }

        return NO_ERROR;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        switch (VideoPowerManagement->PowerState) {
            case VideoPowerOn:



                //
                // If the device was previously turned off, we need to reinitialize it.
                //


                if ( (HwDeviceExtension->curPowerState == VideoPowerHibernate)  ||
                     (HwDeviceExtension->curPowerState == VideoPowerStandBy)    ||
                     (HwDeviceExtension->curPowerState == VideoPowerSuspend)    ||
                     (HwDeviceExtension->curPowerState == VideoPowerOff))

                    {
                    VIDEO_REQUEST_PACKET requestPacket;
                    STATUS_BLOCK statusblock;

                    if (HwDeviceExtension->CurrentMode==NULL)
                        {
                        //
                        //  If CurrentMode is not initialized, we know that our chip is
                        //  never initialized at all therefore, we must exit immediately.
                        //  And we should return no error. (configuration: ATI on motherboard
                        //  primary, NV3 as secondary, not posted)

                        //  NOTE:  Keep this fix here for now, until we can verify that
                        //  we can write to hardware registers in RmLoadState().
                        //  i.e....If this device was NOT posted, I'm not convinced that
                        //  we'll be able to touch the hardware registers (device is NOT on).
                        //  We should be able to delete this check once BIOS post code is added here.
                        //
                        return(NO_ERROR);
                        }


#ifndef IA64
                    //**********************************************************
                    // If the Via chipset is found, then we need to
                    // fixup one of the THEIR registers in order for AGP to work.
                    // Somewhat dangerous, but hibernation won't resume in
                    // AGP mode unless this register is programmed correctly.
                    //**********************************************************

                    if (HwDeviceExtension->Via694ChipsetFound == TRUE)
                        {

                        //******************************************************
                        // Save the value of this VIA AGP register
                        //******************************************************

                        /*
                        _asm {
                             mov    eax,0x80000088
                             mov    dx,0xcf8
                             out    dx,eax

                             mov    dx,0xcfc
                             mov    eax,ViaAgpRegister
                             out    dx,eax
                             }
                        */

                        HalSetBusDataByOffset(PCIConfiguration,
                                              0,    //  Bus 0
                                              0,    //  Slot 0
                                              &ViaAgpRegister,
                                              (0x88 >> 2),  //  Offset in byte
                                              sizeof(ULONG));   //  Size in byte
                        }

                    //**********************************************************
                    // If the AMD 751 chipset is found, then we need to 
                    // fixup two of THEIR registers in order for the AGP to work.
                    //**********************************************************
                    if (HwDeviceExtension->AMD751ChipsetFound == TRUE) {
                        NVAMD751ChipsetRestoreHibernationRegisters(HwDeviceExtension);
                    }
#endif // IA64

                    //**********************************************************
                    // Make absolutely sure bus mastering gets enabled.
                    // Some motherboard BIOS's don't turn it on
                    //**********************************************************

                    NVEnableBusMastering(HwDeviceExtension);

                    //**********************************************************
                    // Make absolutely sure VGA IO subsystem is enabled !!!!
                    // Some motherboard BIOS's don't turn it on
                    //**********************************************************

                    NVEnableVGASubsystem(HwDeviceExtension);

                    //**********************************************************
                    // Make sure to clear the NV3 'mutex' hardware register
                    //**********************************************************

                    NVClearMutexPmeAudBuff0(HwDeviceExtension);

                    //**********************************************************
                    // HIBERNATION:
                    // -----------
                    // If coming back from hibernation, ONLY post the card
                    // if it's NOT primary (primary cards are always posted when coming
                    // back from hibernation, secondary cards are NOT posted,
                    // so we need to post the card)
                    //
                    // S1 OR S3 STANDBY:
                    // ----------------
                    // Always POST the NV card (if coming back from S1 or S3 Standby)
                    //
                    // Preferably, we should only POST an NV card when coming back
                    // from S3 standby (power is removed from card) and not S1 (power remains).
                    // That's because, when posting a card, the card's OWN bios should be used
                    // to post the card, because each vendor's cards may vary in different ways.
                    // The POST code that we include here in the miniport is 'fallback' BIOS
                    // post code and has only been tested on reference NV boards.
                    // If systems were to always post the video card when resuming
                    // from S3 standby, this would NOT be a problem.  We wouldn't
                    // have to include fallback Bios post code here...
                    //
                    // But some systems (ie. Intel Kahneeta) allows users
                    // to DISABLE posting of their card when resuming from S3 Standby.
                    // So, we've included BIOS post code in our miniport driver (RmPostNvDevice)
                    // as a fall back.  Bottom line: Someone has to post the card
                    // if power was removed.  Preferably, the card's own BIOS should do it.
                    // Otherwise, the miniport will have to do it.
                    //
                    // Unfortunately, it doesn't seem like we can distinguish between
                    // S1 standby (where power is NOT removed) and S3 standby (power IS removed),
                    // since both use 'VideoPowerOff'. In addition, we have no idea
                    // if the user has DISABLED Bios Posting on S3 Resume, in the
                    // system BIOS setup.
                    //
                    // To make a long story short, it seems that we'll ALWAYS
                    // have to post our card when resuming from S1 or S3 Standby.
                    // (so the card may actually end up getting posted TWICE unecessarily)
                    //**********************************************************

                    if  (  (HwDeviceExtension->curPowerState != VideoPowerHibernate)  ||
                           ((HwDeviceExtension->curPowerState == VideoPowerHibernate) && (HwDeviceExtension->NonPrimaryDevice == TRUE)))
                        {

                        if ( (HwDeviceExtension->ulChipID == NV3_DEVICE_NV3_ID) &&
                             ((ULONG)(*(PULONG)(HwDeviceExtension->FrameBufferPtr)) == 0x33557799))
                            {
                            //**********************************************************
                            // Due to an S3 standby bug with NV3 and BIOS posting, we'll try to determine manually
                            // if this was S1 (Power stays on) or S3 (power removed).
                            // If power was removed, then we'll post NV3.  Otherwise, we won't post NV3
                            //**********************************************************

                            ; // Don't Post NV3 for S1 standby
                            }

                        else


                            {
                            if (!RmPostNvDevice(HwDeviceExtension->DeviceReference,(PHWREG)(&(HwDeviceExtension->SavedBiosImageArray[0])),(PHWREG)(HwDeviceExtension->FrameBufferBase)))
                                {
                                VideoDebugPrint((0, "ERROR:  ----------------------------- !!!! "));
                                VideoDebugPrint((0, "ERROR:  Could NOT Post the NV Device  !!!! "));
                                VideoDebugPrint((0, "ERROR:  Could NOT Post the NV Device  !!!! "));
                                VideoDebugPrint((0, "ERROR:  Could NOT Post the NV Device  !!!! "));
                                VideoDebugPrint((0, "ERROR:  ----------------------------- !!!! "));
                                }

                            }

                        }


                    //**********************************************************
                    // Restore Instance Memory and other registers
                    // which are NOT reloaded by RmLoadState
                    //**********************************************************

                    NVRestoreSpecificRegistersForPwrMgmt(HwDeviceExtension);

                    //**********************************************************
                    // AGP fixups for specific chipsets which have
                    // problems with AGP.
                    //**********************************************************

#if 0
                    RmUpdateAGPConfig(HwDeviceExtension->DeviceReference);
#endif

                    //**********************************************************
                    // Tell RM to reload device state.
                    //**********************************************************

                    if (!RmLoadState
                        (
                            HwDeviceExtension->DeviceReference,
                            HwDeviceExtension->LastWidth,
                            HwDeviceExtension->LastHeight,
                            HwDeviceExtension->LastDepth,
                            HwDeviceExtension->LastRefreshRate,
                            TRUE
                        )
                    )
                        {
                        return ERROR_INVALID_PARAMETER;
                        }
                    }
                    //**********************************************************
                    // Update the current power state
                    //**********************************************************

                    //
                    // Make sure the NV_PFIFO_CACHES register has the value 1 inorder to enable reassigning
                    // of the FIFO amongst different channels (clients). Otherwise, if you go down in standby/hibernate with 
                    // an OGL app, then on resumption the display driver hangs waiting on a notifier since this register
                    // would not have been enabled.
                    //
                    REG_WR32(0x00002500, 1);

                    HwDeviceExtension->curPowerState = VideoPowerManagement->PowerState;

                return NO_ERROR;
                break;


            case VideoPowerHibernate:
            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:

                {
                VIDEO_REQUEST_PACKET requestPacket;
                STATUS_BLOCK statusblock;


                HwDeviceExtension->curPowerState = VideoPowerManagement->PowerState;

#ifndef IA64
                //**************************************************************
                // If the Via chipset is found, then we need to
                // fixup one of the THEIR registers in order for AGP to work.
                // Somewhat dangerous, but hibernation won't resume in
                // AGP mode unless this register is programmed correctly.
                //**************************************************************

                if (HwDeviceExtension->Via694ChipsetFound == TRUE)
                    {

                    //**********************************************************
                    // Save the value of this VIA AGP register
                    //**********************************************************

                    /*
                    _asm {
                         mov    eax,0x80000088
                         mov    dx,0xcf8
                         out    dx,eax

                         mov    dx,0xcfc
                         in     eax,dx
                         mov    ViaAgpRegister,eax
                         }
                    */

                    HalGetBusDataByOffset(PCIConfiguration,
                                          0,    //  Bus 0
                                          0,    //  Slot 0
                                          &ViaAgpRegister,
                                          (0x88 >> 2),  //  Offset in bytes
                                          sizeof(ULONG));   //  Size in bytes
                    }

                //**********************************************************
                // If the AMD 751 chipset is found, then we need to 
                // fixup two of THEIR registers in order for the AGP to work.
                //**********************************************************
                if (HwDeviceExtension->AMD751ChipsetFound == TRUE) {
                    NVAMD751ChipsetSaveHibernationRegisters(HwDeviceExtension);
                }
#endif // IA64
                    

                //**************************************************************
                // Save instance memory and registers which are not saved
                // by RmUnloadState
                //**************************************************************

                NVSaveSpecificRegistersForPwrMgmt(HwDeviceExtension);

                //**************************************************************
                // changing the mode destroys instance memory, unload (i.e. store away)
                // device state for the RM.
                //**************************************************************
                if (!RmUnloadState(HwDeviceExtension->DeviceReference))
                    {
                    return ERROR_INVALID_PARAMETER;
                    }


                }


                //**************************************************************
                // NV3 hack: Write a value (0x33557799) to the frame buffer and
                //           see if it's still present when we resume. This hopefully
                //           will allows us to distinguish between an S1 or S3 standby
                //**************************************************************

                if (HwDeviceExtension->ulChipID == NV3_DEVICE_NV3_ID)
                    {
                    ((ULONG)(*(PULONG)(HwDeviceExtension->FrameBufferPtr)) = 0x33557799);
                    }


                return NO_ERROR;
                break;




            default:
                //
                // Unrecognized power state.
                //
                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
                break;
        }

    } else {

        VideoDebugPrint((0, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}
#endif ENABLE_RESMAN_ACPI_CODE

#ifndef _WIN64
VOID
NVAMD751ChipsetSaveHibernationRegisters(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PCI_COMMON_CONFIG AGPConfigInfo;
    PHYSICAL_ADDRESS physaddr;
    ULONG GetBusDataStatus;
    #define RM_PAGE_MASK 0x0FFF
    #define RM_PAGE_SIZE 4096

    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                0,                          // slot number
                &AGPConfigInfo,
                sizeof(PCI_COMMON_CONFIG));

    // Sanity check. Check the vendor ID and device ID.
    if ((GetBusDataStatus <= 2) || (AGPConfigInfo.VendorID != 0x1022) ||  (AGPConfigInfo.DeviceID != 0x7006)) {
        VideoDebugPrint((0, "*** NVAMD751ChipsetSaveHibernationRegisters(). Something wrong. The chipset is not AMD 751 even though it should be.\n"));
        return;
    }

    // AMD 751 has its AGP related regs memory-mapped via BAR1 (setup this mapping).
    physaddr.HighPart = 0;
    physaddr.LowPart  = AGPConfigInfo.u.type0.BaseAddresses[1] & ~RM_PAGE_MASK;
    HwDeviceExtension->AMD751_BAR1_Mapped_Address = (PHWREG)MmMapIoSpace(physaddr.LowPart, RM_PAGE_SIZE, FALSE);
    VideoDebugPrint((3, "hwDeviceExtension->AMD751_BAR1_Mapped_Address: 0x%p\n",HwDeviceExtension->AMD751_BAR1_Mapped_Address));
    if (HwDeviceExtension->AMD751_BAR1_Mapped_Address == (PHWREG)NULL) {
        VideoDebugPrint((0,"*** Failed to map AMD 751's AGP chipset registers\n"));
    } else {
        // Save the registers values. We restore them later while coming back up from hibernation.
        HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT =   HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg016[1];
        HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG  =   HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg032[1];
        VideoDebugPrint((3, "Saved AMD751 Status register: 0x%x\n",HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT));
        VideoDebugPrint((3, "Saved AMD751 GART Base register: 0x%x\n",HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG));
    }
}

VOID
NVAMD751ChipsetRestoreHibernationRegisters(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    // Sanity check. Ensure the chipset is AMD751.
    if (HwDeviceExtension->AMD751ChipsetFound != TRUE) {
        VideoDebugPrint((0, "*** NVAMD751ChipsetRestoreHibernationRegisters(). Something wrong. The chipset is not AMD 751 even though it should be.\n"));
        return;
    }
    //***********************************************************************
    // Two of the AMD 751 chipset's BAR1 registers are not set correctly when
    // the machines wakes up from hibernation. So we restore these
    // Enable and Status register and GART base register to the values at the
    // normal bootup time. 
    //***********************************************************************
    if ((VOID *)HwDeviceExtension->AMD751_BAR1_Mapped_Address != NULL) {
        HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg016[1] = HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT;
        HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg032[1] = HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG;
        VideoDebugPrint((3, "Restored AMD751 Status register: 0x%x\n",HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT));
        VideoDebugPrint((3, "Restored AMD751 GART Base register: 0x%x\n",HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG));
    }
}
#endif // #ifndef _WIN64

#endif // #ifdef NV_PWR_MGMT


#endif // #if (_WIN32_WINNT >= 0x0500)
//******************************************************************************
//
// Function:    NVFindAdapter()
//
// Routine Description:
//
//     This routine is called to determine if the adapter for this driver
//     is present in the system.
//     If it is present, the function fills out some information describing
//     the adapter.
//
// Arguments:
//
//     HwDeviceExtension - Supplies the miniport driver's adapter storage. This
//         storage is initialized to zero before this call.
//
//     HwContext - Supplies the context value which was passed to
//         VideoPortInitialize().
//
//     ArgumentString - Supplies a NULL terminated ASCII string. This string
//         originates from the user.
//
//     ConfigInfo - Returns the configuration information structure which is
//         filled by the miniport driver. This structure is initialized with
//         any known configuration information (such as SystemIoBusNumber) by
//         the port driver. Where possible, drivers should have one set of
//         defaults which do not require any supplied configuration information.
//
//     Again - Indicates if the miniport driver wants the port driver to call
//         its VIDEO_HW_FIND_ADAPTER function again with a new device extension
//         and the same config info. This is used by the miniport drivers which
//         can search for several adapters on a bus.
//
// Return Value:
//
//     This routine must return:
//
//     NO_ERROR - Indicates a host adapter was found and the
//         configuration information was successfully determined.
//
//     ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
//         error obtaining the configuration information. If possible an error
//         should be logged.
//
//     ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
//         supplied configuration information.
//
//******************************************************************************

VP_STATUS NVFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG NV1Slot;
    ULONG OutData;
    ULONG Status;
    PVOID NonCachedSystemMemoryPtr;
    ULONG TestSize;
    ULONG SysMemTextureFlag2;
    ULONG SysMemTextureFlag4;
    ULONG SysMemTextureFlag6;
    ULONG DMADisableFlag;
    ULONG DMAEnableFlag;
    ULONG DisableVBlankFlag;
    VP_STATUS   status;
    int i;
    PCI_COMMON_CONFIG pciData;
    PCI_COMMON_CONFIG ALIPciData;
    PCI_COMMON_CONFIG IntelPciData;
    ULONG SlotSearchNum;
    ULONG BusSearchNum;
    ULONG GetBusDataStatus;
    ULONG AliFoundStatus = FALSE;
    ULONG Intel810FoundStatus = FALSE;
    //**************************************************************************
    // Initialize this local variable before using it.
    //**************************************************************************
    //numAccessRanges = 0;

    //**************************************************************************
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //**************************************************************************

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //  Make sure that we only called this once
    //  The reason why RmInitRm() is moved to FindAdapter is that
    //  W2k/Whistler will unload miniport right after DriverEntry
    //  during setup.  Since there is no way to clean up any buffer
    //  allocation which we allocate in RmInitRm(), we end up holding
    //  a chunk of memory.
    //  Also, RmInitRm allocates global clientInfo and dmaListElementPool.
    //  In W2k/Whistler, DriverEntry is called multiple time depending on
    //  the number of devices.  If RmInitRm() is called more than one time,
    //  the new allocation will overwritten the previous one without freeing
    //  them first.  This leads to memory leads.

    if(!g_bIsRmInitRmCalled)
    {
        if(!RmInitRm())
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        g_bIsRmInitRmCalled = TRUE;
    }

    //**************************************************************************
    // Look for ALI 15411 chipset
    // Need to implement a workaround for chipset cache issues
    //**************************************************************************

    SlotSearchNum = 0;
    GetBusDataStatus = FALSE;
    AliFoundStatus   = FALSE;
    hwDeviceExtension->Via694ChipsetFound = FALSE;
    hwDeviceExtension->AMD751ChipsetFound = FALSE;


#if (_WIN32_WINNT >= 0x0500)
#if !defined(_WIN64)

    // Try to find ALI1541 chipset under Win2k
    //
    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                0,                          // slot number
                &ALIPciData,
                sizeof(PCI_COMMON_HDR_LENGTH));

    //**************************************************************************
    // If status is Non-zero, and greater than 2, check the vendor id, device id
    //**************************************************************************
   
    if (GetBusDataStatus > 2)
        {
        if ((ALIPciData.DeviceID == 0x1541) &&
            (ALIPciData.VendorID == 0x10B9))
            {
            AliFoundStatus = TRUE;
            }


        //**********************************************************************
        // Use the same structure, see if a VIA 694 chipset was found
        //**********************************************************************
        if ((ALIPciData.DeviceID == 0x691) &&
            (ALIPciData.VendorID == 0x1106))
            {
            hwDeviceExtension->Via694ChipsetFound = TRUE;
            }
    

        //**********************************************************************
        // Use the same structure, see if an AMD 751 chipset was found
        //**********************************************************************
        if ((ALIPciData.DeviceID == 0x7006) &&
            (ALIPciData.VendorID == 0x1022))
            {
                hwDeviceExtension->AMD751ChipsetFound = TRUE;
                // Note: Do not try to get the BAR1 address of the chipset.
                // It has not been set correctly at this point in time.
                // We will do that when we are going down in hibernation.
            }

        }
    //**************************************************************************
    // Try to find an Intel 810 chip
    //**************************************************************************

    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                1,                          // slot number
                &IntelPciData,
                sizeof(PCI_COMMON_HDR_LENGTH));

    //**************************************************************************
    // If status is Non-zero, and greater than 2, check the vendor id, device id
    //**************************************************************************

    if (GetBusDataStatus > 2)
        {
        if ( ((IntelPciData.DeviceID == 0x7121) || (IntelPciData.DeviceID == 0x7123) || (IntelPciData.DeviceID == 0x7125)) &&
            (IntelPciData.VendorID == 0x8086))
            {
            Intel810FoundStatus = TRUE;
            }

        }
#endif // !defined(_WIN64)


    //*************************************************************************
    // Save the size of physical system memory in the device extension.
    //*************************************************************************
    hwDeviceExtension->SystemMemorySize = ConfigInfo->SystemMemorySize;

#else // (_WIN32_WINNT >= 0x0500)

    // Try to find ALI1541 chipset under NT4

    while ( (SlotSearchNum<8) && (AliFoundStatus == FALSE) )
        {

        GetBusDataStatus = VideoPortGetBusData(
                           hwDeviceExtension,
                           PCIConfiguration,
                           SlotSearchNum,
                           &ALIPciData,
                           0,
                           PCI_COMMON_HDR_LENGTH
                           );

        //**************************************************************************
        // If status is Non-zero, and greater than 2, check the vendor id, device id
        //**************************************************************************

        if (GetBusDataStatus > 2)
            {
            if ((ALIPciData.DeviceID == 0x1541) &&
                (ALIPciData.VendorID == 0x10B9))
                {
                AliFoundStatus = TRUE;
                }

            }


        SlotSearchNum++;

        }

#endif

    //**************************************************************************
    // Tell the display driver to implement an IO workaround for the ALI 1541 chipset
    // Since FindAdapter gets called for the PCI and AGP buses, and
    // the HwDeviceExtension is NOT preserved, we unfortunately have to resort
    // to using a global variable.
    //**************************************************************************

    if (AliFoundStatus)
        Ali_1541_Chipset_Found = TRUE;

    //**************************************************************************
    // Check and see if NV adapter is present.  If NV is present, the
    // the BASE PHYSICAL address of NV is stored in the NVAccessRange
    // member of the device extension.
    //**************************************************************************

    if (!NVIsPresent(hwDeviceExtension, &NV1Slot))
        return(ERROR_DEV_NOT_EXIST);


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // Code change request for Win2k per Microsoft
    // Fail if there is a resource conflict
    //**************************************************************************

    if ( (ConfigInfo->BusInterruptLevel == 0 ) && (ConfigInfo->BusInterruptVector == 0))
        return(ERROR_DEV_NOT_EXIST);

#endif

    //**************************************************************************
    // Initialize the Ali_1541 flag in the hwDeviceExtension according
    // to the global flag (Since VideoPortGetBusData doesn't work
    // across buses)
    //**************************************************************************

    if (Ali_1541_Chipset_Found == TRUE)
        hwDeviceExtension->AliChipset_Problem_Found = TRUE;


    //**************************************************************************
    // Assume that the device mapping will always succeed
    //**************************************************************************

    hwDeviceExtension->DeviceMappingFailed = FALSE;

    //**************************************************************************
    // Now map the NV registers so we can get to them
    //**************************************************************************
    Status = NVMapMemoryRanges(hwDeviceExtension);
    if (Status != NO_ERROR)
        {
        //**********************************************************************
        // Our device mapping requires 16Mb.  This call has ALWAYS succeeded, even on 32Mb
        // systems.  However, during Win2k unattended install with an Intel 810 present,
        // this call may fail. In order to workaround this, We set a flag acknowledging
        // this low memory situation.  Subsequent functions will have to be forced
        // to succeed (and do nothing), at least enough to get through the unattended install.
        //**********************************************************************

        if (Intel810FoundStatus == TRUE)

            {
            hwDeviceExtension->DeviceMappingFailed = TRUE;

            ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
            ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
            ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;

            ConfigInfo->NumEmulatorAccessEntries     = 0;
            ConfigInfo->EmulatorAccessEntries        = NULL;
            ConfigInfo->EmulatorAccessEntriesContext = 0;

            ConfigInfo->HardwareStateSize = 0;

            *Again = 0;

            //******************************************************************
            // The only thing this function needed to do anyway
            // was to detect the presence of our chip
            //******************************************************************

            return NO_ERROR;
            }

        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Show all relevant Linear memory ranges to help debug
    //**************************************************************************

    VideoDebugPrint((0,"PMC = 0x%p \n", hwDeviceExtension->NV1_Lin_PMC_Registers));
    VideoDebugPrint((0,"PFB = 0x%p \n",hwDeviceExtension->NV1_Lin_PFB_Registers));
    VideoDebugPrint((0,"PRAMIN = 0x%p \n",hwDeviceExtension->NV3_Lin_PRAMIN_Registers));
    VideoDebugPrint((0,"PRAMFC = 0x%p \n",hwDeviceExtension->NV1_Lin_PRAMFC_Registers));
    VideoDebugPrint((0,"PRAMHT = 0x%p \n",hwDeviceExtension->NV1_Lin_PRAMHT_Registers));
    VideoDebugPrint((0,"PFIFO = 0x%p \n",hwDeviceExtension->NV1_Lin_PFIFO_Registers));
    VideoDebugPrint((0,"PBUS = 0x%p \n",hwDeviceExtension->NV1_Lin_PBUS_Registers));
    VideoDebugPrint((0,"PGRAPH = 0x%p \n",hwDeviceExtension->NV1_Lin_PGRAPH_Registers));
    VideoDebugPrint((0,"CONFIG = 0x%p \n",hwDeviceExtension->NV1_Lin_CONFIG_Registers));
    VideoDebugPrint((0,"PRAMDAC = 0x%p \n",hwDeviceExtension->NV3_Lin_PRAMDAC_Registers));
    VideoDebugPrint((0,"USERDAC = 0x%p \n",hwDeviceExtension->NV3_Lin_USERDAC_Registers));
    VideoDebugPrint((0,"PRMVIO = 0x%p \n",hwDeviceExtension->NV3_Lin_PRMVIO_Registers));
    VideoDebugPrint((0,"PRMCIO = 0x%p \n",hwDeviceExtension->NV3_Lin_PRMCIO_Registers));


#ifdef PC98

    //
    // POST the chip if we're running on a system with no VGA BIOS
    //
    NvPostEx(hwDeviceExtension);

#endif // PC98

    // initialize the RM device register mapping
    if (
        !RmInitNvMapping(
            (VOID*)hwDeviceExtension,
            hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart,
            hwDeviceExtension->NvRegisterBase,
            &hwDeviceExtension->DeviceReference
        )
    )
    {
        return ERROR_DEV_NOT_EXIST;
    }

    // We need to update the IRQ info as the RM has not done this
    {
       U032 oldValue;

       // Get the hals view of the IRQ line from the adapter
       VideoPortGetBusData(
            hwDeviceExtension,
            PCIConfiguration,
            NV1Slot,
            &pciData,
            0,
            PCI_COMMON_HDR_LENGTH
            );

       // Go ahead and set the mapping
       RmConfigSetKernel(hwDeviceExtension->DeviceReference, NV_CFG_IRQ,
                                   (ULONG)pciData.u.type0.InterruptLine, &oldValue);

    }

    //**************************************************************************
    // Flag to denote if adapter is NON primary (ie..device was not booted)
    //**************************************************************************

    hwDeviceExtension->NonPrimaryDevice = FALSE;


#if (_WIN32_WINNT >= 0x0500)

    // POST a non-primary device, if necessary
    VideoPortGetBusData(
        hwDeviceExtension,
        PCIConfiguration,
        NV1Slot,
        &pciData,
        0,
        PCI_COMMON_HDR_LENGTH
    );
#if defined(_WIN64)
    if (1)
#else
    if (
        !(pciData.Command & PCI_ENABLE_MEMORY_SPACE) ||
        !(pciData.Command & PCI_ENABLE_BUS_MASTER)
    )
#endif
    {
        VP_STATUS ntStatus = NO_ERROR;
        PHYSICAL_ADDRESS fbPhysAddr;
        ULONG qtyBytesSet, inIoSpace, fbLength;
        PVOID fbAddr;

        // enable the non-primary device on the PCI bus
        pciData.Command |= PCI_ENABLE_MEMORY_SPACE;
        pciData.Command |= PCI_ENABLE_BUS_MASTER;
        qtyBytesSet = VideoPortSetBusData(
            hwDeviceExtension,
            PCIConfiguration,
            NV1Slot,
            &pciData,
            0,
            PCI_COMMON_HDR_LENGTH
        );
        if (qtyBytesSet == 0)
        {
            return ERROR_INVALID_PARAMETER;
        }

        // hook up the HAL state now that the chip is accessible
        if (!RmInitNvHal(hwDeviceExtension->DeviceReference))
        {
            return ERROR_DEV_NOT_EXIST;
        }

        // create a large enuff temporary FB mapping to POST the device
        fbPhysAddr.HighPart = 0x00000000;
        fbPhysAddr.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
        fbPhysAddr.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;
        fbLength = 0x04000000 + BIOS_MEM_SIZE_ADJUST_FACTOR;
        inIoSpace = VIDEO_MEMORY_SPACE_P6CACHE;
        fbAddr = NULL;
        ntStatus = VideoPortMapMemory
        (
            hwDeviceExtension,
            fbPhysAddr,
            &fbLength,
            &inIoSpace,
            &fbAddr
        );
        if (ntStatus != NO_ERROR)
        {
            return ntStatus;
        }


        //**********************************************************************
        // Extract the BIOS image (64k) from either PROM or PRAMIN
        // (This function call behaves differently depending on whether
        // MEMORY_SPACE is set by VideoPortSetBusData)
        //**********************************************************************

        NVExtractBiosImage(hwDeviceExtension);


        // POST the device
        if (!RmPostNvDevice(hwDeviceExtension->DeviceReference, (PHWREG)(&(hwDeviceExtension->SavedBiosImageArray[0])), (PHWREG)fbAddr))
        {
            return ERROR_INVALID_PARAMETER;
        }

        // free up the temporary FB mapping
        VideoPortUnmapMemory(
            hwDeviceExtension,
            fbAddr,
            0
        );

    //**************************************************************************
    // If multiple adapters are present, do NOT invoke reset device
    //**************************************************************************

    MultiAdaptersPresent = TRUE;

    //**************************************************************************
    // Flag to denote if adapter is NON primary (ie..device was not booted)
    //**************************************************************************

    hwDeviceExtension->NonPrimaryDevice = TRUE;
    }
    else
    {
        // hook up the HAL state for the primary device
        if (!RmInitNvHal(hwDeviceExtension->DeviceReference))
        {
            return ERROR_DEV_NOT_EXIST;
        }
    }

    //**************************************************************************
    // If this is the PRIMARY adapter, we still need to save off the BIOS image
    // (ExtractBiosImage behaves differently, the BIOS image will be in PROM or PRAMIN)
    //**************************************************************************

    if (hwDeviceExtension->NonPrimaryDevice == FALSE)
        NVExtractBiosImage(hwDeviceExtension);
#else
    // hook up the HAL state for the primary device
    if (!RmInitNvHal(hwDeviceExtension->DeviceReference))
    {
        return ERROR_DEV_NOT_EXIST;
    }
#endif



    //**************************************************************************
    // Fill in NVInfo information structure
    //**************************************************************************

    if (NVGetNVInfo(hwDeviceExtension) == FALSE)
        return(ERROR_DEV_NOT_EXIST);        // Default to VGA if error getting info


    //
    // Store Memory Size
    //

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &(hwDeviceExtension->NvInfo.Framebuffer.RamSize),
                                   sizeof(ULONG));

    //
    // We have this so that the int10 will also work on the VGA also if we
    // use it in this driver.
    //

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;

    //**************************************************************************
    // Check the DisableVBLANK registry setting
    //**************************************************************************

    DisableVBlankFlag = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DisableVBlank",
                                       FALSE,
                                       NVRegistryCallback,
                                       NULL);

    if (DisableVBlankFlag == NO_ERROR)
        hwDeviceExtension->DisableVBlankFlag = TRUE;
    else
        hwDeviceExtension->DisableVBlankFlag = FALSE;

    //**************************************************************************
    // Check to see if VESA DMT monitor timings should be used
    //**************************************************************************
    hwDeviceExtension->bUseDMT = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DMTOVERRIDE",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bUseDMT));


    //**************************************************************************
    // Check to see if there is a GTF method requested by the user instead ( DMTOVERRIDE has priority)
    //**************************************************************************
    hwDeviceExtension->bUseGTF = FALSE;

    // Try and get some kind of monitor timing selection
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                           L"MonitorTiming",
                                           FALSE,
                                           NVReadMonitorTimingModeCallback,
                                           &(hwDeviceExtension->bUseGTF));


    // The DMT overide has priority
    if(hwDeviceExtension->bUseDMT) {
        hwDeviceExtension->bUseGTF = FALSE;
    }


    //**************************************************************************
    // Check to see if we should handle IF09 format video data.
    //**************************************************************************
    hwDeviceExtension->bEnableIF09 = TRUE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"IF09",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bEnableIF09));
#if _WIN32_WINNT < 0x0500
    //**************************************************************************
    // Check the EnableExtRefresh registry setting. If this is false or
    // not present we limit refresh rates to 85Hz.
    //**************************************************************************
    hwDeviceExtension->bExtRefreshDisable = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DisableExtRefresh",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bExtRefreshDisable));
#endif // #if _WIN32_WINNT < 0x0500

    //**************************************************************************
    // Check the Disable19x12Mode registry setting.
    //**************************************************************************
    hwDeviceExtension->bMax16x12 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Max16x12",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bMax16x12));

    hwDeviceExtension->bDisable19x12x32at60 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable19x12x32at60",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable19x12x32at60));

    hwDeviceExtension->bDisable16x12x32ge70 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable16x12x32ge70",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable16x12x32ge70));

    hwDeviceExtension->bDisable19x10x32ge70 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable19x10x32ge70",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable19x10x32ge70));


    //**************************************************************************
    // DellSwitch1 registry switch 1:
    //
    // 1) Add 1600x1024 modes 76hz for specific customers
    // 2) Also change 1920x1200 75Hz to 1920x1200 76Hz
    //**************************************************************************

    hwDeviceExtension->bDellSwitch1 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DellSwitch1",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDellSwitch1));


    //**************************************************************************
    // OGL Stencil registry switch
    //**************************************************************************

    hwDeviceExtension->OglStencilSwitch = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"OglStencil",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->OglStencilSwitch));

    //**************************************************************************
    // Force SW cursor registry switch
    //**************************************************************************

    hwDeviceExtension->ulForceSwCursor = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"ForceSwCursor",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->ulForceSwCursor));


    //**************************************************************************
    // This function is only meaningful for NV4 or better (uses newer RM modeset code)
    // It creates the list of available modes, depending on
    // what modes are available in vesadata.c, and what modes
    // are specified in the registry
    //**************************************************************************

    BuildAvailableModesTable(HwDeviceExtension);

    //**************************************************************************
    // This function is only meaningful for NV4 or better
    // If the NV registry switches are NOT present, then write them to the registry.
    // (Otherwise read the registry values).
    // Then load the registry values into the NT_NV_REGISTRY structure
    // so the miniport/display driver can get to them.
    //**************************************************************************

    LoadRegistrySettings(HwDeviceExtension);


    //**************************************************************************
    // ** MODE DATA FIXUP HACK **
    // The ModeTimingTable is normally a fixed STATIC data table.
    // We can't just ADD another refresh rate without some major changes.
    // So for now, just manually change the 1920x1200 75Hz timing to 1920x1200 76Hz
    // (Note: ValidateModes in nvmode.c also needs to be changed!)
    //
    // OEM Customer wants a SPECIFIC 76hz timing which is NOT GTF or DMT compliant.
    // So we'll accommodate them an use their specific timing....
    //**************************************************************************

    if (hwDeviceExtension->bDellSwitch1)
        {

// Standard GTF timing

//        ModeTimingTable[14*NUMBER_OF_RATES+3][0] = 2624;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][1] = 2064;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][2] = 2272;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][3] = 1253;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][4] = 1201;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][5] = 1204;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][6] = 24988;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][7] = 7600;

// OEM specific requested timing (for Wide Sony monitor)

        ModeTimingTable[14*NUMBER_OF_RATES+3][0] = 2584;
        ModeTimingTable[14*NUMBER_OF_RATES+3][1] = 1984;
        ModeTimingTable[14*NUMBER_OF_RATES+3][2] = 2240;
        ModeTimingTable[14*NUMBER_OF_RATES+3][3] = 1250;
        ModeTimingTable[14*NUMBER_OF_RATES+3][4] = 1203;
        ModeTimingTable[14*NUMBER_OF_RATES+3][5] = 1206;
        ModeTimingTable[14*NUMBER_OF_RATES+3][6] = 24548;
        ModeTimingTable[14*NUMBER_OF_RATES+3][7] = 7600;
        ModeTimingTable[14*NUMBER_OF_RATES+3][8] = BUFFER_HSYNC_NEGATIVE;
        ModeTimingTable[14*NUMBER_OF_RATES+3][9] = BUFFER_VSYNC_NEGATIVE;


        }


#if _WIN32_WINNT >= 0x0500
    //**************************************************************************
    // Determine if we should DISABLE AGP support (Default=ENABLE AGP support)
    //**************************************************************************
    status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       L"DisableAgp",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisableAgp));


#endif // #if _WIN32_WINNT >= 0x0500


#ifdef NVPE
    //**************************************************************************
    // Determine if we should DISABLE VPE (Video Port Extension that controls
    // the Media Port). Default is VPE Enabled !
    //**************************************************************************
    status = VideoPortGetRegistryParameters(
                hwDeviceExtension,
                L"VPEENABLE",
                FALSE,
                NVRegistryCallbackPnpId,
                (PVOID)(&(hwDeviceExtension->dwVPEEnabled)));
    if (status != NO_ERROR)
    {
       // most probably, we didn't find the VPEEnable key, so enable VPE by default !!!
       hwDeviceExtension->dwVPEEnabled = TRUE;
    }
#endif


    *Again = 0;

    //**************************************************************************
    // Indicate a successful completion status.
    //**************************************************************************

    return NO_ERROR;

    } // NVFindAdapter()


//******************************************************************************
//
// Function: NVInitialize()
//
// Routine Description:
//
//     This routine does one time initialization of the device.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's adapter information.
//
// Return Value:
//
//     None.
//
//******************************************************************************

BOOLEAN NVInitialize(
    PVOID HwDeviceExtension
    )


    {


    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG Status;


    //**************************************************************************
    // Check for unattended install with Intel 810.
    // If so, then just return true.
    //**************************************************************************

    if (hwDeviceExtension->DeviceMappingFailed == TRUE)
        return TRUE;

    //**************************************************************************
    // Map the frame buffer here, so the Resource Manager can also get access to it,
    // instead of enablehardware in the display driver.
    //**************************************************************************

    Status = NVMapFrameBuffer(hwDeviceExtension);
    if (Status != NO_ERROR)
        return(FALSE);

    //**************************************************************************
    // Set up the default cursor position and type.
    //**************************************************************************


    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    hwDeviceExtension->BiosArea = (PUSHORT)NULL;

    //***************************************************************************
    // Default to disabling write combining when mapping fb.
    //***************************************************************************
    hwDeviceExtension->flMapMemory = 0;

    //***************************************************************************
    // Initialize current power state.
    //***************************************************************************
    hwDeviceExtension->curPowerState = VideoPowerOn;

    //**************************************************************************
    // For NV3, instead of passing the Frame buffer pointer back to the RM,
    // we will ONLY map instance memory beginning at address = framebuffer + 12Mb
    // This is because , for NV3, the RM accesses instance memory using the 'frame buffer'
    // ptr, and it must NOT be write combined.  Essentially, for NV3, we map
    // the frame buffer (write combined) and give this to the display driver.
    // But we also map 4Mb of instance memory (NON write combined) and
    // give it to the resource manager.
    //
    //  FrameBufferPtr = WRITE COMBINED mapping of frame buffer
    //  FrameBufferBase = NON write combined mapping of framebuffer+12Mb
    //                    used to access instance memory
    //
    // This is DIFFERENT from NV4 !!
    //**************************************************************************

    SetGlobalHwDev(hwDeviceExtension);

    // One time initialization of the twinview structures.
    NVOneTimeInit_TwinView(hwDeviceExtension);




    //**************************************************************************
    // Make sure Non_primary monitor is alive, so that
    // dacConnectMonitorStatus in the RM will correctly detect the monitor!!
    // Only do this for NON primary devices.  Otherwise, the screen
    // will get garbled on the primary monitor.
    //**************************************************************************

    if (MultiAdaptersPresent == TRUE)
       if (hwDeviceExtension->NonPrimaryDevice == TRUE)
            WakeUpCard(hwDeviceExtension);


    // initialize the device
    if (
        !RmInitNvDevice(
            hwDeviceExtension->DeviceReference,
            hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart,
            hwDeviceExtension->FrameBufferBase
        )
    )
    {
        return FALSE;
    }

    // Detect the Head info and read in the EDIDs
    NVInitialize_DacsAndEDID(hwDeviceExtension);

    // One time initialization of the common mode set code fields.
    InitializeCommonModesetCode(hwDeviceExtension);

#ifdef ENABLE_RESMAN_ACPI_CODE
    // One time initialization of the mapping of power states from Win2K's states to nVidia's states.
    InitializeACPIStates(hwDeviceExtension);
#endif

    //**************************************************************************
    // Store BIOS revision string in the registry. This must be
    // done now since we need to call the RM to get the BIOS rev,
    // and the RM is not fully initialized at FindAdapter time.
    //**************************************************************************
    NVSetBiosInfo(hwDeviceExtension);

    //**************************************************************************
    // Get monitor info (TV out) into NVInfo struct
    //**************************************************************************
    NVGetMonitorType(hwDeviceExtension);

    //**************************************************************************
    // Get total amount of instance memory.
    // We need to save/restore all of instance memory across a Win2k standby
    //**************************************************************************

    RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_INSTANCE_TOTAL, &(hwDeviceExtension->TotalInstanceMemory));

#if 0
    if (hwDeviceExtension->TotalInstanceMemory > MAX_INSTANCE_MEM_SIZE)
        {
        VideoDebugPrint((0, "ERROR:  ----------------------------- !!!! "));
        VideoDebugPrint((0, "ERROR:  Need to increase size of      !!!! "));
        VideoDebugPrint((0, "ERROR:  SavedInstanceMemory buffer    !!!! "));
        VideoDebugPrint((0, "ERROR:  in HwDeviceExtension          !!!! "));
        VideoDebugPrint((0, "ERROR:  ----------------------------- !!!! "));
        }
#endif

    //**************************************************************************
    // Validate the modes.
    // This function call was originally in NVFindAdapter.
    // However, since it depends on the result of GetMonitorType,
    // (whether we're running on a TV or not), it needs to occur
    // AFTER GetMonitorType.
    //**************************************************************************

    NVValidateModes(hwDeviceExtension);

#if 0 // NUGOOP
#if (_WIN32_WINNT >= 0x0500) && (!defined(DISABLE_AGP))
    {
    //**************************************************************************
    // Check registry switch to see if we disabled AGP support
    //**************************************************************************

    if (hwDeviceExtension->bDisableAgp)
        goto Agp_Done;

    //**************************************************************************
    // Disable AGP if running on an ALI 1541 chipset
    //**************************************************************************

    if (hwDeviceExtension->AliChipset_Problem_Found)
        goto Agp_Done;

    hwDeviceExtension->AgpPagesTotal = ((MAX_AGP_HEAP + (PAGE_SIZE - 1)) &
                                            ~(PAGE_SIZE - 1)) / PAGE_SIZE;

    //***********************************************************
    // Determine if AGP memory is available.
    //***********************************************************
    hwDeviceExtension->bAgp =
        VideoPortGetAgpServices(hwDeviceExtension,
            &(hwDeviceExtension->AgpServices));
    }
Agp_Done:

    //**************************************************************************
    // If successful, let the RM know where the AGP services are
    //**************************************************************************
    if (hwDeviceExtension->bAgp)
    {
        RmSetAgpServices(hwDeviceExtension->DeviceReference,
                         &hwDeviceExtension->AgpServices);
    }

#endif // #if _WIN32_WINNT >= 0x0500
#endif

    {
      PVIDEO_CLUTDATA   pvcdItem;
      int i, iHead;

      VideoDebugPrint((1, "NVInitialize - Initializing the Gamma cache values to defaults\n"));

      // - Init the clut params
      hwDeviceExtension->GammaCache.NumEntries = 256;
          hwDeviceExtension->GammaCache.FirstEntry = 0;

                pvcdItem = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;

      // - Init the CLUT data to a default gamma ramp
      for(iHead = 0; iHead < NV_NO_DACS; iHead++)
      {
        for(i = 0; i < 256; i++) 
        {
            pvcdItem[i+iHead*256].Blue   = (UCHAR)i; /* blue value */
            pvcdItem[i+iHead*256].Green  = (UCHAR)i; /* green value */
            pvcdItem[i+iHead*256].Red    = (UCHAR)i; /* red value */
            pvcdItem[i+iHead*256].Unused = (UCHAR)0; /* unused value */
        }
      }

    }

   
    // To rid oursleves of some nasty visual effects when opening the panel when on a TV,
    // we need to stash the encoder status and type in the registry for later reference
    {
       NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
       ULONG TVEncoderType;
       ULONG TVEncoderID;

       // Assume that this adapter lacks a TV encoder 
       TVEncoderType = TV_ENCODER_NONE;
       TVEncoderID = 0;

       // Use head 0 for this case
       TVInfo.Head = 0;

       // Attemp the resman call for the encoder info...
       if(RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                              NV_CFGEX_GET_TV_ENCODER_INFO_MULTI, &TVInfo, 
                              sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS))) 
           
       {

            // We have a valid blob from the resman, so extract the encoder info
            TVEncoderType = TVInfo.EncoderType;
            TVEncoderID = TVInfo.EncoderID;

       }
       else
       {

          // The resman had issues with our request, so spew a warning
          VideoDebugPrint((0, "NVInitialize -  RmConfigGetExKernel() returned error for NV_CFGEX_GET_TV_ENCODER_INFO_MULTI\n"));
       }

       
       // No matter what the outcome above, flush the derived encoder values to the registry
      
       VideoPortSetRegistryParameters( HwDeviceExtension,
                                       L"TVEncoderType",
                                       &TVEncoderType,
                                       sizeof(ULONG));

       VideoPortSetRegistryParameters( HwDeviceExtension,
                                       L"TVEncoderID",
                                       &TVEncoderID,
                                       sizeof(ULONG));

    }
    

#if (_WIN32_WINNT >= 0x0500)
    // Initializing the macrovision
    hwDeviceExtension->ulCurrentMacrovisionKey = -1;
    hwDeviceExtension->ulNextMacrovisionKey = 0x99999999;
    hwDeviceExtension->ulMacrovisionMode = 3;
#endif
    return TRUE;

    } // NVInitialize()


//******************************************************************************
//
// Function: NVStartIO()
//
// Routine Description:
//
//    This routine is the main execution routine for the miniport driver. It
//    acceptss a Video Request Packet, performs the request, and then returns
//    with the appropriate status.
//
// Arguments:
//
//    HwDeviceExtension - Pointer to the miniport driver's adapter information.
//
//    RequestPacket - Pointer to the video request packet. This structure
//        contains all the parameters passed to the VideoIoControl function.
//
// Return Value:
//
//    This routine will return error codes from the various support routines
//    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
//    buffers and ERROR_INVALID_FUNCTION for unsupported functions.
//
//******************************************************************************


BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG byteLength;
    ULONG sharedViewSize;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    ULONG Address;
    PHYSICAL_ADDRESS NVFrameBuffer;
    PHYSICAL_ADDRESS AliFixupBaseAddress;
    ULONG IOLength;
    ULONG AliVirtualAddress;
    PHWINFO NVInfo;

    //**************************************************************************
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //**************************************************************************

    VideoDebugPrint((2, "W32StartIO Entry - %08.8x\n", RequestPacket->IoControlCode));

    switch (RequestPacket->IoControlCode) {

    //**************************************************************************
    // SHARE_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:


        VideoDebugPrint((2, "W32StartIO - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
            }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //**********************************************************************
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //**********************************************************************

        //**********************************************************************
        //
        // NOTE: AdapterMemorySize was adjusted in NVValidateModes
        //       to compensate for INSTANCE memory in offscreen memory.
        //       That is, Hash Table, Fifo Context, and Run Out information
        //       is stored in PRAMIN memory, which also exists in offscreen memory.
        //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
        //       To make a long story short, AdapterMemorySize was adjusted by
        //       64k in NVValidateModes (The last 64k of VRAM contains Instance memory).
        //       See NVValidateModes for more comments.
        //
        //       When sharing memory (for Direct X), we must make sure that
        //       we don't give anyone else access to the last 64k of offscreen VRAM.
        //       Otherwise, someone else may corrupt our instance memory.
        //**********************************************************************

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = 0;

        //**********************************************************************
        // NOTE: we are ignoring ViewOffset
        //**********************************************************************

        shareAddress.HighPart = 0x00000000;
        shareAddress.LowPart = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
        shareAddress.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;

        //**********************************************************************
        // Specifying virtualAddress = 0 will cause this address to be
        // mapped into the address space of the current process
        //**********************************************************************
        inIoSpace |= hwDeviceExtension->flMapMemory;
        status = VideoPortMapMemory(hwDeviceExtension,
                                    shareAddress,
                                    &sharedViewSize,
                                    &inIoSpace,
                                    &virtualAddress);

        pShareMemoryInformation = RequestPacket->OutputBuffer;

        //**********************************************************************
        // Returned shared virtual address to specific process
        //**********************************************************************

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        break;

    //**************************************************************************
    // UNSHARE_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "W32StartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;

    //**************************************************************************
    // QUERY_PUBLIC_ACCESS_RANGES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:


        VideoDebugPrint((1, "NVStartIO - Map W32 MMU or ACL\n"));

        //**********************************************************************
        // Currently, we'll be giving the display driver
        // public access to 5 ranges (in addition to the frame buffer)
        //
        //     1) User Channel
        //     2) Graphics Status register (to check for Engine Busy)
        //     3) Vertical Blank (PFB_CONFIG_0 register)
        //     4) Frame Buffer Start Address
        //     5) DAC Registers
        //
        // The Frame buffer is mapped separately in VIDEO_MAP_VIDEO_MEMORY
        //
        //
        // NV3: We also need access to the following memory ranges for NV3
        //      to access the cursor, vertical,miscellaneous registers
        //      which are different from NV1.
        //
        //     6) PRMCIO
        //     7) PRMVIO
        //     8) PRAMDAC
        //     9) PRAMIN (So we can get to the cursor image data)
        //     10) TEXTURE DATA (in System Memory)
        //     11) PGRAPH Registers
        //     12) DMA Buffer Area (Fixed/Locked contiguous memory)
        //     13) PFIFO Registers
        //
        //**********************************************************************

        if (RequestPacket->OutputBufferLength <
            13 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        else

            {
            PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
            PVOID                       base;
            ULONG                       ulIndex;

            //******************************************************************
            // Currently, we'll be giving the display driver
            // public access to 5 ranges (in addition to the frame buffer)
            //
            //     1) User Channel
            //     2) Graphics Status register (to check for Engine Busy)
            //     3) Vertical Blank (PFB_CONFIG_0 register)
            //     4) Frame Buffer Start Address
            //     5) DAC Registers
            //
            // The Frame buffer is mapped separately in VIDEO_MAP_VIDEO_MEMORY
            //
            //
            // NV3: We also need access to the following memory ranges for NV3
            //      to access the cursor,vertical,miscellaneous registers
            //      which are different from NV1.
            //
            //     6) PRMCIO
            //     7) PRMVIO
            //     8) PRAMDAC
            //     9) PRAMIN (So we can get to the cursor image data)
            //     10) TEXTURE DATA (in System Memory)
            //     11) PGRAPH Registers
            //
            //******************************************************************

            RequestPacket->StatusBlock->Information =
                12 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

            portAccess = RequestPacket->OutputBuffer;

            //******************************************************************
            // Map the NV user channel area (Treat it like Memory Mapped IO)
            //******************************************************************

            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

            //******************************************************************
            // We now use just 1 mapping to access ALL registers, and
            // just 1 mapping to access the framebuffer.  Display Driver,
            // miniport, and Resource Manager now use the same mappings!
            // See NVMapMemoryRanges() and NVMapFrameBuffer() for more info.
            //******************************************************************

            status = NO_ERROR;

            portAccess->VirtualAddress  = (PVOID)(hwDeviceExtension->NvRegisterBase);
            base                         = (PVOID)(hwDeviceExtension->NvRegisterBase);



//Map_PGRAPH_Status:

            //******************************************************************
            // Map the second range for the PGRAPH Status register
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset;

//Map_PFG_CONFIG_0:

            //******************************************************************
            // Map the third range for the PFB_CONFIG_0 register
            // (so we can check for vertical blanking)
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset;

//Map_PFB_Start_Address:

            //******************************************************************
            // Map the fourth range for the PFB_START_ADDRESS register
            // (so we can flip the current buffer)
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

//Map_DAC_Regs:

            //******************************************************************
            // Map the fifth range for the DACRegs memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;



//Map_PRMCIO_Regs:

            //******************************************************************
            // Map the sixth range for the NV3 PRMCIO memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;

            //******************************************************************
            // PRMCIO only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRMCIO_INDEX].ulOffset;


//Map_PRMVIO_Regs:

            //******************************************************************
            // Map the seventh range for the NV3 PRMVIO memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // PRMVIO only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRMVIO_INDEX].ulOffset;


//Map_PRAMDAC_Regs:

            //******************************************************************
            // Map the eighth range for the NV3 PRAMDAC memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // PRAMDAC only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRAMDAC_INDEX].ulOffset;


//Map_PRAMIN_Memory:

            //******************************************************************
            // Map the ninth range for the NV3 PRAMIN Instance Memory
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

//Map_Texture_Buffer:

            //******************************************************************
            // Map the Tenth range to contain information about
            // the texture buffer in system memory.
            // We'll use Virtual Address  -> Virtual Address
            //           InIoSpace        -> Physical Address
            //           MappedInIoSpace  -> Length of buffer
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = FALSE;



//Map_PGRAPH_Regs:
            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // Map the Eleventh range for the NV3 PGRAPH registers
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PGRAPH_INDEX].ulOffset;

//Map_PFIFO_Regs:
            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // Map the Twelfth range for the NV3 PFIFO registers
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PFIFO_INDEX].ulOffset;


//Map_NV3_DMA_Buffer_Area:

            //******************************************************************
            // Map the 13th range to contain information about
            // the DMA buffer in system memory.
            // We'll use Virtual Address  -> Virtual Address
            //           InIoSpace        -> Physical Address
            //           MappedInIoSpace  -> Length of buffer
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = FALSE;

            }

        break;

    //**************************************************************************
    // FREE_PUBLIC_ACCESS_RANGES
    //**************************************************************************

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:


        VideoDebugPrint((2, "NVStartIO - FreePublicAccessRanges\n"));

        {
        PVIDEO_MEMORY mappedMemory;
        ULONG i;

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        status = NO_ERROR;


        //******************************************************************
        // We now use just 1 mapping to access ALL registers, and
        // just 1 mapping to access the framebuffer.  Display Driver,
        // miniport, and Resource Manager now use the same mappings!
        // See NVMapMemoryRanges() and NVMapFrameBuffer() for more info.
        //
        // It never gets unmapped, and is always available
        //******************************************************************

        }

        break;

    //**************************************************************************
    // MAP_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "NVStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        //*********************************************************************
        // Make sure to set the VideoRamLength!
        //
        // NOTE: AdapterMemorySize was adjusted in NVValidateModes
        //       to compensate for INSTANCE memory in offscreen memory.
        //       That is, Hash Table, Fifo Context, and Run Out information
        //       is stored in PRAMIN memory, which also exists in offscreen memory.
        //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
        //       To make a long story short, AdapterMemorySize was adjusted by
        //       64k in NVValidateModes (The last 64k of VRAM contains Instance memory).
        //       See NVValidateModes for more comments.
        //
        //*********************************************************************

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        //*********************************************************************
        // Get the ptr to the NVInfo structure and initialize the video ram
        // length to be mapped.  DO NOT use hwDeviceExtension->AdapterMemorySize
        // because that value is NOT aligned on a MB boundary (it's adjusted to
        // exclude a portion of video memory).  Using that value would cause
        // the VideoPortMapMemory call to NOT correctly set write combining.
        // Use Framebuffer.RamSize instead !!!
        //*********************************************************************

        NVInfo = &(hwDeviceExtension->NvInfo);

        //**********************************************************************
        // Frame buffer is now mapped earlier, in NVMapFrameBuffer
        // So just return that mapping...Mapping is done in ONE place
        // ONLY, so the miniport, RM, and display driver can access it.
        // (No more multiple mappings of the frame buffer!)
        //**********************************************************************

        memoryInformation->FrameBufferBase = hwDeviceExtension->FrameBufferPtr;
        memoryInformation->FrameBufferLength = NVInfo->Framebuffer.RamSize;

        status = NO_ERROR;


        break;

    //**************************************************************************
    // UNMAP_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "NVStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        //**********************************************************************
        // Frame buffer is now mapped earlier, in NVMapFrameBuffer
        // It's mapped one time, and doesn't get unmapped
        //**********************************************************************

        status = NO_ERROR;

        break;

    //**************************************************************************
    // QUERY_AVAIL_MODES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "NVStartIO - QueryAvailableModes\n"));

        status = NVQueryAvailableModes(HwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // QUERY_NUM_AVAIL_MODES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "NVStartIO - QueryNumAvailableModes\n"));

        status = NVQueryNumberOfAvailableModes(HwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // QUERY_CURRENT_MODE
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "NVStartIO - QueryCurrentMode\n"));

        status = NVQueryCurrentMode(HwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // GET TIMING OF DAC at giving resolution
    //
    //**************************************************************************
    case IOCTL_VIDEO_GET_TIMING_DAC:
    {
        HEAD_RESOLUTION_INFO * pResolution;
        DAC_TIMING_VALUES * pTimingInfo;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(HEAD_RESOLUTION_INFO))
        {
            pResolution = (HEAD_RESOLUTION_INFO *) RequestPacket->InputBuffer;
            if(RequestPacket->OutputBufferLength == sizeof(DAC_TIMING_VALUES))
            {
                pTimingInfo = (DAC_TIMING_VALUES *) RequestPacket->OutputBuffer;
                if(NVGetTimingForDac(hwDeviceExtension, pResolution, pTimingInfo))
                {
                    RequestPacket->StatusBlock->Information = sizeof(DAC_TIMING_VALUES);
                    status = NO_ERROR;
                }
            }
        }
    }

    break;

    //**************************************************************************
    // Call RM before set mdoe
    //
    //**************************************************************************
    case IOCTL_VIDEO_PREMODE_SET:
    {
        ULONG * pulHead;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(ULONG))
        {
            pulHead = (ULONG *) RequestPacket->InputBuffer;
            if(RmPreModeSet(hwDeviceExtension->DeviceReference, *pulHead))
            {
                    status = NO_ERROR;
            }
        }


    }
    break;

    //**************************************************************************
    // Call RM after set mdoe
    //
    //**************************************************************************
    case IOCTL_VIDEO_POSTMODE_SET:
    {
        ULONG * pulHead;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(ULONG))
        {
            pulHead = (ULONG *) RequestPacket->InputBuffer;
            if(RmPostModeSet(hwDeviceExtension->DeviceReference, *pulHead))
            {
                    status = NO_ERROR;

            }

        }


    }
    break;

    //**************************************************************************
    // Setup Virtual Desktop information
    //**************************************************************************
    case IOCTL_VIDEO_SET_DESKTOP_INFO_MODE:
        {
            NV_DESKTOP_INFO * pDeskTop;
            ULONG i;

            if(RequestPacket->InputBufferLength == sizeof(NV_DESKTOP_INFO))
            {
                pDeskTop = (NV_DESKTOP_INFO *) RequestPacket->InputBuffer;
                hwDeviceExtension->DeskTopInfo.ulDesktopModeIndex = pDeskTop->ulDesktopModeIndex;

                hwDeviceExtension->DeskTopInfo.ulDesktopMode = pDeskTop->ulDesktopMode;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard = pDeskTop->ulNumberDacsOnBoard;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = pDeskTop->ulNumberDacsConnected;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsActive = pDeskTop->ulNumberDacsActive;

                hwDeviceExtension->DeskTopInfo.ulDesktopWidth = pDeskTop->ulDesktopWidth;
                hwDeviceExtension->DeskTopInfo.ulDesktopHeight = pDeskTop->ulDesktopHeight;

                hwDeviceExtension->DeskTopInfo.ulAllDeviceMask = pDeskTop->ulAllDeviceMask;
                hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask = pDeskTop->ulConnectedDeviceMask;

                for(i = 0; i < NV_NO_DACS; i++)
                {
                    hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i] = pDeskTop->ulDisplayWidth[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i] = pDeskTop->ulDisplayHeight[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayRefresh[i] = pDeskTop->ulDisplayRefresh[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayPixelDepth[i] = pDeskTop->ulDisplayPixelDepth[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i] = pDeskTop->ulDeviceDisplay[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceMask[i] = pDeskTop->ulDeviceMask[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceType[i] = pDeskTop->ulDeviceType[i];
                    hwDeviceExtension->DeskTopInfo.ulTVFormat[i] = pDeskTop->ulTVFormat[i];
                }

                // TODO ...  
                // Display driver already checks this; Miniport driver should double check ??
                // Should call RM to check dual head support
                if(1)
                    *((BOOLEAN *) RequestPacket->OutputBuffer) =  TRUE ;
                else
                    *((BOOLEAN *) RequestPacket->OutputBuffer) =  FALSE ;

                RequestPacket->StatusBlock->Information = sizeof(BOOLEAN);
                status = NO_ERROR;
                break;
            }
            else
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_DESKTOP_DISPLAY_MODE - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        }

        break;

    

    //**************************************************************************
    // SET_CURRENT_MODE
    //**************************************************************************

        case IOCTL_VIDEO_SET_CURRENT_MODE:


        VideoDebugPrint((2, "NVStartIO - SetCurrentModes\n"));

        // Call the RM to enable hot key functionality
        RmSetDriverHotkeyHandling(hwDeviceExtension->DeviceReference, TRUE);


        status = NVSetMode(HwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);

        //******************************************************************************
        // Did caller ask if we supported hw video overlay?
        //******************************************************************************
        if (RequestPacket->OutputBufferLength  == sizeof(BOOLEAN))
            {
            //******************************************************************************
            // return whether or hw video overlay is supported in the current mode.
            //******************************************************************************
            *((BOOLEAN *) RequestPacket->OutputBuffer) = hwDeviceExtension->bHwVidOvl;
            RequestPacket->StatusBlock->Information = sizeof(BOOLEAN);
            }


// removed hard coded status....

        //
        // Refresh gamma clut after modeset
        //
        // Update the gamma concept if we are not on an NV3
        if( !(hwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
        {

            VideoDebugPrint((2, "IOCTL_VIDEO_SET_CURRENT_MODE - Updating gamma registers\n"));

                // We need to make sure that we wait for the vblank interrupt handler to run at least once before
                // we update the gamma values, as the handler will also write out the values in the dac.gamma table
                // and clobber anything that we have written.  This is very backdoor, and should be handled in a more
                // proper way, say by letting the vblank code update these for us by letting it know what we want.


            if(hwDeviceExtension->ulChipID != NV3_DEVICE_NV3_ID)
            {
               U032   StartVBlank,CurrentVBlank;

               // Do this: Get some vblank count and wait for it to change

               // Get the first relative start value
               if(RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_VBLANK_COUNTER, &CurrentVBlank)) {

                  StartVBlank = CurrentVBlank;
                  while(CurrentVBlank == StartVBlank) {    // Wait till they are different
                        if(!RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_VBLANK_COUNTER, &CurrentVBlank)) {
                           CurrentVBlank = StartVBlank + 1;   // This is how we break out of here if the RM fails
                        }
                  }
               }

                NV_SetPixMixBits(HwDeviceExtension);

                NVSetColorLookup(HwDeviceExtension,
                            (PVIDEO_CLUT) &hwDeviceExtension->GammaCache,
                            MAX_CLUT_SIZE);
            }
        }

        //**************************************************************************
        //
        // We need to let the control panel know that the modeset has occurred.
        // For example, in TwinView configuration, NT4.0/Win2K sometimes ignores a 
        // modeset request for the same mode even though we could be changing the mode
        // from normal to clone, but with the same resolution.
        // nVidia control sets this registry entry to 0, calls Win2K to do a modeset
        // and then tests this registry entry to see if the display driver actually
        // was called or not.
        //
        //**************************************************************************

        {
          ULONG NvCplModeSetHasOccurred;
    
          NvCplModeSetHasOccurred = 1;

          VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"NvCplModeSetHasOccurred",
                                      &NvCplModeSetHasOccurred,
                                      sizeof(ULONG));
        }
        break;

    //**************************************************************************
    // RESET_DEVICE
    //**************************************************************************

    case IOCTL_VIDEO_RESET_DEVICE:

        // Clean up virtual desktop flag.
        hwDeviceExtension->DeskTopInfo.ulDesktopMode = 0;

        VideoDebugPrint((2, "NVStartIO - Reset Device\n"));

        status = NO_ERROR;

        // Call the RM to disable hot key functionality
        RmSetDriverHotkeyHandling(hwDeviceExtension->DeviceReference, FALSE);

        if(hwDeviceExtension->ulRmTurnedOffMonitor)
        {
            // PowerManagement turn off the monitor 
            // It is not necessary to call BIOS to reset the chip
            break;
        }


#ifdef  NT_BUILD_NV4
        // Reset the head to 0 because BIOS and VGA do not understand the multi-heads
        RmEnableHead(hwDeviceExtension->DeviceReference, 0);
#endif
        //**********************************************************************
        // Must *NOT* call Int10 in a multiple adapter configuration
        //**********************************************************************

        if (MultiAdaptersPresent == FALSE)
            {
            //******************************************************************
            // Make sure that NV interrupts are disabled before we call Int10!!!
            // Otherwise, there may be conflicts writing to the hardware registers
            // (especially in an SMP system)
            //******************************************************************

            NV_DisableNVInterrupts(hwDeviceExtension);


#if _WIN32_WINNT < 0x0500

            //******************************************************************
            // For NT4, do a 'manual' text modeset for NV10 ONLY
            // We won't call the BIOS.
            //******************************************************************

            if ((hwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
                (hwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
                (hwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
                (hwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
                (hwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
                (hwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
                (hwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
                (hwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
                (hwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
                (hwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
                (hwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
                (hwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
                (hwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
                (hwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
                (hwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID) )
                {
                NV_ManualTextModeSet(hwDeviceExtension);
                }

            else

            //******************************************************************
            // For NT4, use Int10 if NOT an NV10  (ie nv3,nv4,nv5,vanta,m64)
            //******************************************************************

                {
                VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
                biosArguments.Eax = 0x0003;
                status = VideoPortInt10(hwDeviceExtension,&biosArguments);
                if (status != NO_ERROR)
                    VideoDebugPrint((0, "NV: IOCTL_VIDEO_RESET_DEVICE FAILED\n"));
                }

#else

            //******************************************************************
            // For Win2k, always use Int10
            //******************************************************************

            VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
            biosArguments.Eax = 0x0003;
            status = VideoPortInt10(hwDeviceExtension,&biosArguments);
            if (status != NO_ERROR)
                VideoDebugPrint((0, "NV: IOCTL_VIDEO_RESET_DEVICE FAILED\n"));

#endif

            //******************************************************************
            // Turn NV interrupts back on
            //******************************************************************

            NV_ReEnableNVInterrupts(hwDeviceExtension);
            }


        break;

    //**************************************************************************
    // SET_COLOR_REGISTERS
    //**************************************************************************

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "NVStartIO - SetColorRegs\n"));

        status = NVSetColorLookup(HwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);


// Initialize this adapters CLUT to the requested gamma ramp
   {

      PVIDEO_CLUTDATA   pvcdItemSrc,pvcdItemDst;
      PVIDEO_CLUT       srcclut;
      ULONG index,item,NumEntries,FirstEntry;

      VideoDebugPrint((1, "IOCTL_VIDEO_SET_COLOR_REGISTERS - Saving gamma mods in gammacache\n"));

      // - Make things nice to look at
          pvcdItemSrc = &(((PVIDEO_CLUT)RequestPacket->InputBuffer)->LookupTable->RgbArray);
          pvcdItemDst = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
      srcclut = (PVIDEO_CLUT)RequestPacket->InputBuffer;

      // - Set the limits on the item count
      NumEntries = srcclut->NumEntries;
      FirstEntry = srcclut->FirstEntry;

      // - Copy over the gamma data
      for(item = FirstEntry; item < NumEntries; item++) {
           index = item + FirstEntry;
           pvcdItemDst[index].Blue   = pvcdItemSrc[index].Blue;
           pvcdItemDst[index].Green  = pvcdItemSrc[index].Green;
           pvcdItemDst[index].Red    = pvcdItemSrc[index].Red;
           pvcdItemDst[index].Unused = pvcdItemSrc[index].Unused;
      }

    }

        break;

    //**************************************************************************
    // Enable the PIXMIX bits in NV_PRAMDAC_GENERAL_CONTROL
    //**************************************************************************
    case IOCTL_VIDEO_ENABLE_PIXMIX_INDEX:
            //
            //      Set PIXMIX bits to 11b
            //
            NV_SetPixMixBits(HwDeviceExtension);

            status = NO_ERROR;
            break;

    //**************************************************************************
    // ENABLE_VDM
    // Do we need to implement this call ??
    // We'll need to implement ResetDevice because we'll be using VgaCompatible=0
    //**************************************************************************

    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "NVStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;

    //**************************************************************************
    // Private IOCTLs established with the driver
    //**************************************************************************


    //**************************************************************************
    // GET_VIDEO_CARD_INFO
    // This call is unnecessary , we don't do banking
    //**************************************************************************

    case IOCTL_VIDEO_GET_VIDEO_CARD_INFO:

        VideoDebugPrint((2, "NVStartIO - Get video card info\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(VIDEO_COPROCESSOR_INFORMATION)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        // return the Coproc Base Address.

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulChipID =
            hwDeviceExtension->ulChipID;

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulRevLevel =
            hwDeviceExtension->ulRevLevel;

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulVideoMemory =
            hwDeviceExtension->AdapterMemorySize;

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI:

        VideoDebugPrint((2, "NVStartIO - Map IO port for ALI\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }
        RequestPacket->StatusBlock->Information = sizeof(VIDEO_MEMORY_INFORMATION);


        memoryInformation = RequestPacket->OutputBuffer;
        memoryInformation->FrameBufferBase   = 0;
        memoryInformation->FrameBufferLength = FALSE;
        hwDeviceExtension->AliFixupIOBase    = NULL;

        //**********************************************************************
        // This code is ONLY necessary for the ALI 1541 chipset
        //**********************************************************************

        if (hwDeviceExtension->AliChipset_Problem_Found == TRUE)
            {
            //******************************************************************
            // Setup to map an IO register
            //******************************************************************

            AliFixupBaseAddress.HighPart = 0x00000000;
            AliFixupBaseAddress.LowPart  = 0x000003d0;
            IOLength            = 4;
            inIoSpace           = TRUE;
            AliVirtualAddress   = 0;

            //******************************************************************
            // Map the IO port, and pass it back to the display driver
            //******************************************************************

            status = VideoPortMapMemory(hwDeviceExtension,
                                     AliFixupBaseAddress,
                                     &(IOLength),
                                     &(inIoSpace),
                                     (PVOID)&(AliVirtualAddress));

            memoryInformation->FrameBufferBase   = (PVOID)AliVirtualAddress;
            memoryInformation->FrameBufferLength = TRUE;
            hwDeviceExtension->AliFixupIOBase    = (PVOID)AliVirtualAddress;
            }



        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI:

        VideoDebugPrint((2, "NVStartIO - Free mapping for IO port \n"));

        //**********************************************************************
        // This code is ONLY necessary for the ALI 1541 chipset
        //**********************************************************************

        if (hwDeviceExtension->AliChipset_Problem_Found == TRUE)
            {

            //******************************************************************
            // Free up the mapping for the IO port
            //******************************************************************

            if (hwDeviceExtension->AliFixupIOBase !=NULL)
                {
                status = VideoPortUnmapMemory(hwDeviceExtension,
                                         hwDeviceExtension->AliFixupIOBase,
                                         0);
                }

            hwDeviceExtension->AliFixupIOBase = NULL;
            }


        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_MAP_NV_PFIFO_USER:
        {
        PHYSICAL_ADDRESS            base, pa;
        ULONG                       length;

        VideoDebugPrint((2, "NVStartIO - Map PFIFO User\n"));

        if (RequestPacket->OutputBufferLength < sizeof(ULONG) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        //**********************************************************************
        // Return mapping to PFIFO registers in user address space
        //**********************************************************************

        virtualAddress = (PVOID)0L;

        //******************************************************************
        // Get physical base address again (since we modified it up above
        // for the PFIFO registers
        //******************************************************************

        base = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart;

        //**************************************************************
        // Call VideoPort to map the range for us
        //**************************************************************

        pa          = base;
        pa.HighPart = 0x00000000;
        pa.LowPart  += RangeOffsets[NV_PFIFO_INDEX].ulOffset;
        sharedViewSize = RangeOffsets[NV_PFIFO_INDEX].ulLength;

        NVMapPhysIntoUserSpace(pa, sharedViewSize, &virtualAddress);
        *(PVOID *)RequestPacket->OutputBuffer = virtualAddress;
        RequestPacket->StatusBlock->Information = sizeof(PVOID);

        status = NO_ERROR;

        }
        break;

    case IOCTL_VIDEO_ENABLE_WRITE_COMBINING:

        VideoDebugPrint((2, "NVStartIO - VIDEO_ENABLE_WRITE_COMBINING\n"));

        //**********************************************************************
        // Set flags to enable fb write combining.
        //**********************************************************************
        hwDeviceExtension->flMapMemory |= VIDEO_MEMORY_SPACE_P6CACHE;
        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO:

        VideoDebugPrint((2, "NVStartIO - Return TV cursor adjustment values\n"));

        if (RequestPacket->OutputBufferLength < sizeof(TV_CURSOR_ADJUST_INFO) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        //**********************************************************************
        // Return information about our DMA buffer
        //**********************************************************************

        RequestPacket->StatusBlock->Information = sizeof(TV_CURSOR_ADJUST_INFO);

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->MonitorType =
                                  hwDeviceExtension->NvInfo.Framebuffer.MonitorType;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Underscan_x =
                                  hwDeviceExtension->NvInfo.Framebuffer.Underscan_x;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Underscan_y =
                                  hwDeviceExtension->NvInfo.Framebuffer.Underscan_y;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Scale_x =
                                  hwDeviceExtension->NvInfo.Framebuffer.Scale_x;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Scale_y =
                                  hwDeviceExtension->NvInfo.Framebuffer.Scale_y;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->FilterEnable =
                                  hwDeviceExtension->NvInfo.Framebuffer.FilterEnable;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->TVCursorMin =
                                  hwDeviceExtension->NvInfo.Dac.TVCursorMin;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->TVCursorMax =
                                  hwDeviceExtension->NvInfo.Dac.TVCursorMax;

        status = NO_ERROR;

        break;

    //**************************************************************************
    // GET_IF09_VIDEO_SUPPORT
    //**************************************************************************

    case IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT\n"));

        //******************************************************************************
        // Should we support IF09 format video data?
        //******************************************************************************
        if (RequestPacket->OutputBufferLength  == sizeof(ULONG))
            {
            //******************************************************************************
            // return whether or IF09 format video data should be supported.
            //******************************************************************************
            *((ULONG *) RequestPacket->OutputBuffer) = hwDeviceExtension->bEnableIF09;
            RequestPacket->StatusBlock->Information = sizeof(ULONG);
            status = NO_ERROR;
            }
        else
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        break;

    //**************************************************************************
    // GET_DEVICE_REF
    //**************************************************************************

    case IOCTL_VIDEO_GET_DEVICE_REF:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_DEVICE_REF\n"));

        if (RequestPacket->OutputBufferLength  == sizeof(ULONG))
        {
            *((ULONG *) RequestPacket->OutputBuffer) = hwDeviceExtension->DeviceReference;
            RequestPacket->StatusBlock->Information = sizeof(ULONG);
            status = NO_ERROR;
        }
        else
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        break;

    //**************************************************************************
    // GET_OGL_STENCIL_SWITCH
    //**************************************************************************

    case IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH\n"));

        if (RequestPacket->OutputBufferLength  == sizeof(ULONG))
        {
            *((ULONG *) RequestPacket->OutputBuffer) = hwDeviceExtension->OglStencilSwitch;
            RequestPacket->StatusBlock->Information = sizeof(ULONG);
            status = NO_ERROR;
        }
        else
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        break;


    //**********************************************************************************
    // The following IOCTLs allow communication between the display driver and the RM
    //**********************************************************************************

    //****CHECK FOR ERROR_INSUFFICIENT_BUFFER here

    // MP/RM merge...

    // TO DO: remove open and close
    // open and close are here for compatibility
    case NVAPI_IOCTL_OPEN:
        status = NO_ERROR;
        break;

    case NVAPI_IOCTL_CLOSE:
        status = NO_ERROR;
        break;

    case IOCTL_NV01_ALLOC_ROOT:
        Nv01AllocRoot((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_DEVICE:
        Nv01AllocDevice((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_CONTEXT_DMA:
        Nv01AllocContextDma((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_CHANNEL_PIO:
        Nv01AllocChannelPio((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV03_ALLOC_CHANNEL_DMA:
        Nv03AllocChannelDma((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_MEMORY:
        Nv01AllocMemory((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_OBJECT:
        Nv01AllocObject((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_EVENT:
        Nv01AllocEvent((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_ALLOC:
        Nv04Alloc((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_FREE:
        Nv01Free((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV03_DMA_FLOW_CONTROL:
        Nv03DmaFlowControl((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ARCH_HEAP:
        Nv03ArchHeap((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_VERSION:
        Nv01ConfigVersion((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_GET:
        Nv01ConfigGet((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_SET:
        Nv01ConfigSet((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_CONFIG_GET_EX:
        Nv04ConfigGetEx((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_CONFIG_SET_EX:
        Nv04ConfigSetEx((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_UPDATE:
        Nv01ConfigUpdate((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_DEBUG_CONTROL:
        Nv01DebugControl((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_DIRECT_METHOD_CALL:
        Nv04DirectMethodCall((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

        //...jsw

    case IOCTL_NV04_I2C_ACCESS:
         {
            NVOS_I2C_ACCESS_PARAMS *i2cparams;

            i2cparams = (NVOS_I2C_ACCESS_PARAMS *)RequestPacket->InputBuffer;

            // Make sure that the data handed us is within limits
            if( (RequestPacket->InputBufferLength  < sizeof(NVOS_I2C_ACCESS_PARAMS)) ||
                (RequestPacket->OutputBufferLength < sizeof(NVOS_I2C_ACCESS_PARAMS)) ){

               status = ERROR_INSUFFICIENT_BUFFER;
               RequestPacket->StatusBlock->Information = 0;
            }
            else {

               // Have the RM help us with this one...
               Nv04I2CAccess((NVOS_I2C_ACCESS_PARAMS *)i2cparams);

               // Make sure that we only give back the right amount
               RequestPacket->StatusBlock->Information = sizeof(NVOS_I2C_ACCESS_PARAMS);
               status = NO_ERROR;
            }
         }
        break;


    //**************************************************************************
    // SYSMEM_SHARE_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SYSMEM_SHARE_MEMORY:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SYSMEM_SHARE_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        NvSystemMemoryShare(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;

        pSysmemShareMemoryOut->pSystemMdl       = pSysmemShareMemoryIn->pSystemMdl;
        pSysmemShareMemoryOut->physicalAddress  = pSysmemShareMemoryIn->physicalAddress;
        pSysmemShareMemoryOut->ddVirtualAddress = pSysmemShareMemoryIn->ddVirtualAddress;
        pSysmemShareMemoryOut->byteLength       = pSysmemShareMemoryIn->byteLength;

        VideoDebugPrint((0, "SHARE: pSystemMdl = 0x%p\n",
                        pSysmemShareMemoryOut->pSystemMdl));
        VideoDebugPrint((0, "SHARE: physicalAddress = 0x%p\n",
                        pSysmemShareMemoryOut->physicalAddress));
        VideoDebugPrint((0, "SHARE: ddVirtualAddress = 0x%p\n",
                        pSysmemShareMemoryOut->ddVirtualAddress));

        status = NO_ERROR;

        }
        break;

    //**************************************************************************
    // SYSMEM_UNSHARE_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn;

        if (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        VideoDebugPrint((0, "UNSHARE: pSystemMdl = 0x%p\n",
                        pSysmemShareMemoryIn->pSystemMdl));
        VideoDebugPrint((0, "UNSHARE: ddVirtualAddress = 0x%p\n",
                        pSysmemShareMemoryIn->ddVirtualAddress));
        NvSystemMemoryUnShare(pSysmemShareMemoryIn);
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // LOCK_DOWN_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_LOCK_DOWN_MEMORY:
        {
        NV_LOCK_DOWN_MEMORY *pLockdownMemoryIn = NULL;
        NV_LOCK_DOWN_MEMORY *pLockdownMemoryOut = NULL;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_LOCK_DOWN_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_LOCK_DOWN_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_LOCK_DOWN_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pLockdownMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_LOCK_DOWN_MEMORY);
        NvLockdownMemory(pLockdownMemoryIn);
        if (pLockdownMemoryIn->pMdl == NULL)
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_LOCK_DOWN_MEMORY - Fails lock - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pLockdownMemoryOut = RequestPacket->OutputBuffer;
        pLockdownMemoryOut->pMdl           = pLockdownMemoryIn->pMdl;
        pLockdownMemoryOut->virtualAddress = pLockdownMemoryIn->virtualAddress;
        pLockdownMemoryOut->byteLength     = pLockdownMemoryIn->byteLength;

        VideoDebugPrint((0, "LOCKDOWN: virtualAddress = 0x%p\n",
                        pLockdownMemoryOut->virtualAddress));
        VideoDebugPrint((0, "LOCKDOWN: pMdl = 0x%p\n",
                        pLockdownMemoryOut->pMdl));
        status = NO_ERROR;

        VideoDebugPrint((2, "W32StartIO - LockDownMemory Exit\n"));
        }
        break;

    //**************************************************************************
    // UNLOCK_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNLOCK_MEMORY:
        {
        NV_UNLOCK_MEMORY *pUnlockMemoryIn = NULL;
        NV_UNLOCK_MEMORY *pUnlockMemoryOut = NULL;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_UNLOCK_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_UNLOCK_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_UNLOCK_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pUnlockMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_UNLOCK_MEMORY);
        NvUnlockMemory(pUnlockMemoryIn);
        pUnlockMemoryOut = RequestPacket->OutputBuffer;
        pUnlockMemoryOut->pMdl = pUnlockMemoryIn->pMdl;
        VideoDebugPrint((0, "UNLOCK: pMdl = 0x%p\n", pUnlockMemoryOut->pMdl));
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // MAP_TO_USER
    //**************************************************************************

    case IOCTL_VIDEO_MAP_TO_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_MAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->ddVirtualAddress points to kernel address which may be locked down
        // pSysmemShareMemoryIn->byteLength points to length of kernel address memory
        NvMapIntoUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        pSysmemShareMemoryOut->userVirtualAddress = pSysmemShareMemoryIn->userVirtualAddress;
        pSysmemShareMemoryOut->physicalAddress    = pSysmemShareMemoryIn->physicalAddress;
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // UNMAP_FROM_USER
    //**************************************************************************

    case IOCTL_VIDEO_UNMAP_FROM_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_MAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->pSystemMdl points to previously allocated MDL
        NvUnmapFromUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        status = NO_ERROR;
        }
        break;


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // NT5 only !
    // IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS
    //**************************************************************************

    case IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS:

        VideoDebugPrint((2, "NVStartIO - IOCTL Handle Video Parameters\n"));

        status = ERROR_INVALID_FUNCTION;
        
        if( (RequestPacket->InputBufferLength  == sizeof(VIDEOPARAMETERS) ) &&
            (RequestPacket->OutputBufferLength == sizeof(VIDEOPARAMETERS) ) )
        {
            VIDEOPARAMETERS * pInVideoParameters  = (VIDEOPARAMETERS *) RequestPacket->InputBuffer;
            VIDEOPARAMETERS * pOutVideoParameters = (VIDEOPARAMETERS *) RequestPacket->OutputBuffer;
            ULONG i, dwTemp;
            NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS nvEncoder;

            switch(pInVideoParameters->dwCommand)
            {
                case VP_COMMAND_GET:
                {
                    pOutVideoParameters->dwMode = VP_MODE_WIN_GRAPHICS;
                    pOutVideoParameters->dwFlags = 0;
                    pOutVideoParameters->dwTVStandard = 0;
            
                    for(i = 0; i < hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
                    {
                        if( (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC) ||
                            (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_PAL) )
                        {
                            pOutVideoParameters->dwFlags  = VP_FLAGS_TV_MODE;
                            pOutVideoParameters->dwFlags |= VP_FLAGS_TV_STANDARD;
                            if(hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC)
                            {
                                pOutVideoParameters->dwTVStandard = pOutVideoParameters->dwAvailableTVStandard 
                                    = VP_TV_STANDARD_NTSC_M;
                            }
                            else
                            {
                                pOutVideoParameters->dwTVStandard = pOutVideoParameters->dwAvailableTVStandard
                                    = VP_TV_STANDARD_PAL_B;
                            }

                            pOutVideoParameters->dwAvailableModes = VP_MODE_WIN_GRAPHICS;
            
                            pOutVideoParameters->dwFlags |= VP_FLAGS_MAX_UNSCALED;
                            pOutVideoParameters->dwMaxUnscaledX = hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i];
                            pOutVideoParameters->dwMaxUnscaledY = hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i];
            
                            pOutVideoParameters->dwFlags |= VP_FLAGS_POSITION;
                            pOutVideoParameters->dwPositionX = 0;
                            pOutVideoParameters->dwPositionY = 0;
            
                            pOutVideoParameters->dwCPType = 0;
                            pOutVideoParameters->dwCPStandard = 0;
            
                            nvEncoder.Head = i;
                            RmConfigGetExKernel(hwDeviceExtension->DeviceReference, NV_CFGEX_VIDEO_ENCODER_TYPE, &nvEncoder, sizeof(NV_CFGEX_VIDEO_ENCODER_TYPE));
                            switch(nvEncoder.EncoderType)
                            {
                                case NV_ENCODER_BROOKTREE_868:
                                case NV_ENCODER_CHRONTEL_7003:
                                case NV_ENCODER_CHRONTEL_7006:
                                case NV_ENCODER_CHRONTEL_7008:
                                    // Not macrovision support
                                    break;
                                default:
                                    // macrovision support
                                    pOutVideoParameters->dwFlags |= VP_FLAGS_COPYPROTECT;
                                    pOutVideoParameters->dwCPType = VP_CP_TYPE_APS_TRIGGER;
                                    pOutVideoParameters->bCP_APSTriggerBits = hwDeviceExtension->ulMacrovisionMode; 
                                    switch(hwDeviceExtension->DeskTopInfo.ulTVFormat[i])
                                    {
                                        case NTSC_M:
                                            dwTemp = VP_TV_STANDARD_NTSC_M;
                                        break;
                                        case NTSC_J:
                                            dwTemp = VP_TV_STANDARD_NTSC_M_J;
                                        break;
                                        case PAL_M:
                                            dwTemp = VP_TV_STANDARD_PAL_M;
                                        break;
                                        case PAL_A:
                                            dwTemp = VP_TV_STANDARD_PAL_B | VP_TV_STANDARD_PAL_D | VP_TV_STANDARD_PAL_G |
                                                 VP_TV_STANDARD_PAL_H | VP_TV_STANDARD_PAL_I;
                                        break;
                                        case PAL_N:
                                            dwTemp = VP_TV_STANDARD_PAL_N;
                                        break;
                                        case PAL_NC:
                                        default:
                                            dwTemp = VP_TV_STANDARD_WIN_VGA;
                                        break;
                                    }
                                    pOutVideoParameters->dwCPStandard = dwTemp;
                                    break;
                                break;
                            }
                            break;
                        } // if
                    } // for
                    RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
                    VideoDebugPrint((0, "NVStartIO - IOCTL Handle Video Parameters Get dwCommand \n"));
                    status = NO_ERROR;
                    break;
                }
                case VP_COMMAND_SET:
                {
                    if((pInVideoParameters->dwFlags  &  VP_FLAGS_COPYPROTECT) &&
                       (pInVideoParameters->dwCPType == VP_CP_TYPE_APS_TRIGGER) )
                    {
                        NV_CFGEX_SET_MACROVISION_MODE_PARAMS nvMacrovision;

                        memcpy((PUCHAR) pOutVideoParameters, (PUCHAR) pInVideoParameters, sizeof(VIDEOPARAMETERS));
                        for(i = 0; i < hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
                        {
                            if( (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC) ||
                                (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_PAL) )
                            {
                                nvEncoder.Head = i;
                                RmConfigGetExKernel(hwDeviceExtension->DeviceReference, NV_CFGEX_VIDEO_ENCODER_TYPE, 
                                        &nvEncoder, sizeof(NV_CFGEX_VIDEO_ENCODER_TYPE));
                                switch(nvEncoder.EncoderType)
                                {
                                    case NV_ENCODER_BROOKTREE_868:
                                    case NV_ENCODER_CHRONTEL_7003:
                                    case NV_ENCODER_CHRONTEL_7006:
                                    case NV_ENCODER_CHRONTEL_7008:
                                    // Not macrovision support
                                        break;
                                    default:
                                        // macrovision support
                                        nvMacrovision.head = i;
                                        nvMacrovision.mode = pInVideoParameters->bCP_APSTriggerBits;
                                        nvMacrovision.resx = hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i];
                                        nvMacrovision.resy = hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i];
                                        switch(pInVideoParameters->dwCPCommand)
                                        {
                                            case VP_CP_CMD_ACTIVATE:
                                                if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                     NV_CFGEX_SET_MACROVISION_MODE,
                                                     &nvMacrovision,
                                                     sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                {
                                                    pOutVideoParameters->dwCPKey = hwDeviceExtension->ulCurrentMacrovisionKey 
                                                                                 = hwDeviceExtension->ulNextMacrovisionKey++;
                                                }
                                            break;
                                            case VP_CP_CMD_DEACTIVATE:
                                                if(pInVideoParameters->dwCPKey == hwDeviceExtension->ulCurrentMacrovisionKey)
                                                {
                                                    nvMacrovision.mode = 0;
                                                    if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                         NV_CFGEX_SET_MACROVISION_MODE,
                                                         &nvMacrovision,
                                                         sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                    {
                                                        // Disabled successfully
                                                    }
                                                    else
                                                    {
                                                        // Failed to disable it.
                                                    }
                                                }
                                            break;
                                            case VP_CP_CMD_CHANGE:
                                                if(pInVideoParameters->dwCPKey == hwDeviceExtension->ulCurrentMacrovisionKey)
                                                {
                                                    nvMacrovision.mode  = pInVideoParameters->bCP_APSTriggerBits & 0x03;
                                                    if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                         NV_CFGEX_SET_MACROVISION_MODE,
                                                         &nvMacrovision,
                                                         sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                    {
                                                        // changed successfully
                                                    }
                                                    else
                                                    {
                                                        // Failed to change it.
                                                    }
                                                }
                                            break;
                                        }
                                        RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
                                        hwDeviceExtension->ulMacrovisionMode = nvMacrovision.mode;
                                } // switch
                            } // if
                        } // for
                   } // if
                   status = NO_ERROR;
                    break; //  
                } // 
                default:
                    break;
             } // switch
        }
        break;

        //**************************************************************************
        // IOCTL_VIDEO_ALLOC_AGP_MEM
        //**************************************************************************

        case IOCTL_VIDEO_ALLOC_AGP_MEM:
            {
            ULONG       cPages;
            PAGP_MEM    pBlock, pOutputBuffer;
            PVOID       VirtualAddress;
            VideoDebugPrint((2, "NVStartIO - IOCTL Alloc AGP Mem\n"));

            if ((RequestPacket->OutputBufferLength < sizeof(AGP_MEM)) ||
                 (RequestPacket->InputBufferLength < sizeof(AGP_MEM)))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_ALLOC_AGP_MEM - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }
            else if (!hwDeviceExtension->bAgp)
                {
                status = ERROR_INVALID_FUNCTION;
                break;
                }
            pBlock = (PAGP_MEM) (RequestPacket->InputBuffer);
            pOutputBuffer = (PAGP_MEM) (RequestPacket->OutputBuffer);
            cPages = ((pBlock->cb / PAGE_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
            if (!(hwDeviceExtension->AgpVirtualBaseAddress =
                    VideoPortAgpReserveVirtual(
                        hwDeviceExtension,
                        (HANDLE)pBlock->hContext,
                        hwDeviceExtension->AgpPhysContext,
                        (PVOID *)(&(hwDeviceExtension->dummyVirtualContext)))))
                {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
                }
            *pOutputBuffer = *pBlock;
            if (!(pOutputBuffer->VirtualAddress =
                    VideoPortAgpCommitVirtual(
                        hwDeviceExtension,
                        hwDeviceExtension->dummyVirtualContext,
                        cPages, 0)))
                {
                VideoPortAgpReleaseVirtual(
                    hwDeviceExtension,
                    hwDeviceExtension->dummyVirtualContext);
                hwDeviceExtension->dummyVirtualContext = NULL;
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
                }
                RequestPacket->StatusBlock->Information = sizeof(AGP_MEM);
                status = NO_ERROR;
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_FREE_AGP_MEM
        //**************************************************************************

        case IOCTL_VIDEO_FREE_AGP_MEM:
            {
            PVOID       VirtualAddress;
            PAGP_MEM    pBlock;
            ULONG       cPages;

            VideoDebugPrint((2, "NVStartIO - IOCTL Free AGP Mem\n"));
            if (RequestPacket->InputBufferLength < sizeof(AGP_MEM))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }
            else if (!hwDeviceExtension->bAgp)
                {
                status = ERROR_INVALID_FUNCTION;
                break;
                }
            pBlock = (PAGP_MEM) RequestPacket->InputBuffer;
            cPages = ((pBlock->cb / PAGE_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
            VideoPortAgpFreeVirtual(
                hwDeviceExtension,
                hwDeviceExtension->dummyVirtualContext,
                cPages,
                (ULONG)((PUCHAR)pBlock->VirtualAddress - (PUCHAR)hwDeviceExtension->dummyVirtualContext)
            );
            VideoPortAgpReleaseVirtual(hwDeviceExtension,
                hwDeviceExtension->dummyVirtualContext);
            hwDeviceExtension->dummyVirtualContext = NULL;
            status = NO_ERROR;
            }
            break;

        ////// all VPE commands go thru here !
#ifdef NVPE
        case IOCTL_VIDEO_VPE_COMMAND:
        VideoDebugPrint((2, "NVStartIO - IOCTL Video Port Extension Command\n"));
                status = NVPEProcessCommand(HwDeviceExtension, RequestPacket);
                break;
#endif  // #ifdef NVPE
#endif  // _WIN32_WINNT >= 0x0500




        //****************************************************************************************************
        // IOCTL_VIDEO_SET_TWINVIEW_STATE
        // Sets the user selected state of Clone/Normal/Multimon.
        // Also sets the other pieces of info like DeviceType, Physical and virtual rectl for each head etc..
        //****************************************************************************************************

        case IOCTL_VIDEO_SET_TWINVIEW_STATE:
            {
                NVTWINVIEWDATA *pInfo;

                VideoDebugPrint((6, "IOCTL_VIDEO_SET_TWINVIEW_STATE():\n"));
                if(RequestPacket->InputBufferLength < sizeof(NVTWINVIEWDATA)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_SET_TWINVIEW_STATE(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (NVTWINVIEWDATA *)(RequestPacket->InputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_SET_TWINVIEW_STATE(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"TwinviewInfo",
                                       pInfo,
                                       sizeof(NVTWINVIEWDATA));
            }
            break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_TWINVIEW_STATE
        // Gets the user selected state of Clone/Normal/Multimon.
        // Also gets the other pieces of info like DeviceType, Physical and virtual rectl for each head etc..
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_TWINVIEW_STATE:
            {
                NVTWINVIEWDATA *pInfo;

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_TWINVIEW_STATE():\n"));
                if(RequestPacket->OutputBufferLength < sizeof(NVTWINVIEWDATA)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_TWINVIEW_STATE(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (NVTWINVIEWDATA *)(RequestPacket->OutputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_TWINVIEW_STATE(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }


                status = VideoPortGetRegistryParameters(
                                       HwDeviceExtension,
                                       L"TwinviewInfo",
                                       FALSE,
                                       NVReadRegistryTwinViewInfoCallback,
                                       pInfo);
                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(NVTWINVIEWDATA);
                else
                    RequestPacket->StatusBlock->Information = 0;
            }
            break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_PCI_NUMBER
        //****************************************************************************************************
        case IOCTL_VIDEO_QUERY_PCI_SLOT:
        {
            ULONG * pulTemp;

            status = NO_ERROR;
            if(RequestPacket->OutputBufferLength < sizeof(ULONG)) 
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_QUERY_PCI_SLOT(): Error: pInfo is wrong Size.\n"));
                status = ERROR_INVALID_PARAMETER;
                break;
            }
            pulTemp = (ULONG *)(RequestPacket->OutputBuffer);

            *pulTemp = hwDeviceExtension->ulSlot; 

            if (status == NO_ERROR)
                RequestPacket->StatusBlock->Information = sizeof(ULONG);
            else
                RequestPacket->StatusBlock->Information = 0;

        }
        break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_NUMBER_DACS_ON_BOARD
        // Gets the number of DACS on the board
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_NUMBER_DACS:
            {
                GET_NUMBER_DACS *pInfo;
                NV_DESKTOP_INFO *pDeskTopInfo;
                ULONG i, Count = 0;

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_NUMBER_DACS():\n"));
                status = NO_ERROR;
                if(RequestPacket->OutputBufferLength < sizeof(GET_NUMBER_DACS)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_NUMBER_DACS(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (GET_NUMBER_DACS *)(RequestPacket->OutputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_NUMBER_DACS(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                // Extract the info from the HwDeviceExtension.
                pDeskTopInfo = (NV_DESKTOP_INFO *)&hwDeviceExtension->DeskTopInfo;

                // Stuff the info to send back to the display driver.
                pInfo->ulNumberDacsOnBoard = pDeskTopInfo->ulNumberDacsOnBoard;
                pInfo->ulNumberDacsConnected = pDeskTopInfo->ulNumberDacsConnected;
                pInfo->ulAllDeviceMask = pDeskTopInfo->ulAllDeviceMask;
                pInfo->ulConnectedDeviceMask = pDeskTopInfo->ulConnectedDeviceMask;
                for (i=0; i < pDeskTopInfo->ulNumberDacsOnBoard; i++)
                {
                    pInfo->ulDeviceMask[i] = pDeskTopInfo->ulDeviceMask[i];
                    pInfo->ulDeviceType[i] = pDeskTopInfo->ulDeviceType[i];
                    pInfo->ulTVFormat[i] = pDeskTopInfo->ulTVFormat[i];
                    pInfo->ulHeadDeviceOptions[i] = pDeskTopInfo->ulHeadDeviceOptions[i];
                }


                VideoDebugPrint((3,"IOCTL_GET_NUMBER_DACS: Number of heads on board returning to display driver: 0x%x, number connected: 0x%x\n",
                    pInfo->ulNumberDacsOnBoard,pInfo->ulNumberDacsConnected));

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(GET_NUMBER_DACS);
                else
                    RequestPacket->StatusBlock->Information = 0;
            }
            break;

            case IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING:
            {
                

                VideoDebugPrint((0, "IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING():\n"));
                status = NO_ERROR;
                bScanHeadDeviceOptions(hwDeviceExtension);
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_PHYSICAL_MODE_LIST
        // Returns the number and list of physical modes for the specified head.
        // Input is the list of virtual modes for that head (no doubled resolutions but single screen resolutions)
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST:
            {
                HEAD_MODE_LIST_INFO *pInput, *pOutput;
                ULONG ulRet, ulRetSize;
                

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST():\n"));
                status = NO_ERROR;
                
                if(RequestPacket->InputBufferLength < sizeof(HEAD_MODE_LIST_INFO)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST(): Error: InputBufferLength is wrong Size: 0x%x\n",
                        RequestPacket->InputBufferLength));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInput = (HEAD_MODE_LIST_INFO *)(RequestPacket->InputBuffer);
                
                if (pInput == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST(): Error: pInput is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }
                


                ulRetSize = 0;
                ulRet = GetHeadPhysicalModeList(hwDeviceExtension, 
                            pInput, &ulRetSize);

                if (ulRet == FALSE)
                {
                    status = ERROR_INVALID_PARAMETER;
                }


                VideoDebugPrint((3,"IOCTL_GET_NUMBER_DACS: Number of PhysicalModes for head: %d returned is: %d\n",
                    pInput->ulHead, (ulRetSize/sizeof(MODE_ENTRY))));

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = ulRetSize;
                else
                    RequestPacket->StatusBlock->Information = 0;
            }
            break;



        //**************************************************************************
        // IOCTL_VIDEO_SET_REGISTRY_VALUE
        // Sets a registry value.
        // Supports only DWORD entries right now.
        //**************************************************************************

        case IOCTL_VIDEO_SET_REGISTRY_VALUE:
            {
                PNV_REGISTRY_STRUCT pRegStruct;

                pRegStruct = (PNV_REGISTRY_STRUCT)(RequestPacket->InputBuffer);

                status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                       pRegStruct->keyName,
                                       pRegStruct->keyVal,
                                       pRegStruct->keyValSize);
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_QUERY_REGISTRY_VAL
        // Queries a registry value.
        // We support only DWORD entries right now.
        //**************************************************************************

        case IOCTL_VIDEO_QUERY_REGISTRY_VAL:
            {
                PWSTR     regKeyName;
                PVOID     regValData;

                regKeyName = (PWSTR)(RequestPacket->InputBuffer);
                regValData = (PVOID)(RequestPacket->OutputBuffer);

                status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       regKeyName,
                                       FALSE,
                                       NVRegistryCallback,
                                       regValData);
                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(ULONG);
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL
        // Queries a Binary registry value.
        //**************************************************************************

        case IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL:
            {
                PWSTR     regKeyName;
                PNV_REGISTRY_STRUCT pRegStructInput;
                PNV_REGISTRY_STRUCT pRegStructOutput;

                
                pRegStructInput = (PNV_REGISTRY_STRUCT)(RequestPacket->InputBuffer);
                regKeyName = (PWSTR)(pRegStructInput->keyName);
                pRegStructOutput = (PNV_REGISTRY_STRUCT)(RequestPacket->OutputBuffer);
                // Copy the required values into the output structure
                pRegStructOutput->keyVal = pRegStructInput->keyVal;
                pRegStructOutput->keyValSize = pRegStructInput->keyValSize;

                status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       regKeyName,
                                       FALSE,
                                       NVReadRegistryBinaryCallback,
                                       (PVOID)pRegStructOutput);
            if (status == NO_ERROR)
            {
                RequestPacket->StatusBlock->Information = pRegStructOutput->keyValSize;
            }
            else
            {
                RequestPacket->StatusBlock->Information = 0;
                pRegStructOutput->keyValSize = 0;
            }
                 

            }
            break;



      // Sets a Display value ( vga, fp or tv, and tv type: ntsc or pal) in the registry
      case IOCTL_VIDEO_SET_DISPLAY_DEVICE:
         {
            NV_CFGEX_SET_DISPLAY_TYPE_PARAMS sdtp;
            PSETGETDEVTYPE sgdt;
            BOOL  ValidParams;

            if(RequestPacket->InputBufferLength < sizeof(SETGETDEVTYPE)) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               sgdt = (PSETGETDEVTYPE)RequestPacket->InputBuffer;
               VideoDebugPrint((2, "NVStartIO - SetDisplayDevice\n"));

               switch(sgdt->dwDeviceType) {
                  case 0:     // NV_DISPLAY_TYPE_VGA
                     sdtp.Type = DISPLAY_TYPE_MONITOR;
                     sdtp.TVType = 0;  // Play it safe
                     ValidParams = TRUE;
                     break;
                  case 2:     // NV_DISPLAY_TYPE_TV_NTSC
                     sdtp.Type = DISPLAY_TYPE_TV;
                     sdtp.TVType = sgdt->dwTvFormat;
                     ValidParams = TRUE;
                     break;
                  case 3:     // NV_DISPLAY_TYPE_TV_PAL
                     sdtp.Type = DISPLAY_TYPE_TV;
                     sdtp.TVType = sgdt->dwTvFormat;
                     ValidParams = TRUE;
                     break;
                  case 4:     // NV_DISPLAY_TYPE_FLAT_PANEL
                     sdtp.Type = DISPLAY_TYPE_FLAT_PANEL;
                     sdtp.TVType = 0;  // Play it safe
                     ValidParams = TRUE;
                     break;
                  default: // ?
                     ValidParams = FALSE;
                     break;
               }

               // - If all of the params are cool, attempt the settings
               if(ValidParams) {

                  VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: Type: %d, TVType: %d\n",sdtp.Type,sdtp.TVType));

                  // - Go set the values in the registry
                  if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                         NV_CFGEX_SET_DISPLAY_TYPE,
                                         &sdtp,
                                         sizeof(NV_CFGEX_SET_DISPLAY_TYPE_PARAMS))) {

                     // The Rm call seems to have succeded
                     status = NO_ERROR;
                  }
                  else {

                     VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: RmConfigSetExKernel failed\n"));
                     status = ERROR_INVALID_PARAMETER;   // This is not correct, but the other error codes are
                                                         // just as incorrect!
                  }

                  // - Nothing to return to the caller
                  RequestPacket->StatusBlock->Information = 0;

               }
               else {

                  VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: The parameters were in error.\n"));
                  // - Wrap up IOCTL control info for failure
                  status = ERROR_INVALID_PARAMETER;
               }
            }
         }
         break;


      // Gets a Display value ( vga, fp or tv, and tv type: ntsc or pal) from the registry
      case IOCTL_VIDEO_GET_DISPLAY_DEVICE:
         {

            NV_CFGEX_GET_DISPLAY_TYPE_PARAMS sdtp;
            PSETGETDEVTYPE sgdt;
            BOOL  ValidRegData;

            if(RequestPacket->OutputBufferLength < sizeof(SETGETDEVTYPE)) {
               status = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - GetDisplayDevice\n"));
               sgdt = (PSETGETDEVTYPE)RequestPacket->OutputBuffer;
               status = NO_ERROR;

               // - Go get the values in the registry
               ValidRegData = FALSE;
               if(RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                      NV_CFGEX_GET_DISPLAY_TYPE,
                                      &sdtp,
                                      sizeof(NV_CFGEX_GET_DISPLAY_TYPE_PARAMS))) {
                  ValidRegData = TRUE;
               }

               if(ValidRegData) {

                  // - Update the values in the passed in buffer
                  switch(sdtp.Type) {

                     case DISPLAY_TYPE_MONITOR:
                        sgdt->dwDeviceType = 0; // NV_DISPLAY_TYPE_VGA
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;

                     case DISPLAY_TYPE_TV:
                        switch(sdtp.TVType) {
                           case 0: // NV_REG_TVFORMAT_NTSCM
                           case 1: // NV_REG_TVFORMAT_NTSCJ
                              sgdt->dwDeviceType = 2; // NV_DISPLAY_TYPE_TV_NTSC
                              sgdt->dwTvFormat = sdtp.TVType;
                              sgdt->dwSuccessFlag = TRUE;
                              break;
                           case 2: // NV_REG_TVFORMAT_PALM
                           case 3: // NV_REG_TVFORMAT_PALB
                           case 4: // NV_REG_TVFORMAT_PALN
                           case 5: // NV_REG_TVFORMAT_PALNC
                              sgdt->dwDeviceType = 3; // NV_DISPLAY_TYPE_TV_PAL
                              sgdt->dwTvFormat = sdtp.TVType;
                              sgdt->dwSuccessFlag = TRUE;
                              break;
                           default:
                              sgdt->dwDeviceType = 2; // Make this NTSC just in case someone does not pay attention
                              sgdt->dwTvFormat = 0;
                              sgdt->dwSuccessFlag = FALSE;
                              break;
                        }
                        break;

                     case DISPLAY_TYPE_FLAT_PANEL: // NV_DISPLAY_TYPE_FLAT_PANEL
                        sgdt->dwDeviceType = 4;
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;


                     default:
                        sgdt->dwDeviceType = 0; // NV_DISPLAY_TYPE_VGA
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;
                  }
               }
               else {   // Data in reg not avail, so return faliure
                     sgdt->dwDeviceType = 0;
                     sgdt->dwTvFormat = 0;
                     sgdt->dwSuccessFlag = FALSE;
               }

               // - Wrap up IOCTL control info
               RequestPacket->StatusBlock->Information = sizeof(SETGETDEVTYPE);
               status = NO_ERROR;

            }
         }
         break;


      // - NV_ESC_VALIDATE_DEVICE_MODE path into the miniport
      case IOCTL_VALIDATE_DEVICE_MODE:
         {

            BOOL  ValidParams;
            VALMODEXTR *vmx;

            if( (RequestPacket->InputBufferLength < sizeof(VALMODEXTR)) ||
                (RequestPacket->OutputBufferLength < sizeof(ULONG)) ){
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               vmx = (VALMODEXTR *)RequestPacket->InputBuffer;
               VideoDebugPrint((1, "NVStartIO - ValidateDeviceMode\n"));
               VideoDebugPrint((1, "NVStartIO -   dwHRes = %ld\n",vmx->dwHRes));
               VideoDebugPrint((1, "NVStartIO -   dwVRes = %ld\n",vmx->dwVRes));
               VideoDebugPrint((1, "NVStartIO -   dwBpp = %ld\n",vmx->dwBpp));
               VideoDebugPrint((1, "NVStartIO -   dwRefresh = %ld\n",vmx->dwRefresh));
               VideoDebugPrint((1, "NVStartIO -   dwDeviceType = %ld\n",vmx->dwDeviceType));

               ValidParams = TRUE;

               // - If all of the params are cool, attempt the validate mode function
               if(ValidParams) {

                  // - Go set the values in the device context, no error checking for now...
                  if(NVValidateDeviceMode(HwDeviceExtension, vmx)) {

                     // - That mode is VALID for this device
                     *(ULONG *)RequestPacket->OutputBuffer = TRUE;
                  }
                  else {

                     // - That mode is NOT VALID for this device
                     *(ULONG *)RequestPacket->OutputBuffer = FALSE;
                  }

                  RequestPacket->StatusBlock->Information = sizeof(ULONG);
                  status = NO_ERROR;

               }
               else {
                  RequestPacket->StatusBlock->Information = 0;
                  status = ERROR_INVALID_PARAMETER;
               }
            }
         }
         break;


      // - This next one seems like a lot of work for nothing, but is keeps it comp with 9x for now
      case IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER:
         {

            if(RequestPacket->OutputBufferLength < sizeof(ULONG)) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER\n"));

               // - We use the device reference + 1
               *(ULONG *)RequestPacket->OutputBuffer = hwDeviceExtension->DeviceReference + 1;
               RequestPacket->StatusBlock->Information = sizeof(ULONG);
               status = NO_ERROR;

            }
         }
         break;

      // - This IOCTL return the current gamma cache clut stored in the device extension
      case IOCTL_VIDEO_GET_GAMMA_CLUT:
         {

            if(RequestPacket->OutputBufferLength != MAX_CLUT_SIZE) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_GAMMA_CLUT\n"));

               status = NVGetColorLookup(HwDeviceExtension,
                                         (PVIDEO_CLUT)RequestPacket->OutputBuffer,
                                         RequestPacket->OutputBufferLength );

               RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE;

            }
         }
         break;
         
        
        //**************************************************************************
        // Save/Restore the Gamma values for the mode switching.
        //**************************************************************************
        case IOCTL_VIDEO_SAVE_GAMMA_VALUES:
            if(RequestPacket->InputBufferLength != sizeof(hwDeviceExtension->GammaCacheData)) 
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else 
            {
                ULONG i;
                ULONG * pGammaCache;
                ULONG * pCallerBuffer;
                
                pGammaCache = (ULONG *) &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pCallerBuffer = (ULONG *) RequestPacket->InputBuffer;
                
                for(i = 0; i < sizeof(hwDeviceExtension->GammaCacheData) / sizeof(ULONG); i++)
                {
                    *pGammaCache++ = *pCallerBuffer++;
                }
                status = NO_ERROR;
            }
            break;
            
        case IOCTL_VIDEO_RESTORE_GAMMA_VALUES:
            if(RequestPacket->OutputBufferLength != sizeof(hwDeviceExtension->GammaCacheData)) 
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else 
            {
                ULONG i;
                ULONG * pGammaCache;
                ULONG * pCallerBuffer;
                
                pGammaCache = (ULONG *) &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pCallerBuffer = (ULONG *) RequestPacket->OutputBuffer;
                
                for(i = 0; i < sizeof(hwDeviceExtension->GammaCacheData) / sizeof(ULONG); i++)
                {
                    *pCallerBuffer++ = *pGammaCache++;
                }
                status = NO_ERROR;
                RequestPacket->StatusBlock->Information =sizeof(hwDeviceExtension->GammaCacheData);
            }
            break;
        //**************************************************************************
        // MAP_PHYS_ADDR
        //**************************************************************************

        case IOCTL_VIDEO_MAP_PHYS_ADDR:
            {
            NV_SYSMEM_SHARE_MEMORY  *pShareMemory, *pShareMemoryInformation;
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS params;
            U032 physicalAGPBase;

            VideoDebugPrint((2, "W32StartIO - MapPhysAddr\n"));

            if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY) ||
                 (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_MAP_PHYS_ADDR - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            pShareMemory = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->InputBuffer;
            RequestPacket->StatusBlock->Information =
                                        sizeof(NV_SYSMEM_SHARE_MEMORY);

            sharedViewSize = pShareMemory->byteLength;

            //**********************************************************************
            // NOTE: we are ignoring ViewOffset
            //**********************************************************************

            shareAddress.HighPart = 0x00000000;
            PHYSICAL_ADDRESS_VALUE(shareAddress) = pShareMemory->physicalAddress;
            pShareMemoryInformation = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->OutputBuffer;

            //**********************************************************************
            // Map the physical address into a non-cached kernel mode address.
            //**********************************************************************
            pShareMemoryInformation->ddVirtualAddress =
                MmMapIoSpace(shareAddress.LowPart,
                            (size_t) sharedViewSize,
                            (MmNonCached | MmWriteCombined));

            if (pShareMemoryInformation->ddVirtualAddress == NULL)
                {
                status = ERROR_INVALID_PARAMETER;
                break;
                }

            //**********************************************************************
            // Set the RM's AGP linear base if a mapping doesn't exist already. We
            // don't expect this to ever been needed, since the RM should've been
            // able to create their own mapping to the AGP phys base. Just in case,
            // set it up if it's not already.
            //**********************************************************************
            RmConfigGetKernel(hwDeviceExtension->DeviceReference,
                              NV_CFG_AGP_PHYS_BASE, &physicalAGPBase);

            RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                NV_CFGEX_AGP_LINEAR_BASE,
                                &params,
                                sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS));
            if ((params.linaddr == NULL) &&
                (physicalAGPBase == pShareMemory->physicalAddress)) {
                
                // update the RM's linear base
                params.linaddr = pShareMemoryInformation->ddVirtualAddress;
                RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                    NV_CFGEX_AGP_LINEAR_BASE,
                                    &params,
                                    sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS));
            }

            //**********************************************************************
            // Returned amount of mapped memory to specific process
            //**********************************************************************

            pShareMemoryInformation->byteLength = sharedViewSize;

            status = NO_ERROR;
            }
            break;

        //**************************************************************************
        // UNMAP_PHYS_ADDR
        //**************************************************************************

        case IOCTL_VIDEO_UNMAP_PHYS_ADDR:
            {
            NV_SYSMEM_SHARE_MEMORY  *pShareMemory;

            VideoDebugPrint((2, "W32StartIO - UnmapPhysAddr\n"));

            if (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_MAP_PHYS_ADDR - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            pShareMemory = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->InputBuffer;
            RequestPacket->StatusBlock->Information =
                                        sizeof(NV_SYSMEM_SHARE_MEMORY);

            sharedViewSize = pShareMemory->byteLength;

            //**********************************************************************
            // Unmap the virtual address.
            //**********************************************************************
            MmUnmapIoSpace(pShareMemory->ddVirtualAddress,
                        (size_t) sharedViewSize);

            pShareMemory->ddVirtualAddress = NULL;
            status = NO_ERROR;
            }
            break;

#if _WIN32_WINNT >= 0x0500
        //**************************************************************************
        // GET_SYSTEM_MEMORY_INFO
        //**************************************************************************

        case IOCTL_VIDEO_GET_SYSTEM_MEMORY_INFO:
            {
            NV_SYSMEM_INFO  *pSysMemInfo;

            VideoDebugPrint((2, "W32StartIO - GetSystemMemoryInfo\n"));

            if (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_INFO))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_GET_SYSTEM_MEMORY_INFO - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            pSysMemInfo = (NV_SYSMEM_INFO *) RequestPacket->OutputBuffer;
            pSysMemInfo->SystemMemorySize =
                hwDeviceExtension->SystemMemorySize;
            pSysMemInfo->AgpAllocationLimit =
                hwDeviceExtension->AgpServices.AllocationLimit;
            RequestPacket->StatusBlock->Information =
                                        sizeof(NV_SYSMEM_INFO);

            status = NO_ERROR;
            }
            break;
#endif // _WIN32_WINNT >= 0x0500


        case IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR:
            {
                ULONG * pulXY;

                if(RequestPacket->InputBufferLength != sizeof(ULONG))
                {

                    VideoDebugPrint((0, "IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR - ERROR_INSUFFICIENT_BUFFER\n"));
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }
                else
                {
                    pulXY = (ULONG *)RequestPacket->InputBuffer;
                    hwDeviceExtension->NvCursorInfo.lCursorX= (LONG)( (SHORT)(*pulXY & 0xFFFF));
                    hwDeviceExtension->NvCursorInfo.lCursorY= (LONG)( (SHORT)(*pulXY >> 16));
                    status = NO_ERROR;
                    break;
                }
            }
            break;

        case IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR:
            {
                NV_CURSOR_INFO * pNvCursorInfo;

                if(RequestPacket->InputBufferLength != sizeof(NV_CURSOR_INFO))
                {

                    VideoDebugPrint((0, "IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR - ERROR_INSUFFICIENT_BUFFER\n"));
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }
                else
                {
                    pNvCursorInfo = (NV_CURSOR_INFO * )RequestPacket->InputBuffer;

                    hwDeviceExtension->NvCursorInfo.lCursorX = pNvCursorInfo->lCursorX;
                    hwDeviceExtension->NvCursorInfo.lCursorY = pNvCursorInfo->lCursorY;
                    hwDeviceExtension->NvCursorInfo.lCursorWidth = pNvCursorInfo->lCursorWidth;
                    hwDeviceExtension->NvCursorInfo.lCursorHeight = pNvCursorInfo->lCursorHeight;
                    hwDeviceExtension->NvCursorInfo.lScreenStride = pNvCursorInfo->lScreenStride;
                    hwDeviceExtension->NvCursorInfo.lScreenPixelDepth = pNvCursorInfo->lScreenPixelDepth;
                    hwDeviceExtension->NvCursorInfo.ulHwCursorWidth = pNvCursorInfo->ulHwCursorWidth;
                    hwDeviceExtension->NvCursorInfo.ulOriginalImageMemOffset = pNvCursorInfo->ulOriginalImageMemOffset;
                    hwDeviceExtension->NvCursorInfo.ulCursorMemOffset = pNvCursorInfo->ulCursorMemOffset;

                    VideoPortStartTimer(hwDeviceExtension);
                    status = NO_ERROR;
                }
            }
            break;

        case IOCTL_VIDEO_STOP_TIMER_FOR_NV10_CURSOR:
            {
                VideoPortStopTimer(hwDeviceExtension);
                status = NO_ERROR;
            }
            break;


    default:

        //**************************************************************************
        // if we get here, an invalid IoControlCode was specified.
        //**************************************************************************

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;
        }

        //  Zero out the Information in StatusBlock when Error occurs.
        
        if(status != NO_ERROR)
        {
            RequestPacket->StatusBlock->Information = 0;
        }

    RequestPacket->StatusBlock->Status = status;
#if DBG
    VideoDebugPrint((2, "W32StartIO Exit  - %08.8x\n", RequestPacket->IoControlCode));
#endif
    return TRUE;

    } // NVStartIO()

//******************************************************************************
//
// Function: NVInterrupt()
//
// Routine Description:
//   This function services interrupts generated by the device.
//
// Arguments:
//
//    HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//   TRUE -- if this device caused the interrupt and when the interrupt is
//           serviced and the interrupt reset
//
//   FALSE -- if this device was not responsible for the interrupt
//
//******************************************************************************


BOOLEAN NVInterrupt(
    PVOID HwDeviceExtension
)
{
        PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
        BOOLEAN serviced;

        serviced = (BOOLEAN) RmIsr(hwDeviceExtension->DeviceReference);

        return serviced;
}

//******************************************************************************
//
// private routines
//
//******************************************************************************


//******************************************************************************
//
// Function: NVSetColorLookup()
//
// Routine Description:
//
//     This routine sets a specified portion of the DAC color lookup table
//     settings.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//     ClutBufferSize - Length of the input buffer supplied by the user.
//
//     ClutBuffer - Pointer to the structure containing the color lookup table.
//
// Return Value:
//
//     NO_ERROR - information returned successfully
//
//     ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.
//
//     ERROR_INVALID_PARAMETER - invalid clut size.
//
//******************************************************************************


VP_STATUS
NVSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )


    {
    USHORT i;
    ULONG OutData;

    //**************************************************************************
    // Check if the size of the data in the input buffer is large enough.
    //**************************************************************************

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //**************************************************************************
    // Check to see if the parameters are valid.
    //**************************************************************************

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
             VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //**************************************************************************
    // Set palette for either.
    //**************************************************************************
    NV_SetColorLookup(HwDeviceExtension,ClutBuffer,ClutBufferSize);

    return NO_ERROR;

    } // end NVSetColorLookup()



//******************************************************************************
//
// Function: NVGetColorLookup()
//
// Routine Description:
//
//     This routine gets a specified portion of the DAC color lookup table
//     settings.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//     ClutBufferSize - Length of the output buffer supplied by the user.
//
//     ClutBuffer - Pointer to the buffer to store the color lookup table.
//
// Return Value:
//
//     NO_ERROR - information returned successfully
//
//     ERROR_INSUFFICIENT_BUFFER - output buffer not large enough for clut data.
//
//     ERROR_INVALID_PARAMETER - invalid clut size.
//
//******************************************************************************

VP_STATUS
NVGetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

    {
      PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
      PVIDEO_CLUTDATA   pvcdItemSrc,pvcdItemDst;
      PVIDEO_CLUT       srcclut,dstclut;
      ULONG index,item,NumEntries,FirstEntry;

      //**************************************************************************
      // Get data from gamma cache.
      //**************************************************************************

      // - Make things nice to look at
                pvcdItemSrc = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pvcdItemDst = &ClutBuffer->LookupTable->RgbArray;
      srcclut = &hwDeviceExtension->GammaCache;
      dstclut = ClutBuffer;

      // - Copy over the clut specs
      dstclut->NumEntries = srcclut->NumEntries;
      dstclut->FirstEntry = srcclut->FirstEntry;

      // - Set the limits on the item copy
      NumEntries = srcclut->NumEntries;
      FirstEntry = srcclut->FirstEntry;

      // - Copy over the gamma data
      for(item = FirstEntry; item < NumEntries; item++) {
           index = item + FirstEntry;
           pvcdItemDst[index].Blue   = pvcdItemSrc[index].Blue;
           pvcdItemDst[index].Green  = pvcdItemSrc[index].Green;
           pvcdItemDst[index].Red    = pvcdItemSrc[index].Red;
           pvcdItemDst[index].Unused = pvcdItemSrc[index].Unused;
      }

    return NO_ERROR;

    } // end NVGetColorLookup()



//******************************************************************************
//
// Function: NVRegistryCallback()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }

    //**********************************************************************
    // Deals with data if size > 4 bytes
    // If > 4 bytes, we'll treat it as Unicode string data  (MODE ENTRIES)
    // and not dword registry switches
    //**********************************************************************

    if (ValueLength > sizeof(ULONG))
        {
        //*******************************************************************
        // Copy string data into our temporary buffer registry_data[]
        // Since this callback can be called MANY times per each
        // VideoPortGetRegistry call, we need to manually keep track of where
        // to store the incoming data, since the Context ptr is NOT
        // automatically incremented.  It's always equal to the
        // base address of registry_data.  That is, the RegistryDataOffset value
        // is incremented each time we read a short value from the registry,
        // so that the next time this callback gets called, we'll know where
        // we left off.
        //*******************************************************************

        DestPtr = (SHORT*)((PUCHAR)Context + hwDeviceExtension->RegistryDataOffset);
        SrcStrPtr = (PUCHAR)(ValueData);

        //**********************************************************************
        // Reading mode data numbers from the current mode entry line.
        // This registry callback will continue getting called for each line
        // until the last line is encountered.
        //**********************************************************************

        while (SrcStrPtr < (PUCHAR)ValueData + ValueLength - 2)
            {

            shortvalue = GetNextWordFromRegistry(hwDeviceExtension,&SrcStrPtr);
            *DestPtr = shortvalue;

            //******************************************************************
            // Need to manually keep track of where we need to store the numbers
            // (short values) the next time the registry call back gets called.
            //******************************************************************

            (hwDeviceExtension->RegistryDataOffset)+=2;
            DestPtr++;

            //******************************************************************
            // Debug Safety Check:
            // Make sure we don't go past the end of the registry_data table
            // Backup 30 words from end of table
            //******************************************************************

            if (hwDeviceExtension->RegistryDataOffset > ( (MAX_STRING_REGISTRY_DATA_WORDS*2) - (30*2))  )
                {
                VideoDebugPrint((0, "!!!                                             !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR ERROR  !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR ERROR  !!!\n"));
                VideoDebugPrint((0, "!!!                                             !!!\n"));
                }

            }



        return(NO_ERROR);


        }

    //*************************************************************************
    // Read dword entries
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, (size_t) ValueLength);
    return(NO_ERROR);
    } // end NVRegistryCallback()



//******************************************************************************
//
// Function: NVReadLocalRegistryCallback()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }


    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, ValueLength);
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()

//******************************************************************************
//
// Function: NVReadRegistryTwinViewInfoCallback()
//
// Routine Description:     Used to read the "TwinViewInfo" registry entry.
//                          Do not use it for any other purpose.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }

    // In rare pathlogical condidtions, it is possible for the disk copy of the "TwinViewInfo" structure to be different
    // than the incore structure. This happens when for example the structure gets modified in the source tree but
    // there is a leftover disk entry from a previous version of driver.
    if (ValueLength != sizeof(NVTWINVIEWDATA))
    {
        VideoDebugPrint((0, "Oops!TwinViewCallback(): size mismatch Diskcopy size: %d, struct size: %d\n",
                         ValueLength, sizeof(NVTWINVIEWDATA)));
        return(ERROR_INVALID_PARAMETER);
    }


    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, ValueLength);
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()


//******************************************************************************
//
// Function: NVReadRegistryCallbackBinaryValue()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistryBinaryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PNV_REGISTRY_STRUCT pRegStruct;




    //**********************************************************************
    // If the destination ptr is null, we return error.
    // The user sent us a null output pointer.
    //**********************************************************************
    if (Context == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    pRegStruct = (PNV_REGISTRY_STRUCT)Context;

    // Check to see if the user passed us a non-NULL buffer
    if (pRegStruct->keyVal == NULL)
    {
        // Tell him what is the expected buffer size.
        pRegStruct->keyValSize = ValueLength;
        return(NO_ERROR);
    }

    // Check to see if the user passed us enough of a buffer
    if (pRegStruct->keyValSize < ValueLength || pRegStruct->keyValSize == 0)
    {
        // The user did not send us enough buffer. Tell him what is the 
        // expected buffer size.
        pRegStruct->keyValSize = ValueLength;
        return(NO_ERROR);
    }

    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) pRegStruct->keyVal, (PUCHAR) ValueData, ValueLength);
    pRegStruct->keyValSize = ValueLength;
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()



//******************************************************************************
//
// Function: NVReadMonitorTimingModeCallback()
//
// Routine Description: If there is a reg entry and it fits, copy it
//                      If it is to big, copy the string L"DMT" instead
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VP_STATUS
NVReadMonitorTimingModeCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if(Context == NULL) {
      return(NO_ERROR);
    }


    //*************************************************************************
    // Compare the value to the GTF and DMT strings
    //*************************************************************************

    if(!memcmp( (PUCHAR)L"GTF", (PUCHAR) ValueData, sizeof(L"GTF"))) {
        VideoDebugPrint((0, "GTF overide detected\n"));
        *(ULONG *)Context = TRUE;
        }
    else {
        *(ULONG *)Context = FALSE;
        }

    return(NO_ERROR);
}


//******************************************************************************
//
// Function:    NVSetBiosInfo(HwDeviceExtension)
//
// Routine Description:
//  Attempts to locate BIOS version string. First it searches for
//  a standard NV Bios Info block. If that is not present, it
//  assumes this is a Viper board and scans for a version
//  string.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
VOID NVSetBiosInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PUCHAR VersionStr = "Version ";
    PUCHAR pBios = HwDeviceExtension->pBios;
    USHORT  i, j, c;
    BOOLEAN Found = FALSE;
    WCHAR   wcNameStr[BIOS_STR_MAX] = L"<unavailable>";
    CHAR    NameStr[BIOS_STR_MAX];

    //********************************************************
    // Ask RM for NVidia BIOS revision.
    //********************************************************
    if (RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_BIOS_REVISION, &(HwDeviceExtension->BiosRevision))
        && HwDeviceExtension->BiosRevision)
        {

        //********************************************************
        // See if it's an Elsa BIOS: Elsa uses a similar data structure
        // as the NVIDIA BIOS, but the version string is 24-bits instead of 32.
        //********************************************************
        if (pBios != NULL)
        {
            strcpy(NameStr, "ELSA");
            for (i = 0; i < MAX_BIOS_SCAN; i++)
                if (Found = (VideoPortCompareMemory(NameStr, &pBios[i], strlen(NameStr)) == strlen(NameStr)))
                    break;
        }

        strcpy(NameStr, "Version ");

        // If Found, it's an ELSA BIOS

        if (Found)
        {
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x00ff0000) >> 16), &(NameStr[strlen(NameStr)]), 16, 0);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x0000ff00) >> 8), &(NameStr[strlen(NameStr)]), 16, 2);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x000000ff)), &(NameStr[strlen(NameStr)]), 16, 2);
        }
        else
        {
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0xff000000) >> 24), &(NameStr[strlen(NameStr)]), 16, 0);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x00ff0000) >> 16), &(NameStr[strlen(NameStr)]), 16, 2);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x0000ffff)), &(NameStr[strlen(NameStr)]), 16, 4);
        }

        //*******************************************************
        // Convert BIOS version string to unicode.
        //*******************************************************
        for (c = i = 0; c < strlen(NameStr); c++)
            {
            wcNameStr[c] = (WCHAR)(NameStr[i + c]) & (WCHAR) 0xff;
            }
        wcNameStr[c] = (WCHAR) 0;
        goto WriteRegistryVersionStr;
        }

    //********************************************************
    // Search for Diamond Viper BIOS: it doesn't use the same
    // version strings as the standard NV BIOS.
    //********************************************************
    if (pBios == NULL)
        return;

    strcpy(NameStr, "Viper ");
    for (i = 0; i < MAX_BIOS_SCAN; i++)
        if (Found = (VideoPortCompareMemory(NameStr, &pBios[i], strlen(NameStr)) == strlen(NameStr)))
            break;

    if (!Found)
        //********************************************************
        // Didn't find a Viper BIOS: write the default version
        // string to the registry.
        //********************************************************
        goto WriteRegistryVersionStr;

    Found = FALSE;
    for ( i += (strlen(NameStr) + 1); i < MAX_BIOS_SCAN; i++)
        if (Found = (VideoPortCompareMemory(VersionStr, &pBios[i], strlen(VersionStr)) == strlen(VersionStr)))
            break;

    if (!Found)
        //********************************************************
        // Didn't find a Version String in the Viper BIOS: write
        // the default version string to the registry.
        //********************************************************
        goto WriteRegistryVersionStr;

    //*******************************************************
    // Determine length of BIOS version string.
    //*******************************************************
    Found = FALSE;
    for (j = i; j < MAX_BIOS_SCAN; j++)
        if (Found = (pBios[j] == '\r'))
            break;

    if (!Found || (j == i))
        return;

    //*******************************************************
    // Convert BIOS version string to unicode.
    //*******************************************************
    for (c = 0; (c < j - i) && (c < BIOS_STR_MAX - 1); c++)
        {
        wcNameStr[c] = (WCHAR)(pBios[i + c] & 0xffffL);
        }

    wcNameStr[c] = (WCHAR) 0;

WriteRegistryVersionStr:
    //*******************************************************
    // Write version string to registry so display applet
    // can access it.
    //*******************************************************
    VideoPortSetRegistryParameters(HwDeviceExtension,
                L"HardwareInformation.BiosString",
                wcNameStr,
                (wcslen(wcNameStr) + 1) * sizeof(WCHAR));
    return;
}

//******************************************************************************
//
// Function: wtoa(Number, pString, radix, width
//
// Routine Description:
//  Converts an unsigned 16 number to an ASCII string.
//
// Arguments:
//      Number      Number to be converted
//      pString     ptr to buffer for converted string. Must be
//                  a min of 6 bytes long.
//      radix       base for conversion
//      width       If 0, do not store leading 0s in pString, otherwise == number of nibbles in input number
//
// Return Value:
//
//******************************************************************************
VOID wtoa(USHORT Number, PUCHAR pString, UCHAR radix, UCHAR width)
{
    ULONG   divisor;
    USHORT  digit;
    USHORT  i;


    if (width)
        divisor = 1 << (4 * (width - 1));
    else
    {
        divisor = radix;
        while (divisor <= Number)
            divisor *= radix;
    }

    for (i = 0; divisor; (divisor /= radix))
        {
        digit = (USHORT)(Number / divisor);
        if (!(!i && !digit && !width))
            if (digit < 10)
                pString[i++] = (UCHAR) ((digit) + '0');
            else
                pString[i++] = (UCHAR) ((digit - 10) + 'A');
        Number = (USHORT) (Number % divisor);
        }
    pString[i]='\0';
}

#if _WIN32_WINNT < 0x0500
//******************************************************************************
//
// Function: wcslen(pString)
//
// Routine Description:
//  Our implementation of a wide char string length routine. We
//  can't call the c lib version of wcslen from this kernel mode
//  driver.
//
// Arguments:
//      pString     wide char string
//
// Return Value:
//      Length of string in wide chars, less the null terminator.
//******************************************************************************
ULONG wcslen(PWCHAR pString)
{
    ULONG i;

    for (i = 0; pString[i]; i++);
    return(i);
}
#endif // #if _WIN32_WINNT < 0x0500



//******************************************************************************
//
// Function: GetNextWordFromRegistry
//
// Routine Description:
//
//          Read the next value in the mode entry line.
//          This function 1) skips unicode white space, and then
//          Converts the unicode string to an integer (short) value.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


SHORT GetNextWordFromRegistry(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR *SrcStrPtr
    )


    {
    SHORT value;
    UCHAR ch;

    ch = **SrcStrPtr;

    //******************************************************************************
    // Skip over empty space in unicode string
    //******************************************************************************

    while ((ch == 0) || (ch == ' '))
        {
        (*SrcStrPtr)++;                 // Advance the unicode string ptr
        ch = **SrcStrPtr;
        }

    //******************************************************************************
    // We're now at the beginning of the next 'unicode' number
    //******************************************************************************

    value = my_wtoi(SrcStrPtr);

    return(value);
    }


//******************************************************************************
//
// Function: my_wtoi
//
// Routine Description:
//
//      Converts unicode string to an integer (short value)
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


SHORT my_wtoi(
    PUCHAR *SrcStrPtr
    )

    {
    short i,n;

    n=0;
    for (i=0  ; ((**SrcStrPtr) >= '0') && ((**SrcStrPtr) <='9')  ; (*SrcStrPtr)+=2 )
        n=10 * n + ((**SrcStrPtr) - '0');

    return(n);
    }

//******************************************************************************
//
// Function: my_strupr
//
// Routine Description:
//
//      Converts string to all upper case
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID my_strupr(
    PUCHAR s
    )

    {
    short i;

    for (i=0; s[i] != '\0'; i++)
        if ( (s[i] >= 'a') && ( s[i] <='z')  )
            s[i] = (s[i] - 'a') + 'A';

    }

//******************************************************************************
//
// Function: my_strcmp
//
// Routine Description:
//
//      String compare routine.
//      Returns Zero if strings are equal.
//      Returns NonZero if string are not equal
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


ULONG my_strcmp(
    PUCHAR s,
    PUCHAR t
    )

    {
    short i;


    for (i=0; s[i] == t[i] ; i++)
        if (s[i] == '\0')
            return(0);

    return(s[i] - t[i]);
    }


//******************************************************************************
//
// Function: my_strcpy
//
// Routine Description:
//
//      Converts string to all upper case
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID my_strcpy(
    PUCHAR s,
    PUCHAR t
    )

    {
    short i;

    i=0;

    while (  ( s[i] = t[i]  ) != '\0')
        i++;
    }


//******************************************************************************
//
// Function: NV10CursorTimer
//
// Routine Description:
//
//      This function is to workaround the NV10 HW cursor alpha blending problem.
//      Please also see NV10SetPointerShape and NV10MovePointer in NV10ptr.c in
//      displays driver.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
VOID NV10CursorTimer(
    PVOID HwDeviceExtension
)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    LONG i, j, x, y;
    LONG lScreenStride;
    LONG lScreenPixelDepth;

    ULONG ulAlpha;
    ULONG ulBgdColor;
    ULONG ulBgdRed;
    ULONG ulBgdGreen;
    ULONG ulBgdBlue;
    ULONG ulSrcRed;
    ULONG ulSrcGreen;
    ULONG ulSrcBlue;
    ULONG ulSrcColor;
    ULONG ulDstColor;
    ULONG ulHwCursorWidth;      // HW : 32 or 64

    NV_CURSOR_INFO * pNvCursorInfo;

    UCHAR * pjScreenLoc;
    ULONG * pulDstCursor;
    ULONG * pulSrcCursor;


    pNvCursorInfo = &hwDeviceExtension->NvCursorInfo;

    lScreenStride = pNvCursorInfo->lScreenStride;
    ulHwCursorWidth = pNvCursorInfo->ulHwCursorWidth;
    lScreenPixelDepth = pNvCursorInfo->lScreenPixelDepth;

    pulDstCursor = (ULONG *)( (UCHAR *)hwDeviceExtension->FrameBufferPtr + pNvCursorInfo->ulCursorMemOffset);
    pulSrcCursor = (ULONG *)( (UCHAR *)hwDeviceExtension->FrameBufferPtr + pNvCursorInfo->ulOriginalImageMemOffset);

    x = pNvCursorInfo->lCursorX;
    y = pNvCursorInfo->lCursorY;

    pjScreenLoc = (PUCHAR)hwDeviceExtension->FrameBufferPtr + y * lScreenStride + x * lScreenPixelDepth;

    for(i = 0; i < pNvCursorInfo->lCursorHeight; i++)
    {
        if( (y+i) < 0 ) continue;

        for(j = 0; j < pNvCursorInfo->lCursorWidth; j++)
        {
            if( (x+j) < 0) continue;
            ulSrcColor = *(i * ulHwCursorWidth + j + pulSrcCursor);
            ulAlpha = (ulSrcColor >> 24);
            if( (!ulAlpha) || (ulAlpha == 0xFF))
            {
                // HW will take care it
                continue;
            }
            else
            {

                // HW is broken;  SW Alpha blending
                ulBgdColor = *(ULONG *)(i * lScreenStride + j * lScreenPixelDepth + pjScreenLoc);

                if(lScreenPixelDepth == 2)
                {
                    // Screen is on 16 BPP mode.
                    ulBgdRed   = (ulBgdColor >> 11) & 0x1F;
                    ulBgdGreen = (ulBgdColor >> 05) & 0x3F;
                    ulBgdBlue  = (ulBgdColor & 0x1F);

                    ulBgdRed   = ulBgdRed  * 0xFF / 0x1F;         // convert to 8 bits format
                    ulBgdGreen = ulBgdGreen  * 0xFF / 0x3F;       // convert to 8 bits format
                    ulBgdBlue  = ulBgdBlue * 0xFF / 0x1F;

                }
                else
                {
                    // Screen is on 32 BPP mode
                    ulBgdRed   = (ulBgdColor >> 16) & 0xFF;
                    ulBgdGreen = (ulBgdColor >> 8) & 0xFF;
                    ulBgdBlue  = (ulBgdColor & 0xFF);
                }

                ulSrcRed   = (ulSrcColor >> 16) & 0xFF;
                ulSrcGreen = (ulSrcColor >> 8) & 0xFF;
                ulSrcBlue  = (ulSrcColor & 0xFF);

                ulSrcRed    = ulSrcRed   + (((255 - ulAlpha) * ulBgdRed + 128) >> 8) ;
                ulSrcRed   &= 0xFF;

                ulSrcGreen  = ulSrcGreen + (((255 - ulAlpha) * ulBgdGreen + 128) >> 8);
                ulSrcGreen &= 0xFF;

                ulSrcBlue   = ulSrcBlue  + (((255 - ulAlpha) * ulBgdBlue + 128) >> 8);
                ulSrcBlue  &= 0xFF;

                ulDstColor =  (0xFF000000) | (ulSrcRed << 16) | (ulSrcGreen << 8) | ulSrcBlue;

                *(i * ulHwCursorWidth + j + pulDstCursor) = ulDstColor;
            }
        }
    }

}




#ifdef NVPE
//******************************************************************************
//
// Function: NVRegistryCallbackPnpId()
//
// Routine Description: callback function used to read 'pnpid' strings from
//                      registry
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS NVRegistryCallbackPnpId(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        return (NO_ERROR);

    VideoPortMoveMemory(Context, ValueData, ValueLength);

    return(NO_ERROR);

} // end NVRegistryCallbackPnpId()

#endif


#ifdef ENABLE_HEAD_API


//
// Detects the number of heads present and reads in the EDID for each head.
//

BOOLEAN NVInitialize_DacsAndEDID(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG Count = 0;
    BOOLEAN bRet = TRUE;
    NV_DESKTOP_INFO * pInfo;
    LONG i,j;
    ULONG ulConnectedDeviceMask;

    VideoDebugPrint((2, "INVInitialize_DacsAndEDID():\n"));


    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    pInfo->ulNumberDacsOnBoard = 1;
    pInfo->ulNumberDacsConnected = 1;

    // Get the bitmask for all the connectors in the system.
    pInfo->ulAllDeviceMask = BITMASK_INVALID_DEVICE;
    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_GET_ALL_DEVICES, &pInfo->ulAllDeviceMask);
    VideoDebugPrint((0,"ulAllDeviceMask: 0x%x\n",pInfo->ulAllDeviceMask));

    // Get the connect status for all the connectors.
    pInfo->ulConnectedDeviceMask = pInfo->ulAllDeviceMask;
    ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

    if(RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                              NV_CFGEX_CHECK_CONNECTED_DEVICES, &pInfo->ulConnectedDeviceMask, 
                              sizeof(pInfo->ulConnectedDeviceMask))) 
           
       {

            // success.
            VideoDebugPrint((0,"ulConnectedDeviceMask: 0x%x\n",pInfo->ulConnectedDeviceMask));
            ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
       }
       else
       {

          // The resman had issues with our request, so spew a warning
          VideoDebugPrint((0, "NVInitialize -  RmConfigGetExKernel() returned error for NV_CFGEX_CHECK_CONNECTED_DEVICESI\n"));
       }


    if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_NUMBER_OF_HEADS, &pInfo->ulNumberDacsOnBoard))
    {
        VideoDebugPrint((0,"Ooops! RmConfigGetKernel() failed for NV_CFG_NUMBER_OF_HEADS\n"));
        bRet = FALSE;
    }
    else
    {
        // if there are two dacs on board, detect to see if both are connected.
        // do the same for the case of a single head board also.
        if (pInfo->ulNumberDacsOnBoard == 2 || pInfo->ulNumberDacsOnBoard == 1)
        {
            ULONG Count = 0;
            if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) > 1)
            {
                pInfo->ulNumberDacsConnected = 2;
            }

            if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) == 1)
            {
                pInfo->ulNumberDacsConnected = 1;
            }

            if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) == 0)
            {
                VideoDebugPrint((0,"OOops! ResMan could not detect any connected monitors. So assume CRT connected to head 0\n"));
                pInfo->ulNumberDacsOnBoard = 1;
                pInfo->ulNumberDacsConnected = 1;
                pInfo->ulConnectedDeviceMask = BITMASK_CRT0;
            }



            // Print the info collected
            VideoDebugPrint((0,"DacsOnBoard: %d, DacsConnected: %d, AllDeviceMask: 0x%x, ConnectedDeviceMask: 0x%x,\n",
                             pInfo->ulNumberDacsOnBoard, pInfo->ulNumberDacsConnected,pInfo->ulAllDeviceMask,  pInfo->ulConnectedDeviceMask));
        }
    } // NumDacsOnBoard == 2 || 1


    VideoDebugPrint((2,"Number of heads on board returning to display driver: 0x%x, number connected: 0x%x\n",
        pInfo->ulNumberDacsOnBoard,pInfo->ulNumberDacsConnected));

    // Initialize all the EDID related fields
    for (i=0; i < NV_NO_CONNECTORS; i++)
    {   
        for (j=0; j < EDID_V2_SIZE; j++)
        {
            HwDeviceExtension->EDIDBuffer[i][j] = 0;
        }
        HwDeviceExtension->EDIDBufferValid[i] = 0;
        HwDeviceExtension->EDIDBufferSize[i] = 0;
    }

    //
    // Now read the EDID for all the connected devices.
    // Get the EDID buffer from the RM always.
    //
    for (i=0; i < NV_NO_CONNECTORS; i++)
    {
        ULONG ulDeviceMask;
        ulDeviceMask = (1 << i);

        // See if this device is connected
        if (ulConnectedDeviceMask & ulDeviceMask)
        {
            NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS EdidParams;
            ULONG EdidBufferSize;

            EdidBufferSize          = EDID_V2_SIZE;
            EdidParams.displayMap = ulDeviceMask;
            EdidParams.edidBuffer   = (UCHAR *) &(HwDeviceExtension->EDIDBuffer[i][0]);
            EdidParams.bufferLength = &EdidBufferSize;

            if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_GET_LOGICAL_DEV_EDID, &EdidParams, sizeof(NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS) ))
            {
                VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_LOGICAL_DEV_EDID for DeviceMask: 0x%x\n",ulDeviceMask));
                // Reset all the data fields.
                for (j=0; j < EDID_V2_SIZE; j++)
                {
                    HwDeviceExtension->EDIDBuffer[i][j] = 0;
                }
                HwDeviceExtension->EDIDBufferValid[i] = 0;
                HwDeviceExtension->EDIDBufferSize[i] = 0;

            }
            else
            {
                HwDeviceExtension->EDIDBufferValid[i] = 1;
                HwDeviceExtension->EDIDBufferSize[i] = EdidBufferSize;
            }
    
        }
    }

    return(TRUE);
}




//
// Returns TRUE if the device list is successfully scanned
//
BOOLEAN bScanHeadDeviceOptions(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    NVInitialize_DacsAndEDID(HwDeviceExtension);
    return(TRUE);
} // End function bScanHeadDeviceOptions()



#else ENABLE_HEAD_API

//
// Detects the number of heads present and reads in the EDID for each head.
//

BOOLEAN NVInitialize_DacsAndEDID(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG Count = 0;
    BOOLEAN bRet = TRUE;
    NV_DESKTOP_INFO * pInfo;
    LONG i;

    VideoDebugPrint((2, "INVInitialize_DacsAndEDID():\n"));


    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    pInfo->ulNumberDacsOnBoard = 1;
    pInfo->ulNumberDacsConnected = 1;

    // Get the bitmask for all the connectors in the system.
    pInfo->ulAllDeviceMask = BITMASK_INVALID_DEVICE;
    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_GET_ALL_DEVICES, &pInfo->ulAllDeviceMask);
    VideoDebugPrint((0,"ulAllDeviceMask: 0x%x\n",pInfo->ulAllDeviceMask));

    // Get the connect status for all the connectors.
    pInfo->ulConnectedDeviceMask = pInfo->ulAllDeviceMask;
    if(RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                              NV_CFGEX_CHECK_CONNECTED_DEVICES, &pInfo->ulConnectedDeviceMask, 
                              sizeof(pInfo->ulConnectedDeviceMask))) 
           
       {

            // success.
            VideoDebugPrint((0,"ulConnectedDeviceMask: 0x%x\n",pInfo->ulConnectedDeviceMask));

       }
       else
       {

          // The resman had issues with our request, so spew a warning
          VideoDebugPrint((0, "NVInitialize -  RmConfigGetExKernel() returned error for NV_CFGEX_CHECK_CONNECTED_DEVICESI\n"));
       }


    if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_NUMBER_OF_HEADS, &pInfo->ulNumberDacsOnBoard))
        {
            VideoDebugPrint((0,"Ooops! RmConfigGetKernel() failed for NV_CFG_NUMBER_OF_HEADS\n"));
            bRet = FALSE;
        }
        else 
        {
            // if there are two dacs on board, detect to see if both are connected.
            // do the same for the case of a single head board also.
            if (pInfo->ulNumberDacsOnBoard == 2 || pInfo->ulNumberDacsOnBoard == 1)
            {
                ULONG Count = 0;

                //
                // Now check to see if the head is really connected
                //
                for (i=0; i < (LONG)pInfo->ulNumberDacsOnBoard; i++)
                {
                    // Initialize the devicetype to some invalid value.
                    pInfo->ulDeviceMask[i] = BITMASK_INVALID_DEVICE;
                    pInfo->ulDeviceType[i] = INVALID_DEVICE_TYPE;

                    // Clear the flags first for the head device options.
                    pInfo->ulHeadDeviceOptions[i] = 0;

                    // We progressively test to see if a CRT/DFP/TV is connected on a given head.
                    // See if CRT is connected.
                    {
                        NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS MonitorInfo;

                        MonitorInfo.Head = i;
                        MonitorInfo.MonitorConnected = 0;
                        if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference,
                                NV_CFGEX_GET_MONITOR_INFO_MULTI, &MonitorInfo, 
                                sizeof(NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS))) 
                        {
                            VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_MONITOR_INFO_MULTI\n"));
                            bRet = FALSE;
                            break;
                        }
                        if (MonitorInfo.MonitorConnected == 1)
                        {
                            if (pInfo->ulDeviceType[i] == INVALID_DEVICE_TYPE) 
                            {
                                pInfo->ulDeviceType[i] = MONITOR_TYPE_VGA;
                                Count++;
                            }
                            pInfo->ulHeadDeviceOptions[i] |= HEAD_DEVICE_OPTION_CRT;
                        }
                    }

                    // See if DFP is connected
                    {
                        NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS FPInfo;

                        FPInfo.Head = i;
                        FPInfo.FlatPanelConnected = 0;
                        if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference,
                             NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI, &FPInfo, 
                             sizeof(NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS))) 
                        {
                             VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_FLATPANEL_INFO_MULTI\n"));
                             bRet = FALSE;
                             break;
                        }
                        if (FPInfo.FlatPanelConnected == 1)
                        {
                            if (pInfo->ulDeviceType[i] == INVALID_DEVICE_TYPE) 
                            {
                                pInfo->ulDeviceType[i] = MONITOR_TYPE_FLAT_PANEL;
                                Count++;
                            }
                            pInfo->ulHeadDeviceOptions[i] |= HEAD_DEVICE_OPTION_DFP;
                        }
                    }
                    

                    // See if TV is connected.
                    {
                        NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
                        ULONG TVType;
                        TVInfo.Head = i;
                        TVInfo.TVConnected = 0;
                        if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference,
                                NV_CFGEX_GET_TV_ENCODER_INFO_MULTI, &TVInfo, 
                                sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS))) 
                        {
                            VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_TV_ENCODER_INFO_MULTI\n"));
                            bRet = FALSE;
                            break;
                        }
                        if (TVInfo.TVConnected == 1)
                        {
                            if (pInfo->ulDeviceType[i] == INVALID_DEVICE_TYPE) 
                            {
                                Count++;
                                // Detect a PAL or NTSC tv type.
                                // BUGBUG: Per Terry, ResMan can not detect
                                // a TV type. So lets assume a NTSC type.
                                pInfo->ulTVFormat[i] = NTSC_M;
                                pInfo->ulDeviceType[i] = MONITOR_TYPE_NTSC;
                            }
                            pInfo->ulHeadDeviceOptions[i] |= HEAD_DEVICE_OPTION_TV;
                        }
                    } // Detect TV
                } // for each DAC

                if (bRet == TRUE) 
                {
                    // Now for the case when the ResMan could not detect any monitors because the monitors are non-EDID or
                    // connected through a moniport port such as Omni-port.
                    // We will assume one monitor is connected in this case (for both single headed and dual headed 
                    // boards).
                    if (Count == 0)
                    {
                        VideoDebugPrint((0,"OOops! ResMan could not detect any connected monitors. So assume CRT connected to head 0\n"));
                        pInfo->ulNumberDacsOnBoard = 1;
                        pInfo->ulNumberDacsConnected = 1;
                        pInfo->ulAllDeviceMask = BITMASK_CRT0;
                        pInfo->ulConnectedDeviceMask = BITMASK_CRT0;
                        pInfo->ulDeviceMask[0] = BITMASK_CRT0;
                        pInfo->ulDeviceType[0] = MONITOR_TYPE_VGA;
                        pInfo->ulHeadDeviceOptions[0] = HEAD_DEVICE_OPTION_CRT;
                    }
                    else
                    {
                        pInfo->ulNumberDacsConnected = Count;
                    }
                    // Print the info collected
                    VideoDebugPrint((0,"DacsOnBoard: %d, DacsConnected: %d, AllDeviceMask: 0x%x, ConnectedDeviceMask: 0x%x,DeviceMask: (0x%x, 0x%x), DeviceType: (0x%x, 0x%x), DeviceOptions: (0x%x, 0x%x)\n",
                        pInfo->ulNumberDacsOnBoard, pInfo->ulNumberDacsConnected,pInfo->ulAllDeviceMask,  pInfo->ulConnectedDeviceMask,  
                        pInfo->ulDeviceMask[0],pInfo->ulDeviceMask[1],
                        pInfo->ulDeviceType[0],pInfo->ulDeviceType[1],
                        pInfo->ulHeadDeviceOptions[0],pInfo->ulHeadDeviceOptions[1]));
                }
            } // NumDacsOnBoard == 2



        }


    VideoDebugPrint((2,"Number of heads on board returning to display driver: 0x%x, number connected: 0x%x\n",
        pInfo->ulNumberDacsOnBoard,pInfo->ulNumberDacsConnected));

    //
    // Now read the EDID for all the heads.
    // Get the EDID buffer from the RM always.
    //
    i = (LONG)pInfo->ulNumberDacsOnBoard;

    /* for some unknown reasons, probably because the resman doesn't restore some registers correctly, doing the
        scan from head 0 to 1 will cause garbage on the CRT after updating from vga to nv driver as well as causing
        win2k system hang when switching mode in twinview, 20000707-112729, 20000812-121158
        and 20000725-202707.
     */
    while (--i >= 0)
    {
        ULONG ulHead;
        NV_CFGEX_GET_EDID_MULTI_PARAMS EdidParams;
        ULONG EdidBufferSize;



        // Get the mapped head. Do not use the ulCurentDac here as we are cycling
        // through the heads.

        ulHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
        HwDeviceExtension->EDIDBufferValid[ulHead] = 0;
        HwDeviceExtension->EDIDBufferSize[ulHead] = 0;
        EdidBufferSize = 0;

        switch (pInfo->ulDeviceType[ulHead]) 
        {
        case MONITOR_TYPE_VGA:
            EdidBufferSize          = EDID_V2_SIZE;
            EdidParams.displayType  = DISPLAY_TYPE_MONITOR;
            EdidParams.Head  = ulHead;
            
            EdidParams.edidBuffer   = (UCHAR *) &(HwDeviceExtension->EDIDBuffer[ulHead][0]);
            EdidParams.bufferLength = &EdidBufferSize;
            if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_GET_EDID_MULTI, &EdidParams, sizeof(NV_CFGEX_GET_EDID_MULTI_PARAMS) ))
            {
                VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_EDID for head: 0x%x, deviceType: 0x%x\n", 
                                 ulHead, pInfo->ulDeviceType[ulHead]));
                bRet = FALSE;
            }
            else
            {
                HwDeviceExtension->EDIDBufferValid[ulHead] = 1;
                HwDeviceExtension->EDIDBufferSize[ulHead] = EdidBufferSize;
            }
            break;

        case MONITOR_TYPE_FLAT_PANEL:
            EdidBufferSize          = EDID_V2_SIZE;
            EdidParams.displayType  = DISPLAY_TYPE_FLAT_PANEL;
            EdidParams.Head  = ulHead;
            
            EdidParams.edidBuffer   = (UCHAR *) &(HwDeviceExtension->EDIDBuffer[ulHead][0]);
            EdidParams.bufferLength = &EdidBufferSize;
            if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_GET_EDID_MULTI, &EdidParams, sizeof(NV_CFGEX_GET_EDID_MULTI_PARAMS) ))
            {
                VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_EDID for head: 0x%x, deviceType: 0x%x\n", 
                                 ulHead, pInfo->ulDeviceType[ulHead]));
                bRet = FALSE;
            }
            else
            {
                HwDeviceExtension->EDIDBufferValid[ulHead] = 1;
                HwDeviceExtension->EDIDBufferSize[ulHead] = EdidBufferSize;
            }
            break;

        case MONITOR_TYPE_NTSC:
        case MONITOR_TYPE_PAL:
            // No EDID for TV.
            HwDeviceExtension->EDIDBufferValid[ulHead] = 0;
            HwDeviceExtension->EDIDBufferSize[ulHead] = 0;
            
            break;

        case INVALID_DEVICE_TYPE:
            // We could not detect any connected output device on this head so don't try reading the EDID
            HwDeviceExtension->EDIDBufferValid[ulHead] = 0;
            break;

        default:
            VideoDebugPrint((0,"OOops! NVInitialize_DacsAndEDID(): Invalid device type: 0x%x for MappedHead: 0x%x.\n",
                             pInfo->ulDeviceType[ulHead],ulHead));
            VideoDebugPrint((0,"No EDID being read for this head\n"));
            HwDeviceExtension->EDIDBufferValid[ulHead] = 0;
            HwDeviceExtension->EDIDBufferSize[ulHead] = 0;
            bRet = FALSE;
            break;
        } // switch deviceType

        // Write the EDID data to the registry for our own debug purposes.
        if (ulHead == 0)
        {
            VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"Head0_EDID_Buffer",
                                      &(HwDeviceExtension->EDIDBuffer[ulHead][0]),
                                      HwDeviceExtension->EDIDBufferSize[ulHead]);
            // Write the device type also for reference
            VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"Head0_EDID_DevType",
                                      &(pInfo->ulDeviceType[ulHead]),
                                      sizeof(ULONG));
        }
        if (ulHead == 1)
        {
            VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"Head1_EDID_Buffer",
                                      &(HwDeviceExtension->EDIDBuffer[ulHead][0]),
                                      HwDeviceExtension->EDIDBufferSize[ulHead]);
            // Write the device type also for reference
            VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"Head1_EDID_DevType",
                                      &(pInfo->ulDeviceType[ulHead]),
                                      sizeof(ULONG));
        }
    } // for each dac.
    
    return(bRet);
}




//
// Returns TRUE if the device list is successfully scanned
//
BOOLEAN bScanHeadDeviceOptions(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG Head;
    LONG i;
    ULONG Head0Connected = FALSE, Head1Connected = FALSE;

    i = (LONG)HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard;

    /* for some unknown reasons, probably because the resman doesn't restore some registers correctly, doing the
        scan from head 0 to 1 will cause garbage on the CRT after updating from vga to nv driver as well as causing
        win2k system hang when switching mode in twinview, 20000707-112729, 20000812-121158
        and 20000725-202707.
   */
    while (--i >= 0)
    {
            Head = (ULONG)i;

            // Clear the flags first.
            HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[Head] = 0;

            // See if CRT is connected.
            {
                NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS MonitorInfo;

                MonitorInfo.Head = Head;
                MonitorInfo.MonitorConnected = 0;
                if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                  NV_CFGEX_GET_MONITOR_INFO_MULTI, &MonitorInfo, sizeof(NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS))) 
                {
                    VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_MONITOR_INFO_MULTI\n"));
                }
                if (MonitorInfo.MonitorConnected == 1)
                {
                    HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[Head] |= HEAD_DEVICE_OPTION_CRT;
                    if (i == 0)
                    {
                        Head0Connected = TRUE;
                    }
                    if (i == 1)
                    {
                        Head1Connected = TRUE;
                    }
                    
                }
            }
            
            // See if DFP is connected
            {
                NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS FPInfo;

                FPInfo.Head = Head;
                FPInfo.FlatPanelConnected = 0;
                if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                  NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI, &FPInfo, sizeof(NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS))) 
                {
                    VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_FLATPANEL_INFO_MULTI\n"));
                }
                if (FPInfo.FlatPanelConnected == 1)
                {
                    HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[Head] |= HEAD_DEVICE_OPTION_DFP;
                    if (i == 0)
                    {
                        Head0Connected = TRUE;
                    }
                    if (i == 1)
                    {
                        Head1Connected = TRUE;
                    }
                }
            }

            // See if TV is connected.
            {
                NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
                ULONG TVType;
                TVInfo.Head = Head;
                TVInfo.TVConnected = 0;
                if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                  NV_CFGEX_GET_TV_ENCODER_INFO_MULTI, &TVInfo, sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS))) 
                {
                    VideoDebugPrint((0, "oops!! RmConfigGetExKernel() returned error for NV_CFGEX_GET_TV_ENCODER_INFO_MULTI\n"));
                }
                if (TVInfo.TVConnected == 1)
                {
                    HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[Head] |= HEAD_DEVICE_OPTION_TV;
                    if (i == 0)
                    {
                        Head0Connected = TRUE;
                    }
                    if (i == 1)
                    {
                        Head1Connected = TRUE;
                    }
                } // if TVConnected == 1
            } // see if TV is connected
    } // for each head.

    if (Head0Connected == TRUE && Head1Connected == TRUE)
    {
        HwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = 2;
    }
    if (Head0Connected == TRUE && Head1Connected == FALSE)
    {
        HwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = 1;
    }
    if (Head0Connected == FALSE && Head1Connected == TRUE)
    {
        HwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = 1;
    }
    if (Head0Connected == FALSE && Head1Connected == FALSE)
    {
        VideoDebugPrint((0,"Oops! Neither Head0 nor Head1 is connected! Assume NumberDacsConnected as 1\n"));
        HwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = 1;
    }

    // Just some safety valves for the worst case scenario where we don't detect any output devices
    if (HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 1)
    {
        if (HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[0] == 0)
        {
            VideoDebugPrint((0,"Oops! Head: 0 has no detected device options. Set it for CRT\n"));
                HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[0] = HEAD_DEVICE_OPTION_CRT;
        }
    }
    if (HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 2)
    {
        if (HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[0] == 0 && 
            HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[1] == 0)
        {
            VideoDebugPrint((0,"Oops! Head0 and Head1 have no detected device options. Set it for CRT\n"));
                HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[0] = HEAD_DEVICE_OPTION_CRT;
                HwDeviceExtension->DeskTopInfo.ulHeadDeviceOptions[1] = HEAD_DEVICE_OPTION_CRT;
        }
    }
   
    return(TRUE);
} // End function bScanHeadDeviceOptions()

#endif ENABLE_HEAD_API


//
// This function should be called once at boot time.
// It initializes the DeskTopInfo structure to safe values.
//
BOOLEAN NVOneTimeInit_TwinView(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG i, Count = 0;
    BOOLEAN bRet = TRUE;
    NV_DESKTOP_INFO * pInfo;

    VideoDebugPrint((2, "NVOneTimeInit_TwinView():\n"));

    
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    pInfo->ulDesktopModeIndex = 0;

    pInfo->ulDesktopMode = 0;
    pInfo->ulNumberDacsOnBoard = 1;
    pInfo->ulNumberDacsConnected = 1;
    pInfo->ulNumberDacsActive = 1;
    pInfo->ulAllDeviceMask = BITMASK_CRT0;
    pInfo->ulConnectedDeviceMask = BITMASK_CRT0;

    pInfo->ulDesktopWidth = 640;
    pInfo->ulDesktopHeight = 480;

    for(i = 0; i < NV_NO_DACS; i++)
    {
        pInfo->ulDisplayWidth[i] = 640;
        pInfo->ulDisplayHeight[i] = 480;
        pInfo->ulDisplayRefresh[i] = 60;
        pInfo->ulDisplayPixelDepth[i] = 8;
        pInfo->ulDeviceDisplay[i] = i;
        pInfo->ulDeviceMask[i] = BITMASK_CRT0;
        pInfo->ulDeviceType[i] = MONITOR_TYPE_VGA;
        pInfo->ulTVFormat[i] = 0;
    }
    return(bRet);
}


//
// Returns the number and list of physical modes for the specified head.
// The following filters are applied
// 1. PixelClockFrequency of the specified head. Note if ulHead is 1 and ulDeviceType is CRT, then the 
//  pixelFreq of Head1 (150MHZ) is used. For other device types (DFP,TV) the head0's (350MHZ) pixel freq is used.
// 2. If a MonitorModeList is found, use this list (after filtering against the pixelFreq) and Return.
// 3. If ulEnableDDC is enabled, then parse the EDID for this to get the modes.
//
BOOLEAN  GetHeadPhysicalModeList(
    PHW_DEVICE_EXTENSION HwDeviceExtension, 
    HEAD_MODE_LIST_INFO * pInput,
    ULONG * pRetSize)
{
    ULONG ulHead;
    ULONG ulEnableDDC;
    MODE_ENTRY *MonitorModeList, *VirtualModeList;
    ULONG NumMonitorModes, NumVirtualModes, NumValidModes;
    MODE_ENTRY *DestPtr;
    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;
    ULONG ulRet, i, j;
    BOOLEAN bFoundMatchInVirtualList;
    ULONG ulHeadEDID;

    VideoDebugPrint((3,"Enter GetHeadPhysicalModeList()\n"));

    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;
    

    ulHead = pInput->ulHead;
    ulEnableDDC = pInput->ulEnableDDC;
    
    #ifdef ENABLE_HEAD_API
    ulHeadEDID =  ConvertDeviceMaskToIndex(pInput->ulDeviceMask);
    #else
    ulHeadEDID = ulHead;
    #endif
    

    
    // If the device type is TV, w simply return the virtual mode list with only
    // 640x480 and 8000x600 for all color depths at only 60HZ
    if (pInput->ulDeviceType == MONITOR_TYPE_NTSC || pInput->ulDeviceType == MONITOR_TYPE_PAL)
    {
        DestPtr = pInput->pPhysicalModeList;
        VirtualModeList = pInput->pVirtualModeList;

        NumVirtualModes = pInput->ulNumVirtualModes;
        NumValidModes = NumVirtualModes;
        for (i=0; i < NumVirtualModes; i++)
        {

            if (VirtualModeList->Width > 800 || VirtualModeList->Height > 600 || VirtualModeList->RefreshRate != 60)
            {
                // Not a valid mode.
                NumValidModes--;
                VirtualModeList++;
                continue;
            }
            // The mode passes all filters.
            // Copy this valid mode and process the next mode from the monitor modelist.
            if (DestPtr)
            {
                *DestPtr++ = *VirtualModeList++;
            }
            else
            {
                VirtualModeList++;
            }
            
        }
        *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
        return(TRUE);
    }

    // Set up the generic fields required for the FindModeEntry() call.
    //
    // Check if CRT is connected for second head. Only then should we
    // use the pixel clock for the second head. Otherwise, we should use the pixel clock of
    // DAC 0 for both heads.
    //
    ulFrequencyHead = ulHead;
    if (ulHead == 1 && pInput->ulDeviceType != MONITOR_TYPE_VGA) {
         ulFrequencyHead = 0;
    }
    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwCRTCIndex = ulHead;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;

    
    // Read in the monitor restriction mode lists for each head.
    ReadMonitorRestrictionModeList(HwDeviceExtension);

    
    // use the right monitor mode list entry for this head.
    switch (ulHead)
    {
        case 0:
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable0[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes0;
            break;
        case 1:
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable1[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes1;
            break;
        default:
            VideoDebugPrint((0,"Oops! Invalid Head: 0x%x\n",ulHead));
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable0[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes0;
            break;
    }

    
 
    // If the monitor mode list is present, then we simply return this mode list for this head.
    // We do not bother about EDID for this case.
    if (NumMonitorModes != 0)
    {
        DestPtr = pInput->pPhysicalModeList;
        
        NumVirtualModes = pInput->ulNumVirtualModes;
        NumValidModes = NumMonitorModes;
        for (i=0; i < NumMonitorModes; i++)
        {
            VirtualModeList = pInput->pVirtualModeList;
            bFoundMatchInVirtualList = FALSE;
            // First validate against the virtual mode list.
            for (j=0; j < NumVirtualModes; j++)
            {
                if (VirtualModeList->Width == MonitorModeList->Width &&
                    VirtualModeList->Height == MonitorModeList->Height &&
                    VirtualModeList->Depth == MonitorModeList->Depth &&
                    VirtualModeList->RefreshRate == MonitorModeList->RefreshRate &&
                    MonitorModeList->ValidMode)
                {
                    bFoundMatchInVirtualList = TRUE;
                    break;
                }
                VirtualModeList++;

            }
            // If we did not find a match for this specified mode in the virtual mode list, this mode is not valid.
            if (bFoundMatchInVirtualList == FALSE)
            {
                // Not a valid mode.
                NumValidModes--;
                MonitorModeList++;
                continue;
            }

            // Now validate against the pixel frequency of the head.
            lpModeDesc->dwXRes = MonitorModeList->Width;
            lpModeDesc->dwYRes = MonitorModeList->Height;
            lpModeDesc->dwBpp = MonitorModeList->Depth;
            lpModeDesc->dwRefreshRate = MonitorModeList->RefreshRate;
            lpModeDesc->dwOriginalRefreshRate = MonitorModeList->RefreshRate;
            lpModeDesc->dwDevType = pInput->ulDeviceType;
            lpModeDesc->dwTVFormat = pInput->ulTVType;
            // We want to ignore the EDID since we are using the explicit monitor mode list.
            lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
            // Call the modeset DLL to see if this mode is valid.
            // We are not interested in the mode timings but just to see if this is a valid mode.
            VideoDebugPrint((3,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));

            ulRet = FindModeEntry(lpDispData, &(HwDeviceExtension->EDIDBuffer[ulHeadEDID][0]), 
                                  HwDeviceExtension->EDIDBufferSize[ulHeadEDID], lpModeDesc, lpModeOut, lpModeNew);
            VideoDebugPrint((3,"ulRet: 0x%x\n",ulRet));
            VideoDebugPrint((3,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
            VideoDebugPrint((3,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

            if (ulRet != 0)
            {
                // Not a valid mode.
                NumValidModes--;
                MonitorModeList++;
                continue;
            }
            

            // The mode passes all filters.
            // Copy this valid mode and process the next mode from the monitor modelist.
            if (DestPtr)
            {
                *DestPtr++ = *MonitorModeList++;
            }
            else
            {
                MonitorModeList++;
            }
        }
        *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
        return(TRUE);
    }

    //
    // There is no specified monitor mode list for this head.
    // Now see if we need to parse the EDID.
    //
    if (pInput->ulEnableDDC)
    {
        // There is no monitor mode list for this head and DDC is enabled by the user for this head.
        // So we need to filter against pixel clock freq and EDID.
        if (HwDeviceExtension->EDIDBufferValid[ulHeadEDID])
        {
            lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
        }
        else
        {
            lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
        }
    }
    else
    {
        // There is no monitor mode list for this head and DDC is disabled by the user for this head.
        // So we need to filter against pixel clock freq only.
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
        // BUGBUG: I am assuming that just setting the UNKNOWN_DEVICE is sufficient while still passing
        // in the EDID and EDIDSize into FindModeEntry().
    }
    // The user does not want EDID detection for this head.
    // We need to only do the filtering of all virtual list modes against the pixel clock.

    DestPtr = pInput->pPhysicalModeList;
    VirtualModeList = pInput->pVirtualModeList;

    NumVirtualModes = pInput->ulNumVirtualModes;
    NumValidModes = NumVirtualModes;
    for (i=0; i < NumVirtualModes; i++)
    {

        // Now validate against the pixel frequency of the head.
        lpModeDesc->dwXRes = VirtualModeList->Width;
        lpModeDesc->dwYRes = VirtualModeList->Height;
        lpModeDesc->dwBpp = VirtualModeList->Depth;
        lpModeDesc->dwRefreshRate = VirtualModeList->RefreshRate;
        lpModeDesc->dwOriginalRefreshRate = VirtualModeList->RefreshRate;
        lpModeDesc->dwDevType = pInput->ulDeviceType;
        lpModeDesc->dwTVFormat = pInput->ulTVType;
        // Call the modeset DLL to see if this mode is valid.
        // We are not interested in the mode timings but just to see if this is a valid mode.
        VideoDebugPrint((3,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                         lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));

        ulRet = FindModeEntry(lpDispData, &(HwDeviceExtension->EDIDBuffer[ulHeadEDID][0]), 
                              HwDeviceExtension->EDIDBufferSize[ulHeadEDID], lpModeDesc, lpModeOut, lpModeNew);
        VideoDebugPrint((3,"ulRet: 0x%x\n",ulRet));
        VideoDebugPrint((3,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
            lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
            lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
        VideoDebugPrint((3,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
            lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
            lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

        if (ulRet != 0)
        {
            // Not a valid mode.
            NumValidModes--;
            VirtualModeList++;
            continue;
        }


        // The mode passes all filters.
        // Copy this valid mode and process the next mode from the monitor modelist.
        if (DestPtr)
        {
            *DestPtr++ = *VirtualModeList++;
        }
        else
        {
            VirtualModeList++;
        }
    }
    *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
    return(TRUE);
 
}



//
// This function initializes the mapping layer between Win2K's power states and nVidia's power states
//
VOID InitializeACPIStates(
    PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    BOOL bRet;
    ULONG Caps, ulHead;
    ULONG HighestNVAdapterState, i;

    ulHead = 0;

    //
    // Note, at this point in time, it does not matter if we have actually done a modeset to the head or
    // not. Anyways, we support only two states for monitors. Its the capabilities of the adapter we
    // need to get.
    //
    bRet = RmGetPowerCaps(HwDeviceExtension->DeviceReference, ulHead, &Caps);

    //
    // Initialize the monitor power states
    //
    for (i=0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard; i++ )
    {
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerOn] = NV_POWER_MONITOR_STATE_0;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerStandBy] = NV_POWER_MONITOR_STATE_1;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerSuspend] = NV_POWER_MONITOR_STATE_1;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerOff] = NV_POWER_MONITOR_STATE_1;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerHibernate] = NV_POWER_MONITOR_STATE_1;            
    }

    //
    // Search for the highest supported adapter power state
    //
    if ((Caps & NV_POWER_ADAPTER_STATE_3) &&
        (Caps & NV_POWER_ADAPTER_STATE_1) &&
        (Caps & NV_POWER_ADAPTER_STATE_0))
    {
        //
        // This is the case for the desktop.
        //
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn] = NV_POWER_ADAPTER_STATE_0;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy] = NV_POWER_ADAPTER_STATE_1;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend] = NV_POWER_ADAPTER_STATE_3;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff] = NV_POWER_ADAPTER_STATE_3;            
        // We support the hibernate state only if the "context save" feature is turned on.
        // If this feature is turned on, we assume that the highest numbered state (3 in this case)
        // will support this context save feature
        if (Caps & NV_POWER_ADAPTER_FEATURE_CTXSAVED)
        {
            HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_3;            
        }
        else
        {
            HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = 0; // not supported
        }
        return;
    }

    if ((Caps & NV_POWER_ADAPTER_STATE_3) &&
        (Caps & NV_POWER_ADAPTER_STATE_2) &&
        (Caps & NV_POWER_ADAPTER_STATE_0))
    {
        //
        // This is the case for the laptop.
        //
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn] = NV_POWER_ADAPTER_STATE_0;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy] = NV_POWER_ADAPTER_STATE_2;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend] = NV_POWER_ADAPTER_STATE_2;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff] = NV_POWER_ADAPTER_STATE_2;            
        // We support the hibernate state only if the "context save" feature is turned on.
        // If this feature is turned on, we assume that the highest numbered state (3 in this case)
        // will support this context save feature
        if (Caps & NV_POWER_ADAPTER_FEATURE_CTXSAVED)
        {
            HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_3;            
        }
        else
        {
            HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = 0; // not supported
        }
        return;
    }
}

//
// Returns the index from the device mask.
// Input: A 32bit bitmask with only one of the 32bits set specifying a unique device
// Return Value: Index of this bitmask
//      For example: 
//      input: 0x4, Return: 2
//      input: 0x20, Return: 5
//      input: 0x1, Return: 0
//      input: 0x0, Return: 0
//
ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask)
{
    ULONG i;
    ULONG ulTmp;
    ulTmp = ulDeviceMask;

  
    i=0;
    for (;;)
    {
        if (ulTmp == 0)
        {
            VideoDebugPrint((0,"Oops! ConvertDeviceMaskToIndex(): Invalid ulDeviceMask: 0x%x\n",ulDeviceMask));
            return(0);
        }
        if (ulTmp & 0x1)
        {
            return(i);
        }
        // shift right by one and increment the index
        ulTmp >>= 1;
        i++;
    }
    
}

//
// Returns the number of bits that are set in the mask.
// 
ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask)
{
    ULONG i, NumDevices, ulDeviceMask;
    NumDevices = 0;
    for(i=0; i < NV_NO_CONNECTORS; i++)
    {
        ulDeviceMask = (1 << i);
        if(ulConnectedDeviceMask & ulDeviceMask)
        {
            NumDevices++;
        }
    }
    return(NumDevices);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\ntnvreg.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/



//******************************************************************************
// Common typedefs
//******************************************************************************

typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

//******************************************************************************
// Type of REGISTRY entry
//******************************************************************************

#define IS_BINARY       0
#define IS_STRING       1
#define IS_DWORD        2

//******************************************************************************
// REGISTRY data length max values
//******************************************************************************

#define REG_STRING_DATA_MAX 30

//******************************************************************************
// Maximum number of NV registry switches
//******************************************************************************

#define MAX_NV_REGISTRY_SWITCHES   100

//******************************************************************************
// Dword value used to IGNORE the presence of the registry switch
//******************************************************************************

#define IGNORE_REGISTRY_SWITCH     0x99999999

//******************************************************************************
// NT Registry Switches:
// ====================
//
// The implementation of NT registry keys are different than Win9x,
// since NT is more restricted when it comes to setting values in its registry.
// Essentially, for NT, we only use a 'flat' registry structure, as opposed to 
// several different keys (directory structure) in Win9x.
//  
// For Win9x, the registy keys and values are stored under 
//          \HKEY_LOCAL_MACHINE\SOFTWARE\NVIDIA Corporation\Riva TNT\
// 
// For WinNT, the registry values are all stored under 
//          \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\nv\DeviceXX
//
// Even though the implementation is different on NT, we'll attempt to keep the
// registry functionality as close to Win9x as possible.
//
//
// NOTE: Since OPENGL is NOT part of the NT display driver (it'a separate DLL),
//       it can read the registry by itself, and does NOT have its registry
//       switches in the same location as all the switches.
//       It's switches are still located in .\Software\NVIDIA Corporation\Riva TNT\
//
//
//      Please Refer to NVREG.H in the \drivers\common\inc directory to
//              see how this structure was obtained
//
//******************************************************************************

typedef struct _NT_NV_REGISTRY_SWITCH_OFFSET
    {
    U032    RegType;
    U008    RegName[REG_STRING_DATA_MAX];
    U032    Offset;
    } NT_NV_REGISTRY_SWITCH_OFFSET;


typedef struct _NT_NV_REGISTRY_DISPLAY
    {
    U008    LastDisplayDevice[REG_STRING_DATA_MAX];     // String
    U008    LastCRTMode[REG_STRING_DATA_MAX];           // String
    U008    LastDFPMode[REG_STRING_DATA_MAX];           // String
    U008    LastNTSCMode[REG_STRING_DATA_MAX];          // String
    U008    LastPALMode[REG_STRING_DATA_MAX];           // String
    U008    CRTMode[REG_STRING_DATA_MAX];               // String
    U008    DFPMode[REG_STRING_DATA_MAX];               // String
    U008    NTSCMode[REG_STRING_DATA_MAX];              // String
    U008    PALMode[REG_STRING_DATA_MAX];               // String
    U008    DefaultCRTRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    DefaultDFPRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    OptimalCRTRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    OptimalDFPRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    DisplayDeviceType[REG_STRING_DATA_MAX];     // String
    U008    MonitorTiming[REG_STRING_DATA_MAX];         // String
    U032    DisplayType;                                // Dword
    U032    TVType;                                     // Dword
    U032    CursorAlpha;                                // Dword
    } NT_NV_REGISTRY_DISPLAY;

typedef struct _NT_NV_REGISTRY_DIRECTDRAW
    {
    U032    VPENABLE;                                   // Dword
    U032    OverlayMode;                                // Dword
    U032    OverlayColorControlEnable;                  // Dword
    U032    OverlayBrightness;                          // Dword
    U032    OverlayContrast;                            // Dword
    U032    OverlayHue;                                 // Dword
    U032    OverlaySaturation;                          // Dword
    U032    OverlayGamma;                               // Dword
    U032    OverlaySharpness;                           // Dword
    } NT_NV_REGISTRY_DIRECTDRAW;


typedef struct _NT_NV_REGISTRY_DIRECT3D
    {
    U032    ANTIALIASENABLE;                            // Dword
    U032    COLORKEYCOMPATABILITYENABLE;                // Dword
    U032    CONTROLTRAFFIC;                             // Dword
    U032    DIRECTMAPENABLE;                            // Dword
    U032    FOGTABLENABLE;                              // Dword
    U032    LOGOENABLE;                                 // Dword
    U032    SCENESYNCENABLE;                            // Dword
    U032    TILINGENABLE;                               // Dword
    U032    USERMIPMAPENABLE;                           // Dword
    U032    VIDEOTEXTUREENABLEENABLE;                   // Dword
    U032    VSYNCENABLE;                                // Dword
    U032    WENABLE;                                    // Dword
    U032    Z24ENABLE;                                  // Dword        
    U032    AAMETHOD;                                   // Dword
    U032    AUTOMIPMAPMETHOD;                           // Dword
    U032    CKREF;                                      // Dword
    U032    DX6ENABLE;                                  // Dword
    U032    ANISOTOPIC4TAP;                             // Dword
    U032    PAL8TEXTURECONVERT;                         // Dword
    U032    PMTRIGGER;                                  // Dword
    U032    TEXELALIGNMENT;                             // Dword
    U032    VALIDATEZMETHOD;                            // Dword
    U032    W16FORMAT;                                  // Dword
    U032    W32FORMAT;                                  // Dword
    U032    AGPTEXCUTOFF;                               // Dword       
    U032    D3DCONTEXTMAX;                              // Dword
    U032    D3DTEXTUREMAX;                              // Dword
    U032    DMAMINPUSHCOUNT;                            // Dword
    U032    LODBIASADJUST;                              // Dword     
    U032    MINVIDEOTEXSIZE;                            // Dword
    U032    MIPMAPLEVELS;                               // Dword       
    U032    PERFSTRATEGY;                               // Dword
    U032    NOVSYNCPREREDNERLIMIT;                      // Dword
    U032    DMAPUSHBUFFERSIZEMAX;                       // Dword
    U032    TEXHEAP;                                    // Dword
    U032    WSCALE16;                                   // Dword
    U032    WSCALE24;                                   // Dword
    
    
    } NT_NV_REGISTRY_DIRECT3D;


typedef struct _NT_NV_REGISTRY_SYSTEM
    {
    U032    Super7Compat;                               // Dword  
    U032    FlipOnHSync;                                // Dword                     
    U032    FilterOverride;                             // Dword                  
    U032    NoNT4AGP;                                   // Dword
    U032    George;                                     // Dword
    U032    Gracie;                                     // Dword
    U032    TVOutOnPrimary;                             // Dword
    U032    Enable256Burst;                             // Dword
    U032    DisableMPCDetect;                           // Dword
    U032    MemoryOverride;                             // Dword
    U032    RTLOverride;                                // Dword
    } NT_NV_REGISTRY_SYSTEM;


typedef struct _NT_NV_REGISTRY_NVTWEAK
    {
    U032    test;                                       // Dword
    } NT_NV_REGISTRY_NVTWEAK;
                     



    //**************************************************************************
    // Complete Registry Structure
    //**************************************************************************


typedef struct _NT_NV_REGISTRY
    {
    //**************************************************************************
    // DISPLAY Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DISPLAY Display;
            
    //**************************************************************************
    // DIRECTDRAW Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DIRECTDRAW DirectDraw;

    //**************************************************************************
    // DIRECT3D Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DIRECT3D Direct3D;

    //**************************************************************************
    // RESMAN Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_SYSTEM System;

    //**************************************************************************
    // NVTWEAK Control Panel Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_NVTWEAK NVTweak;


    } NT_NV_REGISTRY;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\nv.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nv.h
//
// Abstract:
//
//     This module contains the definitions for the code that implements the
//     NVidia NV device driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

//******************************************************************************
// Include IOCTL codes to be shared among all components of driver
//******************************************************************************

#include <dspioctl.h>
#include "ntnvreg.h"

#ifdef NVPE
#include "nvpecntx.h"
#endif // NVPE

#include "nvMultiMon.h"

// Uncomment this line to enable the common modeset code
//#define ENABLE_COMMON_MODESET_CODE

// Uncomment this line to enable exporting the EDID data in nvGetChildDescriptor().
// Terry needs to automatically disble EDID processing when the user wants to switch to spanning modes before
// This code can be enabled.
// #define ENABLE_EXPORTING_EDID_TO_WIN2K

// Uncomment this line to enable the new ResMan power management API code
#define ENABLE_RESMAN_ACPI_CODE

//
// Win2K currently supports 8 different power states as defined in ntddvdeo.h
// We use 16 slots just as a cushion for future additional power states in succeeding
// versions of Win2K.
//
#define MAX_WIN2K_POWER_STATES 16
//
// The only power states of relevance in Win2K currently are on, standby, suspend, off, hibernate
//
#define NV_VideoPowerUnspecified 0
#define NV_VideoPowerOn 1
#define NV_VideoPowerStandBy 2
#define NV_VideoPowerSuspend 3
#define NV_VideoPowerOff 4
#define NV_VideoPowerHibernate 5
#define NV_VideoPowerShutdown 6


//******************************************************************************
// Common typedefs
//******************************************************************************

typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;

typedef unsigned long   BOOL;
typedef long            S032;

#define PHYSICAL_ADDRESS_VALUE(p) ((p).LowPart)

//******************************************************************************
// Polymorphic type stubs for NT4
//******************************************************************************

#if (_WIN32_WINNT < 0x0500)
#define SIZE_T ULONG
#define ULONG_PTR ULONG
#endif // _WIN32_WINNT < 0x0500

//******************************************************************************
// Monitor types  -> Values MUST agree with those from RM !!!
//******************************************************************************

#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3

// Use the following for monitor types. The ones above are obsolete names.
#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

// Use the following for display types. The ones above are obsolete names.
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3

//******************************************************************************
// Our hardcoded defines
//******************************************************************************

#define MAX_CLIP_REGIONS      16
#define MAX_GRPATCH_FANOUT    56
#define MAX_GRPATCH_INPUT     56
#define NUM_PATCHES           10
#define NUM_SUBCHANNELS       8
#define NUM_GRAPHICS_DEVICES  0x1e
#define INVALID               0xffffffff;
#define BIOS_STR_MAX 50

//******************************************************************************
// Size of saved BIOS image (used for manual posting)
//******************************************************************************

#define SAVED_BIOS_IMAGE_SIZE   0x10000

//******************************************************************************
// Bios memory sizing adjust value (for RM Post Device memory sizing)
//******************************************************************************

#define BIOS_MEM_SIZE_ADJUST_FACTOR 0x00010000;

//******************************************************************************
// EDID buffer size (in bytes)
//******************************************************************************

#define EDID_V2_SIZE   256

//******************************************************************************
// Max Size in bytes of saved instance memory (used when powering down)
//******************************************************************************

#define MAX_INSTANCE_MEM_SIZE   0x30000

//******************************************************************************
// Enough memory to store registry data
//
// Set MAX of 30 numbers per mode entry (each line) in INF
// Set MAX of 90  mode entries ( MAX 30 width_height * 3 (for depths))
// Data table will consist of type U016
//
//          Registry Data Format (word values)
//              MAX word values per line = 30 word values
//              MAX of 90 lines (90 mode entries)
//
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           etc...
//******************************************************************************

#define MAX_STRING_REGISTRY_VALUES  30
#define MAX_STRING_REGISTRY_LINES   90
#define MAX_STRING_REGISTRY_DATA_WORDS (MAX_STRING_REGISTRY_VALUES * MAX_STRING_REGISTRY_LINES)

//******************************************************************************
// Enough memory to store valid mode table data
// Set MAX of 1800 mode entries ( MAX 30 width/height * 3 (for depths) * MAX 20 refresh rates)
// Each struct entry  has 5 entries (valid flag, width,height, bpp, refresh)
// Data table will consist of type U016
//******************************************************************************

#define MAX_VALID_MODE_REFRESH_RATES 20
#define MAX_VALID_MODE_TABLE_DATA_WORDS (MAX_STRING_REGISTRY_LINES * MAX_VALID_MODE_REFRESH_RATES * 5)


#define MAX_BIOS_SCAN 1024

//******************************************************************************
// VSync/HSync defines
//******************************************************************************

#define BUFFER_HSYNC_NEGATIVE  0
#define BUFFER_HSYNC_POSITIVE  1

//******************************************************************************
// Memory types
//******************************************************************************

#define NV_BUFFER_SDRAM            0
#define NV_BUFFER_SGRAM            1

//******************************************************************************
// Resolution defines
//******************************************************************************
#define RESOLUTION_640X480      0
#define RESOLUTION_320X240      3
#define RESOLUTION_320X400      6
#define RESOLUTION_400X300      9
#define RESOLUTION_480X360      12
#define RESOLUTION_512X384      15
#define RESOLUTION_640X400      18
#define RESOLUTION_320X200      21
#define RESOLUTION_800X600      24
#define RESOLUTION_960X720      27
#define RESOLUTION_1024X768     30
#define RESOLUTION_1152X864     33
#define RESOLUTION_1280X1024    36
#define RESOLUTION_1600X1200    39
#define RESOLUTION_1800X1440    42
#define RESOLUTION_1920X1080    45
#define RESOLUTION_1920X1200    48

//******************************************************************************
// Various NV Chip ID's
//******************************************************************************

#define NV1_REV_B_02             2
#define NV1_REV_B_03             3
#define NV1_REV_C_01             4
#define NV1_REV_C_02             5
#define NV3_REV_A_00             0
#define NV3_REV_B_00             1
#define NV3_REV_C_00             2


//******************************************************************************
// NV1 Color Format values to be used to generate CONTEXT values
// for STATIC image objects. (Assumes only Destination Buffer 0 enabled)
//******************************************************************************

#define COLOR_FORMAT_X17R5G5B5        0x00000000
#define COLOR_FORMAT_X16A1R5G5B5      0x00002000
#define COLOR_FORMAT_X8R8G8B8         0x00000200
#define COLOR_FORMAT_A8R8G8B8         0x00002200
#define COLOR_FORMAT_X2R10G10B10      0x00000400
#define COLOR_FORMAT_A2R10G10B10      0x00002400
#define COLOR_FORMAT_X24Y8            0x00000600
#define COLOR_FORMAT_X16A8Y8          0x00002600

//******************************************************************************
// NV3 Color Format values to be used to generate CONTEXT values
// for STATIC image objects. (Assumes only Destination Buffer 0 enabled)
// See PGRAPH_CTX_SWITCH register definition for more information.
//******************************************************************************

#define NV3_COLOR_FORMAT_X17R5G5B5        (0x00000000)
#define NV3_COLOR_FORMAT_X16A1R5G5B5      (0x00000008 | 0x00000000)
#define NV3_COLOR_FORMAT_X8R8G8B8         (0x00000001)
#define NV3_COLOR_FORMAT_A8R8G8B8         (0x00000008 | 0x00000001)
#define NV3_COLOR_FORMAT_X2R10G10B10      (0x00000002)
#define NV3_COLOR_FORMAT_A2R10G10B10      (0x00000008 | 0x00000002)
#define NV3_COLOR_FORMAT_X24Y8            (0x00000003)
#define NV3_COLOR_FORMAT_X16A8Y8          (0x00000008 | 0x00000003)
#define NV3_COLOR_FORMAT_Y16                           (0x00000004)


//******************************************************************************
// Monochrome Format values to be used to generate CONTEXT values
// See the CTX_SWITCH register definition for more information (Bit 14)
//******************************************************************************

#define MONO_FORMAT_LE        0x00000000
#define MONO_FORMAT_CGA6      0x00004000

#define NV3_MONO_FORMAT_LE    0x00000000
#define NV3_MONO_FORMAT_CGA6  0x00000100

//******************************************************************************
// NV1 Cursor defines
//******************************************************************************

#define NV1_DAC_CURSOR_TWO_COLOR_XOR    2
#define NV1_DAC_CURSOR_TWO_COLOR        3

//******************************************************************************
// ID values for STATIC image objects
// (Index into the CommonObject array - Currently allow up to 10)
//******************************************************************************

#define IMAGE_SOLID_ID                 0
#define IMAGE_BLACK_RECTANGLE_ID       1
#define IMAGE_PATTERN_ID               2
#define IMAGE_ROP_ID                   3

//******************************************************************************
// ID values for the patches, each is associated with a Rendering object
// (Index into the Render Object array - Currently allow up to 15)
//******************************************************************************

#define RECTANGLE_PATCH                0
#define TRIANGLE_PATCH                 1
#define BLIT_PATCH                     2
#define IMAGE_FROM_CPU_PATCH           3
#define IMAGE_MONO_FROM_CPU_PATCH      4
#define D3DTRIANGLE_PATCH              5
#define CLEARZ_PATCH                   6
#define SRCIMAGE_IN_MEMORY_PATCH       7
#define DSTIMAGE_IN_MEMORY_PATCH       8
#define MEMORY_TO_MEMORY_PATCH         9
#define D3DTRIANGLE_SYSMEM_PATCH       10
#define RENDER_SOLID_LIN_PATCH         11

//******************************************************************************
// Special cased ROP3 operations
//******************************************************************************

#define BLACKNESS 0x0000
#define DSTINVERT 0x0055
#define PATINVERT 0x005A
#define SRCAND    0x0088
#define DSTCOPY   0x00AA
#define SRCCOPY   0x00CC
#define SRCPAINT  0x00EE
#define PATCOPY   0x00F0
#define WHITENESS 0x00FF
//******************************************************************************
// Number of dacs
//******************************************************************************
#define NV_NO_DACS                  2

//******************************************************************************
// maximum Number of output device connectors on a board.
//******************************************************************************
#define NV_NO_CONNECTORS                  24

//******************************************************************************
// Type of video ram
//******************************************************************************

#define BUFFER_DRAM 0
#define BUFFER_VRAM 1

//******************************************************************************
// Page size definitions.
//******************************************************************************
#if defined(_M_IA64)

#define PAGE_SIZE 0x2000

#elif defined(_M_IX86)

#define PAGE_SIZE 0x1000

#endif

//******************************************************************************
// This cursor structure MUST also match the one defined in driver.h
// (in the display driver directory)
//******************************************************************************

typedef struct _TV_CURSOR_ADJUST_INFO
    {
    ULONG   MonitorType;
    ULONG   Underscan_x;
    ULONG   Underscan_y;
    ULONG   Scale_x;
    ULONG   Scale_y;
    ULONG   FilterEnable;
    ULONG   TVCursorMin;
    ULONG   TVCursorMax;
    } TV_CURSOR_ADJUST_INFO;


//******************************************************************************
// Current PRAMIN map: (Currently only 64k is allocated for total PRAMIN size)
//                      in NV3_IsPresent()
//
// Offset   Type of Instance Data
// ======   =====================
//
//          ------------------------------   <--- Start of PRAMIN area
// 0        Hash Table                       ^
//          Run Out                          |
//          Fifo Context                     |
//          Free Instances                   |
//                                           |
//                                           |
//                                           |
//          ------------------------------   |
// 16k                                       |
//                                           |
//                                           |
//                                           |
//                                           |
//                                           |
//                                           |
//          ------------------------------   |----> 64k allocated for PRAMIN
// 32k      VRAM Texture Page Table Entries  |
//          (Used by D3DTriangle Object for  |
//           textures in VRAM)               |
//                                           |
// 42k      SYSMEM Texture Page Table Entreis|
//          (Used by the D3dTriangle Object  |
//           for textures in System Memory)  |
//                                           |
//          ------------------------------   |
// 48k      Cursor data (8 cached images)    |
//          Each bitmap takes up 2k          |
//                                           |
//                                           |
//                                           |
//                                           v
// 64k      ------------------------------
//
//******************************************************************************

//******************************************************************************
// Types of Engine known to FIFO (NV3)
//******************************************************************************

#define ENGINE_SW       0
#define ENGINE_GRAPHICS 1

//******************************************************************************
// Dedicated privileged device ram size in bytes. (NV1)
//******************************************************************************

#define NV_PRAM_DEVICE_SIZE_12_KBYTES   0x3000  // 12KB
#define NV_PRAM_DEVICE_SIZE_20_KBYTES  0x5000   // 20KB
#define NV_PRAM_DEVICE_SIZE_36_KBYTES  0x9000   // 36KB
#define NV_PRAM_DEVICE_SIZE_68_KBYTES  0x11000  // 68KB

//******************************************************************************
// NV3's privileged size, minus audio (NV3)
//******************************************************************************

#define NV_PRAM_DEVICE_SIZE_5_5_KBYTES   0x1600 // 5.5KB
#define NV_PRAM_DEVICE_SIZE_9_5_KBYTES   0x2600 // 9.5KB
#define NV_PRAM_DEVICE_SIZE_17_5_KBYTES  0x4600 // 17.5KB
#define NV_PRAM_DEVICE_SIZE_33_5_KBYTES  0x8600 // 33.5KB

//******************************************************************************
// Offscreen Instance Memory size.
//******************************************************************************

#define NV_PRAM_MIN_SIZE_INSTANCE_MEM  0x1000   // 4KB

#define BUFFER_HSYNC_NEGATIVE           0
#define BUFFER_HSYNC_POSITIVE           1
#define BUFFER_VSYNC_NEGATIVE           0
#define BUFFER_VSYNC_POSITIVE           1
#define BUFFER_CSYNC_DISABLED           0
#define BUFFER_CSYNC_ENABLED            1

//******************************************************************************
// Forward declaration of all structures
//******************************************************************************

typedef struct _def_object                  OBJECT,*POBJECT;
typedef struct _def_common_object           COMMONOBJECT, *PCOMMONOBJECT;
typedef struct _def_render_common           RENDERCOMMON, *PRENDERCOMMON;
typedef struct _def_render_common_object    RENDERCOMMONOBJECT, *PRENDERCOMMONOBJECT;
typedef struct _def_image_blt_object        IMAGEBLITOBJECT, *PIMAGEBLITOBJECT;
typedef struct _def_image_mem_object        IMAGEMEMOBJECT, *PIMAGEMEMOBJECT;
typedef struct _def_render_object           RENDEROBJECT, *PRENDEROBJECT;
typedef struct _def_render_beta_object      RENDERBETAOBJECT, *PRENDERBETAOBJECT;
typedef struct _def_video_object            VIDEOOBJECT, *PVIDEOOBJECT;
typedef struct _def_video_patchcord         VIDEOPATCHCORD, *PVIDEOPATCHCORD;
typedef struct _def_video_switch_object     VIDEOSWITCHOBJECT, *PVIDEOSWITCHOBJECT;
typedef struct _def_ordinal_object          ORDINALOBJECT, *PORDINALOBJECT;
typedef struct _def_video_sink              VIDEOSINKOBJECT, *PVIDEOSINKOBJECT;
typedef struct _def_video_colormap_object   VIDEOCOLORMAPOBJECT, *PVIDEOCOLORMAPOBJECT;
typedef struct _def_image_object            IMAGEOBJECT, *PIMAGEOBJECT;
typedef struct _def_image_patchcord         IMAGEPATCHCORD, *PIMAGEPATCHCORD;
typedef struct _def_image_video_object      IMAGEVIDEOOBJECT, *PIMAGEVIDEOOBJECT;
typedef struct _def_rop_patchcord           ROPPATCHCORD, *PROPPATCHCORD;
typedef struct _def_solid_object            SOLIDOBJECT, *PSOLIDOBJECT;
typedef struct _def_black_rect_object       CLIPOBJECT, *PCLIPOBJECT;
typedef struct _def_pattern_object          PATTERNOBJECT, *PPATTERNOBJECT;
typedef struct _def_rop_object              ROPOBJECT, *PROPOBJECT;
typedef struct _def_beta_object             BETAOBJECT, *PBETAOBJECT;
typedef struct _def_beta_max_object         BETAMAXOBJECT, *PBETAMAXOBJECT;
typedef struct _def_bool_object             BOOLOBJECT, *PBOOLOBJECT;
typedef struct _def_blend_object            BLENDOBJECT, *PBLENDOBJECT;
typedef struct _def_beta_patchcord          BETAPATCHCORD, *PBETAPATCHCORD;
typedef struct _def_stencil_object          STENCILOBJECT, *PSTENCILOBJECT;
typedef struct _def_colorkey_object         COLORKEYOBJECT, *PCOLORKEYOBJECT;
typedef struct _def_plane_mask_object       PLANEMASKOBJECT, *PPLANEMASKOBJECT;
typedef struct _def_fifo                    FIFO, *PFIFO;
typedef struct _def_patch_context           PATCHCONTEXT, *PPATCHCONTEXT;
typedef struct _def_graphics_patch          GRAPHICSPATCH, *PGRAPHICSPATCH;
typedef struct _def_graphics_channel        GRAPHICSCHANNEL, *PGRAPHICSCHANNEL;
typedef struct _def_canvas                  CANVAS, *PCANVAS;
typedef struct _def_node                    NODE, *PNODE;

//******************************************************************************
// Regular Object
//******************************************************************************


struct _def_object
{
    U032       Name;
    U032       ChID;
    U032       ClassType;
};

//******************************************************************************
// Common Object
//******************************************************************************

struct _def_common_object
{
    OBJECT      Base;
    U032        Valid;
    U032        NotifyPending;
    U032        Context;
    U032        Device;
    U032        Instance;           // Useful for NV3 (Uses Instance Addresses)
    PCOMMONOBJECT Next;
    U032        ColorFormat;
    U032        MonoFormat;
};

//******************************************************************************
// Macros to get to the common fields
//******************************************************************************

#define CBase            Common.Base
#define CValid           Common.Valid
#define CNotifyPending   Common.NotifyPending
#define CContext         Common.Context
#define CDevice          Common.Device
#define CInstance        Common.Instance
#define CNext            Common.Next
#define CColorFormat     Common.ColorFormat
#define CMonoFormat      Common.MonoFormat


//******************************************************************************
// BTREE structure.
//******************************************************************************

struct _def_node
{
    U032              Value;
    VOID             *Data;
    U032              LeftCount;
    U032              RightCount;
    struct _def_node *LeftBranch;
    struct _def_node *RightBranch;
} ;

//******************************************************************************
// Canvas
//******************************************************************************

struct _def_canvas
{
    NODE Node;
    U032 CanvasID;
    U032 UsageCount;
    U032 BufferToggle;
    U032 xyMin;
    U032 xyMax;
    U032 ClipCount;
    U032 ClipMisc;
    U032 xyClipMin[MAX_CLIP_REGIONS];
    U032 xyClipMax[MAX_CLIP_REGIONS];
    U032 InOutClip[MAX_CLIP_REGIONS];
    U032 CplxClipCount;
    U032 xyCplxClipMin[2];
    U032 xyCplxClipMax[2];
} ;


//******************************************************************************
// Video Object
//******************************************************************************

struct _def_video_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Video Patchcord
//******************************************************************************

struct _def_video_patchcord
{
    OBJECT       Base;
    PVIDEOOBJECT Source;
    PVIDEOOBJECT Destination;
} ;

//******************************************************************************
// Video Switch Object
//******************************************************************************

struct _def_video_switch_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput[2];
//    VBLANKNOTIFY    VBlankNotify[2];
    PORDINALOBJECT  Ordinal;
    PCANVAS         Canvas;
} ;

//******************************************************************************
// Ordinal Object
//******************************************************************************

struct _def_ordinal_object
{
    OBJECT             Base;
    U032               Value;
    PVIDEOSWITCHOBJECT Switch[MAX_GRPATCH_FANOUT];
    U032               FanOut;
} ;

//******************************************************************************
// Video Sink Object
//******************************************************************************

struct _def_video_sink
{
    OBJECT          Base;
//    PDMAOBJECT      NameXlate;
    PVIDEOPATCHCORD VideoInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Video ColorMap Object
//******************************************************************************

struct _def_video_colormap_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput;
    U032            ColorFormat;
//    PDMAOBJECT      Xlate;
    U032            Start;
    U032            Length;
    U032            DirtyStart;
    U032            DirtyLength;
    U032            ColorMap[256];
} ;

//******************************************************************************
// Image Object
//******************************************************************************

struct _def_image_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Image Patchcord
//******************************************************************************

struct _def_image_patchcord
{
    OBJECT       Base;
    U032         FanOut;
    PIMAGEOBJECT Source;
    PIMAGEOBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Image Video Object
//******************************************************************************

struct _def_image_video_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[MAX_GRPATCH_INPUT];
    PVIDEOPATCHCORD VideoOutput;
//    PDMAOBJECT      NameXlate;
    PCANVAS         Canvas;
    U032            Buffer;
} ;

//******************************************************************************
// ROP Patchcord
//******************************************************************************

struct _def_rop_patchcord
{
    OBJECT      Base;
    U032        FanOut;
    PROPOBJECT  Source;
    PBOOLOBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Solid Object
//******************************************************************************

struct _def_solid_object
{
        COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            Color;
} ;

//******************************************************************************
// Clip Object
//******************************************************************************

struct _def_black_rect_object
{
    COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            xClipMin;
    U032            xClipMax;
    U032            yClipMin;
    U032            yClipMax;
} ;

//******************************************************************************
// Pattern Object
//******************************************************************************

struct _def_pattern_object
{
    COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            PattColor0;
    U032            PattColor0Alpha;
    U032            PattColor1;
    U032            PattColor1Alpha;
    U032            Pattern0;
    U032            Pattern1;
    U032            PatternShape;
} ;

//******************************************************************************
// Rop Object
//******************************************************************************

struct _def_rop_object
{
    COMMONOBJECT  Common;
    PROPPATCHCORD RopOutput;
    U032          Rop3;
} ;


//******************************************************************************
// Beta Object
//******************************************************************************

struct _def_beta_object
{
    COMMONOBJECT   Common;
    PBETAPATCHCORD BetaOutput;
    U032           Beta;
} ;

//******************************************************************************
// Beta Max Object
//******************************************************************************

struct _def_beta_max_object
{
    OBJECT         Base;
    PBETAPATCHCORD BetaOutput;
    PBETAPATCHCORD BetaInput[2];
} ;

//******************************************************************************
// Bool object
//******************************************************************************

struct _def_bool_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[3];
    PROPPATCHCORD     RopInput;
    PROPOBJECT        RopObject;
    PPATTERNOBJECT    PatObject;
    PIMAGEVIDEOOBJECT DstObject;
    U032              Config;
} ;

//******************************************************************************
// Blend Object
//******************************************************************************

struct _def_blend_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[2];
    PBETAPATCHCORD    BetaInput;
    PPATTERNOBJECT    PatObject;
    PCOMMONOBJECT     SrcObject;
    PBETAOBJECT       BetaObject;
    PIMAGEVIDEOOBJECT DstObject;
    U032              Config;
} ;


//******************************************************************************
// Beta Patchcord Object
//******************************************************************************

struct _def_beta_patchcord
{
    OBJECT  Base;
    U032    FanOut;
    POBJECT Source;
    POBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Stencil Object
//******************************************************************************

struct _def_stencil_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[2];
    PCLIPOBJECT     ClipObject;
} ;

//******************************************************************************
// Color Key Object
//******************************************************************************

struct _def_colorkey_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[2];
    PSOLIDOBJECT      ColorObject;
    PIMAGEVIDEOOBJECT DstObject;
} ;

//******************************************************************************
// Plane Mask Object
//******************************************************************************

struct _def_plane_mask_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[3];
    PSOLIDOBJECT      ColorObject;
    PIMAGEVIDEOOBJECT DstObject;
} ;

//******************************************************************************
// Graphics patch context representation,
//
// NOTE: In the RESOURCE MANAGER, this structure mainly consists of POINTERS.
//       But here, we store the actual structures, so we don't have to
//       allocate the memory dynamically.  That is, instead of PROPOBJECT,
//       we use ROPOBJECT instead.  This will take up memory in the
//       HwDeviceExtension structure (which holds all the 'global' values.
//
//******************************************************************************

struct _def_patch_context
{
    U032                 ImageConfig;
    U032                 VideoConfig;
//    PIMAGEVIDEOOBJECT    ImageVideo;
//    PCANVAS              Canvas;
//    PROPOBJECT           Rop;
//    PPATTERNOBJECT       RopPat;
//    PIMAGEVIDEOOBJECT    RopDst;
//    PBETAOBJECT          Beta;
//    PCOMMONOBJECT        BetaSrc;
//    PPATTERNOBJECT       BetaPat;
//    PIMAGEVIDEOOBJECT    BetaDst;
//    PSOLIDOBJECT         ColorKey;
//    PSOLIDOBJECT         PlaneMask;
//    PIMAGEVIDEOOBJECT    PlaneMaskDst;
//    PCLIPOBJECT          Clip;
//    PPATTERNOBJECT       Pattern;
//    PVIDEOCOLORMAPOBJECT ColorMap0;
//    PVIDEOCOLORMAPOBJECT ColorMap1;
//    PVIDEOSWITCHOBJECT   VideoSwitch;

      IMAGEVIDEOOBJECT    ImageVideo;
      CANVAS              Canvas;
      ROPOBJECT           Rop;
      PATTERNOBJECT       RopPat;
      IMAGEVIDEOOBJECT    RopDst;
      BETAOBJECT          Beta;
      COMMONOBJECT        BetaSrc;
      PATTERNOBJECT       BetaPat;
      IMAGEVIDEOOBJECT    BetaDst;
      SOLIDOBJECT         ColorKey;
      SOLIDOBJECT         PlaneMask;
      IMAGEVIDEOOBJECT    PlaneMaskDst;
      CLIPOBJECT          Clip;
      PATTERNOBJECT       Pattern;
      VIDEOCOLORMAPOBJECT ColorMap0;
      VIDEOCOLORMAPOBJECT ColorMap1;
      VIDEOSWITCHOBJECT   VideoSwitch;


} ;

//******************************************************************************
// Render Common Object
//******************************************************************************

struct _def_render_common
{
    PGRAPHICSPATCH  Patch;
    PATCHCONTEXT    PatchContext;
//    PDMAOBJECT      Xlate;
} ;

//******************************************************************************
// Macros to get to the common fields
//******************************************************************************

#define RCPatch            RenderCommon.Patch
#define RCPatchContext     RenderCommon.PatchContext
#define RCXlate            RenderCommon.Xlate


//******************************************************************************
// RenderCommon Object
//******************************************************************************

struct _def_render_common_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
} ;

//******************************************************************************
// Image Blit Object
//******************************************************************************

struct _def_image_blt_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput;
} ;

//******************************************************************************
// ImageMem Object
//******************************************************************************

struct _def_image_mem_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageInputOutput;
} ;

//******************************************************************************
// Render Object
//******************************************************************************

struct _def_render_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
} ;

//******************************************************************************
// Render Beta Object
//******************************************************************************

struct _def_render_beta_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
    PBETAPATCHCORD  BetaOutput;
} ;

//******************************************************************************
// FIFO structure
//******************************************************************************

struct _def_fifo
{
    BOOL    InUse;
    U032    ChID;
//    POBJECT ObjectStack[NUM_SUBCHANNELS];
    ULONG   ObjectStack[NUM_SUBCHANNELS];
    ULONG   SavedChDevInstance[NUM_SUBCHANNELS];
    ULONG   SavedContext[NUM_SUBCHANNELS];
    U032    ObjectCount;
} ;

//******************************************************************************
// Graphics Channel Patch Table
//******************************************************************************

struct _def_graphics_patch
{
    U032                 UsageCount;        // # of objects using this patch c
    U032                 RopUsage;          // # of objects using ROP.
    U032                 BetaUsage;         // # of objects using Beta.
    U032                 ColorKeyUsage;     // # of objects using Color Key.
    U032                 PlaneMaskUsage;    // # of objects using Plane Mask.
    U032                 ClipUsage;         // # of objects using Clip.
    U032                 PatternUsage;      // # of objects using Pattern.
    PGRAPHICSPATCH       Next;
    PRENDERCOMMONOBJECT  XferObject;        // DMA information for graphics.
    PCANVAS              Canvas;            // Associated canvas to this patch
    U032                 xyMinPrev;         // Previous xyMin of canvas.
    U032                 xyMaxPrev;         // Previous xyMax of canvas.
    PVIDEOCOLORMAPOBJECT ColorMap0;         // Associated colormap to buffer 0
    PVIDEOCOLORMAPOBJECT ColorMap1;         // Associated colormap to buffer 1
    PVIDEOSWITCHOBJECT   VideoSwitch;       // Associated video switch.
    PCOMMONOBJECT        UserObjects[NUM_GRAPHICS_DEVICES];
    U032                 AbsX[18];          // Internal state that isn't
    U032                 AbsY[18];          // object specific.  It is
    U032                 XYLogicMisc0;      // restored for whatever
    U032                 XYLogicMisc1;      // object that was last
    U032                 XMisc;             // rendering.
    U032                 YMisc;             // ...
    U032                 CanvasMisc;        // ...
    U032                 MonoColor0;        // ...
    U032                 MonoColor1;        // ...
    U032                 SourceColor;       // ...
    U032                 SubDivide;         // ...
    U032                 EdgeFill;          // ...
    U032                 BetaRam[14];       // ...
    U032                 XAbsIClipMax;      // ...
    U032                 YAbsIClipMax;      // ...
    U032                 Bit33;             // ...
} ;


//******************************************************************************
// Graphics Channel Patch Table
//******************************************************************************

struct _def_graphics_channel
{
    PCOMMONOBJECT  NotifyObject;
    U032           Notify;
    PROPOBJECT     CurrentRop;
    PBETAOBJECT    CurrentBeta;
    PSOLIDOBJECT   CurrentColorKey;
    PSOLIDOBJECT   CurrentPlaneMask;
    PCLIPOBJECT    CurrentClip;
    PPATTERNOBJECT CurrentPattern;
    PGRAPHICSPATCH CurrentPatch;
    PGRAPHICSPATCH PatchList;
    U032           PatchCount;
    U032           Exceptions;
} ;

//******************************************************************************
// Register base macros
//******************************************************************************

#define PMC_Base            HwDeviceExtension->NV1_Lin_PMC_Registers
#define PFB_Base            HwDeviceExtension->NV1_Lin_PFB_Registers
#define PRM_Base            HwDeviceExtension->NV1_Lin_PRM_Registers
#define PDAC_Base           HwDeviceExtension->NV1_Lin_PDAC_Registers
#define PRAM_Base           HwDeviceExtension->NV1_Lin_PRAM_Registers
#define PRAMFC_Base         HwDeviceExtension->NV1_Lin_PRAMFC_Registers
#define PRAMHT_Base         HwDeviceExtension->NV1_Lin_PRAMHT_Registers
#define USER_Base           HwDeviceExtension->NV1_Lin_USER_Registers
#define PFIFO_Base          HwDeviceExtension->NV1_Lin_PFIFO_Registers
#define PBUS_Base           HwDeviceExtension->NV1_Lin_PBUS_Registers
#define PGRAPH_Base         HwDeviceExtension->NV1_Lin_PGRAPH_Registers
#define CONFIG_Base         HwDeviceExtension->NV1_Lin_CONFIG_Registers
#define MEM_Base            HwDeviceExtension->NV1_Lin_MEM_Registers
#define IO_Base             HwDeviceExtension->NV1_Lin_IO_Registers
#define PDMA_Base           HwDeviceExtension->NV1_Lin_PDMA_Registers
#define PTIMER_Base         HwDeviceExtension->NV1_Lin_PTIMER_Registers
#define PAUDIO_Base         HwDeviceExtension->NV1_Lin_PAUDIO_Registers
#define PAUTH_Base          HwDeviceExtension->NV1_Lin_PAUTH_Registers
#define PEXTDEV_Base        HwDeviceExtension->NV1_Lin_PEXTDEV_Registers
#define PEEPROM_Base        HwDeviceExtension->NV1_Lin_PEEPROM_Registers
#define PROM_Base           HwDeviceExtension->NV1_Lin_PROM_Registers
#define PALT_Base           HwDeviceExtension->NV1_Lin_PALT_Registers
#define PRMIO_Base          HwDeviceExtension->NV1_Lin_PRMIO_Registers
#define URECT_Base          HwDeviceExtension->NV1_Lin_URECT_Registers
#define UTRI_Base           HwDeviceExtension->NV1_Lin_UTRI_Registers
#define UBLIT_Base          HwDeviceExtension->NV1_Lin_UBLIT_Registers
#define UIMAGE_Base         HwDeviceExtension->NV1_Lin_UIMAGE_Registers
#define UBITMAP_Base        HwDeviceExtension->NV1_Lin_UBITMAP_Registers
#define PRAMIN_Base         HwDeviceExtension->NV3_Lin_PRAMIN_Registers
#define PRMVIO_Base         HwDeviceExtension->NV3_Lin_PRMVIO_Registers
#define PRMCIO_Base         HwDeviceExtension->NV3_Lin_PRMCIO_Registers
#define PRAMDAC_Base        HwDeviceExtension->NV3_Lin_PRAMDAC_Registers
#define USERDAC_Base        HwDeviceExtension->NV3_Lin_USERDAC_Registers
#define PVIDEO_Base         HwDeviceExtension->NV3_Lin_PVIDEO_Registers

//******************************************************************************
// Device macros
//******************************************************************************


#define GR_DEVICE_INDEX(d)      ((((d)>>16)&0x7F)-0x41)


//******************************************************************************
//
// Save/Restore state macros for graphics engine
//
//******************************************************************************

#define GR_SAVE_STATE(misc)                                                             \
{                                                                                   \
        misc = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_MISC);    \
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC, DRF_DEF(_PGRAPH, _MISC, _FIFO_WRITE, _ENABLED)     \
                        | DRF_DEF(_PGRAPH, _MISC, _FIFO,       _DISABLED));  \
}

#define GR_RESTORE_STATE(misc)                                                          \
{                                                                                   \
        PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_MISC, DRF_DEF(_PGRAPH, _MISC, _FIFO_WRITE, _ENABLED)     \
                              | (DRF_DEF(_PGRAPH, _MISC, _FIFO, _ENABLED) & misc)); \
}

//*************************************************************************
// Graphics Engine DONE and IDLE macros
//*************************************************************************

#define GR_IDLE     while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS))  \
                        {                                                            \
                        V032 pmc;                                                    \
                        pmc = PMC_REG_RD32(PMC_Base,NV_PMC_INTR_0);                  \
                        if (pmc & DRF_DEF(_PMC,_INTR_0,_PGRAPH,_PENDING))            \
                            VideoDebugPrint((0, "Interrupt pending in GR_IDLE"));    \
                        }

#define GR_DONE     while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS));

#define GR_IDLE_NV3 while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS))  \
                        {                                                            \
                        V032 pmc;                                                    \
                        pmc = PMC_REG_RD32(PMC_Base,NV_PMC_INTR_0);                  \
                        if (pmc & DRF_DEF(_PMC,_INTR_0,_PGRAPH0,_PENDING))            \
                            VideoDebugPrint((0, "Interrupt pending in GR_IDLE_NV3"));  \
                        }



//******************************************************************************
//
// Hash table function.
//
//******************************************************************************

#define FIFO_HASH(h,c)  ((((h)^((h)>>8)^((h)>>16)^((h)>>24))&0xFF)^((c)&0x7F))
#define HASH_DEPTH      4
#define HASH_ENTRY(h,d) ((h)*HASH_DEPTH+(d))


//******************************************************************************
//
// NV Reference Manual register access definitions.
//
//******************************************************************************


typedef union _def_HwReg
{
    volatile V008 Reg008[1];
    volatile V016 Reg016[1];
    volatile V032 Reg032[1];
} HWREG, * PHWREG;

// Start using flat register range (instead of using multiple ranges)

#define REG_WR32(a,d)   (HwDeviceExtension->NvRegisterBase)->Reg032[(a)/4]=(U032)(d)
#define REG_RD32(a)     (HwDeviceExtension->NvRegisterBase)->Reg032[(a)/4]
#define REG_WR08(a,d)   (HwDeviceExtension->NvRegisterBase)->Reg008[(a)]  =(U008)(d)
#define REG_RD08(a)     (HwDeviceExtension->NvRegisterBase)->Reg008[(a)]


//#ifdef PC98
#define MEM_WR32(a,d)   fbAddr->Reg032[(a)/4]=(U032)(d)
#define MEM_RD32(a)     fbAddr->Reg032[(a)/4]
//#endif // PC98


#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d) - DEVICE_BASE(d) + 1
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMIN registers (NV3)
//******************************************************************************

#define PRAMIN_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMIN))/4]=(U032)(d)
#define PRAMIN_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMIN))/4]
#define PRAMIN_REG_WR_DRF_NUM(b,d,r,f,n) PRAMIN_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMIN_REG_WR_DRF_DEF(b,d,r,f,c) PRAMIN_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMIN_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMIN_REG_WR32(b,NV##d##r,(PRAMIN_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMIN_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMIN_REG_WR32(b,NV##d##r,(PRAMIN_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMIN_REG_RD_DRF(b,d,r,f)       (((PRAMIN_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
//
// NV Reference Manual INSTANCE MEMORY structure access definitions.
//
//******************************************************************************

#define INST_WR32(b,i,o,d)      PRAMIN_REG_WR32(b,DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o),(d))
#define INST_RD32(b,i,o)        PRAMIN_REG_RD32(b,DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o))
#define SF_OFFSET(sf)           (((0?sf)/32)<<2)
#define SF_SHIFT(sf)            ((0?sf)&31)
#define SF_MASK(sf)             (0xFFFFFFFF>>(31-(1?sf)+(0?sf)))
#define SF_DEF(s,f,c)           ((NV ## s ## f ## c)<<SF_SHIFT(NV ## s ## f))
#define SF_NUM(s,f,n)           (((n)&SF_MASK(NV ## s ## f))<<SF_SHIFT(NV ## s ## f))
#define SF_VAL(s,f,v)           (((v)>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
#define RAM_WR_ISF_NUM(b,i,s,f,n) INST_WR32(b,i,SF_OFFSET(NV ## s ## f),SF_NUM(s,f,n))
#define RAM_WR_ISF_DEF(b,i,s,f,c) INST_WR32(b,i,SF_OFFSET(NV ## s ## f),SF_DEF(s,f,c))
#define FLD_WR_ISF_NUM(b,i,s,f,n) INST_WR32(b,i,SF_OFFSET(NV##s##f),(INST_RD32(b,i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_NUM(s,f,n))
#define FLD_WR_ISF_DEF(b,i,s,f,c) INST_WR32(b,i,SF_OFFSET(NV##s##f),(INST_RD32(b,i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_DEF(s,f,c))
#define RAM_RD_ISF(b,i,s,f)       (((INST_RD32(b,i,SF_OFFSET(NV ## s ## f)))>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))

//******************************************************************************
// Unlike Win95, we don't allocate one pointer to reference the entire
// address space mapped by the NV memory map (32Mb). NT doesn't like us
// taking all this memory.  So what we'll do instead is allocate separate
// chunks of memory for the various classes of registers.  The downside
// is that we can't use the REG_RD and REG_WR macros as is.  We'll need
// to use specific macros for each type of register class.
// The goal is that we want to use all those DEFINES that have already
// been done for us (Instead of having to Re-define the REGISTER BASES)
//
// Format is as follows:
//    b = Base address mapped for this type of register class
//    o = Register Offset address from the base of the NV device (address=0)
//        The correct address will be fixed up as follows:
//        OFFSET_FROM_REGISTER_BASE = OFFSET_FROM_0 - REGISTER_BASE_OFFSET
//
//        For example, OFFSET of NV_PFIFO_INTR_0 = 2100.
//        NEW OFFSET (from register base ) = 2100 - NV_PFIFO = 100
//
// ???? What about performance ?????
// ???? Redefine macros to improve performance ??????
// ???? Does compiler optimize well ?????
//******************************************************************************

//******************************************************************************
// Temporary register range
//******************************************************************************

#define TEMP_REG_WR32(b,d)   (b)->Reg032[0]=(U032)(d)
#define TEMP_REG_RD32(b)     (b)->Reg032[0]

//******************************************************************************
// Macros for NV_CONFIG registers
//******************************************************************************

#define CONFIG_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_CONFIG))/4]=(U032)(d)
#define CONFIG_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_CONFIG))/4]
#define CONFIG_REG_WR_DRF_NUM(b,d,r,f,n) CONFIG_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define CONFIG_REG_WR_DRF_DEF(b,d,r,f,c) CONFIG_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define CONFIG_FLD_WR_DRF_NUM(b,d,r,f,n) CONFIG_REG_WR32(b,NV##d##r,(CONFIG_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define CONFIG_FLD_WR_DRF_DEF(b,d,r,f,c) CONFIG_REG_WR32(b,NV##d##r,(CONFIG_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define CONFIG_REG_RD_DRF(b,d,r,f)       (((CONFIG_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_MEMORY registers
//******************************************************************************

#define MEMORY_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_MEMORY))/4]=(U032)(d)
#define MEMORY_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_MEMORY))/4]
#define MEMORY_REG_WR_DRF_NUM(b,d,r,f,n) MEMORY_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define MEMORY_REG_WR_DRF_DEF(b,d,r,f,c) MEMORY_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define MEMORY_FLD_WR_DRF_NUM(b,d,r,f,n) MEMORY_REG_WR32(b,NV##d##r,(MEMORY_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define MEMORY_FLD_WR_DRF_DEF(b,d,r,f,c) MEMORY_REG_WR32(b,NV##d##r,(MEMORY_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define MEMORY_REG_RD_DRF(b,d,r,f)       (((MEMORY_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_IO registers
//******************************************************************************

#define IO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_IO))/4]=(U032)(d)
#define IO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_IO))/4]
#define IO_REG_WR_DRF_NUM(b,d,r,f,n) IO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define IO_REG_WR_DRF_DEF(b,d,r,f,c) IO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define IO_FLD_WR_DRF_NUM(b,d,r,f,n) IO_REG_WR32(b,NV##d##r,(IO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define IO_FLD_WR_DRF_DEF(b,d,r,f,c) IO_REG_WR32(b,NV##d##r,(IO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define IO_REG_RD_DRF(b,d,r,f)       (((IO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PMC registers
//******************************************************************************

#define PMC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PMC))/4]=(U032)(d)
#define PMC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PMC))/4]
#define PMC_REG_WR_DRF_NUM(b,d,r,f,n) PMC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PMC_REG_WR_DRF_DEF(b,d,r,f,c) PMC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PMC_FLD_WR_DRF_NUM(b,d,r,f,n) PMC_REG_WR32(b,NV##d##r,(PMC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PMC_FLD_WR_DRF_DEF(b,d,r,f,c) PMC_REG_WR32(b,NV##d##r,(PMC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PMC_REG_RD_DRF(b,d,r,f)       (((PMC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PBUS registers
//******************************************************************************

#define PBUS_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PBUS))/4]=(U032)(d)
#define PBUS_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PBUS))/4]
#define PBUS_REG_WR_DRF_NUM(b,d,r,f,n) PBUS_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PBUS_REG_WR_DRF_DEF(b,d,r,f,c) PBUS_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PBUS_FLD_WR_DRF_NUM(b,d,r,f,n) PBUS_REG_WR32(b,NV##d##r,(PBUS_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PBUS_FLD_WR_DRF_DEF(b,d,r,f,c) PBUS_REG_WR32(b,NV##d##r,(PBUS_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PBUS_REG_RD_DRF(b,d,r,f)       (((PBUS_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PFIFO registers
//******************************************************************************

#define PFIFO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PFIFO))/4]=(U032)(d)
#define PFIFO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PFIFO))/4]
#define PFIFO_REG_WR_DRF_NUM(b,d,r,f,n) PFIFO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PFIFO_REG_WR_DRF_DEF(b,d,r,f,c) PFIFO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PFIFO_FLD_WR_DRF_NUM(b,d,r,f,n) PFIFO_REG_WR32(b,NV##d##r,(PFIFO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PFIFO_FLD_WR_DRF_DEF(b,d,r,f,c) PFIFO_REG_WR32(b,NV##d##r,(PFIFO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PFIFO_REG_RD_DRF(b,d,r,f)       (((PFIFO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PDMA registers
//******************************************************************************

#define PDMA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PDMA))/4]=(U032)(d)
#define PDMA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PDMA))/4]
#define PDMA_REG_WR_DRF_NUM(b,d,r,f,n) PDMA_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PDMA_REG_WR_DRF_DEF(b,d,r,f,c) PDMA_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PDMA_FLD_WR_DRF_NUM(b,d,r,f,n) PDMA_REG_WR32(b,NV##d##r,(PDMA_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PDMA_FLD_WR_DRF_DEF(b,d,r,f,c) PDMA_REG_WR32(b,NV##d##r,(PDMA_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PDMA_REG_RD_DRF(b,d,r,f)       (((PDMA_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PTIMER registers
//******************************************************************************

#define PTIMER_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PTIMER))/4]=(U032)(d)
#define PTIMER_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PTIMER))/4]
#define PTIMER_REG_WR_DRF_NUM(b,d,r,f,n) PTIMER_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PTIMER_REG_WR_DRF_DEF(b,d,r,f,c) PTIMER_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PTIMER_FLD_WR_DRF_NUM(b,d,r,f,n) PTIMER_REG_WR32(b,NV##d##r,(PTIMER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PTIMER_FLD_WR_DRF_DEF(b,d,r,f,c) PTIMER_REG_WR32(b,NV##d##r,(PTIMER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PTIMER_REG_RD_DRF(b,d,r,f)       (((PTIMER_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PAUDIO registers
//******************************************************************************

#define PAUDIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PAUDIO))/4]=(U032)(d)
#define PAUDIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PAUDIO))/4]
#define PAUDIO_REG_WR_DRF_NUM(b,d,r,f,n) PAUDIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PAUDIO_REG_WR_DRF_DEF(b,d,r,f,c) PAUDIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PAUDIO_FLD_WR_DRF_NUM(b,d,r,f,n) PAUDIO_REG_WR32(b,NV##d##r,(PAUDIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PAUDIO_FLD_WR_DRF_DEF(b,d,r,f,c) PAUDIO_REG_WR32(b,NV##d##r,(PAUDIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PAUDIO_REG_RD_DRF(b,d,r,f)       (((PAUDIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PGRAPH registers
//******************************************************************************

#define PGRAPH_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PGRAPH))/4]=(U032)(d)
#define PGRAPH_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PGRAPH))/4]
#define PGRAPH_REG_WR_DRF_NUM(b,d,r,f,n) PGRAPH_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PGRAPH_REG_WR_DRF_DEF(b,d,r,f,c) PGRAPH_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PGRAPH_FLD_WR_DRF_NUM(b,d,r,f,n) PGRAPH_REG_WR32(b,NV##d##r,(PGRAPH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PGRAPH_FLD_WR_DRF_DEF(b,d,r,f,c) PGRAPH_REG_WR32(b,NV##d##r,(PGRAPH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PGRAPH_REG_RD_DRF(b,d,r,f)       (((PGRAPH_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRMVIO registers (NV3)
//******************************************************************************

#define PRMVIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMVIO))/4]=(U032)(d)
#define PRMVIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMVIO))/4]
#define PRMVIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMVIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMVIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMVIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMVIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMVIO_REG_WR32(b,NV##d##r,(PRMVIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMVIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMVIO_REG_WR32(b,NV##d##r,(PRMVIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMVIO_REG_RD_DRF(b,d,r,f)       (((PRMVIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

#define PRMVIO_REG_WR08(b,a,d)   (b)->Reg008[(a)-DEVICE_BASE(NV_PRMVIO)]=(U008)(d)
#define PRMVIO_REG_RD08(b,a)     (b)->Reg008[(a)-DEVICE_BASE(NV_PRMVIO)]

#define NV_SR_UNLOCK_VALUE                               0x00000057
#define NV_SR_LOCK_VALUE                                 0x00000099

//******************************************************************************
// Macros for NV_PRMCIO registers (NV3)
//******************************************************************************

#define PRMCIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMCIO))/4]=(U032)(d)
#define PRMCIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMCIO))/4]
#define PRMCIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMCIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMCIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMCIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMCIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMCIO_REG_WR32(b,NV##d##r,(PRMCIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMCIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMCIO_REG_WR32(b,NV##d##r,(PRMCIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMCIO_REG_RD_DRF(b,d,r,f)       (((PRMCIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

#define PRMCIO_REG_WR08(b,o,d)   (b)->Reg008[(o)-DEVICE_BASE(NV_PRMCIO)]=(U008)(d)
#define PRMCIO_REG_RD08(b,o)     (b)->Reg008[(o)-DEVICE_BASE(NV_PRMCIO)]

//******************************************************************************
// Macros for NV_PRAMDAC registers (NV3)
//******************************************************************************

#define PRAMDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMDAC))/4]=(U032)(d)
#define PRAMDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMDAC))/4]
#define PRAMDAC_REG_WR_DRF_NUM(b,d,r,f,n) PRAMDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMDAC_REG_WR_DRF_DEF(b,d,r,f,c) PRAMDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMDAC_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMDAC_REG_WR32(b,NV##d##r,(PRAMDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMDAC_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMDAC_REG_WR32(b,NV##d##r,(PRAMDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMDAC_REG_RD_DRF(b,d,r,f)       (((PRAMDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_USERDAC registers (NV3)
//******************************************************************************

#define USERDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_USER_DAC))/4]=(U032)(d)
#define USERDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_USER_DAC))/4]
#define USERDAC_REG_WR_DRF_NUM(b,d,r,f,n) USERDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define USERDAC_REG_WR_DRF_DEF(b,d,r,f,c) USERDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define USERDAC_FLD_WR_DRF_NUM(b,d,r,f,n) USERDAC_REG_WR32(b,NV##d##r,(USERDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define USERDAC_FLD_WR_DRF_DEF(b,d,r,f,c) USERDAC_REG_WR32(b,NV##d##r,(USERDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define USERDAC_REG_RD_DRF(b,d,r,f)       (((USERDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//#ifdef PC98
#define USERDAC_REG_WR08(b,o,d)   (b)->Reg008[(o)-DEVICE_BASE(NV_USER_DAC)]=(U008)(d)
#define USERDAC_REG_RD08(b,o)     (b)->Reg008[(o)-DEVICE_BASE(NV_USER_DAC)]
//#endif // PC98

//******************************************************************************
// Macros for NV_PVIDEO registers (NV3)
//******************************************************************************

#define PVIDEO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PVIDEO))/4]=(U032)(d)
#define PVIDEO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PVIDEO))/4]
#define PVIDEO_REG_WR_DRF_NUM(b,d,r,f,n) PVIDEO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PVIDEO_REG_WR_DRF_DEF(b,d,r,f,c) PVIDEO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PVIDEO_FLD_WR_DRF_NUM(b,d,r,f,n) PVIDEO_REG_WR32(b,NV##d##r,(PVIDEO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PVIDEO_FLD_WR_DRF_DEF(b,d,r,f,c) PVIDEO_REG_WR32(b,NV##d##r,(PVIDEO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PVIDEO_REG_RD_DRF(b,d,r,f)       (((PVIDEO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))




//******************************************************************************
// CRTC Access Macros
//
// For now use the priviliged space, but we may have to switch to standard VGA i/o
//******************************************************************************

#define CRTC_WR(i,d)    {PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
                        PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CR__COLOR, (d));}
#define CRTC_RD(i,d)    {PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
                        (d) = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_CR__COLOR);}

//******************************************************************************
// Macros for NV_UBETA registers
//******************************************************************************

#define UBETA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBETA))/4]=(U032)(d)
#define UBETA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBETA))/4]

//******************************************************************************
// Macros for NV_UROP registers
//******************************************************************************

#define UROP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UROP))/4]=(U032)(d)
#define UROP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UROP))/4]

//******************************************************************************
// Macros for NV_UCHROMA registers
//******************************************************************************

#define UCHROMA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UCHROMA))/4]=(U032)(d)
#define UCHROMA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UCHROMA))/4]

//******************************************************************************
// Macros for NV_UPLANE registers
//******************************************************************************

#define UPLANE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPLANE))/4]=(U032)(d)
#define UPLANE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPLANE))/4]

//******************************************************************************
// Macros for NV_UCLIP registers
//******************************************************************************

#define UCLIP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UCLIP))/4]=(U032)(d)
#define UCLIP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UCLIP))/4]

//******************************************************************************
// Macros for NV_UPATT registers
//******************************************************************************

#define UPATT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPATT))/4]=(U032)(d)
#define UPATT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPATT))/4]

//******************************************************************************
// Macros for NV_UPOINT registers
//******************************************************************************

#define UPOINT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPOINT))/4]=(U032)(d)
#define UPOINT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPOINT))/4]

//******************************************************************************
// Macros for NV_ULINE registers
//******************************************************************************

#define ULINE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_ULINE))/4]=(U032)(d)
#define ULINE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_ULINE))/4]

//******************************************************************************
// Macros for NV_ULIN registers
//******************************************************************************

#define ULIN_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_ULIN))/4]=(U032)(d)
#define ULIN_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_ULIN))/4]

//******************************************************************************
// Macros for NV_UTRI registers
//******************************************************************************

#define UTRI_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UTRI))/4]=(U032)(d)
#define UTRI_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UTRI))/4]

//******************************************************************************
// Macros for NV_URECT registers
//******************************************************************************

#define URECT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_URECT))/4]=(U032)(d)
#define URECT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_URECT))/4]

//******************************************************************************
// Macros for NV_UBTM registers
//******************************************************************************

#define UBTM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBTM))/4]=(U032)(d)
#define UBTM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBTM))/4]

//******************************************************************************
// Macros for NV_UQTM registers
//******************************************************************************

#define UQTM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UQTM))/4]=(U032)(d)
#define UQTM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UQTM))/4]

//******************************************************************************
// Macros for NV_UBLIT registers
//******************************************************************************

#define UBLIT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBLIT))/4]=(U032)(d)
#define UBLIT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBLIT))/4]

//******************************************************************************
// Macros for NV_UIMAGE registers
//******************************************************************************

#define UIMAGE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UIMAGE))/4]=(U032)(d)
#define UIMAGE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UIMAGE))/4]

//******************************************************************************
// Macros for NV_UBITMAP registers
//******************************************************************************

#define UBITMAP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBITMAP))/4]=(U032)(d)
#define UBITMAP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBITMAP))/4]

//******************************************************************************
// Macros for NV_UFROMEM registers
//******************************************************************************

#define UFROMEM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UFROMEM))/4]=(U032)(d)
#define UFROMEM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UFROMEM))/4]

//******************************************************************************
// Macros for NV_UTOMEM registers
//******************************************************************************

#define UTOMEM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UTOMEM))/4]=(U032)(d)
#define UTOMEM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UTOMEM))/4]

//******************************************************************************
// Macros for NV_UBTMB registers
//******************************************************************************

#define UBTMB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBTMB))/4]=(U032)(d)
#define UBTMB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBTMB))/4]

//******************************************************************************
// Macros for NV_UQTMB registers
//******************************************************************************

#define UQTMB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UQTMB))/4]=(U032)(d)
#define UQTMB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UQTMB))/4]

//******************************************************************************
// Macros for NV_PFB registers
//******************************************************************************

#define PFB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PFB))/4]=(U032)(d)
#define PFB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PFB))/4]
#define PFB_REG_WR_DRF_NUM(b,d,r,f,n) PFB_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PFB_REG_WR_DRF_DEF(b,d,r,f,c) PFB_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PFB_FLD_WR_DRF_NUM(b,d,r,f,n) PFB_REG_WR32(b,NV##d##r,(PFB_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PFB_FLD_WR_DRF_DEF(b,d,r,f,c) PFB_REG_WR32(b,NV##d##r,(PFB_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PFB_REG_RD_DRF(b,d,r,f)       (((PFB_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAM registers
//******************************************************************************

#define PRAM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAM))/4]=(U032)(d)
#define PRAM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAM))/4]
#define PRAM_REG_WR_DRF_NUM(b,d,r,f,n) PRAM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAM_REG_WR_DRF_DEF(b,d,r,f,c) PRAM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAM_FLD_WR_DRF_NUM(b,d,r,f,n) PRAM_REG_WR32(b,NV##d##r,(PRAM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAM_FLD_WR_DRF_DEF(b,d,r,f,c) PRAM_REG_WR32(b,NV##d##r,(PRAM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAM_REG_RD_DRF(b,d,r,f)       (((PRAM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMFC registers
//******************************************************************************

#define PRAMFC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMFC))/4]=(U032)(d)
#define PRAMFC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMFC))/4]
#define PRAMFC_REG_WR_DRF_NUM(b,d,r,f,n) PRAMFC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMFC_REG_WR_DRF_DEF(b,d,r,f,c) PRAMFC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMFC_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMFC_REG_WR32(b,NV##d##r,(PRAMFC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMFC_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMFC_REG_WR32(b,NV##d##r,(PRAMFC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMFC_REG_RD_DRF(b,d,r,f)       (((PRAMFC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMHT registers
//******************************************************************************

#define PRAMHT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMHT))/4]=(U032)(d)
#define PRAMHT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMHT))/4]
#define PRAMHT_REG_WR_DRF_NUM(b,d,r,f,n) PRAMHT_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMHT_REG_WR_DRF_DEF(b,d,r,f,c) PRAMHT_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMHT_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMHT_REG_WR32(b,NV##d##r,(PRAMHT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMHT_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMHT_REG_WR32(b,NV##d##r,(PRAMHT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMHT_REG_RD_DRF(b,d,r,f)       (((PRAMHT_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PAUTH registers
//******************************************************************************

#define PAUTH_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PAUTH))/4]=(U032)(d)
#define PAUTH_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PAUTH))/4]
#define PAUTH_REG_WR_DRF_NUM(b,d,r,f,n) PAUTH_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PAUTH_REG_WR_DRF_DEF(b,d,r,f,c) PAUTH_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PAUTH_FLD_WR_DRF_NUM(b,d,r,f,n) PAUTH_REG_WR32(b,NV##d##r,(PAUTH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PAUTH_FLD_WR_DRF_DEF(b,d,r,f,c) PAUTH_REG_WR32(b,NV##d##r,(PAUTH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PAUTH_REG_RD_DRF(b,d,r,f)       (((PAUTH_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_EXTDEV registers
//******************************************************************************

#define PEXTDEV_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PEXTDEV))/4]=(U032)(d)
#define PEXTDEV_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PEXTDEV))/4]
#define PEXTDEV_REG_WR_DRF_NUM(b,d,r,f,n) PEXTDEV_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PEXTDEV_REG_WR_DRF_DEF(b,d,r,f,c) PEXTDEV_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PEXTDEV_FLD_WR_DRF_NUM(b,d,r,f,n) PEXTDEV_REG_WR32(b,NV##d##r,(PEXTDEV_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PEXTDEV_FLD_WR_DRF_DEF(b,d,r,f,c) PEXTDEV_REG_WR32(b,NV##d##r,(PEXTDEV_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PEXTDEV_REG_RD_DRF(b,d,r,f)       (((PEXTDEV_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PDAC registers
//******************************************************************************

#define PDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PDAC))/4]=(U032)(d)
#define PDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PDAC))/4]
#define PDAC_REG_WR_DRF_NUM(b,d,r,f,n) PDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PDAC_REG_WR_DRF_DEF(b,d,r,f,c) PDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PDAC_FLD_WR_DRF_NUM(b,d,r,f,n) PDAC_REG_WR32(b,NV##d##r,(PDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PDAC_FLD_WR_DRF_DEF(b,d,r,f,c) PDAC_REG_WR32(b,NV##d##r,(PDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PDAC_REG_RD_DRF(b,d,r,f)       (((PDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PEEPROM registers
//******************************************************************************

#define PEEPROM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PEEPROM))/4]=(U032)(d)
#define PEEPROM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PEEPROM))/4]
#define PEEPROM_REG_WR_DRF_NUM(b,d,r,f,n) PEEPROM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PEEPROM_REG_WR_DRF_DEF(b,d,r,f,c) PEEPROM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PEEPROM_FLD_WR_DRF_NUM(b,d,r,f,n) PEEPROM_REG_WR32(b,NV##d##r,(PEEPROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PEEPROM_FLD_WR_DRF_DEF(b,d,r,f,c) PEEPROM_REG_WR32(b,NV##d##r,(PEEPROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PEEPROM_REG_RD_DRF(b,d,r,f)       (((PEEPROM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PROM registers
//******************************************************************************

#define PROM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PROM))/4]=(U032)(d)
#define PROM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PROM))/4]
#define PROM_REG_WR_DRF_NUM(b,d,r,f,n) PROM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PROM_REG_WR_DRF_DEF(b,d,r,f,c) PROM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PROM_FLD_WR_DRF_NUM(b,d,r,f,n) PROM_REG_WR32(b,NV##d##r,(PROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PROM_FLD_WR_DRF_DEF(b,d,r,f,c) PROM_REG_WR32(b,NV##d##r,(PROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PROM_REG_RD_DRF(b,d,r,f)       (((PROM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PALT registers
//******************************************************************************

#define PALT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PALT))/4]=(U032)(d)
#define PALT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PALT))/4]
#define PALT_REG_WR_DRF_NUM(b,d,r,f,n) PALT_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PALT_REG_WR_DRF_DEF(b,d,r,f,c) PALT_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PALT_FLD_WR_DRF_NUM(b,d,r,f,n) PALT_REG_WR32(b,NV##d##r,(PALT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PALT_FLD_WR_DRF_DEF(b,d,r,f,c) PALT_REG_WR32(b,NV##d##r,(PALT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PALT_REG_RD_DRF(b,d,r,f)       (((PALT_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRM registers
//******************************************************************************

#define PRM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRM))/4]=(U032)(d)
#define PRM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRM))/4]
#define PRM_REG_WR_DRF_NUM(b,d,r,f,n) PRM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRM_REG_WR_DRF_DEF(b,d,r,f,c) PRM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRM_FLD_WR_DRF_NUM(b,d,r,f,n) PRM_REG_WR32(b,NV##d##r,(PRM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRM_FLD_WR_DRF_DEF(b,d,r,f,c) PRM_REG_WR32(b,NV##d##r,(PRM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRM_REG_RD_DRF(b,d,r,f)       (((PRM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRMIO registers
//******************************************************************************

#define PRMIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMIO))/4]=(U032)(d)
#define PRMIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMIO))/4]
#define PRMIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMIO_REG_WR32(b,NV##d##r,(PRMIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMIO_REG_WR32(b,NV##d##r,(PRMIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMIO_REG_RD_DRF(b,d,r,f)       (((PRMIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_USER registers
//******************************************************************************

#define USER_REG_WR32(b,o,d)           (b)->Reg032[(o)/4]=(U032)(d)
#define USER_REG_WR_DRF_NUM(b,d,r,f,n) USER_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define USER_REG_WR_DRF_DEF(b,d,r,f,c) USER_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define USER_FLD_WR_DRF_NUM(b,d,r,f,n) USER_REG_WR32(b,NV##d##r,(USER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define USER_FLD_WR_DRF_DEF(b,d,r,f,c) USER_REG_WR32(b,NV##d##r,(USER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))

//******************************************************************************
// Mode Entry Structure (Taken from Resource Manager code and modified)
//******************************************************************************

#define NUM_RESOLUTIONS 18
#define NUM_REFRESHES 7
#define NUM_DEPTHS 5
#define NUM_ELEMENTS 5

extern U016 fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS][NUM_REFRESHES][NUM_ELEMENTS];


//******************************************************************************
// Master NVInfo Structure
//
// CAREFUL:  There are now 2 HWINFO structures, the original one (this one)
//           and the one that also exists in the RM (in nvrm.h).  Modeset.c
//           includes nvrm.h but does NOT include NV.H, so for now, this is ok.
//           (This confuses Soft-Ice though when loading symbols).
// TODO:     These structures should be renamed or consolidated to minimize confusion!
//******************************************************************************

typedef struct _def_hw_info
{
    struct _def_chip_info
    {
        U032 Size;
        char ID[32];
        U032 SavePmc;
        U032 SaveIntrEn0;
        U032 IntrEn0;
        U032 Implementation;
        U032 Revision;
        U032 Architecture;
        U032 Manufacturer;
        U032 Bus;
        U032 ChipToken[2];
        U032 ServiceCount;
        U032 ServiceTimeLo;
        U032 ServiceTimeHi;
        U032 ExceptionTimeLo;
        U032 ExceptionTimeHi;
    } Chip;
    struct _def_mapping_info
    {
        U032 Size;
        char ID[32];
        U032 PhysAddr;
        U032 IntLine;
        U032 IntPin;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Mapping;
    struct _def_pram_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 HashDepth;
        U032 RunOutMask;
        U032 FreeInstSize;
        U032 FreeInstBase;
        U032 FreeInstMax;
        U032 CurrentSize;
        U032 AvailableSize[4];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 HashTableAddr;
        U032 FifoRunoutAddr;
        U032 FifoContextAddr;
        U032 AudioScratchAddr;
        U032 AuthScratchAddr;
        U032 DMATextureInstances;
    } Pram;
    struct _def_fifo_info
    {
        U032 Size;
        char ID[32];
        U032 ServiceCount;
        U032 AllocateCount;
        U032 CacheDepth;
        U032 LieDepth;
        U032 RetryCount;
        U032 Count;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 DmaFetchAmount;       // Burst amount the DMA pusher should use
                                   // when reading into the FIFO
        U032 DmaWaterMark;         // Fifo level which will kick of the next
                                   // DMA burst
    } Fifo;
    struct _def_master_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Master;
    struct _def_framebuffer_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 ConfigPageHeight;
        U032 RamSizeMb;
        U032 RamSize;
        U032 RamType;
        U032 RamTech;
        U032 DpmLevel;
        U032 Depth;
        U032 Resolution;
        U032 RefreshRate;
        U032 HorizFrontPorch;
        U032 HorizSyncWidth;
        U032 HorizBackPorch;
        U032 HorizDisplayWidth;
        U032 VertFrontPorch;
        U032 VertSyncWidth;
        U032 VertBackPorch;
        U032 VertDisplayWidth;
        U032 HSyncPolarity;
        U032 VSyncPolarity;
        U032 CSync;
        U032 Count;
        U032 ServiceCount;
        U032 ActiveCount;
        U032 ActiveMask;
        U032 Start[3];
        U032 Limit[3];
        U032 Current;
        U032 FlipUsageCount;
        U032 FlipTo;
        U032 FlipFrom;
        U032 VBlankToggle;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 MonitorType;
        U032 FilterEnable;
        U032 SaveToEEPROMEnable;
        U032 Underscan_x;
        U032 Underscan_y;
        U032 Scale_x;
        U032 Scale_y;
        U032 Instance;
        U032 DmaInstance;
    } Framebuffer;
    struct _def_graphics_info
    {
        U032 Size;
        char ID[32];
        U032 Debug0;
        U032 Debug1;
        U032 Debug2;
        U032 Debug3;
        U032 CurrentChID;
        U032 Count;
        U032 CanvasCount;
        U032 Enabled;
        U032 ServiceCount;
        U032 ComplexClipCount;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Graphics;
    struct _def_video_info
    {
        U032 CurrentChID;
        U032 ColorKeyEnabled;
        U032 ScaleFactor;   // 12.20
        U032 Enabled;
        U032 VideoStart;
        U032 VideoSize;
        U032 VideoScale;
        U032 VideoColorKey;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Video;
    struct _def_mediaport_info
    {
        U032 CurrentChID;
        U032 Enabled;
    } MediaPort;
    struct _def_audio_info
    {
        U032 Size;
        char ID[32];
        U032 OutLogVolumeLeft;
        U032 OutLogVolumeRight;
        U032 NoteLogVolumeLeft;
        U032 NoteLogVolumeRight;
        U032 OutLinVolumeLeft;
        U032 OutLinVolumeRight;
        U032 NoteLinVolumeLeft;
        U032 NoteLinVolumeRight;
        U032 VolumeThreshold;
        U032 MaxNotes;
        U032 MaxIOs;
        U032 NoteCount;
        U032 InCount;
        U032 OutCount;
        U032 NearMark;
        U032 BlockLength;
        U032 RateConversion;
        U032 ServiceCount;
        U032 Enabled;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Audio;
    struct _def_dac_info
    {
        U032 Size;
        char ID[32];
        U032 InputWidth;
        U032 PClkVClkRatio;
        U032 VClk;
        U032 MClk;
        U032 VPllM;
        U032 VPllN;
        U032 VPllO;
        U032 VPllP;
        U032 MPllM;
        U032 MPllN;
        U032 MPllO;
        U032 MPllP;
        U032 DpmLevel;
        S032 CursorPosX;
        S032 CursorPosY;
        U032 CursorWidth;
        U032 CursorHeight;
        U008 CursorImagePlane[2][32 * sizeof(U032)];
        U032 CursorType;
        U032 CursorColor1;
        U032 CursorColor2;
        U032 CursorColor3;
        U008 CursorColorImage[32][32 * sizeof(U032)];
        S032 CursorSaveUnderPosX;
        S032 CursorSaveUnderPosY;
        U032 CursorSaveUnderWidth;
        U032 CursorSaveUnderHeight;
        U032 CursorSaveUnder[32][32];
        U032 CursorExclude;
        U032 CursorEmulation;
        U032 Palette[272];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 CursorImageInstance;
        U032 TVCursorMin;
        U032 TVCursorMax;
    } Dac;
    struct _def_codec_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 DpmLevel;
        U032 Frequency;
        U032 OutputAttenuation;
        U032 InputSource;
        U032 InputLineLogGainLeft;
        U032 InputLineLogGainRight;
        U032 InputAuxLogGainLeft;
        U032 InputAuxLogGainRight;
        U032 InputMicLogGainLeft;
        U032 InputMicLogGainRight;
        U032 InputMixLogGainLeft;
        U032 InputMixLogGainRight;
        U032 PassThruAux1LogLeft;
        U032 PassThruAux1LogRight;
        U032 PassThruAux2LogLeft;
        U032 PassThruAux2LogRight;
        U032 InputLineLinGainLeft;
        U032 InputLineLinGainRight;
        U032 InputAuxLinGainLeft;
        U032 InputAuxLinGainRight;
        U032 InputMicLinGainLeft;
        U032 InputMicLinGainRight;
        U032 InputMixLinGainLeft;
        U032 InputMixLinGainRight;
        U032 PassThruAux1LinLeft;
        U032 PassThruAux1LinRight;
        U032 PassThruAux2LinLeft;
        U032 PassThruAux2LinRight;
        U032 Monitor;
        U032 ControlPins;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Codec;
    struct _def_dgp_chip_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 Enable3D;
        U032 Scale;
        U032 HorizDelay;
        U032 HorizOffset;
        U032 HorizScale;
        U032 VertOffset;
        U032 VertScale;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Dgp;
    struct _def_gameport_info
    {
        U032 Size;
        char ID[32];
        U032 DevicePort;
        V032 InputTypes;
        V032 DigitalInputs;
        S032 AnalogInputs[8];
        U032 XferRateDelay;
        U032 HorizRange;
        S032 HorizCenter;
        U032 VertRange;
        S032 VertCenter;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Gameport[13];
    struct _def_timer_info
    {
        U032 Size;
        char ID[32];
        U032 Denominator;
        U032 Numerator;
        U032 ServiceCount;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Timer;
    struct _def_vga_info
    {
        U032 Size;
        char ID[32];
        U032 Enabled;
        U032 GlobalEnable;
        U032 RomVersion;
        U032 RomFixupCode;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Vga;
    struct _def_classes_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Classes;
    struct _def_stat_info
    {
        U032 Size;
        char ID[32];
        U032 AudioExceptionCount;
        U032 FifoExceptionCount;
        U032 FramebufferExceptionCount;
        U032 GraphicsExceptionCount;
        U032 TimerExceptionCount;
        U032 TotalExceptionCount;
        U032 IntTimeLo;
        U032 IntTimeHi;
        U032 ExecTimeLo;
        U032 ExecTimeHi;
        U032 MemAlloced;
        U032 MemLocked;
        U032 UpdateLo;
        U032 UpdateHi;
    } Statistics;
    struct _def_null_info
    {
        U032 Size;
        char ID[32];
    } Null;
} HWINFO, * PHWINFO;


typedef struct _VIDEO_COPROCESSOR_INFORMATION {
    ULONG ulChipID;         // ET3000, ET4000, W32, W32I, W32P, or ET6000
    ULONG ulRevLevel;       // REV_A, REV_B, REV_C, REV_D, REV_UNDEF
    ULONG ulVideoMemory;    // in bytes
} VIDEO_COPROCESSOR_INFORMATION, *PVIDEO_COPROCESSOR_INFORMATION;

typedef enum _CHIP_TYPE {
    NV3 = 1,
    NV4,
} CHIP_TYPE;

typedef enum _REV_TYPE {
    REV_UNDEF = 1,
    REV_A,
    REV_B,
    REV_C,
    REV_D,
} REV_TYPE;

//
//  NV1 PCI defines - These values should match those in NV1_REF.H
//
#define NV1_VENDOR_ID       0x10DE
#define ST1_VENDOR_ID       0x104A
#define NV1_DEVICE_VGA_ID   0x0008
#define NV1_DEVICE_NV1_ID   0x0009


//
//  NV3 PCI defines - These values should match those in NV3_REF.H
//
#define NV3_VENDOR_ID       0x12D2
#define ST3_VENDOR_ID       0x12D2
#define NV3_DEVICE_VGA_ID   0x0008
#define NV3_DEVICE_NV3_ID   0x0018
#define NV3_DEVICE_NV3_ID_2 0x0019


//
//  NV4 PCI defines - These values should match those in NV4_REF.H
//
#define NV4_VENDOR_ID                   0x10DE
#define ST4_VENDOR_ID                   0x10DE
#define NV4_DEVICE_VGA_ID               0x0008
#define NV4_DEVICE_NV4_ID               0x0020
#define NV5_DEVICE_NV5_ID               0x0028
#define NV5ULTRA_DEVICE_NV5ULTRA_ID     0x0029
#define NV5VANTA_DEVICE_NV5VANTA_ID     0x002C
#define NV5MODEL64_DEVICE_NV5MODEL64_ID 0x002D
#define NV0A_DEVICE_NV0A_ID             0x00A0
#define NV10_DEVICE_NV10_ID             0x0100
#define NV10DDR_DEVICE_NV10DDR_ID       0x0101
#define NV10GL_DEVICE_NV10GL_ID         0x0103
#define NV11_DEVICE_NV11_ID             0x0110
#define NV11DDR_DEVICE_NV11DDR_ID       0x0111
#define NV11M_DEVICE_NV11M_ID           0x0112
#define NV11GL_DEVICE_NV11GL_ID         0x0113
#define NV15_DEVICE_NV15_ID             0x0150
#define NV15DDR_DEVICE_NV15DDR_ID       0x0151
#define NV15BR_DEVICE_NV15BR_ID         0x0152
#define NV15GL_DEVICE_NV15GL_ID         0x0153
#define NV20_DEVICE_NV20_ID             0x0200
#define NV20_DEVICE_NV20_1_ID           0x0201
#define NV20_DEVICE_NV20_2_ID           0x0202
#define NV20_DEVICE_NV20_3_ID           0x0203


//////////////////////////////////////////////////////////////////////////////

//
// Do full save and restore.
//

#define EXTENDED_REGISTER_SAVE_RESTORE 1

//
// BIOS Variables
//

#define BIOS_INFO_1 0x488
#define PRODESIGNER_BIOS_INFO 0x4E8

//
// Define type of ET4000 boards
//

typedef enum _BOARD_TYPE {
    SPEEDSTARPLUS = 1,
    SPEEDSTAR24,
    SPEEDSTAR,
    PRODESIGNERIISEISA,
    PRODESIGNERIIS,
    PRODESIGNER2,
    TSENG3000,
    TSENG4000,
    TSENG4000W32,
    STEALTH32,
    TSENG6000,
    OTHER
} BOARD_TYPE;



//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//******************************************************************************
// Indices corresponding to the NV Memory ranges
//******************************************************************************

#define NV_PHYSICAL_ADDRESS_QTY         3
#define NV_PHYSICAL_BASE_ADDRESS        0
#define NV_PHYSICAL_DFB_ADDRESS         1
#define NV_PHYSICAL_REMAPPER_ADDRESS    2

#define NV_PMC_INDEX          0
#define NV_PFB_INDEX          1
#define NV_PRM_INDEX          2
#define NV_PDAC_INDEX         3
#define NV_PRAM_INDEX         4
#define NV_PRAMFC_INDEX       5
#define NV_PRAMHT_INDEX       6
#define NV_PFIFO_INDEX        7
#define NV_PBUS_INDEX         8
#define NV_PGRAPH_INDEX       9
#define NV_URECT_INDEX        10
#define NV_UTRI_INDEX         11
#define NV_UBLIT_INDEX        12
#define NV_UIMAGE_INDEX       13
#define NV_UBITMAP_INDEX      14
#define NV_CONFIG_INDEX       15
#define NV_PDMA_INDEX         16
#define NV_PTIMER_INDEX       17
#define NV_PAUDIO_INDEX       18
#define NV_PAUTH_INDEX        19
#define NV_PEXTDEV_INDEX      20
#define NV_PEEPROM_INDEX      21
#define NV_PROM_INDEX         22
#define NV_PALT_INDEX         23

#define NV_USER_INDEX          24
#define NV_PGRAPH_STATUS_INDEX 25
#define NV_PDFB_INDEX          26

#define NV_PRAMIN_INDEX        27
#define NV_PRMVIO_INDEX        28
#define NV_PRMCIO_INDEX        29

#define NV_PFB_CONFIG_0_INDEX  30
#define NV_PFB_START_ADDRESS_INDEX  31

#define NV_PRAMDAC_INDEX       32
#define NV_USERDAC_INDEX       33

#define NV_SGS_DAC_INDEX       34
#define NV_PVIDEO_INDEX        35

#define NV_NUM_RANGES          36

#define BANKED_FRAME_BUFFER 3
#define LINEAR_FRAME_BUFFER 4

//
// W32 MMU stuff
//

#define PORT_IO_ADDR                0
#define PORT_IO_LEN                 0x10000

// When we are banked

#define BANKED_MMU_BUFFER_MEMORY_ADDR          0xB8000
#define BANKED_MMU_BUFFER_MEMORY_LEN           (0xBE000 - 0xB8000)
#define BANKED_MMU_MEMORY_MAPPED_REGS_ADDR     0xBFF00
#define BANKED_MMU_MEMORY_MAPPED_REGS_LEN      (0xC0000 - 0xBFF00)
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_ADDR   0xBE000
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_LEN    (0xBF000 - 0xBE000)

#define BANKED_APERTURE_0_OFFSET   0x0000
#define BANKED_APERTURE_1_OFFSET   0x2000
#define BANKED_APERTURE_2_OFFSET   0x4000

// When we are linear

#define MMU_BUFFER_MEMORY_ADDR          0x200000
#define MMU_BUFFER_MEMORY_LEN           0x180000
#define MMU_MEMORY_MAPPED_REGS_ADDR     0x3FFF00
#define MMU_MEMORY_MAPPED_REGS_LEN      0x000100
#define MMU_EXTERNAL_MAPPED_REGS_ADDR   0x3FE000
#define MMU_EXTERNAL_MAPPED_REGS_LEN    0x001000

typedef struct {
    ULONG  ulOffset;
    ULONG  ulLength;
} RANGE_OFFSETS;

#define APERTURE_0_OFFSET   0x000000
#define APERTURE_1_OFFSET   0x080000
#define APERTURE_2_OFFSET   0x100000

#define MMU_APERTURE_2_ACL_BIT  0x04

typedef struct {
    ULONG   ulPhysicalAddress;
    ULONG   ulLength;
    ULONG   ulInIoSpace;
    PVOID   pvVirtualAddress;
} W32_ADDRESS_MAPPING_INFORMATION, *PW32_ADDRESS_MAPPING_INFORMATION;


//
// Port definitions for filling the ACCESS_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// W32 CRTCB port addresses (used for ID)
//

#define CRTCB_IO_PORT_BASE    0x0000217A
#define CRTCB_IO_PORT_LEN     0x00000002

#define CRTCB_IO_PORT_INDEX   CRTCB_IO_PORT_BASE
#define CRTCB_IO_PORT_DATA    (CRTCB_IO_PORT_INDEX+1)
#define IND_CRTCB_CHIP_ID     0xEC




//
// VGA register definitions
//
#define NUM_VGA_ACCESS_RANGES  3
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x03B4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03B5  // Data registers in mono mode
#define MODE_CONTROL_PORT_MONO      0x03B8  // Tseng Mode Control port, used
                                            //  here only for unlocking the
                                            //  key so we can get at extended
                                            //  registers
#define FEAT_CTRL_WRITE_PORT_MONO   0x03BA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03BA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in mono mode
#define HERCULES_COMPATIBILITY_PORT 0x03BF  // used to unlock Tseng key to
                                            //  get at extended ports

#define ATT_ADDRESS_PORT            0x03C0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03C0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x010
#define ATT_DATA_READ_PORT          0x03C1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03C2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03C2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03C3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03C4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03C5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03C6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03C7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03C7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03C8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03C9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03CA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03CC  // Miscellaneous Output reg read
                                            // port
#define SEGMENT_SELECT_PORT         0x03CD  // Tseng banking control register
#define SEGMENT_SELECT_HIGH         0x03CB  // Tseng W32 SegSel extension
#define GRAPH_ADDRESS_PORT          0x03CE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03CF  // and Data registers

                                            // ports in color mode
#define CRTC_ADDRESS_PORT_COLOR     0x03D4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03D5  // Data registers in color mode
#define MODE_CONTROL_PORT_COLOR     0x03D8  // Tseng Mode Control port, used
                                            //  here only for unlocking the
                                            //  key so we can get at extended
                                            //  registers
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03DA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03DA  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode
//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_STATE_CONTROL       0x06    // index of TS State Control reg in Seq
#define IND_TS_AUX_MODE         0x07    // index of TS Aux Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC
#define IND_RAS_CAS_CONFIG      0x32    // index of RAS/CAS Config reg in CRTC
#define IND_EXT_START_ADDR      0x33    // index of Extended Start Address reg
                                        //  in CRTC
#define IND_CRTC_COMPAT         0x34    // index of CRTC Compatibility reg
                                        //  in CRTC
#define IND_OFLOW_HIGH          0x35    // index of Overflow High reg in CRTC
#define IND_VID_SYS_CONFIG_1    0x36    // index of Video System Configuration
#define IND_VID_SYS_CONFIG_2    0x37    //  1 & 2 registers in CRTC
#define IND_ATC_MISC            0x16    // index of Miscellaneous reg in ATC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

#define UNLOCK_KEY_1            0x03    // value to output to Herc Compat
                                        //  register as first step in unlocking
                                        //  key so Tseng registers can be set
#define UNLOCK_KEY_2            0xA0    // value to output to Mode Control Port
                                        //  register as 2nd step in unlocking
                                        //  key so Tseng registers can be set
#define LOCK_KEY_1              0x00    // value to output to Herc Compat
                                        //  register as first step in locking
                                        //  key so Tseng registers can't be set
#define LOCK_KEY_2              0x00    // value to output to Mode Control Port
                                        //  register as 2nd step in locking
                                        //  key so Tseng registers can't be set
#define HERCULES_COMPATIBILITY_DEFAULT 0x00
                                        // value to output to Herc Compat
                                        //  register to put back to MDA
                                        //  compatibility

#define MODE_CONTROL_PORT_COLOR_DEFAULT 0x00
#define MODE_CONTROL_PORT_MONO_DEFAULT 0x00
                                        // values to output to CGA and MDA mode
                                        //  registers to put to default state
                                        //  (video disabled).

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F



//
// Indices for type of memory mapping; used in ModesVGA[], must match
// MemoryMap[].
//

typedef enum _VIDEO_MEMORY_MAP {
    MemMap_Mono,
    MemMap_CGA,
    MemMap_VGA
} VIDEO_MEMORY_MAP, *PVIDEO_MEMORY_MAP;

//
// Memory map table definition
//

typedef struct {
    ULONG   MaxSize;        // Maximum addressable size of memory
    ULONG   Start;          // Start address of display memory
} MEMORYMAPS;

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    MemMgrBanking,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;


//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType;             // color or monochrome, text or graphics, via
                                //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;          // # of video memory planes
    USHORT  bitsPerPlane;       // # of bits of color in each plane
    SHORT   col;                // # of text columns across screen with default font

    SHORT   row;                // # of text rows down screen with default font
    USHORT  hres;               // # of pixels across screen
    USHORT  vres;               // # of scan lines down screen
    USHORT  wbytes;             // # of bytes from start of one scan line to start of next
    ULONG   sbytes;             // total size of addressable display memory in bytes
    ULONG   Frequency;          // Vertical Frequency
    ULONG   Interlaced;         // Determines if the mode is interlaced or not
    BANK_TYPE banktype;         // NoBanking, NormalBanking, PlanarHCBanking
    VIDEO_MEMORY_MAP MemMap;    // index from VIDEO_MEMORY_MAP of memory
                                //  mapping used by this mode
    BOOLEAN ValidMode;          // Determines which modes are valid.
    ULONG   Int10ModeNumber;    // Mode number via Int 10
    PUSHORT CmdStrings;         // pointer to array of register-setting commands
} VIDEOMODE, *PVIDEOMODE;


//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0



// 
// Added structs for control panel support
//

// For setting the current device type 
typedef struct  tagSETGETDEVTYPE
{
    unsigned long   dwSuccessFlag;
    unsigned long   dwDeviceType;
    unsigned long   dwTvFormat;
} SETGETDEVTYPE, *PSETGETDEVTYPE;

// For validating a particular mode on a particular device type 
typedef struct  tagVALMODEEXTR
{
    unsigned long   dwHRes;
    unsigned long   dwVRes;
    unsigned long   dwBpp;
    unsigned long   dwRefresh;
    unsigned long   dwDeviceType;
} VALMODEXTR;

// Size of the color lookup table cache in the device extension
#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))


//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//


//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

//
// Indices to start save/restore in extension registers:
// For both chip types

#define ET4000_SEQUENCER_EXT_START     0x06
#define ET4000_SEQUENCER_EXT_END       0x07

#define ET4000_CRTC_EXT_START          0x31
#define ET4000_CRTC_EXT_END            0x37
#define ET4000_CRTC_1_EXT_START        0x3F
#define ET4000_CRTC_1_EXT_END          0x3F

#define ET4000_ATTRIB_EXT_START        0x16
#define ET4000_ATTRIB_EXT_END          0x16

//
// Number of extended regs for both chip types.
//

#define ET4000_NUM_SEQUENCER_EXT_PORTS (ET4000_SEQUENCER_EXT_END - ET4000_SEQUENCER_EXT_START + 1)
#define ET4000_NUM_CRTC_EXT_PORTS      (ET4000_CRTC_EXT_END - ET4000_CRTC_EXT_START + 1) + \
                                       (ET4000_CRTC_1_EXT_END - ET4000_CRTC_1_EXT_START + 1)
#define ET4000_NUM_ATTRIB_EXT_PORTS    (ET4000_ATTRIB_EXT_END - ET4000_ATTRIB_EXT_START + 1)

//
// set values for save/restore area based on largest value for a chipset.
//

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     ET4000_NUM_SEQUENCER_EXT_PORTS
#define EXT_NUM_CRTC_PORTS          ET4000_NUM_CRTC_EXT_PORTS
#define EXT_NUM_ATTRIB_CONT_PORTS   ET4000_NUM_ATTRIB_EXT_PORTS
#define EXT_NUM_DAC_ENTRIES         0

#else

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#endif


#define VGA_MAX_VALIDATOR_DATA       100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET +\
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE

#if 0
//////////////////////
// H.AZAR: (02/15/99)
//

#define NVP_MAX_VPORTS              1
#define NVP_MAX_SURFACES            5
#define NVP_MAX_TRANSFER_BUFFERS    10

//
// Surface definition (Video or VBI) and related data
//
typedef struct _NVP_SURFACE_INFO
{
    //HANDLE              hSurface;           // DirectDraw surface handle
    ULONG               dwCaps;             // capabilites of this DD surface
    ULONG               pVidMem;            // Flat pointer to the surface
    ULONG               dwOffset;           // Offset from the base of the frame buffer
    ULONG               dwPitch;
    ULONG               dwLength;
    ULONG               dwHeight;
    ULONG               dwWidth;            // Ignored for VBI
    ULONG               dwStartLine;        // Programs Y-crop for image, and startline for vbi
    ULONG               dwPreScaleSizeX;    // Ignored for VBI.. prescale size width
    ULONG               dwPreScaleSizeY;    // Ignored for VBI.. prescale size height
    ULONG               dwFieldType;        // what field was this surface setup to capture?
    //ULONG               bAutoFlip;          // do we turn around and auto program this surface?
    ULONG               bIsFirstFieldCaptured;
    LONG                nNextSurfaceIdx;     // the next surface idx in the chain
} NVP_SURFACE_INFO, *PNVP_SURFACE_INFO;

#define NVP_MAX_EXTRA422 10
// Overlay info
typedef struct _NVP_OVERLAY {
    ULONG   dwOverlayFormat;
    ULONG   dwOverlaySrcX;
    ULONG   dwOverlaySrcY;
    ULONG   dwOverlaySrcPitch;
    ULONG   dwOverlaySrcSize;
    ULONG   dwOverlaySrcWidth;
    ULONG   dwOverlaySrcHeight;
    ULONG   dwOverlayDstWidth;
    ULONG   dwOverlayDstHeight;
    ULONG   dwOverlayDstX;
    ULONG   dwOverlayDstY;
    ULONG   dwOverlayDeltaX;
    ULONG   dwOverlayDeltaY;
    ULONG   dwOverlayColorKey;
    ULONG   dwOverlayMode;
    ULONG   aExtra422OverlayOffset[NVP_MAX_EXTRA422];   // extra memory space used for prescaling
    ULONG   dwExtra422Index;            // index of current extra surface
    ULONG   dwExtra422NumSurfaces;      // number of extra allocated surfaces
    ULONG   dwExtra422Pitch;            // extra surface pitch
    ULONG   pNvPioFlipOverlayNotifierFlat;
    ULONG   dwOverlayMaxDownScale;
    ULONG   dwOverlayBufferIndex;
    ULONG   dwReserved1;
    ULONG   dwReserved2;
} NVP_OVERLAY, *PNVP_OVERLAY;

// Transfer
typedef struct _NVP_TRANSFER_BUFFER
{
    ULONG   dwTransferId;
    ULONG   dwTransferStatus;
    ULONG   pSurfaceData;
    //LONG  nSurfaceIdx;    // Idx of surface we're transfering from
    LONG    lStartLine;
    LONG    lEndLine;
    ULONG   dwTransferFlags;
    ULONG   pDestMDL;
    LONG    nNextTransferIdx;
    LONG    nPrevTransferIdx;
} NVP_TRANSFER_BUFFER, *PNVP_TRANSFER_BUFFER;

// transfer status
#define NVP_TRANSFER_QUEUED         0x01
#define NVP_TRANSFER_IN_PROGRESS    0x02
#define NVP_TRANSFER_DONE           0x03
#define NVP_TRANSFER_FAILURE        0x04
#define NVP_TRANSFER_FREE           0xFFFFFFFF

//
// NVidia Video Port context
//
typedef struct _NVP_CONTEXT
{
    NVP_SURFACE_INFO    aVideoSurfaceInfo[NVP_MAX_SURFACES];
    NVP_SURFACE_INFO    aVBISurfaceInfo[NVP_MAX_SURFACES];
    int                 nNumVidSurf;            // number of allocated video surfaces
    int                 nNumVBISurf;            // number of allocated vbi surfaces
    int                 nVidSurfIdx;            // current video surface index
    int                 nVBISurfIdx;            // current vbi surface index
    int                 nNextVideoSurfId;
    int                 nNextVBISurfId;

    int                 nLastFieldId;           // Id of last field captured
    ULONG               bLastFieldType;         // type of last field captured (TRUE if VBI, FALSE if VIDEO)

    ULONG               dwVPState;              // NVP_STATE_STOPPED, NVP_STATE_STARTED
    ULONG               dwVPFlags;
    ULONG               dwVPConFlags;           // connection flags

    ULONG               dwChipId;               // chip version Id
    ULONG               hClient;
    ULONG               dwDeviceId;             // NV_WIN_DEVICE
    ULONG               dwOverlayObjectID;      // overlay object Id (shared object!)
    ULONG               dwScalerObjectID;       // scaler object Id
    ULONG               dwDVDSubPicObjectID;    // used for prescaling on nv4 and nv5
    ULONG               dwDVDObjectCtxDma;      // context dma used for synchronization.
    int                 nFreeCount;     // fifo free count

    // BUGBUG: hacking declerations to avoid including hardware dependent header files
    //         in "nv.h"
    ULONG               pNVPChannel;            // NvChannel *pNVPChannel; // VPE pio channel
    UCHAR               avpNotifiers[16*9];     // (Media port notifiers) NvNotification avpNotifiers[NVP_CLASS04D_MAX_NOTIFIERS];
    UCHAR               aovNotifiers[16*3];     // (Overlay notifiers) NvNotification aovNotifiers[NVP_CLASS07A_MAX_NOTIFIERS];

    // overlay
    NVP_OVERLAY         nvpOverlay;             // information retrieved from UpdateOverlay32() in Ring3
    ULONG               pOverlayChannel;        // NvChannel *pOverlayChannel; // Overlay channel
    ULONG               dwOvrSubChannel;


    // vidmem to sysmem transfer (vbi and video capture !)
    NVP_TRANSFER_BUFFER aTransferBuffers[NVP_MAX_TRANSFER_BUFFERS];
    UCHAR               axfNotifiers[16*6]; //
    int                 nCurTransferIdx;    // current transfer buffer index
    int                 nLastTransferIdx;
    int                 nRecentTransferIdx; // index of most recently transfered buffer
    int                 nNumTransfer;       // current number of transfer buffer in queue
    ULONG               bxfContextCreated;  // TRUE if context already created
    ULONG               bxfContextFlushed;  // TRUE if context flushed
    ULONG               dwTransferCtxStart; // old transfer context start
    ULONG               dwTransferCtxSize;  // transfer size

    ULONG               hVPSyncEvent;       // media port Vsync event handle // PKEVENT hVSyncEvent;

    // DMA push buffer
    PVOID               pDmaChannel;
    ULONG               *nvDmaFifo;
    ULONG               nvDmaCount;
    ULONG               DmaPushBufTotalSize;    // 32 DWORDs
    UCHAR               DmaPushBufErrNotifier[16*1];

} NVP_CONTEXT, *PNVP_CONTEXT;

//////////////////////
#endif

//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PUCHAR  IOAddress;            // base I/O address of VGA ports
    PUCHAR  VgaPortRange[NUM_VGA_ACCESS_RANGES];
                                  // Non-palette related VGA regs
    PVOID   VideoMemoryAddress;   // base virtual memory address of VGA memory
    ULONG   AdapterMemorySize;    // size, in bytes, of the memory on the
                                  // board.
    ULONG   ModeIndex;            // index of current mode in ModesVGA[]
    ULONG   NumRegistryModes;     // number of modes specified from registry/vesadata
    ULONG   NumAvailableModes;    // number of valid modes on this device for first head
    ULONG   NumAvailableModes1;    // number of valid modes on this device for second head.
    ULONG   NonPrimaryDevice;     // Denotes if system was booted on this device

//    PVIDEOMODE  CurrentMode;    // pointer to VIDEOMODE structure for
//                                // current mode.



    PMODE_ENTRY  CurrentMode;     // pointer to MODE_ENTRY structure for
                                  // current mode.

    ULONG   ulChipID;
    REV_TYPE    ulRevLevel;
    WCHAR LegacyPnPId[8];         // legacy PnP ID

    USHORT  FontPelColumns;       // Width of the font in pels
    USHORT  FontPelRows;          // height of the font in pels

    NV_CURSOR_INFO NvCursorInfo;  // Cursor position and other info

    UCHAR CursorEnable;           // whether cursor is enabled or not
    UCHAR CursorTopScanLine;      // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;   // Cursor End register setting (bottom scan)

    USHORT BoardID;                // Used to Identify Diamond boards

    //**************************************************************************
    // OLD Style modeset code
    // ModeTiming table  (represents modes that are valid for this adapter)
    // This needs to be put here in the hw device extension for multi adapter
    // configurations. (still used by NV3)
    //**************************************************************************

    MODE_ENTRY fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS*NUM_REFRESHES];

    //**************************************************************************
    // NEW Style modeset code
    // Allocate a table which will contain all valid modes
    //**************************************************************************
    USHORT ValidModeTable[MAX_VALID_MODE_TABLE_DATA_WORDS]; // For the first head
    USHORT ValidModeTable1[MAX_VALID_MODE_TABLE_DATA_WORDS];// For the second head

    //***************************************************************************
    // The OEM-specific and monitor-specific restriction mode lists.
    //***************************************************************************
    USHORT RestrictionModeTable0[MAX_VALID_MODE_TABLE_DATA_WORDS]; // For the first head
    USHORT RestrictionModeTable1[MAX_VALID_MODE_TABLE_DATA_WORDS]; // For the second head
    ULONG  NumRestrictionModes0; // Number of monitor restriction modes for head0
    ULONG  NumRestrictionModes1; // Number of monitor restriction modes for head1

    

    //**************************************************************************
    // Used to keep track of where to story parsed registry data
    //**************************************************************************

    ULONG RegistryDataOffset;

    //**************************************************************************
    // Structure containing registry switch data
    //**************************************************************************

    NT_NV_REGISTRY NV_Registry_Table;

    //**************************************************************************
    // Saved BIOS image (64k)
    //**************************************************************************

    UCHAR SavedBiosImageArray[SAVED_BIOS_IMAGE_SIZE];

    

    //**************************************************************************
    // Saved instance memory (128k)
    //**************************************************************************

    UCHAR SavedInstanceMemory[MAX_INSTANCE_MEM_SIZE];
    ULONG TotalInstanceMemory;

    //**************************************************************************
    // NV1 Specific registers
    //**************************************************************************

    PHYSICAL_ADDRESS NV1Registers;     // NV1 initialization registers
    ULONG  NV1RegistersLength;         // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PMC_Registers;    // NV1 Master Control Registers
    PHWREG NV1_Lin_PMC_Registers;      // Linear address to Master Control Registers
    ULONG  NV1_PMC_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PFB_Registers;    // NV1 Frame Buffer Control Registers
    PHWREG  NV1_Lin_PFB_Registers;     // Linear address to Frame Buffer Control Registers
    ULONG  NV1_PFB_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRM_Registers;    // NV1 Real Mode Control Registers
    PHWREG  NV1_Lin_PRM_Registers;     // Linear address to Real Mode Control Registers
    ULONG  NV1_PRM_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PDAC_Registers;   // NV1 DAC Registers
    PHWREG  NV1_Lin_PDAC_Registers;    // Linear address to DAC Registers
    ULONG  NV1_PDAC_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAM_Registers;   // NV1 RAM Registers
    PHWREG  NV1_Lin_PRAM_Registers;    // Linear address to RAM Registers
    ULONG  NV1_PRAM_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAMFC_Registers; // NV1 RAMFC Registers
    PHWREG  NV1_Lin_PRAMFC_Registers;  // Linear address to RAMFC Registers
    ULONG  NV1_PRAMFC_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAMHT_Registers;   // NV1 RAMHT Registers
    PHWREG  NV1_Lin_PRAMHT_Registers;    // Linear address to RAMHT Registers
    ULONG  NV1_PRAMHT_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_USER_Registers;   // NV1 USER Registers
    PHWREG  NV1_Lin_USER_Registers;    // Linear address to USER Registers
    ULONG  NV1_USER_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PFIFO_Registers;  // NV1 FIFO Registers
    PHWREG  NV1_Lin_PFIFO_Registers;   // Linear address to FIFO Registers
    ULONG  NV1_PFIFO_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PBUS_Registers;   // NV1 PBUS Registers
    PHWREG  NV1_Lin_PBUS_Registers;    // Linear address to PBUS Registers
    ULONG  NV1_PBUS_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PGRAPH_Registers; // NV1 PGRAPH Registers
    PHWREG  NV1_Lin_PGRAPH_Registers;  // Linear address to PGRAPH Registers
    ULONG  NV1_PGRAPH_Length;          // NV1 register window



    PHYSICAL_ADDRESS NV1_Phys_CONFIG_Registers; // NV1 Config Registers
    PHWREG NV1_Lin_CONFIG_Registers;   // Linear address to Config Registers
    ULONG  NV1_CONFIG_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_MEM_Registers;    // NV1 Mermory Registers
    PHWREG NV1_Lin_MEM_Registers;      // Linear address to Memory Registers
    ULONG  NV1_MEM_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_IO_Registers;     // NV1 IO Registers
    PHWREG NV1_Lin_IO_Registers;       // Linear address to IO Registers
    ULONG  NV1_IO_Length;              // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PDMA_Registers;   // NV1 DMA Registers
    PHWREG NV1_Lin_PDMA_Registers;     // Linear address to DMA Registers
    ULONG  NV1_PDMA_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PTIMER_Registers; // NV1 Timer Registers
    PHWREG NV1_Lin_PTIMER_Registers;   // Linear address to Timer Registers
    ULONG  NV1_PTIMER_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PAUDIO_Registers; // NV1 Audio Registers
    PHWREG NV1_Lin_PAUDIO_Registers;   // Linear address to Audio Registers
    ULONG  NV1_PAUDIO_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PAUTH_Registers;  // NV1 Authority Registers
    PHWREG NV1_Lin_PAUTH_Registers;    // Linear address to Authority Registers
    ULONG  NV1_PAUTH_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PEXTDEV_Registers; // NV1 Extdev Registers
    PHWREG NV1_Lin_PEXTDEV_Registers;   // Linear address to Extdev Registers
    ULONG  NV1_PEXTDEV_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PEEPROM_Registers;// NV1 Eeprom Registers
    PHWREG NV1_Lin_PEEPROM_Registers;  // Linear address to Eeprom Registers
    ULONG  NV1_PEEPROM_Length;         // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PROM_Registers;   // NV1 ROM Registers
    PHWREG NV1_Lin_PROM_Registers;     // Linear address to ROM Registers
    ULONG  NV1_PROM_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PALT_Registers;   // NV1 Alt Registers
    PHWREG NV1_Lin_PALT_Registers;     // Linear address to Alt Registers
    ULONG  NV1_PALT_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRMIO_Registers;  // NV1 Real Mode IO Registers
    PHWREG NV1_Lin_PRMIO_Registers;    // Linear address to Real Mode IO Registers
    ULONG  NV1_PRMIO_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_URECT_Registers;  // NV1 User Rectangle Registers
    PHWREG NV1_Lin_URECT_Registers;    // Linear address to User Rectangle Registers
    ULONG  NV1_URECT_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UTRI_Registers;  // NV1 User Triangle Registers
    PHWREG NV1_Lin_UTRI_Registers;    // Linear address to User Triangle Registers
    ULONG  NV1_UTRI_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UBLIT_Registers;  // NV1 User BLIT Registers
    PHWREG NV1_Lin_UBLIT_Registers;    // Linear address to User BLIT Registers
    ULONG  NV1_UBLIT_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UIMAGE_Registers;  // NV1 User IMAGE Registers
    PHWREG NV1_Lin_UIMAGE_Registers;    // Linear address to User IMAGE Registers
    ULONG  NV1_UIMAGE_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UBITMAP_Registers;  // NV1 User IMAGE MONO Registers
    PHWREG NV1_Lin_UBITMAP_Registers;   // Linear address to User IMAGE MONO Registers
    ULONG  NV1_UBITMAP_Length;           // NV1 register window

    //**************************************************************************
    // NV3 Specific registers
    //**************************************************************************

    PHYSICAL_ADDRESS NV3_Phys_PRAMIN_Registers;   // NV3 RAMIN Registers
    PHWREG  NV3_Lin_PRAMIN_Registers;    // Linear address to RAMIN Registers
    ULONG  NV3_PRAMIN_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRMVIO_Registers;   // NV3 PRMVIO Registers
    PHWREG  NV3_Lin_PRMVIO_Registers;    // Linear address to PRMVIO Registers
    ULONG  NV3_PRMVIO_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRMCIO_Registers;   // NV3 PRMCIO Registers
    PHWREG  NV3_Lin_PRMCIO_Registers;    // Linear address to PRMCIO Registers
    ULONG  NV3_PRMCIO_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRAMDAC_Registers;   // NV3 PRAMDAC Registers
    PHWREG  NV3_Lin_PRAMDAC_Registers;    // Linear address to PRAMDAC Registers
    ULONG  NV3_PRAMDAC_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_USERDAC_Registers;   // NV3 USERDAC Registers
    PHWREG  NV3_Lin_USERDAC_Registers;    // Linear address to USERDAC Registers
    ULONG  NV3_USERDAC_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PVIDEO_Registers;   // NV3 USERDAC Registers
    PHWREG  NV3_Lin_PVIDEO_Registers;     // Linear address to USERDAC Registers
    ULONG  NV3_PVIDEO_Length;            // NV3 register window

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    PHYSICAL_ADDRESS PhysicalFrameBase;  // physical memory address and
    ULONG PhysicalFrameLength;           // length of display memory for the

    ULONG TextureDataLength;            //  Length of allocated texture data in Sys Mem

    ULONG DMABufferLength;            //  Length of allocated texture data in Sys Mem

    ULONG DMAPushLength;            // Size of DMA Push Buffer
    PVOID FrameBufferPtr;           // Get access to frame buffer

    //**************************************************************************
    // NV Software structures
    //**************************************************************************

    ULONG HashTable[HASH_DEPTH*256*2];   // Our local hash table
    ULONG ColorFormatTable[5];         // Color format conversion table
    GRAPHICSCHANNEL GrTable;           // Currently using 1 channel only
    FIFO FifoTable;                    // Currently using 1 channel only
    RENDEROBJECT RenderObject[15];     // Allocate up to 15 objects for now
    COMMONOBJECT CommonObject[10];     // Allocate up to 10 NON Render objects
    HWINFO NvInfo;                     // NVInfo structure information
    UCHAR CRTC[64];                    // Holds CRTC values
    UCHAR FreeInstanceUsage[NV_PRAM_MIN_SIZE_INSTANCE_MEM / 16];
                                       // Array denoting usage of FreeInstance mem
                                       // Each byte represents 1 paragraph of instance mem

    ULONG LastInstanceIndex;      //
    ULONG DisableVBlankFlag;      // Check for VBlank in OpenGL?
    PUSHORT BiosArea;             // address of the BIOS area
    USHORT OriginalBiosData;      // Orignal value in the Bios data area.

    BOOLEAN bLinearModeSupported; // Do we support linear modes?
    BOOLEAN bInLinearMode;        // Are we currently in a linear mode?
    ULONG ulSlot;                 // the slot that the card is in

    //**************************************************************************
    // Denotes if Flat panel is active or not
    //**************************************************************************

    BOOLEAN FlatPanelIsPresent;
    BOOLEAN TvIsPresent;
    BOOLEAN FlatPanelIsOff[NV_NO_DACS];

    //**************************************************************************
    // Max width and height of display (detected by RM)
    //**************************************************************************

    ULONG   MaxFlatPanelWidth;
    ULONG   MaxFlatPanelHeight;

    //**************************************************************************
    // Flag to denote if driver is being installed during unattended install
    //**************************************************************************

    BOOL    DeviceMappingFailed;
    
    //**************************************************************************
    // Save last DPMS state
    //**************************************************************************

    ULONG   CurrentDPMSState;
    
    //**************************************************************************
    // Used to save/restore power managment related registers for Win2k
    //**************************************************************************

    ULONG   Power_refresh;
    ULONG   Power_PfbBoot0;
    ULONG   Power_PfbConfig0;
    ULONG   Power_PfbConfig1;
    ULONG   Power_PfbMrs;
    ULONG   Power_PfbEmrs;
    ULONG   Power_PfbRef;
    ULONG   Power_PbusDebug1;
    ULONG   Power_PextdevBoot0;
    ULONG   Power_PfifoRamHT;
    ULONG   Power_PfifoRamRO;
    ULONG   Power_PfifoRamFC;    
    ULONG   Power_coeff_select;
    ULONG   Power_nvpll;
    ULONG   Power_vpll;
    ULONG   Power_mpll;

    ULONG   Master_Enable;
    ULONG   Fifo_Mode    ;
    ULONG   Numerator    ;
    ULONG   Denominator  ;
    ULONG   PCINV19      ;

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM
    FLONG   flMapMemory;            // Flags passed to VideoPortMapMemory for mapping fb
    BOOLEAN bHwVidOvl;              // Is hw video overlay supported in the current mode?
    ULONG   bEnableIF09;             // Should we support IF09 format video data?
    ULONG   bUseDMT;                // Did a registry flag indicate we should use DMT
                                    // monitor timings?

    // MP/RM integration...
    PHWREG      NvRegisterBase;
    PHWREG      FrameBufferBase;
    ULONG       DeviceReference;

    ULONG       curPowerState;      // Last known power state of the device
    ULONG       ulRmTurnedOffMonitor;     // Last known value power state of monitor

#if _WIN32_WINNT < 0x0500
    ULONG       bExtRefreshDisable;     // DWORD is defined in INF file
#endif // #if _WIN32_WINNT < 0x0500
    ULONG       bMax16x12;
    ULONG       bDisable19x12x32at60;
    ULONG       bDisable19x10x32ge70;
    ULONG       bDisable16x12x32ge70;
    ULONG       bDellSwitch1;
    ULONG       OglStencilSwitch;
    ULONG       ulForceSwCursor;

    ULONG       Via694ChipsetFound;
    ULONG       AMD751ChipsetFound;
    USHORT      AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT;
    ULONG       AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG;
    PHWREG      AMD751_BAR1_Mapped_Address;
    ULONG       AliChipset_Problem_Found;
    PVOID       AliFixupIOBase;
    ULONG       LastWidth;
    ULONG       LastHeight;
    ULONG       LastDepth;
    ULONG       LastRefreshRate;

    ULONG       SavedPMCState;


    ULONG       BiosRevision;
    PUCHAR      pBios;
#if _WIN32_WINNT >= 0x0500
    BOOLEAN     bAgp;
    BOOLEAN     bDisableAgp;
    VIDEO_PORT_AGP_SERVICES AgpServices;
    PHYSICAL_ADDRESS AgpAddressRange;
    ULONG       AgpPagesTotal;
    PVOID       *AgpPhysContext;
    PVOID       dummyVirtualContext;
    PVOID       AgpHeapBase;
    PVOID       AgpVirtualBaseAddress;
    ULONGLONG   SystemMemorySize;
#endif // #if _WIN32_WINNT >= 0x0500

    // per-device PCI addresses
    VIDEO_ACCESS_RANGE NVAccessRanges[NV_PHYSICAL_ADDRESS_QTY];


// Added to support gamma clut support
   VIDEO_CLUT       GammaCache;
   VIDEO_CLUTDATA   GammaCacheData[NV_NO_DACS*256];    // Make it 256 just to be safe...

// Added to support GTF or DMT method selection
    ULONG   bUseGTF; // Did a registry flag indicate we should use GTF?
    // On the fly valid device mode work area
    USHORT ValidDeviceModeTable[MAX_VALID_MODE_TABLE_DATA_WORDS];

    // VPE integration
    ULONG       BusInterruptLevel;
    ULONG       BusInterruptVector;
    PVOID       IRQCallback;
    PVOID       pIRQData;
    ULONG       dwIRQSources;

#ifdef NVPE
    /////////// 
    // H.AZAR: (02/15/99)
    NVP_CONTEXT avpContexts[NVP_MAX_VPORTS];
    ULONG       dwVPEEnabled;       // TRUE Enabled/default, FALSE disabled (registry key)
    ///////////
#endif // NVPE

    // TwinView related fields with info about the dacs.
    //**************************************************************************
    // Saved EDID Buffer
    //**************************************************************************
    UCHAR EDIDBuffer[NV_NO_CONNECTORS][EDID_V2_SIZE];
    ULONG EDIDBufferValid[NV_NO_CONNECTORS]; // Whether this EDID buffer for this head is valid.
    ULONG EDIDBufferSize[NV_NO_CONNECTORS];
    //
    // The max pixelclock frequencies of each head as returned by ResMan.
    // Note: if CRT is connected for second head, only then should we
    // use the pixel clock for the second head. Otherwise, we use the pixel clock of
    // DAC 0 for both heads.
    //
    ULONG maxPixelClockFrequency_8bpp[NV_NO_DACS];
    ULONG maxPixelClockFrequency_16bpp[NV_NO_DACS];
    ULONG maxPixelClockFrequency_32bpp[NV_NO_DACS];

    //
    // We create a mapping array from Win2K's power state to NVidia's supported power states
    //
    ULONG NVMonitorPowerState[NV_NO_DACS][MAX_WIN2K_POWER_STATES];
    ULONG NVAdapterPowerState[MAX_WIN2K_POWER_STATES];
    
    NV_DESKTOP_INFO DeskTopInfo;         // Information about the virtual desktop
    // End TwinView related fields

#if (_WIN32_WINNT >= 0x0500)
    // macrovision
    ULONG ulCurrentMacrovisionKey;
    ULONG ulNextMacrovisionKey;
    ULONG ulMacrovisionMode;
#endif

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;



//
// Function prototypes.
//

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

//
// Bank switch code start and end labels, define in HARDWARE.ASM
//

extern UCHAR BankSwitchStart;
extern UCHAR PlanarHCBankSwitchStart;
extern UCHAR EnablePlanarHCStart;
extern UCHAR DisablePlanarHCStart;
extern UCHAR BankSwitchEnd;

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];

extern MEMORYMAPS MemoryMaps[];

extern VIDEOMODE ModesVGA[];
extern ULONG NumVideoModes;

extern RANGE_OFFSETS RangeOffsets[NV_NUM_RANGES];

extern VIDEO_ACCESS_RANGE VgaAccessRange[];
extern VIDEO_ACCESS_RANGE VgaPaletteAccessRange;

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     6
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 4
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 2
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];



//
// These are macros used to call the VideoPort AGP functions. Their
// purpose is to make the code more readable. VideoPortGetAGPServices
// MUST be called prior to invoking these macros.
//
#define VideoPortAgpReservePhysical(_HwDeviceExt, _Pages, _Caching, _PhysContext) \
(_HwDeviceExt)->AgpServices.AgpReservePhysical((_HwDeviceExt), (_Pages), \
                (_Caching), (_PhysContext))

#define VideoPortAgpReleasePhysical(_HwDeviceExt, _PhysContext) \
(_HwDeviceExt)->AgpServices.AgpReleasePhysical((_HwDeviceExt), (_PhysContext))

#define VideoPortAgpCommitPhysical(_HwDeviceExt, _PhysContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpCommitPhysical((_HwDeviceExt), (_PhysContext), \
                _Pages, _Offset)

#define VideoPortAgpFreePhysical(_HwDeviceExt, _PhysContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpFreePhysical((_HwDeviceExt), \
                (_PhysContext), (_Pages), (_Offset))

#define VideoPortAgpReserveVirtual(_HwDeviceExt, _Pid, _PhysContext, _VirtContext) \
(_HwDeviceExt)->AgpServices.AgpReserveVirtual((_HwDeviceExt), (_Pid), \
                (_PhysContext), (_VirtContext))

#define VideoPortAgpReleaseVirtual(_HwDeviceExt, _VirtContext) \
(_HwDeviceExt)->AgpServices.AgpReleaseVirtual((_HwDeviceExt), (_VirtContext))

#define VideoPortAgpCommitVirtual(_HwDeviceExt, _VirtContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpCommitVirtual((_HwDeviceExt), (_VirtContext), \
                (_Pages), (_Offset))

#define VideoPortAgpFreeVirtual(_HwDeviceExt, _VirtContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpFreeVirtual((_HwDeviceExt), (_VirtContext), \
                (_Pages), (_Offset))

//******************************************************************************
// Capabilities flags
//
// These are private flags passed to the NV display driver.  They
// come from the 'DriverSpecificAttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the display drivers 'driver.h'!
//******************************************************************************

typedef enum {
    CAPS_NV1_IS_PRESENT     = 0x00000010,   // NV1 Chip is present
    CAPS_NV3_IS_PRESENT     = 0x00000020,   // NV3 Chip is present
    CAPS_NV4_IS_PRESENT     = 0x00000040,   // NV4 Chip is present
    CAPS_NV5_IS_PRESENT     = 0x00000080,   // NV5 Chip is present
    CAPS_NV5VANTA_IS_PRESENT= 0x00000100,   // NV5 VANTA Chip is present
    CAPS_NV5ULTRA_IS_PRESENT= 0x00000200,   // NV5 ULTRA Chip is present
    CAPS_NV0A_IS_PRESENT    = 0x00000400,   // NV0A Chip is present
    CAPS_NV10_IS_PRESENT    = 0x00000800,   // NV10 Chip is present
  CAPS_NV5MODEL64_IS_PRESENT= 0x00001000,   // NV5 MODEL64 Chip is present
  CAPS_NV10DDR_IS_PRESENT   = 0x00002000,   // NV10 DDR Chip is present
  CAPS_NV10GL_IS_PRESENT    = 0x00004000,   // NV10 GL Chip is present
  CAPS_NV11_IS_PRESENT      = 0x00008000,   // NV11 Chip is present
  CAPS_NV11DDR_IS_PRESENT   = 0x00010000,   // NV11 DDR Chip is present
// defined at end of list:    CAPS_NV11M_IS_PRESENT   = 0x80000000,   // NV11M Chip is present
  CAPS_NV11GL_IS_PRESENT    = 0x00020000,   // NV11 GL Chip is present
  CAPS_NV15_IS_PRESENT      = 0x00040000,   // NV15 Chip is present
  CAPS_NV15DDR_IS_PRESENT   = 0x00080000,   // NV15 DDR Chip is present
  CAPS_NV15GL_IS_PRESENT    = 0x00100000,   // NV15 GL Chip is present
  CAPS_NV15BR_IS_PRESENT    = 0x00200000,   // NV15 BR Chip is present
  CAPS_NV20_IS_PRESENT      = 0x00400000,   // NV20 Chip is present
// not used    CAPS_TI025_POINTER      = 0x00800000,   // Use TI TVP3020/3025 pointer
// not used    CAPS_SCALE_POINTER      = 0x01000000,   // Set if the S3 hardware pointer
// not used                                            //   x position has to be scaled by
// not used                                            //   two
// not used    CAPS_SPARSE_SPACE       = 0x02000000,   // Frame buffer is mapped in sparse
// not used                                            //   space on the Alpha
// not used    CAPS_NEW_BANK_CONTROL   = 0x04000000,   // Set if 801/805/928 style banking
// not used    CAPS_NEWER_BANK_CONTROL = 0x08000000,   // Set if 864/964 style banking
// not used    CAPS_RE_REALIZE_PATTERN = 0x10000000,   // Set if we have to work around the
// not used                                            //   864/964 hardware pattern bug
// not used    CAPS_SLOW_MONO_EXPANDS  = 0x20000000,   // Set if we have to slow down
// not used                                            //   monochrome expansions
    CAPS_SW_POINTER         = 0x40000000,   // No hardware pointer; use software simulation
    CAPS_NV11M_IS_PRESENT   = 0x80000000,   // NV11M Chip is present


} CAPS;

//**********************************************************************************
// Defines for VESA power management function.
//**********************************************************************************
#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f

#if DBG
VOID DbgBreakPoint(VOID);
#define NvDbgBreak() DbgBreakPoint();
#else
#define NvDbgBreak()
#endif

//******************************************************************************
// External declarations.
//******************************************************************************
BOOLEAN NVGetNVInfo(PHW_DEVICE_EXTENSION);
//BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PULONG);
ULONG NVMapMemoryRanges(PVOID);
ULONG NVMapFrameBuffer(PVOID HwDeviceExtension);
ULONG NVMapVgaPaletteRegisters(PHW_DEVICE_EXTENSION);
VOID NVGetMonitorType(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID NV_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NVSetBiosInfo(PHW_DEVICE_EXTENSION);
VOID wtoa(USHORT, PUCHAR, UCHAR, UCHAR);

#if _WIN32_WINNT < 0x0500
ULONG wcslen(PWCHAR pString);
#endif // #if _WIN32_WINNT < 0x0500

#if _WIN32_WINNT >= 0x0500
VOID NV_SetPixMixBits(PHW_DEVICE_EXTENSION);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\nv3a_ref.h ===
/* @(#) $Header: /drivers/display/WINNT40/miniport/NV_MINI/NV3A_REF.H 2     1/10/97 7:10p Vidall $
 NVidia Corporation */
/* basis: nv1 manuals 10.1
 95/06/27 NVidia Corporation */

#ifndef _NV_REF_H_
#define _NV_REF_H_

/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID                           15:0 /* C--UF */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA_SGS          0x000012D2 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC                     18:16 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA            0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP                     31:19 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1            0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV3            0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_1_IO_SPACE                             0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED             0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE                         1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL                      4:4 /* C--VF */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED      0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED       0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP                        5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_DISABLED        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_ENABLED         0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_CAPLIST                            20:20 /* R--VF */
#define NV_CONFIG_PCI_NV_1_CAPLIST_NOT_PRESENT           0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_CAPLIST_PRESENT               0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ                              21:21 /* C--VF */
#define NV_CONFIG_PCI_NV_1_66MHZ_INCAPABLE               0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ_CAPABLE                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK                     23:23 /* C--VF */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE        0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                      26:25 /* C--VF */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM          0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET                    27:27 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET                    28:28 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER                    29:29 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_2                               0x00000008 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_2_REVISION_ID                          7:0 /* C--UF */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_A                 0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE                          31:8 /* C--VF */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA                0x00030000 /* C---V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA         0x00048000 /* ----V */
#define NV_CONFIG_PCI_NV_3                               0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER                      15:11 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS      0x0000001E /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS      0x0000001F /* RW--V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE                        23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_SINGLEFUNC        0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC         0x00000080 /* ----V */
#define NV_CONFIG_PCI_NV_4                               0x00000010 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE         0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_5                               0x00000014 /* RW-4R */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_NOT              0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_MERGABLE         0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_5_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_6                               0x00000018 /* RW-4R */
#define NV_CONFIG_PCI_NV_6__ALIAS_1                NV_PBUS_PCI_NV_6 /*       */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_MEMORY             0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_IO                 0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_6_BASE_ADDRESS                        31:8 /* RWXUF */
#define NV_CONFIG_PCI_NV_7(i)                    (0x0000001C+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_7__SIZE_1                                4 /*       */
#define NV_CONFIG_PCI_NV_7__ALIAS_1                NV_PBUS_PCI_NV_7 /*       */
#define NV_CONFIG_PCI_NV_7_RESERVED                            31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_7_RESERVED_0                    0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_11                              0x0000002C /* R--4R */
#define NV_CONFIG_PCI_NV_11__ALIAS_1              NV_PBUS_PCI_NV_11 /*       */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID               31:16 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID                       15:0 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_12                              0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE                          0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED          0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED           0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_12_ROM_BASE                          31:22 /* RWXUF */
#define NV_CONFIG_PCI_NV_13                              0x00000034 /* RW-4R */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_13_CAP_PTR                             7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_13_CAP_PTR_AGP                  0x00000044 /* C---V */
#define NV_CONFIG_PCI_NV_14                              0x00000038 /* R--4A */
#define NV_CONFIG_PCI_NV_14__ALIAS_1              NV_PBUS_PCI_NV_14 /*       */
#define NV_CONFIG_PCI_NV_14_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_14_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_15                              0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_15_INTR_LINE                           7:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0               0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1               0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15              0x0000000F /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN            0x000000FF /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_PIN                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_15_INTR_PIN_INTA                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT                           23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_750NS                0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT                           31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_250NS                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_16                              0x00000040 /* RW-4R */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID               31:16 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID                       15:0 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_17                              0x00000044 /* RW-4R */
#define NV_CONFIG_PCI_NV_17__ALIAS_1              NV_PBUS_PCI_NV_17 /*       */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR                     23:20 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR_1              0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR                     19:16 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR_0              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR_NULL                0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_CAP_ID                              7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_17_CAP_ID_AGP                   0x00000002 /* C---V */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ                     31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ_4              0x00000004 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA                      9:9 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA_NONE          0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE                     1:0 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X           0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH              31:24 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0       0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE              8:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF   0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE               1:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF    0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20                              0x00000050 /* RW-4R */
#define NV_CONFIG_PCI_NV_20__ALIAS_1              NV_PBUS_PCI_NV_20 /*       */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER                       0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_DISABLED       0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_ENABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS                        1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_DISABLED        0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_ENABLED         0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO                           3:3 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ                          4:4 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_DISABLED          0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_ENABLED           0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING                         5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_DISABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_ENABLED          0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO                        7:7 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_ENABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_DISABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE                             9:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SB_BASE_220H                 0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_240H                 0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_260H                 0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE                          13:12 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_330H                0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_230H                0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_300H                0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP                         16:16 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_21                              0x00000054 /* RW-4R */
#define NV_CONFIG_PCI_NV_21__ALIAS_1              NV_PBUS_PCI_NV_21 /*       */
#define NV_CONFIG_PCI_NV_21_VGA                                 0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_21_VGA_DISABLED                 0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_21_VGA_ENABLED                  0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_22                              0x00000058 /* RW-4R */
#define NV_CONFIG_PCI_NV_22__ALIAS_1              NV_PBUS_PCI_NV_22 /*       */
#define NV_CONFIG_PCI_NV_22_SCRATCH                            23:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_22_SCRATCH_DEFAULT              0x0023D6CE /* RWI-V */
#define NV_CONFIG_PCI_NV_23(i)                   (0x0000005C+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_23__SIZE_1                              41 /*       */
#define NV_CONFIG_PCI_NV_23__ALIAS_1              NV_PBUS_PCI_NV_23 /*       */
#define NV_CONFIG_PCI_NV_23_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_23_RESERVED_0                   0x00000000 /* C---V */
/* dev_bus.ref */
#define NV_RMA_ID                                        0x00000000 /* R--4R */
#define NV_RMA_ID__ALIAS_1                          NV_PRMIO_RMA_ID /*       */
#define NV_RMA_ID_CODE                                         31:0 /* C--UF */
#define NV_RMA_ID_CODE_VALID                             0x2B16D065 /* C---V */
#define NV_RMA_PTR                                       0x00000004 /* RW-4R */
#define NV_RMA_PTR__ALIAS_1                        NV_PRMIO_RMA_PTR /*       */
#define NV_RMA_PTR_ADDRESS                                     24:2 /* RWXUF */
#define NV_RMA_DATA                                      0x00000008 /* RW-4R */
#define NV_RMA_DATA__ALIAS_1                      NV_PRMIO_RMA_DATA /*       */
#define NV_RMA_DATA_PORT                                       31:0 /* RWXUF */
#define NV_RMA_DATA32                                    0x0000000C /* RW-2R */
#define NV_RMA_DATA32__ALIAS_1                  NV_PRMIO_RMA_DATA32 /*       */
#define NV_RMA_DATA32_MSW                                     31:16 /* -WXUF */
#define NV_RMA_DATA32_LSW                                      15:0 /* RWXUF */
#define NV_RMA_INCDATA                                   0x00000010 /* RW-4R */
#define NV_RMA_INCDATA__ALIAS_1                NV_PRMIO_RMA_INCDATA /*       */
#define NV_RMA_INCDATA_PORT                                    31:0 /* RWXUF */
#define NV_RMA_INCDATA32                                 0x00000014 /* RW-4R */
#define NV_RMA_INCDATA32__ALIAS_1            NV_PRMIO_RMA_INCDATA32 /*       */
#define NV_RMA_INCDATA32_PORT                                  31:0 /* RWXUF */
/* dev_bus.ref */
#define NV_RMAIO                              0x000000FF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
#define NV_PRMIO_RMA_ID__ALIAS_1                          NV_RMA_ID /*       */
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
#define NV_PRMIO_RMA_PTR__ALIAS_1                        NV_RMA_PTR /*       */
#define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
#define NV_PRMIO_RMA_DATA__ALIAS_1                      NV_RMA_DATA /*       */
#define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-2R */
#define NV_PRMIO_RMA_DATA32__ALIAS_1                  NV_RMA_DATA32 /*       */
#define NV_PRMIO_RMA_INCDATA                             0x00007110 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA__ALIAS_1                NV_RMA_INCDATA /*       */
#define NV_PRMIO_RMA_INCDATA32                           0x00007114 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA32__ALIAS_1            NV_RMA_INCDATA32 /*       */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_realmode.ref */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_IO_DMA_0000                                   0x00000000 /* -W-1R */
#define NV_IO_DMA_0000_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0001                                   0x00000001 /* -W-1R */
#define NV_IO_DMA_0001_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0002                                   0x00000002 /* -W-1R */
#define NV_IO_DMA_0002_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0003                                   0x00000003 /* -W-1R */
#define NV_IO_DMA_0003_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0004                                   0x00000004 /* -W-1R */
#define NV_IO_DMA_0004_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0005                                   0x00000005 /* -W-1R */
#define NV_IO_DMA_0005_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0006                                   0x00000006 /* -W-1R */
#define NV_IO_DMA_0006_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0007                                   0x00000007 /* -W-1R */
#define NV_IO_DMA_0007_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0008                                   0x00000008 /* -W-1R */
#define NV_IO_DMA_0008_CONTROLLER                               2:2 /* -W-VF */
#define NV_IO_DMA_0008_CONTROLLER_DISABLED               0x00000000 /* -W--V */
#define NV_IO_DMA_0008_CONTROLLER_ENABLED                0x00000001 /* -W--V */
#define NV_IO_DMA_000A                                   0x0000000A /* -W-1R */
#define NV_IO_DMA_000A_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000A_MASK_BIT                                 2:2 /* -W-VF */
#define NV_IO_DMA_000A_MASK_BIT_CLEAR                    0x00000000 /* -W--V */
#define NV_IO_DMA_000A_MASK_BIT_SET                      0x00000001 /* -W--V */
#define NV_IO_DMA_000B                                   0x0000000B /* -W-1R */
#define NV_IO_DMA_000B_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000B_AUTOINITIALIZE                           4:4 /* -W-VF */
#define NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED           0x00000000 /* -W--V */
#define NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED            0x00000001 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION                                5:5 /* -W-VF */
#define NV_IO_DMA_000B_DIRECTION_INCREMENT               0x00000000 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION_DECREMENT               0x00000001 /* -W--V */
#define NV_IO_DMA_000C                                   0x0000000C /* -W-1R */
#define NV_IO_DMA_000C_CLEAR_FLIPFLOP                           7:0 /* -W-VF */
#define NV_IO_DMA_0081                                   0x00000081 /* -W-1R */
#define NV_IO_DMA_0081_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0082                                   0x00000082 /* -W-1R */
#define NV_IO_DMA_0082_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0083                                   0x00000083 /* -W-1R */
#define NV_IO_DMA_0083_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0087                                   0x00000087 /* -W-1R */
#define NV_IO_DMA_0087_ADDRESS                                  3:0 /* -W-UF */
/* dev_dac.ref */
#define NV_PRAMDAC                            0x00680FFF:0x00680300 /* RW--D */
#define NV_PRAMDAC_CU_START_POS                          0x00680300 /* RW-4R */
#define NV_PRAMDAC_CU_START_POS_X                              11:0 /* RWXSF */
#define NV_PRAMDAC_CU_START_POS_Y                             27:16 /* RWXSF */
#define NV_PRAMDAC_APLL_COEFF                            0x00680500 /* RW-4R */
#define NV_PRAMDAC_APLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_MPLL_COEFF                            0x00680504 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_VPLL_COEFF                            0x00680508 /* RW-4R */
#define NV_PRAMDAC_VPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT                      0x0068050C /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS                  4:4 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_FALSE     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_TRUE      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE                 8:8 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS               12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE               16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS               20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE               25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VPLL     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VIP      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_XTALOSC  0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO                28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL                     0x00680510 /* RW-4R */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                 0x0000044E /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER                      0x00680514 /* RW-4R */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS                  9:0 /* -WIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VALUE                      15:0 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE                    16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET                     20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK          0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_ACLK          0x00000010 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST                  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED   0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCK                 29:29 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK                 30:30 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK                 31:31 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_TEST                          0x00680518 /* RW-4R */
#define NV_PRAMDAC_PALETTE_TEST_BLUE_DATA                       7:0 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_GREEN_DATA                     15:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_RED_DATA                      23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_MODE                          24:24 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_MODE_8BIT                0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_MODE_24BIT               0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC                       28:28 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE        0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL                       0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF                     1:0 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF_DEF          0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE                     4:4 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_GAMMA        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_INDEX        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE                    8:8 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSE       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE                   12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_NOTSEL       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_SEL          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL                 16:16 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION                17:17 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM     0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM     0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC                        20:20 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS             0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS             0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP                  24:24 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS         0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK                28:28 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS       0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_RECOVERY                      0x00680604 /* R--4R */
#define NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              7:0 /* R--UF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER                10:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED      0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN    0x00000010 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE     0x00000100 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE                 13:12 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE      0x00000000 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ       0x00000011 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA                  23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA                31:24 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL                          0x00680608 /* RW-4R */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET                       0:0 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE                      4:4 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL                     9:8 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE         0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN        0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED          0x00000010 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN                     12:12 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC                    16:16 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF           0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM                         20:20 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_TEST               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1                        24:24 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_SET               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31                       25:25 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_SET              0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB                        28:28 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO            0x00000000 /* R---V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI             0x00000001 /* R---V */
#define NV_PRAMDAC_CHECKSUM                              0x0068060C /* R--4R */
#define NV_PRAMDAC_CHECKSUM_VALUE                              23:0 /* R--VF */
#define NV_PRAMDAC_TESTPOINT_DATA                        0x00680610 /* -W-4R */
#define NV_PRAMDAC_TESTPOINT_DATA_RED                           9:0 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_GREEN                       19:10 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLUE                        29:20 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLACK                       30:30 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK                    31:31 /* -W-VF */
#define NV_PRAMDAC_VSERR_WIDTH                           0x00680700 /* RW-4R */
#define NV_PRAMDAC_VSERR_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_END                              0x00680704 /* RW-4R */
#define NV_PRAMDAC_VEQU_END_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_END                           0x00680708 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_END_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_END                            0x0068070C /* RW-4R */
#define NV_PRAMDAC_VBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_START                          0x00680710 /* RW-4R */
#define NV_PRAMDAC_VBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_START                         0x00680714 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_START_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_START                            0x00680718 /* RW-4R */
#define NV_PRAMDAC_VEQU_START_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VTOTAL                                0x0068071C /* RW-4R */
#define NV_PRAMDAC_VTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HSYNC_WIDTH                           0x00680720 /* RW-4R */
#define NV_PRAMDAC_HSYNC_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_START                          0x00680724 /* RW-4R */
#define NV_PRAMDAC_HBURST_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_END                            0x00680728 /* RW-4R */
#define NV_PRAMDAC_HBURST_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_START                          0x0068072C /* RW-4R */
#define NV_PRAMDAC_HBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_END                            0x00680730 /* RW-4R */
#define NV_PRAMDAC_HBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HTOTAL                                0x00680734 /* RW-4R */
#define NV_PRAMDAC_HTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HEQU_WIDTH                            0x00680738 /* RW-4R */
#define NV_PRAMDAC_HEQU_WIDTH_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HSERR_WIDTH                           0x0068073C /* RW-4R */
#define NV_PRAMDAC_HSERR_WIDTH_VAL                             10:0 /* RWIVF */
/* dev_dac.ref */
#define NV_USER_DAC                           0x00681FFF:0x00681200 /* RW--D */
#define NV_USER_DAC_PIXEL_MASK                           0x006813C6 /* RWI1R */
#define NV_USER_DAC_PIXEL_MASK_VALUE                            7:0 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK_MASK                      0x000000FF /* RWI-V */
#define NV_USER_DAC_READ_MODE_ADDRESS                    0x006813C7 /* RW-1R */
#define NV_USER_DAC_READ_MODE_ADDRESS_VALUE                     7:0 /* RW-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE                  7:0 /* -W-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE                  1:0 /* R--VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE     0x00000000 /* R---V */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ      0x00000011 /* R---V */
#define NV_USER_DAC_WRITE_MODE_ADDRESS                   0x006813C8 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE                    7:0 /* RW-VF */
#define NV_USER_DAC_PALETTE_DATA                         0x006813C9 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA_VALUE                          7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
#define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
#define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
#define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_FIB_REVISION                              3:0 /* C--VF */
#define NV_PMC_BOOT_0_FIB_REVISION_0                     0x00000000 /* ----V */
#define NV_PMC_BOOT_0_FIB_REVISION_1                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_FIB_REVISION_2                     0x00000002 /* C---V */
#define NV_PMC_BOOT_0_MASK_REVISION                             7:4 /* C--VF */
#define NV_PMC_BOOT_0_MASK_REVISION_A                    0x00000000 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION_B                    0x00000001 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION_C                    0x00000002 /* C---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           15:8 /* R--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV0                 0x00000000 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1V32              0x00000001 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1D32              0x00000002 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_PICASSO             0x00000003 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV2MUTARA           0x00000004 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV3                 0x00000005 /* R---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            23:16 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV3                   0x00000003 /* C---V */
#define NV_PMC_BOOT_0_MANUFACTURER                            27:24 /* C--UF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY                                 31:28 /* C--VF */
#define NV_PMC_BOOT_0_FOUNDRY_SGS                        0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY_HELIOS                     0x00000001 /* ----V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PAUDIO                                    0:0 /* R--VF */
#define NV_PMC_INTR_0_PAUDIO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PAUDIO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PMEDIA                                    4:4 /* R--VF */
#define NV_PMC_INTR_0_PMEDIA_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PMEDIA_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0                                 12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH0_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1                                 13:13 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH1_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PVIDEO                                  16:16 /* R--VF */
#define NV_PMC_INTR_0_PVIDEO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PVIDEO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFB                                     24:24 /* R--VF */
#define NV_PMC_INTR_0_PFB_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFB_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_PBUS                                    28:28 /* R--VF */
#define NV_PMC_INTR_0_PBUS_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PBUS_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                31:31 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PAUDIO                                    0:0 /* RWIVF */
#define NV_PMC_ENABLE_PAUDIO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PAUDIO_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PMEDIA                                    4:4 /* RWIVF */
#define NV_PMC_ENABLE_PMEDIA_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PMEDIA_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PPMI                                    16:16 /* RWIVF */
#define NV_PMC_ENABLE_PPMI_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PPMI_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     20:20 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PCRTC                                   24:24 /* RWIVF */
#define NV_PMC_ENABLE_PCRTC_DISABLED                     0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PCRTC_ENABLED                      0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO                                  28:28 /* RWIVF */
#define NV_PMC_ENABLE_PVIDEO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO_ENABLED                     0x00000001 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_MODE                                    0:0 /* RWIVF */
#define NV_PBUS_DEBUG_0_MODE_DISABLED                    0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MODE_ENABLED                     0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_DESKEWER                                4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_DESKEWER_ENABLED                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_DESKEWER_BYPASS                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                        11:8 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_SEL_0                              0x00001090 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_1                              0x00001094 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_2                              0x00001098 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_3                              0x0000109C /* RW-4R */
#define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_HOST                               0x000010A0 /* RW-4R */
#define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
#define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_AGP                                2:2 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_AGP                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_PCI                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE                              5:5 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO                            11:11 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1                                13:13 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE2                                14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
#define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0                                0x00001E80 /* RW-4R */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                        7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                       15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                      23:16 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT                            24:24 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                 0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_SET                   0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                      25:25 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED        0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION                           26:26 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT            0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CHANNEL                             29:28 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER                          30:30 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP                            31:31 /* RWIVF */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0                0x00000000 /* RWI-V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1                0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_1                                0x00001E84 /* RW-4R */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_0                          7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_1                         15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_STATE                               28:28 /* RWXVF */
#define NV_PBUS_RMC_DMA_1_STATE_CLEAN                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_1_STATE_DIRTY                    0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_0                                 0x00001800 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_NV_1                                 0x00001804 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_NV_2                                 0x00001808 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_3                                 0x0000180C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_4                                 0x00001810 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_NV_5                                 0x00001814 /* RW-4R */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_NV_6                                 0x00001818 /* RW-4R */
#define NV_PBUS_PCI_NV_6__ALIAS_1                NV_CONFIG_PCI_NV_6 /*       */
#define NV_PBUS_PCI_NV_7(i)                      (0x0000181C+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_7__SIZE_1                                  4 /*       */
#define NV_PBUS_PCI_NV_7__ALIAS_1                NV_CONFIG_PCI_NV_7 /*       */
#define NV_PBUS_PCI_NV_11                                0x0000182C /* R--4R */
#define NV_PBUS_PCI_NV_11__ALIAS_1              NV_CONFIG_PCI_NV_11 /*       */
#define NV_PBUS_PCI_NV_12                                0x00001830 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_NV_13                                0x00001834 /* RW-4R */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_NV_14                                0x00001838 /* R--4A */
#define NV_PBUS_PCI_NV_14__ALIAS_1              NV_CONFIG_PCI_NV_14 /*       */
#define NV_PBUS_PCI_NV_15                                0x0000183C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_NV_16                                0x00001840 /* RW-4R */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
#define NV_PBUS_PCI_NV_17                                0x00001844 /* RW-4R */
#define NV_PBUS_PCI_NV_17__ALIAS_1              NV_CONFIG_PCI_NV_17 /*       */
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_PBUS_PCI_NV_20                                0x00001850 /* RW-4R */
#define NV_PBUS_PCI_NV_20__ALIAS_1              NV_CONFIG_PCI_NV_20 /*       */
#define NV_PBUS_PCI_NV_21                                0x00001854 /* RW-4R */
#define NV_PBUS_PCI_NV_21__ALIAS_1              NV_CONFIG_PCI_NV_21 /*       */
#define NV_PBUS_PCI_NV_22                                0x00001858 /* RW-4R */
#define NV_PBUS_PCI_NV_22__ALIAS_1              NV_CONFIG_PCI_NV_22 /*       */
#define NV_PBUS_PCI_NV_23(i)                     (0x0000185C+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_23__SIZE_1                                41 /*       */
#define NV_PBUS_PCI_NV_23__ALIAS_1              NV_CONFIG_PCI_NV_23 /*       */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             7:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PUSHER                            12:12 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING           0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_PENDING               0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_RESET                 0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PTE                               16:16 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PTE_NOT_PENDING              0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_PENDING                  0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_RESET                    0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER                         12:12 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED            0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE                            16:16 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_DISABLED              0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_ENABLED               0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0                                0x00002200 /* RW-4R */
#define NV_PFIFO_CONFIG_0_DMA_FETCH                            10:8 /* RWXVF */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_32_BYTES             0x00000000 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_64_BYTES             0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_96_BYTES             0x00000002 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_128_BYTES            0x00000003 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_160_BYTES            0x00000004 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_192_BYTES            0x00000005 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_224_BYTES            0x00000006 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_256_BYTES            0x00000007 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_WATERMARK                       22:18 /* RWXVF */
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
#define NV_PFIFO_RAMHT_BASE_ADDRESS                           15:12 /* RWXVF */
#define NV_PFIFO_RAMHT_BASE_ADDRESS_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWXVF */
#define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
#define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
#define NV_PFIFO_RAMFC_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_1C00                 0x00001C00 /* RWI-V */
#define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
#define NV_PFIFO_RAMRO_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_1E00                 0x00001E00 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWXVF */
#define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003004 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA0                             0x00003220 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA0_ACCESS                             0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_DISABLED             0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_ENABLED              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA0_STATE                              4:4 /* R-IVF */
#define NV_PFIFO_CACHE1_DMA0_STATE_IDLE                  0x00000000 /* R-I-V */
#define NV_PFIFO_CACHE1_DMA0_STATE_BUSY                  0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA1                             0x00003224 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA1_LENGTH                            23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA2                             0x00003228 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA2_ADDRESS                           23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3                             0x0000322C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE                        1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_PCI             0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_AGP             0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS                       0x00003218 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD                      12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_SUBCHANNEL                 15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD_COUNT               28:18 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON                     30:30 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_DONE           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_NON_CACHE      0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   23:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x00003234 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE                        0:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_PRESENT         0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE                  0x00003238 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE_ADDRESS                19:2 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003040 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003240 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_CTX                               4:4 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_CTX_CLEAN                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_CTX_DIRTY                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_STATUS                           0x00003014 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003214 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_RANOUT                           0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX(i)                  (0x00003080+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE0_CTX__SIZE_1                               1 /*       */
#define NV_PFIFO_CACHE0_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE0_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_CTX(i)                  (0x00003280+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE1_CTX__SIZE_1                               8 /*       */
#define NV_PFIFO_CACHE1_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE1_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003300+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                           32 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003304+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                             32 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    6:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /*       */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_audio.ref */
#define NV_PAUDIO                             0x00300FFF:0x00300000 /* RW--D */
#define NV_PAUDIO_PINS                                   0x00300000 /* RW-4R */
#define NV_PAUDIO_PINS_SI_DELAY                                 0:0 /* RWIVF */
#define NV_PAUDIO_PINS_SI_DELAY_NORMAL                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SI_DELAY_I2S                      0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SI_EDGE                                  1:1 /* RWIVF */
#define NV_PAUDIO_PINS_SI_EDGE_NEGATIVE                  0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SI_EDGE_POSITIVE                  0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SO_DELAY                                 4:4 /* RWIVF */
#define NV_PAUDIO_PINS_SO_DELAY_NORMAL                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SO_DELAY_I2S                      0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SO_EDGE                                  5:5 /* RWIVF */
#define NV_PAUDIO_PINS_SO_EDGE_NEGATIVE                  0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SO_EDGE_POSITIVE                  0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_FMT_AC97                                 8:8 /* RWIVF */
#define NV_PAUDIO_PINS_SERIAL                                   9:9 /* RWIVF */
#define NV_PAUDIO_PINS_SERIAL_DISABLED                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SERIAL_ENABLED                    0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_LEFT_JUST                              10:10 /* RWIVF */
#define NV_PAUDIO_PINS_LEFT_SENSE                             11:11 /* RWIVF */
#define NV_PAUDIO_PINS_LEFT_LOW                          0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_LEFT_HIGH                         0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL                                14:12 /* RWIVF */
#define NV_PAUDIO_PINS_CONTROL_0                         0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_CONTROL_1                         0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_2                         0x00000002 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_3                         0x00000003 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_4                         0x00000004 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_5                         0x00000005 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_6                         0x00000006 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_7                         0x00000007 /* RW--V */
#define NV_PAUDIO_GREEN_0                                0x003000C0 /* RW-4R */
#define NV_PAUDIO_GREEN_0_CODEC                                 0:0 /* RWIVF */
#define NV_PAUDIO_GREEN_0_CODEC_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_CODEC_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_AUDIO                                 4:4 /* RWIVF */
#define NV_PAUDIO_GREEN_0_AUDIO_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_AUDIO_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_APUMP                                 8:8 /* RWIVF */
#define NV_PAUDIO_GREEN_0_APUMP_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_APUMP_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_CODEC_WARM                            8:8 /* RWIVF */
#define NV_PAUDIO_GREEN_0_CODEC_WARM_END                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_APUMP_WARM_UP                  0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_0                                 0x00300100 /* RW-4R */
#define NV_PAUDIO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PAUDIO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_OVERFLOW                               4:4 /* RWIVF */
#define NV_PAUDIO_INTR_0_OVERFLOW_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_OVERFLOW_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_OVERFLOW_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_AN_OVFL                                8:8 /* RWIVF */
#define NV_PAUDIO_INTR_0_AN_OVFL_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_AN_OVFL_PENDING                 0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_AN_OVFL_RESET                   0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_AN_UNFL                              12:12 /* RWIVF */
#define NV_PAUDIO_INTR_0_AN_UNFL_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_AN_UNFL_PENDING                 0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_AN_UNFL_RESET                   0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1                                 0x00300104 /* RW-4R */
#define NV_PAUDIO_INTR_1_SYNC                                   0:0 /* RWIVF */
#define NV_PAUDIO_INTR_1_SYNC_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_SYNC_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_SYNC_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_IDLE                                   4:4 /* RWIVF */
#define NV_PAUDIO_INTR_1_IDLE_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_IDLE_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_IDLE_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY                              8:8 /* RWIVF */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_TOO_BUSY                             12:12 /* RWIVF */
#define NV_PAUDIO_INTR_1_TOO_BUSY_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2                                 0x00300108 /* RW-4R */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE                           0:0 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_PENDING            0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_RESET              0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT                            4:4 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_PENDING             0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_RESET               0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT                            8:8 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_PENDING             0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_RESET               0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_PENDING           0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_RESET             0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3                                 0x0030010C /* RW-4R */
#define NV_PAUDIO_INTR_3_PINS_0                                 0:0 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_0_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_0_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_0_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_1                                 4:4 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_1_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_1_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_1_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_2                                 8:8 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_2_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_2_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_2_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_3                               12:12 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_3_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_3_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_3_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_0                              0x00300140 /* RW-4R */
#define NV_PAUDIO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW                            4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL                             8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL_DISABLED             0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL_ENABLED              0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL                           12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL_DISABLED             0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL_ENABLED              0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1                              0x00300144 /* RW-4R */
#define NV_PAUDIO_INTR_EN_1_SYNC                                0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_SYNC_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_SYNC_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_IDLE                                4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_IDLE_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_IDLE_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY                           8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_DISABLED           0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_ENABLED            0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY                          12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_2                              0x00300148 /* RW-4R */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE                        0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_NOT_PENDING     0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_PENDING         0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_RESET           0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT                         4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_PENDING          0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_RESET            0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT                         8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_PENDING          0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_RESET            0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR                     12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_NOT_PENDING    0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_PENDING        0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_RESET          0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3                              0x0030014C /* RW-4R */
#define NV_PAUDIO_INTR_EN_3_PINS_0                              0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_0_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_0_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_0_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_1                              4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_1_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_1_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_1_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_2                              8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_2_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_2_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_2_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_3                            12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_3_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_3_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_3_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_BLOCK_NEW                              0x00300200 /* RW-4R */
#define NV_PAUDIO_BLOCK_NEW_LENGTH                              7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_LG2                     14:12 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_1                  0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_2                  0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_4                  0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_8                  0x00000003 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_16                 0x00000004 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_32                 0x00000005 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_64                 0x00000006 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_128                0x00000007 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE                           0x00300204 /* RW-4R */
#define NV_PAUDIO_BLOCK_ENGINE_LENGTH                           7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_LG2                  14:12 /* R-XVF */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_1               0x00000000 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_2               0x00000001 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_4               0x00000002 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_8               0x00000003 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_16              0x00000004 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_32              0x00000005 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_64              0x00000006 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_128             0x00000007 /* R---V */
#define NV_PAUDIO_RAMAU                                  0x00300210 /* RW-4R */
#define NV_PAUDIO_RAMAU_BASE_ADDRESS                          15:12 /* RWXVF */
#define NV_PAUDIO_RAMAU_BASE_ADDRESS_1000                0x00001000 /* RWI-V */
#define NV_PAUDIO_ISA_SEL                                0x00300280 /* RW-4R */
#define NV_PAUDIO_ISA_SEL_IRQ                                   2:0 /* RWXVF */
#define NV_PAUDIO_ISA_SEL_IRQ_0                          0x00000001 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_IRQ_1                          0x00000002 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_IRQ_2                          0x00000004 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_DRQ                                   9:8 /* RWXVF */
#define NV_PAUDIO_ISA_SEL_DRQ_0                          0x00000001 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_DRQ_1                          0x00000002 /* RWI-V */
#define NV_PAUDIO_TLB_PTE                                0x00300310 /* R-X4R */
#define NV_PAUDIO_TLB_PTE_PAGE                                31:10 /* R-XVF */
#define NV_PAUDIO_TLB_PTE_READ_ONLY                             1:1 /* R-XVF */
#define NV_PAUDIO_TLB_PTE_PRESENT                               0:0 /* R-XVF */
#define NV_PAUDIO_TLB_TAG                                0x00300320 /* R-X4R */
#define NV_PAUDIO_DMA_TLB_TAG                                 31:12 /* R-XVF */
#define NV_PAUDIO_DMAIA                                  0x00300330 /* R-X4R */
#define NV_PAUDIO_DMA_INSTANCE                                 31:2 /* R-XVF */
#define NV_PAUDIO_DMA_INSTANCE_TARGET                           1:0 /* R-XVF */
#define NV_PAUDIO_NEAR_MARK                              0x00300400 /* RW-4R */
#define NV_PAUDIO_NEAR_MARK_COUNT                               7:0 /* RWXUF */
#define NV_PAUDIO_SAMPLE_COUNT                           0x00300410 /* R--4R */
#define NV_PAUDIO_SAMPLE_COUNT_VALUE                            7:0 /* R-XUF */
#define NV_PAUDIO_SAMPLE_COUNT_BUFFER                           8:8 /* R-XUF */
#define NV_PAUDIO_PROG_COUNTER                           0x00300420 /* R--4R */
#define NV_PAUDIO_PROG_COUNTER_VALUE                            7:0 /* R-XUF */
#define NV_PAUDIO_AN_VOLUME                              0x00300430 /* RWI4R */
#define NV_PAUDIO_AN_VOLUME_INITIAL                               7 /* RWI-V */
#define NV_PAUDIO_AN_VOLUME_VALUE                               2:0 /* RWXUF */
#define NV_PAUDIO_TERM_USAGE                             0x00300C0C /* RW-4R */
#define NV_PAUDIO_TERMINATION_LEVEL                           31:16 /* RWXUF */
#define NV_PAUDIO_TERMINATION_LEVEL_DISABLED             0x00000000 /* RW--V */
#define NV_PAUDIO_USAGE_LEVEL                                  15:0 /* RWXUF */
#define NV_PAUDIO_CONTEXT                                0x00300E10 /* RW-4R */
#define NV_PAUDIO_CONTEXT_INSTANCE                             31:0 /* RWXUF */
#define NV_PAUDIO_BLASTER(i)                       (0x00301000+(i)) /* RW-1A */
#define NV_PAUDIO_BLASTER__SIZE_1                                 1 /*       */
#define NV_PAUDIO_BLASTER_DATA                                  7:0 /* RW-VF */
#define NV_PAUDIO_CODEC(i)                       (0x00302800+(i)*4) /* RW-4A */
#define NV_PAUDIO_CODEC__SIZE_1                                 256 /*       */
#define NV_PAUDIO_CODEC_DATA                                   19:0 /* RW-VF */
#define NV_PAUDIO_INST_TARGET_NVM                        0x00000000 /* RW--V */
#define NV_PAUDIO_INST_TARGET_CART                       0x00000001 /* RW--V */
#define NV_PAUDIO_INST_TARGET_PCI                        0x00000002 /* RW--V */
#define NV_PAUDIO_ROOT_INPUT                             0x00300C00 /* RW-4R */
#define NV_PAUDIO_ROOT_INPUT_TARGET                             1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_INPUT_INSTANCE                          31:2 /* RWXUF */
#define NV_PAUDIO_ROOT_OUTPUT                            0x00300C04 /* RW-4R */
#define NV_PAUDIO_ROOT_OUTPUT_TARGET                            1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_OUTPUT_INSTANCE                         31:2 /* RWXUF */
#define NV_PAUDIO_ROOT_NOTE                              0x00300C08 /* RW-4R */
#define NV_PAUDIO_ROOT_NOTE_TARGET                              1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_NOTE_INSTANCE                           31:2 /* RWXUF */
#define NV_PAUDIO_DIAG(i)                        (0x00300C10+(i)*4) /* RW-4A */
#define NV_PAUDIO_DIAG__SIZE_1                                  252 /*       */
#define NV_PAUDIO_DIAG_DATA                                    31:0 /* RW-VF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00401FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE                         1:1 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE                           2:2 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE                         3:3 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_BULK_READS                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE1                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE2                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_TILING                              16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_TILING_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_TILING_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D                  20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D                  21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X                            8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X                            9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_SPARE1                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND                       0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE1                                4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO                             8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D                         15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D                      17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D                        20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ                        21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_PREFETCH                            24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_PREFETCH_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_PREFETCH_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
#define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH                                7:7 /* CW-VF */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ                        8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D                        9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ                   10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D                   11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT                       14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D                           15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD                         17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK                        22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA                         24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE1                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_0_RESERVED                               0:0 /* RW-VF */
#define NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING            0x00000000 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH                         4:4 /* RWIVF */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_VBLANK                                 8:8 /* RWIVF */
#define NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_VBLANK_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_VBLANK_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_RANGE                                12:12 /* RWIVF */
#define NV_PGRAPH_INTR_0_RANGE_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_RANGE_PENDING                   0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RANGE_RESET                     0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_FORMAT                               20:20 /* RWIVF */
#define NV_PGRAPH_INTR_0_FORMAT_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_FORMAT_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_FORMAT_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP                         24:24 /* RWIVF */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_NOTIFY                               28:28 /* RWIVF */
#define NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_1_METHOD                                 0:0 /* RWIVF */
#define NV_PGRAPH_INTR_1_METHOD_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_METHOD_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_METHOD_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DATA                                   4:4 /* RWIVF */
#define NV_PGRAPH_INTR_1_DATA_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DATA_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DATA_RESET                      0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY                        12:12 /* RWIVF */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET             0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0_RESERVED                            0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH                      4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_VBLANK                              8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_RANGE                             12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RANGE_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RANGE_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_FORMAT                            20:20 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_FORMAT_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_FORMAT_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                      24:24 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY                            28:28 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1_METHOD                              0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_METHOD_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_METHOD_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DATA                                4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DATA_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DATA_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY                     12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH_COLOR                              2:0 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R5G5B5                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R8G8B8                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R10G10B10             0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y8                    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y16                   0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_V8Y18U8Y08            0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y18V8Y08U8            0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y420                  0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA                              3:3 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1                             4:4 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                        8:8 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS                         9:9 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2                           10:10 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE                           12:12 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY                       13:13 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK                       14:14 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP                        15:15 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER                       17:16 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_0                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_1                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_2                0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_3                0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0                      20:20 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1                      21:21 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2                      22:22 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3                      23:23 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG                     28:24 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD0          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_DST_SRC    0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_DST    0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_SRC    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_DST    0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_SRC    0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_DST    0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC0   0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC1   0x00000008 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_PAT    0x00000009 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_SRC    0x0000000a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_PAT    0x0000000b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_SRC    0x0000000c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_PAT    0x0000000d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_PAT_SRC    0x0000000e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD1          0x0000000f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_DST    0x00000010 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_DST_SRC    0x00000011 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_DST    0x00000012 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_PAT    0x00000013 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_PAT_SRC    0x00000014 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_PAT    0x00000015 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD2          0x00000016 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_BYPASS     0x00000017 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD0    0x00000018 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC_DST  0x00000019 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_DST_SRC  0x0000001a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD1    0x0000001b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD2    0x0000001c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC      0x0000001d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD3    0x0000001e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD4    0x0000001f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3                           29:29 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE                         31:31 /* CWIVF */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* CWI-V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_CTX_CACHE(i)                   (0x004001a0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE__SIZE_1                               8 /*       */
#define NV_PGRAPH_CTX_CACHE_COLOR                              2:0  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_ALPHA                              3:3  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE1                             4:4  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_MONO_FORMAT                        8:8  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DAC_BYPASS                         9:9  /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_SPARE2                            10:10 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_ZWRITE                            12:12 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_CHROMA_KEY                        13:13 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PLANE_MASK                        14:14 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_USER_CLIP                         15:15 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SRC_BUFFER                        17:16 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER0                       20:20 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER1                       21:21 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER2                       22:22 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER3                       23:23 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PATCH_CONFIG                      28:24 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE3                            29:29 /* RWXVF */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_USER                               0x00400194 /* RW-4R */
#define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CLASS                              20:16 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CHID                               30:24 /* RWXVF */
#define NV_PGRAPH_FIFO                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_FIFO_ACCESS                                   0:0 /* RWIVF */
#define NV_PGRAPH_FIFO_ACCESS_DISABLED                   0x00000000 /* RW--V */
#define NV_PGRAPH_FIFO_ACCESS_ENABLED                    0x00000001 /* RWI-V */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_3D                                   24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_3D_IDLE                         0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_3D_BUSY                         0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
#define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
#define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_ZFIFO                                27:27 /* R-IVF */
#define NV_PGRAPH_STATUS_ZFIFO_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_ZFIFO_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_USER                            28:28 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_USER_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_USER_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006B4 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CLASS                          20:16 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CHID                           30:24 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006B8 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_TRAPPED_INST                           0x004006BC /* R--4R */
#define NV_PGRAPH_TRAPPED_INST_VALUE                           15:0 /* R-XVF */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC_REGIONS                             1:0 /* RWIUF */
#define NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_RENDER                              4:4 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED              0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX                             8:8 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_SRC_CANVAS_MIN                         0x00400550 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MIN_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN                         0x00400558 /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX                         0x00400554 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX                         0x0040055C /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MIN_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_DMA_INSTANCE                                 15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_NOTIFY_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE                                 23:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_TYPE_HW                         0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_1                       0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_2                       0x00000002 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_3                       0x00000003 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_4                       0x00000004 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_5                       0x00000005 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_6                       0x00000006 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_7                       0x00000007 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_8                       0x00000008 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_9                       0x00000009 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_10                      0x0000000A /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_11                      0x0000000B /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_12                      0x0000000C /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_13                      0x0000000D /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_14                      0x0000000E /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_15                      0x0000000F /* RW--V */
#define NV_PGRAPH_INSTANCE                               0x00400688 /* RW-4R */
#define NV_PGRAPH_INSTANCE_TAG                                 15:0 /* RWXUF */
#define NV_PGRAPH_INSTANCE_TAG_INVALID                   0x00000000 /* RWI-V */
#define NV_PGRAPH_MEMFMT                                 0x0040068C /* RW-4R */
#define NV_PGRAPH_MEMFMT_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_MEMFMT_LINEAR                               16:16 /* RWIVF */
#define NV_PGRAPH_MEMFMT_LINEAR_OUT                      0x00000000 /* RW--V */
#define NV_PGRAPH_MEMFMT_LINEAR_IN                       0x00000001 /* RW--V */
#define NV_PGRAPH_BOFFSET0                               0x00400630 /* RW-4R */
#define NV_PGRAPH_BOFFSET0_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET1                               0x00400634 /* RW-4R */
#define NV_PGRAPH_BOFFSET1_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET2                               0x00400638 /* RW-4R */
#define NV_PGRAPH_BOFFSET2_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET3                               0x0040063C /* RW-4R */
#define NV_PGRAPH_BOFFSET3_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0                                0x00400650 /* RW-4R */
#define NV_PGRAPH_BPITCH0_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH1                                0x00400654 /* RW-4R */
#define NV_PGRAPH_BPITCH1_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH2                                0x00400658 /* RW-4R */
#define NV_PGRAPH_BPITCH2_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH3                                0x0040065C /* RW-4R */
#define NV_PGRAPH_BPITCH3_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPIXEL                                 0x004006a8 /* RW-4R */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT                             1:0 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0                                 2:2 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT                             5:4 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1                                 6:6 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT                             9:8 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2                               10:10 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT                           13:12 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3                               14:14 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX                            0x004006c0 /* RW-4R */
#define NV_PGRAPH_CACHE_INDEX_BANK                              2:2 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_BANK_10                    0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_BANK_32                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS                             12:3 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_ADRS_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP                              14:13 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_OP_WR_CACHE                0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_CACHE                0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_INDEX                0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_RAM                              0x004006c4 /* RW-4R */
#define NV_PGRAPH_CACHE_RAM_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400610+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8                0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1               0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64               0x00000002 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK_BLUE                               9:0 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_GREEN                            19:10 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_RED                              29:20 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_ALPHA                            30:30 /* RWXUF */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_CHROMA_BLUE                                   9:0 /* RWXUF */
#define NV_PGRAPH_CHROMA_GREEN                                19:10 /* RWXUF */
#define NV_PGRAPH_CHROMA_RED                                  29:20 /* RWXUF */
#define NV_PGRAPH_CHROMA_ALPHA                                30:30 /* RWXUF */
#define NV_PGRAPH_BETA                                   0x00400640 /* RW-4R */
#define NV_PGRAPH_BETA_VALUE_FRACTION                         30:23 /* RWXUF */
#define NV_PGRAPH_CONTROL_OUT                            0x00400644 /* RW-4R */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_CULLING_ILLEGAL            0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER                         15:15 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_ILLEGAL       0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     25:24 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_PGRAPH_DPRAM_INDEX                            0x00400648 /* RW-4R */
#define NV_PGRAPH_DPRAM_INDEX_ADRS                              5:0 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE                  0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA               0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_DATA                             0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE                               0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE__ALIAS_1            NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_VALUE                               31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA                            0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA__ALIAS_1         NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_VALUE                            31:0 /* RWXVF */
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_EXCEPTIONS                             0x00400508 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS_VALID                             27:0 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_VALID_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN                         28:28 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN                        29:29 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX                         30:30 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX                        31:31 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
#define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
#define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_PASSTHRU                               0x0040054c /* RW-4R */
#define NV_PGRAPH_PASSTHRU_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_ZFOG_RAM(i)                    (0x00400580+(i)*4) /* RW-4A */
#define NV_PGRAPH_ZFOG_RAM__SIZE_1                               16 /*       */
#define NV_PGRAPH_ZFOG_RAM_ZETA                                15:0 /* RWXUF */
#define NV_PGRAPH_ZFOG_RAM_FOG                                23:16 /* RWXUF */
#define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
#define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_UV                                 0x004005c4 /* RW-4R */
#define NV_PGRAPH_D3D_UV_U_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_UV_V_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_ZETA                               0x004005c8 /* RW-4R */
#define NV_PGRAPH_D3D_ZETA_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_RGB                                0x004005cc /* RW-4R */
#define NV_PGRAPH_D3D_RGB_VALUE                                15:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG                                0x004005d0 /* RW-4R */
#define NV_PGRAPH_D3D_FOG_I0                                    3:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I1                                    7:4 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I2                                   11:8 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I3                                  15:12 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I4                                  19:16 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I5                                  23:20 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_FOG_VALUE                           31:24 /* RWXSF */
#define NV_PGRAPH_D3D_M                                  0x004005d4 /* RW-4R */
#define NV_PGRAPH_D3D_M_VALUE                                  31:0 /* RWXSF */
#define NV_PGRAPH_DMA_INTR_0                             0x00401100 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE                           0:0 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING        0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT                            4:4 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING         0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_RESET               0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION                         8:8 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING      0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR                           12:12 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY                           16:16 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_EN_0                          0x00401140 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                        0:0 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT                         4:4 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION                      8:8 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR                        12:12 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY                        16:16 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_ACCESS                             0x00401200 /* -W-4R */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE                            0:0 /* -W-VF */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_CONTROL                            0x00401210 /* RW-4R */
#define NV_PGRAPH_DMA_CONTROL_ADJUST                           11:0 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                      16:16 /* RWXVF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE                     25:24 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM            0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI            0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP            0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_LIMIT                              0x00401220 /* RW-4R */
#define NV_PGRAPH_DMA_LIMIT_OFFSET                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_PTE                            0x00401230 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE                              0:0 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT               0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS                            1:1 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS                   31:12 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_TAG                            0x00401240 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_TAG_ADDRESS                         31:12 /* RWXUF */
#define NV_PGRAPH_DMA_ADJ_OFFSET                         0x00401250 /* RW-4R */
#define NV_PGRAPH_DMA_ADJ_OFFSET_VALUE                         31:0 /* RWXUF */
#define NV_PGRAPH_DMA_OFFSET                             0x00401260 /* RW-4R */
#define NV_PGRAPH_DMA_OFFSET_VALUE                             31:0 /* RW-UF */
#define NV_PGRAPH_DMA_SIZE                               0x00401270 /* RW-4R */
#define NV_PGRAPH_DMA_SIZE_VALUE                               21:0 /* RW-UF */
#define NV_PGRAPH_DMA_XLATE_INST                         0x00401280 /* RW-4R */
#define NV_PGRAPH_DMA_XLATE_INST_VALUE                         15:0 /* RWXUF */
#define NV_PGRAPH_DMA_Y_SIZE                             0x00401290 /* RW-4R */
#define NV_PGRAPH_DMA_Y_SIZE_VALUE                             10:0 /* RW-UF */
#define NV_PGRAPH_DMA_LINEAR_LIMIT                       0x00401400 /* RW-4R */
#define NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                       21:0 /* RWXUF */
#define NV_PGRAPH_DMA_START(i)                  (0x00401800+(i)*16) /* RW-4A */
#define NV_PGRAPH_DMA_START__SIZE_1                               3 /*       */
#define NV_PGRAPH_DMA_START_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_DMA_PITCH                              0x00401830 /* RW-4R */
#define NV_PGRAPH_DMA_PITCH_0                                  15:0 /* RWXS4 */
#define NV_PGRAPH_DMA_PITCH_1                                 31:16 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT                             0x00401840 /* RW-4R */
#define NV_PGRAPH_DMA_FORMAT_SRC                                2:0 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST                               10:8 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_MTMF_NOTIFY                        0x00401820 /* RW-4R */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE                         31:0 /* RWIVF */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE_HW                0x00000000 /* RWI-V */
/* dev_video.ref */
#define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
#define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
#define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
#define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
#define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
#define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
#define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
#define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
#define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
#define NV_PVIDEO_BUFF0_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
#define NV_PVIDEO_BUFF1_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
#define NV_PVIDEO_BUFF0_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
#define NV_PVIDEO_BUFF1_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
#define NV_PVIDEO_BUFF0_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_X_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_X_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
#define NV_PVIDEO_BUFF1_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_X_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_X_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
#define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
#define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
#define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
#define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
#define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
#define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
#define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
#define NV_PVIDEO_FIFO_THRES_SIZE                               6:3 /* RW--F */
#define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
#define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
#define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
#define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
#define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
#define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
#define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
#define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
#define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
#define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
#define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
#define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
#define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
#define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
#define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
#define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
#define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
#define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
#define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
#define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
#define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
#define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
/* vga.ref */
#define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
#define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
#define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
#define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
#define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
#define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
#define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
#define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
#define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
#define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
#define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
#define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
#define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
#define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
#define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
#define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
#define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
#define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */

// actually an NV4 register, but nv3ddraw uses this file for both NV3 and NV4
#define NV_PCRTC_RASTER                                  0x00600808 /* R-I4R */
#define NV_PCRTC_RASTER_POSITION                               10:0 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD                               13:12 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD_DISPLAY                  0x00000000 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_BEFORE                   0x00000001 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_AFTER                    0x00000002 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK                            16:16 /* R---F */
#define NV_PCRTC_RASTER_VERT_BLANK_ACTIVE                0x00000001 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK_INACTIVE              0x00000000 /* R---V */

/* vga.ref */
#define NV_CIO                                          0x3DF:0x3B0 /* ----- */
#define NV_CIO_INP0                                      0x000003c2 /* R--1R */
#define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
#define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
#define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
#define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
#define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
#define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
#define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
#define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
#define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
#define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
#define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
#define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
#define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
#define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
#define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
#define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
#define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
#define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
#define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
#define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
#define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
#define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
#define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
#define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
#define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
#define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
#define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
#define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
#define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
#define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
#define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
#define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
#define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
#define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
#define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
#define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
#define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
#define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
#define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
#define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
#define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
#define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
#define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
#define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
#define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
#define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
#define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
#define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
#define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
#define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
#define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
#define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
#define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
#define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
#define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
#define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
#define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
#define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
#define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
#define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
#define NV_CIO_CRE_RPC0_INDEX                           0x00000019 /*       */
#define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
#define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
#define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
#define NV_CIO_CRE_RPC1_LARGE                                  2:2 /* RW--F */
#define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
#define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
#define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
#define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
#define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
#define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
#define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
#define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
#define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
#define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
#define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
#define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
#define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_FORMAT                                   7:6 /* RW--F */
#define NV_CIO_CRE_LSR_FORMAT_8BIT                       0x00000001 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_555                        0x00000002 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_565                        0x00000003 /* RW--V */
#define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
#define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
#define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
#define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
#define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
#define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
#define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
#define NV_CIO_CRE_PIXEL_TILING                                 2:2 /* RW--F */
#define NV_CIO_CRE_DEC__INDEX                            0x00000029 /*       */
#define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
#define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
#define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
#define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
#define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
#define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
#define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
#define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
#define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
#define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
#define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:3 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
#define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
#define NV_CIO_CRE_VID_END_7_0                                  7:0 /* RW--F */
#define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
#define NV_CIO_CRE_VID_END_ENABLE                               4:4 /* RW--F */
#define NV_CIO_CRE_VID_END_10_8                                 2:0 /* RW--F */
#define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
#define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
#define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
#define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
#define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
#define NV_CIO_CRE_TREG_HCNT                                    6:6 /* RW--F */
#define NV_CIO_CRE_TREG_VCNT                                    4:4 /* RW--F */
#define NV_CIO_CRE_TREG_HCNT_INDEX                       0x00000000 /*       */
#define NV_CIO_CRE_TREG_VCNTA_INDEX                      0x00000006 /*       */
#define NV_CIO_CRE_TREG_VCNTB_INDEX                      0x00000007 /*       */
#define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
#define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
/* vga.ref */
#define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
#define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
#define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
#define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
#define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
#define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
#define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
#define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*       */
#define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*       */
#define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*       */
#define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
#define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_SR_LOCK                                0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_LOCK_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
#define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
#define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
#define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
#define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
#define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
#define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
#define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
/* vga.ref */
#define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
/* dev_media.ref */
#define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
#define NV_PME_DEBUG_0                                   0x00200080 /* RWI4R */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH                         0:0 /* RWI-F */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_DISABLED         0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_ENABLED          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1                                   0x00200084 /* RWI4R */
#define NV_PME_DEBUG_1_SEL                                      1:0 /* RWI-F */
#define NV_PME_DEBUG_1_SEL_VIPCLK                        0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_SEL_MCLK                          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1_SEL_GLOB                          0x00000002 /* RW--V */
#define NV_PME_DEBUG_1_VIPCLK_SEL                               6:4 /* RWI-F */
#define NV_PME_DEBUG_1_VIPCLK_SEL_DEFAULT                0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_MCLK_SEL                                 9:8 /* RWI-F */
#define NV_PME_DEBUG_1_MCLK_SEL_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
#define NV_PME_INTR_0_NOTIFY                                    0:0 /* RWIVF */
#define NV_PME_INTR_0_NOTIFY_NOT_PENDING                 0x00000000 /* R-I-V */
#define NV_PME_INTR_0_NOTIFY_PENDING                     0x00000001 /* R---V */
#define NV_PME_INTR_0_NOTIFY_RESET                       0x00000001 /* -W--V */
#define NV_PME_INTR_0_VMI                                       4:4 /* RWIVF */
#define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
#define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
#define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
#define NV_PME_INTR_EN_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PME_INTR_EN_0_NOTIFY_DISABLED                 0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_NOTIFY_ENABLED                  0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VMI                                    4:4 /* RWIVF */
#define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
#define NV_PME_CONFIG_0_CCIR656                                 0:0 /* RWIVF */
#define NV_PME_CONFIG_0_CCIR656_DISABLED                 0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_CCIR656_ENABLED                  0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VMI                                     4:4 /* RWIVF */
#define NV_PME_CONFIG_0_VMI_DISABLED                     0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VMI_ENABLED                      0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
#define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
#define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
#define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
#define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
#define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
#define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
#define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
#define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */
#define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */
#define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */
#define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */
#define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */
#define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */
#define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
#define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */
#define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */
#define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */
#define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */
#define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */
#define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */
#define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */
#define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
#define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */
#define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
#define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */
#define NV_PME_VBI_BUFF0_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */
#define NV_PME_VBI_BUFF1_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */
#define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */
#define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */
#define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */
#define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
#define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
#define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
#define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI                                       0x002003a4 /* RWI4R */
#define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
#define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
#define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */
#define NV_PME_IMAGE_BUFF1_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */
#define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */
#define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
#define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
#define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
#define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
#define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_Y_CROP                              0x0020042c /* RW-4R */
#define NV_PME_IMAGE_Y_CROP_STARTLINE                           8:0 /* RWXVF */
#define NV_PME_FIFO_LINE_START                           0x00200480 /* R--4R */
#define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* R-XVF */
#define NV_PME_FIFO_CURRENT                              0x00200484 /* RWI4R */
#define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
#define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
#define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
#define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R--VF */
#define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
#define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */
#define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
/* usr_beta_solid.ref */
#define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
#define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
#define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
#define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
#define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
#define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
/* usr_rop_solid.ref */
#define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
#define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
#define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
#define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
#define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF *