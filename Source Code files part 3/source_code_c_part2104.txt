
    12/01/2004   sdoll     Created.

--*/


#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _WCT_OBJECT_TYPE
{
    WctCriticalSectionType = 1,
    WctSendMessageType,
    WctMutexType,
    WctAlpcType,
    WctComType,
    WctThreadWaitType,
    WctProcessWaitType,
    WctThreadType,
    WctComActivationType,
    WctUnknownType,
    WctSocketIoType,
    WctSmbIoType,
    WctMaxType
} WCT_OBJECT_TYPE;


typedef enum _WCT_OBJECT_STATUS
{
    WctStatusNoAccess = 1,            // ACCESS_DENIED for this object
    WctStatusRunning,                 // Thread status
    WctStatusBlocked,                 // Thread status
    WctStatusPidOnly,                 // Thread status
    WctStatusPidOnlyRpcss,            // Thread status
    WctStatusOwned,                   // Dispatcher object status
    WctStatusNotOwned,                // Dispatcher object status
    WctStatusAbandoned,               // Dispatcher object status
    WctStatusUnknown,                 // All objects
    WctStatusError,                   // All objects
    WctStatusMax
} WCT_OBJECT_STATUS;

// Max. number of nodes in the wait chain
#define WCT_MAX_NODE_COUNT 16

#define WCT_OBJNAME_LENGTH 128

typedef struct _WAITCHAIN_NODE_INFO
{
    WCT_OBJECT_TYPE ObjectType;
    WCT_OBJECT_STATUS ObjectStatus;

    union {
        struct {
            WCHAR ObjectName[WCT_OBJNAME_LENGTH];
            LARGE_INTEGER Timeout;    // Not implemented in v1
            BOOL Alertable;           // Not implemented in v1
        } LockObject;

        struct {
            DWORD ProcessId;
            DWORD ThreadId;
            DWORD WaitTime;
            DWORD ContextSwitches;
        } ThreadObject;
    };

} WAITCHAIN_NODE_INFO, *PWAITCHAIN_NODE_INFO;


typedef LPVOID HWCT;

typedef VOID (CALLBACK *PWAITCHAINCALLBACK) (
    HWCT WctHandle,
    DWORD_PTR Context,
    DWORD CallbackStatus,
    LPDWORD NodeCount,
    PWAITCHAIN_NODE_INFO NodeInfoArray,
    LPBOOL IsCycle
    );

#define WCT_ASYNC_OPEN_FLAG 0x1
#define WCTP_OPEN_ALL_FLAGS (WCT_ASYNC_OPEN_FLAG)

__checkReturn
WINADVAPI
HWCT WINAPI
OpenThreadWaitChainSession (
    __in DWORD Flags,
    __in_opt PWAITCHAINCALLBACK callback
    );

WINADVAPI
VOID WINAPI
CloseThreadWaitChainSession (
    __in HWCT WctHandle
    );

#define WCT_OUT_OF_PROC_FLAG     0x1
#define WCT_OUT_OF_PROC_COM_FLAG 0x2
#define WCT_OUT_OF_PROC_CS_FLAG  0x4
#define WCT_NETWORK_IO_FLAG      0x8
#define WCTP_GETINFO_ALL_FLAGS (WCT_OUT_OF_PROC_FLAG|WCT_OUT_OF_PROC_COM_FLAG|WCT_OUT_OF_PROC_CS_FLAG)

__checkReturn
WINADVAPI
BOOL WINAPI
GetThreadWaitChain (
    __in HWCT WctHandle,
    __in_opt DWORD_PTR Context,
    __in DWORD Flags,
    __in DWORD ThreadId,
    __inout LPDWORD NodeCount,
    __out_ecount(*NodeCount) PWAITCHAIN_NODE_INFO NodeInfoArray,
    __out LPBOOL IsCycle
    );

typedef HRESULT (*PCOGETCALLSTATE)(int, PULONG);
typedef HRESULT (*PCOGETACTIVATIONSTATE)(GUID, DWORD, DWORD*);

WINADVAPI
VOID WINAPI
RegisterWaitChainCOMCallback (
    __in PCOGETCALLSTATE CallStateCallback,
    __in PCOGETACTIVATIONSTATE ActivationStateCallback
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WdsBp.h ===
/*++

Copyright (c) 2006 Microsoft Corporation

Module Name:

    WdsBp.h

Abstract:

    This module defines data structure and public APIs which are used to parse
    and construct packets for WDS Network Boot Program.

Environment:

    User Mode

--*/

#ifndef __WDSBP_H__
#define __WDSBP_H__

#ifdef __cplusplus
extern "C"
{
#endif

//
// Calling Convention.
//

#define WDSBPAPI        __stdcall

//
// Options used by WDS Network Boot Program.
//

#define WDSBP_MAKE_OPTION(_Pk, _Type, _Id)      ((_Type) | ((_Pk) << 8) | ((_Id) << 16))

//
// Packet Types.
//

#define WDSBP_PK_TYPE_DHCP                      1
#define WDSBP_PK_TYPE_WDSNBP                    2
#define WDSBP_PK_TYPE_BCD                       4

//
// Option Types.
//

#define WDSBP_OPT_TYPE_NONE                     0
#define WDSBP_OPT_TYPE_BYTE                     1
#define WDSBP_OPT_TYPE_USHORT                   2
#define WDSBP_OPT_TYPE_ULONG                    3
#define WDSBP_OPT_TYPE_WSTR                     4
#define WDSBP_OPT_TYPE_STR                      5
#define WDSBP_OPT_TYPE_IP4                      6

//
// Boot Program Options.
//

#define WDSBP_OPT_ARCHITECTURE                  WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_USHORT,        1)
#define WDSBP_OPT_NEXT_ACTION                   WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_BYTE,          2)
#define WDSBP_OPT_POLL_INTERVAL                 WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_USHORT,        3)
#define WDSBP_OPT_POLL_RETRY_COUNT              WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_USHORT,        4)
#define WDSBP_OPT_REQUEST_ID                    WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_ULONG,         5)
#define WDSBP_OPT_MESSAGE                       WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_STR,           6)
#define WDSBP_OPT_VERSION_QUERY                 WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_NONE,          7)
#define WDSBP_OPT_SERVER_VERSION                WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_ULONG,         8)
#define WDSBP_OPT_REFERRAL_SERVER               WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_IP4,           9)
#define WDSBP_OPT_PXE_CLIENT_PROMPT             WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_BYTE,          11)
#define WDSBP_OPT_PXE_PROMPT_DONE               WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_BYTE,          12)
#define WDSBP_OPT_NBP_VER                       WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_USHORT,        13)
#define WDSBP_OPT_ACTION_DONE                   WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_BYTE,          14)
#define WDSBP_OPT_ALLOW_SERVER_SELECTION        WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_WDSNBP,     WDSBP_OPT_TYPE_BYTE,          15)
#define WDSBP_OPT_BCD_FILE_PATH                 WDSBP_MAKE_OPTION(WDSBP_PK_TYPE_BCD,        WDSBP_OPT_TYPE_STR,           252)

//
// Helper Macros.
//

#define WDSBP_IS_PK_TYPE(_Value, _Type)         (((_Value) & (_Type)) == (_Type))

//
// Values for WDSBP_OPT_NEXT_ACTION Option.
//

#define WDSBP_OPTVAL_ACTION_APPROVAL            1
#define WDSBP_OPTVAL_ACTION_REFERRAL            3
#define WDSBP_OPTVAL_ACTION_ABORT               5

//
// Values for WDSBP_OPT_PXE_CLIENT_PROMPT and WDSBP_OPT_PXE_PROMPT_DONE.
//

#define WDSBP_OPTVAL_PXE_PROMPT_OPTIN           1
#define WDSBP_OPTVAL_PXE_PROMPT_NOPROMPT        2
#define WDSBP_OPTVAL_PXE_PROMPT_OPTOUT          3

//
// Values for WDSBP_OPT_NBP_VER.
//

#define WDSBP_OPTVAL_NBP_VER_7                  0x0700

//
// APIs.
//

DWORD
WDSBPAPI
WdsBpParseInitialize(
    __in_bcount(uPacketLen) PVOID pPacket,
    __in ULONG uPacketLen,
    __out_opt PBYTE pbPacketType,
    __out HANDLE *phHandle
);

DWORD
WDSBPAPI 
WdsBpInitialize(
    __in BYTE bPacketType,
    __out HANDLE *phHandle
);    

DWORD
WDSBPAPI
WdsBpCloseHandle(
    __in HANDLE hHandle 
);

DWORD
WDSBPAPI 
WdsBpQueryOption(
    __in HANDLE hHandle,
    __in ULONG uOption,
    __in ULONG uValueLen,
    __out_bcount_part(uValueLen, *puBytes) PVOID pValue,
    __out PULONG puBytes
);

DWORD
WDSBPAPI 
WdsBpAddOption(
    __in HANDLE hHandle,
    __in ULONG uOption,
    __in ULONG uValueLen,
    __in_bcount(uValueLen) PVOID pValue 
);

DWORD 
WDSBPAPI    
WdsBpGetOptionBuffer(
    __in HANDLE hHandle,
    __in ULONG uBufferLen,
    __out_bcount_part(uBufferLen, *puBytes) PVOID pBuffer,
    __out PULONG puBytes 
);    

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WcnFunctionDiscoveryKeys.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    WcnFunctionDiscoveryKeys.h

Abstract:

    Function Discovery PKEYs used by WCN API

--*/


#ifndef _wcnfunctiondiscoverykeys_h_
#define _wcnfunctiondiscoverykeys_h_

#if NTDDI_VERSION >= NTDDI_WIN7

#include <PropKeyDef.h>

// C100BECA-D33A-4a4b-BF23-BBEF4663D017
DEFINE_GUID( SID_WcnProvider, 0xC100BECA,0xD33A,0x4A4B,0xBF,0x23,0xBB,0xEF,0x46,0x63,0xD0,0x17);


DEFINE_PROPERTYKEY(PKEY_WCN_DeviceType_Category,       0x88190b8b, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000010); // VT_UINT
DEFINE_PROPERTYKEY(PKEY_WCN_DeviceType_SubCategoryOUI, 0x88190b8b, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000011); // VT_UINT
DEFINE_PROPERTYKEY(PKEY_WCN_DeviceType_SubCategory,    0x88190b8b, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000012); // VT_UINT
DEFINE_PROPERTYKEY(PKEY_WCN_SSID,                      0x88190b8b, 0x4684, 0x11da, 0xa2, 0x6a, 0x00, 0x02, 0xb3, 0x98, 0x8e, 0x81, 0x00000020); // VT_LPWSTR (should be VT_UI1|VT_VECTOR, but that's not supported by IFunctionInstanceCollectionQuery::AddPropertyConstraint)


#endif // NTDDI_VERSION >= NTDDI_WIN7

#endif // _wcnfunctiondiscoverykeys_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WcnTypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wcntypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __wcntypes_h__
#define __wcntypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wcntypes_0000_0000 */
/* [local] */ 

/*++

Copyright (c) Microsoft Corporation

Module Name:

    WcnTypes.h

Abstract:

    Defines basic types and constants for WCN API

--*/
//
// WCN API error codes
//
#define WCN_E_PEER_NOT_FOUND             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x3C01)
#define WCN_E_AUTHENTICATION_FAILED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x3C02)
#define WCN_E_CONNECTION_REJECTED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x3C03)
#define WCN_E_SESSION_TIMEDOUT           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x3C04)
#define WCN_E_PROTOCOL_ERROR             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x3C05)


//
// FD Query Constraint:
// Turn on SoftAP and listen for wireless devices
//
#define WCN_QUERY_CONSTRAINT_USE_SOFTAP                L"WCN.Discovery.SoftAP"


//
// List of defined WCN attribute types.
// These are based off of WPS TLV types.
//
typedef /* [v1_enum] */ 
enum tagWCN_ATTRIBUTE_TYPE
    {	WCN_TYPE_AP_CHANNEL	= 0,
	WCN_TYPE_ASSOCIATION_STATE	= ( WCN_TYPE_AP_CHANNEL + 1 ) ,
	WCN_TYPE_AUTHENTICATION_TYPE	= ( WCN_TYPE_ASSOCIATION_STATE + 1 ) ,
	WCN_TYPE_AUTHENTICATION_TYPE_FLAGS	= ( WCN_TYPE_AUTHENTICATION_TYPE + 1 ) ,
	WCN_TYPE_AUTHENTICATOR	= ( WCN_TYPE_AUTHENTICATION_TYPE_FLAGS + 1 ) ,
	WCN_TYPE_CONFIG_METHODS	= ( WCN_TYPE_AUTHENTICATOR + 1 ) ,
	WCN_TYPE_CONFIGURATION_ERROR	= ( WCN_TYPE_CONFIG_METHODS + 1 ) ,
	WCN_TYPE_CONFIRMATION_URL4	= ( WCN_TYPE_CONFIGURATION_ERROR + 1 ) ,
	WCN_TYPE_CONFIRMATION_URL6	= ( WCN_TYPE_CONFIRMATION_URL4 + 1 ) ,
	WCN_TYPE_CONNECTION_TYPE	= ( WCN_TYPE_CONFIRMATION_URL6 + 1 ) ,
	WCN_TYPE_CONNECTION_TYPE_FLAGS	= ( WCN_TYPE_CONNECTION_TYPE + 1 ) ,
	WCN_TYPE_CREDENTIAL	= ( WCN_TYPE_CONNECTION_TYPE_FLAGS + 1 ) ,
	WCN_TYPE_DEVICE_NAME	= ( WCN_TYPE_CREDENTIAL + 1 ) ,
	WCN_TYPE_DEVICE_PASSWORD_ID	= ( WCN_TYPE_DEVICE_NAME + 1 ) ,
	WCN_TYPE_E_HASH1	= ( WCN_TYPE_DEVICE_PASSWORD_ID + 1 ) ,
	WCN_TYPE_E_HASH2	= ( WCN_TYPE_E_HASH1 + 1 ) ,
	WCN_TYPE_E_SNONCE1	= ( WCN_TYPE_E_HASH2 + 1 ) ,
	WCN_TYPE_E_SNONCE2	= ( WCN_TYPE_E_SNONCE1 + 1 ) ,
	WCN_TYPE_ENCRYPTED_SETTINGS	= ( WCN_TYPE_E_SNONCE2 + 1 ) ,
	WCN_TYPE_ENCRYPTION_TYPE	= ( WCN_TYPE_ENCRYPTED_SETTINGS + 1 ) ,
	WCN_TYPE_ENCRYPTION_TYPE_FLAGS	= ( WCN_TYPE_ENCRYPTION_TYPE + 1 ) ,
	WCN_TYPE_ENROLLEE_NONCE	= ( WCN_TYPE_ENCRYPTION_TYPE_FLAGS + 1 ) ,
	WCN_TYPE_FEATURE_ID	= ( WCN_TYPE_ENROLLEE_NONCE + 1 ) ,
	WCN_TYPE_IDENTITY	= ( WCN_TYPE_FEATURE_ID + 1 ) ,
	WCN_TYPE_IDENTITY_PROOF	= ( WCN_TYPE_IDENTITY + 1 ) ,
	WCN_TYPE_KEY_WRAP_AUTHENTICATOR	= ( WCN_TYPE_IDENTITY_PROOF + 1 ) ,
	WCN_TYPE_KEY_IDENTIFIER	= ( WCN_TYPE_KEY_WRAP_AUTHENTICATOR + 1 ) ,
	WCN_TYPE_MAC_ADDRESS	= ( WCN_TYPE_KEY_IDENTIFIER + 1 ) ,
	WCN_TYPE_MANUFACTURER	= ( WCN_TYPE_MAC_ADDRESS + 1 ) ,
	WCN_TYPE_MESSAGE_TYPE	= ( WCN_TYPE_MANUFACTURER + 1 ) ,
	WCN_TYPE_MODEL_NAME	= ( WCN_TYPE_MESSAGE_TYPE + 1 ) ,
	WCN_TYPE_MODEL_NUMBER	= ( WCN_TYPE_MODEL_NAME + 1 ) ,
	WCN_TYPE_NETWORK_INDEX	= ( WCN_TYPE_MODEL_NUMBER + 1 ) ,
	WCN_TYPE_NETWORK_KEY	= ( WCN_TYPE_NETWORK_INDEX + 1 ) ,
	WCN_TYPE_NETWORK_KEY_INDEX	= ( WCN_TYPE_NETWORK_KEY + 1 ) ,
	WCN_TYPE_NEW_DEVICE_NAME	= ( WCN_TYPE_NETWORK_KEY_INDEX + 1 ) ,
	WCN_TYPE_NEW_PASSWORD	= ( WCN_TYPE_NEW_DEVICE_NAME + 1 ) ,
	WCN_TYPE_OOB_DEVICE_PASSWORD	= ( WCN_TYPE_NEW_PASSWORD + 1 ) ,
	WCN_TYPE_OS_VERSION	= ( WCN_TYPE_OOB_DEVICE_PASSWORD + 1 ) ,
	WCN_TYPE_POWER_LEVEL	= ( WCN_TYPE_OS_VERSION + 1 ) ,
	WCN_TYPE_PSK_CURRENT	= ( WCN_TYPE_POWER_LEVEL + 1 ) ,
	WCN_TYPE_PSK_MAX	= ( WCN_TYPE_PSK_CURRENT + 1 ) ,
	WCN_TYPE_PUBLIC_KEY	= ( WCN_TYPE_PSK_MAX + 1 ) ,
	WCN_TYPE_RADIO_ENABLED	= ( WCN_TYPE_PUBLIC_KEY + 1 ) ,
	WCN_TYPE_REBOOT	= ( WCN_TYPE_RADIO_ENABLED + 1 ) ,
	WCN_TYPE_REGISTRAR_CURRENT	= ( WCN_TYPE_REBOOT + 1 ) ,
	WCN_TYPE_REGISTRAR_ESTABLISHED	= ( WCN_TYPE_REGISTRAR_CURRENT + 1 ) ,
	WCN_TYPE_REGISTRAR_LIST	= ( WCN_TYPE_REGISTRAR_ESTABLISHED + 1 ) ,
	WCN_TYPE_REGISTRAR_MAX	= ( WCN_TYPE_REGISTRAR_LIST + 1 ) ,
	WCN_TYPE_REGISTRAR_NONCE	= ( WCN_TYPE_REGISTRAR_MAX + 1 ) ,
	WCN_TYPE_REQUEST_TYPE	= ( WCN_TYPE_REGISTRAR_NONCE + 1 ) ,
	WCN_TYPE_RESPONSE_TYPE	= ( WCN_TYPE_REQUEST_TYPE + 1 ) ,
	WCN_TYPE_RF_BANDS	= ( WCN_TYPE_RESPONSE_TYPE + 1 ) ,
	WCN_TYPE_R_HASH1	= ( WCN_TYPE_RF_BANDS + 1 ) ,
	WCN_TYPE_R_HASH2	= ( WCN_TYPE_R_HASH1 + 1 ) ,
	WCN_TYPE_R_SNONCE1	= ( WCN_TYPE_R_HASH2 + 1 ) ,
	WCN_TYPE_R_SNONCE2	= ( WCN_TYPE_R_SNONCE1 + 1 ) ,
	WCN_TYPE_SELECTED_REGISTRAR	= ( WCN_TYPE_R_SNONCE2 + 1 ) ,
	WCN_TYPE_SERIAL_NUMBER	= ( WCN_TYPE_SELECTED_REGISTRAR + 1 ) ,
	WCN_TYPE_WI_FI_PROTECTED_SETUP_STATE	= ( WCN_TYPE_SERIAL_NUMBER + 1 ) ,
	WCN_TYPE_SSID	= ( WCN_TYPE_WI_FI_PROTECTED_SETUP_STATE + 1 ) ,
	WCN_TYPE_TOTAL_NETWORKS	= ( WCN_TYPE_SSID + 1 ) ,
	WCN_TYPE_UUID_E	= ( WCN_TYPE_TOTAL_NETWORKS + 1 ) ,
	WCN_TYPE_UUID_R	= ( WCN_TYPE_UUID_E + 1 ) ,
	WCN_TYPE_VENDOR_EXTENSION	= ( WCN_TYPE_UUID_R + 1 ) ,
	WCN_TYPE_VERSION	= ( WCN_TYPE_VENDOR_EXTENSION + 1 ) ,
	WCN_TYPE_X_509_CERTIFICATE_REQUEST	= ( WCN_TYPE_VERSION + 1 ) ,
	WCN_TYPE_X_509_CERTIFICATE	= ( WCN_TYPE_X_509_CERTIFICATE_REQUEST + 1 ) ,
	WCN_TYPE_EAP_IDENTITY	= ( WCN_TYPE_X_509_CERTIFICATE + 1 ) ,
	WCN_TYPE_MESSAGE_COUNTER	= ( WCN_TYPE_EAP_IDENTITY + 1 ) ,
	WCN_TYPE_PUBLIC_KEY_HASH	= ( WCN_TYPE_MESSAGE_COUNTER + 1 ) ,
	WCN_TYPE_REKEY_KEY	= ( WCN_TYPE_PUBLIC_KEY_HASH + 1 ) ,
	WCN_TYPE_KEY_LIFETIME	= ( WCN_TYPE_REKEY_KEY + 1 ) ,
	WCN_TYPE_PERMITTED_CONFIG_METHODS	= ( WCN_TYPE_KEY_LIFETIME + 1 ) ,
	WCN_TYPE_SELECTED_REGISTRAR_CONFIG_METHODS	= ( WCN_TYPE_PERMITTED_CONFIG_METHODS + 1 ) ,
	WCN_TYPE_PRIMARY_DEVICE_TYPE	= ( WCN_TYPE_SELECTED_REGISTRAR_CONFIG_METHODS + 1 ) ,
	WCN_TYPE_SECONDARY_DEVICE_TYPE_LIST	= ( WCN_TYPE_PRIMARY_DEVICE_TYPE + 1 ) ,
	WCN_TYPE_PORTABLE_DEVICE	= ( WCN_TYPE_SECONDARY_DEVICE_TYPE_LIST + 1 ) ,
	WCN_TYPE_AP_SETUP_LOCKED	= ( WCN_TYPE_PORTABLE_DEVICE + 1 ) ,
	WCN_TYPE_APPLICATION_EXTENSION	= ( WCN_TYPE_AP_SETUP_LOCKED + 1 ) ,
	WCN_TYPE_EAP_TYPE	= ( WCN_TYPE_APPLICATION_EXTENSION + 1 ) ,
	WCN_TYPE_INITIALIZATION_VECTOR	= ( WCN_TYPE_EAP_TYPE + 1 ) ,
	WCN_TYPE_KEY_PROVIDED_AUTOMATICALLY	= ( WCN_TYPE_INITIALIZATION_VECTOR + 1 ) ,
	WCN_TYPE_802_1X_ENABLED	= ( WCN_TYPE_KEY_PROVIDED_AUTOMATICALLY + 1 ) ,
	WCN_TYPE_APPSESSIONKEY	= ( WCN_TYPE_802_1X_ENABLED + 1 ) ,
	WCN_TYPE_WEPTRANSMITKEY	= ( WCN_TYPE_APPSESSIONKEY + 1 ) ,
	WCN_TYPE_UUID	= ( WCN_TYPE_WEPTRANSMITKEY + 1 ) ,
	WCN_TYPE_PRIMARY_DEVICE_TYPE_CATEGORY	= ( WCN_TYPE_UUID + 1 ) ,
	WCN_TYPE_PRIMARY_DEVICE_TYPE_SUBCATEGORY_OUI	= ( WCN_TYPE_PRIMARY_DEVICE_TYPE_CATEGORY + 1 ) ,
	WCN_TYPE_PRIMARY_DEVICE_TYPE_SUBCATEGORY	= ( WCN_TYPE_PRIMARY_DEVICE_TYPE_SUBCATEGORY_OUI + 1 ) ,
	WCN_TYPE_CURRENT_SSID	= ( WCN_TYPE_PRIMARY_DEVICE_TYPE_SUBCATEGORY + 1 ) ,
	WCN_TYPE_BSSID	= ( WCN_TYPE_CURRENT_SSID + 1 ) ,
	WCN_TYPE_DOT11_MAC_ADDRESS	= ( WCN_TYPE_BSSID + 1 ) ,
	WCN_NUM_ATTRIBUTE_TYPES	= ( WCN_TYPE_DOT11_MAC_ADDRESS + 1 ) 
    } 	WCN_ATTRIBUTE_TYPE;


//
// Values for all boolean types (example: WCN_TYPE_AP_SETUP_LOCKED)
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_BOOLEAN
    {	WCN_VALUE_FALSE	= 0,
	WCN_VALUE_TRUE	= 1
    } 	WCN_VALUE_TYPE_BOOLEAN;


//
// Values for WCN_TYPE_ASSOCIATION_STATE
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_ASSOCIATION_STATE
    {	WCN_VALUE_AS_NOT_ASSOCIATED	= 0,
	WCN_VALUE_AS_CONNECTION_SUCCESS	= 1,
	WCN_VALUE_AS_CONFIGURATION_FAILURE	= 2,
	WCN_VALUE_AS_ASSOCIATION_FAILURE	= 3,
	WCN_VALUE_AS_IP_FAILURE	= 4
    } 	WCN_VALUE_TYPE_ASSOCIATION_STATE;


//
// Values for WCN_TYPE_AUTHENTICATION_TYPE
// and WCN_TYPE_AUTHENTICATION_TYPE_FLAGS
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_AUTHENTICATION_TYPE
    {	WCN_VALUE_AT_OPEN	= 0x1,
	WCN_VALUE_AT_WPAPSK	= 0x2,
	WCN_VALUE_AT_SHARED	= 0x4,
	WCN_VALUE_AT_WPA	= 0x8,
	WCN_VALUE_AT_WPA2	= 0x10,
	WCN_VALUE_AT_WPA2PSK	= 0x20
    } 	WCN_VALUE_TYPE_AUTHENTICATION_TYPE;


//
// Values for WCN_TYPE_CONFIG_METHODS
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_CONFIG_METHODS
    {	WCN_VALUE_CM_USBA	= 0x1,
	WCN_VALUE_CM_ETHERNET	= 0x2,
	WCN_VALUE_CM_LABEL	= 0x4,
	WCN_VALUE_CM_DISPLAY	= 0x8,
	WCN_VALUE_CM_EXTERNAL_NFC	= 0x10,
	WCN_VALUE_CM_INTEGRATED_NFC	= 0x20,
	WCN_VALUE_CM_NFC_INTERFACE	= 0x40,
	WCN_VALUE_CM_PUSHBUTTON	= 0x80,
	WCN_VALUE_CM_KEYPAD	= 0x100
    } 	WCN_VALUE_TYPE_CONFIG_METHODS;


//
// Values for WCN_TYPE_CONFIGURATION_ERROR
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_CONFIGURATION_ERROR
    {	WCN_VALUE_CE_NO_ERROR	= 0,
	WCN_VALUE_CE_OOB_INTERFACE_READ_ERROR	= 1,
	WCN_VALUE_CE_DECRYPTION_CRC_FAILURE	= 2,
	WCN_VALUE_CE_2_4_CHANNEL_NOT_SUPPORTED	= 3,
	WCN_VALUE_CE_5_0_CHANNEL_NOT_SUPPORTED	= 4,
	WCN_VALUE_CE_SIGNAL_TOO_WEAK	= 5,
	WCN_VALUE_CE_NETWORK_AUTHENTICATION_FAILURE	= 6,
	WCN_VALUE_CE_NETWORK_ASSOCIATION_FAILURE	= 7,
	WCN_VALUE_CE_NO_DHCP_RESPONSE	= 8,
	WCN_VALUE_CE_FAILED_DHCP_CONFIG	= 9,
	WCN_VALUE_CE_IP_ADDRESS_CONFLICT	= 10,
	WCN_VALUE_CE_COULD_NOT_CONNECT_TO_REGISTRAR	= 11,
	WCN_VALUE_CE_MULTIPLE_PBC_SESSIONS_DETECTED	= 12,
	WCN_VALUE_CE_ROGUE_ACTIVITY_SUSPECTED	= 13,
	WCN_VALUE_CE_DEVICE_BUSY	= 14,
	WCN_VALUE_CE_SETUP_LOCKED	= 15,
	WCN_VALUE_CE_MESSAGE_TIMEOUT	= 16,
	WCN_VALUE_CE_REGISTRATION_SESSION_TIMEOUT	= 17,
	WCN_VALUE_CE_DEVICE_PASSWORD_AUTH_FAILURE	= 18
    } 	WCN_VALUE_TYPE_CONFIGURATION_ERROR;


//
// Values for WCN_TYPE_CONNECTION_TYPE
// and WCN_TYPE_CONNECTION_TYPE_FLAGS
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_CONNECTION_TYPE
    {	WCN_VALUE_CT_ESS	= 1,
	WCN_VALUE_CT_IBSS	= 2
    } 	WCN_VALUE_TYPE_CONNECTION_TYPE;


//
// Values for WCN_TYPE_DEVICE_PASSWORD_ID
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_DEVICE_PASSWORD_ID
    {	WCN_VALUE_DP_DEFAULT	= 0,
	WCN_VALUE_DP_USER_SPECIFIED	= 0x1,
	WCN_VALUE_DP_MACHINE_SPECIFIED	= 0x2,
	WCN_VALUE_DP_REKEY	= 0x3,
	WCN_VALUE_DP_PUSHBUTTON	= 0x4,
	WCN_VALUE_DP_REGISTRAR_SPECIFIED	= 0x5
    } 	WCN_VALUE_TYPE_DEVICE_PASSWORD_ID;


//
// Values for WCN_TYPE_ENCRYPTION_TYPE and
// WCN_TYPE_ENCRYPTION_TYPE_FLAGS
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_ENCRYPTION_TYPE
    {	WCN_VALUE_ET_NONE	= 0x1,
	WCN_VALUE_ET_WEP	= 0x2,
	WCN_VALUE_ET_TKIP	= 0x4,
	WCN_VALUE_ET_AES	= 0x8
    } 	WCN_VALUE_TYPE_ENCRYPTION_TYPE;


//
// Values for WCN_TYPE_MESSAGE_TYPE
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_MESSAGE_TYPE
    {	WCN_VALUE_MT_BEACON	= 0x1,
	WCN_VALUE_MT_PROBE_REQUEST	= 0x2,
	WCN_VALUE_MT_PROBE_RESPONSE	= 0x3,
	WCN_VALUE_MT_M1	= 0x4,
	WCN_VALUE_MT_M2	= 0x5,
	WCN_VALUE_MT_M2D	= 0x6,
	WCN_VALUE_MT_M3	= 0x7,
	WCN_VALUE_MT_M4	= 0x8,
	WCN_VALUE_MT_M5	= 0x9,
	WCN_VALUE_MT_M6	= 0xa,
	WCN_VALUE_MT_M7	= 0xb,
	WCN_VALUE_MT_M8	= 0xc,
	WCN_VALUE_MT_ACK	= 0xd,
	WCN_VALUE_MT_NACK	= 0xe,
	WCN_VALUE_MT_DONE	= 0xf
    } 	WCN_VALUE_TYPE_MESSAGE_TYPE;


//
// Values for WCN_TYPE_REQUEST_TYPE
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_REQUEST_TYPE
    {	WCN_VALUE_ReqT_ENROLLEE_INFO	= 0,
	WCN_VALUE_ReqT_ENROLLEE_OPEN_1X	= 0x1,
	WCN_VALUE_ReqT_REGISTRAR	= 0x2,
	WCN_VALUE_ReqT_MANAGER_REGISTRAR	= 0x3
    } 	WCN_VALUE_TYPE_REQUEST_TYPE;


//
// Values for WCN_TYPE_RESPONSE_TYPE
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_RESPONSE_TYPE
    {	WCN_VALUE_RspT_ENROLLEE_INFO	= 0,
	WCN_VALUE_RspT_ENROLLEE_OPEN_1X	= 0x1,
	WCN_VALUE_RspT_REGISTRAR	= 0x2,
	WCN_VALUE_RspT_AP	= 0x3
    } 	WCN_VALUE_TYPE_RESPONSE_TYPE;


//
// Values for WCN_TYPE_RF_BANDS
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_RF_BANDS
    {	WCN_VALUE_RB_24GHZ	= 0x1,
	WCN_VALUE_RB_50GHZ	= 0x2
    } 	WCN_VALUE_TYPE_RF_BANDS;


//
// Values for WCN_TYPE_WI_FI_PROTECTED_SETUP_STATE
//
typedef /* [v1_enum] */ 
enum tagWCN_VALUE_TYPE_WI_FI_PROTECTED_SETUP_STATE
    {	WCN_VALUE_SS_RESERVED00	= 0,
	WCN_VALUE_SS_NOT_CONFIGURED	= 0x1,
	WCN_VALUE_SS_CONFIGURED	= 0x2
    } 	WCN_VALUE_TYPE_WI_FI_PROTECTED_SETUP_STATE;


//
// Values for WCN_TYPE_PRIMARY_DEVICE_TYPE[Category]
//
typedef unsigned short WCN_VALUE_TYPE_DEVICE_TYPE_CATEGORY;

#define	WCN_VALUE_DT_CATEGORY_COMPUTER	( 0x1 )

#define	WCN_VALUE_DT_CATEGORY_INPUT_DEVICE	( 0x2 )

#define	WCN_VALUE_DT_CATEGORY_PRINTER	( 0x3 )

#define	WCN_VALUE_DT_CATEGORY_CAMERA	( 0x4 )

#define	WCN_VALUE_DT_CATEGORY_STORAGE	( 0x5 )

#define	WCN_VALUE_DT_CATEGORY_NETWORK_INFRASTRUCTURE	( 0x6 )

#define	WCN_VALUE_DT_CATEGORY_DISPLAY	( 0x7 )

#define	WCN_VALUE_DT_CATEGORY_MULTIMEDIA_DEVICE	( 0x8 )

#define	WCN_VALUE_DT_CATEGORY_GAMING_DEVICE	( 0x9 )

#define	WCN_VALUE_DT_CATEGORY_TELEPHONE	( 0xa )


//
// Value for WCN_TYPE_PRIMARY_DEVICE_TYPE[SubCategoryOUI]
//
typedef unsigned __int32 WCN_VALUE_TYPE_DEVICE_TYPE_SUBCATEGORY_OUI;

// Standard OUI for Wi-Fi Alliance
#define	WCN_VALUE_DT_SUBTYPE_WIFI_OUI	( 0x50f204 )


//
// Values for WCN_TYPE_PRIMARY_DEVICE_TYPE[SubCategory]
//
typedef unsigned short WCN_VALUE_TYPE_DEVICE_TYPE_SUBCATEGORY;

// Category = WCN_VALUE_DT_CATEGORY_COMPUTER
#define	WCN_VALUE_DT_SUBTYPE_COMPUTER__PC	( 0x1 )

#define	WCN_VALUE_DT_SUBTYPE_COMPUTER__SERVER	( 0x2 )

// Category = WCN_VALUE_DT_CATEGORY_PRINTER
#define	WCN_VALUE_DT_SUBTYPE_PRINTER__PRINTER	( 0x1 )

#define	WCN_VALUE_DT_SUBTYPE_PRINTER__SCANNER	( 0x2 )

// Category = WCN_VALUE_DT_CATEGORY_CAMERA
#define	WCN_VALUE_DT_SUBTYPE_CAMERA__STILL_CAMERA	( 0x1 )

// Category = WCN_VALUE_DT_CATEGORY_STORAGE
#define	WCN_VALUE_DT_SUBTYPE_STORAGE__NAS	( 0x1 )

// Category = WCN_VALUE_DT_CATEGORY_NETWORK_INFRASTRUCTURE
#define	WCN_VALUE_DT_SUBTYPE_NETWORK_INFRASTRUCUTURE__AP	( 0x1 )

#define	WCN_VALUE_DT_SUBTYPE_NETWORK_INFRASTRUCUTURE__ROUTER	( 0x2 )

#define	WCN_VALUE_DT_SUBTYPE_NETWORK_INFRASTRUCUTURE__SWITCH	( 0x3 )

// Category = WCN_VALUE_DT_CATEGORY_DISPLAY
#define	WCN_VALUE_DT_SUBTYPE_DISPLAY__TELEVISION	( 0x1 )

#define	WCN_VALUE_DT_SUBTYPE_DISPLAY__PICTURE_FRAME	( 0x2 )

#define	WCN_VALUE_DT_SUBTYPE_DISPLAY__PROJECTOR	( 0x3 )

// Category = WCN_VALUE_DT_CATEGORY_MULTIMEDIA_DEVICE
#define	WCN_VALUE_DT_SUBTYPE_MULTIMEDIA_DEVICE__DAR	( 0x1 )

#define	WCN_VALUE_DT_SUBTYPE_MULTIMEDIA_DEVICE__PVR	( 0x2 )

#define	WCN_VALUE_DT_SUBTYPE_MULTIMEDIA_DEVICE__MCX	( 0x3 )

// Category = WCN_VALUE_DT_CATEGORY_GAMING_DEVICE
#define	WCN_VALUE_DT_SUBTYPE_GAMING_DEVICE__XBOX	( 0x1 )

#define	WCN_VALUE_DT_SUBTYPE_GAMING_DEVICE__XBOX360	( 0x2 )

#define	WCN_VALUE_DT_SUBTYPE_GAMING_DEVICE__PLAYSTATION	( 0x3 )

// Category = WCN_VALUE_DT_CATEGORY_TELEPHONE
#define	WCN_VALUE_DT_SUBTYPE_TELEPHONE__WINDOWS_MOBILE	( 0x1 )

//
// Values for WCN_TYPE_PRIMARY_DEVICE_TYPE
//
#ifdef  _MSC_VER
#pragma pack(push, 1)
typedef struct tagWCN_VALUE_TYPE_PRIMARY_DEVICE_TYPE
    {
    WCN_VALUE_TYPE_DEVICE_TYPE_CATEGORY Category;
    WCN_VALUE_TYPE_DEVICE_TYPE_SUBCATEGORY_OUI SubCategoryOUI;
    WCN_VALUE_TYPE_DEVICE_TYPE_SUBCATEGORY SubCategory;
    } 	WCN_VALUE_TYPE_PRIMARY_DEVICE_TYPE;

#pragma pack(pop)
#endif // _MSC_VER


extern RPC_IF_HANDLE __MIDL_itf_wcntypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wcntypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wdstpdi.h ===
/*++

Copyright (c) 2006 Microsoft Corporation

Module Name:

    wdstpdi.h

Abstract:

    This module defines the structures and functions that compose the interface
    that content providers must expose to the multicast server.
 
Environment:

    User Mode

--*/

#ifndef _WDSTPDI_H
#define _WDSTPDI_H

#ifdef __cplusplus
extern "C"
{
#endif

#define WDSTRANSPORTPROVIDERAPI        __stdcall 
#define WDSMCSAPI                      __stdcall 

//---Defines-----------------------------------------------------

#define MC_SERVER_CURRENT_VERSION 1
#define TRANSPORTPROVIDER_CURRENT_VERSION 1

#define TRANSPORT_INVALID_HANDLE (HANDLE)-1

typedef enum _TRANSPORTPROVIDER_CALLBACK_ID
{
    WDS_TRANSPORTPROVIDER_CREATE_INSTANCE = 0,
    WDS_TRANSPORTPROVIDER_COMPARE_CONTENT,
    WDS_TRANSPORTPROVIDER_OPEN_CONTENT,
    WDS_TRANSPORTPROVIDER_USER_ACCESS_CHECK,
    WDS_TRANSPORTPROVIDER_GET_CONTENT_SIZE,
    WDS_TRANSPORTPROVIDER_READ_CONTENT,
    WDS_TRANSPORTPROVIDER_CLOSE_CONTENT,
    WDS_TRANSPORTPROVIDER_CLOSE_INSTANCE,
    WDS_TRANSPORTPROVIDER_SHUTDOWN,
    WDS_TRANSPORTPROVIDER_DUMP_STATE,
    WDS_TRANSPORTPROVIDER_REFRESH_SETTINGS,
    WDS_TRANSPORTPROVIDER_GET_CONTENT_METADATA,

    WDS_TRANSPORTPROVIDER_MAX_CALLBACKS,
} TRANSPORTPROVIDER_CALLBACK_ID, *PTRANSPORTPROVIDER_CALLBACK_ID;

typedef ULONG WDS_MC_SEVERITY;

#define WDS_MC_TRACE_VERBOSE           0x00010000
#define WDS_MC_TRACE_INFO              0x00020000
#define WDS_MC_TRACE_WARNING           0x00040000
#define WDS_MC_TRACE_ERROR             0x00080000
#define WDS_MC_TRACE_FATAL             0x00100000

//---Structs-----------------------------------------------------

typedef struct _WDS_TRANSPORTPROVIDER_INIT_PARAMS
{
    //
    // The length of this structure.
    //

    ULONG ulLength;

    //
    // The multicast server's version.
    //

    ULONG ulMcServerVersion;
    
    //
    // An open handle to the registry key where this provider should
    // store and retrieve its settings.
    //
    
    HKEY hRegistryKey;

    //
    // A handle that the provider can use to uniquely identify
    // itself in calls to the multicast server.
    //

    HANDLE hProvider;
} WDS_TRANSPORTPROVIDER_INIT_PARAMS, *PWDS_TRANSPORTPROVIDER_INIT_PARAMS;

typedef struct _WDS_TRANSPORTPROVIDER_SETTINGS
{
    //
    // The length of this structure.
    //

    ULONG ulLength;

    //
    // The version of the api that this provider implements.
    //

    ULONG ulProviderVersion;
} WDS_TRANSPORTPROVIDER_SETTINGS, *PWDS_TRANSPORTPROVIDER_SETTINGS;

//---Functions the provider must implement (required callbacks)---

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderInitialize(
    __in PWDS_TRANSPORTPROVIDER_INIT_PARAMS pInParameters,
    __out_bcount(ulLength) PWDS_TRANSPORTPROVIDER_SETTINGS pSettings,
    __in ULONG ulLength
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderCreateInstance(
    __in PCWSTR pwszConfigString,
    __out PHANDLE phInstance
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderCompareContent(
    __in HANDLE hInstance,
    __in PCWSTR pwszContentName,
    __in HANDLE hContent,
    __out PBOOL pbContentMatches
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderOpenContent(
    __in HANDLE hInstance,
    __in PCWSTR pwszContentName,
    __out PHANDLE phContent
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderGetContentMetadata(
    __in HANDLE hContent,
    __out_bcount(*pulLength) PVOID* pvData,
    __out PULONG pulLength
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderUserAccessCheck(
    __in HANDLE hContent,
    __in HANDLE hUserToken,
    __out PBOOL pbAccessAllowed
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderGetContentSize(
    __in HANDLE hContent,
    __out PULARGE_INTEGER pContentSize
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderReadContent(
    __in HANDLE hContent,
    __in_bcount(ulBytesToRead) PVOID pBuffer,
    __in ULONG ulBytesToRead,
    __in PULARGE_INTEGER pContentOffset,
    __in PVOID pvUserData
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderCloseContent(
    __in HANDLE hContent
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderCloseInstance(
    __in HANDLE hInstance
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderShutdown(
);

//---Functions the provider may implement (optional callbacks)-------

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderDumpState(
);

HRESULT
WDSTRANSPORTPROVIDERAPI
WdsTransportProviderRefreshSettings(
);

//---Functions provided by the multicast server----------------------

HRESULT
WDSMCSAPI
WdsTransportServerRegisterCallback(
    __in HANDLE hProvider,
    __in TRANSPORTPROVIDER_CALLBACK_ID CallbackId,
    __in PVOID pfnCallback
);

HRESULT
WDSMCSAPI
WdsTransportServerCompleteRead(
    __in HANDLE hProvider,
    __in ULONG ulBytesRead,
    __in PVOID pvUserData,
    __in HRESULT hReadResult
);

HRESULT
WDSMCSAPI
WdsTransportServerTrace(
    __in HANDLE hProvider,
    __in WDS_MC_SEVERITY Severity,
    __in LPCWSTR pwszFormat,
    ...
);

HRESULT
WDSMCSAPI
WdsTransportServerTraceV(
    __in HANDLE hProvider,
    __in WDS_MC_SEVERITY Severity,
    __in LPCWSTR pwszFormat,
    __in va_list Params
);

PVOID
WDSMCSAPI
WdsTransportServerAllocateBuffer(
    __in HANDLE hProvider,
    __in ULONG ulBufferSize
);

HRESULT
WDSMCSAPI
WdsTransportServerFreeBuffer(
    __in HANDLE hProvider,
    __in PVOID pvBuffer
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WdsClientApi.h ===
/*++

Copyright (c) 2006 Microsoft Corporation

Module Name:

    WdsClientApi.h

Abstract:

    WDS Client API public header file.

Environment:

    User Mode

--*/
#ifndef __WDSCLIENTAPI_H__
#define __WDSCLIENTAPI_H__

#if (_MSC_VER > 1000)
#pragma once
#endif

#define WDSCLIAPI WINAPI

#ifdef __cplusplus
extern "C"
{
#endif

//
// Structures
//


// Credentials structure.
//
typedef struct tagWDS_CLI_CRED
{
    PCWSTR pwszUserName,
           pwszDomain,
           pwszPassword;
} WDS_CLI_CRED, *PWDS_CLI_CRED, *LPWDS_CLI_CRED;


//
// General functions
//
HRESULT
WDSCLIAPI
WdsCliClose( 
    __in HANDLE Handle );


typedef 
VOID
(WDSCLIAPI *PFN_WdsCliTraceFunction)(
    __in LPCWSTR pwszFormat,
    __in va_list Params
);


HRESULT
WDSCLIAPI
WdsCliRegisterTrace(
    __in_opt PFN_WdsCliTraceFunction pfn );


HRESULT
WDSCLIAPI
WdsCliFreeStringArray(
    __inout_ecount_opt(ulCount) PWSTR *ppwszArray,
    __in ULONG ulCount );

//
// Image enumeration functions
//
HRESULT
WDSCLIAPI
WdsCliFindFirstImage(
    __in HANDLE hSession,
    __out PHANDLE phFindHandle );

HRESULT
WDSCLIAPI
WdsCliFindNextImage(
    __in HANDLE Handle );

HRESULT
WDSCLIAPI
WdsCliGetEnumerationFlags(
    __in HANDLE Handle,
    __out PDWORD pdwFlags );

HRESULT
WDSCLIAPI
WdsCliGetImageHandleFromFindHandle(
    __in HANDLE FindHandle,
    __out PHANDLE phImageHandle );

HRESULT
WDSCLIAPI
WdsCliGetImageHandleFromTransferHandle(
    __in HANDLE hTransfer,
    __out PHANDLE phImageHandle );


//
// Image enumeration constants
//

enum
{
    WdsCliFlagEnumFilterVersion = 0x0001,
    WdsCliFlagEnumFilterFirmware = 0x0002, 
};

//
// Image Type constants.
//
typedef enum _WDS_CLI_IMAGE_TYPE
{
    WDS_CLI_IMAGE_TYPE_UNKNOWN = 0,
    WDS_CLI_IMAGE_TYPE_WIM,
    WDS_CLI_IMAGE_TYPE_VHD
} WDS_CLI_IMAGE_TYPE, *PWDS_CLI_IMAGE_TYPE;

//
// Firmware Types.
//
typedef enum _WDS_CLI_FIRMWARE_TYPE 
{
    WDS_CLI_FIRMWARE_UNKNOWN = 0,
    WDS_CLI_FIRMWARE_BIOS = 0x0001,
    WDS_CLI_FIRMWARE_EFI = 0x0002,
} WDS_CLI_FIRMWARE_TYPE, *PWDS_CLI_FIRMWARE_TYPE;

//
// Extended Image Parameters.
//
typedef enum _WDS_CLI_IMAGE_PARAM_TYPE
{
    WDS_CLI_IMAGE_PARAM_UNKNOWN = 0,
    WDS_CLI_IMAGE_PARAM_SPARSE_FILE,
    WDS_CLI_IMAGE_PARAM_SUPPORTED_FIRMWARES,
} WDS_CLI_IMAGE_PARAM_TYPE, *PWDS_CLI_IMAGE_PARAM_TYPE;

//
// Session functions
//
HRESULT
WDSCLIAPI
WdsCliCreateSession(
    __in PWSTR pwszServer,
    __in_opt PWDS_CLI_CRED pCred,
    __out PHANDLE phSession );

HRESULT
WDSCLIAPI
WdsCliAuthorizeSession(
    __inout HANDLE hSession,
    __in_opt PWDS_CLI_CRED pCred );

//
// Client -> Server Logging functions
//
HRESULT
WDSCLIAPI
WdsCliInitializeLog(
    __in HANDLE hSession, 
    __in ULONG ulClientArchitecture,
    __in PWSTR pwszClientId,
    __in PWSTR pwszClientAddress );

HRESULT
WDSCLIAPI
WdsCliLog(
    __in HANDLE hSession,
    __in ULONG ulLogLevel,
    __in ULONG ulMessageCode,
    ... );

//
// Log events sent by the client to the server.
// Each one of these has a set of variables associated with it
// that must be present in the request in order for the request to be 
// considered valid.
//
typedef enum
{
    WDS_LOG_TYPE_CLIENT_ERROR = 1,
    WDS_LOG_TYPE_CLIENT_STARTED,
    WDS_LOG_TYPE_CLIENT_FINISHED,
    WDS_LOG_TYPE_CLIENT_IMAGE_SELECTED,    
    WDS_LOG_TYPE_CLIENT_APPLY_STARTED,
    WDS_LOG_TYPE_CLIENT_APPLY_FINISHED,
    WDS_LOG_TYPE_CLIENT_GENERIC_MESSAGE,
    WDS_LOG_TYPE_CLIENT_UNATTEND_MODE,
    WDS_LOG_TYPE_CLIENT_TRANSFER_START,
    WDS_LOG_TYPE_CLIENT_TRANSFER_END,
    WDS_LOG_TYPE_CLIENT_TRANSFER_DOWNGRADE,
    WDS_LOG_TYPE_CLIENT_DOMAINJOINERROR,
    WDS_LOG_TYPE_CLIENT_POST_ACTIONS_START,
    WDS_LOG_TYPE_CLIENT_POST_ACTIONS_END,
    WDS_LOG_TYPE_CLIENT_APPLY_STARTED_2,
    WDS_LOG_TYPE_CLIENT_APPLY_FINISHED_2,
    WDS_LOG_TYPE_CLIENT_DOMAINJOINERROR_2,
    WDS_LOG_TYPE_CLIENT_DRIVER_PACKAGE_NOT_ACCESSIBLE,
    WDS_LOG_TYPE_CLIENT_OFFLINE_DRIVER_INJECTION_START,
    WDS_LOG_TYPE_CLIENT_OFFLINE_DRIVER_INJECTION_END,
    WDS_LOG_TYPE_CLIENT_OFFLINE_DRIVER_INJECTION_FAILURE,
    WDS_LOG_TYPE_CLIENT_IMAGE_SELECTED2,   // Only add entries before WDS_LOG_TYPE_CLIENT_MAX_CODE.
    WDS_LOG_TYPE_CLIENT_MAX_CODE 
};

//
// Log levels.
//
typedef enum
{
    WDS_LOG_LEVEL_DISABLED = 0,
    WDS_LOG_LEVEL_ERROR = 1,
    WDS_LOG_LEVEL_WARNING = 2,
    WDS_LOG_LEVEL_INFO = 3
};

//
// Image information functions
//

HRESULT
WDSCLIAPI
WdsCliGetImageName(
    __in HANDLE hIfh, 
    __out PWSTR *ppwszValue );

HRESULT
WDSCLIAPI
WdsCliGetImageDescription(
    __in HANDLE hIfh, 
    __out PWSTR *ppwszValue );

HRESULT 
WDSCLIAPI 
WdsCliGetImageType(
    __in HANDLE hIfh,
    __out PWDS_CLI_IMAGE_TYPE pImageType );

HRESULT
WDSCLIAPI
WdsCliGetImageFiles(
    __in HANDLE hIfh,
    __deref_out_ecount(*pdwCount) LPWSTR **pppwszFiles,
   __out PDWORD pdwCount );

HRESULT
WDSCLIAPI
WdsCliGetImageLanguage(
    __in HANDLE hIfh, 
    __out PWSTR *ppwszValue );

HRESULT
WDSCLIAPI
WdsCliGetImageLanguages(
    __in HANDLE hIfh,
    __out_ecount(*pdwNumValues) PTSTR **pppszValues,
    __out PDWORD pdwNumValues );

HRESULT
WDSCLIAPI
WdsCliGetImageVersion(
    __in HANDLE hIfh, 
    __out PWSTR *ppwszValue );

HRESULT
WDSCLIAPI
WdsCliGetImagePath(
    __in HANDLE hIfh,
    __out PWSTR *ppwszValue );

HRESULT
WDSCLIAPI
WdsCliGetImageIndex(
    __in HANDLE hIfh,
    __out PDWORD pdwValue );

HRESULT
WDSCLIAPI
WdsCliGetImageArchitecture(
    __in HANDLE hIfh,
    __out PDWORD pdwValue );

HRESULT
WDSCLIAPI
WdsCliGetImageLastModifiedTime(
    __in HANDLE hIfh,
    __out PSYSTEMTIME *ppSysTimeValue );

HRESULT
WDSCLIAPI
WdsCliGetImageSize(
    __in HANDLE hIfh,
    __out PULONGLONG pullValue );

HRESULT
WDSCLIAPI
WdsCliGetImageHalName(
    __in HANDLE hIfh,
    __out PWSTR *ppwszValue );

HRESULT
WDSCLIAPI
WdsCliGetImageGroup(
    __in HANDLE hIfh,
    __out PWSTR *ppwszValue );

HRESULT
WDSCLIAPI
WdsCliGetImageNamespace(
    __in HANDLE hIfh,
    __out PWSTR *ppwszValue );

HRESULT 
WDSCLIAPI 
WdsCliGetImageParameter(
    __in HANDLE hIfh,
    __in WDS_CLI_IMAGE_PARAM_TYPE ParamType,
    __out_bcount(uResponseLen) PVOID pResponse,
    __in ULONG uResponseLen );

//
// Image transfer functions.
//

// Callback function
//

typedef
VOID
(WDSCLIAPI *PFN_WdsCliCallback)(
    DWORD dwMessageId,
    __in_opt WPARAM wParam,
    __in_opt LPARAM lParam,
    __in_opt PVOID pvUserData );

// Callback messages.
//
typedef enum
{
    WDS_CLI_MSG_START = 0,
    WDS_CLI_MSG_COMPLETE,
    WDS_CLI_MSG_PROGRESS,
    WDS_CLI_MSG_TEXT,
};


HRESULT
WDSCLIAPI
WdsCliGetTransferSize(
    __in HANDLE hIfh,
    __out PULONGLONG pullValue );

// Flags for transfer functions
//
#define WDS_CLI_TRANSFER_ASYNCHRONOUS         0x00000001
#define WDS_CLI_NO_SPARSE_FILE                0x00000002

HRESULT
WDSCLIAPI
WdsCliTransferImage(
    __in HANDLE hImage,
    __in PWSTR pwszLocalPath,
    __in DWORD dwFlags,
    __in DWORD dwReserved,
    __in_opt PFN_WdsCliCallback pfnWdsCliCallback,
    __in_opt PVOID pvUserData,
    __out PHANDLE phTransfer );

HRESULT
WDSCLIAPI
WdsCliTransferFile(
    __in PCWSTR pwszServer,
    __in PCWSTR pwszNamespace,
    __in PCWSTR pwszRemoteFilePath,
    __in PCWSTR pwszLocalFilePath,
    __in DWORD dwFlags,
    __in DWORD dwReserved,
    __in_opt PFN_WdsCliCallback pfnWdsCliCallback,
    __in_opt PVOID pvUserData,
    __out PHANDLE phTransfer );

HRESULT
WDSCLIAPI
WdsCliCancelTransfer(
    __in HANDLE hTransfer );

HRESULT
WDSCLIAPI
WdsCliWaitForTransfer(
    __in HANDLE hTransfer );

//
// Dynamic Driver Provisioning functions
//
HRESULT
WDSCLIAPI
WdsCliObtainDriverPackages(
    __in HANDLE hImage,
    __deref_out PWSTR *ppwszServerName,
    __deref_out_ecount(*pulCount) PWSTR **pppwszDriverPackages,
    __out ULONG *pulCount    
    );


#ifdef __cplusplus
}
#endif

#endif  // __WDSCLIENTAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wdspxe.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wdspxe.h

Abstract:

    Contains functions used to write Providers for WDSPXE Server

--*/

#ifndef __WDSPXE_H__
#define __WDSPXE_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Calling convention for WDSPXE APIs.
//
#define PXEAPI __stdcall

//
// PXE_REG_INDEX
//
typedef ULONG PXE_REG_INDEX;

#define PXE_REG_INDEX_TOP           (0)
#define PXE_REG_INDEX_BOTTOM        0xFFFFFFFF

//
// PXE_PROVIDER
//
typedef __struct_bcount(uSizeOfStruct) struct tagPXE_PROVIDER
{
    ULONG uSizeOfStruct;
    LPWSTR pwszName;
    LPWSTR pwszFilePath;
    BOOL bIsCritical;
    ULONG uIndex;
} PXE_PROVIDER, *PPXE_PROVIDER;

//
// PXE_CALLBACK_TYPE
//
typedef ULONG PXE_CALLBACK_TYPE;

#define PXE_CALLBACK_RECV_REQUEST       0
#define PXE_CALLBACK_SHUTDOWN           1
#define PXE_CALLBACK_SERVICE_CONTROL    2

#define PXE_CALLBACK_MAX                3

//
// PXE_GSI_TYPE
//
typedef ULONG PXE_GSI_TYPE;

#define PXE_GSI_TRACE_ENABLED           1

//
// PXE_ADDRESS
//
#define PXE_MAX_ADDRESS         16

#define PXE_ADDR_BROADCAST      0x0001
#define PXE_ADDR_USE_PORT       0x0002
#define PXE_ADDR_USE_ADDR       0x0004
#define PXE_ADDR_USE_DHCP_RULES 0x0008

typedef struct tagPXE_ADDRESS
{
    ULONG uFlags;
    
    union
    {
        BYTE bAddress[PXE_MAX_ADDRESS];
        ULONG uIpAddress;
    };
    
    ULONG uAddrLen;
    USHORT uPort;
} PXE_ADDRESS, *PPXE_ADDRESS;

//
// PXE_BOOT_ACTION
//
typedef ULONG PXE_BOOT_ACTION;

#define PXE_BA_NBP              1
#define PXE_BA_CUSTOM           2
#define PXE_BA_IGNORE           3
#define PXE_BA_REJECTED         4

//
// PXE_SEVERITY
//
typedef ULONG PXE_SEVERITY;

#define PXE_TRACE_VERBOSE           0x00010000
#define PXE_TRACE_INFO              0x00020000
#define PXE_TRACE_WARNING           0x00040000
#define PXE_TRACE_ERROR             0x00080000
#define PXE_TRACE_FATAL             0x00100000

//
// PXE_PROVIDER_ATTRIBUTE
//
typedef ULONG PXE_PROVIDER_ATTRIBUTE;

#define PXE_PROV_ATTR_FILTER        0

#define PXE_PROV_FILTER_ALL         0x0000
#define PXE_PROV_FILTER_DHCP_ONLY   0x0001
#define PXE_PROV_FILTER_PXE_ONLY    0x0002
//
// Provider Registration and Enumeration APIs
//
DWORD
PXEAPI
PxeProviderRegister(
    __in LPCWSTR pszProviderName,
    __in LPCWSTR pszModulePath,
    __in PXE_REG_INDEX Index,
    __in BOOL bIsCritical,
    __out_opt PHKEY phProviderKey
);

DWORD
PXEAPI
PxeProviderUnRegister(
    __in LPCWSTR pszProviderName
);

DWORD
PXEAPI
PxeProviderQueryIndex(
    __in LPCWSTR pszProviderName,
    __out PULONG puIndex
);

DWORD
PXEAPI
PxeProviderEnumFirst(
    __out HANDLE *phEnum
);

DWORD
PXEAPI
PxeProviderEnumNext(
    __in HANDLE hEnum,
    __out PPXE_PROVIDER *ppProvider
);

DWORD
PXEAPI
PxeProviderEnumClose(
    __in HANDLE hEnum
);

DWORD
PxeProviderFreeInfo(
    __in PPXE_PROVIDER pProvider
);    
    
//
// Callback Registration
//
DWORD
PXEAPI
PxeRegisterCallback(
    __in HANDLE hProvider,
    __in PXE_CALLBACK_TYPE CallbackType,
    __in PVOID pCallbackFunction,
    __in_opt PVOID pContext
);

//
// UDP Send/Boot Action
//
DWORD
PXEAPI
PxeSendReply(
    __in HANDLE hClientRequest,
    __in_bcount(uPacketLen) PVOID pPacket,
    __in ULONG uPacketLen,
    __in PXE_ADDRESS *pAddress
);

//
// Notify of Async Processing
//
DWORD
PXEAPI
PxeAsyncRecvDone(
    __in HANDLE hClientRequest,
    __in PXE_BOOT_ACTION Action
);

//
// Trace
//

DWORD
PXEAPI
PxeTrace(
    __in HANDLE hProvider,
    __in PXE_SEVERITY Severity,
    __in LPCWSTR pszFormat,
    ...
); 

DWORD
PXEAPI
PxeTraceV(
    __in HANDLE hProvider,
    __in PXE_SEVERITY Severity,
    __in LPCWSTR pszFormat,
    __in va_list Params
); 

//
// Packet Allocation
//
PVOID
PXEAPI
PxePacketAllocate(
    __in HANDLE hProvider,
    __in HANDLE hClientRequest,
    __in ULONG uSize
);

DWORD
PXEAPI
PxePacketFree(
    __in HANDLE hProvider,
    __in HANDLE hClientRequest,
    __in PVOID pPacket
);

//
// Provider Attributes
//
DWORD
PXEAPI
PxeProviderSetAttribute(
    __in HANDLE hProvider,
    __in PXE_PROVIDER_ATTRIBUTE Attribute,
    __in_bcount(uParamLen) PVOID pParameterBuffer,
    __in ULONG uParamLen
);

//
// Dhcp Functions
//
DWORD
PXEAPI
PxeDhcpInitialize(
    __in_bcount(uRecvPacketLen) PVOID pRecvPacket,
    __in ULONG uRecvPacketLen,
    __inout_bcount(uMaxReplyPacketLen) PVOID pReplyPacket,
    __in ULONG uMaxReplyPacketLen,
    __out PULONG puReplyPacketLen
);

DWORD
PXEAPI
PxeDhcpAppendOption(
    __inout_bcount(uMaxReplyPacketLen) PVOID pReplyPacket,
    __in ULONG uMaxReplyPacketLen,
    __inout PULONG puReplyPacketLen,
    __in BYTE bOption,
    __in BYTE bOptionLen,
    __in_bcount_opt(bOptionLen) PVOID pValue
);

DWORD
PXEAPI
PxeDhcpAppendOptionRaw(
    __inout_bcount(uMaxReplyPacketLen) PVOID pReplyPacket,
    __in ULONG uMaxReplyPacketLen,
    __inout PULONG puReplyPacketLen,
    __in USHORT uBufferLen,
    __in_bcount(uBufferLen) PVOID pBuffer
);

DWORD
PXEAPI
PxeDhcpIsValid(
    __in_bcount(uPacketLen) PVOID pPacket,
    __in ULONG uPacketLen,
    __in BOOL bRequestPacket,
    __out_opt PBOOL pbPxeOptionPresent
);

DWORD
PXEAPI
PxeDhcpGetOptionValue(
    __in_bcount(uPacketLen) PVOID pPacket,
    __in ULONG uPacketLen,
    __in ULONG uInstance,
    __in BYTE bOption,
    __out PBYTE pbOptionLen,
    __out PVOID *ppOptionValue
);

DWORD
PXEAPI
PxeDhcpGetVendorOptionValue(
    __in_bcount(uPacketLen) PVOID pPacket,
    __in ULONG uPacketLen,
    __in BYTE bOption,
    __in ULONG uInstance,
    __out PBYTE pbOptionLen,
    __out PVOID *ppOptionValue
);

//
// Server Information
//
DWORD
PXEAPI
PxeGetServerInfo(
    __in PXE_GSI_TYPE uInfoType,
    __out_bcount(uBufferLen) PVOID pBuffer,
    __in ULONG uBufferLen
);

//
// Ports for WDS PXE Server
//
#define     PXE_DHCP_SERVER_PORT            67
#define     PXE_DHCP_CLIENT_PORT            68
#define     PXE_SERVER_PORT                 4011

//
// PXE_DHCP_MESSAGE
//
#define     PXE_DHCP_FILE_SIZE              128
#define     PXE_DHCP_SERVER_SIZE            64
#define     PXE_DHCP_HWAADR_SIZE            16

#define     PXE_DHCP_MAGIC_COOKIE_SIZE      4
#define     PXEDHCP_MAGIC_COOKIE            (ULONG)0x63538263

//
// PXE_DHCP_OPTION
//
typedef struct tagPXE_DHCP_OPTION 
{
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[1];
} PXE_DHCP_OPTION, *PPXE_DHCP_OPTION;

typedef struct tagPXE_DHCP_MESSAGE
{
    BYTE Operation;
    BYTE HardwareAddressType;
    BYTE HardwareAddressLength;
    BYTE HopCount;
    DWORD TransactionID;
    WORD SecondsSinceBoot;
    WORD Reserved;
    ULONG ClientIpAddress;
    ULONG YourIpAddress;
    ULONG BootstrapServerAddress;
    ULONG RelayAgentIpAddress;
    BYTE HardwareAddress[PXE_DHCP_HWAADR_SIZE];
    BYTE HostName[PXE_DHCP_SERVER_SIZE];
    BYTE BootFileName[PXE_DHCP_FILE_SIZE];
    
    union
    {
        BYTE bMagicCookie[PXE_DHCP_MAGIC_COOKIE_SIZE];
        ULONG uMagicCookie;
    };

    PXE_DHCP_OPTION Option;
} PXE_DHCP_MESSAGE, *PPXE_DHCP_MESSAGE;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wdstptmgmtmsg.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2006
//
//--------------------------------------------------------------------------
// CLog::LogEvent compares the error level of the HRESULT with the error
// level of the module attempting to log the HRESULT's message (which is
// set during CLog::InitLogInstance).  If the HRESULT's error level <=
// the module's error level, then the error is logged.
//
// ADDING AND REMOVING MESSAGES
//
// Note that the MessageId is actually broken up into two parts.  The
// high 4 bits is actually an error level indicating the severity of
// the error.  The rest of the bit number indicates the actual event
// message id.  The error level can be used to filter out event
// messages that you don't want logged all the time, unless the
// administrator is actively diagnosing something.  Also note the
// message id's are limited to a 16-bit number.
//
// The messages in this file are explicitly numbered. Do not renumber
// existing messages so as to make space to add your message.
// You should always add you message in the end of the file.
// The reason is that it often desirable to be able to read an event
// log with a message file that is from a different build, so renumbering
// existing messages should be avoided.
//
// If you want to remove a message, do NOT simply delete it from the file.
// Instead change its symbolic name to BIGLOG_UNUSED_xxx (where xxx is a
// sequential number just used to uniquify the names) and its text to
//  "Unused message".
//
// If you want to set the log level of the message, you need to OR the
// message ID with the following constants, to get log level of 0, 1, 2, 3
// 0x0000 , 0x4000, 0x8000, 0xc000
//
// For example:
//     MessageId=0x8100
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_100
//     Language=English
//     This is the text for error ID 0x101, with error level 8
//     .
//     MessageId=0x4101
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_101
//     Language=English
//     This is the text for error ID 0x101, with error level 1
//     .
//     .
//     MessageId=0x10000
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_10000
//     Language=English
//     DON'T DO THIS!!!  Message ID is > 0xFFFF.  This won't EVER work
//     .
//
// IMPORTANT NOTES
//
// NOTE THAT YOU MUST NOT DELETE OR RE-USE EVENTS THAT WERE MEANINGFUL IN
// PREVIOUSLY RELEASED VERSIONS OF THE PRODUCT.  Why?  Consider an app running
// on Win2k+1 that scans the event logs of all DCs (Win2k and Win2k+1) in an
// enterprise.  The scanner should be able to retrieve the text asociated
// with the Win2k event on the Win2k+1 box (since the event log does not
// provide this service -- text must always be looked up locally).  Also
// consider that watchdog tools often cue off of certain event IDs appearing
// in the event log (e.g., to page an admin when something particularly bad
// happens), so you don't want event 893 to mean one thing on Win2k and
// something completely different on Win2k+1.
//
// By the same token, YOU MUST NOT CHANGE THE ORDER OF INSERTION STRINGS OF
// EVENTS THAT WERE MEANINGFUL IN PREVIOUSLY RELEASED VERSIONS OF THE PRODUCT.
// It's okay to add new insertion strings to existing event log messages (they
// just won't be filled in when looking at the event generated by an older
// program), just add them at the end.  (E.g., if %1 %2 and %3 are already used,
// add new insertion strings at %4, *don't* put the new one as %2 and bump
// the old %2 to %3 and the old %3 to %4.)  Whether an insertion string is
// %1 or %4 or whatever of course doesn't restrict where it can be placed in
// the message text, it only provides a mapping to the order of parameters
// given to LogEvent.
//
// To add a new message, first see if there is an existing unused message
// that you can recycle.  If so, do so.  If no more unused messages remain,
// then you must be sure to add new messages only at the very end of the
// file.
//
// Dev Note:
//     If you add new facilities here, remember to update the registry setup
//     for event logging in the manifest to correctly reflect the new category
//     count.
//
// Define the severities
//
// Define the facility names
//
//
// Service specific facilities
//
// READ THIS: be sure to update this as facilities change
//
// Category Names Used for Event Logging
//
//
// These message id's are names for categories, which are equivalent to
// to facilities - 0x100.  LogEvent extracts the facility from the HRESULT,
// and logs that as the Category.  These message IDs allow that category
// to appear as the textual facility name in the event viewer
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WDSTPTMGMT              0x110
#define FACILITY_MAX_WDSTPTMGMT          0x110
#define FACILITY_BASE_WDSTPTMGMT         0x100


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: WDSTPTMGMT_CATEGORY
//
// MessageText:
//
// WdsTptMgmt
//
#define WDSTPTMGMT_CATEGORY              ((HRESULT)0x00000001L)

///////////////////////////////////////////////////////////////////
//
//                WDSTPTMGMT Facility Messages
//
///////////////////////////////////////////////////////////////////
//
// MessageId: WDSTPTMGMT_E_INVALID_PROPERTY
//
// MessageText:
//
// The property is invalid.
//
#define WDSTPTMGMT_E_INVALID_PROPERTY    ((HRESULT)0xC1100100L)

//
// MessageId: WDSTPTMGMT_E_INVALID_OPERATION
//
// MessageText:
//
// The operation is invalid.
//
#define WDSTPTMGMT_E_INVALID_OPERATION   ((HRESULT)0xC1100101L)

//
// MessageId: WDSTPTMGMT_E_INVALID_CLASS
//
// MessageText:
//
// The interface pointer passed to the method has an invalid underlying class. Only library classes are supported.
//
#define WDSTPTMGMT_E_INVALID_CLASS       ((HRESULT)0xC1100102L)

//
// MessageId: WDSTPTMGMT_E_CONTENT_PROVIDER_ALREADY_REGISTERED
//
// MessageText:
//
// A content provider with the specified name is already registered on the server.
//
#define WDSTPTMGMT_E_CONTENT_PROVIDER_ALREADY_REGISTERED ((HRESULT)0xC1100103L)

//
// MessageId: WDSTPTMGMT_E_CONTENT_PROVIDER_NOT_REGISTERED
//
// MessageText:
//
// The specified content provider is not registered on the server.
//
#define WDSTPTMGMT_E_CONTENT_PROVIDER_NOT_REGISTERED ((HRESULT)0xC1100104L)

//
// MessageId: WDSTPTMGMT_E_INVALID_CONTENT_PROVIDER_NAME
//
// MessageText:
//
// The specified content provider name is invalid. The name must be 1 to 255 characters long and cannot contain a backslash (\) character.
//
#define WDSTPTMGMT_E_INVALID_CONTENT_PROVIDER_NAME ((HRESULT)0xC1100105L)

//
// MessageId: WDSTPTMGMT_E_TRANSPORT_SERVER_ROLE_NOT_CONFIGURED
//
// MessageText:
//
// The Windows Deployment Services Transport Server role service has not been configured on the server.
//
#define WDSTPTMGMT_E_TRANSPORT_SERVER_ROLE_NOT_CONFIGURED ((HRESULT)0xC1100106L)

//
// MessageId: WDSTPTMGMT_E_NAMESPACE_ALREADY_REGISTERED
//
// MessageText:
//
// The specified namespace is already registered on the server.
//
#define WDSTPTMGMT_E_NAMESPACE_ALREADY_REGISTERED ((HRESULT)0xC1100107L)

//
// MessageId: WDSTPTMGMT_E_NAMESPACE_NOT_REGISTERED
//
// MessageText:
//
// The specified namespace is not registered on the server.
//
#define WDSTPTMGMT_E_NAMESPACE_NOT_REGISTERED ((HRESULT)0xC1100108L)

//
// MessageId: WDSTPTMGMT_E_CANNOT_REINITIALIZE_OBJECT
//
// MessageText:
//
// The object has already been initialized and cannot be reinitialized.
//
#define WDSTPTMGMT_E_CANNOT_REINITIALIZE_OBJECT ((HRESULT)0xC1100109L)

//
// MessageId: WDSTPTMGMT_E_INVALID_NAMESPACE_NAME
//
// MessageText:
//
// The specified namespace name is invalid. The name must be 1 to 255 characters long and cannot contain a backslash (\) character.
//
#define WDSTPTMGMT_E_INVALID_NAMESPACE_NAME ((HRESULT)0xC110010AL)

//
// MessageId: WDSTPTMGMT_E_INVALID_NAMESPACE_DATA
//
// MessageText:
//
// The namespace contains invalid or unknown data.
//
#define WDSTPTMGMT_E_INVALID_NAMESPACE_DATA ((HRESULT)0xC110010BL)

//
// MessageId: WDSTPTMGMT_E_NAMESPACE_READ_ONLY
//
// MessageText:
//
// The namespace data cannot be modified because it is or has been previously registered on the server.
//
#define WDSTPTMGMT_E_NAMESPACE_READ_ONLY ((HRESULT)0xC110010CL)

//
// MessageId: WDSTPTMGMT_E_INVALID_NAMESPACE_START_TIME
//
// MessageText:
//
// The scheduled start time for the namespace is invalid.
//
#define WDSTPTMGMT_E_INVALID_NAMESPACE_START_TIME ((HRESULT)0xC110010DL)

//
// MessageId: WDSTPTMGMT_E_INVALID_DIAGNOSTICS_COMPONENTS
//
// MessageText:
//
// The specified diagnostics components mask contains invalid or unknown components.
//
#define WDSTPTMGMT_E_INVALID_DIAGNOSTICS_COMPONENTS ((HRESULT)0xC110010EL)

//
// MessageId: WDSTPTMGMT_E_CANNOT_REFRESH_DIRTY_OBJECT
//
// MessageText:
//
// The object contains unsaved changes. The object data cannot be refreshed until you commit or discard the changes.
//
#define WDSTPTMGMT_E_CANNOT_REFRESH_DIRTY_OBJECT ((HRESULT)0xC110010FL)

//
// MessageId: WDSTPTMGMT_E_INVALID_SERVICE_IP_ADDRESS_RANGE
//
// MessageText:
//
// The specified IP address range is invalid. The start and end IP addresses must be valid and the start IP address must be less than or equal to the end IP address.
//
#define WDSTPTMGMT_E_INVALID_SERVICE_IP_ADDRESS_RANGE ((HRESULT)0xC1100110L)

//
// MessageId: WDSTPTMGMT_E_INVALID_SERVICE_PORT_RANGE
//
// MessageText:
//
// The specified service port range is invalid. The start port must be less than or equal to the end port, and both values must be between 1025 and 65536, inclusive.
//
#define WDSTPTMGMT_E_INVALID_SERVICE_PORT_RANGE ((HRESULT)0xC1100111L)

//
// MessageId: WDSTPTMGMT_E_INVALID_NAMESPACE_START_PARAMETERS
//
// MessageText:
//
// The start parameters for the namespace are invalid.
//
#define WDSTPTMGMT_E_INVALID_NAMESPACE_START_PARAMETERS ((HRESULT)0xC1100112L)

//
// MessageId: WDSTPTMGMT_E_TRANSPORT_SERVER_UNAVAILABLE
//
// MessageText:
//
// The Windows Deployment Services Transport Server is unavailable.
//
#define WDSTPTMGMT_E_TRANSPORT_SERVER_UNAVAILABLE ((HRESULT)0xC1100113L)

//
// MessageId: WDSTPTMGMT_E_NAMESPACE_NOT_ON_SERVER
//
// MessageText:
//
// The specified namespace has never been registered on the server.
//
#define WDSTPTMGMT_E_NAMESPACE_NOT_ON_SERVER ((HRESULT)0xC1100114L)

//
// MessageId: WDSTPTMGMT_E_NAMESPACE_REMOVED_FROM_SERVER
//
// MessageText:
//
// The specified namespace has been unregistered and removed from the server.
//
#define WDSTPTMGMT_E_NAMESPACE_REMOVED_FROM_SERVER ((HRESULT)0xC1100115L)

//
// MessageId: WDSTPTMGMT_E_INVALID_IP_ADDRESS
//
// MessageText:
//
// The specified IP address is invalid. The IP address must be a well formed value of the correct type.
//
#define WDSTPTMGMT_E_INVALID_IP_ADDRESS  ((HRESULT)0xC1100116L)

//
// MessageId: WDSTPTMGMT_E_INVALID_IPV4_MULTICAST_ADDRESS
//
// MessageText:
//
// The specified IPv4 address is not valid for multicast. IPv4 multicast addresses must be in the range 224.0.1.0 to 239.255.255.255.
//
#define WDSTPTMGMT_E_INVALID_IPV4_MULTICAST_ADDRESS ((HRESULT)0xC1100117L)

//
// MessageId: WDSTPTMGMT_E_INVALID_IPV6_MULTICAST_ADDRESS
//
// MessageText:
//
// The specified IPv6 address is not valid for multicast. IPv6 multicast addresses must start with FF (for example, FF15::FF).
//
#define WDSTPTMGMT_E_INVALID_IPV6_MULTICAST_ADDRESS ((HRESULT)0xC1100118L)

//
// MessageId: WDSTPTMGMT_E_IPV6_NOT_SUPPORTED
//
// MessageText:
//
// The Windows Deployment Services Transport Server does not support IPv6.
//
#define WDSTPTMGMT_E_IPV6_NOT_SUPPORTED  ((HRESULT)0xC1100119L)

//
// MessageId: WDSTPTMGMT_E_INVALID_IPV6_MULTICAST_ADDRESS_SOURCE
//
// MessageText:
//
// The specified IPv6 multicast address source is invalid. Transport Server only supports using IPv6 multicast addresses from a range.
//
#define WDSTPTMGMT_E_INVALID_IPV6_MULTICAST_ADDRESS_SOURCE ((HRESULT)0xC110011AL)

//
// MessageId: WDSTPTMGMT_E_INVALID_MULTISTREAM_STREAM_COUNT
//
// MessageText:
//
// The specified multistream stream count is invalid. The stream count must be set to either 2 or 3.
//
#define WDSTPTMGMT_E_INVALID_MULTISTREAM_STREAM_COUNT ((HRESULT)0xC110011BL)

//
// MessageId: WDSTPTMGMT_E_INVALID_AUTO_DISCONNECT_THRESHOLD
//
// MessageText:
//
// The specified AutoDisconnect threshold is invalid. The threshold must be set to a value between 1 KBps and 4194303 KBps, inclusive.
//
#define WDSTPTMGMT_E_INVALID_AUTO_DISCONNECT_THRESHOLD ((HRESULT)0xC110011CL)

//
// MessageId: WDSTPTMGMT_E_MULTICAST_SESSION_POLICY_NOT_SUPPORTED
//
// MessageText:
//
// You cannot configure the multicast session policy on this Transport Server. This policy is only supported on Windows Server 2008 R2 and later.
//
#define WDSTPTMGMT_E_MULTICAST_SESSION_POLICY_NOT_SUPPORTED ((HRESULT)0xC110011DL)

//
// MessageId: WDSTPTMGMT_E_INVALID_SLOW_CLIENT_HANDLING_TYPE
//
// MessageText:
//
// The specified slow-client handling type is not valid.
//
#define WDSTPTMGMT_E_INVALID_SLOW_CLIENT_HANDLING_TYPE ((HRESULT)0xC110011EL)

//
// MessageId: WDSTPTMGMT_E_NETWORK_PROFILES_NOT_SUPPORTED
//
// MessageText:
//
// This Windows Deployment Services Transport Server does not support network profiles.
//
#define WDSTPTMGMT_E_NETWORK_PROFILES_NOT_SUPPORTED ((HRESULT)0xC110011FL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wdsmcerr.h ===
//
//
// Copyright (c) 2006 Microsoft Corporation
//
// ADDING AND REMOVING MESSAGES
//
// Note that the MessageId is actually broken up into two parts.  The
// high 4 bits is actually an error level indicating the severity of
// the error.  The rest of the bit number indicates the actual event
// message id.  The error level can be used to filter out event
// messages that you don't want logged all the time, unless the
// administrator is actively diagnosing something.  Also note the
// message id's are limited to a 16-bit number.
//
// The messages in this file are explicitly numbered. Do not renumber
// existing messages so as to make space to add your message.
// You should always add you message in the end of the file.
// The reason is that it often desirable to be able to read an event
// log with a message file that is from a different build, so renumbering
// existing messages should be avoided.
//
// If you want to remove a message, do NOT simply delete it from the file.
// Instead change its symbolic name to BIGLOG_UNUSED_xxx (where xxx is a
// sequential number just used to uniquify the names) and its text to
//  "Unused message".
//
// If you want to set the log level of the message, you need to OR the
// message ID with the following constants, to get log level of 0, 1, 2, 3
// 0x0000 , 0x4000, 0x8000, 0xc000
//
// For example:
//     MessageId=0x8100
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_100
//     Language=English
//     This is the text for error ID 0x101, with error level 8
//     .
//     MessageId=0x4101
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_101
//     Language=English
//     This is the text for error ID 0x101, with error level 1
//     .
//     .
//     MessageId=0x10000
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_10000
//     Language=English
//     DON'T DO THIS!!!  Message ID is > 0xFFFF.  This won't EVER work
//     .
//
// IMPORTANT NOTES
//
// NOTE THAT YOU MUST NOT DELETE OR RE-USE EVENTS THAT WERE MEANINGFUL IN
// PREVIOUSLY RELEASED VERSIONS OF THE PRODUCT.  Why?  Consider an app running
// on Win2k+1 that scans the event logs of all DCs (Win2k and Win2k+1) in an
// enterprise.  The scanner should be able to retrieve the text asociated
// with the Win2k event on the Win2k+1 box (since the event log does not
// provide this service -- text must always be looked up locally).  Also
// consider that watchdog tools often cue off of certain event IDs appearing
// in the event log (e.g., to page an admin when something particularly bad
// happens), so you don't want event 893 to mean one thing on Win2k and
// something completely different on Win2k+1.
//
// By the same token, YOU MUST NOT CHANGE THE ORDER OF INSERTION STRINGS OF
// EVENTS THAT WERE MEANINGFUL IN PREVIOUSLY RELEASED VERSIONS OF THE PRODUCT.
// It's okay to add new insertion strings to existing event log messages (they
// just won't be filled in when looking at the event generated by an older
// program), just add them at the end.  (E.g., if %1 %2 and %3 are already used,
// add new insertion strings at %4, *don't* put the new one as %2 and bump
// the old %2 to %3 and the old %3 to %4.)  Whether an insertion string is
// %1 or %4 or whatever of course doesn't restrict where it can be placed in
// the message text, it only provides a mapping to the order of parameters
// given to LogEvent.
//
// To add a new message, first see if there is an existing unused message
// that you can recycle.  If so, do so.  If no more unused messages remain,
// then you must be sure to add new messages only at the very end of the
// file.
// 
// Naming Convention:
//
// For error codes (which are not logged to event log)
//
//     <Facility>_<Type>_<Error>
//
// For errors that are logged as events in event log:
//
//     EVT_<Facility>_<Type>_<Error>
//
// Dev Note:
//     If you add new facilities here, remember to update the registry setup
//     for event logging in the manifest to correctly reflect the new category
//     count.
//
// Define the severities
//
// Define the facility names
//
//
// Service specific facilities
//
//
// WDS Multicast Client facility. 
//
// READ THIS: be sure to update this as facilities change
//
// Category Names Used for Event Logging
//
//
// These message id's are names for categories, which are equivalent to
// to facilities - 0x100.  LogEvent extracts the facility from the HRESULT,
// and logs that as the Category.  These message IDs allow that category
// to appear as the textual facility name in the event viewer
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WDSMCSERVER             0x121
#define FACILITY_WDSMCCLIENT             0x122
#define FACILITY_MAX_WDSMC               0x122
#define FACILITY_BASE_WDSMC              0x120


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: WDSMCSERVER_CATEGORY
//
// MessageText:
//
// WDS Multicast Server
//
#define WDSMCSERVER_CATEGORY             ((HRESULT)0x00000001L)

//
// MessageId: WDSMCCLIENT_CATEGORY
//
// MessageText:
//
// WDS Multicast Client
//
#define WDSMCCLIENT_CATEGORY             ((HRESULT)0x00000002L)

///////////////////////////////////////////////////////////////////
//
// WDS Multicast Server Facility Error Codes.
//
///////////////////////////////////////////////////////////////////
//
// MessageId: WDSMCS_E_SESSION_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// The request for content was rejected because shutdown is in progress for 
// specified session.
//
#define WDSMCS_E_SESSION_SHUTDOWN_IN_PROGRESS ((HRESULT)0xC1210100L)

//
// MessageId: WDSMCS_E_REQCALLBACKS_NOT_REG
//
// MessageText:
//
// The Content Provider did not register required callbacks.
//
#define WDSMCS_E_REQCALLBACKS_NOT_REG    ((HRESULT)0xC1210101L)

//
// MessageId: WDSMCS_E_INCOMPATIBLE_VERSION
//
// MessageText:
//
// The supported version reported by Content Provider is incompatible.
//
#define WDSMCS_E_INCOMPATIBLE_VERSION    ((HRESULT)0xC1210102L)

//
// MessageId: WDSMCS_E_CONTENT_NOT_FOUND
//
// MessageText:
//
// The specified content was not found.
//
#define WDSMCS_E_CONTENT_NOT_FOUND       ((HRESULT)0xC1210103L)

//
// MessageId: WDSMCS_E_CLIENT_NOT_FOUND
//
// MessageText:
//
// The specified client was not found.
//
#define WDSMCS_E_CLIENT_NOT_FOUND        ((HRESULT)0xC1210104L)

//
// MessageId: WDSMCS_E_NAMESPACE_NOT_FOUND
//
// MessageText:
//
// The specified namespace was not found.
//
#define WDSMCS_E_NAMESPACE_NOT_FOUND     ((HRESULT)0xC1210105L)

//
// MessageId: WDSMCS_E_CONTENT_PROVIDER_NOT_FOUND
//
// MessageText:
//
// The specified content provider was not found.
//
#define WDSMCS_E_CONTENT_PROVIDER_NOT_FOUND ((HRESULT)0xC1210106L)

//
// MessageId: WDSMCS_E_NAMESPACE_ALREADY_EXISTS
//
// MessageText:
//
// The specified namespace already exists.
//
#define WDSMCS_E_NAMESPACE_ALREADY_EXISTS ((HRESULT)0xC1210107L)

//
// MessageId: WDSMCS_E_NAMESPACE_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// Namespace is in pending close state.
//
#define WDSMCS_E_NAMESPACE_SHUTDOWN_IN_PROGRESS ((HRESULT)0xC1210108L)

//
// MessageId: WDSMCS_E_NAMESPACE_ALREADY_STARTED
//
// MessageText:
//
// The namespace has already started.
//
#define WDSMCS_E_NAMESPACE_ALREADY_STARTED ((HRESULT)0xC1210109L)

//
// MessageId: WDSMCS_E_NS_START_FAILED_NO_CLIENTS
//
// MessageText:
//
// The namespace cannot be started because there are no clients in the namespace.
//
#define WDSMCS_E_NS_START_FAILED_NO_CLIENTS ((HRESULT)0xC121010AL)

//
// MessageId: WDSMCS_E_START_TIME_IN_PAST
//
// MessageText:
//
// The specified start time is in the past.
//
#define WDSMCS_E_START_TIME_IN_PAST      ((HRESULT)0xC121010BL)

//
// MessageId: WDSMCS_E_PACKET_NOT_HASHED
//
// MessageText:
//
// A packet was received without a hash.
//
#define WDSMCS_E_PACKET_NOT_HASHED       ((HRESULT)0xC121010CL)

//
// MessageId: WDSMCS_E_PACKET_NOT_SIGNED
//
// MessageText:
//
// A packet was received without a signature.
//
#define WDSMCS_E_PACKET_NOT_SIGNED       ((HRESULT)0xC121010DL)

//
// MessageId: WDSMCS_E_PACKET_HAS_SECURITY
//
// MessageText:
//
// A signed or hashed packet was received.
//
#define WDSMCS_E_PACKET_HAS_SECURITY     ((HRESULT)0xC121010EL)

//
// MessageId: WDSMCS_E_PACKET_NOT_CHECKSUMED
//
// MessageText:
//
// A packet was received without checksum.
//
#define WDSMCS_E_PACKET_NOT_CHECKSUMED   ((HRESULT)0xC121010FL)

//
// MessageId: WDSMCS_E_CLIENT_DOESNOT_SUPPORT_SECURITY_MODE
//
// MessageText:
//
// The client does not support the required security mode.
//
#define WDSMCS_E_CLIENT_DOESNOT_SUPPORT_SECURITY_MODE ((HRESULT)0xC1210110L)

///////////////////////////////////////////////////////////////////
//
// WDS Multicast Server Facility Event Log Messages.
//
///////////////////////////////////////////////////////////////////
//
// MessageId: EVT_WDSMCS_S_PARAMETERS_READ
//
// MessageText:
//
// The Windows Deployment Multicast server successfully read its configuration 
// settings. The Windows Deployment Multicast server will now process incoming 
// client requests.
//
#define EVT_WDSMCS_S_PARAMETERS_READ     ((HRESULT)0x41210200L)

//
// MessageId: EVT_WDSMCS_E_PARAMETERS_READ_FAILED
//
// MessageText:
//
// An error occurred while trying to read the configuration information. The 
// Windows Deployment Multicast server will not process incoming client requests. %n
// %n
// Error Information: %1 %n
//
#define EVT_WDSMCS_E_PARAMETERS_READ_FAILED ((HRESULT)0xC1210201L)

//
// MessageId: EVT_WDSMCS_E_DUPLICATE_MULTICAST_ADDR
//
// MessageText:
//
// The multicast IP address %1 is being used by another Windows Deployment Services 
// server, which has IP %2. Use the Windows Deployment Services management tools to 
// configure your multicast IP address range to avoid this multicast IP address. If 
// you allow this overlap to continue, your network usage will be increased.
//
#define EVT_WDSMCS_E_DUPLICATE_MULTICAST_ADDR ((HRESULT)0xC1210202L)

//
// MessageId: EVT_WDSMCS_E_NON_WDS_DUPLICATE_MULTICAST_ADDR
//
// MessageText:
//
// The multicast IP address %1 is being used by another multicast server, which has 
// IP %2. Use the Windows Deployment Services management tools to configure your 
// multicast IP address range to avoid this multicast IP address. If you allow this
// overlap to continue, your network usage will be increased.
//
#define EVT_WDSMCS_E_NON_WDS_DUPLICATE_MULTICAST_ADDR ((HRESULT)0xC1210203L)

//---------------------------------------------------------- Content Providers.
//
// MessageId: EVT_WDSMCS_E_CP_DLL_LOAD_FAILED
//
// MessageText:
//
// An error occurred while trying to load the module %1 for Content Provider %2. %n
// %n
// Error Information: %3 %n
//
#define EVT_WDSMCS_E_CP_DLL_LOAD_FAILED  ((HRESULT)0xC1210250L)

//
// MessageId: EVT_WDSMCS_E_CP_INIT_FUNC_MISSING
//
// MessageText:
//
// The module %1 for Content Provider %2 does not export the initialization 
// function %3. %n
// %n
// Error Information: %4 %n
//
#define EVT_WDSMCS_E_CP_INIT_FUNC_MISSING ((HRESULT)0xC1210251L)

//
// MessageId: EVT_WDSMCS_E_CP_INIT_FUNC_FAILED
//
// MessageText:
//
// The Content Provider %1 loaded from %2 failed to initialize. %n
// %n
// Error Information: %3 %n
//
#define EVT_WDSMCS_E_CP_INIT_FUNC_FAILED ((HRESULT)0xC1210252L)

//
// MessageId: EVT_WDSMCS_E_CP_INCOMPATIBLE_SERVER_VERSION
//
// MessageText:
//
// The Content Provider %1 is incompatible with this version of Windows Deployment
// Multicast Server. %n
//
#define EVT_WDSMCS_E_CP_INCOMPATIBLE_SERVER_VERSION ((HRESULT)0xC1210253L)

//
// MessageId: EVT_WDSMCS_E_CP_CALLBACKS_NOT_REG
//
// MessageText:
//
// The Content Provider %1 did not register required callbacks during its 
// initialization. %n
//
#define EVT_WDSMCS_E_CP_CALLBACKS_NOT_REG ((HRESULT)0xC1210254L)

//
// MessageId: EVT_WDSMCS_E_CP_SHUTDOWN_FUNC_FAILED
//
// MessageText:
//
// The shutdown function for Content Provider %1 failed. %n
// %n
// Error Information: %2 %n
//
#define EVT_WDSMCS_E_CP_SHUTDOWN_FUNC_FAILED ((HRESULT)0xC1210255L)

//
// MessageId: EVT_WDSMCS_E_CP_MEMORY_LEAK
//
// MessageText:
//
// The Content Provider %1 did not release %2 memory allocation(s) after its 
// shutdown function has successfully returned.
//
#define EVT_WDSMCS_E_CP_MEMORY_LEAK      ((HRESULT)0xC1210256L)

//
// MessageId: EVT_WDSMCS_E_CP_OPEN_INSTANCE_FAILED
//
// MessageText:
//
// The Content Provider %1 returned an error while trying to open a new instance. %n
// %n
// Configuration: %2 %n
// Error Information: %3 %n
//
#define EVT_WDSMCS_E_CP_OPEN_INSTANCE_FAILED ((HRESULT)0xC1210257L)

//
// MessageId: EVT_WDSMCS_E_CP_CLOSE_INSTANCE_FAILED
//
// MessageText:
//
// The Content Provider %1 returned an error while trying to close an instance. %n
// %n
// Error Information: %2 %n
//
#define EVT_WDSMCS_E_CP_CLOSE_INSTANCE_FAILED ((HRESULT)0xC1210258L)

//
// MessageId: EVT_WDSMCS_E_CP_OPEN_CONTENT_FAILED
//
// MessageText:
//
// The Content Provider %1 returned an error while trying to open content %2. %n
// %n
// Error Information: %3 %n
//
#define EVT_WDSMCS_E_CP_OPEN_CONTENT_FAILED ((HRESULT)0xC1210259L)

//
// MessageId: EVT_WDSMCS_W_CP_DLL_LOAD_FAILED_NOT_CRITICAL
//
// MessageText:
//
// The Content Provider %1 failed to initialize. The provider is marked as non-critical.
// WDS Multicast server will continue to start.%n
// %n
// Error Information: %2 %n
//
#define EVT_WDSMCS_W_CP_DLL_LOAD_FAILED_NOT_CRITICAL ((HRESULT)0x8121025AL)

//
// MessageId: EVT_WDSMCS_E_CP_DLL_LOAD_FAILED_CRITICAL
//
// MessageText:
//
// The Content Provider %1 failed to initialize. The provider is marked as critical.
// WDS Multicast server will fail to start.%n
// %n
// Error Information: %2 %n
//
#define EVT_WDSMCS_E_CP_DLL_LOAD_FAILED_CRITICAL ((HRESULT)0xC121025BL)

//------------------------------------------------------------------ Namespace.
//
// MessageId: EVT_WDSMCS_E_NSREG_START_TIME_IN_PAST
//
// MessageText:
//
// The ScheduledCast namespace %1 using content provider %2 could not be registered 
// as it starts in the past. The namespace has been removed from the namespace 
// store. %n
// %n
// Error Information: %3 %n
//
#define EVT_WDSMCS_E_NSREG_START_TIME_IN_PAST ((HRESULT)0xC1210300L)

//
// MessageId: EVT_WDSMCS_E_NSREG_CONTENT_PROVIDER_NOT_REG
//
// MessageText:
//
// The namespace %1 using content provider %2 could not be registered as the 
// content provider is not registered. The namespace has been removed from the 
// namespace store. %n
// %n
// Error Information: %3 %n
//
#define EVT_WDSMCS_E_NSREG_CONTENT_PROVIDER_NOT_REG ((HRESULT)0xC1210301L)

//
// MessageId: EVT_WDSMCS_E_NSREG_NAMESPACE_EXISTS
//
// MessageText:
//
// The namespace %1 using content provider %2 could not be registered as a 
// namespace by that name already exists. The namespace has been removed from the 
// namespace store. %n
// %n
// Error Information: %3 %n
//
#define EVT_WDSMCS_E_NSREG_NAMESPACE_EXISTS ((HRESULT)0xC1210302L)

//
// MessageId: EVT_WDSMCS_E_NSREG_FAILURE
//
// MessageText:
//
// The namespace %1 using content provider %2 could not be registered due to an 
// unknown error. %n
// %n
// Error Information: %3 %n
//
#define EVT_WDSMCS_E_NSREG_FAILURE       ((HRESULT)0xC1210303L)

///////////////////////////////////////////////////////////////////
//
// WDS Multicast Client Facility Error Codes.
//
///////////////////////////////////////////////////////////////////
//
// MessageId: WDSTPC_E_CALLBACKS_NOT_REG
//
// MessageText:
//
// The required callbacks were not registered.
//
#define WDSTPC_E_CALLBACKS_NOT_REG       ((HRESULT)0xC1220300L)

//
// MessageId: WDSTPC_E_ALREADY_COMPLETED
//
// MessageText:
//
// The session has already completed the download. 
//
#define WDSTPC_E_ALREADY_COMPLETED       ((HRESULT)0xC1220301L)

//
// MessageId: WDSTPC_E_ALREADY_IN_PROGRESS
//
// MessageText:
//
// The download is already in progress.
//
#define WDSTPC_E_ALREADY_IN_PROGRESS     ((HRESULT)0xC1220302L)

//
// MessageId: WDSTPC_E_UNKNOWN_ERROR
//
// MessageText:
//
// An unknown error occurred.
//
#define WDSTPC_E_UNKNOWN_ERROR           ((HRESULT)0xC1220303L)

//
// MessageId: WDSTPC_E_NOT_INITIALIZED
//
// MessageText:
//
// WDS Multicast Client not initialized.
//
#define WDSTPC_E_NOT_INITIALIZED         ((HRESULT)0xC1220304L)

//
// MessageId: WDSTPC_E_KICKED_POLICY_NOT_MET
//
// MessageText:
//
// The client did not meet the policy requirements set by the administrator and was
// kicked from the session.
//
#define WDSTPC_E_KICKED_POLICY_NOT_MET   ((HRESULT)0xC1220305L)

//
// MessageId: WDSTPC_E_KICKED_FALLBACK
//
// MessageText:
//
// The client was kicked by the administrator. The client should fallback to some 
// other mechanism to get the contents. 
//
#define WDSTPC_E_KICKED_FALLBACK         ((HRESULT)0xC1220306L)

//
// MessageId: WDSTPC_E_KICKED_FAIL
//
// MessageText:
//
// The client was kicked by the administrator. The client should fail the operation
// completely.
//
#define WDSTPC_E_KICKED_FAIL             ((HRESULT)0xC1220307L)

//
// MessageId: WDSTPC_E_KICKED_UNKNOWN
//
// MessageText:
//
// The client was kicked by the administrator. An unknown reason was specified for 
// kicking from session.
//
#define WDSTPC_E_KICKED_UNKNOWN          ((HRESULT)0xC1220308L)

//
// MessageId: WDSTPC_E_MULTISTREAM_NOT_ENABLED
//
// MessageText:
//
// Multistream support is not enabled.
//
#define WDSTPC_E_MULTISTREAM_NOT_ENABLED ((HRESULT)0xC1220309L)

//
// MessageId: WDSTPC_E_ALREADY_IN_LOWEST_SESSION
//
// MessageText:
//
// The specified client is already in the lowest multistream session.
//
#define WDSTPC_E_ALREADY_IN_LOWEST_SESSION ((HRESULT)0xC122030AL)

//
// MessageId: WDSTPC_E_CLIENT_DEMOTE_NOT_SUPPORTED
//
// MessageText:
//
// The specified client does not support demotion.
//
#define WDSTPC_E_CLIENT_DEMOTE_NOT_SUPPORTED ((HRESULT)0xC122030BL)

//
// MessageId: WDSTPC_E_NO_IP4_INTERFACE
//
// MessageText:
//
// No IPv4 interface available on server.
//
#define WDSTPC_E_NO_IP4_INTERFACE        ((HRESULT)0xC122030CL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wdscpmsg.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2006
//
//--------------------------------------------------------------------------
// CLog::LogEvent compares the error level of the HRESULT with the error
// level of the module attempting to log the HRESULT's message (which is
// set during CLog::InitLogInstance).  If the HRESULT's error level <=
// the module's error level, then the error is logged.
//
// ADDING AND REMOVING MESSAGES
//
// Note that the MessageId is actually broken up into two parts.  The
// high 4 bits is actually an error level indicating the severity of
// the error.  The rest of the bit number indicates the actual event
//    message id.  The error level can be used to filter out event
// messages that you don't want logged all the time, unless the
// administrator is actively diagnosing something.  Also note the
// message id's are limited to a 16-bit number.
//
// The messages in this file are explicitly numbered. Do not renumber
// existing messages so as to make space to add your message.
// You should always add you message in the end of the file.
// The reason is that it often desirable to be able to read an event
// log with a message file that is from a different build, so renumbering
// existing messages should be avoided.
//
// If you want to remove a message, do NOT simply delete it from the file.
// Instead change its symbolic name to BIGLOG_UNUSED_xxx (where xxx is a
// sequential number just used to uniquify the names) and its text to
//  "Unused message".
//
// If you want to set the log level of the message, you need to OR the
// message ID with the following constants, to get log level of 0, 1, 2, 3
// 0x0000 , 0x4000, 0x8000, 0xc000
//
// For example:
//     MessageId=0x8100
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_100
//     Language=English
//     This is the text for error ID 0x101, with error level 8
//     .
//     MessageId=0x4101
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_101
//     Language=English
//     This is the text for error ID 0x101, with error level 1
//     .
//     .
//     MessageId=0x10000
//     Facility=MyFacility
//     Severity=Error
//     SymbolicName=ERROR_ID_10000
//     Language=English
//     DONT' DO THIS!!!  Message ID is > 0xFFFF.  This won't EVER work
//     .
//
// IMPORTANT NOTES
//
// NOTE THAT YOU MUST NOT DELETE OR RE-USE EVENTS THAT WERE MEANINGFUL IN
// PREVIOUSLY RELEASED VERSIONS OF THE PRODUCT.  Why?  Consider an app running
// on Win2k+1 that scans the event logs of all DCs (Win2k and Win2k+1) in an
// enterprise.  The scanner should be able to retrieve the text asociated
// with the Win2k event on the Win2k+1 box (since the event log does not
// provide this service -- text must always be looked up locally).  Also
// consider that watchdog tools often cue off of certain event IDs appearing
// in the event log (e.g., to page an admin when something particularly bad
// happens), so you don't want event 893 to mean one thing on Win2k and
// something completely different on Win2k+1.
//
// By the same token, YOU MUST NOT CHANGE THE ORDER OF INSERTION STRINGS OF
// EVENTS THAT WERE MEANINGFUL IN PREVIOUSLY RELEASED VERSIONS OF THE PRODUCT.
// It's okay to add new insertion strings to existing event log messages (they
// just won't be filled in when looking at the event generated by an older
// program), just add them at the end.  (E.g., if %1 %2 and %3 are already used,
// add new insertion strings at %4, *don't* put the new one as %2 and bump
// the old %2 to %3 and the old %3 to %4.)  Whether an insertion string is
// %1 or %4 or whatever of course doesn't restrict where it can be placed in
// the message text, it only provides a mapping to the order of parameters
// given to LogEvent.
//
// To add a new message, first see if there is an existing unused message
// that you can recycle.  If so, do so.  If no more unused messages remain,
// then you must be sure to add new messages only at the very end of the
// file.
//
// Dev Note:
//     If you add new facilities here, remember to update the registry setup
//     for event logging in the manifest to correctly reflect the new category
//     count.
//
// Define the severities
//
// Define the facility names
//
//
// Service specific facilities
//
// READ THIS: be sure to update this as facilities change
//
// Category Names Used for Event Logging
//
//
// These message id's are names for categories, which are equivalent to
// to facilities - 0x100.  LogEvent extracts the facility from the HRESULT,
// and logs that as the Category.  These message IDs allow that category
// to appear as the textual facility name in the event viewer
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WDSCP                   0x125
#define FACILITY_MAX_WDSCP               0x125
#define FACILITY_BASE_WDSCP              0x100


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: WDSCP_CATEGORY
//
// MessageText:
//
// WdsCp
//
#define WDSCP_CATEGORY                   ((HRESULT)0x00000001L)

///////////////////////////////////////////////////////////////////
//
//                WDSCP Facility Messages
//
///////////////////////////////////////////////////////////////////
//
// Error Messages
// These start at ID 100
//
//
// MessageId: WDSCP_E_INVALID_CONFIGURATION
//
// MessageText:
//
// The configuration string was invalid or empty.
//
#define WDSCP_E_INVALID_CONFIGURATION    ((HRESULT)0xC1250100L)

//
// MessageId: WDSCP_E_NOT_A_DIRECTORY
//
// MessageText:
//
// The path specified in the configuration string was not a directory.
//
#define WDSCP_E_NOT_A_DIRECTORY          ((HRESULT)0xC1250101L)

//
// MessageId: WDSCP_E_CONFIG_STRING_REQUIRED
//
// MessageText:
//
// The WDS Content Provider requires that a configuration string be provided.
//
#define WDSCP_E_CONFIG_STRING_REQUIRED   ((HRESULT)0xC1250102L)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wdstci.h ===
/*++

Copyright (c) 2005 Microsoft Corporation

Module Name:

    wdstci.h

Abstract:

    This module defines the structures and functions that compose the interface
    between the content receiver and the transport client.
 
Environment:

    User Mode

--*/

#ifndef _WDSTCI_H
#define _WDSTCI_H

#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif

#define WDSTCIAPI                      __stdcall 

//----------------------------------------------------------------- Defines.

#define WDS_TRANSPORTCLIENT_CURRENT_API_VERSION 1

//
// Protocol types
//

#define WDS_TRANSPORTCLIENT_PROTOCOL_MULTICAST       0x00000001

//
// Authentication levels
//

#define WDS_TRANSPORTCLIENT_AUTH    0x1
#define WDS_TRANSPORTCLIENT_NO_AUTH 0x2

typedef enum _TRANSPORTCLIENT_CALLBACK_ID
{
    WDS_TRANSPORTCLIENT_SESSION_START = 0,
    WDS_TRANSPORTCLIENT_RECEIVE_CONTENTS,
    WDS_TRANSPORTCLIENT_SESSION_COMPLETE,
    WDS_TRANSPORTCLIENT_RECEIVE_METADATA,
    WDS_TRANSPORTCLIENT_SESSION_STARTEX,

    WDS_TRANSPORTCLIENT_MAX_CALLBACKS,
} TRANSPORTCLIENT_CALLBACK_ID, *PTRANSPORTCLIENT_CALLBACK_ID;

typedef struct _TRANSPORTCLIENT_SESSION_INFO
{
    //
    // The length of this structure in bytes.
    //
    
    ULONG ulStructureLength;

    //
    // The size of the file, in bytes.
    //

    ULARGE_INTEGER ullFileSize;

    //
    // The size of a receive block, in bytes.
    //

    ULONG ulBlockSize;
    
} TRANSPORTCLIENT_SESSION_INFO, *PTRANSPORTCLIENT_SESSION_INFO;

#define WDS_TRANSPORTCLIENT_NO_CACHE                0

//
// Download status. 
//
#define WDS_TRANSPORTCLIENT_STATUS_IN_PROGRESS      0x0001
#define WDS_TRANSPORTCLIENT_STATUS_SUCCESS          0x0002
#define WDS_TRANSPORTCLIENT_STATUS_FAILURE          0x0003

//----------------------------------------------------------------- Callbacks.



typedef
VOID
(CALLBACK *PFN_WdsTransportClientSessionStart)(
    __in HANDLE hSessionKey,
    __in PVOID pCallerData,
    __in PULARGE_INTEGER FileSize
);

typedef
VOID
(CALLBACK *PFN_WdsTransportClientSessionStartEx)(
    __in HANDLE hSessionKey,
    __in PVOID pCallerData,
    __in PTRANSPORTCLIENT_SESSION_INFO Info
);

typedef
VOID
(CALLBACK *PFN_WdsTransportClientReceiveMetadata)(
    __in HANDLE hSessionKey,
    __in PVOID pCallerData,
    __in_bcount(ulSize) PVOID pMetadata,
    __in ULONG ulSize
);

typedef
VOID
(CALLBACK *PFN_WdsTransportClientReceiveContents)(
    __in HANDLE hSessionKey,
    __in PVOID pCallerData,    
    __in_bcount(ulSize) PVOID pContents,
    __in ULONG ulSize,
    __in PULARGE_INTEGER pContentOffset
);

typedef
VOID
(CALLBACK *PFN_WdsTransportClientSessionComplete)(
    __in HANDLE hSessionKey,
    __in PVOID pCallerData,    
    __in DWORD dwError
);

//----------------------------------------------------------------- Structures.

typedef struct _WDS_TRANSPORTCLIENT_REQUEST 
{
    //
    // The length of this structure.
    //
    ULONG ulLength;

    //
    // The version of the api that the caller is built against.  Callers should
    // always set this field to WDS_TRANSPORT_CLIENT_CURRENT_API_VERSION.
    //
    ULONG ulApiVersion;

    //
    // The level of authentication to send to the server.
    //
    ULONG ulAuthLevel;

    //
    // Server name. 
    //
    LPCWSTR pwszServer;

    //
    // Namespace of the object to retrieve.
    //
    LPCWSTR pwszNamespace;

    //
    // Specifies the name of the object to retrieve.  Object names are
    // provider dependant.
    //
    LPCWSTR pwszObjectName;

    //
    // Specifies how much data in bytes the consumer can store in its queue.  Once
    // this threshold is reached, the client will not send any more writes to
    // the consumer until some memory is released with 
    // WdsTransportClientCompleteWrite.
    //
    ULONG ulCacheSize;

    //
    // Specifies the protocol to be used for this transfer.
    //
    ULONG ulProtocol;

    //
    // Protocol specific information.
    //
    PVOID pvProtocolData;

    //
    // The length of the protocol data pointed to by pvProtocolData.
    //
    ULONG ulProtocolDataLength;
} WDS_TRANSPORTCLIENT_REQUEST, *PWDS_TRANSPORTCLIENT_REQUEST;

//----------------------------------------------------------------- Functions.

DWORD 
WDSTCIAPI
WdsTransportClientInitialize(
);

DWORD 
WDSTCIAPI
WdsTransportClientInitializeSession(
    __in PWDS_TRANSPORTCLIENT_REQUEST pSessionRequest,
    __in PVOID pCallerData,
    __out PHANDLE hSessionKey
);

DWORD 
WDSTCIAPI
WdsTransportClientRegisterCallback(
    __in HANDLE hSessionKey,
    __in TRANSPORTCLIENT_CALLBACK_ID CallbackId,
    __in PVOID pfnCallback
);

DWORD 
WDSTCIAPI
WdsTransportClientStartSession(
    __in HANDLE hSessionKey
);

DWORD
WDSTCIAPI
WdsTransportClientCompleteReceive(
    __in HANDLE hSessionKey,
    __in ULONG ulSize,
    __in PULARGE_INTEGER pullOffset
);

DWORD 
WDSTCIAPI
WdsTransportClientCancelSession(
    __in HANDLE hSessionKey
);

DWORD
WDSTCIAPI 
WdsTransportClientCancelSessionEx(
    __in HANDLE hSessionKey,
    __in DWORD dwErrorCode 
);    

DWORD
WDSTCIAPI 
WdsTransportClientWaitForCompletion(
    __in HANDLE hSessionKey,
    __in ULONG uTimeout 
);

DWORD
WDSTCIAPI
WdsTransportClientQueryStatus(
    __in HANDLE hSessionKey,
    __out PULONG puStatus,
    __out PULONG puErrorCode 
);    

DWORD
WDSTCIAPI
WdsTransportClientCloseSession(
    __in HANDLE hSessionKey
);

DWORD
WDSTCIAPI
WdsTransportClientAddRefBuffer(
    __in PVOID pvBuffer
);

DWORD
WDSTCIAPI
WdsTransportClientReleaseBuffer(
    __in PVOID pvBuffer
);

DWORD 
WDSTCIAPI
WdsTransportClientShutdown(
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wdstptmgmt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wdstptmgmt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wdstptmgmt_h__
#define __wdstptmgmt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWdsTransportCacheable_FWD_DEFINED__
#define __IWdsTransportCacheable_FWD_DEFINED__
typedef interface IWdsTransportCacheable IWdsTransportCacheable;
#endif 	/* __IWdsTransportCacheable_FWD_DEFINED__ */


#ifndef __IWdsTransportCollection_FWD_DEFINED__
#define __IWdsTransportCollection_FWD_DEFINED__
typedef interface IWdsTransportCollection IWdsTransportCollection;
#endif 	/* __IWdsTransportCollection_FWD_DEFINED__ */


#ifndef __IWdsTransportManager_FWD_DEFINED__
#define __IWdsTransportManager_FWD_DEFINED__
typedef interface IWdsTransportManager IWdsTransportManager;
#endif 	/* __IWdsTransportManager_FWD_DEFINED__ */


#ifndef __IWdsTransportServer_FWD_DEFINED__
#define __IWdsTransportServer_FWD_DEFINED__
typedef interface IWdsTransportServer IWdsTransportServer;
#endif 	/* __IWdsTransportServer_FWD_DEFINED__ */


#ifndef __IWdsTransportSetupManager_FWD_DEFINED__
#define __IWdsTransportSetupManager_FWD_DEFINED__
typedef interface IWdsTransportSetupManager IWdsTransportSetupManager;
#endif 	/* __IWdsTransportSetupManager_FWD_DEFINED__ */


#ifndef __IWdsTransportConfigurationManager_FWD_DEFINED__
#define __IWdsTransportConfigurationManager_FWD_DEFINED__
typedef interface IWdsTransportConfigurationManager IWdsTransportConfigurationManager;
#endif 	/* __IWdsTransportConfigurationManager_FWD_DEFINED__ */


#ifndef __IWdsTransportConfigurationManager2_FWD_DEFINED__
#define __IWdsTransportConfigurationManager2_FWD_DEFINED__
typedef interface IWdsTransportConfigurationManager2 IWdsTransportConfigurationManager2;
#endif 	/* __IWdsTransportConfigurationManager2_FWD_DEFINED__ */


#ifndef __IWdsTransportNamespaceManager_FWD_DEFINED__
#define __IWdsTransportNamespaceManager_FWD_DEFINED__
typedef interface IWdsTransportNamespaceManager IWdsTransportNamespaceManager;
#endif 	/* __IWdsTransportNamespaceManager_FWD_DEFINED__ */


#ifndef __IWdsTransportServicePolicy_FWD_DEFINED__
#define __IWdsTransportServicePolicy_FWD_DEFINED__
typedef interface IWdsTransportServicePolicy IWdsTransportServicePolicy;
#endif 	/* __IWdsTransportServicePolicy_FWD_DEFINED__ */


#ifndef __IWdsTransportDiagnosticsPolicy_FWD_DEFINED__
#define __IWdsTransportDiagnosticsPolicy_FWD_DEFINED__
typedef interface IWdsTransportDiagnosticsPolicy IWdsTransportDiagnosticsPolicy;
#endif 	/* __IWdsTransportDiagnosticsPolicy_FWD_DEFINED__ */


#ifndef __IWdsTransportMulticastSessionPolicy_FWD_DEFINED__
#define __IWdsTransportMulticastSessionPolicy_FWD_DEFINED__
typedef interface IWdsTransportMulticastSessionPolicy IWdsTransportMulticastSessionPolicy;
#endif 	/* __IWdsTransportMulticastSessionPolicy_FWD_DEFINED__ */


#ifndef __IWdsTransportNamespace_FWD_DEFINED__
#define __IWdsTransportNamespace_FWD_DEFINED__
typedef interface IWdsTransportNamespace IWdsTransportNamespace;
#endif 	/* __IWdsTransportNamespace_FWD_DEFINED__ */


#ifndef __IWdsTransportNamespaceAutoCast_FWD_DEFINED__
#define __IWdsTransportNamespaceAutoCast_FWD_DEFINED__
typedef interface IWdsTransportNamespaceAutoCast IWdsTransportNamespaceAutoCast;
#endif 	/* __IWdsTransportNamespaceAutoCast_FWD_DEFINED__ */


#ifndef __IWdsTransportNamespaceScheduledCast_FWD_DEFINED__
#define __IWdsTransportNamespaceScheduledCast_FWD_DEFINED__
typedef interface IWdsTransportNamespaceScheduledCast IWdsTransportNamespaceScheduledCast;
#endif 	/* __IWdsTransportNamespaceScheduledCast_FWD_DEFINED__ */


#ifndef __IWdsTransportNamespaceScheduledCastManualStart_FWD_DEFINED__
#define __IWdsTransportNamespaceScheduledCastManualStart_FWD_DEFINED__
typedef interface IWdsTransportNamespaceScheduledCastManualStart IWdsTransportNamespaceScheduledCastManualStart;
#endif 	/* __IWdsTransportNamespaceScheduledCastManualStart_FWD_DEFINED__ */


#ifndef __IWdsTransportNamespaceScheduledCastAutoStart_FWD_DEFINED__
#define __IWdsTransportNamespaceScheduledCastAutoStart_FWD_DEFINED__
typedef interface IWdsTransportNamespaceScheduledCastAutoStart IWdsTransportNamespaceScheduledCastAutoStart;
#endif 	/* __IWdsTransportNamespaceScheduledCastAutoStart_FWD_DEFINED__ */


#ifndef __IWdsTransportContent_FWD_DEFINED__
#define __IWdsTransportContent_FWD_DEFINED__
typedef interface IWdsTransportContent IWdsTransportContent;
#endif 	/* __IWdsTransportContent_FWD_DEFINED__ */


#ifndef __IWdsTransportSession_FWD_DEFINED__
#define __IWdsTransportSession_FWD_DEFINED__
typedef interface IWdsTransportSession IWdsTransportSession;
#endif 	/* __IWdsTransportSession_FWD_DEFINED__ */


#ifndef __IWdsTransportClient_FWD_DEFINED__
#define __IWdsTransportClient_FWD_DEFINED__
typedef interface IWdsTransportClient IWdsTransportClient;
#endif 	/* __IWdsTransportClient_FWD_DEFINED__ */


#ifndef __WdsTransportCacheable_FWD_DEFINED__
#define __WdsTransportCacheable_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportCacheable WdsTransportCacheable;
#else
typedef struct WdsTransportCacheable WdsTransportCacheable;
#endif /* __cplusplus */

#endif 	/* __WdsTransportCacheable_FWD_DEFINED__ */


#ifndef __WdsTransportCollection_FWD_DEFINED__
#define __WdsTransportCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportCollection WdsTransportCollection;
#else
typedef struct WdsTransportCollection WdsTransportCollection;
#endif /* __cplusplus */

#endif 	/* __WdsTransportCollection_FWD_DEFINED__ */


#ifndef __WdsTransportManager_FWD_DEFINED__
#define __WdsTransportManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportManager WdsTransportManager;
#else
typedef struct WdsTransportManager WdsTransportManager;
#endif /* __cplusplus */

#endif 	/* __WdsTransportManager_FWD_DEFINED__ */


#ifndef __WdsTransportServer_FWD_DEFINED__
#define __WdsTransportServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportServer WdsTransportServer;
#else
typedef struct WdsTransportServer WdsTransportServer;
#endif /* __cplusplus */

#endif 	/* __WdsTransportServer_FWD_DEFINED__ */


#ifndef __WdsTransportSetupManager_FWD_DEFINED__
#define __WdsTransportSetupManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportSetupManager WdsTransportSetupManager;
#else
typedef struct WdsTransportSetupManager WdsTransportSetupManager;
#endif /* __cplusplus */

#endif 	/* __WdsTransportSetupManager_FWD_DEFINED__ */


#ifndef __WdsTransportConfigurationManager_FWD_DEFINED__
#define __WdsTransportConfigurationManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportConfigurationManager WdsTransportConfigurationManager;
#else
typedef struct WdsTransportConfigurationManager WdsTransportConfigurationManager;
#endif /* __cplusplus */

#endif 	/* __WdsTransportConfigurationManager_FWD_DEFINED__ */


#ifndef __WdsTransportNamespaceManager_FWD_DEFINED__
#define __WdsTransportNamespaceManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportNamespaceManager WdsTransportNamespaceManager;
#else
typedef struct WdsTransportNamespaceManager WdsTransportNamespaceManager;
#endif /* __cplusplus */

#endif 	/* __WdsTransportNamespaceManager_FWD_DEFINED__ */


#ifndef __WdsTransportServicePolicy_FWD_DEFINED__
#define __WdsTransportServicePolicy_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportServicePolicy WdsTransportServicePolicy;
#else
typedef struct WdsTransportServicePolicy WdsTransportServicePolicy;
#endif /* __cplusplus */

#endif 	/* __WdsTransportServicePolicy_FWD_DEFINED__ */


#ifndef __WdsTransportDiagnosticsPolicy_FWD_DEFINED__
#define __WdsTransportDiagnosticsPolicy_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportDiagnosticsPolicy WdsTransportDiagnosticsPolicy;
#else
typedef struct WdsTransportDiagnosticsPolicy WdsTransportDiagnosticsPolicy;
#endif /* __cplusplus */

#endif 	/* __WdsTransportDiagnosticsPolicy_FWD_DEFINED__ */


#ifndef __WdsTransportMulticastSessionPolicy_FWD_DEFINED__
#define __WdsTransportMulticastSessionPolicy_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportMulticastSessionPolicy WdsTransportMulticastSessionPolicy;
#else
typedef struct WdsTransportMulticastSessionPolicy WdsTransportMulticastSessionPolicy;
#endif /* __cplusplus */

#endif 	/* __WdsTransportMulticastSessionPolicy_FWD_DEFINED__ */


#ifndef __WdsTransportNamespace_FWD_DEFINED__
#define __WdsTransportNamespace_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportNamespace WdsTransportNamespace;
#else
typedef struct WdsTransportNamespace WdsTransportNamespace;
#endif /* __cplusplus */

#endif 	/* __WdsTransportNamespace_FWD_DEFINED__ */


#ifndef __WdsTransportNamespaceAutoCast_FWD_DEFINED__
#define __WdsTransportNamespaceAutoCast_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportNamespaceAutoCast WdsTransportNamespaceAutoCast;
#else
typedef struct WdsTransportNamespaceAutoCast WdsTransportNamespaceAutoCast;
#endif /* __cplusplus */

#endif 	/* __WdsTransportNamespaceAutoCast_FWD_DEFINED__ */


#ifndef __WdsTransportNamespaceScheduledCast_FWD_DEFINED__
#define __WdsTransportNamespaceScheduledCast_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportNamespaceScheduledCast WdsTransportNamespaceScheduledCast;
#else
typedef struct WdsTransportNamespaceScheduledCast WdsTransportNamespaceScheduledCast;
#endif /* __cplusplus */

#endif 	/* __WdsTransportNamespaceScheduledCast_FWD_DEFINED__ */


#ifndef __WdsTransportNamespaceScheduledCastManualStart_FWD_DEFINED__
#define __WdsTransportNamespaceScheduledCastManualStart_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportNamespaceScheduledCastManualStart WdsTransportNamespaceScheduledCastManualStart;
#else
typedef struct WdsTransportNamespaceScheduledCastManualStart WdsTransportNamespaceScheduledCastManualStart;
#endif /* __cplusplus */

#endif 	/* __WdsTransportNamespaceScheduledCastManualStart_FWD_DEFINED__ */


#ifndef __WdsTransportNamespaceScheduledCastAutoStart_FWD_DEFINED__
#define __WdsTransportNamespaceScheduledCastAutoStart_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportNamespaceScheduledCastAutoStart WdsTransportNamespaceScheduledCastAutoStart;
#else
typedef struct WdsTransportNamespaceScheduledCastAutoStart WdsTransportNamespaceScheduledCastAutoStart;
#endif /* __cplusplus */

#endif 	/* __WdsTransportNamespaceScheduledCastAutoStart_FWD_DEFINED__ */


#ifndef __WdsTransportContent_FWD_DEFINED__
#define __WdsTransportContent_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportContent WdsTransportContent;
#else
typedef struct WdsTransportContent WdsTransportContent;
#endif /* __cplusplus */

#endif 	/* __WdsTransportContent_FWD_DEFINED__ */


#ifndef __WdsTransportSession_FWD_DEFINED__
#define __WdsTransportSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportSession WdsTransportSession;
#else
typedef struct WdsTransportSession WdsTransportSession;
#endif /* __cplusplus */

#endif 	/* __WdsTransportSession_FWD_DEFINED__ */


#ifndef __WdsTransportClient_FWD_DEFINED__
#define __WdsTransportClient_FWD_DEFINED__

#ifdef __cplusplus
typedef class WdsTransportClient WdsTransportClient;
#else
typedef struct WdsTransportClient WdsTransportClient;
#endif /* __cplusplus */

#endif 	/* __WdsTransportClient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wdstptmgmt_0000_0000 */
/* [local] */ 

//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
//



















typedef /* [public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0001
    {	WdsTptFeatureAdminPack	= 0x1,
	WdsTptFeatureTransportServer	= 0x2,
	WdsTptFeatureDeploymentServer	= 0x4
    } 	WDSTRANSPORT_FEATURE_FLAGS;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0001 *PWDSTRANSPORT_FEATURE_FLAGS;

#define WDSTRANSPORT_FEATURE_FLAGS_ALL  ( WdsTptFeatureAdminPack | WdsTptFeatureTransportServer | WdsTptFeatureDeploymentServer )
typedef /* [public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0002
    {	WdsTptProtocolUnicast	= 0x1,
	WdsTptProtocolMulticast	= 0x2
    } 	WDSTRANSPORT_PROTOCOL_FLAGS;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0002 *PWDSTRANSPORT_PROTOCOL_FLAGS;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0003
    {	WdsTptNamespaceTypeUnknown	= 0,
	WdsTptNamespaceTypeAutoCast	= 1,
	WdsTptNamespaceTypeScheduledCastManualStart	= 2,
	WdsTptNamespaceTypeScheduledCastAutoStart	= 3
    } 	WDSTRANSPORT_NAMESPACE_TYPE;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0003 *PWDSTRANSPORT_NAMESPACE_TYPE;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0004
    {	WdsTptDisconnectUnknown	= 0,
	WdsTptDisconnectFallback	= 1,
	WdsTptDisconnectAbort	= 2
    } 	WDSTRANSPORT_DISCONNECT_TYPE;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0004 *PWDSTRANSPORT_DISCONNECT_TYPE;

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0005
    {	WdsTptServiceNotifyUnknown	= 0,
	WdsTptServiceNotifyReadSettings	= 1
    } 	WDSTRANSPORT_SERVICE_NOTIFICATION;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0005 *PWDSTRANSPORT_SERVICE_NOTIFICATION;

typedef /* [public][public][public][public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0006
    {	WdsTptIpAddressUnknown	= 0,
	WdsTptIpAddressIpv4	= 1,
	WdsTptIpAddressIpv6	= 2
    } 	WDSTRANSPORT_IP_ADDRESS_TYPE;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0006 *PWDSTRANSPORT_IP_ADDRESS_TYPE;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0007
    {	WdsTptIpAddressSourceUnknown	= 0,
	WdsTptIpAddressSourceDhcp	= 1,
	WdsTptIpAddressSourceRange	= 2
    } 	WDSTRANSPORT_IP_ADDRESS_SOURCE_TYPE;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0007 *PWDSTRANSPORT_IP_ADDRESS_SOURCE_TYPE;

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0008
    {	WdsTptNetworkProfileUnknown	= 0,
	WdsTptNetworkProfileCustom	= 1,
	WdsTptNetworkProfile10Mbps	= 2,
	WdsTptNetworkProfile100Mbps	= 3,
	WdsTptNetworkProfile1Gbps	= 4
    } 	WDSTRANSPORT_NETWORK_PROFILE_TYPE;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0008 *PWDSTRANSPORT_NETWORK_PROFILE_TYPE;

typedef /* [public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0009
    {	WdsTptDiagnosticsComponentPxe	= 0x1,
	WdsTptDiagnosticsComponentTftp	= 0x2,
	WdsTptDiagnosticsComponentImageServer	= 0x4,
	WdsTptDiagnosticsComponentMulticast	= 0x8
    } 	WDSTRANSPORT_DIAGNOSTICS_COMPONENT_FLAGS;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0009 *PWDSTRANSPORT_DIAGNOSTICS_COMPONENT_FLAGS;

#define WDSTRANSPORT_DIAGNOSTICS_COMPONENT_FLAGS_ALL  ( WdsTptDiagnosticsComponentPxe | WdsTptDiagnosticsComponentTftp | WdsTptDiagnosticsComponentImageServer | WdsTptDiagnosticsComponentMulticast )
#define WDSTRANSPORT_RESOURCE_UTILIZATION_UNKNOWN    0xFF
typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0010
    {	WdsTptSlowClientHandlingUnknown	= 0,
	WdsTptSlowClientHandlingNone	= 1,
	WdsTptSlowClientHandlingAutoDisconnect	= 2,
	WdsTptSlowClientHandlingMultistream	= 3
    } 	WDSTRANSPORT_SLOW_CLIENT_HANDLING_TYPE;

typedef /* [v1_enum] */ enum __MIDL___MIDL_itf_wdstptmgmt_0000_0000_0010 *PWDSTRANSPORT_SLOW_CLIENT_HANDLING_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wdstptmgmt_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wdstptmgmt_0000_0000_v0_0_s_ifspec;

#ifndef __IWdsTransportCacheable_INTERFACE_DEFINED__
#define __IWdsTransportCacheable_INTERFACE_DEFINED__

/* interface IWdsTransportCacheable */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportCacheable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("46AD894B-0BAB-47DC-84B2-7B553F1D8F80")
    IWdsTransportCacheable : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Dirty( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbDirty) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Discard( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportCacheableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportCacheable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportCacheable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportCacheable * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportCacheable * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportCacheable * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportCacheable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportCacheable * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dirty )( 
            __RPC__in IWdsTransportCacheable * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbDirty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Discard )( 
            __RPC__in IWdsTransportCacheable * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportCacheable * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWdsTransportCacheable * This);
        
        END_INTERFACE
    } IWdsTransportCacheableVtbl;

    interface IWdsTransportCacheable
    {
        CONST_VTBL struct IWdsTransportCacheableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportCacheable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportCacheable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportCacheable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportCacheable_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportCacheable_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportCacheable_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportCacheable_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportCacheable_get_Dirty(This,pbDirty)	\
    ( (This)->lpVtbl -> get_Dirty(This,pbDirty) ) 

#define IWdsTransportCacheable_Discard(This)	\
    ( (This)->lpVtbl -> Discard(This) ) 

#define IWdsTransportCacheable_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportCacheable_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportCacheable_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportCollection_INTERFACE_DEFINED__
#define __IWdsTransportCollection_INTERFACE_DEFINED__

/* interface IWdsTransportCollection */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8BA4B1A-2FF4-43AB-996C-B2B10A91A6EB")
    IWdsTransportCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out ULONG *pulCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ ULONG ulIndex,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IWdsTransportCollection * This,
            /* [retval][out] */ __RPC__out ULONG *pulCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IWdsTransportCollection * This,
            /* [in] */ ULONG ulIndex,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IWdsTransportCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppVal);
        
        END_INTERFACE
    } IWdsTransportCollectionVtbl;

    interface IWdsTransportCollection
    {
        CONST_VTBL struct IWdsTransportCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportCollection_get_Count(This,pulCount)	\
    ( (This)->lpVtbl -> get_Count(This,pulCount) ) 

#define IWdsTransportCollection_get_Item(This,ulIndex,ppVal)	\
    ( (This)->lpVtbl -> get_Item(This,ulIndex,ppVal) ) 

#define IWdsTransportCollection_get__NewEnum(This,ppVal)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportCollection_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportManager_INTERFACE_DEFINED__
#define __IWdsTransportManager_INTERFACE_DEFINED__

/* interface IWdsTransportManager */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5B0D35F5-1B13-4AFD-B878-6526DC340B5D")
    IWdsTransportManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWdsTransportServer( 
            /* [in] */ __RPC__in BSTR bszServerName,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportServer **ppWdsTransportServer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetWdsTransportServer )( 
            __RPC__in IWdsTransportManager * This,
            /* [in] */ __RPC__in BSTR bszServerName,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportServer **ppWdsTransportServer);
        
        END_INTERFACE
    } IWdsTransportManagerVtbl;

    interface IWdsTransportManager
    {
        CONST_VTBL struct IWdsTransportManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportManager_GetWdsTransportServer(This,bszServerName,ppWdsTransportServer)	\
    ( (This)->lpVtbl -> GetWdsTransportServer(This,bszServerName,ppWdsTransportServer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportManager_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportServer_INTERFACE_DEFINED__
#define __IWdsTransportServer_INTERFACE_DEFINED__

/* interface IWdsTransportServer */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09CCD093-830D-4344-A30A-73AE8E8FCA90")
    IWdsTransportServer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SetupManager( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportSetupManager **ppWdsTransportSetupManager) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConfigurationManager( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportConfigurationManager **ppWdsTransportConfigurationManager) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NamespaceManager( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespaceManager **ppWdsTransportNamespaceManager) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisconnectClient( 
            /* [in] */ ULONG ulClientId,
            WDSTRANSPORT_DISCONNECT_TYPE DisconnectionType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportServer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportServer * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportServer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportServer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportServer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IWdsTransportServer * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SetupManager )( 
            __RPC__in IWdsTransportServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportSetupManager **ppWdsTransportSetupManager);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConfigurationManager )( 
            __RPC__in IWdsTransportServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportConfigurationManager **ppWdsTransportConfigurationManager);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NamespaceManager )( 
            __RPC__in IWdsTransportServer * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespaceManager **ppWdsTransportNamespaceManager);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisconnectClient )( 
            __RPC__in IWdsTransportServer * This,
            /* [in] */ ULONG ulClientId,
            WDSTRANSPORT_DISCONNECT_TYPE DisconnectionType);
        
        END_INTERFACE
    } IWdsTransportServerVtbl;

    interface IWdsTransportServer
    {
        CONST_VTBL struct IWdsTransportServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportServer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportServer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportServer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportServer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportServer_get_Name(This,pbszName)	\
    ( (This)->lpVtbl -> get_Name(This,pbszName) ) 

#define IWdsTransportServer_get_SetupManager(This,ppWdsTransportSetupManager)	\
    ( (This)->lpVtbl -> get_SetupManager(This,ppWdsTransportSetupManager) ) 

#define IWdsTransportServer_get_ConfigurationManager(This,ppWdsTransportConfigurationManager)	\
    ( (This)->lpVtbl -> get_ConfigurationManager(This,ppWdsTransportConfigurationManager) ) 

#define IWdsTransportServer_get_NamespaceManager(This,ppWdsTransportNamespaceManager)	\
    ( (This)->lpVtbl -> get_NamespaceManager(This,ppWdsTransportNamespaceManager) ) 

#define IWdsTransportServer_DisconnectClient(This,ulClientId,DisconnectionType)	\
    ( (This)->lpVtbl -> DisconnectClient(This,ulClientId,DisconnectionType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportServer_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportSetupManager_INTERFACE_DEFINED__
#define __IWdsTransportSetupManager_INTERFACE_DEFINED__

/* interface IWdsTransportSetupManager */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportSetupManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7238425-EFA8-40A4-AEF9-C98D969C0B75")
    IWdsTransportSetupManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ __RPC__out ULONGLONG *pullVersion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InstalledFeatures( 
            /* [retval][out] */ __RPC__out ULONG *pulInstalledFeatures) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocols( 
            /* [retval][out] */ __RPC__out ULONG *pulProtocols) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterContentProvider( 
            /* [in] */ __RPC__in BSTR bszName,
            /* [in] */ __RPC__in BSTR bszDescription,
            /* [in] */ __RPC__in BSTR bszFilePath,
            /* [in] */ __RPC__in BSTR bszInitializationRoutine) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeregisterContentProvider( 
            /* [in] */ __RPC__in BSTR bszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportSetupManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportSetupManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportSetupManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportSetupManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [retval][out] */ __RPC__out ULONGLONG *pullVersion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InstalledFeatures )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [retval][out] */ __RPC__out ULONG *pulInstalledFeatures);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocols )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [retval][out] */ __RPC__out ULONG *pulProtocols);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterContentProvider )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [in] */ __RPC__in BSTR bszName,
            /* [in] */ __RPC__in BSTR bszDescription,
            /* [in] */ __RPC__in BSTR bszFilePath,
            /* [in] */ __RPC__in BSTR bszInitializationRoutine);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeregisterContentProvider )( 
            __RPC__in IWdsTransportSetupManager * This,
            /* [in] */ __RPC__in BSTR bszName);
        
        END_INTERFACE
    } IWdsTransportSetupManagerVtbl;

    interface IWdsTransportSetupManager
    {
        CONST_VTBL struct IWdsTransportSetupManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportSetupManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportSetupManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportSetupManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportSetupManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportSetupManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportSetupManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportSetupManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportSetupManager_get_Version(This,pullVersion)	\
    ( (This)->lpVtbl -> get_Version(This,pullVersion) ) 

#define IWdsTransportSetupManager_get_InstalledFeatures(This,pulInstalledFeatures)	\
    ( (This)->lpVtbl -> get_InstalledFeatures(This,pulInstalledFeatures) ) 

#define IWdsTransportSetupManager_get_Protocols(This,pulProtocols)	\
    ( (This)->lpVtbl -> get_Protocols(This,pulProtocols) ) 

#define IWdsTransportSetupManager_RegisterContentProvider(This,bszName,bszDescription,bszFilePath,bszInitializationRoutine)	\
    ( (This)->lpVtbl -> RegisterContentProvider(This,bszName,bszDescription,bszFilePath,bszInitializationRoutine) ) 

#define IWdsTransportSetupManager_DeregisterContentProvider(This,bszName)	\
    ( (This)->lpVtbl -> DeregisterContentProvider(This,bszName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportSetupManager_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportConfigurationManager_INTERFACE_DEFINED__
#define __IWdsTransportConfigurationManager_INTERFACE_DEFINED__

/* interface IWdsTransportConfigurationManager */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportConfigurationManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("84CC4779-42DD-4792-891E-1321D6D74B44")
    IWdsTransportConfigurationManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServicePolicy( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportServicePolicy **ppWdsTransportServicePolicy) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiagnosticsPolicy( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportDiagnosticsPolicy **ppWdsTransportDiagnosticsPolicy) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WdsTransportServicesRunning( 
            /* [in] */ VARIANT_BOOL bRealtimeStatus,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbServicesRunning) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableWdsTransportServices( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableWdsTransportServices( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartWdsTransportServices( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopWdsTransportServices( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestartWdsTransportServices( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NotifyWdsTransportServices( 
            /* [in] */ WDSTRANSPORT_SERVICE_NOTIFICATION ServiceNotification) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportConfigurationManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportConfigurationManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportConfigurationManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportConfigurationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportConfigurationManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportConfigurationManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportConfigurationManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportConfigurationManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServicePolicy )( 
            __RPC__in IWdsTransportConfigurationManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportServicePolicy **ppWdsTransportServicePolicy);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiagnosticsPolicy )( 
            __RPC__in IWdsTransportConfigurationManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportDiagnosticsPolicy **ppWdsTransportDiagnosticsPolicy);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WdsTransportServicesRunning )( 
            __RPC__in IWdsTransportConfigurationManager * This,
            /* [in] */ VARIANT_BOOL bRealtimeStatus,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbServicesRunning);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisableWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestartWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NotifyWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager * This,
            /* [in] */ WDSTRANSPORT_SERVICE_NOTIFICATION ServiceNotification);
        
        END_INTERFACE
    } IWdsTransportConfigurationManagerVtbl;

    interface IWdsTransportConfigurationManager
    {
        CONST_VTBL struct IWdsTransportConfigurationManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportConfigurationManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportConfigurationManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportConfigurationManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportConfigurationManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportConfigurationManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportConfigurationManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportConfigurationManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportConfigurationManager_get_ServicePolicy(This,ppWdsTransportServicePolicy)	\
    ( (This)->lpVtbl -> get_ServicePolicy(This,ppWdsTransportServicePolicy) ) 

#define IWdsTransportConfigurationManager_get_DiagnosticsPolicy(This,ppWdsTransportDiagnosticsPolicy)	\
    ( (This)->lpVtbl -> get_DiagnosticsPolicy(This,ppWdsTransportDiagnosticsPolicy) ) 

#define IWdsTransportConfigurationManager_get_WdsTransportServicesRunning(This,bRealtimeStatus,pbServicesRunning)	\
    ( (This)->lpVtbl -> get_WdsTransportServicesRunning(This,bRealtimeStatus,pbServicesRunning) ) 

#define IWdsTransportConfigurationManager_EnableWdsTransportServices(This)	\
    ( (This)->lpVtbl -> EnableWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager_DisableWdsTransportServices(This)	\
    ( (This)->lpVtbl -> DisableWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager_StartWdsTransportServices(This)	\
    ( (This)->lpVtbl -> StartWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager_StopWdsTransportServices(This)	\
    ( (This)->lpVtbl -> StopWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager_RestartWdsTransportServices(This)	\
    ( (This)->lpVtbl -> RestartWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager_NotifyWdsTransportServices(This,ServiceNotification)	\
    ( (This)->lpVtbl -> NotifyWdsTransportServices(This,ServiceNotification) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportConfigurationManager_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportConfigurationManager2_INTERFACE_DEFINED__
#define __IWdsTransportConfigurationManager2_INTERFACE_DEFINED__

/* interface IWdsTransportConfigurationManager2 */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportConfigurationManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D0D85CAF-A153-4F1D-A9DD-96F431C50717")
    IWdsTransportConfigurationManager2 : public IWdsTransportConfigurationManager
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MulticastSessionPolicy( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportMulticastSessionPolicy **ppWdsTransportMulticastSessionPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportConfigurationManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportConfigurationManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportConfigurationManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportConfigurationManager2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServicePolicy )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportServicePolicy **ppWdsTransportServicePolicy);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiagnosticsPolicy )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportDiagnosticsPolicy **ppWdsTransportDiagnosticsPolicy);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WdsTransportServicesRunning )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [in] */ VARIANT_BOOL bRealtimeStatus,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbServicesRunning);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisableWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestartWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NotifyWdsTransportServices )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [in] */ WDSTRANSPORT_SERVICE_NOTIFICATION ServiceNotification);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MulticastSessionPolicy )( 
            __RPC__in IWdsTransportConfigurationManager2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportMulticastSessionPolicy **ppWdsTransportMulticastSessionPolicy);
        
        END_INTERFACE
    } IWdsTransportConfigurationManager2Vtbl;

    interface IWdsTransportConfigurationManager2
    {
        CONST_VTBL struct IWdsTransportConfigurationManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportConfigurationManager2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportConfigurationManager2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportConfigurationManager2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportConfigurationManager2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportConfigurationManager2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportConfigurationManager2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportConfigurationManager2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportConfigurationManager2_get_ServicePolicy(This,ppWdsTransportServicePolicy)	\
    ( (This)->lpVtbl -> get_ServicePolicy(This,ppWdsTransportServicePolicy) ) 

#define IWdsTransportConfigurationManager2_get_DiagnosticsPolicy(This,ppWdsTransportDiagnosticsPolicy)	\
    ( (This)->lpVtbl -> get_DiagnosticsPolicy(This,ppWdsTransportDiagnosticsPolicy) ) 

#define IWdsTransportConfigurationManager2_get_WdsTransportServicesRunning(This,bRealtimeStatus,pbServicesRunning)	\
    ( (This)->lpVtbl -> get_WdsTransportServicesRunning(This,bRealtimeStatus,pbServicesRunning) ) 

#define IWdsTransportConfigurationManager2_EnableWdsTransportServices(This)	\
    ( (This)->lpVtbl -> EnableWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager2_DisableWdsTransportServices(This)	\
    ( (This)->lpVtbl -> DisableWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager2_StartWdsTransportServices(This)	\
    ( (This)->lpVtbl -> StartWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager2_StopWdsTransportServices(This)	\
    ( (This)->lpVtbl -> StopWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager2_RestartWdsTransportServices(This)	\
    ( (This)->lpVtbl -> RestartWdsTransportServices(This) ) 

#define IWdsTransportConfigurationManager2_NotifyWdsTransportServices(This,ServiceNotification)	\
    ( (This)->lpVtbl -> NotifyWdsTransportServices(This,ServiceNotification) ) 


#define IWdsTransportConfigurationManager2_get_MulticastSessionPolicy(This,ppWdsTransportMulticastSessionPolicy)	\
    ( (This)->lpVtbl -> get_MulticastSessionPolicy(This,ppWdsTransportMulticastSessionPolicy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportConfigurationManager2_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportNamespaceManager_INTERFACE_DEFINED__
#define __IWdsTransportNamespaceManager_INTERFACE_DEFINED__

/* interface IWdsTransportNamespaceManager */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportNamespaceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E22D9F6-3777-4D98-83E1-F98696717BA3")
    IWdsTransportNamespaceManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateNamespace( 
            /* [in] */ WDSTRANSPORT_NAMESPACE_TYPE NamespaceType,
            /* [in] */ __RPC__in BSTR bszNamespaceName,
            /* [in] */ __RPC__in BSTR bszContentProvider,
            /* [in] */ __RPC__in BSTR bszConfiguration,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespace) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetrieveNamespace( 
            /* [in] */ __RPC__in BSTR bszNamespaceName,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespace) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetrieveNamespaces( 
            /* [in] */ __RPC__in BSTR bszContentProvider,
            /* [in] */ __RPC__in BSTR bszNamespaceName,
            /* [in] */ VARIANT_BOOL bIncludeTombstones,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportNamespaces) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportNamespaceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportNamespaceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportNamespaceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportNamespaceManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportNamespaceManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportNamespaceManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportNamespaceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportNamespaceManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateNamespace )( 
            __RPC__in IWdsTransportNamespaceManager * This,
            /* [in] */ WDSTRANSPORT_NAMESPACE_TYPE NamespaceType,
            /* [in] */ __RPC__in BSTR bszNamespaceName,
            /* [in] */ __RPC__in BSTR bszContentProvider,
            /* [in] */ __RPC__in BSTR bszConfiguration,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespace);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveNamespace )( 
            __RPC__in IWdsTransportNamespaceManager * This,
            /* [in] */ __RPC__in BSTR bszNamespaceName,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespace);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveNamespaces )( 
            __RPC__in IWdsTransportNamespaceManager * This,
            /* [in] */ __RPC__in BSTR bszContentProvider,
            /* [in] */ __RPC__in BSTR bszNamespaceName,
            /* [in] */ VARIANT_BOOL bIncludeTombstones,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportNamespaces);
        
        END_INTERFACE
    } IWdsTransportNamespaceManagerVtbl;

    interface IWdsTransportNamespaceManager
    {
        CONST_VTBL struct IWdsTransportNamespaceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportNamespaceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportNamespaceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportNamespaceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportNamespaceManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportNamespaceManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportNamespaceManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportNamespaceManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportNamespaceManager_CreateNamespace(This,NamespaceType,bszNamespaceName,bszContentProvider,bszConfiguration,ppWdsTransportNamespace)	\
    ( (This)->lpVtbl -> CreateNamespace(This,NamespaceType,bszNamespaceName,bszContentProvider,bszConfiguration,ppWdsTransportNamespace) ) 

#define IWdsTransportNamespaceManager_RetrieveNamespace(This,bszNamespaceName,ppWdsTransportNamespace)	\
    ( (This)->lpVtbl -> RetrieveNamespace(This,bszNamespaceName,ppWdsTransportNamespace) ) 

#define IWdsTransportNamespaceManager_RetrieveNamespaces(This,bszContentProvider,bszNamespaceName,bIncludeTombstones,ppWdsTransportNamespaces)	\
    ( (This)->lpVtbl -> RetrieveNamespaces(This,bszContentProvider,bszNamespaceName,bIncludeTombstones,ppWdsTransportNamespaces) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportNamespaceManager_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportServicePolicy_INTERFACE_DEFINED__
#define __IWdsTransportServicePolicy_INTERFACE_DEFINED__

/* interface IWdsTransportServicePolicy */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportServicePolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9468578-9F2B-48CC-B27A-A60799C2750C")
    IWdsTransportServicePolicy : public IWdsTransportCacheable
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IpAddressSource( 
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_IP_ADDRESS_SOURCE_TYPE *pSourceType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IpAddressSource( 
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_SOURCE_TYPE SourceType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartIpAddress( 
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszStartIpAddress) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartIpAddress( 
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [in] */ __RPC__in BSTR bszStartIpAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EndIpAddress( 
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszEndIpAddress) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EndIpAddress( 
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [in] */ __RPC__in BSTR bszEndIpAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartPort( 
            /* [retval][out] */ __RPC__out ULONG *pulStartPort) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartPort( 
            /* [in] */ ULONG ulStartPort) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EndPort( 
            /* [retval][out] */ __RPC__out ULONG *pulEndPort) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EndPort( 
            /* [in] */ ULONG ulEndPort) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkProfile( 
            /* [retval][out] */ __RPC__out WDSTRANSPORT_NETWORK_PROFILE_TYPE *pProfileType) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NetworkProfile( 
            /* [in] */ WDSTRANSPORT_NETWORK_PROFILE_TYPE ProfileType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportServicePolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportServicePolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportServicePolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportServicePolicy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dirty )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbDirty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Discard )( 
            __RPC__in IWdsTransportServicePolicy * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportServicePolicy * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWdsTransportServicePolicy * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IpAddressSource )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_IP_ADDRESS_SOURCE_TYPE *pSourceType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IpAddressSource )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_SOURCE_TYPE SourceType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartIpAddress )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszStartIpAddress);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartIpAddress )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [in] */ __RPC__in BSTR bszStartIpAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndIpAddress )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszEndIpAddress);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EndIpAddress )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ WDSTRANSPORT_IP_ADDRESS_TYPE AddressType,
            /* [in] */ __RPC__in BSTR bszEndIpAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartPort )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [retval][out] */ __RPC__out ULONG *pulStartPort);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartPort )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ ULONG ulStartPort);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndPort )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [retval][out] */ __RPC__out ULONG *pulEndPort);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EndPort )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ ULONG ulEndPort);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkProfile )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_NETWORK_PROFILE_TYPE *pProfileType);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NetworkProfile )( 
            __RPC__in IWdsTransportServicePolicy * This,
            /* [in] */ WDSTRANSPORT_NETWORK_PROFILE_TYPE ProfileType);
        
        END_INTERFACE
    } IWdsTransportServicePolicyVtbl;

    interface IWdsTransportServicePolicy
    {
        CONST_VTBL struct IWdsTransportServicePolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportServicePolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportServicePolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportServicePolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportServicePolicy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportServicePolicy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportServicePolicy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportServicePolicy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportServicePolicy_get_Dirty(This,pbDirty)	\
    ( (This)->lpVtbl -> get_Dirty(This,pbDirty) ) 

#define IWdsTransportServicePolicy_Discard(This)	\
    ( (This)->lpVtbl -> Discard(This) ) 

#define IWdsTransportServicePolicy_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportServicePolicy_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 


#define IWdsTransportServicePolicy_get_IpAddressSource(This,AddressType,pSourceType)	\
    ( (This)->lpVtbl -> get_IpAddressSource(This,AddressType,pSourceType) ) 

#define IWdsTransportServicePolicy_put_IpAddressSource(This,AddressType,SourceType)	\
    ( (This)->lpVtbl -> put_IpAddressSource(This,AddressType,SourceType) ) 

#define IWdsTransportServicePolicy_get_StartIpAddress(This,AddressType,pbszStartIpAddress)	\
    ( (This)->lpVtbl -> get_StartIpAddress(This,AddressType,pbszStartIpAddress) ) 

#define IWdsTransportServicePolicy_put_StartIpAddress(This,AddressType,bszStartIpAddress)	\
    ( (This)->lpVtbl -> put_StartIpAddress(This,AddressType,bszStartIpAddress) ) 

#define IWdsTransportServicePolicy_get_EndIpAddress(This,AddressType,pbszEndIpAddress)	\
    ( (This)->lpVtbl -> get_EndIpAddress(This,AddressType,pbszEndIpAddress) ) 

#define IWdsTransportServicePolicy_put_EndIpAddress(This,AddressType,bszEndIpAddress)	\
    ( (This)->lpVtbl -> put_EndIpAddress(This,AddressType,bszEndIpAddress) ) 

#define IWdsTransportServicePolicy_get_StartPort(This,pulStartPort)	\
    ( (This)->lpVtbl -> get_StartPort(This,pulStartPort) ) 

#define IWdsTransportServicePolicy_put_StartPort(This,ulStartPort)	\
    ( (This)->lpVtbl -> put_StartPort(This,ulStartPort) ) 

#define IWdsTransportServicePolicy_get_EndPort(This,pulEndPort)	\
    ( (This)->lpVtbl -> get_EndPort(This,pulEndPort) ) 

#define IWdsTransportServicePolicy_put_EndPort(This,ulEndPort)	\
    ( (This)->lpVtbl -> put_EndPort(This,ulEndPort) ) 

#define IWdsTransportServicePolicy_get_NetworkProfile(This,pProfileType)	\
    ( (This)->lpVtbl -> get_NetworkProfile(This,pProfileType) ) 

#define IWdsTransportServicePolicy_put_NetworkProfile(This,ProfileType)	\
    ( (This)->lpVtbl -> put_NetworkProfile(This,ProfileType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportServicePolicy_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportDiagnosticsPolicy_INTERFACE_DEFINED__
#define __IWdsTransportDiagnosticsPolicy_INTERFACE_DEFINED__

/* interface IWdsTransportDiagnosticsPolicy */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportDiagnosticsPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13B33EFC-7856-4F61-9A59-8DE67B6B87B6")
    IWdsTransportDiagnosticsPolicy : public IWdsTransportCacheable
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Components( 
            /* [retval][out] */ __RPC__out ULONG *pulComponents) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Components( 
            /* [in] */ ULONG ulComponents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportDiagnosticsPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportDiagnosticsPolicy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dirty )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbDirty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Discard )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Components )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [retval][out] */ __RPC__out ULONG *pulComponents);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Components )( 
            __RPC__in IWdsTransportDiagnosticsPolicy * This,
            /* [in] */ ULONG ulComponents);
        
        END_INTERFACE
    } IWdsTransportDiagnosticsPolicyVtbl;

    interface IWdsTransportDiagnosticsPolicy
    {
        CONST_VTBL struct IWdsTransportDiagnosticsPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportDiagnosticsPolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportDiagnosticsPolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportDiagnosticsPolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportDiagnosticsPolicy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportDiagnosticsPolicy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportDiagnosticsPolicy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportDiagnosticsPolicy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportDiagnosticsPolicy_get_Dirty(This,pbDirty)	\
    ( (This)->lpVtbl -> get_Dirty(This,pbDirty) ) 

#define IWdsTransportDiagnosticsPolicy_Discard(This)	\
    ( (This)->lpVtbl -> Discard(This) ) 

#define IWdsTransportDiagnosticsPolicy_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportDiagnosticsPolicy_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 


#define IWdsTransportDiagnosticsPolicy_get_Enabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pbEnabled) ) 

#define IWdsTransportDiagnosticsPolicy_put_Enabled(This,bEnabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,bEnabled) ) 

#define IWdsTransportDiagnosticsPolicy_get_Components(This,pulComponents)	\
    ( (This)->lpVtbl -> get_Components(This,pulComponents) ) 

#define IWdsTransportDiagnosticsPolicy_put_Components(This,ulComponents)	\
    ( (This)->lpVtbl -> put_Components(This,ulComponents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportDiagnosticsPolicy_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportMulticastSessionPolicy_INTERFACE_DEFINED__
#define __IWdsTransportMulticastSessionPolicy_INTERFACE_DEFINED__

/* interface IWdsTransportMulticastSessionPolicy */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportMulticastSessionPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E5753CF-68EC-4504-A951-4A003266606B")
    IWdsTransportMulticastSessionPolicy : public IWdsTransportCacheable
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SlowClientHandling( 
            /* [retval][out] */ __RPC__out WDSTRANSPORT_SLOW_CLIENT_HANDLING_TYPE *pSlowClientHandling) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SlowClientHandling( 
            /* [in] */ WDSTRANSPORT_SLOW_CLIENT_HANDLING_TYPE SlowClientHandling) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoDisconnectThreshold( 
            /* [retval][out] */ __RPC__out ULONG *pulThreshold) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoDisconnectThreshold( 
            /* [in] */ ULONG ulThreshold) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MultistreamStreamCount( 
            /* [retval][out] */ __RPC__out ULONG *pulStreamCount) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MultistreamStreamCount( 
            /* [in] */ ULONG ulStreamCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SlowClientFallback( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbClientFallback) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SlowClientFallback( 
            /* [in] */ VARIANT_BOOL bClientFallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportMulticastSessionPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportMulticastSessionPolicy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dirty )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbDirty);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Discard )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SlowClientHandling )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_SLOW_CLIENT_HANDLING_TYPE *pSlowClientHandling);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SlowClientHandling )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [in] */ WDSTRANSPORT_SLOW_CLIENT_HANDLING_TYPE SlowClientHandling);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoDisconnectThreshold )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [retval][out] */ __RPC__out ULONG *pulThreshold);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoDisconnectThreshold )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [in] */ ULONG ulThreshold);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MultistreamStreamCount )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [retval][out] */ __RPC__out ULONG *pulStreamCount);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MultistreamStreamCount )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [in] */ ULONG ulStreamCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SlowClientFallback )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbClientFallback);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SlowClientFallback )( 
            __RPC__in IWdsTransportMulticastSessionPolicy * This,
            /* [in] */ VARIANT_BOOL bClientFallback);
        
        END_INTERFACE
    } IWdsTransportMulticastSessionPolicyVtbl;

    interface IWdsTransportMulticastSessionPolicy
    {
        CONST_VTBL struct IWdsTransportMulticastSessionPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportMulticastSessionPolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportMulticastSessionPolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportMulticastSessionPolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportMulticastSessionPolicy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportMulticastSessionPolicy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportMulticastSessionPolicy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportMulticastSessionPolicy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportMulticastSessionPolicy_get_Dirty(This,pbDirty)	\
    ( (This)->lpVtbl -> get_Dirty(This,pbDirty) ) 

#define IWdsTransportMulticastSessionPolicy_Discard(This)	\
    ( (This)->lpVtbl -> Discard(This) ) 

#define IWdsTransportMulticastSessionPolicy_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportMulticastSessionPolicy_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 


#define IWdsTransportMulticastSessionPolicy_get_SlowClientHandling(This,pSlowClientHandling)	\
    ( (This)->lpVtbl -> get_SlowClientHandling(This,pSlowClientHandling) ) 

#define IWdsTransportMulticastSessionPolicy_put_SlowClientHandling(This,SlowClientHandling)	\
    ( (This)->lpVtbl -> put_SlowClientHandling(This,SlowClientHandling) ) 

#define IWdsTransportMulticastSessionPolicy_get_AutoDisconnectThreshold(This,pulThreshold)	\
    ( (This)->lpVtbl -> get_AutoDisconnectThreshold(This,pulThreshold) ) 

#define IWdsTransportMulticastSessionPolicy_put_AutoDisconnectThreshold(This,ulThreshold)	\
    ( (This)->lpVtbl -> put_AutoDisconnectThreshold(This,ulThreshold) ) 

#define IWdsTransportMulticastSessionPolicy_get_MultistreamStreamCount(This,pulStreamCount)	\
    ( (This)->lpVtbl -> get_MultistreamStreamCount(This,pulStreamCount) ) 

#define IWdsTransportMulticastSessionPolicy_put_MultistreamStreamCount(This,ulStreamCount)	\
    ( (This)->lpVtbl -> put_MultistreamStreamCount(This,ulStreamCount) ) 

#define IWdsTransportMulticastSessionPolicy_get_SlowClientFallback(This,pbClientFallback)	\
    ( (This)->lpVtbl -> get_SlowClientFallback(This,pbClientFallback) ) 

#define IWdsTransportMulticastSessionPolicy_put_SlowClientFallback(This,bClientFallback)	\
    ( (This)->lpVtbl -> put_SlowClientFallback(This,bClientFallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportMulticastSessionPolicy_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportNamespace_INTERFACE_DEFINED__
#define __IWdsTransportNamespace_INTERFACE_DEFINED__

/* interface IWdsTransportNamespace */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportNamespace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA561F57-FBEF-4ED3-B056-127CB1B33B84")
    IWdsTransportNamespace : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out WDSTRANSPORT_NAMESPACE_TYPE *pType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out ULONG *pulId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR bszName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszFriendlyName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FriendlyName( 
            /* [in] */ __RPC__in BSTR bszFriendlyName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR bszDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ContentProvider( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszContentProvider) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ContentProvider( 
            /* [in] */ __RPC__in BSTR bszContentProvider) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Configuration( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszConfiguration) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Configuration( 
            /* [in] */ __RPC__in BSTR bszConfiguration) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Registered( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRegistered) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tombstoned( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTombstoned) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TombstoneTime( 
            /* [retval][out] */ __RPC__out DATE *pTombstoneTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransmissionStarted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTransmissionStarted) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Register( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Deregister( 
            /* [in] */ VARIANT_BOOL bTerminateSessions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespaceClone) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetrieveContents( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportContents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportNamespaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportNamespace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportNamespace * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportNamespace * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_NAMESPACE_TYPE *pType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__out ULONG *pulId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ __RPC__in BSTR bszName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszFriendlyName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ __RPC__in BSTR bszFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ __RPC__in BSTR bszDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentProvider )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszContentProvider);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContentProvider )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ __RPC__in BSTR bszContentProvider);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Configuration )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszConfiguration);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Configuration )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ __RPC__in BSTR bszConfiguration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Registered )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRegistered);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tombstoned )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTombstoned);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TombstoneTime )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__out DATE *pTombstoneTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStarted )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTransmissionStarted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Register )( 
            __RPC__in IWdsTransportNamespace * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Deregister )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [in] */ VARIANT_BOOL bTerminateSessions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespaceClone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportNamespace * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveContents )( 
            __RPC__in IWdsTransportNamespace * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportContents);
        
        END_INTERFACE
    } IWdsTransportNamespaceVtbl;

    interface IWdsTransportNamespace
    {
        CONST_VTBL struct IWdsTransportNamespaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportNamespace_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportNamespace_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportNamespace_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportNamespace_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportNamespace_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportNamespace_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportNamespace_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportNamespace_get_Type(This,pType)	\
    ( (This)->lpVtbl -> get_Type(This,pType) ) 

#define IWdsTransportNamespace_get_Id(This,pulId)	\
    ( (This)->lpVtbl -> get_Id(This,pulId) ) 

#define IWdsTransportNamespace_get_Name(This,pbszName)	\
    ( (This)->lpVtbl -> get_Name(This,pbszName) ) 

#define IWdsTransportNamespace_put_Name(This,bszName)	\
    ( (This)->lpVtbl -> put_Name(This,bszName) ) 

#define IWdsTransportNamespace_get_FriendlyName(This,pbszFriendlyName)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pbszFriendlyName) ) 

#define IWdsTransportNamespace_put_FriendlyName(This,bszFriendlyName)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,bszFriendlyName) ) 

#define IWdsTransportNamespace_get_Description(This,pbszDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbszDescription) ) 

#define IWdsTransportNamespace_put_Description(This,bszDescription)	\
    ( (This)->lpVtbl -> put_Description(This,bszDescription) ) 

#define IWdsTransportNamespace_get_ContentProvider(This,pbszContentProvider)	\
    ( (This)->lpVtbl -> get_ContentProvider(This,pbszContentProvider) ) 

#define IWdsTransportNamespace_put_ContentProvider(This,bszContentProvider)	\
    ( (This)->lpVtbl -> put_ContentProvider(This,bszContentProvider) ) 

#define IWdsTransportNamespace_get_Configuration(This,pbszConfiguration)	\
    ( (This)->lpVtbl -> get_Configuration(This,pbszConfiguration) ) 

#define IWdsTransportNamespace_put_Configuration(This,bszConfiguration)	\
    ( (This)->lpVtbl -> put_Configuration(This,bszConfiguration) ) 

#define IWdsTransportNamespace_get_Registered(This,pbRegistered)	\
    ( (This)->lpVtbl -> get_Registered(This,pbRegistered) ) 

#define IWdsTransportNamespace_get_Tombstoned(This,pbTombstoned)	\
    ( (This)->lpVtbl -> get_Tombstoned(This,pbTombstoned) ) 

#define IWdsTransportNamespace_get_TombstoneTime(This,pTombstoneTime)	\
    ( (This)->lpVtbl -> get_TombstoneTime(This,pTombstoneTime) ) 

#define IWdsTransportNamespace_get_TransmissionStarted(This,pbTransmissionStarted)	\
    ( (This)->lpVtbl -> get_TransmissionStarted(This,pbTransmissionStarted) ) 

#define IWdsTransportNamespace_Register(This)	\
    ( (This)->lpVtbl -> Register(This) ) 

#define IWdsTransportNamespace_Deregister(This,bTerminateSessions)	\
    ( (This)->lpVtbl -> Deregister(This,bTerminateSessions) ) 

#define IWdsTransportNamespace_Clone(This,ppWdsTransportNamespaceClone)	\
    ( (This)->lpVtbl -> Clone(This,ppWdsTransportNamespaceClone) ) 

#define IWdsTransportNamespace_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportNamespace_RetrieveContents(This,ppWdsTransportContents)	\
    ( (This)->lpVtbl -> RetrieveContents(This,ppWdsTransportContents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportNamespace_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportNamespaceAutoCast_INTERFACE_DEFINED__
#define __IWdsTransportNamespaceAutoCast_INTERFACE_DEFINED__

/* interface IWdsTransportNamespaceAutoCast */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportNamespaceAutoCast;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD931A72-C4BD-4C41-8FBC-59C9C748DF9E")
    IWdsTransportNamespaceAutoCast : public IWdsTransportNamespace
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportNamespaceAutoCastVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportNamespaceAutoCast * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_NAMESPACE_TYPE *pType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__out ULONG *pulId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ __RPC__in BSTR bszName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszFriendlyName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ __RPC__in BSTR bszFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ __RPC__in BSTR bszDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentProvider )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszContentProvider);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContentProvider )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ __RPC__in BSTR bszContentProvider);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Configuration )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszConfiguration);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Configuration )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ __RPC__in BSTR bszConfiguration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Registered )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRegistered);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tombstoned )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTombstoned);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TombstoneTime )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__out DATE *pTombstoneTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStarted )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTransmissionStarted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Register )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Deregister )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [in] */ VARIANT_BOOL bTerminateSessions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespaceClone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveContents )( 
            __RPC__in IWdsTransportNamespaceAutoCast * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportContents);
        
        END_INTERFACE
    } IWdsTransportNamespaceAutoCastVtbl;

    interface IWdsTransportNamespaceAutoCast
    {
        CONST_VTBL struct IWdsTransportNamespaceAutoCastVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportNamespaceAutoCast_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportNamespaceAutoCast_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportNamespaceAutoCast_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportNamespaceAutoCast_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportNamespaceAutoCast_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportNamespaceAutoCast_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportNamespaceAutoCast_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportNamespaceAutoCast_get_Type(This,pType)	\
    ( (This)->lpVtbl -> get_Type(This,pType) ) 

#define IWdsTransportNamespaceAutoCast_get_Id(This,pulId)	\
    ( (This)->lpVtbl -> get_Id(This,pulId) ) 

#define IWdsTransportNamespaceAutoCast_get_Name(This,pbszName)	\
    ( (This)->lpVtbl -> get_Name(This,pbszName) ) 

#define IWdsTransportNamespaceAutoCast_put_Name(This,bszName)	\
    ( (This)->lpVtbl -> put_Name(This,bszName) ) 

#define IWdsTransportNamespaceAutoCast_get_FriendlyName(This,pbszFriendlyName)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pbszFriendlyName) ) 

#define IWdsTransportNamespaceAutoCast_put_FriendlyName(This,bszFriendlyName)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,bszFriendlyName) ) 

#define IWdsTransportNamespaceAutoCast_get_Description(This,pbszDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbszDescription) ) 

#define IWdsTransportNamespaceAutoCast_put_Description(This,bszDescription)	\
    ( (This)->lpVtbl -> put_Description(This,bszDescription) ) 

#define IWdsTransportNamespaceAutoCast_get_ContentProvider(This,pbszContentProvider)	\
    ( (This)->lpVtbl -> get_ContentProvider(This,pbszContentProvider) ) 

#define IWdsTransportNamespaceAutoCast_put_ContentProvider(This,bszContentProvider)	\
    ( (This)->lpVtbl -> put_ContentProvider(This,bszContentProvider) ) 

#define IWdsTransportNamespaceAutoCast_get_Configuration(This,pbszConfiguration)	\
    ( (This)->lpVtbl -> get_Configuration(This,pbszConfiguration) ) 

#define IWdsTransportNamespaceAutoCast_put_Configuration(This,bszConfiguration)	\
    ( (This)->lpVtbl -> put_Configuration(This,bszConfiguration) ) 

#define IWdsTransportNamespaceAutoCast_get_Registered(This,pbRegistered)	\
    ( (This)->lpVtbl -> get_Registered(This,pbRegistered) ) 

#define IWdsTransportNamespaceAutoCast_get_Tombstoned(This,pbTombstoned)	\
    ( (This)->lpVtbl -> get_Tombstoned(This,pbTombstoned) ) 

#define IWdsTransportNamespaceAutoCast_get_TombstoneTime(This,pTombstoneTime)	\
    ( (This)->lpVtbl -> get_TombstoneTime(This,pTombstoneTime) ) 

#define IWdsTransportNamespaceAutoCast_get_TransmissionStarted(This,pbTransmissionStarted)	\
    ( (This)->lpVtbl -> get_TransmissionStarted(This,pbTransmissionStarted) ) 

#define IWdsTransportNamespaceAutoCast_Register(This)	\
    ( (This)->lpVtbl -> Register(This) ) 

#define IWdsTransportNamespaceAutoCast_Deregister(This,bTerminateSessions)	\
    ( (This)->lpVtbl -> Deregister(This,bTerminateSessions) ) 

#define IWdsTransportNamespaceAutoCast_Clone(This,ppWdsTransportNamespaceClone)	\
    ( (This)->lpVtbl -> Clone(This,ppWdsTransportNamespaceClone) ) 

#define IWdsTransportNamespaceAutoCast_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportNamespaceAutoCast_RetrieveContents(This,ppWdsTransportContents)	\
    ( (This)->lpVtbl -> RetrieveContents(This,ppWdsTransportContents) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportNamespaceAutoCast_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportNamespaceScheduledCast_INTERFACE_DEFINED__
#define __IWdsTransportNamespaceScheduledCast_INTERFACE_DEFINED__

/* interface IWdsTransportNamespaceScheduledCast */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportNamespaceScheduledCast;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3840CECF-D76C-416E-A4CC-31C741D2874B")
    IWdsTransportNamespaceScheduledCast : public IWdsTransportNamespace
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartTransmission( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportNamespaceScheduledCastVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_NAMESPACE_TYPE *pType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__out ULONG *pulId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ __RPC__in BSTR bszName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszFriendlyName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ __RPC__in BSTR bszFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ __RPC__in BSTR bszDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentProvider )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszContentProvider);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContentProvider )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ __RPC__in BSTR bszContentProvider);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Configuration )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszConfiguration);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Configuration )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ __RPC__in BSTR bszConfiguration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Registered )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRegistered);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tombstoned )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTombstoned);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TombstoneTime )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__out DATE *pTombstoneTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStarted )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTransmissionStarted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Register )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Deregister )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [in] */ VARIANT_BOOL bTerminateSessions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespaceClone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveContents )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportContents);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartTransmission )( 
            __RPC__in IWdsTransportNamespaceScheduledCast * This);
        
        END_INTERFACE
    } IWdsTransportNamespaceScheduledCastVtbl;

    interface IWdsTransportNamespaceScheduledCast
    {
        CONST_VTBL struct IWdsTransportNamespaceScheduledCastVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportNamespaceScheduledCast_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportNamespaceScheduledCast_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportNamespaceScheduledCast_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportNamespaceScheduledCast_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportNamespaceScheduledCast_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportNamespaceScheduledCast_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportNamespaceScheduledCast_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportNamespaceScheduledCast_get_Type(This,pType)	\
    ( (This)->lpVtbl -> get_Type(This,pType) ) 

#define IWdsTransportNamespaceScheduledCast_get_Id(This,pulId)	\
    ( (This)->lpVtbl -> get_Id(This,pulId) ) 

#define IWdsTransportNamespaceScheduledCast_get_Name(This,pbszName)	\
    ( (This)->lpVtbl -> get_Name(This,pbszName) ) 

#define IWdsTransportNamespaceScheduledCast_put_Name(This,bszName)	\
    ( (This)->lpVtbl -> put_Name(This,bszName) ) 

#define IWdsTransportNamespaceScheduledCast_get_FriendlyName(This,pbszFriendlyName)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pbszFriendlyName) ) 

#define IWdsTransportNamespaceScheduledCast_put_FriendlyName(This,bszFriendlyName)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,bszFriendlyName) ) 

#define IWdsTransportNamespaceScheduledCast_get_Description(This,pbszDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbszDescription) ) 

#define IWdsTransportNamespaceScheduledCast_put_Description(This,bszDescription)	\
    ( (This)->lpVtbl -> put_Description(This,bszDescription) ) 

#define IWdsTransportNamespaceScheduledCast_get_ContentProvider(This,pbszContentProvider)	\
    ( (This)->lpVtbl -> get_ContentProvider(This,pbszContentProvider) ) 

#define IWdsTransportNamespaceScheduledCast_put_ContentProvider(This,bszContentProvider)	\
    ( (This)->lpVtbl -> put_ContentProvider(This,bszContentProvider) ) 

#define IWdsTransportNamespaceScheduledCast_get_Configuration(This,pbszConfiguration)	\
    ( (This)->lpVtbl -> get_Configuration(This,pbszConfiguration) ) 

#define IWdsTransportNamespaceScheduledCast_put_Configuration(This,bszConfiguration)	\
    ( (This)->lpVtbl -> put_Configuration(This,bszConfiguration) ) 

#define IWdsTransportNamespaceScheduledCast_get_Registered(This,pbRegistered)	\
    ( (This)->lpVtbl -> get_Registered(This,pbRegistered) ) 

#define IWdsTransportNamespaceScheduledCast_get_Tombstoned(This,pbTombstoned)	\
    ( (This)->lpVtbl -> get_Tombstoned(This,pbTombstoned) ) 

#define IWdsTransportNamespaceScheduledCast_get_TombstoneTime(This,pTombstoneTime)	\
    ( (This)->lpVtbl -> get_TombstoneTime(This,pTombstoneTime) ) 

#define IWdsTransportNamespaceScheduledCast_get_TransmissionStarted(This,pbTransmissionStarted)	\
    ( (This)->lpVtbl -> get_TransmissionStarted(This,pbTransmissionStarted) ) 

#define IWdsTransportNamespaceScheduledCast_Register(This)	\
    ( (This)->lpVtbl -> Register(This) ) 

#define IWdsTransportNamespaceScheduledCast_Deregister(This,bTerminateSessions)	\
    ( (This)->lpVtbl -> Deregister(This,bTerminateSessions) ) 

#define IWdsTransportNamespaceScheduledCast_Clone(This,ppWdsTransportNamespaceClone)	\
    ( (This)->lpVtbl -> Clone(This,ppWdsTransportNamespaceClone) ) 

#define IWdsTransportNamespaceScheduledCast_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportNamespaceScheduledCast_RetrieveContents(This,ppWdsTransportContents)	\
    ( (This)->lpVtbl -> RetrieveContents(This,ppWdsTransportContents) ) 


#define IWdsTransportNamespaceScheduledCast_StartTransmission(This)	\
    ( (This)->lpVtbl -> StartTransmission(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportNamespaceScheduledCast_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportNamespaceScheduledCastManualStart_INTERFACE_DEFINED__
#define __IWdsTransportNamespaceScheduledCastManualStart_INTERFACE_DEFINED__

/* interface IWdsTransportNamespaceScheduledCastManualStart */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportNamespaceScheduledCastManualStart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("013E6E4C-E6A7-4FB5-B7FF-D9F5DA805C31")
    IWdsTransportNamespaceScheduledCastManualStart : public IWdsTransportNamespaceScheduledCast
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportNamespaceScheduledCastManualStartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_NAMESPACE_TYPE *pType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__out ULONG *pulId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ __RPC__in BSTR bszName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszFriendlyName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ __RPC__in BSTR bszFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ __RPC__in BSTR bszDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentProvider )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszContentProvider);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContentProvider )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ __RPC__in BSTR bszContentProvider);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Configuration )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszConfiguration);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Configuration )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ __RPC__in BSTR bszConfiguration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Registered )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRegistered);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tombstoned )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTombstoned);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TombstoneTime )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__out DATE *pTombstoneTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStarted )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTransmissionStarted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Register )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Deregister )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [in] */ VARIANT_BOOL bTerminateSessions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespaceClone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveContents )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportContents);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartTransmission )( 
            __RPC__in IWdsTransportNamespaceScheduledCastManualStart * This);
        
        END_INTERFACE
    } IWdsTransportNamespaceScheduledCastManualStartVtbl;

    interface IWdsTransportNamespaceScheduledCastManualStart
    {
        CONST_VTBL struct IWdsTransportNamespaceScheduledCastManualStartVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportNamespaceScheduledCastManualStart_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportNamespaceScheduledCastManualStart_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportNamespaceScheduledCastManualStart_get_Type(This,pType)	\
    ( (This)->lpVtbl -> get_Type(This,pType) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_Id(This,pulId)	\
    ( (This)->lpVtbl -> get_Id(This,pulId) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_Name(This,pbszName)	\
    ( (This)->lpVtbl -> get_Name(This,pbszName) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_put_Name(This,bszName)	\
    ( (This)->lpVtbl -> put_Name(This,bszName) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_FriendlyName(This,pbszFriendlyName)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pbszFriendlyName) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_put_FriendlyName(This,bszFriendlyName)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,bszFriendlyName) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_Description(This,pbszDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbszDescription) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_put_Description(This,bszDescription)	\
    ( (This)->lpVtbl -> put_Description(This,bszDescription) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_ContentProvider(This,pbszContentProvider)	\
    ( (This)->lpVtbl -> get_ContentProvider(This,pbszContentProvider) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_put_ContentProvider(This,bszContentProvider)	\
    ( (This)->lpVtbl -> put_ContentProvider(This,bszContentProvider) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_Configuration(This,pbszConfiguration)	\
    ( (This)->lpVtbl -> get_Configuration(This,pbszConfiguration) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_put_Configuration(This,bszConfiguration)	\
    ( (This)->lpVtbl -> put_Configuration(This,bszConfiguration) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_Registered(This,pbRegistered)	\
    ( (This)->lpVtbl -> get_Registered(This,pbRegistered) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_Tombstoned(This,pbTombstoned)	\
    ( (This)->lpVtbl -> get_Tombstoned(This,pbTombstoned) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_TombstoneTime(This,pTombstoneTime)	\
    ( (This)->lpVtbl -> get_TombstoneTime(This,pTombstoneTime) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_get_TransmissionStarted(This,pbTransmissionStarted)	\
    ( (This)->lpVtbl -> get_TransmissionStarted(This,pbTransmissionStarted) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_Register(This)	\
    ( (This)->lpVtbl -> Register(This) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_Deregister(This,bTerminateSessions)	\
    ( (This)->lpVtbl -> Deregister(This,bTerminateSessions) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_Clone(This,ppWdsTransportNamespaceClone)	\
    ( (This)->lpVtbl -> Clone(This,ppWdsTransportNamespaceClone) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportNamespaceScheduledCastManualStart_RetrieveContents(This,ppWdsTransportContents)	\
    ( (This)->lpVtbl -> RetrieveContents(This,ppWdsTransportContents) ) 


#define IWdsTransportNamespaceScheduledCastManualStart_StartTransmission(This)	\
    ( (This)->lpVtbl -> StartTransmission(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportNamespaceScheduledCastManualStart_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportNamespaceScheduledCastAutoStart_INTERFACE_DEFINED__
#define __IWdsTransportNamespaceScheduledCastAutoStart_INTERFACE_DEFINED__

/* interface IWdsTransportNamespaceScheduledCastAutoStart */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportNamespaceScheduledCastAutoStart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D606AF3D-EA9C-4219-961E-7491D618D9B9")
    IWdsTransportNamespaceScheduledCastAutoStart : public IWdsTransportNamespaceScheduledCast
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinimumClients( 
            /* [retval][out] */ __RPC__out ULONG *pulMinimumClients) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MinimumClients( 
            /* [in] */ ULONG ulMinimumClients) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ __RPC__out DATE *pStartTime) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE StartTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportNamespaceScheduledCastAutoStartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__out WDSTRANSPORT_NAMESPACE_TYPE *pType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__out ULONG *pulId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ __RPC__in BSTR bszName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszFriendlyName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ __RPC__in BSTR bszFriendlyName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ __RPC__in BSTR bszDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentProvider )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszContentProvider);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ContentProvider )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ __RPC__in BSTR bszContentProvider);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Configuration )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszConfiguration);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Configuration )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ __RPC__in BSTR bszConfiguration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Registered )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbRegistered);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tombstoned )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTombstoned);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TombstoneTime )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__out DATE *pTombstoneTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransmissionStarted )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbTransmissionStarted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Register )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Deregister )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ VARIANT_BOOL bTerminateSessions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespaceClone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveContents )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportContents);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartTransmission )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumClients )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__out ULONG *pulMinimumClients);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumClients )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ ULONG ulMinimumClients);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [retval][out] */ __RPC__out DATE *pStartTime);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            __RPC__in IWdsTransportNamespaceScheduledCastAutoStart * This,
            /* [in] */ DATE StartTime);
        
        END_INTERFACE
    } IWdsTransportNamespaceScheduledCastAutoStartVtbl;

    interface IWdsTransportNamespaceScheduledCastAutoStart
    {
        CONST_VTBL struct IWdsTransportNamespaceScheduledCastAutoStartVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportNamespaceScheduledCastAutoStart_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportNamespaceScheduledCastAutoStart_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportNamespaceScheduledCastAutoStart_get_Type(This,pType)	\
    ( (This)->lpVtbl -> get_Type(This,pType) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_Id(This,pulId)	\
    ( (This)->lpVtbl -> get_Id(This,pulId) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_Name(This,pbszName)	\
    ( (This)->lpVtbl -> get_Name(This,pbszName) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_put_Name(This,bszName)	\
    ( (This)->lpVtbl -> put_Name(This,bszName) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_FriendlyName(This,pbszFriendlyName)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pbszFriendlyName) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_put_FriendlyName(This,bszFriendlyName)	\
    ( (This)->lpVtbl -> put_FriendlyName(This,bszFriendlyName) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_Description(This,pbszDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbszDescription) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_put_Description(This,bszDescription)	\
    ( (This)->lpVtbl -> put_Description(This,bszDescription) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_ContentProvider(This,pbszContentProvider)	\
    ( (This)->lpVtbl -> get_ContentProvider(This,pbszContentProvider) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_put_ContentProvider(This,bszContentProvider)	\
    ( (This)->lpVtbl -> put_ContentProvider(This,bszContentProvider) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_Configuration(This,pbszConfiguration)	\
    ( (This)->lpVtbl -> get_Configuration(This,pbszConfiguration) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_put_Configuration(This,bszConfiguration)	\
    ( (This)->lpVtbl -> put_Configuration(This,bszConfiguration) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_Registered(This,pbRegistered)	\
    ( (This)->lpVtbl -> get_Registered(This,pbRegistered) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_Tombstoned(This,pbTombstoned)	\
    ( (This)->lpVtbl -> get_Tombstoned(This,pbTombstoned) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_TombstoneTime(This,pTombstoneTime)	\
    ( (This)->lpVtbl -> get_TombstoneTime(This,pTombstoneTime) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_TransmissionStarted(This,pbTransmissionStarted)	\
    ( (This)->lpVtbl -> get_TransmissionStarted(This,pbTransmissionStarted) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_Register(This)	\
    ( (This)->lpVtbl -> Register(This) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_Deregister(This,bTerminateSessions)	\
    ( (This)->lpVtbl -> Deregister(This,bTerminateSessions) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_Clone(This,ppWdsTransportNamespaceClone)	\
    ( (This)->lpVtbl -> Clone(This,ppWdsTransportNamespaceClone) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_RetrieveContents(This,ppWdsTransportContents)	\
    ( (This)->lpVtbl -> RetrieveContents(This,ppWdsTransportContents) ) 


#define IWdsTransportNamespaceScheduledCastAutoStart_StartTransmission(This)	\
    ( (This)->lpVtbl -> StartTransmission(This) ) 


#define IWdsTransportNamespaceScheduledCastAutoStart_get_MinimumClients(This,pulMinimumClients)	\
    ( (This)->lpVtbl -> get_MinimumClients(This,pulMinimumClients) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_put_MinimumClients(This,ulMinimumClients)	\
    ( (This)->lpVtbl -> put_MinimumClients(This,ulMinimumClients) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_get_StartTime(This,pStartTime)	\
    ( (This)->lpVtbl -> get_StartTime(This,pStartTime) ) 

#define IWdsTransportNamespaceScheduledCastAutoStart_put_StartTime(This,StartTime)	\
    ( (This)->lpVtbl -> put_StartTime(This,StartTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportNamespaceScheduledCastAutoStart_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportContent_INTERFACE_DEFINED__
#define __IWdsTransportContent_INTERFACE_DEFINED__

/* interface IWdsTransportContent */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportContent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D405D711-0296-4AB4-A860-AC7D32E65798")
    IWdsTransportContent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Namespace( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespace) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out ULONG *pulId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetrieveSessions( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportSessions) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportContentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportContent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportContent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportContent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportContent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportContent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportContent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportContent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Namespace )( 
            __RPC__in IWdsTransportContent * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportNamespace **ppWdsTransportNamespace);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IWdsTransportContent * This,
            /* [retval][out] */ __RPC__out ULONG *pulId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IWdsTransportContent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveSessions )( 
            __RPC__in IWdsTransportContent * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportSessions);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            __RPC__in IWdsTransportContent * This);
        
        END_INTERFACE
    } IWdsTransportContentVtbl;

    interface IWdsTransportContent
    {
        CONST_VTBL struct IWdsTransportContentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportContent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportContent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportContent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportContent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportContent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportContent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportContent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportContent_get_Namespace(This,ppWdsTransportNamespace)	\
    ( (This)->lpVtbl -> get_Namespace(This,ppWdsTransportNamespace) ) 

#define IWdsTransportContent_get_Id(This,pulId)	\
    ( (This)->lpVtbl -> get_Id(This,pulId) ) 

#define IWdsTransportContent_get_Name(This,pbszName)	\
    ( (This)->lpVtbl -> get_Name(This,pbszName) ) 

#define IWdsTransportContent_RetrieveSessions(This,ppWdsTransportSessions)	\
    ( (This)->lpVtbl -> RetrieveSessions(This,ppWdsTransportSessions) ) 

#define IWdsTransportContent_Terminate(This)	\
    ( (This)->lpVtbl -> Terminate(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportContent_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportSession_INTERFACE_DEFINED__
#define __IWdsTransportSession_INTERFACE_DEFINED__

/* interface IWdsTransportSession */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4EFEA88-65B1-4F30-A4B9-2793987796FB")
    IWdsTransportSession : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Content( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportContent **ppWdsTransportContent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out ULONG *pulId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkInterfaceName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszNetworkInterfaceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkInterfaceAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszNetworkInterfaceAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TransferRate( 
            /* [retval][out] */ __RPC__out ULONG *pulTransferRate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MasterClientId( 
            /* [retval][out] */ __RPC__out ULONG *pulMasterClientId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetrieveClients( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportClients) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportSession * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Content )( 
            __RPC__in IWdsTransportSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportContent **ppWdsTransportContent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IWdsTransportSession * This,
            /* [retval][out] */ __RPC__out ULONG *pulId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkInterfaceName )( 
            __RPC__in IWdsTransportSession * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszNetworkInterfaceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkInterfaceAddress )( 
            __RPC__in IWdsTransportSession * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszNetworkInterfaceAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TransferRate )( 
            __RPC__in IWdsTransportSession * This,
            /* [retval][out] */ __RPC__out ULONG *pulTransferRate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MasterClientId )( 
            __RPC__in IWdsTransportSession * This,
            /* [retval][out] */ __RPC__out ULONG *pulMasterClientId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveClients )( 
            __RPC__in IWdsTransportSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportCollection **ppWdsTransportClients);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            __RPC__in IWdsTransportSession * This);
        
        END_INTERFACE
    } IWdsTransportSessionVtbl;

    interface IWdsTransportSession
    {
        CONST_VTBL struct IWdsTransportSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportSession_get_Content(This,ppWdsTransportContent)	\
    ( (This)->lpVtbl -> get_Content(This,ppWdsTransportContent) ) 

#define IWdsTransportSession_get_Id(This,pulId)	\
    ( (This)->lpVtbl -> get_Id(This,pulId) ) 

#define IWdsTransportSession_get_NetworkInterfaceName(This,pbszNetworkInterfaceName)	\
    ( (This)->lpVtbl -> get_NetworkInterfaceName(This,pbszNetworkInterfaceName) ) 

#define IWdsTransportSession_get_NetworkInterfaceAddress(This,pbszNetworkInterfaceAddress)	\
    ( (This)->lpVtbl -> get_NetworkInterfaceAddress(This,pbszNetworkInterfaceAddress) ) 

#define IWdsTransportSession_get_TransferRate(This,pulTransferRate)	\
    ( (This)->lpVtbl -> get_TransferRate(This,pulTransferRate) ) 

#define IWdsTransportSession_get_MasterClientId(This,pulMasterClientId)	\
    ( (This)->lpVtbl -> get_MasterClientId(This,pulMasterClientId) ) 

#define IWdsTransportSession_RetrieveClients(This,ppWdsTransportClients)	\
    ( (This)->lpVtbl -> RetrieveClients(This,ppWdsTransportClients) ) 

#define IWdsTransportSession_Terminate(This)	\
    ( (This)->lpVtbl -> Terminate(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportSession_INTERFACE_DEFINED__ */


#ifndef __IWdsTransportClient_INTERFACE_DEFINED__
#define __IWdsTransportClient_INTERFACE_DEFINED__

/* interface IWdsTransportClient */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWdsTransportClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B5DBC93A-CABE-46CA-837F-3E44E93C6545")
    IWdsTransportClient : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportSession **ppWdsTransportSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out ULONG *pulId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MacAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszMacAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IpAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszIpAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PercentCompletion( 
            /* [retval][out] */ __RPC__out ULONG *pulPercentCompletion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_JoinDuration( 
            /* [retval][out] */ __RPC__out ULONG *pulJoinDuration) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CpuUtilization( 
            /* [retval][out] */ __RPC__out ULONG *pulCpuUtilization) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemoryUtilization( 
            /* [retval][out] */ __RPC__out ULONG *pulMemoryUtilization) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkUtilization( 
            /* [retval][out] */ __RPC__out ULONG *pulNetworkUtilization) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserIdentity( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszUserIdentity) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ WDSTRANSPORT_DISCONNECT_TYPE DisconnectionType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWdsTransportClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWdsTransportClient * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWdsTransportClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWdsTransportClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWdsTransportClient * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWdsTransportClient * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWdsTransportClient * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWdsTransportClient * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__deref_out_opt IWdsTransportSession **ppWdsTransportSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__out ULONG *pulId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MacAddress )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszMacAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IpAddress )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszIpAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PercentCompletion )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__out ULONG *pulPercentCompletion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_JoinDuration )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__out ULONG *pulJoinDuration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CpuUtilization )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__out ULONG *pulCpuUtilization);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemoryUtilization )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__out ULONG *pulMemoryUtilization);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkUtilization )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__out ULONG *pulNetworkUtilization);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserIdentity )( 
            __RPC__in IWdsTransportClient * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbszUserIdentity);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            __RPC__in IWdsTransportClient * This,
            /* [in] */ WDSTRANSPORT_DISCONNECT_TYPE DisconnectionType);
        
        END_INTERFACE
    } IWdsTransportClientVtbl;

    interface IWdsTransportClient
    {
        CONST_VTBL struct IWdsTransportClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWdsTransportClient_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWdsTransportClient_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWdsTransportClient_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWdsTransportClient_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWdsTransportClient_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWdsTransportClient_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWdsTransportClient_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWdsTransportClient_get_Session(This,ppWdsTransportSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppWdsTransportSession) ) 

#define IWdsTransportClient_get_Id(This,pulId)	\
    ( (This)->lpVtbl -> get_Id(This,pulId) ) 

#define IWdsTransportClient_get_Name(This,pbszName)	\
    ( (This)->lpVtbl -> get_Name(This,pbszName) ) 

#define IWdsTransportClient_get_MacAddress(This,pbszMacAddress)	\
    ( (This)->lpVtbl -> get_MacAddress(This,pbszMacAddress) ) 

#define IWdsTransportClient_get_IpAddress(This,pbszIpAddress)	\
    ( (This)->lpVtbl -> get_IpAddress(This,pbszIpAddress) ) 

#define IWdsTransportClient_get_PercentCompletion(This,pulPercentCompletion)	\
    ( (This)->lpVtbl -> get_PercentCompletion(This,pulPercentCompletion) ) 

#define IWdsTransportClient_get_JoinDuration(This,pulJoinDuration)	\
    ( (This)->lpVtbl -> get_JoinDuration(This,pulJoinDuration) ) 

#define IWdsTransportClient_get_CpuUtilization(This,pulCpuUtilization)	\
    ( (This)->lpVtbl -> get_CpuUtilization(This,pulCpuUtilization) ) 

#define IWdsTransportClient_get_MemoryUtilization(This,pulMemoryUtilization)	\
    ( (This)->lpVtbl -> get_MemoryUtilization(This,pulMemoryUtilization) ) 

#define IWdsTransportClient_get_NetworkUtilization(This,pulNetworkUtilization)	\
    ( (This)->lpVtbl -> get_NetworkUtilization(This,pulNetworkUtilization) ) 

#define IWdsTransportClient_get_UserIdentity(This,pbszUserIdentity)	\
    ( (This)->lpVtbl -> get_UserIdentity(This,pbszUserIdentity) ) 

#define IWdsTransportClient_Disconnect(This,DisconnectionType)	\
    ( (This)->lpVtbl -> Disconnect(This,DisconnectionType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWdsTransportClient_INTERFACE_DEFINED__ */



#ifndef __WdsTptMgmtLib_LIBRARY_DEFINED__
#define __WdsTptMgmtLib_LIBRARY_DEFINED__

/* library WdsTptMgmtLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WdsTptMgmtLib;

EXTERN_C const CLSID CLSID_WdsTransportCacheable;

#ifdef __cplusplus

class DECLSPEC_UUID("70590B16-F146-46BD-BD9D-4AAA90084BF5")
WdsTransportCacheable;
#endif

EXTERN_C const CLSID CLSID_WdsTransportCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("C7F18B09-391E-436E-B10B-C3EF46F2C34F")
WdsTransportCollection;
#endif

EXTERN_C const CLSID CLSID_WdsTransportManager;

#ifdef __cplusplus

class DECLSPEC_UUID("F21523F6-837C-4A58-AF99-8A7E27F8FF59")
WdsTransportManager;
#endif

EXTERN_C const CLSID CLSID_WdsTransportServer;

#ifdef __cplusplus

class DECLSPEC_UUID("EA19B643-4ADF-4413-942C-14F379118760")
WdsTransportServer;
#endif

EXTERN_C const CLSID CLSID_WdsTransportSetupManager;

#ifdef __cplusplus

class DECLSPEC_UUID("C7BEEAAD-9F04-4923-9F0C-FBF52BC7590F")
WdsTransportSetupManager;
#endif

EXTERN_C const CLSID CLSID_WdsTransportConfigurationManager;

#ifdef __cplusplus

class DECLSPEC_UUID("8743F674-904C-47CA-8512-35FE98F6B0AC")
WdsTransportConfigurationManager;
#endif

EXTERN_C const CLSID CLSID_WdsTransportNamespaceManager;

#ifdef __cplusplus

class DECLSPEC_UUID("F08CDB63-85DE-4A28-A1A9-5CA3E7EFDA73")
WdsTransportNamespaceManager;
#endif

EXTERN_C const CLSID CLSID_WdsTransportServicePolicy;

#ifdef __cplusplus

class DECLSPEC_UUID("65ACEADC-2F0B-4F43-9F4D-811865D8CEAD")
WdsTransportServicePolicy;
#endif

EXTERN_C const CLSID CLSID_WdsTransportDiagnosticsPolicy;

#ifdef __cplusplus

class DECLSPEC_UUID("EB3333E1-A7AD-46F5-80D6-6B740204E509")
WdsTransportDiagnosticsPolicy;
#endif

EXTERN_C const CLSID CLSID_WdsTransportMulticastSessionPolicy;

#ifdef __cplusplus

class DECLSPEC_UUID("3C6BC3F4-6418-472A-B6F1-52D457195437")
WdsTransportMulticastSessionPolicy;
#endif

EXTERN_C const CLSID CLSID_WdsTransportNamespace;

#ifdef __cplusplus

class DECLSPEC_UUID("D8385768-0732-4EC1-95EA-16DA581908A1")
WdsTransportNamespace;
#endif

EXTERN_C const CLSID CLSID_WdsTransportNamespaceAutoCast;

#ifdef __cplusplus

class DECLSPEC_UUID("B091F5A8-6A99-478D-B23B-09E8FEE04574")
WdsTransportNamespaceAutoCast;
#endif

EXTERN_C const CLSID CLSID_WdsTransportNamespaceScheduledCast;

#ifdef __cplusplus

class DECLSPEC_UUID("BADC1897-7025-44EB-9108-FB61C4055792")
WdsTransportNamespaceScheduledCast;
#endif

EXTERN_C const CLSID CLSID_WdsTransportNamespaceScheduledCastManualStart;

#ifdef __cplusplus

class DECLSPEC_UUID("D3E1A2AA-CAAC-460E-B98A-47F9F318A1FA")
WdsTransportNamespaceScheduledCastManualStart;
#endif

EXTERN_C const CLSID CLSID_WdsTransportNamespaceScheduledCastAutoStart;

#ifdef __cplusplus

class DECLSPEC_UUID("A1107052-122C-4B81-9B7C-386E6855383F")
WdsTransportNamespaceScheduledCastAutoStart;
#endif

EXTERN_C const CLSID CLSID_WdsTransportContent;

#ifdef __cplusplus

class DECLSPEC_UUID("0A891FE7-4A3F-4C65-B6F2-1467619679EA")
WdsTransportContent;
#endif

EXTERN_C const CLSID CLSID_WdsTransportSession;

#ifdef __cplusplus

class DECLSPEC_UUID("749AC4E0-67BC-4743-BFE5-CACB1F26F57F")
WdsTransportSession;
#endif

EXTERN_C const CLSID CLSID_WdsTransportClient;

#ifdef __cplusplus

class DECLSPEC_UUID("66D2C5E9-0FF6-49EC-9733-DAFB1E01DF1C")
WdsTransportClient;
#endif
#endif /* __WdsTptMgmtLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WFExt.h ===
/*****************************************************************************\
*                                                                             *
* wfext.h -     Windows File Manager Extensions definitions (Win32 variant)   *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1991-1999, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************/

#ifndef _INC_WFEXT
#define _INC_WFEXT            /* #defined if wfext.h has been included */

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus            /* Assume C declaration for C++ */
extern "C" {
#endif  /* __cplusplus */

#define MENU_TEXT_LEN           40

#define FMMENU_FIRST            1
#define FMMENU_LAST             99

#define FMEVENT_LOAD            100
#define FMEVENT_UNLOAD          101
#define FMEVENT_INITMENU        102
#define FMEVENT_USER_REFRESH    103
#define FMEVENT_SELCHANGE       104
#define FMEVENT_TOOLBARLOAD     105
#define FMEVENT_HELPSTRING      106
#define FMEVENT_HELPMENUITEM    107

#define FMFOCUS_DIR             1
#define FMFOCUS_TREE            2
#define FMFOCUS_DRIVES          3
#define FMFOCUS_SEARCH          4

#define FM_GETFOCUS           (WM_USER + 0x0200)
#define FM_GETSELCOUNT        (WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN     (WM_USER + 0x0203)  /* LFN versions are odd */
#define FM_REFRESH_WINDOWS    (WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS  (WM_USER + 0x0207)

#define FM_GETDRIVEINFOA      (WM_USER + 0x0201)
#define FM_GETFILESELA        (WM_USER + 0x0204)
#define FM_GETFILESELLFNA     (WM_USER + 0x0205)  /* LFN versions are odd */

#define FM_GETDRIVEINFOW      (WM_USER + 0x0211)
#define FM_GETFILESELW        (WM_USER + 0x0214)
#define FM_GETFILESELLFNW     (WM_USER + 0x0215)  /* LFN versions are odd */

#ifdef UNICODE
#define FM_GETDRIVEINFO    FM_GETDRIVEINFOW
#define FM_GETFILESEL      FM_GETFILESELW
#define FM_GETFILESELLFN   FM_GETFILESELLFNW
#else
#define FM_GETDRIVEINFO    FM_GETDRIVEINFOA
#define FM_GETFILESEL      FM_GETFILESELA
#define FM_GETFILESELLFN   FM_GETFILESELLFNA
#endif


typedef struct _FMS_GETFILESELA {
   FILETIME ftTime;
   DWORD dwSize;
   BYTE bAttr;
   CHAR szName[260];          // always fully qualified
} FMS_GETFILESELA, FAR *LPFMS_GETFILESELA;

typedef struct _FMS_GETFILESELW {
   FILETIME ftTime ;
   DWORD dwSize;
   BYTE bAttr;
   WCHAR szName[260];          // always fully qualified
} FMS_GETFILESELW, FAR *LPFMS_GETFILESELW;

#ifdef UNICODE
#define FMS_GETFILESEL   FMS_GETFILESELW
#define LPFMS_GETFILESEL LPFMS_GETFILESELW
#else
#define FMS_GETFILESEL   FMS_GETFILESELA
#define LPFMS_GETFILESEL LPFMS_GETFILESELA
#endif


typedef struct _FMS_GETDRIVEINFOA {      // for drive
   DWORD dwTotalSpace;
   DWORD dwFreeSpace;
   CHAR  szPath[260];                    // current directory
   CHAR  szVolume[14];                   // volume label
   CHAR  szShare[128];                   // if this is a net drive
} FMS_GETDRIVEINFOA, FAR *LPFMS_GETDRIVEINFOA;

typedef struct _FMS_GETDRIVEINFOW {      // for drive
   DWORD dwTotalSpace;
   DWORD dwFreeSpace;
   WCHAR szPath[260];                    // current directory
   WCHAR szVolume[14];                   // volume label
   WCHAR szShare[128];                   // if this is a net drive
} FMS_GETDRIVEINFOW, FAR *LPFMS_GETDRIVEINFOW;

#ifdef UNICODE
#define FMS_GETDRIVEINFO   FMS_GETDRIVEINFOW
#define LPFMS_GETDRIVEINFO LPFMS_GETDRIVEINFOW
#else
#define FMS_GETDRIVEINFO   FMS_GETDRIVEINFOA
#define LPFMS_GETDRIVEINFO LPFMS_GETDRIVEINFOA
#endif


typedef struct _FMS_LOADA {
   DWORD dwSize;                        // for version checks
   CHAR  szMenuName[MENU_TEXT_LEN];     // output
   HMENU hMenu;                         // output
   UINT  wMenuDelta;                    // input
} FMS_LOADA, FAR *LPFMS_LOADA;

typedef struct _FMS_LOADW {
   DWORD dwSize;                        // for version checks
   WCHAR szMenuName[MENU_TEXT_LEN];     // output
   HMENU hMenu;                         // output
   UINT  wMenuDelta;                    // input
} FMS_LOADW, FAR *LPFMS_LOADW;

#ifdef UNICODE
#define FMS_LOAD   FMS_LOADW
#define LPFMS_LOAD LPFMS_LOADW
#else
#define FMS_LOAD   FMS_LOADA
#define LPFMS_LOAD LPFMS_LOADA
#endif


// Toolbar definitions

typedef struct tagEXT_BUTTON {
   WORD idCommand;                 /* menu command to trigger */
   WORD idsHelp;                   /* help string ID */
   WORD fsStyle;                   /* button style */
} EXT_BUTTON, FAR *LPEXT_BUTTON;

typedef struct tagFMS_TOOLBARLOAD {
   DWORD dwSize;                   /* for version checks */
   LPEXT_BUTTON lpButtons;         /* output */
   WORD cButtons;                  /* output, 0==>no buttons */
   WORD cBitmaps;                  /* number of non-sep buttons */
   WORD idBitmap;                  /* output */
   HBITMAP hBitmap;                /* output if idBitmap==0 */
} FMS_TOOLBARLOAD, FAR *LPFMS_TOOLBARLOAD;

typedef struct tagFMS_HELPSTRINGA {
   INT   idCommand;       /* input, -1==>the menu was selected */
   HMENU hMenu;           /* input, the extensions menu */
   CHAR  szHelp[128];     /* output, the help string */
} FMS_HELPSTRINGA, FAR *LPFMS_HELPSTRINGA;

typedef struct tagFMS_HELPSTRINGW {
   INT   idCommand;       /* input, -1==>the menu was selected */
   HMENU hMenu;           /* input, the extensions menu */
   WCHAR szHelp[128];     /* output, the help string */
} FMS_HELPSTRINGW, FAR *LPFMS_HELPSTRINGW;

#ifdef UNICODE
#define FMS_HELPSTRING   FMS_HELPSTRINGW
#define LPFMS_HELPSTRING LPFMS_HELPSTRINGW
#else
#define FMS_HELPSTRING   FMS_HELPSTRINGA
#define LPFMS_HELPSTRING LPFMS_HELPSTRINGA
#endif


typedef DWORD (APIENTRY *FM_EXT_PROC)(HWND, WORD, LONG);
typedef DWORD (APIENTRY *FM_UNDELETE_PROC)(HWND, LPTSTR);

#ifdef UNICODE
LONG WINAPI FMExtensionProcW(HWND hwnd, WORD wEvent, LONG lParam);
#else
LONG WINAPI FMExtensionProc(HWND hwnd, WORD wEvent, LONG lParam);
#endif

#ifdef __cplusplus
}                  /* End of extern "C" { */
#endif             /* __cplusplus */

#endif             /* _INC_WFEXT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wheadef.h ===
/*++

Copyright (c) 2007 Microsoft Corporation

Module Name:

    wheadef.h

Abstract:

    This header file defines structures and identifiers used in software
    interfaces for the windows hardware error reporting system. It includes the
    common platform error record and error source descriptor definitions.

--*/

#ifndef _WHEADEF_H_
#define _WHEADEF_H_

#include <cper.h>

//------------------------------------------------------ WHEA_ERROR_SOURCE_TYPE

#define WHEA_PHYSICAL_ADDRESS LARGE_INTEGER

//
// This enumeration defines the various types of error sources that a platform
// can expose to the operating system.
//

typedef enum _WHEA_ERROR_SOURCE_TYPE {
    WheaErrSrcTypeMCE        = 0x00,    // Machine Check Exception
    WheaErrSrcTypeCMC        = 0x01,    // Corrected Machine Check
    WheaErrSrcTypeCPE        = 0x02,    // Corrected Platform Error
    WheaErrSrcTypeNMI        = 0x03,    // Non-Maskable Interrupt
    WheaErrSrcTypePCIe       = 0x04,    // PCI Express Error
    WheaErrSrcTypeGeneric    = 0x05,    // Other types of error sources
    WheaErrSrcTypeINIT       = 0x06,    // IA64 INIT Error Source
    WheaErrSrcTypeBOOT       = 0x07,    // BOOT Error Source
    WheaErrSrcTypeSCIGeneric = 0x08,    // SCI-based generic error source
    WheaErrSrcTypeIPFMCA     = 0x09,    // Itanium Machine Check Abort
    WheaErrSrcTypeIPFCMC     = 0x0a,    // Itanium Machine check
    WheaErrSrcTypeIPFCPE     = 0x0b,    // Itanium Corrected Platform Error
    WheaErrSrcTypeMax
} WHEA_ERROR_SOURCE_TYPE, *PWHEA_ERROR_SOURCE_TYPE;

//
// Error sources have a runtime state associated with them. The following are
// the valid states for an error source.
//

typedef enum _WHEA_ERROR_SOURCE_STATE {
    WheaErrSrcStateStopped = 0x01,
    WheaErrSrcStateStarted = 0x02
} WHEA_ERROR_SOURCE_STATE, *PWHEA_ERROR_SOURCE_STATE;

#define WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10          10

#define WHEA_MAX_MC_BANKS                                32

#define WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST             0x00000001
#define WHEA_ERROR_SOURCE_FLAG_GLOBAL                    0x00000002
#define WHEA_ERROR_SOURCE_FLAG_PREALLOCATE_PER_PROCESSOR 0x00000004
#define WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE             0x80000000

#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE         0
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC         1
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI         2
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA         3
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC         4
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE         5
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT    6
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT    7
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE      8
#define WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC        9

#define WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA            0
#define WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA         1
#define WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA           2

#define WHEA_NOTIFICATION_TYPE_POLLED                    0
#define WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT         1
#define WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT            2
#define WHEA_NOTIFICATION_TYPE_SCI                       3
#define WHEA_NOTIFICATION_TYPE_NMI                       4

#include <pshpack1.h>

//------------------------------------------------ WHEA_ERROR_SOURCE_DESCRIPTOR

typedef union _WHEA_NOTIFICATION_FLAGS {
    struct {
        USHORT PollIntervalRW:1;
        USHORT SwitchToPollingThresholdRW:1;
        USHORT SwitchToPollingWindowRW:1;
        USHORT ErrorThresholdRW:1;
        USHORT ErrorThresholdWindowRW:1;
        USHORT Reserved:11;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} WHEA_NOTIFICATION_FLAGS, *PWHEA_NOTIFICATION_FLAGS;

typedef union _XPF_MC_BANK_FLAGS {
    struct {
        UCHAR ClearOnInitializationRW:1;
        UCHAR ControlDataRW:1;
        UCHAR Reserved:6;
    } DUMMYSTRUCTNAME;
    UCHAR AsUCHAR;
} XPF_MC_BANK_FLAGS, *PXPF_MC_BANK_FLAGS;

typedef union _XPF_MCE_FLAGS {
    struct {
        ULONG MCG_CapabilityRW:1;
        ULONG MCG_GlobalControlRW:1;
        ULONG Reserved:30;
    } DUMMYSTRUCTNAME;
    ULONG AsULONG;
} XPF_MCE_FLAGS, *PXPF_MCE_FLAGS;

typedef union _AER_ROOTPORT_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT RootErrorCommandRW:1;
        USHORT Reserved:11;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_ROOTPORT_DESCRIPTOR_FLAGS, *PAER_ROOTPORT_DESCRIPTOR_FLAGS;

typedef union _AER_ENDPOINT_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT Reserved:12;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_ENDPOINT_DESCRIPTOR_FLAGS, *PAER_ENDPOINT_DESCRIPTOR_FLAGS;

typedef union _AER_BRIDGE_DESCRIPTOR_FLAGS {
    struct {
        USHORT UncorrectableErrorMaskRW:1;
        USHORT UncorrectableErrorSeverityRW:1;
        USHORT CorrectableErrorMaskRW:1;
        USHORT AdvancedCapsAndControlRW:1;
        USHORT SecondaryUncorrectableErrorMaskRW:1;
        USHORT SecondaryUncorrectableErrorSevRW:1;
        USHORT SecondaryCapsAndControlRW:1;
        USHORT Reserved:9;
    } DUMMYSTRUCTNAME;
    USHORT AsUSHORT;
} AER_BRIDGE_DESCRIPTOR_FLAGS, *PAER_BRIDGE_DESCRIPTOR_FLAGS;

//
// The following structure is used to describe how a given error source reports
// errors to the OS.
//

typedef struct _WHEA_NOTIFICATION_DESCRIPTOR {
    UCHAR Type;
    UCHAR Length;
    WHEA_NOTIFICATION_FLAGS Flags;

    union {
        struct {
            ULONG PollInterval;
        } Polled;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Interrupt;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } LocalInterrupt;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Sci;

        struct {
            ULONG PollInterval;
            ULONG Vector;
            ULONG SwitchToPollingThreshold;
            ULONG SwitchToPollingWindow;
            ULONG ErrorThreshold;
            ULONG ErrorThresholdWindow;
        } Nmi;
    } u;
} WHEA_NOTIFICATION_DESCRIPTOR, *PWHEA_NOTIFICATION_DESCRIPTOR;

//
// The following structure describes an XPF machine check bank. It identifies
// the bank with a BankNumber and it contains information that is used to
// configure the bank. MCE and CMC error sources make use of this descriptor
// to describe and configure each bank.
//

typedef struct _WHEA_XPF_MC_BANK_DESCRIPTOR {
    UCHAR BankNumber;
    BOOLEAN ClearOnInitialization;
    UCHAR StatusDataFormat;
    XPF_MC_BANK_FLAGS Flags;
    ULONG ControlMsr;
    ULONG StatusMsr;
    ULONG AddressMsr;
    ULONG MiscMsr;
    ULONGLONG ControlData;
} WHEA_XPF_MC_BANK_DESCRIPTOR, *PWHEA_XPF_MC_BANK_DESCRIPTOR;

//
// The following structure describes an XPF platform's machine check exception
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's MCE error source.
//

typedef struct _WHEA_XPF_MCE_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR NumberOfBanks;
    XPF_MCE_FLAGS Flags;
    ULONGLONG MCG_Capability;
    ULONGLONG MCG_GlobalControl;
    WHEA_XPF_MC_BANK_DESCRIPTOR Banks[WHEA_MAX_MC_BANKS];
} WHEA_XPF_MCE_DESCRIPTOR, *PWHEA_XPF_MCE_DESCRIPTOR;

//
// The following structure describes an XPF platform's corrected machine check
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's CMC error source.
//

typedef struct _WHEA_XPF_CMC_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR NumberOfBanks;
    ULONG Reserved;
    WHEA_NOTIFICATION_DESCRIPTOR Notify;
    WHEA_XPF_MC_BANK_DESCRIPTOR Banks[WHEA_MAX_MC_BANKS];
} WHEA_XPF_CMC_DESCRIPTOR, *PWHEA_XPF_CMC_DESCRIPTOR;

typedef struct _WHEA_PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG DeviceNumber:5;
            ULONG FunctionNumber:3;
            ULONG Reserved:24;
        } bits;
        ULONG AsULONG;
    } u;
} WHEA_PCI_SLOT_NUMBER, *PWHEA_PCI_SLOT_NUMBER;

//
// The following structure describes an XPF platform's non-maskable interrupt
// error source mechanism. The information represented in this structure tells
// the OS how to configure the platform's NMI error source.
//

typedef struct _WHEA_XPF_NMI_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
} WHEA_XPF_NMI_DESCRIPTOR, *PWHEA_XPF_NMI_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER root port
// error source. The information represented in this structure tells the OS how
// to configure the root port's AER settings.
//

typedef struct _WHEA_AER_ROOTPORT_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_ROOTPORT_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
    ULONG RootErrorCommand;
} WHEA_AER_ROOTPORT_DESCRIPTOR, *PWHEA_AER_ROOTPORT_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER endpoint
// error source. The information represented in this structure tells the OS how
// to configure the device's AER settings.
//

typedef struct _WHEA_AER_ENDPOINT_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_ENDPOINT_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
} WHEA_AER_ENDPOINT_DESCRIPTOR, *PWHEA_AER_ENDPOINT_DESCRIPTOR;

//
// The following structure describes a platform's PCI Express AER bridge
// error source. The information represented in this structure tells the OS how
// to configure the bridge's AER settings.
//

typedef struct _WHEA_AER_BRIDGE_DESCRIPTOR {
    USHORT Type;
    BOOLEAN Enabled;
    UCHAR Reserved;
    ULONG BusNumber;
    WHEA_PCI_SLOT_NUMBER Slot;
    USHORT DeviceControl;
    AER_BRIDGE_DESCRIPTOR_FLAGS Flags;
    ULONG UncorrectableErrorMask;
    ULONG UncorrectableErrorSeverity;
    ULONG CorrectableErrorMask;
    ULONG AdvancedCapsAndControl;
    ULONG SecondaryUncorrectableErrorMask;
    ULONG SecondaryUncorrectableErrorSev;
    ULONG SecondaryCapsAndControl;
} WHEA_AER_BRIDGE_DESCRIPTOR, *PWHEA_AER_BRIDGE_DESCRIPTOR;

//
// The following structure describes a generic error source to the OS. Using
// the information in this structure the OS is able to configure a handler for
// the generic error source.
//

typedef struct _WHEA_GENERIC_ERROR_DESCRIPTOR {

    //
    // Type is WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC.
    //

    USHORT Type;

    //
    // This field is reserved.
    //

    UCHAR Reserved;

    //
    // Indicates whether the generic error source is to be enabled.
    //

    UCHAR Enabled;

    //
    // Length of the error status block.
    //

    ULONG ErrStatusBlockLength;

    //
    // If this generic error source relates back to another error source, keep
    // it's identifier here.
    //

    ULONG RelatedErrorSourceId;

    //
    // The following 5 fields have the same layout as a GEN_ADDR structure. They
    // describe the address at which the OS reads error status information
    // from the error source.
    //

    UCHAR ErrStatusAddressSpaceID;
    UCHAR ErrStatusAddressBitWidth;
    UCHAR ErrStatusAddressBitOffset;
    UCHAR ErrStatusAddressAccessSize;
    WHEA_PHYSICAL_ADDRESS ErrStatusAddress;

    //
    // Notify describes how the generic error source notifies the OS that error
    // information is available.
    //

    WHEA_NOTIFICATION_DESCRIPTOR Notify;

} WHEA_GENERIC_ERROR_DESCRIPTOR, *PWHEA_GENERIC_ERROR_DESCRIPTOR;

typedef struct _WHEA_IPF_MCA_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_MCA_DESCRIPTOR, *PWHEA_IPF_MCA_DESCRIPTOR;

typedef struct _WHEA_IPF_CMC_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_CMC_DESCRIPTOR, *PWHEA_IPF_CMC_DESCRIPTOR;

typedef struct _WHEA_IPF_CPE_DESCRIPTOR {
    USHORT Type;
    UCHAR Enabled;
    UCHAR Reserved;
} WHEA_IPF_CPE_DESCRIPTOR, *PWHEA_IPF_CPE_DESCRIPTOR;

typedef struct _WHEA_ERROR_SOURCE_DESCRIPTOR {
    ULONG Length;                                              // +00 (0)
    ULONG Version;                                             // +04 (4)
    WHEA_ERROR_SOURCE_TYPE Type;                               // +08 (8)
    WHEA_ERROR_SOURCE_STATE State;                             // +0C (12)
    ULONG MaxRawDataLength;                                    // +10 (16)
    ULONG NumRecordsToPreallocate;                             // +14 (20)
    ULONG MaxSectionsPerRecord;                                // +18 (24)
    ULONG ErrorSourceId;                                       // +1C (28)
    ULONG PlatformErrorSourceId;                               // +20 (32)
    ULONG Flags;                                               // +24 (36)

    union {                                                    // +28 (40)
        WHEA_XPF_MCE_DESCRIPTOR XpfMceDescriptor;
        WHEA_XPF_CMC_DESCRIPTOR XpfCmcDescriptor;
        WHEA_XPF_NMI_DESCRIPTOR XpfNmiDescriptor;
        WHEA_IPF_MCA_DESCRIPTOR IpfMcaDescriptor;
        WHEA_IPF_CMC_DESCRIPTOR IpfCmcDescriptor;
        WHEA_IPF_CPE_DESCRIPTOR IpfCpeDescriptor;
        WHEA_AER_ROOTPORT_DESCRIPTOR AerRootportDescriptor;
        WHEA_AER_ENDPOINT_DESCRIPTOR AerEndpointDescriptor;
        WHEA_AER_BRIDGE_DESCRIPTOR AerBridgeDescriptor;
        WHEA_GENERIC_ERROR_DESCRIPTOR GenErrDescriptor;
    } Info;

} WHEA_ERROR_SOURCE_DESCRIPTOR, *PWHEA_ERROR_SOURCE_DESCRIPTOR;

#include <poppack.h>

#endif // #ifndef _WHEADEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wdstptmgmt_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wdstptmgmt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IWdsTransportCacheable,0x46AD894B,0x0BAB,0x47DC,0x84,0xB2,0x7B,0x55,0x3F,0x1D,0x8F,0x80);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportCollection,0xB8BA4B1A,0x2FF4,0x43AB,0x99,0x6C,0xB2,0xB1,0x0A,0x91,0xA6,0xEB);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportManager,0x5B0D35F5,0x1B13,0x4AFD,0xB8,0x78,0x65,0x26,0xDC,0x34,0x0B,0x5D);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportServer,0x09CCD093,0x830D,0x4344,0xA3,0x0A,0x73,0xAE,0x8E,0x8F,0xCA,0x90);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportSetupManager,0xF7238425,0xEFA8,0x40A4,0xAE,0xF9,0xC9,0x8D,0x96,0x9C,0x0B,0x75);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportConfigurationManager,0x84CC4779,0x42DD,0x4792,0x89,0x1E,0x13,0x21,0xD6,0xD7,0x4B,0x44);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportConfigurationManager2,0xD0D85CAF,0xA153,0x4F1D,0xA9,0xDD,0x96,0xF4,0x31,0xC5,0x07,0x17);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportNamespaceManager,0x3E22D9F6,0x3777,0x4D98,0x83,0xE1,0xF9,0x86,0x96,0x71,0x7B,0xA3);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportServicePolicy,0xB9468578,0x9F2B,0x48CC,0xB2,0x7A,0xA6,0x07,0x99,0xC2,0x75,0x0C);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportDiagnosticsPolicy,0x13B33EFC,0x7856,0x4F61,0x9A,0x59,0x8D,0xE6,0x7B,0x6B,0x87,0xB6);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportMulticastSessionPolicy,0x4E5753CF,0x68EC,0x4504,0xA9,0x51,0x4A,0x00,0x32,0x66,0x60,0x6B);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportNamespace,0xFA561F57,0xFBEF,0x4ED3,0xB0,0x56,0x12,0x7C,0xB1,0xB3,0x3B,0x84);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportNamespaceAutoCast,0xAD931A72,0xC4BD,0x4C41,0x8F,0xBC,0x59,0xC9,0xC7,0x48,0xDF,0x9E);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportNamespaceScheduledCast,0x3840CECF,0xD76C,0x416E,0xA4,0xCC,0x31,0xC7,0x41,0xD2,0x87,0x4B);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportNamespaceScheduledCastManualStart,0x013E6E4C,0xE6A7,0x4FB5,0xB7,0xFF,0xD9,0xF5,0xDA,0x80,0x5C,0x31);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportNamespaceScheduledCastAutoStart,0xD606AF3D,0xEA9C,0x4219,0x96,0x1E,0x74,0x91,0xD6,0x18,0xD9,0xB9);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportContent,0xD405D711,0x0296,0x4AB4,0xA8,0x60,0xAC,0x7D,0x32,0xE6,0x57,0x98);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportSession,0xF4EFEA88,0x65B1,0x4F30,0xA4,0xB9,0x27,0x93,0x98,0x77,0x96,0xFB);


MIDL_DEFINE_GUID(IID, IID_IWdsTransportClient,0xB5DBC93A,0xCABE,0x46CA,0x83,0x7F,0x3E,0x44,0xE9,0x3C,0x65,0x45);


MIDL_DEFINE_GUID(IID, LIBID_WdsTptMgmtLib,0x9212887F,0xF5BC,0x45DD,0xA5,0x10,0x26,0x54,0x13,0xA1,0x8E,0xD7);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportCacheable,0x70590B16,0xF146,0x46BD,0xBD,0x9D,0x4A,0xAA,0x90,0x08,0x4B,0xF5);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportCollection,0xC7F18B09,0x391E,0x436E,0xB1,0x0B,0xC3,0xEF,0x46,0xF2,0xC3,0x4F);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportManager,0xF21523F6,0x837C,0x4A58,0xAF,0x99,0x8A,0x7E,0x27,0xF8,0xFF,0x59);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportServer,0xEA19B643,0x4ADF,0x4413,0x94,0x2C,0x14,0xF3,0x79,0x11,0x87,0x60);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportSetupManager,0xC7BEEAAD,0x9F04,0x4923,0x9F,0x0C,0xFB,0xF5,0x2B,0xC7,0x59,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportConfigurationManager,0x8743F674,0x904C,0x47CA,0x85,0x12,0x35,0xFE,0x98,0xF6,0xB0,0xAC);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportNamespaceManager,0xF08CDB63,0x85DE,0x4A28,0xA1,0xA9,0x5C,0xA3,0xE7,0xEF,0xDA,0x73);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportServicePolicy,0x65ACEADC,0x2F0B,0x4F43,0x9F,0x4D,0x81,0x18,0x65,0xD8,0xCE,0xAD);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportDiagnosticsPolicy,0xEB3333E1,0xA7AD,0x46F5,0x80,0xD6,0x6B,0x74,0x02,0x04,0xE5,0x09);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportMulticastSessionPolicy,0x3C6BC3F4,0x6418,0x472A,0xB6,0xF1,0x52,0xD4,0x57,0x19,0x54,0x37);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportNamespace,0xD8385768,0x0732,0x4EC1,0x95,0xEA,0x16,0xDA,0x58,0x19,0x08,0xA1);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportNamespaceAutoCast,0xB091F5A8,0x6A99,0x478D,0xB2,0x3B,0x09,0xE8,0xFE,0xE0,0x45,0x74);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportNamespaceScheduledCast,0xBADC1897,0x7025,0x44EB,0x91,0x08,0xFB,0x61,0xC4,0x05,0x57,0x92);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportNamespaceScheduledCastManualStart,0xD3E1A2AA,0xCAAC,0x460E,0xB9,0x8A,0x47,0xF9,0xF3,0x18,0xA1,0xFA);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportNamespaceScheduledCastAutoStart,0xA1107052,0x122C,0x4B81,0x9B,0x7C,0x38,0x6E,0x68,0x55,0x38,0x3F);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportContent,0x0A891FE7,0x4A3F,0x4C65,0xB6,0xF2,0x14,0x67,0x61,0x96,0x79,0xEA);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportSession,0x749AC4E0,0x67BC,0x4743,0xBF,0xE5,0xCA,0xCB,0x1F,0x26,0xF5,0x7F);


MIDL_DEFINE_GUID(CLSID, CLSID_WdsTransportClient,0x66D2C5E9,0x0FF6,0x49EC,0x97,0x33,0xDA,0xFB,0x1E,0x01,0xDF,0x1C);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\webhost.h ===
//
// Web Host APIs
//
// Copyright (c) 2002 Microsoft Corporation
//

#pragma once
#pragma pack(push, 8)

#include <comdef.h>

//
// ListenerChannel Callback provides notifications related to listenerChannels 
// from Protocol Handlers to worker process framework.
// It also allows protocol handlers to access additional parameters such
// as Id of the listenerChannel of the Blob they may contain additional parameters
// passed from listener adapter
//

struct __declspec(uuid("dc3b0a85-9da7-47e4-ba1b-e27da9db8a1e")) IListenerChannelCallback;
struct IListenerChannelCallback : IUnknown {
    virtual HRESULT __stdcall ReportStarted() = 0;

    virtual HRESULT __stdcall ReportStopped(HRESULT hr) = 0;

    virtual HRESULT __stdcall ReportMessageReceived() = 0;

    virtual HRESULT __stdcall GetId(DWORD* pdwListenerChannelId) = 0;

    virtual HRESULT __stdcall GetBlobLength(DWORD* pcbLength) = 0;

    virtual HRESULT __stdcall GetBlob(PBYTE pBlob, DWORD* pcbBlob) = 0;
};

//
// AppDomainInfo contains details about an appdomain
//

struct __declspec(uuid("5BC9C234-6CD7-49bf-A07A-6FDB7F22DFFF")) IAppDomainInfo;
struct IAppDomainInfo : IUnknown {
    virtual HRESULT __stdcall GetId(
        BSTR *pbstrAppDomainId ) = 0;

    virtual HRESULT __stdcall GetVirtualPath(
        BSTR *pbstrVirtualPath ) = 0;

    virtual HRESULT __stdcall GetPhysicalPath(
        BSTR *pbstrPhysicalPath ) = 0;

    virtual HRESULT __stdcall GetSiteId(
        DWORD *pdwSiteId ) = 0;

    virtual HRESULT __stdcall GetIsIdle(
        DWORD *pfIsIdle ) = 0;
};

//
// Enumerator to get access to the information about
// all app domains managed by ProcessHost
//

struct __declspec(uuid("F79648FB-558B-4a09-88F1-1E3BCB30E34F")) IAppDomainInfoEnum;
struct IAppDomainInfoEnum : IUnknown {
    virtual HRESULT __stdcall GetData(
        IAppDomainInfo ** ppAppDomainInfo ) = 0;

    virtual HRESULT __stdcall Count(
        DWORD * pdwCount ) = 0;

    virtual HRESULT __stdcall MoveNext(
        DWORD * pfMoreItems ) = 0;

    virtual HRESULT __stdcall Reset(
         ) = 0;
};

//
// Helper functions for Process Host that are exposed (indirectly) by worker process
// framework through the protocol manager that interfaces worker process framework
// with the managed Process Host
//
struct __declspec(uuid("35f9c4c1-3800-4d17-99bc-018a62243687")) IProcessHostSupportFunctions;
struct IProcessHostSupportFunctions : IUnknown {
    virtual HRESULT __stdcall GetApplicationProperties(
        LPCWSTR appId, 
        BSTR   *pbstrVirtualPath,
        BSTR   *pbstrPhysicalPath,
        BSTR   *pbstrSiteName,
        BSTR   *pbstrSiteId) = 0;

    virtual HRESULT __stdcall MapPath(
        LPCWSTR appId, 
        LPCWSTR virtualPath, 
        BSTR   *pbstrPhysicalPath) = 0;

    virtual HRESULT __stdcall GetConfigToken(
        LPCWSTR appId, 
        HANDLE *pToken) = 0;

    virtual HRESULT __stdcall GetAppHostConfigFilename(
        BSTR   *pbstrPhysicalPath) = 0;
    
    virtual HRESULT __stdcall GetRootWebConfigFilename(
        BSTR   *pbstrPhysicalPath) = 0;

    virtual HRESULT __stdcall GetNativeConfigurationSystem(
        PPVOID ppConfigSystem) = 0;
};

//
// Ping callback interface
//
struct __declspec(uuid("f11dc4c9-ddd1-4566-ad53-cf6f3a28fefe")) 
                                                        IProcessPingCallback;
struct IProcessPingCallback : IUnknown {
    virtual HRESULT __stdcall Respond() = 0;
};

//
// Process Host
// 
struct __declspec(uuid("0ccd465e-3114-4ca3-ad50-cea561307e93")) IProcessHost;
struct IProcessHost : IUnknown {
    virtual HRESULT __stdcall StartApplication(
        PCWSTR appId,
        PCWSTR appPath,
        IUnknown ** ppRuntimeObject ) = 0;
    
    virtual HRESULT __stdcall ShutdownApplication(
        LPCWSTR appId) = 0;

    virtual HRESULT __stdcall Shutdown() = 0;

    virtual HRESULT __stdcall EnumerateAppDomains(
        IAppDomainInfoEnum ** pAppDomainsInfo ) = 0;
};

//
// Process Protocol Handlers Manager
//
struct __declspec(uuid("1cc9099d-0a8d-41cb-87d6-845e4f8c4e91")) IPphManager;
struct IPphManager : IUnknown {
    virtual HRESULT __stdcall StartProcessProtocolListenerChannel(
        LPCWSTR protocolId,
        IListenerChannelCallback *pListenerChannelCallback) = 0;

    virtual HRESULT __stdcall StopProcessProtocolListenerChannel(
        LPCWSTR protocolId,
        DWORD listenerChannelId,
        BOOL immediate) = 0;

    virtual HRESULT __stdcall StopProcessProtocol(
        LPCWSTR protocolId,
        BOOL immediate) = 0;
};

//
// Process Host Idle and Health Check
//
struct __declspec(uuid("9d98b251-453e-44f6-9cec-8b5aed970129")) 
                                            IProcessHostIdleAndHealthMonitor;
struct IProcessHostIdleAndHealthMonitor : IUnknown {
    //
    // Check if process host is idle
    //
    virtual HRESULT __stdcall IsIdle(
        BOOL *pfIdle) = 0;

    //
    // Perform health check
    //

    virtual HRESULT __stdcall Ping(
        IProcessPingCallback *pCallback) = 0;
};


//
// Helper to create and configure Process Host
//

struct __declspec(uuid("02fd465d-5c5d-4b7e-95b6-82faa031b74a")) 
                                                    IProcessHostFactoryHelper;
struct IProcessHostFactoryHelper : IUnknown {
    virtual HRESULT __stdcall GetProcessHost(
        IProcessHostSupportFunctions *pFunctions,
        IUnknown **ppProcessHost) = 0;
};

//
// Application preload util
//
struct __declspec(uuid("940D8ADD-9E40-4475-9A67-2CDCDF57995C")) 
                                                    IApplicationPreloadUtil;
struct IApplicationPreloadUtil : IUnknown {
    virtual
    HRESULT
    __stdcall
    GetApplicationPreloadInfo(
        PCWSTR pszContext,
        BOOL * pfEnabled,
        BSTR * pbstrType,
        SAFEARRAY ** psaPreloadValues
    ) = 0;
    
    virtual
    HRESULT
    __stdcall
    ReportApplicationPreloadFailure(
        PCWSTR pszContext,
        HRESULT hrFailureCode,
        PCWSTR pszErrorString
    ) = 0;
};

//
// Application preload manager
//
struct __declspec(uuid("AE54F424-71BC-4da5-AA2F-8C0CD53496FC")) 
                                                    IApplicationPreloadManager;
struct IApplicationPreloadManager : IUnknown {
    virtual HRESULT __stdcall SetApplicationPreloadUtil(
        IApplicationPreloadUtil * pPreload
    ) = 0;
    
    virtual HRESULT __stdcall SetApplicationPreloadState(
        PCWSTR pszContext,
        PCWSTR pszAppId,
        BOOL fEnabled
    ) = 0;
};

//
// Function pointer declarations
//
HRESULT __stdcall GetIsapiProcessHost(
    IProcessHostSupportFunctions *pFunctions,
    IProcessHost **ppProcessHost);

// Corresponding function typedef
typedef HRESULT (__stdcall *PFNGetIsapiProcessHost)(
    IProcessHostSupportFunctions *pFunctions,
    IProcessHost **ppProcessHost);

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WERAPI.H ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    werapi.h

Abstract:

    This file contains the function prototypes for Windows Error Reporting (WER)

Notes:
    
--*/

#pragma once

#include <specstrings.h>

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////// Defines //////////////////////////////////////////////

typedef HANDLE HREPORT;

//
// Do not add heap dumps for reports for the process
//
#define WER_FAULT_REPORTING_FLAG_NOHEAP     1

//
// Queue critical reports for this process
//
#define WER_FAULT_REPORTING_FLAG_QUEUE      2

//
// Do not suspend the process before error reporting
//
#define WER_FAULT_REPORTING_FLAG_DISABLE_THREAD_SUSPENSION   4

//
// Queue critical reports for this process and upload from the queue
//
#define WER_FAULT_REPORTING_FLAG_QUEUE_UPLOAD      8

//
// Fault reporting UI should always be shown. This is only applicable for interactive processes
//
#define WER_FAULT_REPORTING_ALWAYS_SHOW_UI          16

// 
// Maximum length of the report event name
//
#define WER_MAX_EVENT_NAME_LENGTH 64

//
// Maximum length of the name of a signature element
//
#define WER_MAX_SIGNATURE_NAME_LENGTH 128

//
// This is the maximum length of any created URL
//
#define WER_MAX_TOTAL_PARAM_LENGTH      1720

//
// This is the maximum length of any parameter including the NULL character
//
#define WER_MAX_PARAM_LENGTH            (MAX_PATH)

//
// Number of extra modules that we can select to get extra data in the minidump
// 
#define WER_MAX_PREFERRED_MODULES           128
#define WER_MAX_PREFERRED_MODULES_BUFFER    256

//
// Maximum number of parameters for a report
//
#define WER_MAX_PARAM_COUNT 10

//
// The maximum size of memory block that can be registered
//
#define WER_MAX_MEM_BLOCK_SIZE (64 * 1024)

//
// Event Type constant for application crashes
//
#define APPCRASH_EVENT          L"APPCRASH"

// Indexes for the parameter ids
#define WER_P0  0
#define WER_P1  1
#define WER_P2  2
#define WER_P3  3
#define WER_P4  4
#define WER_P5  5
#define WER_P6  6
#define WER_P7  7
#define WER_P8  8
#define WER_P9  9

//
// Custom error HRESULTS
//
//  This error occurs if we are adding some parameter and this will cause the URL string to
//  exceed the maximum length

#define WER_ERROR_START (0xff00)

#define WER_E_INSUFFICIENT_BUFFER           (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
#define WER_E_NOT_FOUND                     (HRESULT_FROM_WIN32(ERROR_NOT_FOUND))

#define WER_E_LENGTH_EXCEEDED               (HRESULT_FROM_WIN32(ERROR_PARAMETER_QUOTA_EXCEEDED))
//
// The API was called when it should not have been called. E.g trying to report the same
// event twice when the first reportign is still going on
#define WER_E_INVALID_STATE                 (HRESULT_FROM_WIN32(ERROR_INVALID_STATE))

// The store was disabled
#define WER_E_STORE_DISABLED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, WER_ERROR_START + 3)

//
// There were some params that were missing, i.e the coniditon index A < B < C and parameter at B is null
// but parameters at A and C are not
#define WER_E_MISSING_PARAM                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINDOWS, WER_ERROR_START + 5)

///////////////////////////////////////////////////////////////////////////////

//
// The enum that describes the indexes of the customizable UI strings
// 
typedef enum _WER_REPORT_UI
{
    WerUIAdditionalDataDlgHeader = 1,
    WerUIIconFilePath = 2,
    WerUIConsentDlgHeader = 3,
    WerUIConsentDlgBody = 4,
    WerUIOnlineSolutionCheckText = 5,
    WerUIOfflineSolutionCheckText = 6,
    WerUICloseText = 7,
    WerUICloseDlgHeader = 8,
    WerUICloseDlgBody = 9,
    WerUICloseDlgButtonText = 10,
    WerUICustomActionButtonText = 11,
    WerUIMax
} WER_REPORT_UI;

//
// The type of the registered files
//
typedef enum _WER_REGISTER_FILE_TYPE
{   
    WerRegFileTypeUserDocument = 1,
    WerRegFileTypeOther = 2,
    WerRegFileTypeMax
} WER_REGISTER_FILE_TYPE;

//
// The type of files that can be added to the report
// 
typedef enum _WER_FILE_TYPE
{   
    WerFileTypeMicrodump = 1,
    WerFileTypeMinidump = 2,
    WerFileTypeHeapdump = 3,
    WerFileTypeUserDocument = 4,
    WerFileTypeOther = 5,
    WerFileTypeMax
} WER_FILE_TYPE;

typedef enum _WER_SUBMIT_RESULT
{
    WerReportQueued = 1,
    WerReportUploaded = 2,
    WerReportDebug = 3,
    WerReportFailed = 4,
    WerDisabled = 5,
    WerReportCancelled = 6,
    WerDisabledQueue = 7,
    WerReportAsync = 8,
    WerCustomAction = 9
} WER_SUBMIT_RESULT, *PWER_SUBMIT_RESULT;

//
// The type of the report
//
typedef enum _WER_REPORT_TYPE
{   
    WerReportNonCritical = 0,
    WerReportCritical = 1,
    WerReportApplicationCrash = 2,
    WerReportApplicationHang = 3,
    WerReportKernel = 4,
    WerReportInvalid
} WER_REPORT_TYPE;

//
// Flags that can be specified when adding a file to the report. 
//
// NOTE: These should always occupy the lower 16 bits of the file flag dword. 
// The upper 16 bits are reserved for internal use and get cleared by WerAddFile.
//
#define WER_FILE_DELETE_WHEN_DONE       1  // Delete the file once WER is done
#define WER_FILE_ANONYMOUS_DATA         2  // This file does not contain any PII

//
// Report submission flags. 
//                     
#define WER_SUBMIT_HONOR_RECOVERY               1       // show recovery option
#define WER_SUBMIT_HONOR_RESTART                2       // show application restart option
#define WER_SUBMIT_QUEUE                        4       // report directly to queue
#define WER_SUBMIT_SHOW_DEBUG                   8       // show the debug button
#define WER_SUBMIT_ADD_REGISTERED_DATA          16      // Add registered data to the WER report 
#define WER_SUBMIT_OUTOFPROCESS                 32      // Force the report to go out of process
#define WER_SUBMIT_NO_CLOSE_UI                  64      // Do not show the close dialog for the critical report
#define WER_SUBMIT_NO_QUEUE                     128     // Do not queue the report
#define WER_SUBMIT_NO_ARCHIVE                   256     // Do not archive the report
#define WER_SUBMIT_START_MINIMIZED              512     // The initial reporting UI is minimized and will flash
#define WER_SUBMIT_OUTOFPROCESS_ASYNC           1024    // Force the report to go out of process and do not wait for it to finish
#define WER_SUBMIT_BYPASS_DATA_THROTTLING       2048    // Bypass data throttling for the report
#define WER_SUBMIT_ARCHIVE_PARAMETERS_ONLY      4096    // Archive only the parameters; the cab is discarded
#define WER_SUBMIT_REPORT_MACHINE_ID            8192    // Always send the machine ID, regardless of the consent the report was submitted with

typedef struct _WER_REPORT_INFORMATION
{
    DWORD dwSize;
    HANDLE hProcess;
    WCHAR wzConsentKey[64];
    WCHAR wzFriendlyEventName[128];
    WCHAR wzApplicationName[128];
    WCHAR wzApplicationPath[MAX_PATH];
    WCHAR wzDescription[512];
    HWND hwndParent;    

} WER_REPORT_INFORMATION, *PWER_REPORT_INFORMATION;

typedef struct _WER_DUMP_CUSTOM_OPTIONS 
{
    DWORD dwSize;   
    DWORD dwMask;
    DWORD dwDumpFlags;
    BOOL  bOnlyThisThread;
    DWORD dwExceptionThreadFlags;
    DWORD dwOtherThreadFlags;
    DWORD dwExceptionThreadExFlags;
    DWORD dwOtherThreadExFlags;
    DWORD dwPreferredModuleFlags;
    DWORD dwOtherModuleFlags;
    WCHAR wzPreferredModuleList[WER_MAX_PREFERRED_MODULES_BUFFER];
    
} WER_DUMP_CUSTOM_OPTIONS, *PWER_DUMP_CUSTOM_OPTIONS;

typedef struct _WER_EXCEPTION_INFORMATION
{   
    PEXCEPTION_POINTERS pExceptionPointers;
    BOOL bClientPointers;
} WER_EXCEPTION_INFORMATION, *PWER_EXCEPTION_INFORMATION;

typedef enum _WER_CONSENT
{
    WerConsentNotAsked = 1,
    WerConsentApproved = 2,
    WerConsentDenied = 3,
    WerConsentAlwaysPrompt = 4,
    WerConsentMax
}WER_CONSENT;

__control_entrypoint(DllExport)
HRESULT
WINAPI
WerReportCreate(
    __in PCWSTR pwzEventType, 
    __in WER_REPORT_TYPE repType,
    __in_opt PWER_REPORT_INFORMATION pReportInformation,
    __out HREPORT *phReportHandle
    );
    
__control_entrypoint(DllExport)
HRESULT
WINAPI
WerReportSetParameter(
    __in HREPORT hReportHandle, 
    __in DWORD dwparamID, 
    __in_opt PCWSTR pwzName,
    __in PCWSTR pwzValue
    );
    
__control_entrypoint(DllExport)
HRESULT
WINAPI
WerReportAddFile(
    __in HREPORT hReportHandle, 
    __in PCWSTR pwzPath, 
    __in WER_FILE_TYPE repFileType,
    __in DWORD  dwFileFlags
    );

__control_entrypoint(DllExport)
HRESULT  
WINAPI
WerReportSetUIOption(
    __in HREPORT hReportHandle, 
    __in WER_REPORT_UI repUITypeID, 
    __in PCWSTR pwzValue
    );

__control_entrypoint(DllExport)
HRESULT 
WINAPI
WerReportSubmit(
    __in HREPORT hReportHandle,
    __in WER_CONSENT consent,
    __in DWORD  dwFlags,
    __out_opt PWER_SUBMIT_RESULT pSubmitResult
    );

//
// Masks to be used for customizing the dump
//
#define WER_DUMP_MASK_START 1
#define WER_DUMP_MASK_DUMPTYPE               (WER_DUMP_MASK_START << 0)
#define WER_DUMP_MASK_ONLY_THISTHREAD        (WER_DUMP_MASK_START << 1)
#define WER_DUMP_MASK_THREADFLAGS            (WER_DUMP_MASK_START << 2)
#define WER_DUMP_MASK_THREADFLAGS_EX         (WER_DUMP_MASK_START << 3)
#define WER_DUMP_MASK_OTHERTHREADFLAGS       (WER_DUMP_MASK_START << 4)
#define WER_DUMP_MASK_OTHERTHREADFLAGS_EX    (WER_DUMP_MASK_START << 5)
#define WER_DUMP_MASK_PREFERRED_MODULESFLAGS (WER_DUMP_MASK_START << 6)
#define WER_DUMP_MASK_OTHER_MODULESFLAGS     (WER_DUMP_MASK_START << 7)
#define WER_DUMP_MASK_PREFERRED_MODULE_LIST  (WER_DUMP_MASK_START << 8)

//
// WER dump flags
//
#define  WER_DUMP_NOHEAP_ONQUEUE    1

typedef enum _WER_DUMP_TYPE
{
    WerDumpTypeMicroDump = 1,
    WerDumpTypeMiniDump = 2,
    WerDumpTypeHeapDump = 3,
    WerDumpTypeMax = 4
} WER_DUMP_TYPE;

__control_entrypoint(DllExport)
HRESULT  
WINAPI
WerReportAddDump(
    __in HREPORT hReportHandle, 
    __in HANDLE  hProcess,
    __in_opt HANDLE hThread,
    __in WER_DUMP_TYPE dumpType,
    __in_opt  PWER_EXCEPTION_INFORMATION pExceptionParam,
    __in_opt PWER_DUMP_CUSTOM_OPTIONS pDumpCustomOptions,
    __in DWORD dwFlags
    );

__control_entrypoint(DllExport)
HRESULT 
WINAPI
WerReportCloseHandle(
    __in HREPORT hReportHandle
    );
    

//
// ++++++++++++++++++++++++++ Registration APIs ++++++++++++++++++++++++++++++++++++++
//

#define WER_MAX_REGISTERED_ENTRIES 512

HRESULT 
WINAPI
WerRegisterFile(
    __in PCWSTR pwzFile, 
    __in WER_REGISTER_FILE_TYPE regFileType,
    __in DWORD dwFlags
    );

HRESULT 
WINAPI
WerUnregisterFile(
    __in PCWSTR pwzFilePath
    );

HRESULT
WINAPI
WerRegisterMemoryBlock(
    __in PVOID pvAddress,
    __in DWORD dwSize
    );

HRESULT 
WINAPI
WerUnregisterMemoryBlock(
    __in PVOID pvAddress
    );
    
HRESULT
WINAPI
WerSetFlags(
    __in DWORD dwFlags
    );
    
HRESULT
WINAPI
WerGetFlags(
    __in HANDLE hProcess,
    __out PDWORD pdwFlags
    );

//
// ++++++++++++++++++++++++++ Application Setup APIs ++++++++++++++++++++++++++++++++++++++
// 
HRESULT
WINAPI
WerAddExcludedApplication(
    __in PCWSTR pwzExeName,
    __in BOOL bAllUsers
    );
    
HRESULT
WINAPI
WerRemoveExcludedApplication(
    __in PCWSTR pwzExeName,
    __in BOOL bAllUsers
    );

//
// ++++++++++++++++++++++++++ Run time handler APIs +++++++++++++++++++++++++++
// 

#define WER_MAX_REGISTERED_RUNTIME_EXCEPTION_MODULES 16

HRESULT
WINAPI
WerRegisterRuntimeExceptionModule(
    __in PCWSTR pwszOutOfProcessCallbackDll,
    __in PVOID pContext
    );

HRESULT
WINAPI
WerUnregisterRuntimeExceptionModule(
    __in PCWSTR pwszOutOfProcessCallbackDll,
    __in PVOID pContext
    );

#define WER_RUNTIME_EXCEPTION_EVENT_FUNCTION                "OutOfProcessExceptionEventCallback"
#define WER_RUNTIME_EXCEPTION_EVENT_SIGNATURE_FUNCTION      "OutOfProcessExceptionEventSignatureCallback"
#define WER_RUNTIME_EXCEPTION_DEBUGGER_LAUNCH               "OutOfProcessExceptionEventDebuggerLaunchCallback"

typedef struct _WER_RUNTIME_EXCEPTION_INFORMATION
{
    DWORD dwSize;
    HANDLE hProcess;
    HANDLE hThread;
    EXCEPTION_RECORD exceptionRecord;
    CONTEXT context;
    PCWSTR pwszReportId;
} WER_RUNTIME_EXCEPTION_INFORMATION, *PWER_RUNTIME_EXCEPTION_INFORMATION;

typedef
HRESULT
(* PFN_WER_RUNTIME_EXCEPTION_EVENT)(       
    __in PVOID pContext,
    __in const PWER_RUNTIME_EXCEPTION_INFORMATION pExceptionInformation,
    __out BOOL * pbOwnershipClaimed,
    __out_ecount(*pchSize) PWSTR pwszEventName,
    __inout PDWORD  pchSize,
    __out PDWORD  pdwSignatureCount
    );

typedef
HRESULT
(* PFN_WER_RUNTIME_EXCEPTION_EVENT_SIGNATURE)(       
    __in PVOID pContext,
    __in const PWER_RUNTIME_EXCEPTION_INFORMATION pExceptionInformation,
    __in DWORD dwIndex,
    __out_ecount(*pchName) PWSTR pwszName,
    __inout PDWORD  pchName,
    __out_ecount(*pchValue) PWSTR pwszValue,
    __inout PDWORD  pchValue
    );

typedef
HRESULT
(* PFN_WER_RUNTIME_EXCEPTION_DEBUGGER_LAUNCH)(       
    __in PVOID pContext,
    __in const PWER_RUNTIME_EXCEPTION_INFORMATION pExceptionInformation,
    __out PBOOL pbIsCustomDebugger,
    __out_ecount(*pchName) PWSTR pwszDebuggerLaunch,
    __inout PDWORD  pchDebuggerLaunch,
    __out PBOOL pbIsDebuggerAutolaunch
    );
   
#ifdef __cplusplus
}                  
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\webevnts.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for webevnts.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __webevnts_h__
#define __webevnts_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWebBrowserEventsService_FWD_DEFINED__
#define __IWebBrowserEventsService_FWD_DEFINED__
typedef interface IWebBrowserEventsService IWebBrowserEventsService;
#endif 	/* __IWebBrowserEventsService_FWD_DEFINED__ */


#ifndef __IWebBrowserEventsUrlService_FWD_DEFINED__
#define __IWebBrowserEventsUrlService_FWD_DEFINED__
typedef interface IWebBrowserEventsUrlService IWebBrowserEventsUrlService;
#endif 	/* __IWebBrowserEventsUrlService_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_webevnts_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// webevnts.h
//=--------------------------------------------------------------------------=
// (C) Copyright Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IWebBrowserEventsService and IWebBrowserUrlForEvents Interfaces.



#ifndef _LPWEBEVNTS_DEFINED
#define _LPWEBEVNTS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_webevnts_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_webevnts_0000_0000_v0_0_s_ifspec;

#ifndef __IWebBrowserEventsService_INTERFACE_DEFINED__
#define __IWebBrowserEventsService_INTERFACE_DEFINED__

/* interface IWebBrowserEventsService */
/* [object][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IWebBrowserEventsService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54A8F188-9EBD-4795-AD16-9B4945119636")
    IWebBrowserEventsService : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireBeforeNavigate2Event( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfCancel) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireNavigateComplete2Event( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireDownloadBeginEvent( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireDownloadCompleteEvent( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FireDocumentCompleteEvent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowserEventsServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWebBrowserEventsService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWebBrowserEventsService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWebBrowserEventsService * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FireBeforeNavigate2Event )( 
            __RPC__in IWebBrowserEventsService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfCancel);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FireNavigateComplete2Event )( 
            __RPC__in IWebBrowserEventsService * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FireDownloadBeginEvent )( 
            __RPC__in IWebBrowserEventsService * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FireDownloadCompleteEvent )( 
            __RPC__in IWebBrowserEventsService * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FireDocumentCompleteEvent )( 
            __RPC__in IWebBrowserEventsService * This);
        
        END_INTERFACE
    } IWebBrowserEventsServiceVtbl;

    interface IWebBrowserEventsService
    {
        CONST_VTBL struct IWebBrowserEventsServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowserEventsService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWebBrowserEventsService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWebBrowserEventsService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWebBrowserEventsService_FireBeforeNavigate2Event(This,pfCancel)	\
    ( (This)->lpVtbl -> FireBeforeNavigate2Event(This,pfCancel) ) 

#define IWebBrowserEventsService_FireNavigateComplete2Event(This)	\
    ( (This)->lpVtbl -> FireNavigateComplete2Event(This) ) 

#define IWebBrowserEventsService_FireDownloadBeginEvent(This)	\
    ( (This)->lpVtbl -> FireDownloadBeginEvent(This) ) 

#define IWebBrowserEventsService_FireDownloadCompleteEvent(This)	\
    ( (This)->lpVtbl -> FireDownloadCompleteEvent(This) ) 

#define IWebBrowserEventsService_FireDocumentCompleteEvent(This)	\
    ( (This)->lpVtbl -> FireDocumentCompleteEvent(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWebBrowserEventsService_INTERFACE_DEFINED__ */


#ifndef __IWebBrowserEventsUrlService_INTERFACE_DEFINED__
#define __IWebBrowserEventsUrlService_INTERFACE_DEFINED__

/* interface IWebBrowserEventsUrlService */
/* [object][hidden][helpcontext][helpstring][uuid] */ 


EXTERN_C const IID IID_IWebBrowserEventsUrlService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("87CC5D04-EAFA-4833-9820-8F986530CC00")
    IWebBrowserEventsUrlService : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetUrlForEvents( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebBrowserEventsUrlServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWebBrowserEventsUrlService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWebBrowserEventsUrlService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWebBrowserEventsUrlService * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUrlForEvents )( 
            __RPC__in IWebBrowserEventsUrlService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pUrl);
        
        END_INTERFACE
    } IWebBrowserEventsUrlServiceVtbl;

    interface IWebBrowserEventsUrlService
    {
        CONST_VTBL struct IWebBrowserEventsUrlServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebBrowserEventsUrlService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWebBrowserEventsUrlService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWebBrowserEventsUrlService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWebBrowserEventsUrlService_GetUrlForEvents(This,pUrl)	\
    ( (This)->lpVtbl -> GetUrlForEvents(This,pUrl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWebBrowserEventsUrlService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_webevnts_0000_0002 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_webevnts_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_webevnts_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Wia.h ===
#if (_WIN32_WINNT >= 0x0600) // Windows Vista and later
#include <wia_lh.h>
#elif (_WIN32_WINNT >= 0x0501) // Windows XP and later
#include <wia_xp.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WebServices.h ===
#ifndef __WEBSERVICES_H__
#define __WEBSERVICES_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <windows.h>
#include <wtypes.h>
#include <wincrypt.h>
#ifdef __cplusplus
extern "C"
{
#endif

//  HANDLES
typedef struct _WS_XML_READER WS_XML_READER;

typedef struct _WS_XML_WRITER WS_XML_WRITER;

typedef struct _WS_XML_BUFFER WS_XML_BUFFER;

typedef struct _WS_CHANNEL WS_CHANNEL;

typedef struct _WS_OPERATION_CONTEXT WS_OPERATION_CONTEXT;

typedef struct _WS_ERROR WS_ERROR;

typedef struct _WS_HEAP WS_HEAP;

typedef struct _WS_LISTENER WS_LISTENER;

typedef struct _WS_MESSAGE WS_MESSAGE;

typedef struct _WS_SECURITY_TOKEN WS_SECURITY_TOKEN;

typedef struct _WS_SECURITY_CONTEXT WS_SECURITY_CONTEXT;

typedef struct _WS_SERVICE_HOST WS_SERVICE_HOST;

typedef struct _WS_SERVICE_PROXY WS_SERVICE_PROXY;

typedef struct _WS_METADATA WS_METADATA;

typedef struct _WS_POLICY WS_POLICY;

//  STRUCT DECLARATIONS
typedef struct _WS_XML_DICTIONARY WS_XML_DICTIONARY;

typedef struct _WS_XML_STRING WS_XML_STRING;

typedef struct _WS_XML_QNAME WS_XML_QNAME;

typedef struct _WS_XML_NODE_POSITION WS_XML_NODE_POSITION;

typedef struct _WS_XML_READER_PROPERTY WS_XML_READER_PROPERTY;

typedef struct _WS_XML_CANONICALIZATION_INCLUSIVE_PREFIXES WS_XML_CANONICALIZATION_INCLUSIVE_PREFIXES;

typedef struct _WS_XML_CANONICALIZATION_PROPERTY WS_XML_CANONICALIZATION_PROPERTY;

typedef struct _WS_XML_WRITER_PROPERTY WS_XML_WRITER_PROPERTY;

typedef struct _WS_XML_BUFFER_PROPERTY WS_XML_BUFFER_PROPERTY;

typedef struct _WS_XML_TEXT WS_XML_TEXT;

typedef struct _WS_XML_UTF8_TEXT WS_XML_UTF8_TEXT;

typedef struct _WS_XML_UTF16_TEXT WS_XML_UTF16_TEXT;

typedef struct _WS_XML_BASE64_TEXT WS_XML_BASE64_TEXT;

typedef struct _WS_XML_BOOL_TEXT WS_XML_BOOL_TEXT;

typedef struct _WS_XML_INT32_TEXT WS_XML_INT32_TEXT;

typedef struct _WS_XML_INT64_TEXT WS_XML_INT64_TEXT;

typedef struct _WS_XML_UINT64_TEXT WS_XML_UINT64_TEXT;

typedef struct _WS_XML_FLOAT_TEXT WS_XML_FLOAT_TEXT;

typedef struct _WS_XML_DOUBLE_TEXT WS_XML_DOUBLE_TEXT;

typedef struct _WS_XML_DECIMAL_TEXT WS_XML_DECIMAL_TEXT;

typedef struct _WS_XML_GUID_TEXT WS_XML_GUID_TEXT;

typedef struct _WS_XML_UNIQUE_ID_TEXT WS_XML_UNIQUE_ID_TEXT;

typedef struct _WS_DATETIME WS_DATETIME;

typedef struct _WS_XML_DATETIME_TEXT WS_XML_DATETIME_TEXT;

typedef struct _WS_TIMESPAN WS_TIMESPAN;

typedef struct _WS_XML_TIMESPAN_TEXT WS_XML_TIMESPAN_TEXT;

typedef struct _WS_XML_QNAME_TEXT WS_XML_QNAME_TEXT;

typedef struct _WS_XML_LIST_TEXT WS_XML_LIST_TEXT;

typedef struct _WS_XML_NODE WS_XML_NODE;

typedef struct _WS_XML_ATTRIBUTE WS_XML_ATTRIBUTE;

typedef struct _WS_XML_ELEMENT_NODE WS_XML_ELEMENT_NODE;

typedef struct _WS_XML_TEXT_NODE WS_XML_TEXT_NODE;

typedef struct _WS_XML_COMMENT_NODE WS_XML_COMMENT_NODE;

typedef struct _WS_XML_READER_INPUT WS_XML_READER_INPUT;

typedef struct _WS_XML_READER_BUFFER_INPUT WS_XML_READER_BUFFER_INPUT;

typedef struct _WS_XML_READER_STREAM_INPUT WS_XML_READER_STREAM_INPUT;

typedef struct _WS_XML_READER_ENCODING WS_XML_READER_ENCODING;

typedef struct _WS_XML_READER_TEXT_ENCODING WS_XML_READER_TEXT_ENCODING;

typedef struct _WS_XML_READER_BINARY_ENCODING WS_XML_READER_BINARY_ENCODING;

typedef struct _WS_STRING WS_STRING;

typedef struct _WS_XML_READER_MTOM_ENCODING WS_XML_READER_MTOM_ENCODING;

typedef struct _WS_XML_READER_RAW_ENCODING WS_XML_READER_RAW_ENCODING;

typedef struct _WS_XML_WRITER_ENCODING WS_XML_WRITER_ENCODING;

typedef struct _WS_XML_WRITER_TEXT_ENCODING WS_XML_WRITER_TEXT_ENCODING;

typedef struct _WS_XML_WRITER_BINARY_ENCODING WS_XML_WRITER_BINARY_ENCODING;

typedef struct _WS_XML_WRITER_MTOM_ENCODING WS_XML_WRITER_MTOM_ENCODING;

typedef struct _WS_XML_WRITER_RAW_ENCODING WS_XML_WRITER_RAW_ENCODING;

typedef struct _WS_XML_WRITER_OUTPUT WS_XML_WRITER_OUTPUT;

typedef struct _WS_XML_WRITER_BUFFER_OUTPUT WS_XML_WRITER_BUFFER_OUTPUT;

typedef struct _WS_XML_WRITER_STREAM_OUTPUT WS_XML_WRITER_STREAM_OUTPUT;

typedef struct _WS_XML_WRITER_PROPERTIES WS_XML_WRITER_PROPERTIES;

typedef struct _WS_XML_READER_PROPERTIES WS_XML_READER_PROPERTIES;

typedef struct _WS_ASYNC_CONTEXT WS_ASYNC_CONTEXT;

typedef struct _WS_ASYNC_STATE WS_ASYNC_STATE;

typedef struct _WS_ASYNC_OPERATION WS_ASYNC_OPERATION;

typedef struct _WS_CHANNEL_PROPERTY WS_CHANNEL_PROPERTY;

typedef struct _WS_CUSTOM_HTTP_PROXY WS_CUSTOM_HTTP_PROXY;

typedef struct _WS_CHANNEL_PROPERTIES WS_CHANNEL_PROPERTIES;

typedef struct _WS_CUSTOM_CHANNEL_CALLBACKS WS_CUSTOM_CHANNEL_CALLBACKS;

typedef struct _WS_HTTP_HEADER_MAPPING WS_HTTP_HEADER_MAPPING;

typedef struct _WS_HTTP_MESSAGE_MAPPING WS_HTTP_MESSAGE_MAPPING;

typedef struct _WS_ELEMENT_DESCRIPTION WS_ELEMENT_DESCRIPTION;

typedef struct _WS_MESSAGE_DESCRIPTION WS_MESSAGE_DESCRIPTION;

typedef struct _WS_CHANNEL_ENCODER WS_CHANNEL_ENCODER;

typedef struct _WS_CHANNEL_DECODER WS_CHANNEL_DECODER;

typedef struct _WS_HTTP_REDIRECT_CALLBACK_CONTEXT WS_HTTP_REDIRECT_CALLBACK_CONTEXT;

typedef struct _WS_ENDPOINT_IDENTITY WS_ENDPOINT_IDENTITY;

typedef struct _WS_ENDPOINT_ADDRESS WS_ENDPOINT_ADDRESS;

typedef struct _WS_DNS_ENDPOINT_IDENTITY WS_DNS_ENDPOINT_IDENTITY;

typedef struct _WS_UPN_ENDPOINT_IDENTITY WS_UPN_ENDPOINT_IDENTITY;

typedef struct _WS_SPN_ENDPOINT_IDENTITY WS_SPN_ENDPOINT_IDENTITY;

typedef struct _WS_BYTES WS_BYTES;

typedef struct _WS_RSA_ENDPOINT_IDENTITY WS_RSA_ENDPOINT_IDENTITY;

typedef struct _WS_CERT_ENDPOINT_IDENTITY WS_CERT_ENDPOINT_IDENTITY;

typedef struct _WS_UNKNOWN_ENDPOINT_IDENTITY WS_UNKNOWN_ENDPOINT_IDENTITY;

typedef struct _WS_ERROR_PROPERTY WS_ERROR_PROPERTY;

typedef struct _WS_FAULT_REASON WS_FAULT_REASON;

typedef struct _WS_FAULT_CODE WS_FAULT_CODE;

typedef struct _WS_FAULT WS_FAULT;

typedef struct _WS_FAULT_DETAIL_DESCRIPTION WS_FAULT_DETAIL_DESCRIPTION;

typedef struct _WS_HEAP_PROPERTY WS_HEAP_PROPERTY;

typedef struct _WS_HEAP_PROPERTIES WS_HEAP_PROPERTIES;

typedef struct _WS_LISTENER_PROPERTY WS_LISTENER_PROPERTY;

typedef struct _WS_DISALLOWED_USER_AGENT_SUBSTRINGS WS_DISALLOWED_USER_AGENT_SUBSTRINGS;

typedef struct _WS_LISTENER_PROPERTIES WS_LISTENER_PROPERTIES;

typedef struct _WS_HOST_NAMES WS_HOST_NAMES;

typedef struct _WS_CUSTOM_LISTENER_CALLBACKS WS_CUSTOM_LISTENER_CALLBACKS;

typedef struct _WS_MESSAGE_PROPERTY WS_MESSAGE_PROPERTY;

typedef struct _WS_MESSAGE_PROPERTIES WS_MESSAGE_PROPERTIES;

typedef struct _WS_SECURITY_ALGORITHM_PROPERTY WS_SECURITY_ALGORITHM_PROPERTY;

typedef struct _WS_SECURITY_ALGORITHM_SUITE WS_SECURITY_ALGORITHM_SUITE;

typedef struct _WS_SECURITY_PROPERTY WS_SECURITY_PROPERTY;

typedef struct _WS_SECURITY_PROPERTIES WS_SECURITY_PROPERTIES;

typedef struct _WS_SECURITY_BINDING_PROPERTY WS_SECURITY_BINDING_PROPERTY;

typedef struct _WS_SECURITY_BINDING_PROPERTIES WS_SECURITY_BINDING_PROPERTIES;

typedef struct _WS_SERVICE_SECURITY_IDENTITIES WS_SERVICE_SECURITY_IDENTITIES;

typedef struct _WS_CERT_CREDENTIAL WS_CERT_CREDENTIAL;

typedef struct _WS_SUBJECT_NAME_CERT_CREDENTIAL WS_SUBJECT_NAME_CERT_CREDENTIAL;

typedef struct _WS_THUMBPRINT_CERT_CREDENTIAL WS_THUMBPRINT_CERT_CREDENTIAL;

typedef struct _WS_CUSTOM_CERT_CREDENTIAL WS_CUSTOM_CERT_CREDENTIAL;

typedef struct _WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL;

typedef struct _WS_STRING_WINDOWS_INTEGRATED_AUTH_CREDENTIAL WS_STRING_WINDOWS_INTEGRATED_AUTH_CREDENTIAL;

typedef struct _WS_DEFAULT_WINDOWS_INTEGRATED_AUTH_CREDENTIAL WS_DEFAULT_WINDOWS_INTEGRATED_AUTH_CREDENTIAL;

typedef struct _WS_OPAQUE_WINDOWS_INTEGRATED_AUTH_CREDENTIAL WS_OPAQUE_WINDOWS_INTEGRATED_AUTH_CREDENTIAL;

typedef struct _WS_USERNAME_CREDENTIAL WS_USERNAME_CREDENTIAL;

typedef struct _WS_STRING_USERNAME_CREDENTIAL WS_STRING_USERNAME_CREDENTIAL;

typedef struct _WS_SECURITY_KEY_HANDLE WS_SECURITY_KEY_HANDLE;

typedef struct _WS_RAW_SYMMETRIC_SECURITY_KEY_HANDLE WS_RAW_SYMMETRIC_SECURITY_KEY_HANDLE;

typedef struct _WS_NCRYPT_ASYMMETRIC_SECURITY_KEY_HANDLE WS_NCRYPT_ASYMMETRIC_SECURITY_KEY_HANDLE;

typedef struct _WS_CAPI_ASYMMETRIC_SECURITY_KEY_HANDLE WS_CAPI_ASYMMETRIC_SECURITY_KEY_HANDLE;

typedef struct _WS_SECURITY_BINDING WS_SECURITY_BINDING;

typedef struct _WS_SSL_TRANSPORT_SECURITY_BINDING WS_SSL_TRANSPORT_SECURITY_BINDING;

typedef struct _WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING;

typedef struct _WS_HTTP_HEADER_AUTH_SECURITY_BINDING WS_HTTP_HEADER_AUTH_SECURITY_BINDING;

typedef struct _WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING;

typedef struct _WS_USERNAME_MESSAGE_SECURITY_BINDING WS_USERNAME_MESSAGE_SECURITY_BINDING;

typedef struct _WS_SECURITY_DESCRIPTION WS_SECURITY_DESCRIPTION;

typedef struct _WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING;

typedef struct _WS_SECURITY_CONTEXT_PROPERTY WS_SECURITY_CONTEXT_PROPERTY;

typedef struct _WS_XML_SECURITY_TOKEN_PROPERTY WS_XML_SECURITY_TOKEN_PROPERTY;

typedef struct _WS_XML_TOKEN_MESSAGE_SECURITY_BINDING WS_XML_TOKEN_MESSAGE_SECURITY_BINDING;

typedef struct _WS_SAML_AUTHENTICATOR WS_SAML_AUTHENTICATOR;

typedef struct _WS_CERT_SIGNED_SAML_AUTHENTICATOR WS_CERT_SIGNED_SAML_AUTHENTICATOR;

typedef struct _WS_SAML_MESSAGE_SECURITY_BINDING WS_SAML_MESSAGE_SECURITY_BINDING;

typedef struct _WS_REQUEST_SECURITY_TOKEN_PROPERTY WS_REQUEST_SECURITY_TOKEN_PROPERTY;

typedef struct _WS_ANY_ATTRIBUTE WS_ANY_ATTRIBUTE;

typedef struct _WS_ANY_ATTRIBUTES WS_ANY_ATTRIBUTES;

typedef struct _WS_BOOL_DESCRIPTION WS_BOOL_DESCRIPTION;

typedef struct _WS_GUID_DESCRIPTION WS_GUID_DESCRIPTION;

typedef struct _WS_DATETIME_DESCRIPTION WS_DATETIME_DESCRIPTION;

typedef struct _WS_DURATION WS_DURATION;

typedef struct _WS_DURATION_DESCRIPTION WS_DURATION_DESCRIPTION;

typedef struct _WS_TIMESPAN_DESCRIPTION WS_TIMESPAN_DESCRIPTION;

typedef struct _WS_UNIQUE_ID_DESCRIPTION WS_UNIQUE_ID_DESCRIPTION;

typedef struct _WS_STRING_DESCRIPTION WS_STRING_DESCRIPTION;

typedef struct _WS_XML_STRING_DESCRIPTION WS_XML_STRING_DESCRIPTION;

typedef struct _WS_XML_QNAME_DESCRIPTION WS_XML_QNAME_DESCRIPTION;

typedef struct _WS_CHAR_ARRAY_DESCRIPTION WS_CHAR_ARRAY_DESCRIPTION;

typedef struct _WS_BYTE_ARRAY_DESCRIPTION WS_BYTE_ARRAY_DESCRIPTION;

typedef struct _WS_UTF8_ARRAY_DESCRIPTION WS_UTF8_ARRAY_DESCRIPTION;

typedef struct _WS_WSZ_DESCRIPTION WS_WSZ_DESCRIPTION;

typedef struct _WS_INT8_DESCRIPTION WS_INT8_DESCRIPTION;

typedef struct _WS_UINT8_DESCRIPTION WS_UINT8_DESCRIPTION;

typedef struct _WS_INT16_DESCRIPTION WS_INT16_DESCRIPTION;

typedef struct _WS_UINT16_DESCRIPTION WS_UINT16_DESCRIPTION;

typedef struct _WS_INT32_DESCRIPTION WS_INT32_DESCRIPTION;

typedef struct _WS_UINT32_DESCRIPTION WS_UINT32_DESCRIPTION;

typedef struct _WS_INT64_DESCRIPTION WS_INT64_DESCRIPTION;

typedef struct _WS_UINT64_DESCRIPTION WS_UINT64_DESCRIPTION;

typedef struct _WS_FLOAT_DESCRIPTION WS_FLOAT_DESCRIPTION;

typedef struct _WS_DOUBLE_DESCRIPTION WS_DOUBLE_DESCRIPTION;

typedef struct _WS_DECIMAL_DESCRIPTION WS_DECIMAL_DESCRIPTION;

typedef struct _WS_BYTES_DESCRIPTION WS_BYTES_DESCRIPTION;

typedef struct _WS_ENUM_VALUE WS_ENUM_VALUE;

typedef struct _WS_ENUM_DESCRIPTION WS_ENUM_DESCRIPTION;

typedef struct _WS_ITEM_RANGE WS_ITEM_RANGE;

typedef struct _WS_DEFAULT_VALUE WS_DEFAULT_VALUE;

typedef struct _WS_FIELD_DESCRIPTION WS_FIELD_DESCRIPTION;

typedef struct _WS_UNION_FIELD_DESCRIPTION WS_UNION_FIELD_DESCRIPTION;

typedef struct _WS_STRUCT_DESCRIPTION WS_STRUCT_DESCRIPTION;

typedef struct _WS_UNION_DESCRIPTION WS_UNION_DESCRIPTION;

typedef struct _WS_ENDPOINT_ADDRESS_DESCRIPTION WS_ENDPOINT_ADDRESS_DESCRIPTION;

typedef struct _WS_FAULT_DESCRIPTION WS_FAULT_DESCRIPTION;

typedef struct _WS_VOID_DESCRIPTION WS_VOID_DESCRIPTION;

typedef struct _WS_CUSTOM_TYPE_DESCRIPTION WS_CUSTOM_TYPE_DESCRIPTION;

typedef struct _WS_ATTRIBUTE_DESCRIPTION WS_ATTRIBUTE_DESCRIPTION;

typedef struct _WS_PARAMETER_DESCRIPTION WS_PARAMETER_DESCRIPTION;

typedef struct _WS_OPERATION_DESCRIPTION WS_OPERATION_DESCRIPTION;

typedef struct _WS_CONTRACT_DESCRIPTION WS_CONTRACT_DESCRIPTION;

typedef struct _WS_SERVICE_CONTRACT WS_SERVICE_CONTRACT;

typedef struct _WS_SERVICE_PROPERTY WS_SERVICE_PROPERTY;

typedef struct _WS_SERVICE_ENDPOINT_PROPERTY WS_SERVICE_ENDPOINT_PROPERTY;

typedef struct _WS_SERVICE_PROPERTY_ACCEPT_CALLBACK WS_SERVICE_PROPERTY_ACCEPT_CALLBACK;

typedef struct _WS_SERVICE_METADATA_DOCUMENT WS_SERVICE_METADATA_DOCUMENT;

typedef struct _WS_SERVICE_METADATA WS_SERVICE_METADATA;

typedef struct _WS_SERVICE_PROPERTY_CLOSE_CALLBACK WS_SERVICE_PROPERTY_CLOSE_CALLBACK;

typedef struct _WS_SERVICE_ENDPOINT_METADATA WS_SERVICE_ENDPOINT_METADATA;

typedef struct _WS_SERVICE_ENDPOINT WS_SERVICE_ENDPOINT;

typedef struct _WS_PROXY_PROPERTY WS_PROXY_PROPERTY;

typedef struct _WS_PROXY_MESSAGE_CALLBACK_CONTEXT WS_PROXY_MESSAGE_CALLBACK_CONTEXT;

typedef struct _WS_CALL_PROPERTY WS_CALL_PROPERTY;

typedef struct _WS_URL WS_URL;

typedef struct _WS_HTTP_URL WS_HTTP_URL;

typedef struct _WS_HTTPS_URL WS_HTTPS_URL;

typedef struct _WS_NETTCP_URL WS_NETTCP_URL;

typedef struct _WS_SOAPUDP_URL WS_SOAPUDP_URL;

typedef struct _WS_UNIQUE_ID WS_UNIQUE_ID;

typedef struct _WS_BUFFERS WS_BUFFERS;

typedef struct _WS_METADATA_ENDPOINT WS_METADATA_ENDPOINT;

typedef struct _WS_METADATA_ENDPOINTS WS_METADATA_ENDPOINTS;

typedef struct _WS_METADATA_PROPERTY WS_METADATA_PROPERTY;

typedef struct _WS_POLICY_PROPERTY WS_POLICY_PROPERTY;

typedef struct _WS_POLICY_PROPERTIES WS_POLICY_PROPERTIES;

typedef struct _WS_SECURITY_BINDING_PROPERTY_CONSTRAINT WS_SECURITY_BINDING_PROPERTY_CONSTRAINT;

typedef struct _WS_SECURITY_BINDING_CONSTRAINT WS_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_SSL_TRANSPORT_SECURITY_BINDING_CONSTRAINT WS_SSL_TRANSPORT_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_USERNAME_MESSAGE_SECURITY_BINDING_CONSTRAINT WS_USERNAME_MESSAGE_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_HTTP_HEADER_AUTH_SECURITY_BINDING_CONSTRAINT WS_HTTP_HEADER_AUTH_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_CONSTRAINT WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_CERT_MESSAGE_SECURITY_BINDING_CONSTRAINT WS_CERT_MESSAGE_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_CONSTRAINT WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_REQUEST_SECURITY_TOKEN_PROPERTY_CONSTRAINT WS_REQUEST_SECURITY_TOKEN_PROPERTY_CONSTRAINT;

typedef struct _WS_ISSUED_TOKEN_MESSAGE_SECURITY_BINDING_CONSTRAINT WS_ISSUED_TOKEN_MESSAGE_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_SECURITY_PROPERTY_CONSTRAINT WS_SECURITY_PROPERTY_CONSTRAINT;

typedef struct _WS_SECURITY_CONSTRAINTS WS_SECURITY_CONSTRAINTS;

typedef struct _WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_CONSTRAINT WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_CONSTRAINT;

typedef struct _WS_CHANNEL_PROPERTY_CONSTRAINT WS_CHANNEL_PROPERTY_CONSTRAINT;

typedef struct _WS_POLICY_EXTENSION WS_POLICY_EXTENSION;

typedef struct _WS_ENDPOINT_POLICY_EXTENSION WS_ENDPOINT_POLICY_EXTENSION;

typedef struct _WS_POLICY_CONSTRAINTS WS_POLICY_CONSTRAINTS;

typedef struct _WS_HTTP_POLICY_DESCRIPTION WS_HTTP_POLICY_DESCRIPTION;

typedef struct _WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_SSL_POLICY_DESCRIPTION WS_HTTP_SSL_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_HEADER_AUTH_SECURITY_BINDING_POLICY_DESCRIPTION WS_HTTP_HEADER_AUTH_SECURITY_BINDING_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_HEADER_AUTH_POLICY_DESCRIPTION WS_HTTP_HEADER_AUTH_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_SSL_HEADER_AUTH_POLICY_DESCRIPTION WS_HTTP_SSL_HEADER_AUTH_POLICY_DESCRIPTION;

typedef struct _WS_USERNAME_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION WS_USERNAME_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_SSL_USERNAME_POLICY_DESCRIPTION WS_HTTP_SSL_USERNAME_POLICY_DESCRIPTION;

typedef struct _WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_SSL_KERBEROS_APREQ_POLICY_DESCRIPTION WS_HTTP_SSL_KERBEROS_APREQ_POLICY_DESCRIPTION;

typedef struct _WS_TCP_POLICY_DESCRIPTION WS_TCP_POLICY_DESCRIPTION;

typedef struct _WS_SSPI_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION WS_SSPI_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION;

typedef struct _WS_TCP_SSPI_POLICY_DESCRIPTION WS_TCP_SSPI_POLICY_DESCRIPTION;

typedef struct _WS_TCP_SSPI_USERNAME_POLICY_DESCRIPTION WS_TCP_SSPI_USERNAME_POLICY_DESCRIPTION;

typedef struct _WS_TCP_SSPI_KERBEROS_APREQ_POLICY_DESCRIPTION WS_TCP_SSPI_KERBEROS_APREQ_POLICY_DESCRIPTION;

typedef struct _WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION;

typedef struct _WS_SECURITY_CONTEXT_SECURITY_BINDING_POLICY_DESCRIPTION WS_SECURITY_CONTEXT_SECURITY_BINDING_POLICY_DESCRIPTION;

typedef struct _WS_TCP_SSPI_KERBEROS_APREQ_SECURITY_CONTEXT_POLICY_DESCRIPTION WS_TCP_SSPI_KERBEROS_APREQ_SECURITY_CONTEXT_POLICY_DESCRIPTION;

typedef struct _WS_TCP_SSPI_USERNAME_SECURITY_CONTEXT_POLICY_DESCRIPTION WS_TCP_SSPI_USERNAME_SECURITY_CONTEXT_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_SSL_USERNAME_SECURITY_CONTEXT_POLICY_DESCRIPTION WS_HTTP_SSL_USERNAME_SECURITY_CONTEXT_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_SSL_KERBEROS_APREQ_SECURITY_CONTEXT_POLICY_DESCRIPTION WS_HTTP_SSL_KERBEROS_APREQ_SECURITY_CONTEXT_POLICY_DESCRIPTION;

typedef struct _WS_HTTP_BINDING_TEMPLATE WS_HTTP_BINDING_TEMPLATE;

typedef struct _WS_TCP_BINDING_TEMPLATE WS_TCP_BINDING_TEMPLATE;

typedef struct _WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE;

typedef struct _WS_HTTP_SSL_BINDING_TEMPLATE WS_HTTP_SSL_BINDING_TEMPLATE;

typedef struct _WS_HTTP_HEADER_AUTH_SECURITY_BINDING_TEMPLATE WS_HTTP_HEADER_AUTH_SECURITY_BINDING_TEMPLATE;

typedef struct _WS_HTTP_HEADER_AUTH_BINDING_TEMPLATE WS_HTTP_HEADER_AUTH_BINDING_TEMPLATE;

typedef struct _WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TEMPLATE WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TEMPLATE;

typedef struct _WS_TCP_SSPI_BINDING_TEMPLATE WS_TCP_SSPI_BINDING_TEMPLATE;

typedef struct _WS_HTTP_SSL_HEADER_AUTH_BINDING_TEMPLATE WS_HTTP_SSL_HEADER_AUTH_BINDING_TEMPLATE;

typedef struct _WS_USERNAME_MESSAGE_SECURITY_BINDING_TEMPLATE WS_USERNAME_MESSAGE_SECURITY_BINDING_TEMPLATE;

typedef struct _WS_HTTP_SSL_USERNAME_BINDING_TEMPLATE WS_HTTP_SSL_USERNAME_BINDING_TEMPLATE;

typedef struct _WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_TEMPLATE WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_TEMPLATE;

typedef struct _WS_HTTP_SSL_KERBEROS_APREQ_BINDING_TEMPLATE WS_HTTP_SSL_KERBEROS_APREQ_BINDING_TEMPLATE;

typedef struct _WS_TCP_SSPI_USERNAME_BINDING_TEMPLATE WS_TCP_SSPI_USERNAME_BINDING_TEMPLATE;

typedef struct _WS_TCP_SSPI_KERBEROS_APREQ_BINDING_TEMPLATE WS_TCP_SSPI_KERBEROS_APREQ_BINDING_TEMPLATE;

typedef struct _WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_TEMPLATE WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_TEMPLATE;

typedef struct _WS_SECURITY_CONTEXT_SECURITY_BINDING_TEMPLATE WS_SECURITY_CONTEXT_SECURITY_BINDING_TEMPLATE;

typedef struct _WS_HTTP_SSL_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE WS_HTTP_SSL_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE;

typedef struct _WS_HTTP_SSL_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE WS_HTTP_SSL_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE;

typedef struct _WS_TCP_SSPI_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE WS_TCP_SSPI_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE;

typedef struct _WS_TCP_SSPI_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE WS_TCP_SSPI_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE;

//  ENUM DEFINITIONS

//  XML Reader enum
//  
//   Each xml reader property is identified by an ID and has an associated
//  value.
//  
typedef enum
{
    WS_XML_READER_PROPERTY_MAX_DEPTH                              = 0,
    WS_XML_READER_PROPERTY_ALLOW_FRAGMENT                         = 1,
    WS_XML_READER_PROPERTY_MAX_ATTRIBUTES                         = 2,
    WS_XML_READER_PROPERTY_READ_DECLARATION                       = 3,
    WS_XML_READER_PROPERTY_CHARSET                                = 4,
    WS_XML_READER_PROPERTY_ROW                                    = 5,
    WS_XML_READER_PROPERTY_COLUMN                                 = 6,
    WS_XML_READER_PROPERTY_UTF8_TRIM_SIZE                         = 7,
    WS_XML_READER_PROPERTY_STREAM_BUFFER_SIZE                     = 8,
    WS_XML_READER_PROPERTY_IN_ATTRIBUTE                           = 9,
    WS_XML_READER_PROPERTY_STREAM_MAX_ROOT_MIME_PART_SIZE         = 10,
    WS_XML_READER_PROPERTY_STREAM_MAX_MIME_HEADERS_SIZE           = 11,
    WS_XML_READER_PROPERTY_MAX_MIME_PARTS                         = 12,
    WS_XML_READER_PROPERTY_ALLOW_INVALID_CHARACTER_REFERENCES     = 13,
    WS_XML_READER_PROPERTY_MAX_NAMESPACES                         = 14,
} WS_XML_READER_PROPERTY_ID;



//  XML Canonicalization enum
//  
//   Defines the values for the XML canonicalization algorithms.
//  
typedef enum
{
    WS_EXCLUSIVE_XML_CANONICALIZATION_ALGORITHM                   = 0,
    WS_EXCLUSIVE_WITH_COMMENTS_XML_CANONICALIZATION_ALGORITHM     = 1,
    WS_INCLUSIVE_XML_CANONICALIZATION_ALGORITHM                   = 2,
    WS_INCLUSIVE_WITH_COMMENTS_XML_CANONICALIZATION_ALGORITHM     = 3,
} WS_XML_CANONICALIZATION_ALGORITHM;



//  XML Canonicalization enum
//  
//   Each XML canonicalization property is identified by an ID and has an associated
//  value.
//  
typedef enum
{
    WS_XML_CANONICALIZATION_PROPERTY_ALGORITHM              = 0,
    WS_XML_CANONICALIZATION_PROPERTY_INCLUSIVE_PREFIXES     = 1,
    WS_XML_CANONICALIZATION_PROPERTY_OMITTED_ELEMENT        = 2,
    WS_XML_CANONICALIZATION_PROPERTY_OUTPUT_BUFFER_SIZE     = 3,
} WS_XML_CANONICALIZATION_PROPERTY_ID;



//  XML Writer enum
//  
//   Each xml writer property is identified by an ID and has an associated value.
//  
typedef enum
{
    WS_XML_WRITER_PROPERTY_MAX_DEPTH                              = 0,
    WS_XML_WRITER_PROPERTY_ALLOW_FRAGMENT                         = 1,
    WS_XML_WRITER_PROPERTY_MAX_ATTRIBUTES                         = 2,
    WS_XML_WRITER_PROPERTY_WRITE_DECLARATION                      = 3,
    WS_XML_WRITER_PROPERTY_INDENT                                 = 4,
    WS_XML_WRITER_PROPERTY_BUFFER_TRIM_SIZE                       = 5,
    WS_XML_WRITER_PROPERTY_CHARSET                                = 6,
    WS_XML_WRITER_PROPERTY_BUFFERS                                = 7,
    WS_XML_WRITER_PROPERTY_BUFFER_MAX_SIZE                        = 8,
    WS_XML_WRITER_PROPERTY_BYTES                                  = 9,
    WS_XML_WRITER_PROPERTY_IN_ATTRIBUTE                           = 10,
    WS_XML_WRITER_PROPERTY_MAX_MIME_PARTS_BUFFER_SIZE             = 11,
    WS_XML_WRITER_PROPERTY_INITIAL_BUFFER                         = 12,
    WS_XML_WRITER_PROPERTY_ALLOW_INVALID_CHARACTER_REFERENCES     = 13,
    WS_XML_WRITER_PROPERTY_MAX_NAMESPACES                         = 14,
    WS_XML_WRITER_PROPERTY_BYTES_WRITTEN                          = 15,
    WS_XML_WRITER_PROPERTY_BYTES_TO_CLOSE                         = 16,
    WS_XML_WRITER_PROPERTY_COMPRESS_EMPTY_ELEMENTS                = 17,
} WS_XML_WRITER_PROPERTY_ID;



//  XML Buffer enum
//  
//   Each xml buffer property is identified by an ID and has an associated
//  value.
//  
typedef enum
{
} WS_XML_BUFFER_PROPERTY_ID;



//  XML Node enum
//  
//   Indicates the type of WS_XML_TEXT structure.
//  
typedef enum
{
    WS_XML_TEXT_TYPE_UTF8          = 1,
    WS_XML_TEXT_TYPE_UTF16         = 2,
    WS_XML_TEXT_TYPE_BASE64        = 3,
    WS_XML_TEXT_TYPE_BOOL          = 4,
    WS_XML_TEXT_TYPE_INT32         = 5,
    WS_XML_TEXT_TYPE_INT64         = 6,
    WS_XML_TEXT_TYPE_UINT64        = 7,
    WS_XML_TEXT_TYPE_FLOAT         = 8,
    WS_XML_TEXT_TYPE_DOUBLE        = 9,
    WS_XML_TEXT_TYPE_DECIMAL       = 10,
    WS_XML_TEXT_TYPE_GUID          = 11,
    WS_XML_TEXT_TYPE_UNIQUE_ID     = 12,
    WS_XML_TEXT_TYPE_DATETIME      = 13,
    WS_XML_TEXT_TYPE_TIMESPAN      = 14,
    WS_XML_TEXT_TYPE_QNAME         = 15,
    WS_XML_TEXT_TYPE_LIST          = 16,
} WS_XML_TEXT_TYPE;



//  XML Node enum
//  
//   Indicates the type of WS_XML_NODE structure.
//  
typedef enum
{
    WS_XML_NODE_TYPE_ELEMENT         = 1,
    WS_XML_NODE_TYPE_TEXT            = 2,
    WS_XML_NODE_TYPE_END_ELEMENT     = 3,
    WS_XML_NODE_TYPE_COMMENT         = 4,
    WS_XML_NODE_TYPE_CDATA           = 6,
    WS_XML_NODE_TYPE_END_CDATA       = 7,
    WS_XML_NODE_TYPE_EOF             = 8,
    WS_XML_NODE_TYPE_BOF             = 9,
} WS_XML_NODE_TYPE;



//  XML Buffer enum
//  
//   This enumeration identifies the various ways to move about an xml document.
//  
typedef enum
{
    WS_MOVE_TO_ROOT_ELEMENT         = 0,
    WS_MOVE_TO_NEXT_ELEMENT         = 1,
    WS_MOVE_TO_PREVIOUS_ELEMENT     = 2,
    WS_MOVE_TO_CHILD_ELEMENT        = 3,
    WS_MOVE_TO_END_ELEMENT          = 4,
    WS_MOVE_TO_PARENT_ELEMENT       = 5,
    WS_MOVE_TO_NEXT_NODE            = 6,
    WS_MOVE_TO_PREVIOUS_NODE        = 7,
    WS_MOVE_TO_FIRST_NODE           = 8,
    WS_MOVE_TO_BOF                  = 9,
    WS_MOVE_TO_EOF                  = 10,
    WS_MOVE_TO_CHILD_NODE           = 11,
} WS_MOVE_TO;



//  XML Node enum
//  
//   An enumeration of the different types of fixed-size primitives.
//  
typedef enum
{
    WS_BOOL_VALUE_TYPE         = 0,
    WS_INT8_VALUE_TYPE         = 1,
    WS_INT16_VALUE_TYPE        = 2,
    WS_INT32_VALUE_TYPE        = 3,
    WS_INT64_VALUE_TYPE        = 4,
    WS_UINT8_VALUE_TYPE        = 5,
    WS_UINT16_VALUE_TYPE       = 6,
    WS_UINT32_VALUE_TYPE       = 7,
    WS_UINT64_VALUE_TYPE       = 8,
    WS_FLOAT_VALUE_TYPE        = 9,
    WS_DOUBLE_VALUE_TYPE       = 10,
    WS_DECIMAL_VALUE_TYPE      = 11,
    WS_DATETIME_VALUE_TYPE     = 12,
    WS_TIMESPAN_VALUE_TYPE     = 13,
    WS_GUID_VALUE_TYPE         = 14,
    WS_DURATION_VALUE_TYPE     = 15,
} WS_VALUE_TYPE;



//  XML Reader enum
//  
//   Indicates the type of WS_XML_READER_INPUT structure.
//  
typedef enum
{
    WS_XML_READER_INPUT_TYPE_BUFFER     = 1,
    WS_XML_READER_INPUT_TYPE_STREAM     = 2,
} WS_XML_READER_INPUT_TYPE;



//  XML Reader enum
//  
//   Indicates the type of WS_XML_READER_ENCODING structure.
//  
typedef enum
{
    WS_XML_READER_ENCODING_TYPE_TEXT       = 1,
    WS_XML_READER_ENCODING_TYPE_BINARY     = 2,
    WS_XML_READER_ENCODING_TYPE_MTOM       = 3,
    WS_XML_READER_ENCODING_TYPE_RAW        = 4,
} WS_XML_READER_ENCODING_TYPE;



//  XML Writer enum

typedef enum
{
    WS_CHARSET_AUTO        = 0,
    WS_CHARSET_UTF8        = 1,
    WS_CHARSET_UTF16LE     = 2,
    WS_CHARSET_UTF16BE     = 3,
} WS_CHARSET;



//  XML Writer enum
//  
//   Indicates the type of WS_XML_WRITER_ENCODING structure.
//  
typedef enum
{
    WS_XML_WRITER_ENCODING_TYPE_TEXT       = 1,
    WS_XML_WRITER_ENCODING_TYPE_BINARY     = 2,
    WS_XML_WRITER_ENCODING_TYPE_MTOM       = 3,
    WS_XML_WRITER_ENCODING_TYPE_RAW        = 4,
} WS_XML_WRITER_ENCODING_TYPE;



//  XML Writer enum
//  
//   Indicates the type of WS_XML_WRITER_OUTPUT structure.
//  
typedef enum
{
    WS_XML_WRITER_OUTPUT_TYPE_BUFFER     = 1,
    WS_XML_WRITER_OUTPUT_TYPE_STREAM     = 2,
} WS_XML_WRITER_OUTPUT_TYPE;



//  Async Model enum
//  
//   Used to specify the threading behavior of a callback (for example, a WS_ASYNC_CALLBACK).
//  
typedef enum
{
    WS_SHORT_CALLBACK     = 0,
    WS_LONG_CALLBACK      = 1,
} WS_CALLBACK_MODEL;



//  Channel enum
//  
//   An enumeration of the different encodings (message formats).
typedef enum
{
    WS_ENCODING_XML_BINARY_1             = 0,
    WS_ENCODING_XML_BINARY_SESSION_1     = 1,
    WS_ENCODING_XML_MTOM_UTF8            = 2,
    WS_ENCODING_XML_MTOM_UTF16BE         = 3,
    WS_ENCODING_XML_MTOM_UTF16LE         = 4,
    WS_ENCODING_XML_UTF8                 = 5,
    WS_ENCODING_XML_UTF16BE              = 6,
    WS_ENCODING_XML_UTF16LE              = 7,
    WS_ENCODING_RAW                      = 8,
} WS_ENCODING;



//  Channel enum
//  An enumeration of the different states that a channel can be in.
typedef enum
{
    WS_CHANNEL_STATE_CREATED       = 0,
    WS_CHANNEL_STATE_OPENING       = 1,
    WS_CHANNEL_STATE_ACCEPTING     = 2,
    WS_CHANNEL_STATE_OPEN          = 3,
    WS_CHANNEL_STATE_FAULTED       = 4,
    WS_CHANNEL_STATE_CLOSING       = 5,
    WS_CHANNEL_STATE_CLOSED        = 6,
} WS_CHANNEL_STATE;



//  Channel enum
//  
//   Specifies whether a message is required or not when receiving from a channel.
//  
typedef enum
{
    WS_RECEIVE_REQUIRED_MESSAGE     = 1,
    WS_RECEIVE_OPTIONAL_MESSAGE     = 2,
} WS_RECEIVE_OPTION;



//  Channel enum
//  
//   The channel binding indicates the protocol stack to use for the channel.
//  
typedef enum
{
    WS_HTTP_CHANNEL_BINDING       = 0,
    WS_TCP_CHANNEL_BINDING        = 1,
    WS_UDP_CHANNEL_BINDING        = 2,
    WS_CUSTOM_CHANNEL_BINDING     = 3,
} WS_CHANNEL_BINDING;



//  Channel enum
//  
//   The channel type indicates the basic characteristics of the channel, such as whether it is
//  sessionful, and what directions of communication are supported.
//  
typedef enum
{
    WS_CHANNEL_TYPE_INPUT              = 0x1,
    WS_CHANNEL_TYPE_OUTPUT             = 0x2,
    WS_CHANNEL_TYPE_SESSION            = 0x4,
    WS_CHANNEL_TYPE_INPUT_SESSION      = (WS_CHANNEL_TYPE_INPUT | WS_CHANNEL_TYPE_SESSION),
    WS_CHANNEL_TYPE_OUTPUT_SESSION     = (WS_CHANNEL_TYPE_OUTPUT | WS_CHANNEL_TYPE_SESSION),
    WS_CHANNEL_TYPE_DUPLEX             = (WS_CHANNEL_TYPE_INPUT | WS_CHANNEL_TYPE_OUTPUT),
    WS_CHANNEL_TYPE_DUPLEX_SESSION     = (WS_CHANNEL_TYPE_INPUT | WS_CHANNEL_TYPE_OUTPUT | WS_CHANNEL_TYPE_SESSION),
    WS_CHANNEL_TYPE_REQUEST            = 0x8,
    WS_CHANNEL_TYPE_REPLY              = 0x10,
} WS_CHANNEL_TYPE;



//  Channel enum
//  
//   The transfer mode indicates whether messages that are sent or received are streamed or buffered.
//  
typedef enum
{
    WS_STREAMED_INPUT_TRANSFER_MODE      = 0x1,
    WS_STREAMED_OUTPUT_TRANSFER_MODE     = 0x2,
    WS_BUFFERED_TRANSFER_MODE            = 0x0,
    WS_STREAMED_TRANSFER_MODE            = (WS_STREAMED_INPUT_TRANSFER_MODE | WS_STREAMED_OUTPUT_TRANSFER_MODE),
} WS_TRANSFER_MODE;



//  Channel enum
//  
//   Proxy setting indicates HTTP proxy setting for the channel with binding WS_HTTP_CHANNEL_BINDING.
//  This is specified as part of WS_CHANNEL_PROPERTY_HTTP_PROXY_SETTING_MODE channel property.
//  
typedef enum
{
    WS_HTTP_PROXY_SETTING_MODE_AUTO       = 0x1,
    WS_HTTP_PROXY_SETTING_MODE_NONE       = 0x2,
    WS_HTTP_PROXY_SETTING_MODE_CUSTOM     = 0x3,
} WS_HTTP_PROXY_SETTING_MODE;



//  Channel enum
//  
//   Each channel property is identified by an ID and has an associated
//  value.  If a property is not specified when the channel is created,
//  then its default value is used.
//  
typedef enum
{
    WS_CHANNEL_PROPERTY_MAX_BUFFERED_MESSAGE_SIZE                = 0,
    WS_CHANNEL_PROPERTY_MAX_STREAMED_MESSAGE_SIZE                = 1,
    WS_CHANNEL_PROPERTY_MAX_STREAMED_START_SIZE                  = 2,
    WS_CHANNEL_PROPERTY_MAX_STREAMED_FLUSH_SIZE                  = 3,
    WS_CHANNEL_PROPERTY_ENCODING                                 = 4,
    WS_CHANNEL_PROPERTY_ENVELOPE_VERSION                         = 5,
    WS_CHANNEL_PROPERTY_ADDRESSING_VERSION                       = 6,
    WS_CHANNEL_PROPERTY_MAX_SESSION_DICTIONARY_SIZE              = 7,
    WS_CHANNEL_PROPERTY_STATE                                    = 8,
    WS_CHANNEL_PROPERTY_ASYNC_CALLBACK_MODEL                     = 9,
    WS_CHANNEL_PROPERTY_IP_VERSION                               = 10,
    WS_CHANNEL_PROPERTY_RESOLVE_TIMEOUT                          = 11,
    WS_CHANNEL_PROPERTY_CONNECT_TIMEOUT                          = 12,
    WS_CHANNEL_PROPERTY_SEND_TIMEOUT                             = 13,
    WS_CHANNEL_PROPERTY_RECEIVE_RESPONSE_TIMEOUT                 = 14,
    WS_CHANNEL_PROPERTY_RECEIVE_TIMEOUT                          = 15,
    WS_CHANNEL_PROPERTY_CLOSE_TIMEOUT                            = 16,
    WS_CHANNEL_PROPERTY_ENABLE_TIMEOUTS                          = 17,
    WS_CHANNEL_PROPERTY_TRANSFER_MODE                            = 18,
    WS_CHANNEL_PROPERTY_MULTICAST_INTERFACE                      = 19,
    WS_CHANNEL_PROPERTY_MULTICAST_HOPS                           = 20,
    WS_CHANNEL_PROPERTY_REMOTE_ADDRESS                           = 21,
    WS_CHANNEL_PROPERTY_REMOTE_IP_ADDRESS                        = 22,
    WS_CHANNEL_PROPERTY_HTTP_CONNECTION_ID                       = 23,
    WS_CHANNEL_PROPERTY_CUSTOM_CHANNEL_CALLBACKS                 = 24,
    WS_CHANNEL_PROPERTY_CUSTOM_CHANNEL_PARAMETERS                = 25,
    WS_CHANNEL_PROPERTY_CUSTOM_CHANNEL_INSTANCE                  = 26,
    WS_CHANNEL_PROPERTY_TRANSPORT_URL                            = 27,
    WS_CHANNEL_PROPERTY_NO_DELAY                                 = 28,
    WS_CHANNEL_PROPERTY_SEND_KEEP_ALIVES                         = 29,
    WS_CHANNEL_PROPERTY_KEEP_ALIVE_TIME                          = 30,
    WS_CHANNEL_PROPERTY_KEEP_ALIVE_INTERVAL                      = 31,
    WS_CHANNEL_PROPERTY_MAX_HTTP_SERVER_CONNECTIONS              = 32,
    WS_CHANNEL_PROPERTY_IS_SESSION_SHUT_DOWN                     = 33,
    WS_CHANNEL_PROPERTY_CHANNEL_TYPE                             = 34,
    WS_CHANNEL_PROPERTY_TRIM_BUFFERED_MESSAGE_SIZE               = 35,
    WS_CHANNEL_PROPERTY_ENCODER                                  = 36,
    WS_CHANNEL_PROPERTY_DECODER                                  = 37,
    WS_CHANNEL_PROPERTY_PROTECTION_LEVEL                         = 38,
    WS_CHANNEL_PROPERTY_COOKIE_MODE                              = 39,
    WS_CHANNEL_PROPERTY_HTTP_PROXY_SETTING_MODE                  = 40,
    WS_CHANNEL_PROPERTY_CUSTOM_HTTP_PROXY                        = 41,
    WS_CHANNEL_PROPERTY_HTTP_MESSAGE_MAPPING                     = 42,
    WS_CHANNEL_PROPERTY_ENABLE_HTTP_REDIRECT                     = 43,
    WS_CHANNEL_PROPERTY_HTTP_REDIRECT_CALLBACK_CONTEXT           = 44,
    WS_CHANNEL_PROPERTY_FAULTS_AS_ERRORS                         = 45,
    WS_CHANNEL_PROPERTY_ALLOW_UNSECURED_FAULTS                   = 46,
    WS_CHANNEL_PROPERTY_HTTP_SERVER_SPN                          = 47,
    WS_CHANNEL_PROPERTY_HTTP_PROXY_SPN                           = 48,
    WS_CHANNEL_PROPERTY_MAX_HTTP_REQUEST_HEADERS_BUFFER_SIZE     = 49,
} WS_CHANNEL_PROPERTY_ID;



//  Channel enum
//  
//   A set of flags that control how mapped headers appear in an HTTP request or response.
//  
enum
{
    WS_HTTP_HEADER_MAPPING_COMMA_SEPARATOR         = 0x1,
    WS_HTTP_HEADER_MAPPING_SEMICOLON_SEPARATOR     = 0x2,
    WS_HTTP_HEADER_MAPPING_QUOTED_VALUE            = 0x4,
};



//  Channel enum
//  
//   A set of flags that control how HTTP responses
//  are mapped to the message object.
//  
enum
{
    WS_HTTP_RESPONSE_MAPPING_STATUS_CODE     = 0x1,
    WS_HTTP_RESPONSE_MAPPING_STATUS_TEXT     = 0x2,
};



//  Channel enum
//  
//   A set of flags that control how HTTP requests
//  are mapped to the message object.
//  
enum
{
    WS_HTTP_REQUEST_MAPPING_VERB     = 0x2,
};



//  Channel enum
//  
//   An enumeration used to specify how to handle HTTP cookies.
//  
typedef enum
{
    WS_MANUAL_COOKIE_MODE     = 1,
    WS_AUTO_COOKIE_MODE       = 2,
} WS_COOKIE_MODE;



//  Context enum
//  
//   Each property represents a property available on the Context. Not all properties may be available
//  at a given point on a context. All context properties are available through WsGetOperationContextProperty.
//  
typedef enum
{
    WS_OPERATION_CONTEXT_PROPERTY_CHANNEL                  = 0,
    WS_OPERATION_CONTEXT_PROPERTY_CONTRACT_DESCRIPTION     = 1,
    WS_OPERATION_CONTEXT_PROPERTY_HOST_USER_STATE          = 2,
    WS_OPERATION_CONTEXT_PROPERTY_CHANNEL_USER_STATE       = 3,
    WS_OPERATION_CONTEXT_PROPERTY_INPUT_MESSAGE            = 4,
    WS_OPERATION_CONTEXT_PROPERTY_OUTPUT_MESSAGE           = 5,
    WS_OPERATION_CONTEXT_PROPERTY_HEAP                     = 6,
    WS_OPERATION_CONTEXT_PROPERTY_LISTENER                 = 7,
    WS_OPERATION_CONTEXT_PROPERTY_ENDPOINT_ADDRESS         = 8,
} WS_OPERATION_CONTEXT_PROPERTY_ID;



//  Endpoint Identity enum
//  
//   The type of the endpoint identity, used as a selector for subtypes of
//   WS_ENDPOINT_IDENTITY.
//  
typedef enum
{
    WS_DNS_ENDPOINT_IDENTITY_TYPE         = 1,
    WS_UPN_ENDPOINT_IDENTITY_TYPE         = 2,
    WS_SPN_ENDPOINT_IDENTITY_TYPE         = 3,
    WS_RSA_ENDPOINT_IDENTITY_TYPE         = 4,
    WS_CERT_ENDPOINT_IDENTITY_TYPE        = 5,
    WS_UNKNOWN_ENDPOINT_IDENTITY_TYPE     = 6,
} WS_ENDPOINT_IDENTITY_TYPE;



//  Endpoint Identity enum
//  
//   This identifies a type of extension within the extensions field of the
//   WS_ENDPOINT_ADDRESS.
//  
typedef enum
{
    WS_ENDPOINT_ADDRESS_EXTENSION_METADATA_ADDRESS     = 1,
} WS_ENDPOINT_ADDRESS_EXTENSION_TYPE;



//  Errors enum
//  
//   A set of property values associated with the error.  They are set
//  and retrieved using WsGetErrorProperty and
//   WsSetErrorProperty.
//  
typedef enum
{
    WS_ERROR_PROPERTY_STRING_COUNT            = 0,
    WS_ERROR_PROPERTY_ORIGINAL_ERROR_CODE     = 1,
    WS_ERROR_PROPERTY_LANGID                  = 2,
} WS_ERROR_PROPERTY_ID;



//  Errors enum
//  
//   An enumeration of structured exception codes thrown by this component.  These
//  exceptions are fatal and should not be handled by the application.
//  
typedef enum
{
    WS_EXCEPTION_CODE_USAGE_FAILURE        = 0xC03D0000,
    WS_EXCEPTION_CODE_INTERNAL_FAILURE     = 0xc03d0001,
} WS_EXCEPTION_CODE;



//  Faults enum
//  
//   A set of values used with WsSetFaultErrorProperty and
//   WsGetFaultErrorProperty.
//  
typedef enum
{
    WS_FAULT_ERROR_PROPERTY_FAULT      = 0,
    WS_FAULT_ERROR_PROPERTY_ACTION     = 1,
    WS_FAULT_ERROR_PROPERTY_HEADER     = 2,
} WS_FAULT_ERROR_PROPERTY_ID;



//  Faults enum
//  
//   Controls how much error information is included in a fault.
//  
typedef enum
{
    WS_MINIMAL_FAULT_DISCLOSURE     = 0,
    WS_FULL_FAULT_DISCLOSURE        = 1,
} WS_FAULT_DISCLOSURE;



//  Heap enum
//  
//   Each heap property is identified by an ID and has an associated value.
//  
typedef enum
{
    WS_HEAP_PROPERTY_MAX_SIZE           = 0,
    WS_HEAP_PROPERTY_TRIM_SIZE          = 1,
    WS_HEAP_PROPERTY_REQUESTED_SIZE     = 2,
    WS_HEAP_PROPERTY_ACTUAL_SIZE        = 3,
} WS_HEAP_PROPERTY_ID;



//  Listener enum
//  And enumeration of the different states that a listener can be in.
typedef enum
{
    WS_LISTENER_STATE_CREATED     = 0,
    WS_LISTENER_STATE_OPENING     = 1,
    WS_LISTENER_STATE_OPEN        = 2,
    WS_LISTENER_STATE_FAULTED     = 3,
    WS_LISTENER_STATE_CLOSING     = 4,
    WS_LISTENER_STATE_CLOSED      = 5,
} WS_LISTENER_STATE;



//  Listener enum
//  
//   Each listener property is of type WS_LISTENER_PROPERTY and is
//  is identified by an ID and has an associated value.  If a property
//  is not specified when the listener is created, then its default value is used.
//  
typedef enum
{
    WS_LISTENER_PROPERTY_LISTEN_BACKLOG                     = 0,
    WS_LISTENER_PROPERTY_IP_VERSION                         = 1,
    WS_LISTENER_PROPERTY_STATE                              = 2,
    WS_LISTENER_PROPERTY_ASYNC_CALLBACK_MODEL               = 3,
    WS_LISTENER_PROPERTY_CHANNEL_TYPE                       = 4,
    WS_LISTENER_PROPERTY_CHANNEL_BINDING                    = 5,
    WS_LISTENER_PROPERTY_CONNECT_TIMEOUT                    = 6,
    WS_LISTENER_PROPERTY_IS_MULTICAST                       = 7,
    WS_LISTENER_PROPERTY_MULTICAST_INTERFACES               = 8,
    WS_LISTENER_PROPERTY_MULTICAST_LOOPBACK                 = 9,
    WS_LISTENER_PROPERTY_CLOSE_TIMEOUT                      = 10,
    WS_LISTENER_PROPERTY_TO_HEADER_MATCHING_OPTIONS         = 11,
    WS_LISTENER_PROPERTY_TRANSPORT_URL_MATCHING_OPTIONS     = 12,
    WS_LISTENER_PROPERTY_CUSTOM_LISTENER_CALLBACKS          = 13,
    WS_LISTENER_PROPERTY_CUSTOM_LISTENER_PARAMETERS         = 14,
    WS_LISTENER_PROPERTY_CUSTOM_LISTENER_INSTANCE           = 15,
    WS_LISTENER_PROPERTY_DISALLOWED_USER_AGENT              = 16,
} WS_LISTENER_PROPERTY_ID;



//  Listener enum
//  
//   Specifies an IP version.
//  
typedef enum
{
    WS_IP_VERSION_4        = 1,
    WS_IP_VERSION_6        = 2,
    WS_IP_VERSION_AUTO     = 3,
} WS_IP_VERSION;



//  Listener enum
//  
//   A set of flags used to specify how to match a URL.
//  
enum
{
    WS_MATCH_URL_DNS_HOST                     = 0x1,
    WS_MATCH_URL_DNS_FULLY_QUALIFIED_HOST     = 0x2,
    WS_MATCH_URL_NETBIOS_HOST                 = 0x4,
    WS_MATCH_URL_LOCAL_HOST                   = 0x8,
    WS_MATCH_URL_HOST_ADDRESSES               = 0x10,
    WS_MATCH_URL_THIS_HOST                    = (WS_MATCH_URL_DNS_HOST | WS_MATCH_URL_DNS_FULLY_QUALIFIED_HOST | WS_MATCH_URL_NETBIOS_HOST | WS_MATCH_URL_LOCAL_HOST | WS_MATCH_URL_HOST_ADDRESSES),
    WS_MATCH_URL_PORT                         = 0x20,
    WS_MATCH_URL_EXACT_PATH                   = 0x40,
    WS_MATCH_URL_PREFIX_PATH                  = 0x80,
    WS_MATCH_URL_NO_QUERY                     = 0x100,
};



//  Message enum
//  
//   The different states that a message can be in.
//  
typedef enum
{
    WS_MESSAGE_STATE_EMPTY           = 1,
    WS_MESSAGE_STATE_INITIALIZED     = 2,
    WS_MESSAGE_STATE_READING         = 3,
    WS_MESSAGE_STATE_WRITING         = 4,
    WS_MESSAGE_STATE_DONE            = 5,
} WS_MESSAGE_STATE;



//  Message enum
//  
//   The following values specify what headers the
//   WsInitializeMessage
//   should add to the message.
//  
typedef enum
{
    WS_BLANK_MESSAGE         = 0,
    WS_DUPLICATE_MESSAGE     = 1,
    WS_REQUEST_MESSAGE       = 2,
    WS_REPLY_MESSAGE         = 3,
    WS_FAULT_MESSAGE         = 4,
} WS_MESSAGE_INITIALIZATION;



//  Message enum
//  
//   This enum is used to specify whether a header is expected
//  to appear more than once in a message.
//  
typedef enum
{
    WS_REPEATING_HEADER     = 1,
    WS_SINGLETON_HEADER     = 2,
} WS_REPEATING_HEADER_OPTION;



//  Message enum
//  
//   Identifies a type of header.
//  
typedef enum
{
    WS_ACTION_HEADER         = 1,
    WS_TO_HEADER             = 2,
    WS_MESSAGE_ID_HEADER     = 3,
    WS_RELATES_TO_HEADER     = 4,
    WS_FROM_HEADER           = 5,
    WS_REPLY_TO_HEADER       = 6,
    WS_FAULT_TO_HEADER       = 7,
} WS_HEADER_TYPE;



//  Message enum
//  
//   A set of flags representing the SOAP mustUnderstand and relay attributes of a header.
//  
enum
{
    WS_MUST_UNDERSTAND_HEADER_ATTRIBUTE     = 0x1,
    WS_RELAY_HEADER_ATTRIBUTE               = 0x2,
};



//  Message enum
//  
//   The following values identify the version of the specification used for
//  the addressing headers.
typedef enum
{
    WS_ADDRESSING_VERSION_0_9           = 1,
    WS_ADDRESSING_VERSION_1_0           = 2,
    WS_ADDRESSING_VERSION_TRANSPORT     = 3,
} WS_ADDRESSING_VERSION;



//  Message enum
//  
//   Identifies the version of the specification used for the envelope
//  structure.
//  
typedef enum
{
    WS_ENVELOPE_VERSION_SOAP_1_1     = 1,
    WS_ENVELOPE_VERSION_SOAP_1_2     = 2,
    WS_ENVELOPE_VERSION_NONE         = 3,
} WS_ENVELOPE_VERSION;



//  Message enum
//  
//   Each message property is identified by an ID and has an associated
//  value.
//  
typedef enum
{
    WS_MESSAGE_PROPERTY_STATE                                = 0,
    WS_MESSAGE_PROPERTY_HEAP                                 = 1,
    WS_MESSAGE_PROPERTY_ENVELOPE_VERSION                     = 2,
    WS_MESSAGE_PROPERTY_ADDRESSING_VERSION                   = 3,
    WS_MESSAGE_PROPERTY_HEADER_BUFFER                        = 4,
    WS_MESSAGE_PROPERTY_HEADER_POSITION                      = 5,
    WS_MESSAGE_PROPERTY_BODY_READER                          = 6,
    WS_MESSAGE_PROPERTY_BODY_WRITER                          = 7,
    WS_MESSAGE_PROPERTY_IS_ADDRESSED                         = 8,
    WS_MESSAGE_PROPERTY_HEAP_PROPERTIES                      = 9,
    WS_MESSAGE_PROPERTY_XML_READER_PROPERTIES                = 10,
    WS_MESSAGE_PROPERTY_XML_WRITER_PROPERTIES                = 11,
    WS_MESSAGE_PROPERTY_IS_FAULT                             = 12,
    WS_MESSAGE_PROPERTY_MAX_PROCESSED_HEADERS                = 13,
    WS_MESSAGE_PROPERTY_USERNAME                             = 14,
    WS_MESSAGE_PROPERTY_ENCODED_CERT                         = 15,
    WS_MESSAGE_PROPERTY_TRANSPORT_SECURITY_WINDOWS_TOKEN     = 16,
    WS_MESSAGE_PROPERTY_HTTP_HEADER_AUTH_WINDOWS_TOKEN       = 17,
    WS_MESSAGE_PROPERTY_MESSAGE_SECURITY_WINDOWS_TOKEN       = 18,
    WS_MESSAGE_PROPERTY_SAML_ASSERTION                       = 19,
    WS_MESSAGE_PROPERTY_SECURITY_CONTEXT                     = 20,
    WS_MESSAGE_PROPERTY_PROTECTION_LEVEL                     = 21,
} WS_MESSAGE_PROPERTY_ID;



//  Security Bindings enum
//  
//  The type of the security binding, used as a selector for subtypes of
//   WS_SECURITY_BINDING.  In general, the type name of the
//  security binding (one of the values defined here) specifies how the
//  security token used with that security binding is obtained and used.
//  
typedef enum
{
    WS_SSL_TRANSPORT_SECURITY_BINDING_TYPE                = 1,
    WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TYPE           = 2,
    WS_HTTP_HEADER_AUTH_SECURITY_BINDING_TYPE             = 3,
    WS_USERNAME_MESSAGE_SECURITY_BINDING_TYPE             = 4,
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_TYPE       = 5,
    WS_XML_TOKEN_MESSAGE_SECURITY_BINDING_TYPE            = 6,
    WS_SAML_MESSAGE_SECURITY_BINDING_TYPE                 = 7,
    WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_TYPE     = 8,
} WS_SECURITY_BINDING_TYPE;



//  Security Binding Settings enum
//  
//  Defines the options for performing client authentication using HTTP
//  authentication headers.
//  
enum
{
    WS_HTTP_HEADER_AUTH_SCHEME_NONE          = 0x1,
    WS_HTTP_HEADER_AUTH_SCHEME_BASIC         = 0x2,
    WS_HTTP_HEADER_AUTH_SCHEME_DIGEST        = 0x4,
    WS_HTTP_HEADER_AUTH_SCHEME_NTLM          = 0x8,
    WS_HTTP_HEADER_AUTH_SCHEME_NEGOTIATE     = 0x10,
    WS_HTTP_HEADER_AUTH_SCHEME_PASSPORT      = 0x20,
};



//  Security Binding Settings enum
//  
//  Defines the target for the HTTP header authentication security binding.
//  
typedef enum
{
    WS_HTTP_HEADER_AUTH_TARGET_SERVICE     = 1,
    WS_HTTP_HEADER_AUTH_TARGET_PROXY       = 2,
} WS_HTTP_HEADER_AUTH_TARGET;



//  Security Binding Settings enum
//  
//  Defines the specific SSP package to be used for Windows Integrated
//  Authentication.
//  
typedef enum
{
    WS_WINDOWS_INTEGRATED_AUTH_PACKAGE_KERBEROS     = 1,
    WS_WINDOWS_INTEGRATED_AUTH_PACKAGE_NTLM         = 2,
    WS_WINDOWS_INTEGRATED_AUTH_PACKAGE_SPNEGO       = 3,
} WS_WINDOWS_INTEGRATED_AUTH_PACKAGE;



//  Security Channel Settings enum
//  
//   Defines the WS-Security specification version to be used with message
//  security and mixed-mode security.
//  
typedef enum
{
    WS_SECURITY_HEADER_VERSION_1_0     = 0x1,
    WS_SECURITY_HEADER_VERSION_1_1     = 0x2,
} WS_SECURITY_HEADER_VERSION;



//  Security Binding Settings enum
//  
//   Defines the WS-Trust specification version to be used with message
//  security and mixed-mode security.
//  
typedef enum
{
    WS_TRUST_VERSION_FEBRUARY_2005     = 0x1,
    WS_TRUST_VERSION_1_3               = 0x2,
} WS_TRUST_VERSION;



//  Security Binding Settings enum
//  
//   Defines which set of actions to use when negotiating security tokens using WS-Trust.
//  
typedef enum
{
    WS_REQUEST_SECURITY_TOKEN_ACTION_ISSUE             = 1,
    WS_REQUEST_SECURITY_TOKEN_ACTION_NEW_CONTEXT       = 2,
    WS_REQUEST_SECURITY_TOKEN_ACTION_RENEW_CONTEXT     = 3,
} WS_REQUEST_SECURITY_TOKEN_ACTION;



//  Security Channel Settings enum
//  
//   Defines the WS-SecureCoversation specification version to be used with message
//  security and mixed-mode security.
//  
typedef enum
{
    WS_SECURE_CONVERSATION_VERSION_FEBRUARY_2005     = 0x1,
    WS_SECURE_CONVERSATION_VERSION_1_3               = 0x2,
} WS_SECURE_CONVERSATION_VERSION;



//  Security Channel Settings enum
//  
//  With message security and mixed-mode security, this defines when a
//  timestamp element should be generated and demanded in the WS-Security
//  header.
//  
typedef enum
{
    WS_SECURITY_TIMESTAMP_USAGE_ALWAYS            = 1,
    WS_SECURITY_TIMESTAMP_USAGE_NEVER             = 2,
    WS_SECURITY_TIMESTAMP_USAGE_REQUESTS_ONLY     = 3,
} WS_SECURITY_TIMESTAMP_USAGE;



//  Security Channel Settings enum
//  
//  Defines the layout rules applied to the elements of the WS-Security
//  security header.  This setting is relevant to message security
//  bindings and mixed-mode security bindings.
//  
typedef enum
{
    WS_SECURITY_HEADER_LAYOUT_STRICT                       = 1,
    WS_SECURITY_HEADER_LAYOUT_LAX                          = 2,
    WS_SECURITY_HEADER_LAYOUT_LAX_WITH_TIMESTAMP_FIRST     = 3,
    WS_SECURITY_HEADER_LAYOUT_LAX_WITH_TIMESTAMP_LAST      = 4,
} WS_SECURITY_HEADER_LAYOUT;



//  Security Channel Settings enum
//  
//  Identifies the properties representing security algorithm knobs.
//  
typedef enum
{
} WS_SECURITY_ALGORITHM_PROPERTY_ID;



//  Security Channel Settings enum
//  
//   Defines the security algorithms to be used with WS-Security.
//  These values are relevant to message security bindings
//  and mixed-mode security bindings.
//  
typedef enum
{
    WS_SECURITY_ALGORITHM_DEFAULT                                      = 0,
    WS_SECURITY_ALGORITHM_CANONICALIZATION_EXCLUSIVE                   = 1,
    WS_SECURITY_ALGORITHM_CANONICALIZATION_EXCLUSIVE_WITH_COMMENTS     = 2,
    WS_SECURITY_ALGORITHM_DIGEST_SHA1                                  = 3,
    WS_SECURITY_ALGORITHM_DIGEST_SHA_256                               = 4,
    WS_SECURITY_ALGORITHM_DIGEST_SHA_384                               = 5,
    WS_SECURITY_ALGORITHM_DIGEST_SHA_512                               = 6,
    WS_SECURITY_ALGORITHM_SYMMETRIC_SIGNATURE_HMAC_SHA1                = 7,
    WS_SECURITY_ALGORITHM_SYMMETRIC_SIGNATURE_HMAC_SHA_256             = 8,
    WS_SECURITY_ALGORITHM_SYMMETRIC_SIGNATURE_HMAC_SHA_384             = 9,
    WS_SECURITY_ALGORITHM_SYMMETRIC_SIGNATURE_HMAC_SHA_512             = 10,
    WS_SECURITY_ALGORITHM_ASYMMETRIC_SIGNATURE_RSA_SHA1                = 11,
    WS_SECURITY_ALGORITHM_ASYMMETRIC_SIGNATURE_DSA_SHA1                = 12,
    WS_SECURITY_ALGORITHM_ASYMMETRIC_SIGNATURE_RSA_SHA_256             = 13,
    WS_SECURITY_ALGORITHM_ASYMMETRIC_SIGNATURE_RSA_SHA_384             = 14,
    WS_SECURITY_ALGORITHM_ASYMMETRIC_SIGNATURE_RSA_SHA_512             = 15,
    WS_SECURITY_ALGORITHM_ASYMMETRIC_KEYWRAP_RSA_1_5                   = 16,
    WS_SECURITY_ALGORITHM_ASYMMETRIC_KEYWRAP_RSA_OAEP                  = 17,
    WS_SECURITY_ALGORITHM_KEY_DERIVATION_P_SHA1                        = 18,
} WS_SECURITY_ALGORITHM_ID;



//  Security Channel Settings enum
//  
//  Defines the required integrity and confidentiality levels for sent and
//  received messages.  With transport and mixed-mode security bindings,
//  this setting applies to each message as a whole.  With message
//  security, the protection level is specified at the granularity of a
//  message header or body.  The default value defined applies only to
//  transport and mixed-mode security.
//  
typedef enum
{
    WS_PROTECTION_LEVEL_NONE                 = 1,
    WS_PROTECTION_LEVEL_SIGN                 = 2,
    WS_PROTECTION_LEVEL_SIGN_AND_ENCRYPT     = 3,
} WS_PROTECTION_LEVEL;



//  Security Channel Settings enum
//  
//   Identifies the properties representing channel-wide security knobs.
//  
typedef enum
{
    WS_SECURITY_PROPERTY_TRANSPORT_PROTECTION_LEVEL       = 1,
    WS_SECURITY_PROPERTY_ALGORITHM_SUITE                  = 2,
    WS_SECURITY_PROPERTY_ALGORITHM_SUITE_NAME             = 3,
    WS_SECURITY_PROPERTY_MAX_ALLOWED_LATENCY              = 4,
    WS_SECURITY_PROPERTY_TIMESTAMP_VALIDITY_DURATION      = 5,
    WS_SECURITY_PROPERTY_MAX_ALLOWED_CLOCK_SKEW           = 6,
    WS_SECURITY_PROPERTY_TIMESTAMP_USAGE                  = 7,
    WS_SECURITY_PROPERTY_SECURITY_HEADER_LAYOUT           = 8,
    WS_SECURITY_PROPERTY_SECURITY_HEADER_VERSION          = 9,
    WS_SECURITY_PROPERTY_EXTENDED_PROTECTION_POLICY       = 10,
    WS_SECURITY_PROPERTY_EXTENDED_PROTECTION_SCENARIO     = 11,
    WS_SECURITY_PROPERTY_SERVICE_IDENTITIES               = 12,
} WS_SECURITY_PROPERTY_ID;



//  Security Binding Settings enum
//  
//  The key type of a security token.  It is used as the return type when
//  a security token is queried about its key.  It is also used to specify
//  the required key type when requesting a security token from a security
//  token service.
//  
typedef enum
{
    WS_SECURITY_KEY_TYPE_NONE           = 1,
    WS_SECURITY_KEY_TYPE_SYMMETRIC      = 2,
    WS_SECURITY_KEY_TYPE_ASYMMETRIC     = 3,
} WS_SECURITY_KEY_TYPE;



//  Security Binding Settings enum
//  
//   A suite of security algorithms used for tasks such as signing and encryting.
//  The values in this enumeration correspond to the suites defined in
//   (http://schemas.xmlsoap.org/ws/2005/07/securitypolicy/) WS-SecurityPolicy 1.1
//   section 7.1.
//  
typedef enum
{
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC256                  = 1,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC192                  = 2,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC128                  = 3,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC256_RSA15            = 4,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC192_RSA15            = 5,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC128_RSA15            = 6,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC256_SHA256           = 7,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC192_SHA256           = 8,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC128_SHA256           = 9,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC256_SHA256_RSA15     = 10,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC192_SHA256_RSA15     = 11,
    WS_SECURITY_ALGORITHM_SUITE_NAME_BASIC128_SHA256_RSA15     = 12,
} WS_SECURITY_ALGORITHM_SUITE_NAME;



//  Security Binding Settings enum
//  
//  With message and mixed-mode security bindings, the mechanism to use to
//  refer to a security token from signatures, encrypted items and derived
//  tokens.  The security runtime can use the right reference on its own
//  most of the time, and this needs to be explicitly set only when a
//  specific reference mechanism is required, typically for interop with
//  another platform that supports only that reference form.
//  
typedef enum
{
    WS_SECURITY_TOKEN_REFERENCE_MODE_LOCAL_ID                = 1,
    WS_SECURITY_TOKEN_REFERENCE_MODE_XML_BUFFER              = 2,
    WS_SECURITY_TOKEN_REFERENCE_MODE_CERT_THUMBPRINT         = 3,
    WS_SECURITY_TOKEN_REFERENCE_MODE_SECURITY_CONTEXT_ID     = 4,
    WS_SECURITY_TOKEN_REFERENCE_MODE_SAML_ASSERTION_ID       = 5,
} WS_SECURITY_TOKEN_REFERENCE_MODE;



//  Security Binding Settings enum
//  
//   Defines failures related to certificate validation. Can be used with WS_SECURITY_BINDING_PROPERTY_CERT_FAILURES_TO_IGNORE to
//  specify which certificate verification failures should be ignored.
//  
enum
{
    WS_CERT_FAILURE_CN_MISMATCH            = 0x1,
    WS_CERT_FAILURE_INVALID_DATE           = 0x2,
    WS_CERT_FAILURE_UNTRUSTED_ROOT         = 0x4,
    WS_CERT_FAILURE_WRONG_USAGE            = 0x8,
    WS_CERT_FAILURE_REVOCATION_OFFLINE     = 0x10,
};



//  Security Binding Settings enum
//  
//  Defines how randomness should be contributed to the issued key during
//  a security token negotiation done with message and mixed-mode security.
//  
typedef enum
{
    WS_SECURITY_KEY_ENTROPY_MODE_CLIENT_ONLY     = 1,
    WS_SECURITY_KEY_ENTROPY_MODE_SERVER_ONLY     = 2,
    WS_SECURITY_KEY_ENTROPY_MODE_COMBINED        = 3,
} WS_SECURITY_KEY_ENTROPY_MODE;



//  Extended Protection enum
//  
//   Defines if Extended Protection data should be validated. This property is only available on the server,
//  and can only be set when WS_HTTP_CHANNEL_BINDING with WS_SSL_TRANSPORT_SECURITY_BINDING and either WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING
//   or WS_HTTP_HEADER_AUTH_SECURITY_BINDING is used.
//  
typedef enum
{
    WS_EXTENDED_PROTECTION_POLICY_NEVER              = 1,
    WS_EXTENDED_PROTECTION_POLICY_WHEN_SUPPORTED     = 2,
    WS_EXTENDED_PROTECTION_POLICY_ALWAYS             = 3,
} WS_EXTENDED_PROTECTION_POLICY;



//  Extended Protection enum
//  
//   Defines how Extended Protection is validated. For most configurations, the runtime can automatically determine what needs to
//  be validated based on the presence of the WS_SSL_TRANSPORT_SECURITY_BINDING. However, if the SSL connection is terminated at
//  an intermediary such as a proxy prior to reaching the server then the validation method must change, and this scenario cannot be automatically detected.
//  
//   Only available on the server.
//  
typedef enum
{
    WS_EXTENDED_PROTECTION_SCENARIO_BOUND_SERVER       = 1,
    WS_EXTENDED_PROTECTION_SCENARIO_TERMINATED_SSL     = 2,
} WS_EXTENDED_PROTECTION_SCENARIO;



//  Security Binding Settings enum
//  
//   Identifies the properties used to specify security
//  binding settings.  Security binding settings are present
//  in (WS_SECURITY_BINDING) security bindings
//  that are used, in turn, in a (WS_SECURITY_DESCRIPTION) security description.
//  
//  Note that the related enum WS_SECURITY_TOKEN_PROPERTY_ID
//  defines the keys for extracting fields from a security token instance.
//  Thus, WS_SECURITY_BINDING_PROPERTY enables specifying security binding
//  settings at channel / listener creation time to influence how a
//  security token is created and used, whereas WS_SECURITY_TOKEN_PROPERTY_ID
//  enables extracting fields out of a security token -- typically a
//  security token from a received message when the channel and security
//  are 'live'.
//  
typedef enum
{
    WS_SECURITY_BINDING_PROPERTY_REQUIRE_SSL_CLIENT_CERT                   = 1,
    WS_SECURITY_BINDING_PROPERTY_WINDOWS_INTEGRATED_AUTH_PACKAGE           = 2,
    WS_SECURITY_BINDING_PROPERTY_REQUIRE_SERVER_AUTH                       = 3,
    WS_SECURITY_BINDING_PROPERTY_ALLOW_ANONYMOUS_CLIENTS                   = 4,
    WS_SECURITY_BINDING_PROPERTY_ALLOWED_IMPERSONATION_LEVEL               = 5,
    WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_SCHEME                   = 6,
    WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_TARGET                   = 7,
    WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_BASIC_REALM              = 8,
    WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_DIGEST_REALM             = 9,
    WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_DIGEST_DOMAIN            = 10,
    WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_KEY_SIZE                 = 11,
    WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_KEY_ENTROPY_MODE         = 12,
    WS_SECURITY_BINDING_PROPERTY_MESSAGE_PROPERTIES                        = 13,
    WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_MAX_PENDING_CONTEXTS     = 14,
    WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_MAX_ACTIVE_CONTEXTS      = 15,
    WS_SECURITY_BINDING_PROPERTY_SECURE_CONVERSATION_VERSION               = 16,
    WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_SUPPORT_RENEW            = 17,
    WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_RENEWAL_INTERVAL         = 18,
    WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_ROLLOVER_INTERVAL        = 19,
    WS_SECURITY_BINDING_PROPERTY_CERT_FAILURES_TO_IGNORE                   = 20,
    WS_SECURITY_BINDING_PROPERTY_DISABLE_CERT_REVOCATION_CHECK             = 21,
} WS_SECURITY_BINDING_PROPERTY_ID;



//  Security Credentials enum
//  
//  The type of the certificate credential, used as a selector for
//  subtypes of WS_CERT_CREDENTIAL.
//  
typedef enum
{
    WS_SUBJECT_NAME_CERT_CREDENTIAL_TYPE     = 1,
    WS_THUMBPRINT_CERT_CREDENTIAL_TYPE       = 2,
    WS_CUSTOM_CERT_CREDENTIAL_TYPE           = 3,
} WS_CERT_CREDENTIAL_TYPE;



//  Security Credentials enum
//  
//  The type of the Windows Integrated Authentication credential, used as
//  a selector for subtypes of WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL.
//  
typedef enum
{
    WS_STRING_WINDOWS_INTEGRATED_AUTH_CREDENTIAL_TYPE      = 1,
    WS_DEFAULT_WINDOWS_INTEGRATED_AUTH_CREDENTIAL_TYPE     = 2,
    WS_OPAQUE_WINDOWS_INTEGRATED_AUTH_CREDENTIAL_TYPE      = 3,
} WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL_TYPE;



//  Security Credentials enum
//  
//  The type of the username/password credential, used as a selector for
//  subtypes of WS_USERNAME_CREDENTIAL.
//  
typedef enum
{
    WS_STRING_USERNAME_CREDENTIAL_TYPE     = 1,
} WS_USERNAME_CREDENTIAL_TYPE;



//  Security Processing Results enum
//  
//   Defines the keys for the fields and properties that can be extracted
//  from a security token.  Not all properties are valid for all security
//  token types.  The function WsGetSecurityTokenProperty uses
//  the values defined here as keys.
//  
//   See also WS_SECURITY_BINDING_PROPERTY.
//  
typedef enum
{
    WS_SECURITY_TOKEN_PROPERTY_KEY_TYPE                     = 1,
    WS_SECURITY_TOKEN_PROPERTY_VALID_FROM_TIME              = 2,
    WS_SECURITY_TOKEN_PROPERTY_VALID_TILL_TIME              = 3,
    WS_SECURITY_TOKEN_PROPERTY_SERIALIZED_XML               = 4,
    WS_SECURITY_TOKEN_PROPERTY_ATTACHED_REFERENCE_XML       = 5,
    WS_SECURITY_TOKEN_PROPERTY_UNATTACHED_REFERENCE_XML     = 6,
    WS_SECURITY_TOKEN_PROPERTY_SYMMETRIC_KEY                = 7,
} WS_SECURITY_TOKEN_PROPERTY_ID;



//  Security Bindings enum
//  
//  Types of security keys.
//  
typedef enum
{
    WS_RAW_SYMMETRIC_SECURITY_KEY_HANDLE_TYPE         = 1,
    WS_NCRYPT_ASYMMETRIC_SECURITY_KEY_HANDLE_TYPE     = 2,
    WS_CAPI_ASYMMETRIC_SECURITY_KEY_HANDLE_TYPE       = 3,
} WS_SECURITY_KEY_HANDLE_TYPE;



//  Security Bindings enum
//  
//  Defines how a message security binding attaches the security token
//  corresponding to it to a message using WS-Security mechanisms.
//  
typedef enum
{
    WS_SUPPORTING_MESSAGE_SECURITY_USAGE     = 1,
} WS_MESSAGE_SECURITY_USAGE;



//  Security Context enum
//  
//   Identifies a property of a security context object.
//  
typedef enum
{
    WS_SECURITY_CONTEXT_PROPERTY_IDENTIFIER                         = 1,
    WS_SECURITY_CONTEXT_PROPERTY_USERNAME                           = 2,
    WS_SECURITY_CONTEXT_PROPERTY_MESSAGE_SECURITY_WINDOWS_TOKEN     = 3,
    WS_SECURITY_CONTEXT_PROPERTY_SAML_ASSERTION                     = 4,
} WS_SECURITY_CONTEXT_PROPERTY_ID;



//  Security Channel Settings enum
//  
//   Identifies the properties for the creation of XML security tokens.
//  
typedef enum
{
    WS_XML_SECURITY_TOKEN_PROPERTY_ATTACHED_REFERENCE       = 1,
    WS_XML_SECURITY_TOKEN_PROPERTY_UNATTACHED_REFERENCE     = 2,
    WS_XML_SECURITY_TOKEN_PROPERTY_VALID_FROM_TIME          = 3,
    WS_XML_SECURITY_TOKEN_PROPERTY_VALID_TILL_TIME          = 4,
} WS_XML_SECURITY_TOKEN_PROPERTY_ID;



//  Security Bindings enum
//  
//  The type ids of the SAML token authenticators used on the server side
//  (i.e., relying party) to validate incoming SAML tokens.
//  
typedef enum
{
    WS_CERT_SIGNED_SAML_AUTHENTICATOR_TYPE     = 1,
} WS_SAML_AUTHENTICATOR_TYPE;



//  Security Channel Settings enum
//  
//   Identifies the properties for requesting a security token from an issuer.
//  
typedef enum
{
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_APPLIES_TO                      = 1,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_TRUST_VERSION                   = 2,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_SECURE_CONVERSATION_VERSION     = 3,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_ISSUED_TOKEN_TYPE               = 4,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_REQUEST_ACTION                  = 5,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_EXISTING_TOKEN                  = 6,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_ISSUED_TOKEN_KEY_TYPE           = 7,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_ISSUED_TOKEN_KEY_SIZE           = 8,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_ISSUED_TOKEN_KEY_ENTROPY        = 9,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_LOCAL_REQUEST_PARAMETERS        = 10,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_SERVICE_REQUEST_PARAMETERS      = 11,
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_MESSAGE_PROPERTIES              = 12,
} WS_REQUEST_SECURITY_TOKEN_PROPERTY_ID;



//  Serialization enum
//  
//   An enumeration of the different types supported for serialization.
//  
typedef enum
{
    WS_BOOL_TYPE                 = 0,
    WS_INT8_TYPE                 = 1,
    WS_INT16_TYPE                = 2,
    WS_INT32_TYPE                = 3,
    WS_INT64_TYPE                = 4,
    WS_UINT8_TYPE                = 5,
    WS_UINT16_TYPE               = 6,
    WS_UINT32_TYPE               = 7,
    WS_UINT64_TYPE               = 8,
    WS_FLOAT_TYPE                = 9,
    WS_DOUBLE_TYPE               = 10,
    WS_DECIMAL_TYPE              = 11,
    WS_DATETIME_TYPE             = 12,
    WS_TIMESPAN_TYPE             = 13,
    WS_GUID_TYPE                 = 14,
    WS_UNIQUE_ID_TYPE            = 15,
    WS_STRING_TYPE               = 16,
    WS_WSZ_TYPE                  = 17,
    WS_BYTES_TYPE                = 18,
    WS_XML_STRING_TYPE           = 19,
    WS_XML_QNAME_TYPE            = 20,
    WS_XML_BUFFER_TYPE           = 21,
    WS_CHAR_ARRAY_TYPE           = 22,
    WS_UTF8_ARRAY_TYPE           = 23,
    WS_BYTE_ARRAY_TYPE           = 24,
    WS_DESCRIPTION_TYPE          = 25,
    WS_STRUCT_TYPE               = 26,
    WS_CUSTOM_TYPE               = 27,
    WS_ENDPOINT_ADDRESS_TYPE     = 28,
    WS_FAULT_TYPE                = 29,
    WS_VOID_TYPE                 = 30,
    WS_ENUM_TYPE                 = 31,
    WS_DURATION_TYPE             = 32,
    WS_UNION_TYPE                = 33,
    WS_ANY_ATTRIBUTES_TYPE       = 34,
} WS_TYPE;



//  Serialization enum
//  
//   Specifies how a field of a structure is represented in XML.  This is used within
//  a WS_FIELD_DESCRIPTION.
//  
typedef enum
{
    WS_TYPE_ATTRIBUTE_FIELD_MAPPING               = 0,
    WS_ATTRIBUTE_FIELD_MAPPING                    = 1,
    WS_ELEMENT_FIELD_MAPPING                      = 2,
    WS_REPEATING_ELEMENT_FIELD_MAPPING            = 3,
    WS_TEXT_FIELD_MAPPING                         = 4,
    WS_NO_FIELD_MAPPING                           = 5,
    WS_XML_ATTRIBUTE_FIELD_MAPPING                = 6,
    WS_ELEMENT_CHOICE_FIELD_MAPPING               = 7,
    WS_REPEATING_ELEMENT_CHOICE_FIELD_MAPPING     = 8,
    WS_ANY_ELEMENT_FIELD_MAPPING                  = 9,
    WS_REPEATING_ANY_ELEMENT_FIELD_MAPPING        = 10,
    WS_ANY_CONTENT_FIELD_MAPPING                  = 11,
    WS_ANY_ATTRIBUTES_FIELD_MAPPING               = 12,
} WS_FIELD_MAPPING;



//  Serialization enum
//  
//   A set of flags used within a WS_STRUCT_DESCRIPTION.
//  
enum
{
    WS_STRUCT_ABSTRACT                            = 0x1,
    WS_STRUCT_IGNORE_TRAILING_ELEMENT_CONTENT     = 0x2,
    WS_STRUCT_IGNORE_UNHANDLED_ATTRIBUTES         = 0x4,
};



//  Serialization enum
//  
//   A set of flags used within a WS_FIELD_DESCRIPTION.
//  
enum
{
    WS_FIELD_POINTER             = 0x1,
    WS_FIELD_OPTIONAL            = 0x2,
    WS_FIELD_NILLABLE            = 0x4,
    WS_FIELD_NILLABLE_ITEM       = 0x8,
    WS_FIELD_OTHER_NAMESPACE     = 0x10,
};



//  Serialization enum
//  
//   Specifies how a WS_TYPE maps to/from XML when serialized
//  or deserialized.
//  
typedef enum
{
    WS_ELEMENT_TYPE_MAPPING             = 1,
    WS_ATTRIBUTE_TYPE_MAPPING           = 2,
    WS_ELEMENT_CONTENT_TYPE_MAPPING     = 3,
    WS_ANY_ELEMENT_TYPE_MAPPING         = 4,
} WS_TYPE_MAPPING;



//  Serialization enum
//  
//   Specifies whether a value is required, and how the value should be allocated.
//  
typedef enum
{
    WS_READ_REQUIRED_VALUE       = 1,
    WS_READ_REQUIRED_POINTER     = 2,
    WS_READ_OPTIONAL_POINTER     = 3,
    WS_READ_NILLABLE_POINTER     = 4,
    WS_READ_NILLABLE_VALUE       = 5,
} WS_READ_OPTION;



//  Serialization enum
//  
//   Specifies whether a storage specified contains the value, or a pointer to the value,
//  and whether the value can be represented as nil in the XML content.
//  
typedef enum
{
    WS_WRITE_REQUIRED_VALUE       = 1,
    WS_WRITE_REQUIRED_POINTER     = 2,
    WS_WRITE_NILLABLE_VALUE       = 3,
    WS_WRITE_NILLABLE_POINTER     = 4,
} WS_WRITE_OPTION;



//  Service Operation enum
//  
//   An enumeration of the different reasons for which a cancel can occur.
//  
typedef enum
{
    WS_SERVICE_HOST_ABORT          = 0,
    WS_SERVICE_CHANNEL_FAULTED     = 1,
} WS_SERVICE_CANCEL_REASON;



//  Service Operation enum
//  
//   An enumeration of the different operation styles.
//  
typedef enum
{
    WS_NON_RPC_LITERAL_OPERATION     = 0,
    WS_RPC_LITERAL_OPERATION         = 1,
} WS_OPERATION_STYLE;



//  Service Operation enum
//  
//   An enumeration of the different parameter types.
//  
typedef enum
{
    WS_PARAMETER_TYPE_NORMAL          = 0,
    WS_PARAMETER_TYPE_ARRAY           = 1,
    WS_PARAMETER_TYPE_ARRAY_COUNT     = 2,
    WS_PARAMETER_TYPE_MESSAGES        = 3,
} WS_PARAMETER_TYPE;



//  Service Operation enum
//  
//   A set of flags used within a WS_OPERATION_DESCRIPTION.
//  
enum
{
    WS_SERVICE_OPERATION_MESSAGE_NILLABLE_ELEMENT     = 0x1,
};



//  Service Host enum
//  
//   Each property represents optional parameters for configuring
//  the given WS_SERVICE_ENDPOINT.
//  
typedef enum
{
    WS_SERVICE_ENDPOINT_PROPERTY_ACCEPT_CHANNEL_CALLBACK          = 0,
    WS_SERVICE_ENDPOINT_PROPERTY_CLOSE_CHANNEL_CALLBACK           = 1,
    WS_SERVICE_ENDPOINT_PROPERTY_MAX_ACCEPTING_CHANNELS           = 2,
    WS_SERVICE_ENDPOINT_PROPERTY_MAX_CONCURRENCY                  = 3,
    WS_SERVICE_ENDPOINT_PROPERTY_BODY_HEAP_MAX_SIZE               = 4,
    WS_SERVICE_ENDPOINT_PROPERTY_BODY_HEAP_TRIM_SIZE              = 5,
    WS_SERVICE_ENDPOINT_PROPERTY_MESSAGE_PROPERTIES               = 6,
    WS_SERVICE_ENDPOINT_PROPERTY_MAX_CALL_POOL_SIZE               = 7,
    WS_SERVICE_ENDPOINT_PROPERTY_MAX_CHANNEL_POOL_SIZE            = 8,
    WS_SERVICE_ENDPOINT_PROPERTY_LISTENER_PROPERTIES              = 9,
    WS_SERVICE_ENDPOINT_PROPERTY_CHECK_MUST_UNDERSTAND            = 10,
    WS_SERVICE_ENDPOINT_PROPERTY_METADATA_EXCHANGE_TYPE           = 11,
    WS_SERVICE_ENDPOINT_PROPERTY_METADATA                         = 12,
    WS_SERVICE_ENDPOINT_PROPERTY_METADATA_EXCHANGE_URL_SUFFIX     = 13,
    WS_SERVICE_ENDPOINT_PROPERTY_MAX_CHANNELS                     = 14,
} WS_SERVICE_ENDPOINT_PROPERTY_ID;



//  Service Metadata enum

typedef enum
{
    WS_METADATA_EXCHANGE_TYPE_NONE         = 0,
    WS_METADATA_EXCHANGE_TYPE_MEX          = 1,
    WS_METADATA_EXCHANGE_TYPE_HTTP_GET     = 2,
} WS_METADATA_EXCHANGE_TYPE;



//  Service Host enum
//  
//   Each property represents optional parameters for configuring the service host.
//  
typedef enum
{
    WS_SERVICE_PROPERTY_HOST_USER_STATE      = 0,
    WS_SERVICE_PROPERTY_FAULT_DISCLOSURE     = 1,
    WS_SERVICE_PROPERTY_FAULT_LANGID         = 2,
    WS_SERVICE_PROPERTY_HOST_STATE           = 3,
    WS_SERVICE_PROPERTY_METADATA             = 4,
    WS_SERVICE_PROPERTY_CLOSE_TIMEOUT        = 5,
} WS_SERVICE_PROPERTY_ID;



//  Service Host enum
//  An enumeration of the different states that a service host can be in.
typedef enum
{
    WS_SERVICE_HOST_STATE_CREATED     = 0,
    WS_SERVICE_HOST_STATE_OPENING     = 1,
    WS_SERVICE_HOST_STATE_OPEN        = 2,
    WS_SERVICE_HOST_STATE_CLOSING     = 3,
    WS_SERVICE_HOST_STATE_CLOSED      = 4,
    WS_SERVICE_HOST_STATE_FAULTED     = 5,
} WS_SERVICE_HOST_STATE;



//  Service Proxy State Machine enum
//  
//   See Service Proxy State Machine for detail.
//  
typedef enum
{
    WS_SERVICE_PROXY_STATE_CREATED     = 0,
    WS_SERVICE_PROXY_STATE_OPENING     = 1,
    WS_SERVICE_PROXY_STATE_OPEN        = 2,
    WS_SERVICE_PROXY_STATE_CLOSING     = 3,
    WS_SERVICE_PROXY_STATE_CLOSED      = 4,
    WS_SERVICE_PROXY_STATE_FAULTED     = 5,
} WS_SERVICE_PROXY_STATE;



//  Service Proxy enum
//  
//   Optional parameters for configuring the service proxy. With an exception of
//   WS_PROXY_PROPERTY_STATE all the values are only supported for
//  use with WsCreateServiceProxy.
//  
typedef enum
{
    WS_PROXY_PROPERTY_CALL_TIMEOUT           = 0,
    WS_PROXY_PROPERTY_MESSAGE_PROPERTIES     = 1,
    WS_PROXY_PROPERTY_MAX_CALL_POOL_SIZE     = 2,
    WS_PROXY_PROPERTY_STATE                  = 3,
    WS_PROXY_PROPERTY_MAX_PENDING_CALLS      = 4,
    WS_PROXY_PROPERTY_MAX_CLOSE_TIMEOUT      = 5,
    WS_PROXY_FAULT_LANG_ID                   = 6,
} WS_PROXY_PROPERTY_ID;



//  Service Proxy enum
//  
//   Optional parameters for configuring a call on a client side service operation.
//  
typedef enum
{
    WS_CALL_PROPERTY_CALL_ID                     = 0,
    WS_CALL_PROPERTY_SEND_MESSAGE_CONTEXT        = 1,
    WS_CALL_PROPERTY_RECEIVE_MESSAGE_CONTEXT     = 2,
    WS_CALL_PROPERTY_CHECK_MUST_UNDERSTAND       = 3,
} WS_CALL_PROPERTY_ID;



//  Tracing enum

typedef enum
{
    WS_TRACE_API_NONE                                      = -1,
    WS_TRACE_API_START_READER_CANONICALIZATION             = 0,
    WS_TRACE_API_END_READER_CANONICALIZATION               = 1,
    WS_TRACE_API_START_WRITER_CANONICALIZATION             = 2,
    WS_TRACE_API_END_WRITER_CANONICALIZATION               = 3,
    WS_TRACE_API_CREATE_XML_BUFFER                         = 4,
    WS_TRACE_API_REMOVE_NODE                               = 5,
    WS_TRACE_API_CREATE_READER                             = 6,
    WS_TRACE_API_SET_INPUT                                 = 7,
    WS_TRACE_API_SET_INPUT_TO_BUFFER                       = 8,
    WS_TRACE_API_FREE_XML_READER                           = 9,
    WS_TRACE_API_GET_READER_PROPERTY                       = 10,
    WS_TRACE_API_GET_READER_NODE                           = 11,
    WS_TRACE_API_FILL_READER                               = 12,
    WS_TRACE_API_READ_START_ELEMENT                        = 13,
    WS_TRACE_API_READ_TO_START_ELEMENT                     = 14,
    WS_TRACE_API_READ_START_ATTRIBUTE                      = 15,
    WS_TRACE_API_READ_END_ATTRIBUTE                        = 16,
    WS_TRACE_API_READ_NODE                                 = 17,
    WS_TRACE_API_SKIP_NODE                                 = 18,
    WS_TRACE_API_READ_END_ELEMENT                          = 19,
    WS_TRACE_API_FIND_ATTRIBUTE                            = 20,
    WS_TRACE_API_READ_ELEMENT_VALUE                        = 21,
    WS_TRACE_API_READ_CHARS                                = 22,
    WS_TRACE_API_READ_CHARS_UTF8                           = 23,
    WS_TRACE_API_READ_BYTES                                = 24,
    WS_TRACE_API_READ_ARRAY                                = 25,
    WS_TRACE_API_GET_READER_POSITION                       = 26,
    WS_TRACE_API_SET_READER_POSITION                       = 27,
    WS_TRACE_API_MOVE_READER                               = 28,
    WS_TRACE_API_CREATE_WRITER                             = 29,
    WS_TRACE_API_FREE_XML_WRITER                           = 30,
    WS_TRACE_API_SET_OUTPUT                                = 31,
    WS_TRACE_API_SET_OUTPUT_TO_BUFFER                      = 32,
    WS_TRACE_API_GET_WRITER_PROPERTY                       = 33,
    WS_TRACE_API_FLUSH_WRITER                              = 34,
    WS_TRACE_API_WRITE_START_ELEMENT                       = 35,
    WS_TRACE_API_WRITE_END_START_ELEMENT                   = 36,
    WS_TRACE_API_WRITE_XMLNS_ATTRIBUTE                     = 37,
    WS_TRACE_API_WRITE_START_ATTRIBUTE                     = 38,
    WS_TRACE_API_WRITE_END_ATTRIBUTE                       = 39,
    WS_TRACE_API_WRITE_VALUE                               = 40,
    WS_TRACE_API_WRITE_XML_BUFFER                          = 41,
    WS_TRACE_API_READ_XML_BUFFER                           = 42,
    WS_TRACE_API_WRITE_XML_BUFFER_TO_BYTES                 = 43,
    WS_TRACE_API_READ_XML_BUFFER_FROM_BYTES                = 44,
    WS_TRACE_API_WRITE_ARRAY                               = 45,
    WS_TRACE_API_WRITE_QUALIFIED_NAME                      = 46,
    WS_TRACE_API_WRITE_CHARS                               = 47,
    WS_TRACE_API_WRITE_CHARS_UTF8                          = 48,
    WS_TRACE_API_WRITE_BYTES                               = 49,
    WS_TRACE_API_PUSH_BYTES                                = 50,
    WS_TRACE_API_PULL_BYTES                                = 51,
    WS_TRACE_API_WRITE_END_ELEMENT                         = 52,
    WS_TRACE_API_WRITE_TEXT                                = 53,
    WS_TRACE_API_WRITE_START_CDATA                         = 54,
    WS_TRACE_API_WRITE_END_CDATA                           = 55,
    WS_TRACE_API_WRITE_NODE                                = 56,
    WS_TRACE_API_PREFIX_FROM_NAMESPACE                     = 57,
    WS_TRACE_API_GET_WRITER_POSITION                       = 58,
    WS_TRACE_API_SET_WRITER_POSITION                       = 59,
    WS_TRACE_API_MOVE_WRITER                               = 60,
    WS_TRACE_API_TRIM_XML_WHITESPACE                       = 61,
    WS_TRACE_API_VERIFY_XML_NCNAME                         = 62,
    WS_TRACE_API_XML_STRING_EQUALS                         = 63,
    WS_TRACE_API_NAMESPACE_FROM_PREFIX                     = 64,
    WS_TRACE_API_READ_QUALIFIED_NAME                       = 65,
    WS_TRACE_API_GET_XML_ATTRIBUTE                         = 66,
    WS_TRACE_API_COPY_NODE                                 = 67,
    WS_TRACE_API_ASYNC_EXECUTE                             = 68,
    WS_TRACE_API_CREATE_CHANNEL                            = 69,
    WS_TRACE_API_OPEN_CHANNEL                              = 70,
    WS_TRACE_API_SEND_MESSAGE                              = 71,
    WS_TRACE_API_RECEIVE_MESSAGE                           = 72,
    WS_TRACE_API_REQUEST_REPLY                             = 73,
    WS_TRACE_API_SEND_REPLY_MESSAGE                        = 74,
    WS_TRACE_API_SEND_FAULT_MESSAGE_FOR_ERROR              = 75,
    WS_TRACE_API_GET_CHANNEL_PROPERTY                      = 76,
    WS_TRACE_API_SET_CHANNEL_PROPERTY                      = 77,
    WS_TRACE_API_WRITE_MESSAGE_START                       = 78,
    WS_TRACE_API_WRITE_MESSAGE_END                         = 79,
    WS_TRACE_API_READ_MESSAGE_START                        = 80,
    WS_TRACE_API_READ_MESSAGE_END                          = 81,
    WS_TRACE_API_CLOSE_CHANNEL                             = 82,
    WS_TRACE_API_ABORT_CHANNEL                             = 83,
    WS_TRACE_API_FREE_CHANNEL                              = 84,
    WS_TRACE_API_RESET_CHANNEL                             = 85,
    WS_TRACE_API_ABANDON_MESSAGE                           = 86,
    WS_TRACE_API_SHUTDOWN_SESSION_CHANNEL                  = 87,
    WS_TRACE_API_GET_CONTEXT_PROPERTY                      = 88,
    WS_TRACE_API_GET_DICTIONARY                            = 89,
    WS_TRACE_API_READ_ENDPOINT_ADDRESS_EXTENSION           = 90,
    WS_TRACE_API_CREATE_ERROR                              = 91,
    WS_TRACE_API_ADD_ERROR_STRING                          = 92,
    WS_TRACE_API_GET_ERROR_STRING                          = 93,
    WS_TRACE_API_COPY_ERROR                                = 94,
    WS_TRACE_API_GET_ERROR_PROPERTY                        = 95,
    WS_TRACE_API_SET_ERROR_PROPERTY                        = 96,
    WS_TRACE_API_RESET_ERROR                               = 97,
    WS_TRACE_API_FREE_ERROR                                = 98,
    WS_TRACE_API_GET_FAULT_ERROR_PROPERTY                  = 99,
    WS_TRACE_API_SET_FAULT_ERROR_PROPERTY                  = 100,
    WS_TRACE_API_CREATE_FAULT_FROM_ERROR                   = 101,
    WS_TRACE_API_SET_FAULT_ERROR_DETAIL                    = 102,
    WS_TRACE_API_GET_FAULT_ERROR_DETAIL                    = 103,
    WS_TRACE_API_CREATE_HEAP                               = 104,
    WS_TRACE_API_ALLOC                                     = 105,
    WS_TRACE_API_GET_HEAP_PROPERTY                         = 106,
    WS_TRACE_API_RESET_HEAP                                = 107,
    WS_TRACE_API_FREE_HEAP                                 = 108,
    WS_TRACE_API_CREATE_LISTENER                           = 109,
    WS_TRACE_API_OPEN_LISTENER                             = 110,
    WS_TRACE_API_ACCEPT_CHANNEL                            = 111,
    WS_TRACE_API_CLOSE_LISTENER                            = 112,
    WS_TRACE_API_ABORT_LISTENER                            = 113,
    WS_TRACE_API_RESET_LISTENER                            = 114,
    WS_TRACE_API_FREE_LISTENER                             = 115,
    WS_TRACE_API_GET_LISTENER_PROPERTY                     = 116,
    WS_TRACE_API_SET_LISTENER_PROPERTY                     = 117,
    WS_TRACE_API_CREATE_CHANNEL_FOR_LISTENER               = 118,
    WS_TRACE_API_CREATE_MESSAGE                            = 119,
    WS_TRACE_API_CREATE_MESSAGE_FOR_CHANNEL                = 120,
    WS_TRACE_API_INITIALIZE_MESSAGE                        = 121,
    WS_TRACE_API_RESET_MESSAGE                             = 122,
    WS_TRACE_API_FREE_MESSAGE                              = 123,
    WS_TRACE_API_GET_HEADER_ATTRIBUTES                     = 124,
    WS_TRACE_API_GET_HEADER                                = 125,
    WS_TRACE_API_GET_CUSTOM_HEADER                         = 126,
    WS_TRACE_API_REMOVE_HEADER                             = 127,
    WS_TRACE_API_SET_HEADER                                = 128,
    WS_TRACE_API_REMOVE_CUSTOM_HEADER                      = 129,
    WS_TRACE_API_ADD_CUSTOM_HEADER                         = 130,
    WS_TRACE_API_ADD_MAPPED_HEADER                         = 131,
    WS_TRACE_API_REMOVE_MAPPED_HEADER                      = 132,
    WS_TRACE_API_GET_MAPPED_HEADER                         = 133,
    WS_TRACE_API_WRITE_BODY                                = 134,
    WS_TRACE_API_READ_BODY                                 = 135,
    WS_TRACE_API_WRITE_ENVELOPE_START                      = 136,
    WS_TRACE_API_WRITE_ENVELOPE_END                        = 137,
    WS_TRACE_API_READ_ENVELOPE_START                       = 138,
    WS_TRACE_API_READ_ENVELOPE_END                         = 139,
    WS_TRACE_API_GET_MESSAGE_PROPERTY                      = 140,
    WS_TRACE_API_SET_MESSAGE_PROPERTY                      = 141,
    WS_TRACE_API_ADDRESS_MESSAGE                           = 142,
    WS_TRACE_API_CHECK_MUST_UNDERSTAND_HEADERS             = 143,
    WS_TRACE_API_MARK_HEADER_AS_UNDERSTOOD                 = 144,
    WS_TRACE_API_FILL_BODY                                 = 145,
    WS_TRACE_API_FLUSH_BODY                                = 146,
    WS_TRACE_API_REQUEST_SECURITY_TOKEN                    = 147,
    WS_TRACE_API_GET_SECURITY_TOKEN_PROPERTY               = 148,
    WS_TRACE_API_CREATE_XML_SECURITY_TOKEN                 = 149,
    WS_TRACE_API_FREE_SECURITY_TOKEN                       = 150,
    WS_TRACE_API_REVOKE_SECURITY_CONTEXT                   = 151,
    WS_TRACE_API_GET_SECURITY_CONTEXT_PROPERTY             = 152,
    WS_TRACE_API_READ_ELEMENT_TYPE                         = 153,
    WS_TRACE_API_READ_ATTRIBUTE_TYPE                       = 154,
    WS_TRACE_API_READ_TYPE                                 = 155,
    WS_TRACE_API_WRITE_ELEMENT_TYPE                        = 156,
    WS_TRACE_API_WRITE_ATTRIBUTE_TYPE                      = 157,
    WS_TRACE_API_WRITE_TYPE                                = 158,
    WS_TRACE_API_SERVICE_REGISTER_FOR_CANCEL               = 159,
    WS_TRACE_API_GET_SERVICE_HOST_PROPERTY                 = 160,
    WS_TRACE_API_CREATE_SERVICE_HOST                       = 161,
    WS_TRACE_API_OPEN_SERVICE_HOST                         = 162,
    WS_TRACE_API_CLOSE_SERVICE_HOST                        = 163,
    WS_TRACE_API_ABORT_SERVICE_HOST                        = 164,
    WS_TRACE_API_FREE_SERVICE_HOST                         = 165,
    WS_TRACE_API_RESET_SERVICE_HOST                        = 166,
    WS_TRACE_API_GET_SERVICE_PROXY_PROPERTY                = 167,
    WS_TRACE_API_CREATE_SERVICE_PROXY                      = 168,
    WS_TRACE_API_OPEN_SERVICE_PROXY                        = 169,
    WS_TRACE_API_CLOSE_SERVICE_PROXY                       = 170,
    WS_TRACE_API_ABORT_SERVICE_PROXY                       = 171,
    WS_TRACE_API_FREE_SERVICE_PROXY                        = 172,
    WS_TRACE_API_RESET_SERVICE_PROXY                       = 173,
    WS_TRACE_API_ABORT_CALL                                = 174,
    WS_TRACE_API_CALL                                      = 175,
    WS_TRACE_API_DECODE_URL                                = 176,
    WS_TRACE_API_ENCODE_URL                                = 177,
    WS_TRACE_API_COMBINE_URL                               = 178,
    WS_TRACE_API_DATETIME_TO_FILETIME                      = 179,
    WS_TRACE_API_FILETIME_TO_DATETIME                      = 180,
    WS_TRACE_API_DUMP_MEMORY                               = 181,
    WS_TRACE_API_SET_AUTOFAIL                              = 182,
    WS_TRACE_API_CREATE_METADATA                           = 183,
    WS_TRACE_API_READ_METADATA                             = 184,
    WS_TRACE_API_FREE_METADATA                             = 185,
    WS_TRACE_API_RESET_METADATA                            = 186,
    WS_TRACE_API_GET_METADATA_PROPERTY                     = 187,
    WS_TRACE_API_GET_MISSING_METADATA_DOCUMENT_ADDRESS     = 188,
    WS_TRACE_API_GET_METADATA_ENDPOINTS                    = 189,
    WS_TRACE_API_MATCH_POLICY_ALTERNATIVE                  = 190,
    WS_TRACE_API_GET_POLICY_PROPERTY                       = 191,
    WS_TRACE_API_GET_POLICY_ALTERNATIVE_COUNT              = 192,
    WS_TRACE_API_WS_CREATE_SERVICE_PROXY_FROM_TEMPLATE     = 193,
    WS_TRACE_API_WS_CREATE_SERVICE_HOST_FROM_TEMPLATE      = 194,
} WS_TRACE_API;



//  Url enum
//  
//   The set of schemes used with WsDecodeUrl, WsEncodeUrl,
//  and WsCombineUrl.
//  
typedef enum
{
    WS_URL_HTTP_SCHEME_TYPE        = 0,
    WS_URL_HTTPS_SCHEME_TYPE       = 1,
    WS_URL_NETTCP_SCHEME_TYPE      = 2,
    WS_URL_SOAPUDP_SCHEME_TYPE     = 3,
} WS_URL_SCHEME_TYPE;



//  Url enum
//  
//   Flags that control behavior of WsDecodeUrl, WsEncodeUrl,
//  and WsCombineUrl.
//  
enum
{
    WS_URL_FLAGS_ALLOW_HOST_WILDCARDS     = 0x1,
    WS_URL_FLAGS_NO_PATH_COLLAPSE         = 0x2,
    WS_URL_FLAGS_ZERO_TERMINATE           = 0x4,
};



//  Utilities enum
//  
//   Specifies the textual format of a WS_DATETIME.
//  
typedef enum
{
    WS_DATETIME_FORMAT_UTC       = 0,
    WS_DATETIME_FORMAT_LOCAL     = 1,
    WS_DATETIME_FORMAT_NONE      = 2,
} WS_DATETIME_FORMAT;



//  Metadata Import enum
//  
//   The state of the metadata object.
//  
typedef enum
{
    WS_METADATA_STATE_CREATED      = 1,
    WS_METADATA_STATE_RESOLVED     = 2,
    WS_METADATA_STATE_FAULTED      = 3,
} WS_METADATA_STATE;



//  Metadata Import enum
//  
//   Each metadata property is identified by an ID and has an associated
//  value.  If a property is not specified when the metadata is created,
//  then its default value is used.
//  
typedef enum
{
    WS_METADATA_PROPERTY_STATE                   = 1,
    WS_METADATA_PROPERTY_HEAP_PROPERTIES         = 2,
    WS_METADATA_PROPERTY_POLICY_PROPERTIES       = 3,
    WS_METADATA_PROPERTY_HEAP_REQUESTED_SIZE     = 4,
    WS_METADATA_PROPERTY_MAX_DOCUMENTS           = 5,
    WS_METADATA_PROPERTY_HOST_NAMES              = 6,
    WS_METADATA_PROPERTY_VERIFY_HOST_NAMES       = 7,
} WS_METADATA_PROPERTY_ID;



//  Metadata Import enum
//  
//   The state of the policy object.
//  
typedef enum
{
    WS_POLICY_STATE_CREATED     = 1,
    WS_POLICY_STATE_FAULTED     = 2,
} WS_POLICY_STATE;



//  Metadata Import enum
//  
//   Each policy property is identified by an ID and has an associated
//  value.
//  
typedef enum
{
    WS_POLICY_PROPERTY_STATE                = 1,
    WS_POLICY_PROPERTY_MAX_ALTERNATIVES     = 2,
    WS_POLICY_PROPERTY_MAX_DEPTH            = 3,
    WS_POLICY_PROPERTY_MAX_EXTENSIONS       = 4,
} WS_POLICY_PROPERTY_ID;



//  Metadata Import enum
//  
//   The values in this enumeration are used to identify the sub-types of WS_SECURITY_BINDING_CONSTRAINT.
//  
typedef enum
{
    WS_SSL_TRANSPORT_SECURITY_BINDING_CONSTRAINT_TYPE                = 1,
    WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_CONSTRAINT_TYPE           = 2,
    WS_HTTP_HEADER_AUTH_SECURITY_BINDING_CONSTRAINT_TYPE             = 3,
    WS_USERNAME_MESSAGE_SECURITY_BINDING_CONSTRAINT_TYPE             = 4,
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_CONSTRAINT_TYPE       = 5,
    WS_ISSUED_TOKEN_MESSAGE_SECURITY_BINDING_CONSTRAINT_TYPE         = 6,
    WS_CERT_MESSAGE_SECURITY_BINDING_CONSTRAINT_TYPE                 = 7,
    WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_CONSTRAINT_TYPE     = 8,
} WS_SECURITY_BINDING_CONSTRAINT_TYPE;



//  Metadata Import enum
//  
//   The values in this enumeration are used to identify the sub-types of WS_POLICY_EXTENSION.
//  
typedef enum
{
    WS_ENDPOINT_POLICY_EXTENSION_TYPE     = 1,
} WS_POLICY_EXTENSION_TYPE;



//  Policy Support enum
//  
//   An enumeration of the different security binding combinations that
//  are supported in current product.
//  
typedef enum
{
    WS_HTTP_BINDING_TEMPLATE_TYPE                                         = 0,
    WS_HTTP_SSL_BINDING_TEMPLATE_TYPE                                     = 1,
    WS_HTTP_HEADER_AUTH_BINDING_TEMPLATE_TYPE                             = 2,
    WS_HTTP_SSL_HEADER_AUTH_BINDING_TEMPLATE_TYPE                         = 3,
    WS_HTTP_SSL_USERNAME_BINDING_TEMPLATE_TYPE                            = 4,
    WS_HTTP_SSL_KERBEROS_APREQ_BINDING_TEMPLATE_TYPE                      = 5,
    WS_TCP_BINDING_TEMPLATE_TYPE                                          = 6,
    WS_TCP_SSPI_BINDING_TEMPLATE_TYPE                                     = 7,
    WS_TCP_SSPI_USERNAME_BINDING_TEMPLATE_TYPE                            = 8,
    WS_TCP_SSPI_KERBEROS_APREQ_BINDING_TEMPLATE_TYPE                      = 9,
    WS_HTTP_SSL_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE_TYPE           = 10,
    WS_HTTP_SSL_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE_TYPE     = 11,
    WS_TCP_SSPI_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE_TYPE           = 12,
    WS_TCP_SSPI_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE_TYPE     = 13,
} WS_BINDING_TEMPLATE_TYPE;


struct _CERT_CONTEXT;

struct _SecPkgContext_IssuerListInfoEx;

struct _WS_FAULT_CODE;

//  CALLBACK DEFINITIONS

//  XML Reader callback
//  
//   A user-defined callback used by the WS_XML_READER
//   to read from some source into a buffer.
//  
typedef HRESULT (CALLBACK* WS_READ_CALLBACK)(
    __in void* callbackState, 
    __out_bcount_part(maxSize, *actualSize) void* bytes, 
    __in ULONG maxSize, 
    __out ULONG* actualSize, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  XML Writer callback
//  
//   A user-defined callback used by the WS_XML_WRITER
//   to write a buffer to some destination.
//  
typedef HRESULT (CALLBACK* WS_WRITE_CALLBACK)(
    __in void* callbackState, 
    __in_ecount(count) const WS_BYTES* buffers, 
    __in ULONG count, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  XML Writer callback
//  
//   A user-defined callback used by WsPushBytes to request that data be written.
//  
typedef HRESULT (CALLBACK* WS_PUSH_BYTES_CALLBACK)(
    __in void* callbackState, 
    __in WS_WRITE_CALLBACK writeCallback, 
    __in void* writeCallbackState, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  XML Writer callback
//  
//   A user-defined callback used by WsPullBytes to request
//  the data that should be written.
//  
typedef HRESULT (CALLBACK* WS_PULL_BYTES_CALLBACK)(
    __in void* callbackState, 
    __out_bcount_part(maxSize, *actualSize) void* bytes, 
    __in ULONG maxSize, 
    __out ULONG* actualSize, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  XML Writer callback
//  
//   A user-defined callback used in WS_XML_WRITER_BINARY_ENCODING
//   that determines whether the string can be written in an optimized form.
//  
typedef HRESULT (CALLBACK* WS_DYNAMIC_STRING_CALLBACK)(
    __in void* callbackState, 
    __in const WS_XML_STRING* string, 
    __out BOOL* found, 
    __out ULONG* id, 
    __in_opt WS_ERROR* error);


//  Async Model callback
//  
//   The type of a callback used in the Async Model.
//  
typedef void (CALLBACK* WS_ASYNC_CALLBACK)(
    __in HRESULT errorCode, 
    __in WS_CALLBACK_MODEL callbackModel, 
    __in void* callbackState);


//  Async Model callback
//  
//   Used with the WsAsyncExecute to specify the next
//  function to invoke in a series of async operations.
//  
typedef HRESULT (CALLBACK* WS_ASYNC_FUNCTION)(
    __in HRESULT hr, 
    __in WS_CALLBACK_MODEL callbackModel, 
    __in void* callbackState, 
    __inout WS_ASYNC_OPERATION* next, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsCreateChannel call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_CREATE_CHANNEL_CALLBACK)(
    __in WS_CHANNEL_TYPE channelType, 
    __in_bcount(channelParametersSize) const void* channelParameters, 
    __in ULONG channelParametersSize, 
    __deref_out void** channelInstance, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsFreeChannel call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef void (CALLBACK* WS_FREE_CHANNEL_CALLBACK)(__in void* channelInstance);


//  Channel callback
//  
//   This callback handles the WsResetChannel call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_RESET_CHANNEL_CALLBACK)(
    __in void* channelInstance, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsAbortChannel call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_ABORT_CHANNEL_CALLBACK)(
    __in void* channelInstance, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsOpenChannel call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_OPEN_CHANNEL_CALLBACK)(
    __in void* channelInstance, 
    __in const WS_ENDPOINT_ADDRESS* endpointAddress, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsCloseChannel call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_CLOSE_CHANNEL_CALLBACK)(
    __in void* channelInstance, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsSetChannelProperty call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_SET_CHANNEL_PROPERTY_CALLBACK)(
    __in void* channelInstance, 
    __in WS_CHANNEL_PROPERTY_ID id, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsGetChannelProperty call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_GET_CHANNEL_PROPERTY_CALLBACK)(
    __in void* channelInstance, 
    __in WS_CHANNEL_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsReadMessageStart call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_READ_MESSAGE_START_CALLBACK)(
    __in void* channelInstance, 
    __in WS_MESSAGE* message, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsReadMessageEnd call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_READ_MESSAGE_END_CALLBACK)(
    __in void* channelInstance, 
    __in WS_MESSAGE* message, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsWriteMessageStart call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_WRITE_MESSAGE_START_CALLBACK)(
    __in void* channelInstance, 
    __in WS_MESSAGE* message, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsWriteMessageEnd call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_WRITE_MESSAGE_END_CALLBACK)(
    __in void* channelInstance, 
    __in WS_MESSAGE* message, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsAbandonMessage call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_ABANDON_MESSAGE_CALLBACK)(
    __in void* channelInstance, 
    __in WS_MESSAGE* message, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles the WsShutdownSessionChannel call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_SHUTDOWN_SESSION_CHANNEL_CALLBACK)(
    __in void* channelInstance, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles creating an encoder instance.
//  
typedef HRESULT (CALLBACK* WS_CREATE_ENCODER_CALLBACK)(
    __in void* createContext, 
    __in WS_WRITE_CALLBACK writeCallback, 
    __in void* writeContext, 
    __deref_out void** encoderContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback is invoked to get the content type of the message.
//  
typedef HRESULT (CALLBACK* WS_ENCODER_GET_CONTENT_TYPE_CALLBACK)(
    __in void* encoderContext, 
    __in const WS_STRING* contentType, 
    __out WS_STRING* newContentType, 
    __out WS_STRING* contentEncoding, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback is invoked to start encoding a message.
//  
typedef HRESULT (CALLBACK* WS_ENCODER_START_CALLBACK)(
    __in void* encoderContext, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback is invoked to encode a message.
//  
typedef HRESULT (CALLBACK* WS_ENCODER_ENCODE_CALLBACK)(
    __in void* encoderContext, 
    __in_ecount(count) const WS_BYTES* buffers, 
    __in ULONG count, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback is invoked to encode the end of a message.
//  
typedef HRESULT (CALLBACK* WS_ENCODER_END_CALLBACK)(
    __in void* encoderContext, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles freeing an encoder instance.
//  
typedef void (CALLBACK* WS_FREE_ENCODER_CALLBACK)(__in void* encoderContext);


//  Channel callback
//  
//   This callback handles creating an decoder instance.
//  
typedef HRESULT (CALLBACK* WS_CREATE_DECODER_CALLBACK)(
    __in void* createContext, 
    __in WS_READ_CALLBACK readCallback, 
    __in void* readContext, 
    __deref_out void** decoderContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback is invoked to get the content type of the message.
//  
typedef HRESULT (CALLBACK* WS_DECODER_GET_CONTENT_TYPE_CALLBACK)(
    __in void* decoderContext, 
    __in const WS_STRING* contentType, 
    __in_opt const WS_STRING* contentEncoding, 
    __out WS_STRING* newContentType, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback is invoked to start decoding a message.
//  
typedef HRESULT (CALLBACK* WS_DECODER_START_CALLBACK)(
    __in void* encoderContext, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback is invoked to decode a message.
//  
typedef HRESULT (CALLBACK* WS_DECODER_DECODE_CALLBACK)(
    __in void* encoderContext, 
    __out_bcount_part(maxLength, *length) void* buffer, 
    __in ULONG maxLength, 
    __out ULONG* length, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback is invoked to decode the end of a message.
//  
typedef HRESULT (CALLBACK* WS_DECODER_END_CALLBACK)(
    __in void* encoderContext, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel callback
//  
//   This callback handles freeing an decoder instance.
//  
typedef void (CALLBACK* WS_FREE_DECODER_CALLBACK)(__in void* decoderContext);


//  Channel callback
//  
//   This callback is invoked when a message is about to be automatically
//  redirected to another service utilizing HTTP auto redirect functionality
//  as described in RFC2616. If the redirection should not be allowed, this
//  callback should return S_FALSE or an error value. Otherwise the auto
//  HTTP redirection will proceed.
//  
typedef HRESULT (CALLBACK* WS_HTTP_REDIRECT_CALLBACK)(
    __in void* state, 
    __in const WS_STRING* originalUrl, 
    __in const WS_STRING* newUrl);


//  Listener callback
//  
//   This callback handles the WsCreateListener call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_CREATE_LISTENER_CALLBACK)(
    __in WS_CHANNEL_TYPE channelType, 
    __in_bcount(listenerParametersSize) const void* listenerParameters, 
    __in ULONG listenerParametersSize, 
    __deref_out void** listenerInstance, 
    __in_opt WS_ERROR* error);


//  Listener callback
//  
//   This callback handles the WsFreeListener call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef void (CALLBACK* WS_FREE_LISTENER_CALLBACK)(__in void* listenerInstance);


//  Listener callback
//  
//   This callback handles the WsResetListener call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_RESET_LISTENER_CALLBACK)(
    __in void* listenerInstance, 
    __in_opt WS_ERROR* error);


//  Listener callback
//  
//   This callback handles the WsOpenListener call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_OPEN_LISTENER_CALLBACK)(
    __in void* listenerInstance, 
    __in const WS_STRING* url, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Listener callback
//  
//   This callback handles the WsCloseListener call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_CLOSE_LISTENER_CALLBACK)(
    __in void* listenerInstance, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Listener callback
//  
//   This callback handles the WsGetListenerProperty call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_GET_LISTENER_PROPERTY_CALLBACK)(
    __in void* listenerInstance, 
    __in WS_LISTENER_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Listener callback
//  
//   This callback handles the WsSetListenerProperty call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_SET_LISTENER_PROPERTY_CALLBACK)(
    __in void* listenerInstance, 
    __in WS_LISTENER_PROPERTY_ID id, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Listener callback
//  
//   This callback handles the WsAcceptChannel call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_ACCEPT_CHANNEL_CALLBACK)(
    __in void* listenerInstance, 
    __in void* channelInstance, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Listener callback
//  
//   This callback handles the WsAbortListener call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_ABORT_LISTENER_CALLBACK)(
    __in void* listenerInstance, 
    __in_opt WS_ERROR* error);


//  Listener callback
//  
//   This callback handles the WsCreateChannelForListener call
//  for a WS_CUSTOM_CHANNEL_BINDING.
//  
typedef HRESULT (CALLBACK* WS_CREATE_CHANNEL_FOR_LISTENER_CALLBACK)(
    __in void* listenerInstance, 
    __in_bcount(channelParametersSize) const void* channelParameters, 
    __in ULONG channelParametersSize, 
    __deref_out void** channelInstance, 
    __in_opt WS_ERROR* error);


//  Message callback
//  
//   This callback is used as a notification that the message is done using
//  the WS_XML_READER supplied to WsReadEnvelopeStart
//   or the WS_XML_WRITER supplied to WsWriteEnvelopeStart.
//  
typedef void (CALLBACK* WS_MESSAGE_DONE_CALLBACK)(__in void* doneCallbackState);


//  Security Credentials callback
//  
//  Callback for providing a certificate to the security runtime.  This
//  callback is specified as part of the WS_CUSTOM_CERT_CREDENTIAL,
//  which in turn may be specified as part of a security binding that requires a
//  certificate credential. The runtime will invoke this callback when the channel
//  (client-side) or the listener (server-side) is opened.
//  
//  Cert ownership: If this callback returns a success HRESULT, the caller
//  (namely, the security runtime) will take ownership of the returned
//  certificate, and will free it when the containing channel no longer
//  needs it.  If this callback returns a failure HRESULT, the caller will
//  NOT take ownership of, or even look at, the value returned in the out
//  parameter 'cert'.
//  
typedef HRESULT (CALLBACK* WS_GET_CERT_CALLBACK)(
    __in void* getCertCallbackState, 
    __in_opt const WS_ENDPOINT_ADDRESS* targetAddress, 
    __in_opt const WS_STRING* viaUri, 
    __deref_out const struct _CERT_CONTEXT** cert, 
    __in_opt WS_ERROR* error);


//  Security Credentials callback
//  
//  The callback to notify the client of the list of certificate issuers
//  that are acceptable to the server.  With some protocols such as SSL,
//  the server may optionally send such an issuer list to help the client
//  choose a certificate.
//  
//  This callback is an optional part of the WS_CUSTOM_CERT_CREDENTIAL.
//  If the (possibly NULL) certificate returned by the WS_GET_CERT_CALLBACK is
//  accepted by the server, then this callback is never invoked.  If the
//  server rejects it and sends back an issuer list, then this callback
//  will be invoked.  The client may then choose a certificate based on
//  the issuer list and supply that certificate when the channel is opened
//  next and WS_GET_CERT_CALLBACK is invoked again.
//  
//  The parameters supplied during this callback are valid only for the
//  duration of the callback.
//  
typedef HRESULT (CALLBACK* WS_CERT_ISSUER_LIST_NOTIFICATION_CALLBACK)(
    __in void* certIssuerListNotificationCallbackState, 
    __in const struct _SecPkgContext_IssuerListInfoEx* issuerList, 
    __in_opt WS_ERROR* error);


//  Security Credentials callback
//  
//  Application supplied callback for validating a username/password pair
//  on the receiver side.  When a WS_USERNAME_MESSAGE_SECURITY_BINDING
//  containing this callback is included in the security description, this callback
//  is invoked for each received message at the server.  This callback is expected
//  to return S_OKif the username/password pair was successfully validated, S_FALSE
//  when the pair could not be validated and an error value if an unexpected error occurred.
//  Returning any result other than S_OK from this callback will result in
//  the associated receive message failing with a security error.
//  
//  As with all security callbacks, the application should expect to
//  receive this callback any time between channel/listener open and close,
//  but it will never be invoked when a channel is not open.  In the
//  current drop, this callback is always invoked synchronously.  In the
//  next drop, this callback will be invoked synchronously for synchronous
//  message receives and asynchronously for asynchronous message receives,
//  but it will always be invoked (WS_SHORT_CALLBACK) short
//  when it is invoked asynchronously.
//  
typedef HRESULT (CALLBACK* WS_VALIDATE_PASSWORD_CALLBACK)(
    __in_opt void* passwordValidatorCallbackState, 
    __in const WS_STRING* username, 
    __in const WS_STRING* password, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Security Bindings callback
//  
//  Application supplied callback for validating a SAML assertion.  If a
//  received SAML assertion passes the signature verification checks that
//  ensure the SAML was issued by a trusted issuer, then this callback is
//  invoked to enable the application to do additional validation on the
//  XML form of the SAML assertion.  This callback is expected to return
//  S_OK if the SAML assertion was successfully validated, S_FALSE when
//  the assertion could not be validated and an error value if an
//  unexpected error occurred.  Returning any result other than S_OK from
//  this callback will result in the associated receive message failing
//  with a security error.
//  
//  As with all security callbacks, the application should expect to
//  receive this callback any time between listener open and close, but it
//  will never be invoked when a listener is not open.
//  
typedef HRESULT (CALLBACK* WS_VALIDATE_SAML_CALLBACK)(
    __in_opt void* samlValidatorCallbackState, 
    __in WS_XML_BUFFER* samlAssertion, 
    __in_opt WS_ERROR* error);


//  Serialization callback
//  
//   This callback is invoked to compare two durations.
//  
typedef HRESULT (CALLBACK* WS_DURATION_COMPARISON_CALLBACK)(
    __in const WS_DURATION* duration1, 
    __in const WS_DURATION* duration2, 
    __out int* result, 
    __in_opt WS_ERROR* error);


//  Serialization callback
//  
//   This callback is invoked to read an value when WS_CUSTOM_TYPE
//   has been specified.  This allows reading of XML constructs which do not easily
//  map to the core serialization model.
//  
typedef HRESULT (CALLBACK* WS_READ_TYPE_CALLBACK)(
    __in WS_XML_READER* reader, 
    __in WS_TYPE_MAPPING typeMapping, 
    __in const void* descriptionData, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Serialization callback
//  
//   This callback is invoked to write an element when WS_CUSTOM_TYPE
//   has been specified.  This allows writing of XML constructs which do not easily
//  map to the core serialization model.
//  
typedef HRESULT (CALLBACK* WS_WRITE_TYPE_CALLBACK)(
    __in WS_XML_WRITER* writer, 
    __in WS_TYPE_MAPPING typeMapping, 
    __in const void* descriptionData, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Serialization callback
//  
//   This callback is invoked before a value that is handled
//  by a WS_CUSTOM_TYPE is serialized in order to
//  determine if the value is the default value.  Support
//  for default values is enabled by specifying
//  when WS_FIELD_OPTIONAL in the WS_FIELD_DESCRIPTION.
//  
typedef HRESULT (CALLBACK* WS_IS_DEFAULT_VALUE_CALLBACK)(
    __in const void* descriptionData, 
    __in_bcount(valueSize) const void* value, 
    __in_bcount_opt(valueSize) const void* defaultValue, 
    __in ULONG valueSize, 
    __out BOOL* isDefault, 
    __in_opt WS_ERROR* error);


//  Contract callback
//  
//   It is invoked when a WS_MESSAGE is received on an endpoint configured
//  with a WS_SERVICE_CONTRACT which has defaultMessageHandlerCallback set.
//  
//   The incoming WS_MESSAGE, the serviceProxy along with other parameters
//  is made available to the callback through WS_OPERATION_CONTEXT.
//  
typedef HRESULT (CALLBACK* WS_SERVICE_MESSAGE_RECEIVE_CALLBACK)(
    __in const WS_OPERATION_CONTEXT* context, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Call cancellation callback
//  
//   This callback is invoked by service model to notify a cancellation of an
//  async service operation call as a result of an aborted shutdown of service host.
//  
typedef void (CALLBACK* WS_OPERATION_CANCEL_CALLBACK)(
    __in const WS_SERVICE_CANCEL_REASON reason, 
    __in void* state);


//  Call cancellation callback
//  
//   This callback is invoked by service model to allow application to cleanup
//  state that was registered with cancellation callback.
//  
typedef void (CALLBACK* WS_OPERATION_FREE_STATE_CALLBACK)(__in void* state);


//  Contract callback
//  
//   This callback is invoked by service model to delegate to the service
//  operation call. This callback is generated by (Web Service Compiler Tool) wsutil.exe
//   for every service operation. It is defined on the WS_OPERATION_DESCRIPTION for each
//  service operation.
//  
typedef HRESULT (CALLBACK* WS_SERVICE_STUB_CALLBACK)(
    __in const WS_OPERATION_CONTEXT* context, 
    __in void* frame, 
    __in const void* callback, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Service Host callback
//  
//   This callback is invoked when a channel is accepted on an endpoint
//  listener by service host.
//  
//   For (Contract) session based service contract, this notification signifies session initiation.
//  Thus an application state scoped for the session can be created within this callback.
//  
typedef HRESULT (CALLBACK* WS_SERVICE_ACCEPT_CHANNEL_CALLBACK)(
    __in const WS_OPERATION_CONTEXT* context, 
    __deref_out void** channelState, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Service Host callback
//  
//   This callback is invoked when a channel is closed/or aborted on an endpoint.
//  This callback is called right before we are about to close the channel.
//  
//   For normal operation when service host is running and the client cleanly
//  closed the channel, this implies that we have received a session closure
//  from the client and we are about to close the channel.
//  
//   The other scenario is when service host is going through an Abort Shutdown
//  or during the processing of the message an unrecoverable error condition is
//  met, as a result of this we attempt to abort and then close the channel.
//  In this case as well right before the abort we will call upon this callback.
//  
//   For (Contract) session based service contract, this notification
//  signifies session tear down. Thus an application state scoped for the session
//  can be destroyed within this callback.
//  
typedef HRESULT (CALLBACK* WS_SERVICE_CLOSE_CHANNEL_CALLBACK)(
    __in const WS_OPERATION_CONTEXT* context, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext);


//  Service Authorization callback
//  
//   This callback is invoked when headers of the incoming message
//  are received and the body is not processed.
//  
typedef HRESULT (CALLBACK* WS_SERVICE_SECURITY_CALLBACK)(
    __in const WS_OPERATION_CONTEXT* context, 
    __out BOOL* authorized, 
    __in_opt WS_ERROR* error);


//  Service Proxy callback
//  
//   The callback is invoked when the headers of the input message are
//  about to be sent through, or when an output message headers are just received.
//  
typedef HRESULT (CALLBACK* WS_PROXY_MESSAGE_CALLBACK)(
    __in WS_MESSAGE* message, 
    __in WS_HEAP* heap, 
    __in void* state, 
    __in_opt WS_ERROR* error);


//  STRUCT DEFINITIONS

//  XML Node structure
//  
//   Represents a set of unique strings.  This information is used by the binary
//  encoding to write a more compact xml document.
//  
struct _WS_XML_DICTIONARY {
    GUID guid;
    WS_XML_STRING* strings;
    ULONG stringCount;
    BOOL isConst;
};


//  XML Node structure
//  
//   Represents a string that optionally has (WS_XML_DICTIONARY) dictionary
//   information associated with it.  The xml APIs use WS_XML_STRINGs to identify prefixes,
//  localNames and namespaces.
//  
struct _WS_XML_STRING {
    ULONG length;
    BYTE* bytes;
    WS_XML_DICTIONARY* dictionary;
    ULONG id;
};


//  XML Node structure
//  
//   A structure used to specify an XML name (of an element or an attribute) as
//  a local name, namespace pair.
//  
struct _WS_XML_QNAME {
    WS_XML_STRING localName;
    WS_XML_STRING ns;
};


//  XML Buffer structure
//  
//   Represents a position within an XML Buffer.  The current position within
//  a reader or writer may be obtained by calling WsGetReaderPosition or
//   WsGetWriterPosition.  The current position within a reader or writer
//  may be set by calling WsSetReaderPosition or WsSetWriterPosition.
//  
//   Using WsRemoveNode to remove a node that corresponds to or contains a
//  position will cause subsequent use of the position to fail.  The position itself
//  remains valid, but operations that depend on that position will fail.
//  
//   Positions may be used as long as the containing XML buffer is valid.  Using a position
//  after its corresponding buffer has been deleted will exhibit undefined behavior.
//  
struct _WS_XML_NODE_POSITION {
    WS_XML_BUFFER* buffer;
    void* node;
};


//  XML Reader structure
//  
//   Specifies a reader specific setting.
//  
struct _WS_XML_READER_PROPERTY {
    WS_XML_READER_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  XML Canonicalization structure
//  
//   An array of XML prefixes that should be treated as
//  inclusive prefixes during exclusive XML canonicalization.  The
//  treatment of inclusive prefixes is defined in
//   (http://tools.ietf.org/html/rfc3741) RFC 3741.
//  
struct _WS_XML_CANONICALIZATION_INCLUSIVE_PREFIXES {
    ULONG prefixCount;
    WS_XML_STRING* prefixes;
};


//  XML Canonicalization structure
//  
//   Specifies a setting that controls how XML canonicalization is done.
//  
struct _WS_XML_CANONICALIZATION_PROPERTY {
    WS_XML_CANONICALIZATION_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  XML Writer structure
//  
//   Specifies a writer specific setting.
//  
struct _WS_XML_WRITER_PROPERTY {
    WS_XML_WRITER_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  XML Buffer structure
//  
//   Specifies an xml buffer specific setting.
//  
struct _WS_XML_BUFFER_PROPERTY {
    WS_XML_BUFFER_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  XML Node structure
//  
//   Represents a node of text content in xml.
//  
struct _WS_XML_TEXT {
    WS_XML_TEXT_TYPE textType;
};


//  XML Node structure
//  
//   Represents text encoded as UTF-8 bytes.
//  
struct _WS_XML_UTF8_TEXT {
    WS_XML_TEXT text;
    WS_XML_STRING value;
};


//  XML Node structure
//  
//   Represents text encoded as UTF-16 bytes.
//  
struct _WS_XML_UTF16_TEXT {
    WS_XML_TEXT text;
    BYTE* bytes;
    ULONG byteCount;
};


//  XML Node structure
//  
//   Represents base64 encoded data. (e.g. The three bytes { 0, 0, 0 } represent the text "AAAA".)
//  
struct _WS_XML_BASE64_TEXT {
    WS_XML_TEXT text;
    BYTE* bytes;
    ULONG length;
};


//  XML Node structure
//  
//   A boolean that represents the text "true" or "false".
//  
struct _WS_XML_BOOL_TEXT {
    WS_XML_TEXT text;
    BOOL value;
};


//  XML Node structure
//  
//   Represents a signed 32 bit integer.  (e.g. The value 255 represents the text "255")
//  
struct _WS_XML_INT32_TEXT {
    WS_XML_TEXT text;
    __int32 value;
};


//  XML Node structure
//  
//   Represents a signed 64 bit integer.  (e.g. The value 255 represents the text "255")
//  
struct _WS_XML_INT64_TEXT {
    WS_XML_TEXT text;
    __int64 value;
};


//  XML Node structure
//  
//   Represents an unsigned 64 bit integer.  (e.g. The value 255 represents the text "255")
//  
struct _WS_XML_UINT64_TEXT {
    WS_XML_TEXT text;
    unsigned __int64 value;
};


//  XML Node structure
//  
//   Represents a 4 byte floating point value.  (e.g. The value 0.0 represents the text "0")
//  
struct _WS_XML_FLOAT_TEXT {
    WS_XML_TEXT text;
    float value;
};


//  XML Node structure
//  
//   Represents an 8 byte floating point value.  (e.g. The value 0.0 represents the text "0")
//  
struct _WS_XML_DOUBLE_TEXT {
    WS_XML_TEXT text;
    double value;
};


//  XML Node structure
//  
//   Represents a 12 byte fixed point value.  (e.g. The value 1.23 represents the text "1.23")
//  
struct _WS_XML_DECIMAL_TEXT {
    WS_XML_TEXT text;
    DECIMAL value;
};


//  XML Node structure
//  
//   Represents a guid formatted as the text "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
//  
struct _WS_XML_GUID_TEXT {
    WS_XML_TEXT text;
    GUID value;
};


//  XML Node structure
//  
//   Represents a guid formatted as the text "urn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".
//  
struct _WS_XML_UNIQUE_ID_TEXT {
    WS_XML_TEXT text;
    GUID value;
};


//  Utilities structure
//  
//   This structure is used to represent dates and times.
//  
//   Represents dates and times with values ranging from 12:00:00 midnight,
//  January 1, 0001 Anno Domini (Common Era) through 11:59:59 P.M.,
//  December 31, 9999 A.D. (C.E.) to an accuracy of 100 nanoseconds.
//  
//   The functions WsDateTimeToFileTime and WsFileTimeToDateTime
//   can be used to convert a WS_DATETIME to and from a FILETIME.
//  
struct _WS_DATETIME {
    unsigned __int64 ticks;
    WS_DATETIME_FORMAT format;
};


//  XML Node structure
//  
//   Represents a datetime formatted as an
//   (http://www.w3.org/TR/xmlschema-2/#dateTime) xsd:dateTime.
//  
//   Negative datetime values are not supported.
//  
struct _WS_XML_DATETIME_TEXT {
    WS_XML_TEXT text;
    WS_DATETIME value;
};


//  Utilities structure
//  
//   Represents a signed 64-bit time interval in 100 nanosecond units.
//  
struct _WS_TIMESPAN {
    __int64 ticks;
};


//  XML Node structure
//  
//   Represents a time span formatted as the text "[+|-][d?.]HH:mm:ss[.fffffff]"
//  
//  .d is a series of digits representing the day.
//  
//  .HH is a two digit number representing the hour of the day, from to 0 to 23.
//  
//  .mm is a two digit number representing the minute of the hour, from to 0 to 59.
//  
//  .ss is a two digit number representing the second of the minute, from to 0 to 59.
//  
//  .fffffff is up to 7 decimal digits representing the fraction of a second.
//  
struct _WS_XML_TIMESPAN_TEXT {
    WS_XML_TEXT text;
    WS_TIMESPAN value;
};


//  XML Node structure
//  
//   Represents a qname formatted as the text "prefix:localName"
//  
struct _WS_XML_QNAME_TEXT {
    WS_XML_TEXT text;
    WS_XML_STRING* prefix;
    WS_XML_STRING* localName;
    WS_XML_STRING* ns;
};


//  XML Node structure
//  
//   Represents a list of text values separated by a single whitespace character.
//  
//   (e.g. The list { { WS_XML_TEXT_TYPE_INT32 }, 123},
//  { { WS_XML_TEXT_TYPE_BOOL }, 1 } represents the text "123 true")
//  
struct _WS_XML_LIST_TEXT {
    WS_XML_TEXT text;
    ULONG itemCount;
    WS_XML_TEXT** items;
};


//  XML Node structure
//  
//   An xml node is unit of data in xml.  This structure is the base type
//  for all the different kinds of nodes.
//  
struct _WS_XML_NODE {
    WS_XML_NODE_TYPE nodeType;
};


//  XML Node structure
//  
//   Represents an attribute (e.g. <a:purchaseOrder xmlns:a="http://tempuri.org" id="5">)
//  
struct _WS_XML_ATTRIBUTE {
    BYTE singleQuote;
    BYTE isXmlNs;
    WS_XML_STRING* prefix;
    WS_XML_STRING* localName;
    WS_XML_STRING* ns;
    WS_XML_TEXT* value;
};


//  XML Node structure
//  
//   Represents a start element in xml (e.g.
//  "<a:purchaseOrder xmlns:a="http://tempuri.org" id="5">")
//  
struct _WS_XML_ELEMENT_NODE {
    WS_XML_NODE node;
    WS_XML_STRING* prefix;
    WS_XML_STRING* localName;
    WS_XML_STRING* ns;
    ULONG attributeCount;
    WS_XML_ATTRIBUTE** attributes;
    BOOL isEmpty;
};


//  XML Node structure
//  
//   Represents an element, attribute, or CDATA content.
//  
struct _WS_XML_TEXT_NODE {
    WS_XML_NODE node;
    WS_XML_TEXT* text;
};


//  XML Node structure
//  
//   Represents a comment.  (e.g. "<!--The message follows-->")
//  
struct _WS_XML_COMMENT_NODE {
    WS_XML_NODE node;
    WS_XML_STRING value;
};


//  XML Reader structure
//  
//   Specifies where the reader should obtain the bytes that comprise the xml document.
//  
struct _WS_XML_READER_INPUT {
    WS_XML_READER_INPUT_TYPE inputType;
};


//  XML Reader structure
//  
//   Specifies that the source of the xml input is a buffer.
//  
struct _WS_XML_READER_BUFFER_INPUT {
    WS_XML_READER_INPUT input;
    void* encodedData;
    ULONG encodedDataSize;
};


//  XML Reader structure
//  
//   Specifies that the source of the xml should be obtained from a callback.
//  
struct _WS_XML_READER_STREAM_INPUT {
    WS_XML_READER_INPUT input;
    WS_READ_CALLBACK readCallback;
    void* readCallbackState;
};


//  XML Reader structure
//  
//   This structure is the base type for all the different kinds of reader encodings.
//  
struct _WS_XML_READER_ENCODING {
    WS_XML_READER_ENCODING_TYPE encodingType;
};


//  XML Reader structure
//  
//   Used to indicate that the reader should interpret the bytes it reads as textual xml.
//  
struct _WS_XML_READER_TEXT_ENCODING {
    WS_XML_READER_ENCODING encoding;
    WS_CHARSET charSet;
};


//  XML Reader structure
//  
//   Used to indicate that the reader should interpret the bytes it reads as binary xml.
//  
struct _WS_XML_READER_BINARY_ENCODING {
    WS_XML_READER_ENCODING encoding;
    WS_XML_DICTIONARY* staticDictionary;
    WS_XML_DICTIONARY* dynamicDictionary;
};


//  Utilities structure
//  
//   An array of unicode characters and a length.
//  
struct _WS_STRING {
    ULONG length;
    WCHAR* chars;
};


//  XML Reader structure
//  
//   Used to indicate that the reader should interpret the bytes it reads as in MTOM format.
//  
struct _WS_XML_READER_MTOM_ENCODING {
    WS_XML_READER_ENCODING encoding;
    WS_XML_READER_ENCODING* textEncoding;
    BOOL readMimeHeader;
    WS_STRING startInfo;
    WS_STRING boundary;
    WS_STRING startUri;
};


//  XML Reader structure
//  
//   Used to indicate that the reader should surface the bytes of the document as base64 encoded characters.
//  
struct _WS_XML_READER_RAW_ENCODING {
    WS_XML_READER_ENCODING encoding;
};


//  XML Writer structure
//  
//   This structure is the base type for all the different kinds of writer encodings.
//  
struct _WS_XML_WRITER_ENCODING {
    WS_XML_WRITER_ENCODING_TYPE encodingType;
};


//  XML Writer structure
//  
//   Used to indicate that the reader should emit bytes as textual xml.
//  
struct _WS_XML_WRITER_TEXT_ENCODING {
    WS_XML_WRITER_ENCODING encoding;
    WS_CHARSET charSet;
};


//  XML Writer structure
//  
//   Used to indicate that the writer should emit bytes as binary xml.
//  
struct _WS_XML_WRITER_BINARY_ENCODING {
    WS_XML_WRITER_ENCODING encoding;
    WS_XML_DICTIONARY* staticDictionary;
    WS_DYNAMIC_STRING_CALLBACK dynamicStringCallback;
    void* dynamicStringCallbackState;
};


//  XML Writer structure
//  
//   Used to indicate that the reader should emit bytes in MTOM format.
//  The MTOM format will represent bytes written to it as binary mime
//  parts rather than embedded base64 encoded text.
//  
struct _WS_XML_WRITER_MTOM_ENCODING {
    WS_XML_WRITER_ENCODING encoding;
    WS_XML_WRITER_ENCODING* textEncoding;
    BOOL writeMimeHeader;
    WS_STRING boundary;
    WS_STRING startInfo;
    WS_STRING startUri;
    ULONG maxInlineByteCount;
};


//  XML Writer structure
//  
//   Used to indicate that the writer should emit bytes from decoded base64 characters.
//  
struct _WS_XML_WRITER_RAW_ENCODING {
    WS_XML_WRITER_ENCODING encoding;
};


//  XML Writer structure
//  
//   Specifies where the writer should emit the bytes that comprise the xml document.
//  
struct _WS_XML_WRITER_OUTPUT {
    WS_XML_WRITER_OUTPUT_TYPE outputType;
};


//  XML Writer structure
//  
//   Specifies that the generated bytes should be placed in a buffer.
//  
struct _WS_XML_WRITER_BUFFER_OUTPUT {
    WS_XML_WRITER_OUTPUT output;
};


//  XML Writer structure
//  
//   Specifies that the generated bytes should be sent to callback.
//  
struct _WS_XML_WRITER_STREAM_OUTPUT {
    WS_XML_WRITER_OUTPUT output;
    WS_WRITE_CALLBACK writeCallback;
    void* writeCallbackState;
};


//  XML Writer structure
//  
//   A structure that is used to specify a set of WS_XML_WRITER_PROPERTYs.
//  
struct _WS_XML_WRITER_PROPERTIES {
    WS_XML_WRITER_PROPERTY* properties;
    ULONG propertyCount;
};


//  XML Reader structure
//  
//   A structure that is used to specify a set of WS_XML_READER_PROPERTYs.
//  
struct _WS_XML_READER_PROPERTIES {
    WS_XML_READER_PROPERTY* properties;
    ULONG propertyCount;
};


//  Async Model structure
//  
//   Used with the Async Model to specify the async callback and
//  a pointer which will be passed to the async callback.
//  
struct _WS_ASYNC_CONTEXT {
    WS_ASYNC_CALLBACK callback;
    void* callbackState;
};


//  Async Model structure
//  
//   Used by WsAsyncExecute to manage the state of an asynchronous operation.
//  
struct _WS_ASYNC_STATE {
    void* internal0;
    void* internal1;
    void* internal2;
    void* internal3;
    void* internal4;
};


//  Async Model structure
//  
//   Used with the WsAsyncExecute to specify the next function
//  to invoke in a series of async operations.
//  
struct _WS_ASYNC_OPERATION {
    WS_ASYNC_FUNCTION function;
};


//  Channel structure
//  
//   Specifies a channel specific setting.
//  
struct _WS_CHANNEL_PROPERTY {
    WS_CHANNEL_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Channel structure
//  
//   A structure that is used to specify the custom proxy for the channel, using
//  the WS_CHANNEL_PROPERTY_CUSTOM_HTTP_PROXY.
//  
struct _WS_CUSTOM_HTTP_PROXY {
    WS_STRING servers;
    WS_STRING bypass;
};


//  Channel structure
//  
//   A structure that is used to specify a set of WS_CHANNEL_PROPERTYs.
//  
struct _WS_CHANNEL_PROPERTIES {
    WS_CHANNEL_PROPERTY* properties;
    ULONG propertyCount;
};


//  Channel structure
//  
//   A structure that is used to specify a set of callbacks
//  that form the implementation of a custom channel.
//  
struct _WS_CUSTOM_CHANNEL_CALLBACKS {
    WS_CREATE_CHANNEL_CALLBACK createChannelCallback;
    WS_FREE_CHANNEL_CALLBACK freeChannelCallback;
    WS_RESET_CHANNEL_CALLBACK resetChannelCallback;
    WS_OPEN_CHANNEL_CALLBACK openChannelCallback;
    WS_CLOSE_CHANNEL_CALLBACK closeChannelCallback;
    WS_ABORT_CHANNEL_CALLBACK abortChannelCallback;
    WS_GET_CHANNEL_PROPERTY_CALLBACK getChannelPropertyCallback;
    WS_SET_CHANNEL_PROPERTY_CALLBACK setChannelPropertyCallback;
    WS_WRITE_MESSAGE_START_CALLBACK writeMessageStartCallback;
    WS_WRITE_MESSAGE_END_CALLBACK writeMessageEndCallback;
    WS_READ_MESSAGE_START_CALLBACK readMessageStartCallback;
    WS_READ_MESSAGE_END_CALLBACK readMessageEndCallback;
    WS_ABANDON_MESSAGE_CALLBACK abandonMessageCallback;
    WS_SHUTDOWN_SESSION_CHANNEL_CALLBACK shutdownSessionChannelCallback;
};


//  Channel structure
//  
//   Specifies an individual header that is mapped as part of WS_HTTP_MESSAGE_MAPPING.
//  
struct _WS_HTTP_HEADER_MAPPING {
    WS_XML_STRING headerName;
    ULONG headerMappingOptions;
};


//  Channel structure
//  
//   Specifies information about how an HTTP request or response should be
//  represented in a message object.
//  
struct _WS_HTTP_MESSAGE_MAPPING {
    ULONG requestMappingOptions;
    ULONG responseMappingOptions;
    WS_HTTP_HEADER_MAPPING** requestHeaderMappings;
    ULONG requestHeaderMappingCount;
    WS_HTTP_HEADER_MAPPING** responseHeaderMappings;
    ULONG responseHeaderMappingCount;
};


//  Serialization structure
//  
//   Represents a mapping between a C data type and an XML element.
//  
struct _WS_ELEMENT_DESCRIPTION {
    WS_XML_STRING* elementLocalName;
    WS_XML_STRING* elementNs;
    WS_TYPE type;
    void* typeDescription;
};


//  Channel structure
//  
//   The description of the format of a message.
//  
struct _WS_MESSAGE_DESCRIPTION {
    WS_XML_STRING* action;
    WS_ELEMENT_DESCRIPTION* bodyElementDescription;
};


//  Channel structure
//  
//   A structure that is used to specify a set of callbacks
//  that can transform the content type and encoded bytes of a sent message.
//  
struct _WS_CHANNEL_ENCODER {
    void* createContext;
    WS_CREATE_ENCODER_CALLBACK createEncoderCallback;
    WS_ENCODER_GET_CONTENT_TYPE_CALLBACK encoderGetContentTypeCallback;
    WS_ENCODER_START_CALLBACK encoderStartCallback;
    WS_ENCODER_ENCODE_CALLBACK encoderEncodeCallback;
    WS_ENCODER_END_CALLBACK encoderEndCallback;
    WS_FREE_ENCODER_CALLBACK freeEncoderCallback;
};


//  Channel structure
//  
//   A structure that is used to specify a set of callbacks
//  that can transform the content type and encoded bytes of a received message.
//  
struct _WS_CHANNEL_DECODER {
    void* createContext;
    WS_CREATE_DECODER_CALLBACK createDecoderCallback;
    WS_DECODER_GET_CONTENT_TYPE_CALLBACK decoderGetContentTypeCallback;
    WS_DECODER_START_CALLBACK decoderStartCallback;
    WS_DECODER_DECODE_CALLBACK decoderDecodeCallback;
    WS_DECODER_END_CALLBACK decoderEndCallback;
    WS_FREE_DECODER_CALLBACK freeDecoderCallback;
};


//  Channel structure
//  
//   Specifies the callback function and state for controlling the HTTP auto redirection behavior.
//  
//   See also, WS_HTTP_REDIRECT_CALLBACK_CONTEXT
//   and WS_CHANNEL_PROPERTY_HTTP_REDIRECT_CALLBACK_CONTEXT.
//  
struct _WS_HTTP_REDIRECT_CALLBACK_CONTEXT {
    WS_HTTP_REDIRECT_CALLBACK callback;
    void* state;
};


//  Endpoint Identity structure
//  
//   The base type for all endpoint identities.
//  
struct _WS_ENDPOINT_IDENTITY {
    WS_ENDPOINT_IDENTITY_TYPE identityType;
};


//  Endpoint Address structure
//  
//   Represents the network address of an endpoint.
//  
struct _WS_ENDPOINT_ADDRESS {
    WS_STRING url;
    WS_XML_BUFFER* headers;
    WS_XML_BUFFER* extensions;
    WS_ENDPOINT_IDENTITY* identity;
};


//  Endpoint Identity structure
//  
//   Type for specifying an endpoint identity represented by a DNS name.
//  
struct _WS_DNS_ENDPOINT_IDENTITY {
    WS_ENDPOINT_IDENTITY identity;
    WS_STRING dns;
};


//  Endpoint Identity structure
//  
//  
//   Type for specifying an endpoint identity represented by a UPN (user principal name).
//  
//  
struct _WS_UPN_ENDPOINT_IDENTITY {
    WS_ENDPOINT_IDENTITY identity;
    WS_STRING upn;
};


//  Endpoint Identity structure
//  
//   Type for specifying an endpoint identity represented by an SPN (service principal name).
//  
struct _WS_SPN_ENDPOINT_IDENTITY {
    WS_ENDPOINT_IDENTITY identity;
    WS_STRING spn;
};


//  Utilities structure
//  A structure used to serialize and deserialize an array of bytes.
struct _WS_BYTES {
    ULONG length;
    BYTE* bytes;
};


//  Endpoint Identity structure
//  
//   Type for RSA endpoint identity.
//  
struct _WS_RSA_ENDPOINT_IDENTITY {
    WS_ENDPOINT_IDENTITY identity;
    WS_BYTES modulus;
    WS_BYTES exponent;
};


//  Endpoint Identity structure
//  
//   Type for certificate endpoint identity
//  
struct _WS_CERT_ENDPOINT_IDENTITY {
    WS_ENDPOINT_IDENTITY identity;
    WS_BYTES rawCertificateData;
};


//  Endpoint Identity structure
//  
//   Type for unknown endpoint identity.  This type is only used to represent
//  an endpoint identity type that was deserialized but was not understood.
//  
struct _WS_UNKNOWN_ENDPOINT_IDENTITY {
    WS_ENDPOINT_IDENTITY identity;
    WS_XML_BUFFER* element;
};


//  Errors structure
//  
//   Specifies an error specific setting.
//  
struct _WS_ERROR_PROPERTY {
    WS_ERROR_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Faults structure
//  
//   A fault reason is a human-readable description of the failure conveyed
//  by the fault.  This structure is used within the WS_FAULT structure.
//  For more information about faults, see Faults.
//  
struct _WS_FAULT_REASON {
    WS_STRING text;
    WS_STRING lang;
};


//  Faults structure
//  
//   A fault code identifies the type of failure conveyed by a fault message.
//  This structure is used within the WS_FAULT structure.
//  For more information about faults, see Faults.
//  
struct _WS_FAULT_CODE {
    WS_XML_QNAME value;
    struct _WS_FAULT_CODE* subCode;
};


//  Faults structure
//  
//   A Fault is a value carried in the body of a message which conveys a
//  processing failure.  Faults are modeled using the WS_FAULT structure.
//  See Faults for more information.
//  
struct _WS_FAULT {
    WS_FAULT_CODE* code;
    WS_FAULT_REASON* reasons;
    ULONG reasonCount;
    WS_STRING actor;
    WS_STRING node;
    WS_XML_BUFFER* detail;
};


//  Faults structure
//  
//   A description of the detail element of a fault message.
//  
struct _WS_FAULT_DETAIL_DESCRIPTION {
    WS_XML_STRING* action;
    WS_ELEMENT_DESCRIPTION* detailElementDescription;
};


//  Heap structure
//  
//   Specifies a heap specific setting.
//  
struct _WS_HEAP_PROPERTY {
    WS_HEAP_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Heap structure
//  
//   A structure that is used to specify a set of WS_HEAP_PROPERTYs.
//  
struct _WS_HEAP_PROPERTIES {
    WS_HEAP_PROPERTY* properties;
    ULONG propertyCount;
};


//  Listener structure
//  
//   Specifies a listener specific setting.
//  
struct _WS_LISTENER_PROPERTY {
    WS_LISTENER_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Listener structure
//  
//   Specifies the list of blocked UserAgent sub-string's. This is
//  used with the WS_LISTENER_PROPERTY_DISALLOWED_USER_AGENT
//   listener property.
//  
struct _WS_DISALLOWED_USER_AGENT_SUBSTRINGS {
    ULONG subStringCount;
    WS_STRING** subStrings;
};


//  Listener structure
//  
//   A structure that is used to specify a set of WS_LISTENER_PROPERTYs.
//  
struct _WS_LISTENER_PROPERTIES {
    WS_LISTENER_PROPERTY* properties;
    ULONG propertyCount;
};


//  Listener structure
//  
//   A structure containing a list of host names.
//  
struct _WS_HOST_NAMES {
    WS_STRING* hostNames;
    ULONG hostNameCount;
};


//  Listener structure
//  
//   A structure that is used to specify a set of callbacks
//  that form the implementation of a custom
//  listener.
//  
struct _WS_CUSTOM_LISTENER_CALLBACKS {
    WS_CREATE_LISTENER_CALLBACK createListenerCallback;
    WS_FREE_LISTENER_CALLBACK freeListenerCallback;
    WS_RESET_LISTENER_CALLBACK resetListenerCallback;
    WS_OPEN_LISTENER_CALLBACK openListenerCallback;
    WS_CLOSE_LISTENER_CALLBACK closeListenerCallback;
    WS_ABORT_LISTENER_CALLBACK abortListenerCallback;
    WS_GET_LISTENER_PROPERTY_CALLBACK getListenerPropertyCallback;
    WS_SET_LISTENER_PROPERTY_CALLBACK setListenerPropertyCallback;
    WS_CREATE_CHANNEL_FOR_LISTENER_CALLBACK createChannelForListenerCallback;
    WS_ACCEPT_CHANNEL_CALLBACK acceptChannelCallback;
};


//  Message structure
//  
//   Specifies a message specific setting.
//  
struct _WS_MESSAGE_PROPERTY {
    WS_MESSAGE_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Message structure
//  
//   A structure that is used to specify a set of WS_MESSAGE_PROPERTYs.
//  
struct _WS_MESSAGE_PROPERTIES {
    WS_MESSAGE_PROPERTY* properties;
    ULONG propertyCount;
};


//  Security Channel Settings structure
//  
//   Specifies a crypto algorithm setting.
//  
struct _WS_SECURITY_ALGORITHM_PROPERTY {
    WS_SECURITY_ALGORITHM_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Security Channel Settings structure
//  
//  Defines the security algorithms and key lengths to be used with
//  WS-Security.  This setting is relevant to message security bindings
//  and mixed-mode security bindings.
//  
struct _WS_SECURITY_ALGORITHM_SUITE {
    WS_SECURITY_ALGORITHM_ID canonicalizationAlgorithm;
    WS_SECURITY_ALGORITHM_ID digestAlgorithm;
    WS_SECURITY_ALGORITHM_ID symmetricSignatureAlgorithm;
    WS_SECURITY_ALGORITHM_ID asymmetricSignatureAlgorithm;
    WS_SECURITY_ALGORITHM_ID encryptionAlgorithm;
    WS_SECURITY_ALGORITHM_ID keyDerivationAlgorithm;
    WS_SECURITY_ALGORITHM_ID symmetricKeyWrapAlgorithm;
    WS_SECURITY_ALGORITHM_ID asymmetricKeyWrapAlgorithm;
    ULONG minSymmetricKeyLength;
    ULONG maxSymmetricKeyLength;
    ULONG minAsymmetricKeyLength;
    ULONG maxAsymmetricKeyLength;
    WS_SECURITY_ALGORITHM_PROPERTY* properties;
    ULONG propertyCount;
};


//  Security Channel Settings structure
//  
//   Specifies a channel-wide security setting.
//  
struct _WS_SECURITY_PROPERTY {
    WS_SECURITY_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Security Channel Settings structure
//  
//   Specifies an array of channel-wide security settings.
//  
struct _WS_SECURITY_PROPERTIES {
    WS_SECURITY_PROPERTY* properties;
    ULONG propertyCount;
};


//  Security Binding Settings structure
//  
//   Specifies a security binding specific setting.
//  
struct _WS_SECURITY_BINDING_PROPERTY {
    WS_SECURITY_BINDING_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Security Channel Settings structure
//  
//   Specifies an array of security binding settings.
//  
struct _WS_SECURITY_BINDING_PROPERTIES {
    WS_SECURITY_BINDING_PROPERTY* properties;
    ULONG propertyCount;
};


//  Extended Protection structure
//  
//   A list of Server Principal Names (SPNs) that are used to validate Extended Protection.
//  
//   Only available on the server.
//  
struct _WS_SERVICE_SECURITY_IDENTITIES {
    WS_STRING* serviceIdentities;
    ULONG serviceIdentityCount;
};


//  Security Credentials structure
//  
//  The abstract base type for all certificate credential types.
//  
struct _WS_CERT_CREDENTIAL {
    WS_CERT_CREDENTIAL_TYPE credentialType;
};


//  Security Credentials structure
//  
//  The type for specifying a certificate credential using the
//  certificate's subject name, store location and store name.  The
//  specified credential is loaded when the containing channel or listener
//  is opened.
//  
struct _WS_SUBJECT_NAME_CERT_CREDENTIAL {
    WS_CERT_CREDENTIAL credential;
    ULONG storeLocation;
    WS_STRING storeName;
    WS_STRING subjectName;
};


//  Security Credentials structure
//  
//  The type for specifying a certificate credential using the
//  certificate's thumbprint, store location and store name.  The
//  specified credential is loaded when the containing channel or listener
//  is opened.
//  
//  The thumbprint is the best option for specifying a certificate when
//  subject name based specification is expected to be ambiguous due to
//  the presence of multiple certificates with matching subject names in
//  the cert store being specified.
//  
struct _WS_THUMBPRINT_CERT_CREDENTIAL {
    WS_CERT_CREDENTIAL credential;
    ULONG storeLocation;
    WS_STRING storeName;
    WS_STRING thumbprint;
};


//  Security Credentials structure
//  
//  The type for specifying a certificate credential that is to be
//  supplied by a callback to the application.  This callback is invoked
//  to get the certificate during WsOpenChannel on the client
//  side and during WsOpenListener on the server side.  It is
//  always invoked (WS_SHORT_CALLBACK) short.
//  
struct _WS_CUSTOM_CERT_CREDENTIAL {
    WS_CERT_CREDENTIAL credential;
    WS_GET_CERT_CALLBACK getCertCallback;
    void* getCertCallbackState;
    WS_CERT_ISSUER_LIST_NOTIFICATION_CALLBACK certIssuerListNotificationCallback;
    void* certIssuerListNotificationCallbackState;
};


//  Security Credentials structure
//  
//  The abstract base type for all credential types used with Windows
//  Integrated Authentication.
//  
struct _WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL {
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL_TYPE credentialType;
};


//  Security Credentials structure
//  
//  Type for supplying a Windows credential as username, password, domain strings.
//  
struct _WS_STRING_WINDOWS_INTEGRATED_AUTH_CREDENTIAL {
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL credential;
    WS_STRING username;
    WS_STRING password;
    WS_STRING domain;
};


//  Security Credentials structure
//  
//   Type for supplying a Windows Integrated Authentication credential based on the current Windows identity.
//  If this credential subtype is used for a security binding, the current thread token on the thread that calls
//   WsOpenChannel or WsOpenServiceProxy is used as the Windows
//  identity when sending messages or making service calls. WsAcceptChannel and WsOpenServiceHost do not support this credential type when called
//  from an impersonating thread.
//  
struct _WS_DEFAULT_WINDOWS_INTEGRATED_AUTH_CREDENTIAL {
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL credential;
};


//  Security Credentials structure
//  
//  Type for supplying a Windows Integrated Authentication credential as an opaque handle created by
//  SspiPromptForCredentials and the related family of APIs.  This feature
//  is available only on Windows 7 and later.
//  
struct _WS_OPAQUE_WINDOWS_INTEGRATED_AUTH_CREDENTIAL {
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL credential;
    void* opaqueAuthIdentity;
};


//  Security Credentials structure
//  
//  The abstract base type for all username/password credentials.
//  
//  Note that WS_USERNAME_CREDENTIAL and its concrete subtypes
//  are used with the WS-Security WS_USERNAME_MESSAGE_SECURITY_BINDING.
//  They are best suitable for application-level username/password pairs, such as
//  those used for online customer accounts.  The usernames and passwords specified
//  are not interpreted by the security runtime, and are merely carried
//  client-to-server for authentication by the specified server-side
//  username/password validator specified by the application.
//  
//  In contrast, the WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL and
//  its concrete subtypes are used for Windows Integrated Authentication
//  and the security bindings that use it.
//  
struct _WS_USERNAME_CREDENTIAL {
    WS_USERNAME_CREDENTIAL_TYPE credentialType;
};


//  Security Credentials structure
//  
//  The type for supplying a username/password pair as strings.
//  
struct _WS_STRING_USERNAME_CREDENTIAL {
    WS_USERNAME_CREDENTIAL credential;
    WS_STRING username;
    WS_STRING password;
};


//  Security Bindings structure
//  
//  The abstract base type for all types that specify a cryptographic key.
//  Such a key is typically specified for a generic XML security token or
//  a custom security token.
//  
struct _WS_SECURITY_KEY_HANDLE {
    WS_SECURITY_KEY_HANDLE_TYPE keyHandleType;
};


//  Security Bindings structure
//  
//  The type for specifying a symmetric cryptographic key as raw bytes.
//  
struct _WS_RAW_SYMMETRIC_SECURITY_KEY_HANDLE {
    WS_SECURITY_KEY_HANDLE keyHandle;
    WS_BYTES rawKeyBytes;
};


//  Security Bindings structure
//  
//  The type for specifying asymmetric cryptographic keys as a CryptoNG
//  NCRYPT_KEY_HANDLE.
//  
//  When this structure is used in an API (such as with
//   (WsCreateXmlSecurityToken) XML token creation) and subsequent
//   (WS_XML_TOKEN_MESSAGE_SECURITY_BINDING) use of that XML
//  token for a channel), the application is responsible for making
//  sure that the NCRYPT_KEY_HANDLE remains valid as long as the key is in
//  use.  The application is also responsible for freeing the handle when
//  it is no longer in use.
//  
//  This type is supported only on Windows Vista and later platforms.
//  
struct _WS_NCRYPT_ASYMMETRIC_SECURITY_KEY_HANDLE {
    WS_SECURITY_KEY_HANDLE keyHandle;
    NCRYPT_KEY_HANDLE asymmetricKey;
};


//  Security Bindings structure
//  
//  The type for specifying asymmetric cryptographic keys as CAPI 1.0 key
//  handles.
//  
//  When this structure is used in an API (such as
//  with (WsCreateXmlSecurityToken) XML token creation and subsequent
//   (WS_XML_TOKEN_MESSAGE_SECURITY_BINDING) use of that XML
//  token for a channel), the application is responsible for making
//  sure that the HCRYPTPROV remains valid as long as the key is in
//  use.  The application is also responsible for freeing the handle when
//  it is no longer in use.
//  
//  This type is supported only on pre-Windows Vista platforms: for
//  Windows Vista and later, please use WS_NCRYPT_ASYMMETRIC_SECURITY_KEY_HANDLE.
//  
struct _WS_CAPI_ASYMMETRIC_SECURITY_KEY_HANDLE {
    WS_SECURITY_KEY_HANDLE keyHandle;
    HCRYPTPROV provider;
    ULONG keySpec;
};


//  Security Bindings structure
//  
//  The abstract base type for all security bindings.  One or more
//  concrete subtypes of this are specified in the
//   (WS_SECURITY_DESCRIPTION) security description that is
//  supplied during channel and listener creation.  Each concrete subtype
//  of this corresponds to a security protocol and a way of using it to
//  provide authentication and/or protection to a channel.
//  
//  Each security binding subtype instance in the security description
//  contributes one security token at runtime.  Thus, the fields of this
//  type can be viewed as specifying a security token, how to obtain it,
//  how to use it for channel security, and how to modify its behavior
//  using the optional settings.
//  
struct _WS_SECURITY_BINDING {
    WS_SECURITY_BINDING_TYPE bindingType;
    WS_SECURITY_BINDING_PROPERTY* properties;
    ULONG propertyCount;
};


//  Security Bindings structure
//  
//   The security binding subtype for specifying the use of SSL/TLS
//  protocol based transport security.
//  
//   This security binding is supported only with the
//   WS_HTTP_CHANNEL_BINDING.
//  
//   With this security binding, the following security binding property may be specified:
//  
//  . WS_SECURITY_BINDING_PROPERTY_CERT_FAILURES_TO_IGNORE (client side only)
//  
//  . WS_SECURITY_BINDING_PROPERTY_DISABLE_CERT_REVOCATION_CHECK (client side only)
//  
//  . WS_SECURITY_BINDING_PROPERTY_REQUIRE_SSL_CLIENT_CERT (server side only)
//  
//  
struct _WS_SSL_TRANSPORT_SECURITY_BINDING {
    WS_SECURITY_BINDING binding;
    WS_CERT_CREDENTIAL* localCertCredential;
};


//  Security Bindings structure
//  
//  The security binding subtype for specifying the use of the Windows
//  Integrated Authentication protocol (such as Kerberos, NTLM or SPNEGO)
//  with the TCP transport.  A specific SSP package may be chosen using
//  the security binding property
//   WS_SECURITY_BINDING_PROPERTY_WINDOWS_INTEGRATED_AUTH_PACKAGE;
//  if that property is not specified, SPNEGO is used by default.  The use
//  of NTLM is strongly discouraged due to its security weakness
//  (specifically, lack of server authentication).  If NTLM is to be
//  allowed, the security binding property WS_SECURITY_BINDING_PROPERTY_REQUIRE_SERVER_AUTH
//  must be set to FALSE.
//  
//  This security binding operates at the transport security level and is
//  supported only with the WS_TCP_CHANNEL_BINDING.  The
//  TCP/Windows SSPI combination uses the wire form defined by the
//   (http://msdn.microsoft.com/en-us/library/cc219293.aspx) NegotiateStream
//  protocol and the (http://msdn.microsoft.com/en-us/library/cc236723.aspx) .Net Message Framing specification.
//  
//  On the client side, the security identity of the target server is
//  specified using the identity field of the WS_ENDPOINT_ADDRESS
//  parameter supplied during WsOpenChannel.  If the identity is a
//   WS_SPN_ENDPOINT_IDENTITY or a WS_UPN_ENDPOINT_IDENTITY,
//  that string identity value is used directly with the SSP.  If the identity is a
//   WS_DNS_ENDPOINT_IDENTITY and the value of its dns field is
//  'd1', or if no identity is specified in the WS_ENDPOINT_ADDRESS
//  and the host component (according to Section 3.2.2 of
//   (http://tools.ietf.org/html/rfc2396) RFC2396) the address URI
//  is 'd1', then the form 'host/d1' is used as the server SPN.
//  Specifying any other WS_ENDPOINT_IDENTITY subtype in
//   WS_ENDPOINT_ADDRESS will cause WsOpenChannel to fail.
//  
//  With this security binding, the following security binding properties may be specified:
//  
//  . WS_SECURITY_BINDING_PROPERTY_WINDOWS_INTEGRATED_AUTH_PACKAGE
//  . WS_SECURITY_BINDING_PROPERTY_REQUIRE_SERVER_AUTH (client side only)
//  
//  . WS_SECURITY_BINDING_PROPERTY_ALLOW_ANONYMOUS_CLIENTS (server side only)
//  
//  . WS_SECURITY_BINDING_PROPERTY_ALLOWED_IMPERSONATION_LEVEL (client side only)
//  
struct _WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING {
    WS_SECURITY_BINDING binding;
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL* clientCredential;
};


//  Security Bindings structure
//  
//   The security binding subtype for specifying the use of HTTP header authentication against a target service or a HTTP proxy server
//  based on the basic, digest ( (http://tools.ietf.org/html/rfc2617) RFC 2617) and the SPNEGO ( (http://tools.ietf.org/html/rfc4559) RFC4559) protocols.
//  Since this security binding operates at the HTTP header level, it is supported only with the WS_HTTP_CHANNEL_BINDING.
//  By default, this security binding is used for the target service. However WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_TARGET
//   security binding property can be specified to use it for a HTTP proxy server. This binding provides client authentication, but not message protection
//  since the HTTP body is unaffected by this binding. While this security binding can be used alone, such usage is not recommended;
//  more typically, HTTP header authentication is done in conjunction with transport level security provided by a security binding such as the
//   WS_SSL_TRANSPORT_SECURITY_BINDING. To use this binding without SSL, the the security description property
//   WS_SECURITY_PROPERTY_TRANSPORT_PROTECTION_LEVEL must be explicitly set to WS_PROTECTION_LEVEL_NONE or WS_PROTECTION_LEVEL_SIGN.
//  
//  With this security binding, the following security binding properties may be specified:
//  
//  . WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_SCHEME
//  . WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_TARGET (client side only)
//  
//  . WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_BASIC_REALM (server side only)
//  
//  . WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_DIGEST_REALM (server side only)
//  
//  . WS_SECURITY_BINDING_PROPERTY_HTTP_HEADER_AUTH_DIGEST_DOMAIN (server side only)
//  
struct _WS_HTTP_HEADER_AUTH_SECURITY_BINDING {
    WS_SECURITY_BINDING binding;
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL* clientCredential;
};


//  Security Bindings structure
//  
//   The security binding subtype for specifying the use of the Kerberos
//  AP_REQ ticket as a direct (i.e., without establishing a session)
//  security token with WS-Security.
//  
//   Only one instance of this binding may be present in a (WS_SECURITY_DESCRIPTION) security description.
//  
//   With this security binding, the following security binding properties may be specified:
//  
//  . WS_SECURITY_BINDING_PROPERTY_ALLOWED_IMPERSONATION_LEVEL (client side only)
//  
//  . WS_SECURITY_BINDING_PROPERTY_ALLOW_ANONYMOUS_CLIENTS (server side only)
//  
//   Client side on Vista and above, using this binding with HTTP will result in the message being sent using chunked transfer.
//  
struct _WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING {
    WS_SECURITY_BINDING binding;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL* clientCredential;
};


//  Security Bindings structure
//  
//   The security binding subtype for specifying the use of an application
//  supplied username / password pair as a direct (i.e., one-shot)
//  security token.  This security binding may be used only with message
//  security.  It provides client authentication, but not traffic signing
//  or encryption.  So, it is used in conjunction with another transport
//  security or message security binding that provides message protection.
//  
//   Only one instance of this binding may be present in a (WS_SECURITY_DESCRIPTION) security description.
//  
//   With this security binding, no security binding properties may be specified.
//  
struct _WS_USERNAME_MESSAGE_SECURITY_BINDING {
    WS_SECURITY_BINDING binding;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
    WS_USERNAME_CREDENTIAL* clientCredential;
    WS_VALIDATE_PASSWORD_CALLBACK passwordValidator;
    void* passwordValidatorCallbackState;
};


//  Security Description structure
//  
//  
//  The top-level structure used to specify the security requirements for
//  a (WsCreateChannel) channel (on the client side) or a (WsCreateListener) listener (on the server side).
//  
//  
struct _WS_SECURITY_DESCRIPTION {
    WS_SECURITY_BINDING** securityBindings;
    ULONG securityBindingCount;
    WS_SECURITY_PROPERTY* properties;
    ULONG propertyCount;
};


//  Security Bindings structure
//  
//   The security binding subtype for specifying the use of a security context
//  token negotiated between the client and server using
//  WS-SecureConversation. This security binding may be used only with
//  message security. It is used to establish a message-level security
//  context. Another set of one or more security bindings, specified in the
//  bootstrapSecurityDescription field, is used to the bootstrap the context.
//  
//   Only one instance of this binding may be present in a (WS_SECURITY_DESCRIPTION) security description.
//  
//   When this binding is used, the channel must complete the receive of at least one
//  message before it can be used to send messages.
//  
//   With this security binding, the following security binding properties may be specified:
//  
//  . WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_KEY_SIZE
//  . WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_KEY_ENTROPY_MODE
//  . WS_SECURITY_BINDING_PROPERTY_MESSAGE_PROPERTIES
//  . WS_SECURITY_BINDING_PROPERTY_SECURE_CONVERSATION_VERSION
//  . WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_SUPPORT_RENEW
//  . WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_RENEWAL_INTERVAL
//  . WS_SECURITY_BINDING_PROPERTY_SECURITY_CONTEXT_ROLLOVER_INTERVAL
struct _WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING {
    WS_SECURITY_BINDING binding;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
    WS_SECURITY_DESCRIPTION* bootstrapSecurityDescription;
};


//  Security Context structure
//  
//   Defines a property of a WS_SECURITY_CONTEXT
struct _WS_SECURITY_CONTEXT_PROPERTY {
    WS_SECURITY_CONTEXT_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Security Channel Settings structure
//  
//   Specifies a property for an XML security token.
//  
struct _WS_XML_SECURITY_TOKEN_PROPERTY {
    WS_XML_SECURITY_TOKEN_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Security Bindings structure
//  
//  The security binding subtype for specifying the use of a security
//  token that is already available to the application in XML form.  The
//  security token that is supplied by the application in this binding is
//  presented to a service in a WS-Security header according to the
//  bindingUsage specified.  This security binding may be included in a
//   (WS_SECURITY_DESCRIPTION) security description only on the
//  client side.
//  
//  Although this binding can be used with any token available in XML
//  form, this is commonly used in (Federation) federation
//  scenarios.  For example, a client side token provider such as
//  CardSpace may be used to get a token from a security token service,
//  and that token may then be presented to a Web Service using this
//  security binding.
//  
//  Security note: As with other security tokens and credentials, the
//  application is in charge of the risk assessment decision to disclose a
//  given XML token (supplied by the application in a
//   (WS_SECURITY_DESCRIPTION) security description) to a given
//  server (supplied by the application when
//   (WsOpenChannel) opening the channel).  In particular, the
//  application should consider the threat that the server might use the
//  XML token it receives from the client, in turn, to pretend to be the
//  client to a 3rd party.  For this threat, the following mitigations
//  exist: (A) the server authentication process makes sure that the
//  message (and hence the token) is sent only to a server that can speak
//  for the address specified by the client application; (B) keyless
//  (bearer) tokens are typically usable only at one server (e.g.,
//  contoso.com gains little from passing on a contoso.com
//  username/password token to another site -- the application security
//  design should make sure this property holds); (C) symmetric keyed
//  tokens are unusable at any server that doesn't share the same
//  symmetric key; (D) asymmetric keyed tokens will sign the timestamp and
//  the 'To' header, limiting their applicability to the intended 'To' for
//  a narrow time duration.
//  
//  With this security binding, no security binding properties may be specified:
//  
struct _WS_XML_TOKEN_MESSAGE_SECURITY_BINDING {
    WS_SECURITY_BINDING binding;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
    WS_SECURITY_TOKEN* xmlToken;
};


//  Security Bindings structure
//  
//  The abstract base type for all SAML authenticators used on the server
//  side to validate incoming SAML tokens.
//  
struct _WS_SAML_AUTHENTICATOR {
    WS_SAML_AUTHENTICATOR_TYPE authenticatorType;
};


//  Security Bindings structure
//  
//  The type for specifying a SAML token authenticator based on an array
//  of expected issuer certificates.  When an authenticator of this type
//  is used, an incoming SAML token will be accepted if only if it has a
//  valid XML signature created with any one of the specified X.509
//  certificates.  Thus, the specified X.509 certificates represent a
//  'allow list' of trusted SAML issuers.
//  
//  No revocation or chain trust checks are done by the runtime on the
//  specified certificates: so, it is up to the application to make sure
//  that the certificates are valid before they are specified in this
//  structure.
//  
//  As indicated above, the validation of the received SAML is limited to
//  making sure that it was signed correctly by one of the specified
//  certificates.  The application may then extract the SAML assertion
//  using WsGetMessageProperty with the key
//   WS_MESSAGE_PROPERTY_SAML_ASSERTION and do
//  additional validator or processing.
//  
struct _WS_CERT_SIGNED_SAML_AUTHENTICATOR {
    WS_SAML_AUTHENTICATOR authenticator;
    const struct _CERT_CONTEXT** trustedIssuerCerts;
    ULONG trustedIssuerCertCount;
    const struct _CERT_CONTEXT* decryptionCert;
    WS_VALIDATE_SAML_CALLBACK samlValidator;
    void* samlValidatorCallbackState;
};


//  Security Bindings structure
//  
//   The security binding subtype for specifying the use of a SAML
//  assertion as a message security token.  The SAML token is expected to
//  be presented to a service in a WS-Security header according to the
//  bindingUsage specified.  This security binding may be included in a
//   (WS_SECURITY_DESCRIPTION) security description only on the
//  server side.
//  
//   Only one instance of this binding may be present in a (WS_SECURITY_DESCRIPTION) security description.
//  
//   For a (Federation) federated security scenario that
//  involves getting a security token from an issuer and then presenting
//  it to a service, one may use WsRequestSecurityToken
//   together with the WS_XML_TOKEN_MESSAGE_SECURITY_BINDING on
//  the client side, and this binding on the server side.
//  
//   The extent of validation performed on the received SAML depends on the
//  authenticator specified.  If additional validation is required, the
//  application may get the received SAML assertion using
//   WsGetMessageProperty with the key WS_MESSAGE_PROPERTY_SAML_ASSERTION
//   and do further processing.
//  
//   With this security binding, no security binding properties may be specified:
//  
struct _WS_SAML_MESSAGE_SECURITY_BINDING {
    WS_SECURITY_BINDING binding;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
    WS_SAML_AUTHENTICATOR* authenticator;
};


//  Security Channel Settings structure
//  
//   Specifies a property for requesting a security token from an issuer.
//  
struct _WS_REQUEST_SECURITY_TOKEN_PROPERTY {
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Serialization structure
//  
//   This type is used to store an attribute
//  that has not been directly mapped to a field.
//  
struct _WS_ANY_ATTRIBUTE {
    WS_XML_STRING localName;
    WS_XML_STRING ns;
    WS_XML_TEXT* value;
};


//  Serialization structure
//  
//   This type is used to store a set of attributes
//  that have not been directly mapped to field of
//  a structure.
//  
struct _WS_ANY_ATTRIBUTES {
    WS_ANY_ATTRIBUTE* attributes;
    ULONG attributeCount;
};


//  Serialization structure
//  
//   This type description is used with WS_BOOL_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_BOOL_DESCRIPTION {
    BOOL value;
};


//  Serialization structure
//  
//   This type description is used with WS_GUID_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_GUID_DESCRIPTION {
    GUID value;
};


//  Serialization structure
//  
//   This type description is used with WS_DATETIME_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
//   Only the ticks field of the WS_DATETIME is compared.
//  
struct _WS_DATETIME_DESCRIPTION {
    WS_DATETIME minValue;
    WS_DATETIME maxValue;
};


//  Utilities structure
//  
//   Represents a (http://www.w3.org/TR/xmlschema-2/#duration) xsd:duration.
//  
struct _WS_DURATION {
    BOOL negative;
    ULONG years;
    ULONG months;
    ULONG days;
    ULONG hours;
    ULONG minutes;
    ULONG seconds;
    ULONG milliseconds;
    ULONG ticks;
};


//  Serialization structure
//  
//   This type description is used with WS_DURATION_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_DURATION_DESCRIPTION {
    WS_DURATION minValue;
    WS_DURATION maxValue;
    WS_DURATION_COMPARISON_CALLBACK comparer;
};


//  Serialization structure
//  
//   This type description is used with WS_TIMESPAN_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_TIMESPAN_DESCRIPTION {
    WS_TIMESPAN minValue;
    WS_TIMESPAN maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_UNIQUE_ID_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_UNIQUE_ID_DESCRIPTION {
    ULONG minCharCount;
    ULONG maxCharCount;
};


//  Serialization structure
//  
//   This type description is used with WS_STRING_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_STRING_DESCRIPTION {
    ULONG minCharCount;
    ULONG maxCharCount;
};


//  Serialization structure
//  
//   This type description is used with WS_XML_STRING_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_XML_STRING_DESCRIPTION {
    ULONG minByteCount;
    ULONG maxByteCount;
};


//  Serialization structure
//  
//   This type description is used with WS_XML_QNAME_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_XML_QNAME_DESCRIPTION {
    ULONG minLocalNameByteCount;
    ULONG maxLocalNameByteCount;
    ULONG minNsByteCount;
    ULONG maxNsByteCount;
};


//  Serialization structure
//  
//   This type description is used with WS_CHAR_ARRAY_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_CHAR_ARRAY_DESCRIPTION {
    ULONG minCharCount;
    ULONG maxCharCount;
};


//  Serialization structure
//  
//   This type description is used with WS_BYTE_ARRAY_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_BYTE_ARRAY_DESCRIPTION {
    ULONG minByteCount;
    ULONG maxByteCount;
};


//  Serialization structure
//  
//   This type description is used with WS_UTF8_ARRAY_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_UTF8_ARRAY_DESCRIPTION {
    ULONG minByteCount;
    ULONG maxByteCount;
};


//  Serialization structure
//  
//   This type description is used with WS_WSZ_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_WSZ_DESCRIPTION {
    ULONG minCharCount;
    ULONG maxCharCount;
};


//  Serialization structure
//  
//   This type description is used with WS_INT8_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_INT8_DESCRIPTION {
    char minValue;
    char maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_UINT8_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_UINT8_DESCRIPTION {
    BYTE minValue;
    BYTE maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_INT16_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_INT16_DESCRIPTION {
    short minValue;
    short maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_UINT16_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_UINT16_DESCRIPTION {
    USHORT minValue;
    USHORT maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_INT32_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_INT32_DESCRIPTION {
    int minValue;
    int maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_UINT32_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_UINT32_DESCRIPTION {
    ULONG minValue;
    ULONG maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_INT64_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_INT64_DESCRIPTION {
    __int64 minValue;
    __int64 maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_UINT64_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_UINT64_DESCRIPTION {
    unsigned __int64 minValue;
    unsigned __int64 maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_FLOAT_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_FLOAT_DESCRIPTION {
    float minValue;
    float maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_DOUBLE_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_DOUBLE_DESCRIPTION {
    double minValue;
    double maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_DECIMAL_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_DECIMAL_DESCRIPTION {
    DECIMAL minValue;
    DECIMAL maxValue;
};


//  Serialization structure
//  
//   This type description is used with WS_BYTES_TYPE and is optional.
//  It is used to specify constraints on the set of values
//  which can be deserialized.
//  
struct _WS_BYTES_DESCRIPTION {
    ULONG minByteCount;
    ULONG maxByteCount;
};


//  Serialization structure
//  
//   Provides serialization information about a single value that
//  is part of an enumeration ( WS_ENUM_DESCRIPTION).
//  
struct _WS_ENUM_VALUE {
    int value;
    WS_XML_STRING* name;
};


//  Serialization structure
//  
//   This type description is used with WS_ENUM_TYPE and is required.
//  It provides information used in serializing and deserializing
//  values of an enumeration.
//  
struct _WS_ENUM_DESCRIPTION {
    WS_ENUM_VALUE* values;
    ULONG valueCount;
    ULONG maxByteCount;
    ULONG* nameIndices;
};


//  Serialization structure
//  
//   Defines the minimum and maximum number of items that may appear
//  when using WS_REPEATING_ELEMENT_FIELD_MAPPING,
//   WS_REPEATING_ELEMENT_CHOICE_FIELD_MAPPING,
//  or WS_REPEATING_ANY_ELEMENT_FIELD_MAPPING within
//  a WS_FIELD_DESCRIPTION.  The constraint is only
//  enforced during deserialization.
//  
struct _WS_ITEM_RANGE {
    ULONG minItemCount;
    ULONG maxItemCount;
};


//  Serialization structure
//  
//   Defines a default value for a field.  This is used
//  in a WS_FIELD_DESCRIPTION.
//  
struct _WS_DEFAULT_VALUE {
    void* value;
    ULONG valueSize;
};


//  Serialization structure
//  
//   Used within a WS_STRUCT_DESCRIPTION to represent a field
//  of a structure that is mapped to XML content according to a particular
//   WS_FIELD_MAPPING.
//  
struct _WS_FIELD_DESCRIPTION {
    WS_FIELD_MAPPING mapping;
    WS_XML_STRING* localName;
    WS_XML_STRING* ns;
    WS_TYPE type;
    void* typeDescription;
    ULONG offset;
    ULONG options;
    WS_DEFAULT_VALUE* defaultValue;
    ULONG countOffset;
    WS_XML_STRING* itemLocalName;
    WS_XML_STRING* itemNs;
    WS_ITEM_RANGE* itemRange;
};


//  Serialization structure
//  
//   Represents serialization information about a field within a union.
//  See WS_UNION_DESCRIPTION.
//  
struct _WS_UNION_FIELD_DESCRIPTION {
    int value;
    WS_FIELD_DESCRIPTION field;
};


//  Serialization structure
//  
//   Information about C struct type, and how it maps to an XML element.
//  This is used with WS_STRUCT_TYPE.
//  
struct _WS_STRUCT_DESCRIPTION {
    ULONG size;
    ULONG alignment;
    WS_FIELD_DESCRIPTION** fields;
    ULONG fieldCount;
    WS_XML_STRING* typeLocalName;
    WS_XML_STRING* typeNs;
    WS_STRUCT_DESCRIPTION* parentType;
    WS_STRUCT_DESCRIPTION** subTypes;
    ULONG subTypeCount;
    ULONG structOptions;
};


//  Serialization structure
//  
//   Information about the choices within a union type.
//  This is used with WS_UNION_TYPE.
//  
struct _WS_UNION_DESCRIPTION {
    ULONG size;
    ULONG alignment;
    WS_UNION_FIELD_DESCRIPTION** fields;
    ULONG fieldCount;
    ULONG enumOffset;
    int noneEnumValue;
    ULONG* valueIndices;
};


//  Serialization structure
//  
//   Information about a mapping between an WS_ENDPOINT_ADDRESS
//   and an XML element.
//  
struct _WS_ENDPOINT_ADDRESS_DESCRIPTION {
    WS_ADDRESSING_VERSION addressingVersion;
};


//  Serialization structure
//  
//   Information about a mapping between an WS_FAULT and an XML element.
//  
struct _WS_FAULT_DESCRIPTION {
    WS_ENVELOPE_VERSION envelopeVersion;
};


//  Serialization structure
//  
//   Specifies information about a field which is neither serialized nor
//  deserialized.
//  
//   This is used with WS_VOID_TYPE and WS_NO_FIELD_MAPPING
//   within a WS_FIELD_DESCRIPTION.
//  
//   This type description is only required when WS_FIELD_POINTER is not
//  being used.
//  
struct _WS_VOID_DESCRIPTION {
    ULONG size;
};


//  Serialization structure
//  
//   Represents a custom mapping between a C data type and an XML element.
//  User-defined callbacks are invoked to do the actual reading and
//  writing.
//  
struct _WS_CUSTOM_TYPE_DESCRIPTION {
    ULONG size;
    ULONG alignment;
    WS_READ_TYPE_CALLBACK readCallback;
    WS_WRITE_TYPE_CALLBACK writeCallback;
    void* descriptionData;
    WS_IS_DEFAULT_VALUE_CALLBACK isDefaultValueCallback;
};


//  Serialization structure
//  
//   Represents a mapping between a C data type and an XML attribute.
//  
struct _WS_ATTRIBUTE_DESCRIPTION {
    WS_XML_STRING* attributeLocalName;
    WS_XML_STRING* attributeNs;
    WS_TYPE type;
    void* typeDescription;
};


//  Service Operation structure
//  
//   The index of the parameters in the incoming/outgoing messages field descriptions.
//  
struct _WS_PARAMETER_DESCRIPTION {
    WS_PARAMETER_TYPE parameterType;
    USHORT inputMessageIndex;
    USHORT outputMessageIndex;
};


//  Service Operation structure
//  
//   Metadata for the  service operation.
//  
struct _WS_OPERATION_DESCRIPTION {
    ULONG versionInfo;
    WS_MESSAGE_DESCRIPTION* inputMessageDescription;
    WS_MESSAGE_DESCRIPTION* outputMessageDescription;
    ULONG inputMessageOptions;
    ULONG outputMessageOptions;
    USHORT parameterCount;
    WS_PARAMETER_DESCRIPTION* parameterDescription;
    WS_SERVICE_STUB_CALLBACK stubCallback;
    WS_OPERATION_STYLE style;
};


//  Contract structure
//  
//   The metadata for a service contract for service model.
//  
struct _WS_CONTRACT_DESCRIPTION {
    ULONG operationCount;
    WS_OPERATION_DESCRIPTION** operations;
};


//  Contract structure
//  
//   Used to specify a service contract on an (WS_SERVICE_ENDPOINT) endpoint.
//  
struct _WS_SERVICE_CONTRACT {
    const WS_CONTRACT_DESCRIPTION* contractDescription;
    WS_SERVICE_MESSAGE_RECEIVE_CALLBACK defaultMessageHandlerCallback;
    const void* methodTable;
};


//  Service Host structure
//  
//   Specifies a service specific setting.
//  
struct _WS_SERVICE_PROPERTY {
    WS_SERVICE_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Service Host structure
//  
//   Specifies a service specific setting.
//  
struct _WS_SERVICE_ENDPOINT_PROPERTY {
    WS_SERVICE_ENDPOINT_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Service Host structure
//  
//   Specifies the callback which is called when a channel is successfully accepted.
//  
struct _WS_SERVICE_PROPERTY_ACCEPT_CALLBACK {
    WS_SERVICE_ACCEPT_CHANNEL_CALLBACK callback;
};


//  Service Metadata structure
//  
//   Specifies the individual documents that make up the service metadata.
//  
struct _WS_SERVICE_METADATA_DOCUMENT {
    WS_XML_STRING* content;
    WS_STRING* name;
};


//  Service Metadata structure
//  
//   Specifies the service metadata documents array. This can be a collection of
//  WSDL/XSD documents represented as an array of WS_STRING.
//  
struct _WS_SERVICE_METADATA {
    ULONG documentCount;
    WS_SERVICE_METADATA_DOCUMENT** documents;
    WS_XML_STRING* serviceName;
    WS_XML_STRING* serviceNs;
};


//  Service Host structure
//  
//   Specifies the callback which is called when a channel is about to be closed.
//  See, WS_SERVICE_CLOSE_CHANNEL_CALLBACK for details.
//  
struct _WS_SERVICE_PROPERTY_CLOSE_CALLBACK {
    WS_SERVICE_CLOSE_CHANNEL_CALLBACK callback;
};


//  Service Metadata structure
//  
//   Represents the port element for the endpoint. The port element is
//  generated for the service element as specified by serviceName and
//  serviceNs for WS_SERVICE_PROPERTY_METADATA property
//  on the WS_SERVICE_HOST.
//  
//   Note, the port type will only be generated into the WSDL document if the service
//  element is indeed generated by the runtime.
//  
struct _WS_SERVICE_ENDPOINT_METADATA {
    WS_XML_STRING* portName;
    WS_XML_STRING* bindingName;
    WS_XML_STRING* bindingNs;
};


//  Service Host structure
//  
//   Represents an individual endpoint on a service host. The properties on the endpoint
//  are used to specify the address, binding and contract.
//  
struct _WS_SERVICE_ENDPOINT {
    WS_ENDPOINT_ADDRESS address;
    WS_CHANNEL_BINDING channelBinding;
    WS_CHANNEL_TYPE channelType;
    const WS_SECURITY_DESCRIPTION* securityDescription;
    const WS_SERVICE_CONTRACT* contract;
    WS_SERVICE_SECURITY_CALLBACK authorizationCallback;
    const WS_SERVICE_ENDPOINT_PROPERTY* properties;
    ULONG propertyCount;
    WS_CHANNEL_PROPERTIES channelProperties;
};


//  Service Proxy structure
//  
//   Specifies a proxy property.
//  
struct _WS_PROXY_PROPERTY {
    WS_PROXY_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Service Proxy structure
//  
//   Specifies the callback function and state for an application that wishes
//  to associate or inspect headers in an input or an output message respectively.
//  
//   See also, WS_CALL_PROPERTY_SEND_MESSAGE_CONTEXT and
//   WS_CALL_PROPERTY_RECEIVE_MESSAGE_CONTEXT.
//  
struct _WS_PROXY_MESSAGE_CALLBACK_CONTEXT {
    WS_PROXY_MESSAGE_CALLBACK callback;
    void* state;
};


//  Service Proxy structure
//  
//   Specifies a proxy property.
//  
struct _WS_CALL_PROPERTY {
    WS_CALL_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Url structure
//  
//   The abstract base type for all URL schemes used with WsDecodeUrl and WsEncodeUrl APIs.
//  
struct _WS_URL {
    WS_URL_SCHEME_TYPE scheme;
};


//  Url structure
//  
//   The URL subtype for specifying an http URL.
//  
struct _WS_HTTP_URL {
    WS_URL url;
    WS_STRING host;
    USHORT port;
    WS_STRING portAsString;
    WS_STRING path;
    WS_STRING query;
    WS_STRING fragment;
};


//  Url structure
//  
//   The URL subtype for specifying an https URL.
//  
struct _WS_HTTPS_URL {
    WS_URL url;
    WS_STRING host;
    USHORT port;
    WS_STRING portAsString;
    WS_STRING path;
    WS_STRING query;
    WS_STRING fragment;
};


//  Url structure
//  
//   The URL subtype for specifying an net.tcp URL.
//  
struct _WS_NETTCP_URL {
    WS_URL url;
    WS_STRING host;
    USHORT port;
    WS_STRING portAsString;
    WS_STRING path;
    WS_STRING query;
    WS_STRING fragment;
};


//  Url structure
//  
//   The URL subtype for specifying an soap.udp URL.
//  
struct _WS_SOAPUDP_URL {
    WS_URL url;
    WS_STRING host;
    USHORT port;
    WS_STRING portAsString;
    WS_STRING path;
    WS_STRING query;
    WS_STRING fragment;
};


//  Utilities structure
//  
//   Represents a unique ID URI.
//  
struct _WS_UNIQUE_ID {
    WS_STRING uri;
    GUID guid;
};


//  Utilities structure
//  A structure used to represent a discontiguous array of WS_BYTES.
struct _WS_BUFFERS {
    ULONG bufferCount;
    WS_BYTES* buffers;
};


//  Metadata Import structure
//  
//   Information about a single endpoint that was
//  read from metadata documents.
//  
struct _WS_METADATA_ENDPOINT {
    WS_ENDPOINT_ADDRESS endpointAddress;
    WS_POLICY* endpointPolicy;
    WS_XML_STRING* portName;
    WS_XML_STRING* serviceName;
    WS_XML_STRING* serviceNs;
    WS_XML_STRING* bindingName;
    WS_XML_STRING* bindingNs;
    WS_XML_STRING* portTypeName;
    WS_XML_STRING* portTypeNs;
};


//  Metadata Import structure
//  
//   Information about all endpoints that were
//  read from metadata documents.
//  
struct _WS_METADATA_ENDPOINTS {
    WS_METADATA_ENDPOINT* endpoints;
    ULONG endpointCount;
};


//  Metadata Import structure
//  
//   Specifies a metadata object setting.
//  
struct _WS_METADATA_PROPERTY {
    WS_METADATA_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Metadata Import structure
//  
//   Specifies a policy object setting.
//  
struct _WS_POLICY_PROPERTY {
    WS_POLICY_PROPERTY_ID id;
    void* value;
    ULONG valueSize;
};


//  Metadata Import structure
//  
//   A structure that is used to specify a set of WS_POLICY_PROPERTYs.
//  
struct _WS_POLICY_PROPERTIES {
    WS_POLICY_PROPERTY* properties;
    ULONG propertyCount;
};


//  Metadata Import structure
//  
//   This structure is used to specify a set of constraints
//  for a particular security binding property.
//  Any property constraints that are not specified will use
//  the default constraints.
//  
struct _WS_SECURITY_BINDING_PROPERTY_CONSTRAINT {
    WS_SECURITY_BINDING_PROPERTY_ID id;
    void* allowedValues;
    ULONG allowedValuesSize;
    struct
    {
        WS_SECURITY_BINDING_PROPERTY securityBindingProperty;
    } out;
};


//  Metadata Import structure
//  
//   The base class for all security binding constraint structures.
//  
struct _WS_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT_TYPE type;
    WS_SECURITY_BINDING_PROPERTY_CONSTRAINT* propertyConstraints;
    ULONG propertyConstraintCount;
};


//  Metadata Import structure
//  
//   A security binding constraint that corresponds to the
//   WS_SSL_TRANSPORT_SECURITY_BINDING.
//  
struct _WS_SSL_TRANSPORT_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT bindingConstraint;
    struct
    {
        BOOL clientCertCredentialRequired;
    } out;
};


//  Metadata Import structure
//  
//   A security binding constraint that corresponds to the
//   WS_USERNAME_MESSAGE_SECURITY_BINDING.
//  
struct _WS_USERNAME_MESSAGE_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT bindingConstraint;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
};


//  Metadata Import structure
//  
//   A security binding constraint that corresponds to the
//   WS_HTTP_HEADER_AUTH_SECURITY_BINDING.
//  
struct _WS_HTTP_HEADER_AUTH_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT bindingConstraint;
};


//  Metadata Import structure
//  
//   A security binding constraint that corresponds to the
//   WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING.
//  
struct _WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT bindingConstraint;
};


//  Metadata Import structure
//  
//   A security binding constraint that can be used with
//   WS_XML_TOKEN_MESSAGE_SECURITY_BINDING.
//  
struct _WS_CERT_MESSAGE_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT bindingConstraint;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
};


//  Metadata Import structure
//  
//   A security binding constraint that corresponds to the
//   WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING.
//  
struct _WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT bindingConstraint;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
};


//  Metadata Import structure
//  
//   This structure is used to specify a set of constraints
//  for a particular request security token property.
//  Any property constraints that are not specified will use
//  the default constraints.
//  
struct _WS_REQUEST_SECURITY_TOKEN_PROPERTY_CONSTRAINT {
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_ID id;
    void* allowedValues;
    ULONG allowedValuesSize;
    struct
    {
        WS_REQUEST_SECURITY_TOKEN_PROPERTY requestSecurityTokenProperty;
    } out;
};


//  Metadata Import structure
//  
//   A security binding constraint that can be used to extract information
//  about how to obtain an issued token from an issuing party.
//  
struct _WS_ISSUED_TOKEN_MESSAGE_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT bindingConstraint;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
    WS_XML_STRING* claimConstraints;
    ULONG claimConstraintCount;
    WS_REQUEST_SECURITY_TOKEN_PROPERTY_CONSTRAINT* requestSecurityTokenPropertyConstraints;
    ULONG requestSecurityTokenPropertyConstraintCount;
    struct
    {
        WS_ENDPOINT_ADDRESS* issuerAddress;
        WS_XML_BUFFER* requestSecurityTokenTemplate;
    } out;
};


//  Metadata Import structure
//  
//   This structure is used to specify a set of constraints
//  for a particular security property.
//  Any property constraints that are not specified will use
//  the default constraints.
//  
struct _WS_SECURITY_PROPERTY_CONSTRAINT {
    WS_SECURITY_PROPERTY_ID id;
    void* allowedValues;
    ULONG allowedValuesSize;
    struct
    {
        WS_SECURITY_PROPERTY securityProperty;
    } out;
};


//  Metadata Import structure
//  
//   This structure specifies the security related constraints
//  as part of WS_POLICY_CONSTRAINTS.
//  
struct _WS_SECURITY_CONSTRAINTS {
    WS_SECURITY_PROPERTY_CONSTRAINT* securityPropertyConstraints;
    ULONG securityPropertyConstraintCount;
    WS_SECURITY_BINDING_CONSTRAINT** securityBindingConstraints;
    ULONG securityBindingConstraintCount;
};


//  Metadata Import structure
//  
//   A security binding constraint that corresponds to
//  the WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING.
//  
struct _WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_CONSTRAINT {
    WS_SECURITY_BINDING_CONSTRAINT bindingConstraint;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
    WS_SECURITY_CONSTRAINTS* bootstrapSecurityConstraint;
};


//  Metadata Import structure
//  
//   This structure is used to specify a set of constraints
//  for a particular channel property.
//  Any property constraints that are not specified will use
//  the default constraints.
//  
struct _WS_CHANNEL_PROPERTY_CONSTRAINT {
    WS_CHANNEL_PROPERTY_ID id;
    void* allowedValues;
    ULONG allowedValuesSize;
    struct
    {
        WS_CHANNEL_PROPERTY channelProperty;
    } out;
};


//  Metadata Import structure
//  
//   The base class for all policy extension structures. Policy extensions
//  are assertions that are directly handled by applications such as custom assertions.
//  
struct _WS_POLICY_EXTENSION {
    WS_POLICY_EXTENSION_TYPE type;
};


//  Metadata Import structure
//  
//   This structure is used to specify an endpoint policy extension.
//  
struct _WS_ENDPOINT_POLICY_EXTENSION {
    WS_POLICY_EXTENSION policyExtension;
    WS_XML_STRING* assertionName;
    WS_XML_STRING* assertionNs;
    struct
    {
        WS_XML_BUFFER* assertionValue;
    } out;
};


//  Metadata Import structure
//  
//   This structure is used to specify policy constraints for a channel.
//  
struct _WS_POLICY_CONSTRAINTS {
    WS_CHANNEL_BINDING channelBinding;
    WS_CHANNEL_PROPERTY_CONSTRAINT* channelPropertyConstraints;
    ULONG channelPropertyConstraintCount;
    WS_SECURITY_CONSTRAINTS* securityConstraints;
    WS_POLICY_EXTENSION** policyExtensions;
    ULONG policyExtensionCount;
};


//  Policy Support structure
//  
//   Describes the policy specifying http channel binding.
//  
struct _WS_HTTP_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
};


//  Policy Support structure
//  
//   This type description is used with template APIs to describe
//  the templates generated accordingly to input policy setting.
//  
//   See also,
//   WsCreateServiceProxyFromTemplate,
//   WsCreateServiceEndpointFromTemplate
struct _WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
};


//  Policy Support structure
//  
//   Describes the policy specifying http channel binding.
//  
struct _WS_HTTP_SSL_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sslTransportSecurityBinding;
};


//  Policy Support structure
//  
//   This type description is used with template APIs to describe
//  the templates generated accordingly to input policy setting.
//  
//   See also,
//   WsCreateServiceProxyFromTemplate,
//   WsCreateServiceEndpointFromTemplate
struct _WS_HTTP_HEADER_AUTH_SECURITY_BINDING_POLICY_DESCRIPTION {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
};


//  Policy Support structure
//  
//   Describes the policy specifying http channel binding.
//  
struct _WS_HTTP_HEADER_AUTH_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_HTTP_HEADER_AUTH_SECURITY_BINDING_POLICY_DESCRIPTION httpHeaderAuthSecurityBinding;
};


//  Policy Support structure
//  
//   Describes the policy specifying http channel binding with SSL transport security and
//  header authentication.
//  
struct _WS_HTTP_SSL_HEADER_AUTH_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sslTransportSecurityBinding;
    WS_HTTP_HEADER_AUTH_SECURITY_BINDING_POLICY_DESCRIPTION httpHeaderAuthSecurityBinding;
};


//  Policy Support structure
//  
//   This type description is used with template APIs to describe
//  the templates generated accordingly to input policy setting.
//  
//   See also,
//   WsCreateServiceProxyFromTemplate,
//   WsCreateServiceEndpointFromTemplate
struct _WS_USERNAME_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
};


//  Policy Support structure
//  
//   Describes the policy specifying http channel binding with SSL transport security and
//  username/password message security.
//  
struct _WS_HTTP_SSL_USERNAME_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sslTransportSecurityBinding;
    WS_USERNAME_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION usernameMessageSecurityBinding;
};


//  Policy Support structure
//  
//   This type description is used with template APIs to describe
//  the templates generated accordingly to input policy setting.
//  
//   See also,
//   WsCreateServiceProxyFromTemplate,
//   WsCreateServiceEndpointFromTemplate
struct _WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
};


//  Policy Support structure
//  
//   Describes the policy specifying http channel binding with SSL transport security
//  and KERBEROS AP_REQ message security.
//  
struct _WS_HTTP_SSL_KERBEROS_APREQ_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sslTransportSecurityBinding;
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION kerberosApreqMessageSecurityBinding;
};


//  Policy Support structure
//  
//   Describes the policy specifying http channel binding.
//  
struct _WS_TCP_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
};


//  Policy Support structure
//  
//   This type description is used with template APIs to describe
//  the templates generated accordingly to input policy setting.
//  
//   See also,
//   WsCreateServiceProxyFromTemplate,
//   WsCreateServiceEndpointFromTemplate
struct _WS_SSPI_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
};


//  Policy Support structure
//  
//   Describes the policy specifying TCP channel binding with windows SSPI.
//  
struct _WS_TCP_SSPI_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSPI_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sspiTransportSecurityBinding;
};


//  Policy Support structure
//  
//   Describes the policy specifying TCP channel binding with windows SSPI transport
//  security and username/password message security.
//  
struct _WS_TCP_SSPI_USERNAME_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSPI_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sspiTransportSecurityBinding;
    WS_USERNAME_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION usernameMessageSecurityBinding;
};


//  Policy Support structure
//  
//   Describes the policy specifying TCP channel binding with windows SSPI transport
//  security, and kerberos message security.
//  
struct _WS_TCP_SSPI_KERBEROS_APREQ_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSPI_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sspiTransportSecurityBinding;
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION kerberosApreqMessageSecurityBinding;
};


//  Policy Support structure
//  
//   This type description is used with template APIs to describe
//  the templates generated accordingly to input policy setting.
//  
struct _WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
    WS_MESSAGE_SECURITY_USAGE bindingUsage;
};


//  Policy Support structure
//  
//   This type description is used with template APIs to describe
//  the security context related templates generated accordingly to input policy setting.
//  
struct _WS_SECURITY_CONTEXT_SECURITY_BINDING_POLICY_DESCRIPTION {
    WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION securityContextMessageSecurityBinding;
    WS_SECURITY_PROPERTIES securityProperties;
};


//  Policy Support structure
//  
//   Describes the policy specifying security context message binding using TCP channel binding
//  with windows SSPI transport security. The bootstrap channel uses TCP channel binding with
//  windows SSPI transport security and kerberos message security.
//  
struct _WS_TCP_SSPI_KERBEROS_APREQ_SECURITY_CONTEXT_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSPI_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sspiTransportSecurityBinding;
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION kerberosApreqMessageSecurityBinding;
    WS_SECURITY_CONTEXT_SECURITY_BINDING_POLICY_DESCRIPTION securityContextSecurityBinding;
};


//  Policy Support structure
//  
//   Describes the policy specifying security context message binding using TCP channel binding with windows SSPI transport
//  security. The bootstrap channel uses TCP channel binding with windows SSPI transport
//  security and username/password message security.
//  
struct _WS_TCP_SSPI_USERNAME_SECURITY_CONTEXT_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSPI_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sspiTransportSecurityBinding;
    WS_USERNAME_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION usernameMessageSecurityBinding;
    WS_SECURITY_CONTEXT_SECURITY_BINDING_POLICY_DESCRIPTION securityContextSecurityBinding;
};


//  Policy Support structure
//  
//   Describes the policy specifying security context message binding over http channel binding, with SSL
//  transport security. The bootstrap channel uses http channel binding with SSL transport security
//  and username/password message security.
//  
struct _WS_HTTP_SSL_USERNAME_SECURITY_CONTEXT_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sslTransportSecurityBinding;
    WS_USERNAME_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION usernameMessageSecurityBinding;
    WS_SECURITY_CONTEXT_SECURITY_BINDING_POLICY_DESCRIPTION securityContextSecurityBinding;
};


//  Policy Support structure
//  
//   Describes the policy specifying security context message binding over http channel binding, with SSL
//  transport security. The bootstrap channel uses http channel binding with SSL transport security
//  and KERBEROS AP_REQ message security.
//  
struct _WS_HTTP_SSL_KERBEROS_APREQ_SECURITY_CONTEXT_POLICY_DESCRIPTION {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_POLICY_DESCRIPTION sslTransportSecurityBinding;
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_POLICY_DESCRIPTION kerberosApreqMessageSecurityBinding;
    WS_SECURITY_CONTEXT_SECURITY_BINDING_POLICY_DESCRIPTION securityContextSecurityBinding;
};


//  Policy Support structure
//  
//   HTTP template structure to be filled in by application for http binding.
//  
struct _WS_HTTP_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
};


//  Policy Support structure
//  
//   TCP template structure to be filled in by application for TCP binding.
//  
struct _WS_TCP_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
};


//  Policy Support structure
//  
//   The security binding template for specifying the use of SSL/TLS
//  protocol based transport security.
//  See Also WS_SSL_TRANSPORT_SECURITY_BINDING
//   This security binding is supported only with WS_HTTP_CHANNEL_BINDING.
//  
struct _WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
    WS_CERT_CREDENTIAL* localCertCredential;
};


//  Policy Support structure
//  
//   SSL security template information to be filled in by application.
//  Associated with WS_HTTP_SSL_BINDING_TEMPLATE_TYPE.
//  
struct _WS_HTTP_SSL_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE sslTransportSecurityBinding;
};


//  Policy Support structure
//  
//   The security binding template for specifying the use of HTP header authentication
//  protocol based security.
//  See also WS_HTTP_HEADER_AUTH_SECURITY_BINDING
struct _WS_HTTP_HEADER_AUTH_SECURITY_BINDING_TEMPLATE {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL* clientCredential;
};


//  Policy Support structure
//  
//   HTTP header authentication security template information to be filled in by application.
//  Associated with WS_HTTP_HEADER_AUTH_BINDING_TEMPLATE_TYPE.
//  
struct _WS_HTTP_HEADER_AUTH_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_HTTP_HEADER_AUTH_SECURITY_BINDING_TEMPLATE httpHeaderAuthSecurityBinding;
};


//  Policy Support structure
//  
//   The security binding template for specifying the use of Windows SSPI
//  protocol based transport security.
//  
//   See also WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING.
//  
struct _WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TEMPLATE {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL* clientCredential;
};


//  Policy Support structure
//  
//   HTTP header authentication security template information to be filled in by application.
//  Associated with WS_TCP_SSPI_BINDING_TEMPLATE_TYPE.
//  
struct _WS_TCP_SSPI_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TEMPLATE sspiTransportSecurityBinding;
};


//  Policy Support structure
//  
//   Username/password security template information to be filled in by application.
//  Associated with WS_HTTP_SSL_HEADER_AUTH_BINDING_TEMPLATE_TYPE.
//  
struct _WS_HTTP_SSL_HEADER_AUTH_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE sslTransportSecurityBinding;
    WS_HTTP_HEADER_AUTH_SECURITY_BINDING_TEMPLATE httpHeaderAuthSecurityBinding;
};


//  Policy Support structure
//  
//   The security binding template for specifying the use of an application
//  supplied username / password pair as a direct (i.e., one-shot)
//  security token.  This security binding may be used only with message
//  security.  It provides client authentication, but not traffic signing
//  or encryption.  So, it is used in conjunction with another transport
//  security or message security binding that provides message protection.
//  See also WS_USERNAME_MESSAGE_SECURITY_BINDING
struct _WS_USERNAME_MESSAGE_SECURITY_BINDING_TEMPLATE {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
    WS_USERNAME_CREDENTIAL* clientCredential;
    WS_VALIDATE_PASSWORD_CALLBACK passwordValidator;
    void* passwordValidatorCallbackState;
};


//  Policy Support structure
//  
//   Username/password security template information to be filled in by application.
//  Associated with WS_HTTP_SSL_USERNAME_BINDING_TEMPLATE_TYPE.
//  
struct _WS_HTTP_SSL_USERNAME_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE sslTransportSecurityBinding;
    WS_USERNAME_MESSAGE_SECURITY_BINDING_TEMPLATE usernameMessageSecurityBinding;
};


//  Policy Support structure
//  
//   The security binding template for specifying the use of the Kerberos
//  AP_REQ ticket as a direct (i.e., without establishing a session)
//  security token with WS-Security.
//  See also WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING
struct _WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_TEMPLATE {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
    WS_WINDOWS_INTEGRATED_AUTH_CREDENTIAL* clientCredential;
};


//  Policy Support structure
//  
//   Username/password security template information to be filled in by application.
//  Associated with WS_HTTP_SSL_KERBEROS_APREQ_BINDING_TEMPLATE_TYPE.
//  
struct _WS_HTTP_SSL_KERBEROS_APREQ_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE sslTransportSecurityBinding;
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_TEMPLATE kerberosApreqMessageSecurityBinding;
};


//  Policy Support structure
//  
//   Username/password security template information to be filled in by application.
//  Associated with WS_TCP_SSPI_USERNAME_BINDING_TEMPLATE_TYPE.
//  
struct _WS_TCP_SSPI_USERNAME_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TEMPLATE sspiTransportSecurityBinding;
    WS_USERNAME_MESSAGE_SECURITY_BINDING_TEMPLATE usernameMessageSecurityBinding;
};


//  Policy Support structure
//  
//   Username/password security template information to be filled in by application.
//  Associated with WS_TCP_SSPI_KERBEROS_APREQ_BINDING_TEMPLATE_TYPE.
//  
struct _WS_TCP_SSPI_KERBEROS_APREQ_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TEMPLATE sspiTransportSecurityBinding;
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_TEMPLATE kerberosApreqMessageSecurityBinding;
};


//  Policy Support structure
//  
//   The security binding template for specifying the use of an application
//  supplied security context security binding.  This security binding may
//  be used only with message security. So, it is used in conjunction with another transport
//  security or message security binding that provides message protection.
//  
//   See also WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING
struct _WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_TEMPLATE {
    WS_SECURITY_BINDING_PROPERTIES securityBindingProperties;
};


//  Policy Support structure
//  
//   The security binding template for specifying the use of an application
//  supplied security context security binding.  This security binding may
//  be used only with message security. So, it is used in conjunction with another transport
//  security binding that provides message protection. The security properties are
//  used to establish the secure conversation.
//  
//   See also WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING
struct _WS_SECURITY_CONTEXT_SECURITY_BINDING_TEMPLATE {
    WS_SECURITY_CONTEXT_MESSAGE_SECURITY_BINDING_TEMPLATE securityContextMessageSecurityBinding;
    WS_SECURITY_PROPERTIES securityProperties;
};


//  Policy Support structure
//  
//   Security template information to be filled in by application.
//  Associated with WS_HTTP_SSL_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE_TYPE.
//  
struct _WS_HTTP_SSL_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE sslTransportSecurityBinding;
    WS_USERNAME_MESSAGE_SECURITY_BINDING_TEMPLATE usernameMessageSecurityBinding;
    WS_SECURITY_CONTEXT_SECURITY_BINDING_TEMPLATE securityContextSecurityBinding;
};


//  Policy Support structure
//  
//   Security template information to be filled in by application.
//  Associated with WS_HTTP_SSL_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE_TYPE.
//  
struct _WS_HTTP_SSL_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_SSL_TRANSPORT_SECURITY_BINDING_TEMPLATE sslTransportSecurityBinding;
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_TEMPLATE kerberosApreqMessageSecurityBinding;
    WS_SECURITY_CONTEXT_SECURITY_BINDING_TEMPLATE securityContextSecurityBinding;
};


//  Policy Support structure
//  
//   Security template information to be filled in by application.
//  Associated with WS_TCP_SSPI_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE_TYPE.
//  
struct _WS_TCP_SSPI_USERNAME_SECURITY_CONTEXT_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TEMPLATE sspiTransportSecurityBinding;
    WS_USERNAME_MESSAGE_SECURITY_BINDING_TEMPLATE usernameMessageSecurityBinding;
    WS_SECURITY_CONTEXT_SECURITY_BINDING_TEMPLATE securityContextSecurityBinding;
};


//  Policy Support structure
//  
//   Security template information to be filled in by application.
//  Associated with WS_TCP_SSPI_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE_TYPE.
//  
struct _WS_TCP_SSPI_KERBEROS_APREQ_SECURITY_CONTEXT_BINDING_TEMPLATE {
    WS_CHANNEL_PROPERTIES channelProperties;
    WS_SECURITY_PROPERTIES securityProperties;
    WS_TCP_SSPI_TRANSPORT_SECURITY_BINDING_TEMPLATE sspiTransportSecurityBinding;
    WS_KERBEROS_APREQ_MESSAGE_SECURITY_BINDING_TEMPLATE kerberosApreqMessageSecurityBinding;
    WS_SECURITY_CONTEXT_SECURITY_BINDING_TEMPLATE securityContextSecurityBinding;
};

//  MACRO DEFINITIONS

//  XML Node macro
//  
//   Provides an initializer for a WS_XML_STRING structure when there is an associated dictionary ID.
//  
#define WS_XML_STRING_DICTIONARY_VALUE(S, D, I) { sizeof(S)-1, (BYTE*)RTL_CONST_CAST(char*)(S), RTL_CONST_CAST(WS_XML_DICTIONARY*)(D), I }


//  XML Node macro
//  
//   Provides an initializer for a WS_XML_STRING structure when there is no associated dictionary ID.
//  
#define WS_XML_STRING_VALUE(S) { sizeof(S)-1, (BYTE*)RTL_CONST_CAST(char*)(S), NULL, 0 }


//  XML Node macro
//  
//   Provides an an empty string initializer for a WS_XML_STRING structure.
//  
#define WS_XML_STRING_NULL { 0, NULL, NULL, NULL }


//  Utilities macro
//  
//   A macro to initialize a WS_STRING structure given a constant string.
//  
#define WS_STRING_VALUE(S) { WsCountOf(S) - 1, S }


//  Utilities macro
//  
//   A macro to initialize a WS_STRING structure to a zero-length string.
//  
#define WS_STRING_EMPTY { 0, NULL }


//  Utilities macro
//  
//   Returns the number of elements of an array.
//  
#define WsCountOf(arrayValue) RTL_NUMBER_OF(arrayValue)


//  Utilities macro
//  
//   Returns the offset, in bytes, of a field within a contained structure, given the name
//  of the structure and the name of the field.
//  
#define WsOffsetOf(type, field) FIELD_OFFSET(type, field)


//  FUNCTION DEFINITIONS

//  XML Canonicalization function
//  
//   Starts canonicalization on the specified XML reader.
//  
HRESULT WINAPI WsStartReaderCanonicalization(
    __in WS_XML_READER* reader, 
    __in WS_WRITE_CALLBACK writeCallback, 
    __in void* writeCallbackState, 
    __in_ecount_opt(propertyCount) const WS_XML_CANONICALIZATION_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt WS_ERROR* error);


//  XML Canonicalization function
//  
//   Stops XML canonicalization started by the preceding WsStartReaderCanonicalization call.
//  
HRESULT WINAPI WsEndReaderCanonicalization(
    __in WS_XML_READER* reader, 
    __in_opt WS_ERROR* error);


//  XML Canonicalization function
//  
//   Starts canonicalization on the specified XML writer.
//  
HRESULT WINAPI WsStartWriterCanonicalization(
    __in WS_XML_WRITER* writer, 
    __in WS_WRITE_CALLBACK writeCallback, 
    __in void* writeCallbackState, 
    __in_ecount_opt(propertyCount) const WS_XML_CANONICALIZATION_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt WS_ERROR* error);


//  XML Canonicalization function
//  
//   Stops XML canonicalization started by the preceding WsStartWriterCanonicalization call.
//  
HRESULT WINAPI WsEndWriterCanonicalization(
    __in WS_XML_WRITER* writer, 
    __in_opt WS_ERROR* error);


//  XML Buffer function
//  
//   Creates an XML Buffer which can be used to process xml data in-memory.  It can be
//  navigated through, written to, and read from.
//  
HRESULT WINAPI WsCreateXmlBuffer(
    __in WS_HEAP* heap, 
    __in_ecount_opt(propertyCount) const WS_XML_BUFFER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_XML_BUFFER** buffer, 
    __in_opt WS_ERROR* error);


//  XML Buffer function
//  
//   Removes the node at the specified position from the xml buffer.  If positioned
//  on an element it will remove the element including all of its children and its
//  corresponding end element, otherwise it will remove a single node.
//  
//   The use of any API with a WS_XML_READER or WS_XML_WRITER that
//  currently depends on this position or a child of this position will fail. The
//   WS_XML_READER or WS_XML_WRITER must be repositioned
//  before using further.
//  
//   It will return WS_E_INVALID_OPERATION if the node is positioned on an end
//  element or the root of the document.
//  
//   Calling WsSetReaderPosition or WsSetWriterPosition after calling WsRemoveNode will fail.
//  
HRESULT WINAPI WsRemoveNode(
    __in const WS_XML_NODE_POSITION* nodePosition, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Creates an instance of a WS_XML_READER.  Use WsSetInput or WsSetInputToBuffer
//   to choose the encoding of the reader and to indicate the source of the input.
//  
HRESULT WINAPI WsCreateReader(
    __in_ecount_opt(propertyCount) const WS_XML_READER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_XML_READER** reader, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Sets the encoding and input sources for the reader.
//  
HRESULT WINAPI WsSetInput(
    __in WS_XML_READER* reader, 
    __in_opt const WS_XML_READER_ENCODING* encoding, 
    __in_opt const WS_XML_READER_INPUT* input, 
    __in_ecount_opt(propertyCount) const WS_XML_READER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Sets the reader to use a specified xml buffer as the input source.
//  
HRESULT WINAPI WsSetInputToBuffer(
    __in WS_XML_READER* reader, 
    __in WS_XML_BUFFER* buffer, 
    __in_ecount_opt(propertyCount) const WS_XML_READER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Releases the memory associated with the WS_XML_READER object.
//  
void WINAPI WsFreeReader(__in WS_XML_READER* reader);


//  XML Reader function
//  Returns a property of the specified xml reader.
HRESULT WINAPI WsGetReaderProperty(
    __in WS_XML_READER* reader, 
    __in WS_XML_READER_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Returns the (WS_XML_NODE) node that the (WS_XML_READER) reader is currently positioned on.
//  
HRESULT WINAPI WsGetReaderNode(
    __in WS_XML_READER* xmlReader, 
    __deref_out const WS_XML_NODE** node, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Ensures that the reader has at least a specified amount of data available to it for reading.
//  
HRESULT WINAPI WsFillReader(
    __in WS_XML_READER* reader, 
    __in ULONG minSize, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Advances the reader past a start element skipping any whitespace in front of it.
//  
HRESULT WINAPI WsReadStartElement(
    __in WS_XML_READER* reader, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Advances the reader to the next start element skipping whitespace and comments if necessary.  Optionally,
//  it may also verify the localName and namespace of the element.
//  
HRESULT WINAPI WsReadToStartElement(
    __in WS_XML_READER* reader, 
    __in_opt const WS_XML_STRING* localName, 
    __in_opt const WS_XML_STRING* ns, 
    __out_opt BOOL* found, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Moves the reader to the specified attribute so that its content may be read using ReadValue, ReadChars, or ReadBytes.
//  
HRESULT WINAPI WsReadStartAttribute(
    __in WS_XML_READER* reader, 
    __in ULONG attributeIndex, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Moves the reader back to the element node containing the attribute that was read.
//  
HRESULT WINAPI WsReadEndAttribute(
    __in WS_XML_READER* reader, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Advances the reader to the next (WS_XML_NODE) node in the input stream.
//  
HRESULT WINAPI WsReadNode(
    __in WS_XML_READER* reader, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Advances the reader in the input stream.  If the current node is an element,
//  all of the children of that element are skipped, and the reader is positioned
//  on the node following its end element.  Otherwise, the reader is positioned
//  on the next node in the same manner as WsReadNode.
//  
HRESULT WINAPI WsSkipNode(
    __in WS_XML_READER* reader, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Checks that the current (WS_XML_NODE) node of reader is an end element,
//  and advances the reader to the next (WS_XML_NODE) node.
//  
HRESULT WINAPI WsReadEndElement(
    __in WS_XML_READER* reader, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Searches the attributes of the current element for an attribute with the
//  specified name and namespace and returns its index which may be passed
//  to WsReadStartAttribute.
//  
HRESULT WINAPI WsFindAttribute(
    __in WS_XML_READER* reader, 
    __in const WS_XML_STRING* localName, 
    __in const WS_XML_STRING* ns, 
    __in BOOL required, 
    __out ULONG* attributeIndex, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Reads text from the reader and parses it according to the specified value type.
//  
HRESULT WINAPI WsReadValue(
    __in WS_XML_READER* reader, 
    __in WS_VALUE_TYPE valueType, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Reads a specified number of text characters from the reader.
//  
HRESULT WINAPI WsReadChars(
    __in WS_XML_READER* reader, 
    __out_ecount_part(maxCharCount, *actualCharCount) WCHAR* chars, 
    __in ULONG maxCharCount, 
    __out ULONG* actualCharCount, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Reads a specified number of text characters from the reader and returns them encoded in UTF-8.
//  
HRESULT WINAPI WsReadCharsUtf8(
    __in WS_XML_READER* reader, 
    __out_ecount_part(maxByteCount, *actualByteCount) BYTE* bytes, 
    __in ULONG maxByteCount, 
    __out ULONG* actualByteCount, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Reads text from the reader and decodes the characters as bytes according to the base64 specification.
//  
HRESULT WINAPI WsReadBytes(
    __in WS_XML_READER* reader, 
    __out_bcount_part(maxByteCount, *actualByteCount) void* bytes, 
    __in ULONG maxByteCount, 
    __out ULONG* actualByteCount, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Reads a series of elements from the reader and interprets their
//  content according to the specified value type.
//  
HRESULT WINAPI WsReadArray(
    __in WS_XML_READER* reader, 
    __in const WS_XML_STRING* localName, 
    __in const WS_XML_STRING* ns, 
    __in WS_VALUE_TYPE valueType, 
    __out_bcount_opt(arraySize) void* array, 
    __in ULONG arraySize, 
    __in ULONG itemOffset, 
    __in ULONG itemCount, 
    __out ULONG* actualItemCount, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Returns the current position of the reader.  This can only be used on a reader
//  that is set to an XmlBuffer.
//  
HRESULT WINAPI WsGetReaderPosition(
    __in WS_XML_READER* reader, 
    __out WS_XML_NODE_POSITION* nodePosition, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Sets the current position of the reader.  The position must have been obtained by a call to
//   WsGetReaderPosition or WsGetWriterPosition.
//  
HRESULT WINAPI WsSetReaderPosition(
    __in WS_XML_READER* reader, 
    __in const WS_XML_NODE_POSITION* nodePosition, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Moves the current position of the reader as specified by the moveTo parameter.
//  
HRESULT WINAPI WsMoveReader(
    __in WS_XML_READER* reader, 
    __in WS_MOVE_TO moveTo, 
    __out_opt BOOL* found, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Creates an instance of a WS_XML_WRITER.  Use WsSetOutput or WsSetOutputToBuffer
//   to choose the encoding of the writer and to indicate where to direct the output.
//  
HRESULT WINAPI WsCreateWriter(
    __in_ecount_opt(propertyCount) const WS_XML_WRITER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_XML_WRITER** writer, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Releases the memory associated with the WS_XML_WRITER object.
//  
void WINAPI WsFreeWriter(__in WS_XML_WRITER* writer);


//  XML Writer function
//  
//   Sets the encoding and output callbacks for the writer.  The callbacks are used to
//  provides buffers to the writer and to perform asynchronous i/o.
//  
HRESULT WINAPI WsSetOutput(
    __in WS_XML_WRITER* writer, 
    __in_opt const WS_XML_WRITER_ENCODING* encoding, 
    __in_opt const WS_XML_WRITER_OUTPUT* output, 
    __in_ecount_opt(propertyCount) const WS_XML_WRITER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Sets the writer to emit xml data at the end of the specified buffer.
//  
HRESULT WINAPI WsSetOutputToBuffer(
    __in WS_XML_WRITER* writer, 
    __in WS_XML_BUFFER* buffer, 
    __in_ecount_opt(propertyCount) const WS_XML_WRITER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  Returns a property of the specified xml writer.
HRESULT WINAPI WsGetWriterProperty(
    __in WS_XML_WRITER* writer, 
    __in WS_XML_WRITER_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Instructs the writer to invoke the (WS_WRITE_CALLBACK) callback
//   specified in WS_XML_WRITER_STREAM_OUTPUT if sufficient data has been buffered.
//  
HRESULT WINAPI WsFlushWriter(
    __in WS_XML_WRITER* writer, 
    __in ULONG minSize, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes a start element to the writer.
//  
HRESULT WINAPI WsWriteStartElement(
    __in WS_XML_WRITER* writer, 
    __in_opt const WS_XML_STRING* prefix, 
    __in const WS_XML_STRING* localName, 
    __in const WS_XML_STRING* ns, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Forces the writer to commit the current element and prevent further attributes
//  from being written to the element.
//  
HRESULT WINAPI WsWriteEndStartElement(
    __in WS_XML_WRITER* writer, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes an xmlns attribute to the current element.
//  
HRESULT WINAPI WsWriteXmlnsAttribute(
    __in WS_XML_WRITER* writer, 
    __in_opt const WS_XML_STRING* prefix, 
    __in const WS_XML_STRING* ns, 
    __in BOOL singleQuote, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Starts writing an attribute to the current element.
//  
HRESULT WINAPI WsWriteStartAttribute(
    __in WS_XML_WRITER* writer, 
    __in_opt const WS_XML_STRING* prefix, 
    __in const WS_XML_STRING* localName, 
    __in const WS_XML_STRING* ns, 
    __in BOOL singleQuote, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Finishes writing an attribute to the current element.
//  
HRESULT WINAPI WsWriteEndAttribute(
    __in WS_XML_WRITER* writer, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes a primitive value to the writer.
//  
HRESULT WINAPI WsWriteValue(
    __in WS_XML_WRITER* writer, 
    __in WS_VALUE_TYPE valueType, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  XML Buffer function
//  
//   Writes a WS_XML_BUFFER to a writer.
//  
HRESULT WINAPI WsWriteXmlBuffer(
    __in WS_XML_WRITER* writer, 
    __in WS_XML_BUFFER* xmlBuffer, 
    __in_opt WS_ERROR* error);


//  XML Buffer function
//  
//   Reads the current node from a reader into a WS_XML_BUFFER.
//  
HRESULT WINAPI WsReadXmlBuffer(
    __in WS_XML_READER* reader, 
    __in WS_HEAP* heap, 
    __deref_out WS_XML_BUFFER** xmlBuffer, 
    __in_opt WS_ERROR* error);


//  XML Buffer function
//  
//   Uses a writer to convert a WS_XML_BUFFER to an encoded set of bytes.
//  
HRESULT WINAPI WsWriteXmlBufferToBytes(
    __in WS_XML_WRITER* writer, 
    __in WS_XML_BUFFER* xmlBuffer, 
    __in_opt const WS_XML_WRITER_ENCODING* encoding, 
    __in_ecount_opt(propertyCount) const WS_XML_WRITER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in WS_HEAP* heap, 
    __deref_out_bcount(*byteCount) void** bytes, 
    __out ULONG* byteCount, 
    __in_opt WS_ERROR* error);


//  XML Buffer function
//  
//   Uses a reader to convert a set of encoded bytes to a WS_XML_BUFFER.
//  
HRESULT WINAPI WsReadXmlBufferFromBytes(
    __in WS_XML_READER* reader, 
    __in_opt const WS_XML_READER_ENCODING* encoding, 
    __in_ecount_opt(propertyCount) const WS_XML_READER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_bcount(byteCount) const void* bytes, 
    __in ULONG byteCount, 
    __in WS_HEAP* heap, 
    __deref_out WS_XML_BUFFER** xmlBuffer, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes a series of elements to the writer.
//  
HRESULT WINAPI WsWriteArray(
    __in WS_XML_WRITER* writer, 
    __in const WS_XML_STRING* localName, 
    __in const WS_XML_STRING* ns, 
    __in WS_VALUE_TYPE valueType, 
    __in_bcount_opt(arraySize) const void* array, 
    __in ULONG arraySize, 
    __in ULONG itemOffset, 
    __in ULONG itemCount, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes an xml qualified name to the writer.
//  
HRESULT WINAPI WsWriteQualifiedName(
    __in WS_XML_WRITER* writer, 
    __in_opt const WS_XML_STRING* prefix, 
    __in const WS_XML_STRING* localName, 
    __in_opt const WS_XML_STRING* ns, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes a series of characters to an element or attribute.
//  
HRESULT WINAPI WsWriteChars(
    __in WS_XML_WRITER* writer, 
    __in_ecount(charCount) const WCHAR* chars, 
    __in ULONG charCount, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes a series of characters encoded as UTF-8 to an element or attribute.
//  
HRESULT WINAPI WsWriteCharsUtf8(
    __in WS_XML_WRITER* writer, 
    __in_ecount(byteCount) const BYTE* bytes, 
    __in ULONG byteCount, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes bytes to the writer in a format optimized for the encoding.  When writing
//  in a text encoding, it will emit the bytes encoded in base64.  When writing to
//  a binary format, it will emit the bytes directly.
//  
HRESULT WINAPI WsWriteBytes(
    __in WS_XML_WRITER* writer, 
    __in_bcount(byteCount) const void* bytes, 
    __in ULONG byteCount, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Sets up a callback to be invoked to write bytes within an element.  In some encodings this can
//  be more efficient by eliminating a copy of the data.
//  
HRESULT WINAPI WsPushBytes(
    __in WS_XML_WRITER* writer, 
    __in WS_PUSH_BYTES_CALLBACK callback, 
    __in_opt void* callbackState, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Sets up a callback to be invoked to obtain the bytes to be written within an element.
//  In some encodings this can be more efficient by eliminating a copy of the data.
//  
HRESULT WINAPI WsPullBytes(
    __in WS_XML_WRITER* writer, 
    __in WS_PULL_BYTES_CALLBACK callback, 
    __in_opt void* callbackState, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes an end element to the writer.
//  
HRESULT WINAPI WsWriteEndElement(
    __in WS_XML_WRITER* writer, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes the specified text the XML writer.
//  
HRESULT WINAPI WsWriteText(
    __in WS_XML_WRITER* writer, 
    __in const WS_XML_TEXT* text, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Starts a CDATA section in the writer.
//  
HRESULT WINAPI WsWriteStartCData(
    __in WS_XML_WRITER* writer, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Ends a CDATA section in the writer.
//  
HRESULT WINAPI WsWriteEndCData(
    __in WS_XML_WRITER* writer, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Writes the specified node to the XML Writer.
//  
HRESULT WINAPI WsWriteNode(
    __in WS_XML_WRITER* writer, 
    __in const WS_XML_NODE* node, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Returns a prefix to which the namespace is bound.
//  
HRESULT WINAPI WsGetPrefixFromNamespace(
    __in WS_XML_WRITER* writer, 
    __in const WS_XML_STRING* ns, 
    __in BOOL required, 
    __deref_out const WS_XML_STRING** prefix, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Returns the current position of the writer.  This can only be used on a
//  writer that is set to an XmlBuffer. When writing to a buffer, the position
//  represents the xml node before which new data will be placed.
//  
HRESULT WINAPI WsGetWriterPosition(
    __in WS_XML_WRITER* writer, 
    __out WS_XML_NODE_POSITION* nodePosition, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Sets the current position of the writer.  The position must have been obtained by a
//  call to WsGetReaderPosition or WsGetWriterPosition.
//  
HRESULT WINAPI WsSetWriterPosition(
    __in WS_XML_WRITER* writer, 
    __in const WS_XML_NODE_POSITION* nodePosition, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Moves the current position of the writer as specified by the moveTo parameter.
//  
HRESULT WINAPI WsMoveWriter(
    __in WS_XML_WRITER* writer, 
    __in WS_MOVE_TO moveTo, 
    __out_opt BOOL* found, 
    __in_opt WS_ERROR* error);


//  XML Node function
//  
//   Removes leading and trailing whitespace from a sequence of characters.
//  
HRESULT WINAPI WsTrimXmlWhitespace(
    __in_ecount(charCount) WCHAR* chars, 
    __in ULONG charCount, 
    __deref_out_ecount(*trimmedCount) WCHAR** trimmedChars, 
    __out ULONG* trimmedCount, 
    __in_opt WS_ERROR* error);


//  XML Node function
//  
//   Verifies whether the input string is a valid XML NCName.
//  
HRESULT WINAPI WsVerifyXmlNCName(
    __in_ecount(ncNameCharCount) const WCHAR* ncNameChars, 
    __in ULONG ncNameCharCount, 
    __in_opt WS_ERROR* error);


//  XML Node function
//  
//   Compares two WS_XML_STRING's for equality by performing an ordinal comparison
//  of the character values.
//  
HRESULT WINAPI WsXmlStringEquals(
    __in const WS_XML_STRING* string1, 
    __in const WS_XML_STRING* string2, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Returns the namespace to which the prefix is bound.
//  
HRESULT WINAPI WsGetNamespaceFromPrefix(
    __in WS_XML_READER* reader, 
    __in const WS_XML_STRING* prefix, 
    __in BOOL required, 
    __deref_out const WS_XML_STRING** ns, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Reads a qualified name and separates it into its prefix, localName
//  and namespace based on the current namespace scope of the XML_READER.
//  If the ns parameter is specified, then the namespace that the prefix
//  is bound to will be returned, or WS_E_INVALID_FORMAT
//   will be returned. The strings are placed in the specified heap.
//  
HRESULT WINAPI WsReadQualifiedName(
    __in WS_XML_READER* reader, 
    __in WS_HEAP* heap, 
    __out_opt WS_XML_STRING* prefix, 
    __out WS_XML_STRING* localName, 
    __out_opt WS_XML_STRING* ns, 
    __in_opt WS_ERROR* error);


//  XML Reader function
//  
//   Finds the nearest xml attribute in scope with the specified localName and returns its value.
//  The returned value is placed on the specified heap.
//  
HRESULT WINAPI WsGetXmlAttribute(
    __in WS_XML_READER* reader, 
    __in const WS_XML_STRING* localName, 
    __in WS_HEAP* heap, 
    __deref_out_ecount_opt(*valueCharCount) WCHAR** valueChars, 
    __out ULONG* valueCharCount, 
    __in_opt WS_ERROR* error);


//  XML Writer function
//  
//   Copies the current node from the specified reader to the specified writer.
//  
HRESULT WINAPI WsCopyNode(
    __in WS_XML_WRITER* writer, 
    __in WS_XML_READER* reader, 
    __in_opt WS_ERROR* error);


//  Async Model function
//  
//   WsAsyncExecute is a helper that can be used to implement an asynchronous operation.
//  
HRESULT WINAPI WsAsyncExecute(
    __in WS_ASYNC_STATE* asyncState, 
    __in WS_ASYNC_FUNCTION operation, 
    __in WS_CALLBACK_MODEL callbackModel, 
    __in void* callbackState, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Create a channel used to initiate a message exchange to some endpoint.
//  
HRESULT WINAPI WsCreateChannel(
    __in WS_CHANNEL_TYPE channelType, 
    __in WS_CHANNEL_BINDING channelBinding, 
    __in_ecount_opt(propertyCount) const WS_CHANNEL_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt const WS_SECURITY_DESCRIPTION* securityDescription, 
    __deref_out WS_CHANNEL** channel, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Open a channel to an endpoint.
//  
HRESULT WINAPI WsOpenChannel(
    __in WS_CHANNEL* channel, 
    __in const WS_ENDPOINT_ADDRESS* endpointAddress, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Send a message on a channel using serialization to write the body element.
//  
HRESULT WINAPI WsSendMessage(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* message, 
    __in const WS_MESSAGE_DESCRIPTION* messageDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount_opt(bodyValueSize) const void* bodyValue, 
    __in ULONG bodyValueSize, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Receive a message and deserialize the body of the message as a value.
//  
HRESULT WINAPI WsReceiveMessage(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* message, 
    __in_ecount(messageDescriptionCount) const WS_MESSAGE_DESCRIPTION** messageDescriptions, 
    __in ULONG messageDescriptionCount, 
    __in WS_RECEIVE_OPTION receiveOption, 
    __in WS_READ_OPTION readBodyOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __out_opt ULONG* index, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Used to send a request message and receive a correlated reply message.
//  
HRESULT WINAPI WsRequestReply(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* requestMessage, 
    __in const WS_MESSAGE_DESCRIPTION* requestMessageDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount_opt(requestBodyValueSize) const void* requestBodyValue, 
    __in ULONG requestBodyValueSize, 
    __in WS_MESSAGE* replyMessage, 
    __in const WS_MESSAGE_DESCRIPTION* replyMessageDescription, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount_opt(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Sends a message which is a reply to a received message.
//  
HRESULT WINAPI WsSendReplyMessage(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* replyMessage, 
    __in const WS_MESSAGE_DESCRIPTION* replyMessageDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount_opt(replyBodyValueSize) const void* replyBodyValue, 
    __in ULONG replyBodyValueSize, 
    __in WS_MESSAGE* requestMessage, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Sends a fault message given a WS_ERROR object.
//  
HRESULT WINAPI WsSendFaultMessageForError(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* replyMessage, 
    __in WS_ERROR* faultError, 
    __in HRESULT faultErrorCode, 
    __in WS_FAULT_DISCLOSURE faultDisclosure, 
    __in WS_MESSAGE* requestMessage, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Retrieve a property of the channel.
//  
HRESULT WINAPI WsGetChannelProperty(
    __in WS_CHANNEL* channel, 
    __in WS_CHANNEL_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Set a property of the channel.
//  
HRESULT WINAPI WsSetChannelProperty(
    __in WS_CHANNEL* channel, 
    __in WS_CHANNEL_PROPERTY_ID id, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Write out all the headers of the message to the channel, and prepare to write the body elements.
//  
HRESULT WINAPI WsWriteMessageStart(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* message, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Write the closing elements of the message to the channel.
//  
HRESULT WINAPI WsWriteMessageEnd(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* message, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Read the headers of the next message from the channel, and prepare to read the body elements.
//  
HRESULT WINAPI WsReadMessageStart(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* message, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Read the closing elements of a message from a channel.
//  
HRESULT WINAPI WsReadMessageEnd(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* message, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Close a channel.
//  
HRESULT WINAPI WsCloseChannel(
    __in WS_CHANNEL* channel, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Abort all pending IO for a channel.
//  
HRESULT WINAPI WsAbortChannel(
    __in WS_CHANNEL* channel, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Free a channel.
//  
void WINAPI WsFreeChannel(__in WS_CHANNEL* channel);


//  Channel function
//  
//   Reset a channel so it can be reused.
//  
HRESULT WINAPI WsResetChannel(
    __in WS_CHANNEL* channel, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Used to skip the remainder of a message for a channel.
//  
HRESULT WINAPI WsAbandonMessage(
    __in WS_CHANNEL* channel, 
    __in WS_MESSAGE* message, 
    __in_opt WS_ERROR* error);


//  Channel function
//  
//   Used to signal the end of messages for a session channel.
//  
HRESULT WINAPI WsShutdownSessionChannel(
    __in WS_CHANNEL* channel, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Context function
//  
//   Returns a property of the specified operation context. It should be noted that the
//  validity of these property is limited to the lifetime of the operation context itself.
//  See Operation Context Lifetime and Threading for details around accessing
//  these properties and the lifetime of the operation context.
//  
HRESULT WINAPI WsGetOperationContextProperty(
    __in const WS_OPERATION_CONTEXT* context, 
    __in const WS_OPERATION_CONTEXT_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Dictionaries function

HRESULT WINAPI WsGetDictionary(
    __in WS_ENCODING encoding, 
    __deref_out_opt WS_XML_DICTIONARY** dictionary, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Reads an extension of the WS_ENDPOINT_ADDRESS.
//  
HRESULT WINAPI WsReadEndpointAddressExtension(
    __in WS_XML_READER* reader, 
    __in WS_ENDPOINT_ADDRESS* endpointAddress, 
    __in WS_ENDPOINT_ADDRESS_EXTENSION_TYPE extensionType, 
    __in WS_READ_OPTION readOption, 
    __in WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Errors function
//  
//   Creates an error object that can passed to functions to in order to
//  record rich error information.
//  
HRESULT WINAPI WsCreateError(
    __in_ecount_opt(propertyCount) const WS_ERROR_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_ERROR** error);


//  Errors function
//  
//   Add an error string to the error object.
//  
HRESULT WINAPI WsAddErrorString(
    __in WS_ERROR* error, 
    __in const WS_STRING* string);


//  Errors function
//  
//   Retrieves an error string from an error object.
//  
HRESULT WINAPI WsGetErrorString(
    __in WS_ERROR* error, 
    __in ULONG index, 
    __out WS_STRING* string);


//  Errors function
//  
//   Copies the error object from source to destination.
//  
HRESULT WINAPI WsCopyError(
    __in WS_ERROR* source, 
    __in WS_ERROR* destination);


//  Errors function
//  
//   Retrieve a property of the error.
//  
HRESULT WINAPI WsGetErrorProperty(
    __in WS_ERROR* error, 
    __in WS_ERROR_PROPERTY_ID id, 
    __out_bcount(bufferSize) void* buffer, 
    __in ULONG bufferSize);


//  Errors function
//  
//   Set a property of the error.
//  
HRESULT WINAPI WsSetErrorProperty(
    __in WS_ERROR* error, 
    __in WS_ERROR_PROPERTY_ID id, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize);


//  Errors function
//  
//   Frees the contents of the error object, but does not free the error object itself.
//  
HRESULT WINAPI WsResetError(__in WS_ERROR* error);


//  Errors function
//  
//   Free the error object created by WsCreateError.
//  
void WINAPI WsFreeError(__in WS_ERROR* error);


//  Faults function
//  
//   Retrieve a fault-related property of the error object.
//  
HRESULT WINAPI WsGetFaultErrorProperty(
    __in WS_ERROR* error, 
    __in WS_FAULT_ERROR_PROPERTY_ID id, 
    __out_bcount(bufferSize) void* buffer, 
    __in ULONG bufferSize);


//  Faults function
//  
//   Set a fault-related property of the error object.
//  
HRESULT WINAPI WsSetFaultErrorProperty(
    __in WS_ERROR* error, 
    __in WS_FAULT_ERROR_PROPERTY_ID id, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize);


//  Faults function
//  
//   Construct a WS_FAULT given an error object.
//  
HRESULT WINAPI WsCreateFaultFromError(
    __in WS_ERROR* error, 
    __in HRESULT faultErrorCode, 
    __in WS_FAULT_DISCLOSURE faultDisclosure, 
    __in WS_HEAP* heap, 
    __out WS_FAULT* fault);


//  Faults function
//  
//   Write the fault detail stored in a WS_ERROR object.
//  
HRESULT WINAPI WsSetFaultErrorDetail(
    __in WS_ERROR* error, 
    __in const WS_FAULT_DETAIL_DESCRIPTION* faultDetailDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount_opt(valueSize) const void* value, 
    __in ULONG valueSize);


//  Faults function
//  
//   Read the fault detail stored in a WS_ERROR object.
//  
HRESULT WINAPI WsGetFaultErrorDetail(
    __in WS_ERROR* error, 
    __in const WS_FAULT_DETAIL_DESCRIPTION* faultDetailDescription, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize);


//  Heap function
//  
//   Create a heap object.
//  
HRESULT WINAPI WsCreateHeap(
    __in SIZE_T maxSize, 
    __in SIZE_T trimSize, 
    __in_opt const WS_HEAP_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_HEAP** heap, 
    __in_opt WS_ERROR* error);


//  Heap function
//  Allocate a chunk of data from the heap.
HRESULT WINAPI WsAlloc(
    __in WS_HEAP* heap, 
    __in SIZE_T size, 
    __deref_out_bcount(size) void** ptr, 
    __in_opt WS_ERROR* error);


//  Heap function
//  Returns a property of the specified heap.
HRESULT WINAPI WsGetHeapProperty(
    __in WS_HEAP* heap, 
    __in WS_HEAP_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Heap function
//  
//   This resets the heap to have no allocations.  All allocations made on the heap
//  using WsAlloc are no longer valid.  However, this call does not actually
//  free the heap object.
//  
HRESULT WINAPI WsResetHeap(
    __in WS_HEAP* heap, 
    __in_opt WS_ERROR* error);


//  Heap function
//  
//   This frees the heap object, and the memory associated with any allocations
//  made on it using WsAlloc.
//  
void WINAPI WsFreeHeap(__in WS_HEAP* heap);


//  Listener function
//  
//   Create a listener object.
//  
HRESULT WINAPI WsCreateListener(
    __in WS_CHANNEL_TYPE channelType, 
    __in WS_CHANNEL_BINDING channelBinding, 
    __in_ecount_opt(propertyCount) const WS_LISTENER_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt const WS_SECURITY_DESCRIPTION* securityDescription, 
    __deref_out WS_LISTENER** listener, 
    __in_opt WS_ERROR* error);


//  Listener function
//  
//   Start listening.
//  
HRESULT WINAPI WsOpenListener(
    __in WS_LISTENER* listener, 
    __in const WS_STRING* url, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Listener function
//  
//   Accepts the next incoming message exchange from a listener.
//  
HRESULT WINAPI WsAcceptChannel(
    __in WS_LISTENER* listener, 
    __in WS_CHANNEL* channel, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Listener function
//  
//   Stop listening.
//  
HRESULT WINAPI WsCloseListener(
    __in WS_LISTENER* listener, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Listener function
//  
//   Cancel any pending IO for the listener.
//  
HRESULT WINAPI WsAbortListener(
    __in WS_LISTENER* listener, 
    __in_opt WS_ERROR* error);


//  Listener function
//  
//   Reset a listener so it can be reused.
//  
HRESULT WINAPI WsResetListener(
    __in WS_LISTENER* listener, 
    __in_opt WS_ERROR* error);


//  Listener function
//  
//   Free the listener.
//  
void WINAPI WsFreeListener(__in WS_LISTENER* listener);


//  Listener function
//  
//   Retrieve a property of the listener.
//  
HRESULT WINAPI WsGetListenerProperty(
    __in WS_LISTENER* listener, 
    __in WS_LISTENER_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Listener function
//  
//   Set a property of the listener.
//  
HRESULT WINAPI WsSetListenerProperty(
    __in WS_LISTENER* listener, 
    __in WS_LISTENER_PROPERTY_ID id, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Listener function
//  
//   Create a channel that is used to accept incoming message exchanges from a listener.
//  
HRESULT WINAPI WsCreateChannelForListener(
    __in WS_LISTENER* listener, 
    __in_ecount_opt(propertyCount) const WS_CHANNEL_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_CHANNEL** channel, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Creates a message object.
//  
HRESULT WINAPI WsCreateMessage(
    __in WS_ENVELOPE_VERSION envelopeVersion, 
    __in WS_ADDRESSING_VERSION addressingVersion, 
    __in_ecount_opt(propertyCount) const WS_MESSAGE_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_MESSAGE** message, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Creates a message that is appropriate for use with a particular channel.
//  
HRESULT WINAPI WsCreateMessageForChannel(
    __in WS_CHANNEL* channel, 
    __in_ecount_opt(propertyCount) const WS_MESSAGE_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_MESSAGE** message, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Sets up the initial set of headers for the message in preparation for
//  sending/writing the message.
//  
HRESULT WINAPI WsInitializeMessage(
    __in WS_MESSAGE* message, 
    __in WS_MESSAGE_INITIALIZATION initialization, 
    __in_opt WS_MESSAGE* sourceMessage, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Prepare the message for reuse.
//  
HRESULT WINAPI WsResetMessage(
    __in WS_MESSAGE* message, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Releases the memory associated with the message object.
//  
void WINAPI WsFreeMessage(__in WS_MESSAGE* message);


//  Message function
//  
//   Returns the WS_HEADER_ATTRIBUTES for the header element the reader is positioned on.  The
//  envelope version of the message is used to determine which attributes to return.
//  
HRESULT WINAPI WsGetHeaderAttributes(
    __in WS_MESSAGE* message, 
    __in WS_XML_READER* reader, 
    __out ULONG* headerAttributes, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Finds a particular standard header in the message and deserializes it.
//  
HRESULT WINAPI WsGetHeader(
    __in WS_MESSAGE* message, 
    __in WS_HEADER_TYPE headerType, 
    __in WS_TYPE valueType, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Finds an application-defined header of the message and deserializes it.
//  
HRESULT WINAPI WsGetCustomHeader(
    __in WS_MESSAGE* message, 
    __in const WS_ELEMENT_DESCRIPTION* customHeaderDescription, 
    __in WS_REPEATING_HEADER_OPTION repeatingOption, 
    __in ULONG headerIndex, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __out_opt ULONG* headerAttributes, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Removes all instances of the specified standard header from the message.
//  
HRESULT WINAPI WsRemoveHeader(
    __in WS_MESSAGE* message, 
    __in WS_HEADER_TYPE headerType, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Adds or replaces the specified standard header in the message.
//  
HRESULT WINAPI WsSetHeader(
    __in WS_MESSAGE* message, 
    __in WS_HEADER_TYPE headerType, 
    __in WS_TYPE valueType, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Removes all instances of the application defined header from the message.
//  
HRESULT WINAPI WsRemoveCustomHeader(
    __in WS_MESSAGE* message, 
    __in const WS_XML_STRING* headerName, 
    __in const WS_XML_STRING* headerNs, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Adds the specified application defined header to the message.
//  
HRESULT WINAPI WsAddCustomHeader(
    __in WS_MESSAGE* message, 
    __in const WS_ELEMENT_DESCRIPTION* headerDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in ULONG headerAttributes, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Adds a specified mapped header to the message.
//  
HRESULT WINAPI WsAddMappedHeader(
    __in WS_MESSAGE* message, 
    __in const WS_XML_STRING* headerName, 
    __in WS_TYPE valueType, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Removes all instances of a mapped header from the message.
//  
HRESULT WINAPI WsRemoveMappedHeader(
    __in WS_MESSAGE* message, 
    __in const WS_XML_STRING* headerName, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Finds a mapped header in the message and deserializes it.
//  
HRESULT WINAPI WsGetMappedHeader(
    __in WS_MESSAGE* message, 
    __in const WS_XML_STRING* headerName, 
    __in WS_REPEATING_HEADER_OPTION repeatingOption, 
    __in ULONG headerIndex, 
    __in WS_TYPE valueType, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Serialize a value in the body of the message.
//  
HRESULT WINAPI WsWriteBody(
    __in WS_MESSAGE* message, 
    __in const WS_ELEMENT_DESCRIPTION* bodyDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Deserialize a value from the body of the message.
//  
HRESULT WINAPI WsReadBody(
    __in WS_MESSAGE* message, 
    __in const WS_ELEMENT_DESCRIPTION* bodyDescription, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Write out all the headers of the message and prepare to write the body elements.
//  
HRESULT WINAPI WsWriteEnvelopeStart(
    __in WS_MESSAGE* message, 
    __in WS_XML_WRITER* writer, 
    __in_opt WS_MESSAGE_DONE_CALLBACK doneCallback, 
    __in_opt void* doneCallbackState, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Write the closing elements of the message.
//  
HRESULT WINAPI WsWriteEnvelopeEnd(
    __in WS_MESSAGE* message, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Read the headers of the message and prepare to read the body elements.
//  
HRESULT WINAPI WsReadEnvelopeStart(
    __in WS_MESSAGE* message, 
    __in WS_XML_READER* reader, 
    __in_opt WS_MESSAGE_DONE_CALLBACK doneCallback, 
    __in_opt void* doneCallbackState, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Read the closing elements of a message.
//  
HRESULT WINAPI WsReadEnvelopeEnd(
    __in WS_MESSAGE* message, 
    __in_opt WS_ERROR* error);


//  Message function
//  Returns a property of the specified message.
HRESULT WINAPI WsGetMessageProperty(
    __in WS_MESSAGE* message, 
    __in WS_MESSAGE_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Set a property of the message.
//  
HRESULT WINAPI WsSetMessageProperty(
    __in WS_MESSAGE* message, 
    __in WS_MESSAGE_PROPERTY_ID id, 
    __in_bcount(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Addresses a message given an Endpoint Address.
//  
HRESULT WINAPI WsAddressMessage(
    __in WS_MESSAGE* message, 
    __in_opt const WS_ENDPOINT_ADDRESS* address, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Verifies that all headers that were specified to be required to be
//  understood by the receiver were actually understood.
//  
HRESULT WINAPI WsCheckMustUnderstandHeaders(
    __in WS_MESSAGE* message, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Marks a header as one that was understood by the application.
//  
HRESULT WINAPI WsMarkHeaderAsUnderstood(
    __in WS_MESSAGE* message, 
    __in const WS_XML_NODE_POSITION* headerPosition, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Ensures that the message has at least a specified amount of body data available to it for reading.
//  
HRESULT WINAPI WsFillBody(
    __in WS_MESSAGE* message, 
    __in ULONG minSize, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Message function
//  
//   Flushes all accumulated body data that has been written for the message.
//  
HRESULT WINAPI WsFlushBody(
    __in WS_MESSAGE* message, 
    __in ULONG minSize, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Security Bindings function
//  
//   Get a security token from a security token service (STS) that acts as
//  the token issuer in a (Federation) federation scenario.
//  This function is used on the client side, and performs the WS-Trust
//  based negotiation steps with the STS until the security token is
//  obtained or the negotiation process fails.
//  
HRESULT WINAPI WsRequestSecurityToken(
    __in WS_CHANNEL* channel, 
    __in_ecount_opt(propertyCount) const WS_REQUEST_SECURITY_TOKEN_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_SECURITY_TOKEN** token, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Security Processing Results function
//  
//   Extract a field or a property from a security token. If the queried property does not use the 'heap' parameter, the returned
//  data is owned by the security token and remains valid as long as the security token itself remains valid. Specifically, for
//  security tokens extracted from a received message, the security token and fields extracted from it are valid only as long as
//  the message is not reset or freed.
//   If the 'heap' parameter is required by the property, then the returned data is stored on the heap, with its lifetime
//  detached from the underlying token.
//  
HRESULT WINAPI WsGetSecurityTokenProperty(
    __in WS_SECURITY_TOKEN* securityToken, 
    __in WS_SECURITY_TOKEN_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_HEAP* heap, 
    __in_opt WS_ERROR* error);


//  Security Bindings function
//  
//  Create a security token from its XML form.
//  
HRESULT WINAPI WsCreateXmlSecurityToken(
    __in_opt WS_XML_BUFFER* tokenXml, 
    __in_opt WS_SECURITY_KEY_HANDLE* tokenKey, 
    __in_ecount_opt(propertyCount) const WS_XML_SECURITY_TOKEN_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_SECURITY_TOKEN** token, 
    __in_opt WS_ERROR* error);


//  Security Bindings function
//  
//   Free a security token.
//  
void WINAPI WsFreeSecurityToken(__in WS_SECURITY_TOKEN* token);


//  Security Context function
//  
//   Revokes a security context. Can only be called on the server side.
//  
//   This function can be used when the server knows that no more messages are
//  coming and does not want to wait for the client or the context timeouts to
//  trigger the reclaiming of resources, or when the server wants to engage in
//  active context management.
//  
HRESULT WINAPI WsRevokeSecurityContext(
    __in WS_SECURITY_CONTEXT* securityContext, 
    __in_opt WS_ERROR* error);


//  Security Context function
//  
//   Gets a property of the specified security context.
//  
HRESULT WINAPI WsGetSecurityContextProperty(
    __in WS_SECURITY_CONTEXT* securityContext, 
    __in WS_SECURITY_CONTEXT_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Serialization function
//  
//   Read an element producing a value of the specified WS_TYPE.
//  
HRESULT WINAPI WsReadElement(
    __in WS_XML_READER* reader, 
    __in const WS_ELEMENT_DESCRIPTION* elementDescription, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Serialization function
//  
//   Read an attribute producing a value of the specified WS_TYPE.
//  
HRESULT WINAPI WsReadAttribute(
    __in WS_XML_READER* reader, 
    __in const WS_ATTRIBUTE_DESCRIPTION* attributeDescription, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Serialization function
//  
//   Read a value of a given WS_TYPE from XML according to the WS_TYPE_MAPPING.
//  
HRESULT WINAPI WsReadType(
    __in WS_XML_READER* reader, 
    __in WS_TYPE_MAPPING typeMapping, 
    __in WS_TYPE type, 
    __in_opt const void* typeDescription, 
    __in WS_READ_OPTION readOption, 
    __in_opt WS_HEAP* heap, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Serialization function
//  
//   Write a typed value as an XML element.
//  
HRESULT WINAPI WsWriteElement(
    __in WS_XML_WRITER* writer, 
    __in const WS_ELEMENT_DESCRIPTION* elementDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount_opt(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Serialization function
//  
//   Write a typed value as an XML attribute.
//  
HRESULT WINAPI WsWriteAttribute(
    __in WS_XML_WRITER* writer, 
    __in const WS_ATTRIBUTE_DESCRIPTION* attributeDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount_opt(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Serialization function
//  
//   Write a value of a given WS_TYPE to XML according to the WS_TYPE_MAPPING.
//  
HRESULT WINAPI WsWriteType(
    __in WS_XML_WRITER* writer, 
    __in WS_TYPE_MAPPING typeMapping, 
    __in WS_TYPE type, 
    __in_opt const void* typeDescription, 
    __in WS_WRITE_OPTION writeOption, 
    __in_bcount_opt(valueSize) const void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Call cancellation function
//  
//   A service operation can use this function to register for a cancel notification.
//  It is only valid to call this API when the service operation is executing. The behavior
//  for calling it after the completion of Service Operation is not supported.
//  
//   While this API is being called and the runtime has determined that the cancellation of the
//  service operation is necessary, it can call the callback during the call to this API by the application.
//  
//   The caller should therefore assume that the runtime may call on the callback
//   WS_OPERATION_CANCEL_CALLBACK as soon as the WsRegisterOperationForCancel is called.
//  
HRESULT WINAPI WsRegisterOperationForCancel(
    __in const WS_OPERATION_CONTEXT* context, 
    __in WS_OPERATION_CANCEL_CALLBACK cancelCallback, 
    __in_opt WS_OPERATION_FREE_STATE_CALLBACK freestateCallback, 
    __in_opt void* userState, 
    __in_opt WS_ERROR* error);


//  Service Host function
//  
//   Retrieve a property of the service host.
//  
HRESULT WINAPI WsGetServiceHostProperty(
    __in WS_SERVICE_HOST* serviceHost, 
    __in const WS_SERVICE_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Service Host function
//  
//   Create a service host.
//  
HRESULT WINAPI WsCreateServiceHost(
    __in_ecount_opt(endpointCount) const WS_SERVICE_ENDPOINT** endpoints, 
    __in const USHORT endpointCount, 
    __in_ecount_opt(servicePropertyCount) const WS_SERVICE_PROPERTY* serviceProperties, 
    __in ULONG servicePropertyCount, 
    __deref_out WS_SERVICE_HOST** serviceHost, 
    __in_opt WS_ERROR* error);


//  Service Host function
//  
//   Open a service host for communication. Starts the listeners on all the endpoints.
//  
HRESULT WINAPI WsOpenServiceHost(
    __in WS_SERVICE_HOST* serviceHost, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Service Host function
//  
//   Closes down a service host for communication.
//  
//   During WsCloseServiceHost all the listeners are closed such that no new
//  channels are accepted from the client. Work on  channels already accepted
//  before WsCloseServiceHost closed the listeners, is allowed to complete.
//  This has special implications for endpoints configured to run with session
//  based channel binding. If a client has a session opened to the service, the
//  close will not complete till the client closes the session with the service.
//  
HRESULT WINAPI WsCloseServiceHost(
    __in WS_SERVICE_HOST* serviceHost, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Service Host function
//  
//   Aborts the current operation on the service host.
//  
HRESULT WINAPI WsAbortServiceHost(
    __in WS_SERVICE_HOST* serviceHost, 
    __in_opt WS_ERROR* error);


//  Service Host function
//  Free's the service host.
void WINAPI WsFreeServiceHost(__in WS_SERVICE_HOST* serviceHost);


//  Service Host function
//  
//   Resets service host so that it can be opened again.
//  
//   Rather the creating a new service host from scratch WsResetServiceHost
//  provides a convenient way to reuse service host. Specifically in a scenario
//  where a service host has to go through close and open on a regular basis,
//  this allows for an efficient way for reusing the same service host. It resets
//  the underlying channel and listeners for reuse.
//  
HRESULT WINAPI WsResetServiceHost(
    __in WS_SERVICE_HOST* serviceHost, 
    __in_opt WS_ERROR* error);


//  Service Proxy function
//  
//   Retrieve a property of service proxy.
//  
HRESULT WINAPI WsGetServiceProxyProperty(
    __in WS_SERVICE_PROXY* serviceProxy, 
    __in const WS_PROXY_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Service Proxy function
//  
//   Creates a service proxy.
//  
HRESULT WINAPI WsCreateServiceProxy(
    __in const WS_CHANNEL_TYPE channelType, 
    __in const WS_CHANNEL_BINDING channelBinding, 
    __in_opt const WS_SECURITY_DESCRIPTION* securityDescription, 
    __in_ecount_opt(propertyCount) const WS_PROXY_PROPERTY* properties, 
    __in const ULONG propertyCount, 
    __in_ecount_opt(channelPropertyCount) const WS_CHANNEL_PROPERTY* channelProperties, 
    __in const ULONG channelPropertyCount, 
    __deref_out WS_SERVICE_PROXY** serviceProxy, 
    __in_opt WS_ERROR* error);


//  Service Proxy function
//  
//   Opens the service proxy to a service endpoint.
//  
//   Once the operation succeeds, application can now go ahead and make calls on the service proxy.
//  
HRESULT WINAPI WsOpenServiceProxy(
    __in WS_SERVICE_PROXY* serviceProxy, 
    __in const WS_ENDPOINT_ADDRESS* address, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Service Proxy function
//  
//   Closes a service proxy for communication.
//  
//   Close performs the following tasks in given order
//  
//  .If a service operation call is pending on the service proxy, close will wait for each call to complete.
//  
//  .If the proxy was created with session based channel binding this will close the underlying channel.
//  
//   During this calls are accepted by the service proxy.
//  
HRESULT WINAPI WsCloseServiceProxy(
    __in WS_SERVICE_PROXY* serviceProxy, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Service Proxy function
//  
//   Aborts the service proxy.
//  
//   Aborts cancel all I/O if any on the service proxy.
//  WsAbortServiceProxy: During Open or WS_SERVICE_PROXY_STATE_OPENING state
//   WsAbortServiceProxy can be used to abort the open operation. The service proxy will
//  cancel all pending I/O and transition back to WS_SERVICE_PROXY_STATE_CREATED state.
//  WsAbortServiceProxy: While making calls or WS_SERVICE_PROXY_STATE_OPEN state
//   WsAbortServiceProxy will abort all the underlying channels. The service proxy is transitioned to
//  to WS_SERVICE_PROXY_STATE_FAULTED. Once abort is initiated service proxy will
//  not accept any new calls. The application can call WsCloseServiceProxy to close it.
//  WsAbortServiceProxy: During Close or WS_SERVICE_PROXY_STATE_CLOSING state
//   During close, all underlying channels are aborted. The service proxy is transitioned to the
//   WS_SERVICE_PROXY_STATE_CLOSED state.
//  
HRESULT WINAPI WsAbortServiceProxy(
    __in WS_SERVICE_PROXY* serviceProxy, 
    __in_opt WS_ERROR* error);


//  Service Proxy function
//  Free's a service proxy.
void WINAPI WsFreeServiceProxy(__in WS_SERVICE_PROXY* serviceProxy);


//  Service Proxy function
//  Resets service proxy.
//   WsResetServiceProxy provides a convenient way to reuse the service proxy.
//  Once the proxy is (WS_SERVICE_PROXY_STATE) closed,
//  the application can call WsResetServiceProxy to reuse it.
//  
//   Reusing the service proxy is helpful in scenarios where an application connects
//  to the same service time and time again. The cost of initialization is only paid
//  once during the initial creation of the service proxy.
//  
HRESULT WINAPI WsResetServiceProxy(
    __in WS_SERVICE_PROXY* serviceProxy, 
    __in_opt WS_ERROR* error);


//  Service Proxy function
//  
//   Abandons a call identified by the callId on the given (Service Proxy) service proxy.
//  
//   An applications must be careful with the usage of this operation. Since the actual I/O specific
//  to the call is not canceled. The service proxy will keep the resources for the abandoned call
//  around to complete call.
//  
//   This consumption of resources can be aggravated if the application continues to abandon more
//  and more calls. This aggravation usually results if the server is slow to respond back to the
//  client. Mean while if the application continues to make more calls on the service proxy that
//  can further aggravate the situation.
//  
HRESULT WINAPI WsAbandonCall(
    __in WS_SERVICE_PROXY* serviceProxy, 
    __in ULONG callId, 
    __in_opt WS_ERROR* error);


//  Service Proxy function
//  
//   Using the passed in (WS_OPERATION_DESCRIPTION) operation parameter packs
//  the arguments into a message and sends it over the channel.
//  
//   This function is internally used by proxy service operation. The application should
//  never call it directly.
//  
HRESULT WINAPI WsCall(
    __in WS_SERVICE_PROXY* serviceProxy, 
    __in const WS_OPERATION_DESCRIPTION* operation, 
    __in_opt const void** arguments, 
    __in WS_HEAP* heap, 
    __in_ecount_opt(callPropertyCount) const WS_CALL_PROPERTY* callProperties, 
    __in const ULONG callPropertyCount, 
    __in_opt const WS_ASYNC_CONTEXT* asyncContext, 
    __in_opt WS_ERROR* error);


//  Url function
//  Decodes an URL into its component parts.
HRESULT WINAPI WsDecodeUrl(
    __in const WS_STRING* url, 
    __in ULONG flags, 
    __in WS_HEAP* heap, 
    __deref_out WS_URL** outUrl, 
    __in_opt WS_ERROR* error);


//  Url function
//  Encodes an URL into a string given its component parts.
HRESULT WINAPI WsEncodeUrl(
    __in const WS_URL* url, 
    __in ULONG flags, 
    __in WS_HEAP* heap, 
    __out WS_STRING* outUrl, 
    __in_opt WS_ERROR* error);


//  Url function
//  
//   Produces an absolute URL given a URL reference (absolute or relative URL) and an absolute base URL.
//  
HRESULT WINAPI WsCombineUrl(
    __in const WS_STRING* baseUrl, 
    __in const WS_STRING* referenceUrl, 
    __in ULONG flags, 
    __in WS_HEAP* heap, 
    __out WS_STRING* resultUrl, 
    __in_opt WS_ERROR* error);


//  Utilities function
//  
//   Converts a WS_DATETIME to a FILETIME.
//  
HRESULT WINAPI WsDateTimeToFileTime(
    __in const WS_DATETIME* dateTime, 
    __out FILETIME* fileTime, 
    __in_opt WS_ERROR* error);


//  Utilities function
//  
//   Converts a FILETIME to a WS_DATETIME.
//  
HRESULT WINAPI WsFileTimeToDateTime(
    __in const FILETIME* fileTime, 
    __out WS_DATETIME* dateTime, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   Create a metadata object which is used to collect and process metadata documents.
//  
HRESULT WINAPI WsCreateMetadata(
    __in_ecount_opt(propertyCount) const WS_METADATA_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __deref_out WS_METADATA** metadata, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   Read a metadata element and add it to the set of metadata
//  documents stored in the metadata object.
//  
HRESULT WINAPI WsReadMetadata(
    __in WS_METADATA* metadata, 
    __in WS_XML_READER* reader, 
    __in const WS_STRING* url, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   Free a metadata object.
//  
void WINAPI WsFreeMetadata(__in WS_METADATA* metadata);


//  Metadata Import function
//  
//   Reset a metadata object so it can be reused.
//  
HRESULT WINAPI WsResetMetadata(
    __in WS_METADATA* metadata, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   Retrieve a property of the metadata object.
//  
HRESULT WINAPI WsGetMetadataProperty(
    __in WS_METADATA* metadata, 
    __in WS_METADATA_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   Returns the address of a missing document that is referenced by the metadata object.
//  
HRESULT WINAPI WsGetMissingMetadataDocumentAddress(
    __in WS_METADATA* metadata, 
    __deref_out_opt WS_ENDPOINT_ADDRESS** address, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   Returns the endpoints that were defined in the metadata documents
//  that were added to the metadata object.
//  
HRESULT WINAPI WsGetMetadataEndpoints(
    __in WS_METADATA* metadata, 
    __out WS_METADATA_ENDPOINTS* endpoints, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   This function tests to see if a particular policy alternative is compatible
//  with the specified policy constraint structures.  If the alternative is compatible,
//  then the "out" fields within the constraint structures are filled with information
//  from the policy.
//  
HRESULT WINAPI WsMatchPolicyAlternative(
    __in WS_POLICY* policy, 
    __in ULONG alternativeIndex, 
    __in WS_POLICY_CONSTRAINTS* policyConstraints, 
    __in BOOL matchRequired, 
    __in WS_HEAP* heap, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   Retrieve a property of the policy object.
//  
HRESULT WINAPI WsGetPolicyProperty(
    __in WS_POLICY* policy, 
    __in WS_POLICY_PROPERTY_ID id, 
    __out_bcount(valueSize) void* value, 
    __in ULONG valueSize, 
    __in_opt WS_ERROR* error);


//  Metadata Import function
//  
//   Retrieve the number of alternatives available in the policy object.
//  
HRESULT WINAPI WsGetPolicyAlternativeCount(
    __in WS_POLICY* policy, 
    __out ULONG* count, 
    __in_opt WS_ERROR* error);


//  Policy Support function
//  
//   Helper routine to create channel from policy templates.
//  
HRESULT WINAPI WsCreateServiceProxyFromTemplate(
    __in WS_CHANNEL_TYPE channelType, 
    __in_ecount_opt(propertyCount) const WS_PROXY_PROPERTY* properties, 
    __in const ULONG propertyCount, 
    __in WS_BINDING_TEMPLATE_TYPE templateType, 
    __in_bcount_opt(templateSize) void* templateValue, 
    __in ULONG templateSize, 
    __in const void* templateDescription, 
    __in ULONG templateDescriptionSize, 
    __deref_out WS_SERVICE_PROXY** serviceProxy, 
    __in_opt WS_ERROR* error);


//  Policy Support function
//  
//   Helper routine to create channel from policy templates.
//  
HRESULT WINAPI WsCreateServiceEndpointFromTemplate(
    __in WS_CHANNEL_TYPE channelType, 
    __in const WS_SERVICE_ENDPOINT_PROPERTY* properties, 
    __in ULONG propertyCount, 
    __in_opt const WS_STRING* addressUrl, 
    __in const WS_SERVICE_CONTRACT* contract, 
    __in WS_SERVICE_SECURITY_CALLBACK authorizationCallback, 
    __in WS_HEAP* heap, 
    __in WS_BINDING_TEMPLATE_TYPE templateType, 
    __in_bcount_opt(templateSize) void* templateValue, 
    __in ULONG templateSize, 
    __in const void* templateDescription, 
    __in ULONG templateDescriptionSize, 
    __deref_out WS_SERVICE_ENDPOINT** serviceEndpoint, 
    __in_opt WS_ERROR* error);


//  ERROR DEFINITIONS
#ifndef FACILITY_WEBSERVICES
#define FACILITY_WEBSERVICES                    0x3d
#define WS_S_ASYNC                              0x003D0000
#define WS_S_END                                0x003D0001
#define WS_E_INVALID_FORMAT                     0x803D0000
#define WS_E_OBJECT_FAULTED                     0x803D0001
#define WS_E_NUMERIC_OVERFLOW                   0x803D0002
#define WS_E_INVALID_OPERATION                  0x803D0003
#define WS_E_OPERATION_ABORTED                  0x803D0004
#define WS_E_ENDPOINT_ACCESS_DENIED             0x803D0005
#define WS_E_OPERATION_TIMED_OUT                0x803D0006
#define WS_E_OPERATION_ABANDONED                0x803D0007
#define WS_E_QUOTA_EXCEEDED                     0x803D0008
#define WS_E_NO_TRANSLATION_AVAILABLE           0x803D0009
#define WS_E_SECURITY_VERIFICATION_FAILURE      0x803D000A
#define WS_E_ADDRESS_IN_USE                     0x803D000B
#define WS_E_ADDRESS_NOT_AVAILABLE              0x803D000C
#define WS_E_ENDPOINT_NOT_FOUND                 0x803D000D
#define WS_E_ENDPOINT_NOT_AVAILABLE             0x803D000E
#define WS_E_ENDPOINT_FAILURE                   0x803D000F
#define WS_E_ENDPOINT_UNREACHABLE               0x803D0010
#define WS_E_ENDPOINT_ACTION_NOT_SUPPORTED      0x803D0011
#define WS_E_ENDPOINT_TOO_BUSY                  0x803D0012
#define WS_E_ENDPOINT_FAULT_RECEIVED            0x803D0013
#define WS_E_ENDPOINT_DISCONNECTED              0x803D0014
#define WS_E_PROXY_FAILURE                      0x803D0015
#define WS_E_PROXY_ACCESS_DENIED                0x803D0016
#define WS_E_NOT_SUPPORTED                      0x803D0017
#define WS_E_PROXY_REQUIRES_BASIC_AUTH          0x803D0018
#define WS_E_PROXY_REQUIRES_DIGEST_AUTH         0x803D0019
#define WS_E_PROXY_REQUIRES_NTLM_AUTH           0x803D001A
#define WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH      0x803D001B
#define WS_E_SERVER_REQUIRES_BASIC_AUTH         0x803D001C
#define WS_E_SERVER_REQUIRES_DIGEST_AUTH        0x803D001D
#define WS_E_SERVER_REQUIRES_NTLM_AUTH          0x803D001E
#define WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH     0x803D001F
#define WS_E_INVALID_ENDPOINT_URL               0x803D0020
#define WS_E_OTHER                              0x803D0021
#define WS_E_SECURITY_TOKEN_EXPIRED             0x803D0022
#define WS_E_SECURITY_SYSTEM_FAILURE            0x803D0023
#endif
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WiaVideo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0453 */
/* Compiler settings for wiavideo.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wiavideo_h__
#define __wiavideo_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWiaVideo_FWD_DEFINED__
#define __IWiaVideo_FWD_DEFINED__
typedef interface IWiaVideo IWiaVideo;
#endif 	/* __IWiaVideo_FWD_DEFINED__ */


#ifndef __WiaVideo_FWD_DEFINED__
#define __WiaVideo_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaVideo WiaVideo;
#else
typedef struct WiaVideo WiaVideo;
#endif /* __cplusplus */

#endif 	/* __WiaVideo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wiavideo_0000_0000 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_wiavideo_0000_0000_0001
    {	WIAVIDEO_NO_VIDEO	= 1,
	WIAVIDEO_CREATING_VIDEO	= 2,
	WIAVIDEO_VIDEO_CREATED	= 3,
	WIAVIDEO_VIDEO_PLAYING	= 4,
	WIAVIDEO_VIDEO_PAUSED	= 5,
	WIAVIDEO_DESTROYING_VIDEO	= 6
    } 	WIAVIDEO_STATE;



extern RPC_IF_HANDLE __MIDL_itf_wiavideo_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wiavideo_0000_0000_v0_0_s_ifspec;

#ifndef __IWiaVideo_INTERFACE_DEFINED__
#define __IWiaVideo_INTERFACE_DEFINED__

/* interface IWiaVideo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaVideo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D52920AA-DB88-41F0-946C-E00DC0A19CFA")
    IWiaVideo : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PreviewVisible( 
            /* [retval][out] */ __RPC__out BOOL *pbPreviewVisible) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PreviewVisible( 
            /* [in] */ BOOL bPreviewVisible) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImagesDirectory( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrImageDirectory) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ImagesDirectory( 
            /* [in] */ __RPC__in BSTR bstrImageDirectory) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateVideoByWiaDevID( 
            /* [in] */ __RPC__in BSTR bstrWiaDeviceID,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ BOOL bStretchToFitParent,
            /* [in] */ BOOL bAutoBeginPlayback) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateVideoByDevNum( 
            /* [in] */ UINT uiDeviceNumber,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ BOOL bStretchToFitParent,
            /* [in] */ BOOL bAutoBeginPlayback) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateVideoByName( 
            /* [in] */ __RPC__in BSTR bstrFriendlyName,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ BOOL bStretchToFitParent,
            /* [in] */ BOOL bAutoBeginPlayback) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DestroyVideo( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TakePicture( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNewImageFilename) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResizeVideo( 
            /* [in] */ BOOL bStretchToFitParent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrentState( 
            /* [retval][out] */ __RPC__out WIAVIDEO_STATE *pState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWiaVideo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWiaVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWiaVideo * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreviewVisible )( 
            IWiaVideo * This,
            /* [retval][out] */ __RPC__out BOOL *pbPreviewVisible);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreviewVisible )( 
            IWiaVideo * This,
            /* [in] */ BOOL bPreviewVisible);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImagesDirectory )( 
            IWiaVideo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrImageDirectory);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ImagesDirectory )( 
            IWiaVideo * This,
            /* [in] */ __RPC__in BSTR bstrImageDirectory);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateVideoByWiaDevID )( 
            IWiaVideo * This,
            /* [in] */ __RPC__in BSTR bstrWiaDeviceID,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ BOOL bStretchToFitParent,
            /* [in] */ BOOL bAutoBeginPlayback);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateVideoByDevNum )( 
            IWiaVideo * This,
            /* [in] */ UINT uiDeviceNumber,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ BOOL bStretchToFitParent,
            /* [in] */ BOOL bAutoBeginPlayback);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateVideoByName )( 
            IWiaVideo * This,
            /* [in] */ __RPC__in BSTR bstrFriendlyName,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ BOOL bStretchToFitParent,
            /* [in] */ BOOL bAutoBeginPlayback);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DestroyVideo )( 
            IWiaVideo * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Play )( 
            IWiaVideo * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IWiaVideo * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *TakePicture )( 
            IWiaVideo * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNewImageFilename);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResizeVideo )( 
            IWiaVideo * This,
            /* [in] */ BOOL bStretchToFitParent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentState )( 
            IWiaVideo * This,
            /* [retval][out] */ __RPC__out WIAVIDEO_STATE *pState);
        
        END_INTERFACE
    } IWiaVideoVtbl;

    interface IWiaVideo
    {
        CONST_VTBL struct IWiaVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaVideo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaVideo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaVideo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaVideo_get_PreviewVisible(This,pbPreviewVisible)	\
    ( (This)->lpVtbl -> get_PreviewVisible(This,pbPreviewVisible) ) 

#define IWiaVideo_put_PreviewVisible(This,bPreviewVisible)	\
    ( (This)->lpVtbl -> put_PreviewVisible(This,bPreviewVisible) ) 

#define IWiaVideo_get_ImagesDirectory(This,pbstrImageDirectory)	\
    ( (This)->lpVtbl -> get_ImagesDirectory(This,pbstrImageDirectory) ) 

#define IWiaVideo_put_ImagesDirectory(This,bstrImageDirectory)	\
    ( (This)->lpVtbl -> put_ImagesDirectory(This,bstrImageDirectory) ) 

#define IWiaVideo_CreateVideoByWiaDevID(This,bstrWiaDeviceID,hwndParent,bStretchToFitParent,bAutoBeginPlayback)	\
    ( (This)->lpVtbl -> CreateVideoByWiaDevID(This,bstrWiaDeviceID,hwndParent,bStretchToFitParent,bAutoBeginPlayback) ) 

#define IWiaVideo_CreateVideoByDevNum(This,uiDeviceNumber,hwndParent,bStretchToFitParent,bAutoBeginPlayback)	\
    ( (This)->lpVtbl -> CreateVideoByDevNum(This,uiDeviceNumber,hwndParent,bStretchToFitParent,bAutoBeginPlayback) ) 

#define IWiaVideo_CreateVideoByName(This,bstrFriendlyName,hwndParent,bStretchToFitParent,bAutoBeginPlayback)	\
    ( (This)->lpVtbl -> CreateVideoByName(This,bstrFriendlyName,hwndParent,bStretchToFitParent,bAutoBeginPlayback) ) 

#define IWiaVideo_DestroyVideo(This)	\
    ( (This)->lpVtbl -> DestroyVideo(This) ) 

#define IWiaVideo_Play(This)	\
    ( (This)->lpVtbl -> Play(This) ) 

#define IWiaVideo_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IWiaVideo_TakePicture(This,pbstrNewImageFilename)	\
    ( (This)->lpVtbl -> TakePicture(This,pbstrNewImageFilename) ) 

#define IWiaVideo_ResizeVideo(This,bStretchToFitParent)	\
    ( (This)->lpVtbl -> ResizeVideo(This,bStretchToFitParent) ) 

#define IWiaVideo_GetCurrentState(This,pState)	\
    ( (This)->lpVtbl -> GetCurrentState(This,pState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWiaVideo_get_PreviewVisible_Proxy( 
    IWiaVideo * This,
    /* [retval][out] */ __RPC__out BOOL *pbPreviewVisible);


void __RPC_STUB IWiaVideo_get_PreviewVisible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWiaVideo_put_PreviewVisible_Proxy( 
    IWiaVideo * This,
    /* [in] */ BOOL bPreviewVisible);


void __RPC_STUB IWiaVideo_put_PreviewVisible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWiaVideo_get_ImagesDirectory_Proxy( 
    IWiaVideo * This,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrImageDirectory);


void __RPC_STUB IWiaVideo_get_ImagesDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWiaVideo_put_ImagesDirectory_Proxy( 
    IWiaVideo * This,
    /* [in] */ __RPC__in BSTR bstrImageDirectory);


void __RPC_STUB IWiaVideo_put_ImagesDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_CreateVideoByWiaDevID_Proxy( 
    IWiaVideo * This,
    /* [in] */ __RPC__in BSTR bstrWiaDeviceID,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ BOOL bStretchToFitParent,
    /* [in] */ BOOL bAutoBeginPlayback);


void __RPC_STUB IWiaVideo_CreateVideoByWiaDevID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_CreateVideoByDevNum_Proxy( 
    IWiaVideo * This,
    /* [in] */ UINT uiDeviceNumber,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ BOOL bStretchToFitParent,
    /* [in] */ BOOL bAutoBeginPlayback);


void __RPC_STUB IWiaVideo_CreateVideoByDevNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_CreateVideoByName_Proxy( 
    IWiaVideo * This,
    /* [in] */ __RPC__in BSTR bstrFriendlyName,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ BOOL bStretchToFitParent,
    /* [in] */ BOOL bAutoBeginPlayback);


void __RPC_STUB IWiaVideo_CreateVideoByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_DestroyVideo_Proxy( 
    IWiaVideo * This);


void __RPC_STUB IWiaVideo_DestroyVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_Play_Proxy( 
    IWiaVideo * This);


void __RPC_STUB IWiaVideo_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_Pause_Proxy( 
    IWiaVideo * This);


void __RPC_STUB IWiaVideo_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_TakePicture_Proxy( 
    IWiaVideo * This,
    /* [out] */ __RPC__deref_out_opt BSTR *pbstrNewImageFilename);


void __RPC_STUB IWiaVideo_TakePicture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_ResizeVideo_Proxy( 
    IWiaVideo * This,
    /* [in] */ BOOL bStretchToFitParent);


void __RPC_STUB IWiaVideo_ResizeVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWiaVideo_GetCurrentState_Proxy( 
    IWiaVideo * This,
    /* [retval][out] */ __RPC__out WIAVIDEO_STATE *pState);


void __RPC_STUB IWiaVideo_GetCurrentState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaVideo_INTERFACE_DEFINED__ */



#ifndef __WIAVIDEOLib_LIBRARY_DEFINED__
#define __WIAVIDEOLib_LIBRARY_DEFINED__

/* library WIAVIDEOLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WIAVIDEOLib;

EXTERN_C const CLSID CLSID_WiaVideo;

#ifdef __cplusplus

class DECLSPEC_UUID("3908C3CD-4478-4536-AF2F-10C25D4EF89A")
WiaVideo;
#endif
#endif /* __WIAVIDEOLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wia_xp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wia_xp.idl, wia_xp.acf:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wia_xp_h__
#define __wia_xp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWiaDevMgr_FWD_DEFINED__
#define __IWiaDevMgr_FWD_DEFINED__
typedef interface IWiaDevMgr IWiaDevMgr;
#endif 	/* __IWiaDevMgr_FWD_DEFINED__ */


#ifndef __IEnumWIA_DEV_INFO_FWD_DEFINED__
#define __IEnumWIA_DEV_INFO_FWD_DEFINED__
typedef interface IEnumWIA_DEV_INFO IEnumWIA_DEV_INFO;
#endif 	/* __IEnumWIA_DEV_INFO_FWD_DEFINED__ */


#ifndef __IWiaEventCallback_FWD_DEFINED__
#define __IWiaEventCallback_FWD_DEFINED__
typedef interface IWiaEventCallback IWiaEventCallback;
#endif 	/* __IWiaEventCallback_FWD_DEFINED__ */


#ifndef __IWiaDataCallback_FWD_DEFINED__
#define __IWiaDataCallback_FWD_DEFINED__
typedef interface IWiaDataCallback IWiaDataCallback;
#endif 	/* __IWiaDataCallback_FWD_DEFINED__ */


#ifndef __IWiaDataTransfer_FWD_DEFINED__
#define __IWiaDataTransfer_FWD_DEFINED__
typedef interface IWiaDataTransfer IWiaDataTransfer;
#endif 	/* __IWiaDataTransfer_FWD_DEFINED__ */


#ifndef __IWiaItem_FWD_DEFINED__
#define __IWiaItem_FWD_DEFINED__
typedef interface IWiaItem IWiaItem;
#endif 	/* __IWiaItem_FWD_DEFINED__ */


#ifndef __IWiaPropertyStorage_FWD_DEFINED__
#define __IWiaPropertyStorage_FWD_DEFINED__
typedef interface IWiaPropertyStorage IWiaPropertyStorage;
#endif 	/* __IWiaPropertyStorage_FWD_DEFINED__ */


#ifndef __IEnumWiaItem_FWD_DEFINED__
#define __IEnumWiaItem_FWD_DEFINED__
typedef interface IEnumWiaItem IEnumWiaItem;
#endif 	/* __IEnumWiaItem_FWD_DEFINED__ */


#ifndef __IEnumWIA_DEV_CAPS_FWD_DEFINED__
#define __IEnumWIA_DEV_CAPS_FWD_DEFINED__
typedef interface IEnumWIA_DEV_CAPS IEnumWIA_DEV_CAPS;
#endif 	/* __IEnumWIA_DEV_CAPS_FWD_DEFINED__ */


#ifndef __IEnumWIA_FORMAT_INFO_FWD_DEFINED__
#define __IEnumWIA_FORMAT_INFO_FWD_DEFINED__
typedef interface IEnumWIA_FORMAT_INFO IEnumWIA_FORMAT_INFO;
#endif 	/* __IEnumWIA_FORMAT_INFO_FWD_DEFINED__ */


#ifndef __IWiaLog_FWD_DEFINED__
#define __IWiaLog_FWD_DEFINED__
typedef interface IWiaLog IWiaLog;
#endif 	/* __IWiaLog_FWD_DEFINED__ */


#ifndef __IWiaLogEx_FWD_DEFINED__
#define __IWiaLogEx_FWD_DEFINED__
typedef interface IWiaLogEx IWiaLogEx;
#endif 	/* __IWiaLogEx_FWD_DEFINED__ */


#ifndef __IWiaNotifyDevMgr_FWD_DEFINED__
#define __IWiaNotifyDevMgr_FWD_DEFINED__
typedef interface IWiaNotifyDevMgr IWiaNotifyDevMgr;
#endif 	/* __IWiaNotifyDevMgr_FWD_DEFINED__ */


#ifndef __IWiaItemExtras_FWD_DEFINED__
#define __IWiaItemExtras_FWD_DEFINED__
typedef interface IWiaItemExtras IWiaItemExtras;
#endif 	/* __IWiaItemExtras_FWD_DEFINED__ */


#ifndef __WiaDevMgr_FWD_DEFINED__
#define __WiaDevMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaDevMgr WiaDevMgr;
#else
typedef struct WiaDevMgr WiaDevMgr;
#endif /* __cplusplus */

#endif 	/* __WiaDevMgr_FWD_DEFINED__ */


#ifndef __WiaLog_FWD_DEFINED__
#define __WiaLog_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaLog WiaLog;
#else
typedef struct WiaLog WiaLog;
#endif /* __cplusplus */

#endif 	/* __WiaLog_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wia_xp_0000_0000 */
/* [local] */ 











typedef struct _WIA_DITHER_PATTERN_DATA
    {
    LONG lSize;
    BSTR bstrPatternName;
    LONG lPatternWidth;
    LONG lPatternLength;
    LONG cbPattern;
    BYTE *pbPattern;
    } 	WIA_DITHER_PATTERN_DATA;

typedef struct _WIA_DITHER_PATTERN_DATA *PWIA_DITHER_PATTERN_DATA;

typedef struct _WIA_PROPID_TO_NAME
    {
    PROPID propid;
    LPOLESTR pszName;
    } 	WIA_PROPID_TO_NAME;

typedef struct _WIA_PROPID_TO_NAME *PWIA_PROPID_TO_NAME;

typedef struct _WIA_FORMAT_INFO
    {
    GUID guidFormatID;
    LONG lTymed;
    } 	WIA_FORMAT_INFO;

typedef struct _WIA_FORMAT_INFO *PWIA_FORMAT_INFO;

#include "wiadef.h"


extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0000_v0_0_s_ifspec;

#ifndef __IWiaDevMgr_INTERFACE_DEFINED__
#define __IWiaDevMgr_INTERFACE_DEFINED__

/* interface IWiaDevMgr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDevMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5eb2502a-8cf1-11d1-bf92-0060081ed811")
    IWiaDevMgr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceInfo( 
            /* [in] */ LONG lFlag,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateDevice( 
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem **ppWiaItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem **ppItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlgID( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetImageDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [in] */ IWiaItem *pItemRoot,
            /* [in] */ BSTR bstrFilename,
            /* [out][in] */ GUID *pguidFormat) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackProgram( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrCommandline,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackInterface( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackCLSID( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDeviceDlg( 
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDevMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaDevMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaDevMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaDevMgr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceInfo )( 
            __RPC__in IWiaDevMgr * This,
            /* [in] */ LONG lFlag,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateDevice )( 
            IWiaDevMgr * This,
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem **ppWiaItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlg )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem **ppItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlgID )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetImageDlg )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [in] */ IWiaItem *pItemRoot,
            /* [in] */ BSTR bstrFilename,
            /* [out][in] */ GUID *pguidFormat);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackProgram )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrCommandline,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackInterface )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackCLSID )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDeviceDlg )( 
            __RPC__in IWiaDevMgr * This,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IWiaDevMgrVtbl;

    interface IWiaDevMgr
    {
        CONST_VTBL struct IWiaDevMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDevMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDevMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDevMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDevMgr_EnumDeviceInfo(This,lFlag,ppIEnum)	\
    ( (This)->lpVtbl -> EnumDeviceInfo(This,lFlag,ppIEnum) ) 

#define IWiaDevMgr_CreateDevice(This,bstrDeviceID,ppWiaItemRoot)	\
    ( (This)->lpVtbl -> CreateDevice(This,bstrDeviceID,ppWiaItemRoot) ) 

#define IWiaDevMgr_SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot)	\
    ( (This)->lpVtbl -> SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot) ) 

#define IWiaDevMgr_SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID)	\
    ( (This)->lpVtbl -> SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID) ) 

#define IWiaDevMgr_GetImageDlg(This,hwndParent,lDeviceType,lFlags,lIntent,pItemRoot,bstrFilename,pguidFormat)	\
    ( (This)->lpVtbl -> GetImageDlg(This,hwndParent,lDeviceType,lFlags,lIntent,pItemRoot,bstrFilename,pguidFormat) ) 

#define IWiaDevMgr_RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrCommandline,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrCommandline,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr_RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject)	\
    ( (This)->lpVtbl -> RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject) ) 

#define IWiaDevMgr_RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr_AddDeviceDlg(This,hwndParent,lFlags)	\
    ( (This)->lpVtbl -> AddDeviceDlg(This,hwndParent,lFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalCreateDevice_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem **ppWiaItemRoot);


void __RPC_STUB IWiaDevMgr_LocalCreateDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalSelectDeviceDlg_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem **ppItemRoot);


void __RPC_STUB IWiaDevMgr_LocalSelectDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalSelectDeviceDlgID_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);


void __RPC_STUB IWiaDevMgr_LocalSelectDeviceDlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalGetImageDlg_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ __RPC__in_opt IWiaItem *pItemRoot,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out][in] */ __RPC__inout GUID *pguidFormat);


void __RPC_STUB IWiaDevMgr_LocalGetImageDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackProgram_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrCommandline,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackInterface_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackCLSID_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDevMgr_INTERFACE_DEFINED__ */


#ifndef __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__
#define __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__

/* interface IEnumWIA_DEV_INFO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_DEV_INFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e38b83c-8cf1-11d1-bf92-0060081ed811")
    IEnumWIA_DEV_INFO : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_DEV_INFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWIA_DEV_INFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWIA_DEV_INFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWIA_DEV_INFO * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_DEV_INFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWIA_DEV_INFO * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWIA_DEV_INFO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWIA_DEV_INFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWIA_DEV_INFO * This,
            /* [out] */ __RPC__out ULONG *celt);
        
        END_INTERFACE
    } IEnumWIA_DEV_INFOVtbl;

    interface IEnumWIA_DEV_INFO
    {
        CONST_VTBL struct IEnumWIA_DEV_INFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_DEV_INFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_DEV_INFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_DEV_INFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_DEV_INFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_DEV_INFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_DEV_INFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_DEV_INFO_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_DEV_INFO_GetCount(This,celt)	\
    ( (This)->lpVtbl -> GetCount(This,celt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_RemoteNext_Proxy( 
    __RPC__in IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_DEV_INFO_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__ */


#ifndef __IWiaEventCallback_INTERFACE_DEFINED__
#define __IWiaEventCallback_INTERFACE_DEFINED__

/* interface IWiaEventCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaEventCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae6287b0-0084-11d2-973b-00a0c9068f2e")
    IWiaEventCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ImageEventCallback( 
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrEventDescription,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrDeviceDescription,
            /* [in] */ DWORD dwDeviceType,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out][in] */ __RPC__inout ULONG *pulEventType,
            /* [in] */ ULONG ulReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaEventCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaEventCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaEventCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaEventCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ImageEventCallback )( 
            __RPC__in IWiaEventCallback * This,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrEventDescription,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrDeviceDescription,
            /* [in] */ DWORD dwDeviceType,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out][in] */ __RPC__inout ULONG *pulEventType,
            /* [in] */ ULONG ulReserved);
        
        END_INTERFACE
    } IWiaEventCallbackVtbl;

    interface IWiaEventCallback
    {
        CONST_VTBL struct IWiaEventCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaEventCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaEventCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaEventCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaEventCallback_ImageEventCallback(This,pEventGUID,bstrEventDescription,bstrDeviceID,bstrDeviceDescription,dwDeviceType,bstrFullItemName,pulEventType,ulReserved)	\
    ( (This)->lpVtbl -> ImageEventCallback(This,pEventGUID,bstrEventDescription,bstrDeviceID,bstrDeviceDescription,dwDeviceType,bstrFullItemName,pulEventType,ulReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaEventCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_xp_0000_0003 */
/* [local] */ 

typedef struct _WIA_DATA_CALLBACK_HEADER
    {
    LONG lSize;
    GUID guidFormatID;
    LONG lBufferSize;
    LONG lPageCount;
    } 	WIA_DATA_CALLBACK_HEADER;

typedef struct _WIA_DATA_CALLBACK_HEADER *PWIA_DATA_CALLBACK_HEADER;



extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0003_v0_0_s_ifspec;

#ifndef __IWiaDataCallback_INTERFACE_DEFINED__
#define __IWiaDataCallback_INTERFACE_DEFINED__

/* interface IWiaDataCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDataCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a558a866-a5b0-11d2-a08f-00c04f72dc3c")
    IWiaDataCallback : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BandedDataCallback( 
            /* [in] */ LONG lMessage,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ LONG lReserved,
            /* [in] */ LONG lResLength,
            /* [size_is][in] */ BYTE *pbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDataCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaDataCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaDataCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaDataCallback * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BandedDataCallback )( 
            IWiaDataCallback * This,
            /* [in] */ LONG lMessage,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ LONG lReserved,
            /* [in] */ LONG lResLength,
            /* [size_is][in] */ BYTE *pbBuffer);
        
        END_INTERFACE
    } IWiaDataCallbackVtbl;

    interface IWiaDataCallback
    {
        CONST_VTBL struct IWiaDataCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDataCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDataCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDataCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDataCallback_BandedDataCallback(This,lMessage,lStatus,lPercentComplete,lOffset,lLength,lReserved,lResLength,pbBuffer)	\
    ( (This)->lpVtbl -> BandedDataCallback(This,lMessage,lStatus,lPercentComplete,lOffset,lLength,lReserved,lResLength,pbBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_RemoteBandedDataCallback_Proxy( 
    __RPC__in IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lResLength) BYTE *pbBuffer);


void __RPC_STUB IWiaDataCallback_RemoteBandedDataCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDataCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_xp_0000_0004 */
/* [local] */ 

typedef struct _WIA_DATA_TRANSFER_INFO
    {
    ULONG ulSize;
    ULONG ulSection;
    ULONG ulBufferSize;
    BOOL bDoubleBuffer;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulReserved3;
    } 	WIA_DATA_TRANSFER_INFO;

typedef struct _WIA_DATA_TRANSFER_INFO *PWIA_DATA_TRANSFER_INFO;

typedef struct _WIA_EXTENDED_TRANSFER_INFO
    {
    ULONG ulSize;
    ULONG ulMinBufferSize;
    ULONG ulOptimalBufferSize;
    ULONG ulMaxBufferSize;
    ULONG ulNumBuffers;
    } 	WIA_EXTENDED_TRANSFER_INFO;

typedef struct _WIA_EXTENDED_TRANSFER_INFO *PWIA_EXTENDED_TRANSFER_INFO;



extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0004_v0_0_s_ifspec;

#ifndef __IWiaDataTransfer_INTERFACE_DEFINED__
#define __IWiaDataTransfer_INTERFACE_DEFINED__

/* interface IWiaDataTransfer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDataTransfer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6cef998-a5b0-11d2-a08f-00c04f72dc3c")
    IWiaDataTransfer : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE idtGetData( 
            /* [out][in] */ LPSTGMEDIUM pMedium,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE idtGetBandedData( 
            /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtQueryGetData( 
            /* [unique][in] */ __RPC__in_opt WIA_FORMAT_INFO *pfe) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtEnumWIA_FORMAT_INFO( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtGetExtendedTransferInfo( 
            /* [out] */ __RPC__out PWIA_EXTENDED_TRANSFER_INFO pExtendedTransferInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDataTransferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaDataTransfer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaDataTransfer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaDataTransfer * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *idtGetData )( 
            IWiaDataTransfer * This,
            /* [out][in] */ LPSTGMEDIUM pMedium,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *idtGetBandedData )( 
            IWiaDataTransfer * This,
            /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtQueryGetData )( 
            __RPC__in IWiaDataTransfer * This,
            /* [unique][in] */ __RPC__in_opt WIA_FORMAT_INFO *pfe);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtEnumWIA_FORMAT_INFO )( 
            __RPC__in IWiaDataTransfer * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtGetExtendedTransferInfo )( 
            __RPC__in IWiaDataTransfer * This,
            /* [out] */ __RPC__out PWIA_EXTENDED_TRANSFER_INFO pExtendedTransferInfo);
        
        END_INTERFACE
    } IWiaDataTransferVtbl;

    interface IWiaDataTransfer
    {
        CONST_VTBL struct IWiaDataTransferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDataTransfer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDataTransfer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDataTransfer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDataTransfer_idtGetData(This,pMedium,pIWiaDataCallback)	\
    ( (This)->lpVtbl -> idtGetData(This,pMedium,pIWiaDataCallback) ) 

#define IWiaDataTransfer_idtGetBandedData(This,pWiaDataTransInfo,pIWiaDataCallback)	\
    ( (This)->lpVtbl -> idtGetBandedData(This,pWiaDataTransInfo,pIWiaDataCallback) ) 

#define IWiaDataTransfer_idtQueryGetData(This,pfe)	\
    ( (This)->lpVtbl -> idtQueryGetData(This,pfe) ) 

#define IWiaDataTransfer_idtEnumWIA_FORMAT_INFO(This,ppEnum)	\
    ( (This)->lpVtbl -> idtEnumWIA_FORMAT_INFO(This,ppEnum) ) 

#define IWiaDataTransfer_idtGetExtendedTransferInfo(This,pExtendedTransferInfo)	\
    ( (This)->lpVtbl -> idtGetExtendedTransferInfo(This,pExtendedTransferInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetDataEx_Proxy( 
    __RPC__in IWiaDataTransfer * This,
    /* [out][in] */ __RPC__inout LPSTGMEDIUM pMedium,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);


void __RPC_STUB IWiaDataTransfer_idtGetDataEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedDataEx_Proxy( 
    __RPC__in IWiaDataTransfer * This,
    /* [unique][in] */ __RPC__in_opt PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);


void __RPC_STUB IWiaDataTransfer_idtGetBandedDataEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDataTransfer_INTERFACE_DEFINED__ */


#ifndef __IWiaItem_INTERFACE_DEFINED__
#define __IWiaItem_INTERFACE_DEFINED__

/* interface IWiaItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4db1ad10-3391-11d2-9a33-00c04fa36145")
    IWiaItem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemType( 
            /* [out] */ __RPC__out LONG *pItemType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AnalyzeItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumChildItems( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnumWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateChildItem( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumRegisterEventInfo( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByName( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [out] */ LONG *plItemCount,
            /* [out] */ IWiaItem ***ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeviceCommand( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem **pIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRootItem( 
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceCapabilities( 
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpDrvItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpTreeItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Diagnostic( 
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaItem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__out LONG *pItemType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AnalyzeItem )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumChildItems )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnumWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateChildItem )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumRegisterEventInfo )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindItemByName )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DeviceDlg )( 
            IWiaItem * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [out] */ LONG *plItemCount,
            /* [out] */ IWiaItem ***ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeviceCommand )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem **pIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRootItem )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceCapabilities )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpItemData )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpDrvItemData )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpTreeItemData )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Diagnostic )( 
            __RPC__in IWiaItem * This,
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer);
        
        END_INTERFACE
    } IWiaItemVtbl;

    interface IWiaItem
    {
        CONST_VTBL struct IWiaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItem_GetItemType(This,pItemType)	\
    ( (This)->lpVtbl -> GetItemType(This,pItemType) ) 

#define IWiaItem_AnalyzeItem(This,lFlags)	\
    ( (This)->lpVtbl -> AnalyzeItem(This,lFlags) ) 

#define IWiaItem_EnumChildItems(This,ppIEnumWiaItem)	\
    ( (This)->lpVtbl -> EnumChildItems(This,ppIEnumWiaItem) ) 

#define IWiaItem_DeleteItem(This,lFlags)	\
    ( (This)->lpVtbl -> DeleteItem(This,lFlags) ) 

#define IWiaItem_CreateChildItem(This,lFlags,bstrItemName,bstrFullItemName,ppIWiaItem)	\
    ( (This)->lpVtbl -> CreateChildItem(This,lFlags,bstrItemName,bstrFullItemName,ppIWiaItem) ) 

#define IWiaItem_EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum)	\
    ( (This)->lpVtbl -> EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum) ) 

#define IWiaItem_FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem)	\
    ( (This)->lpVtbl -> FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem) ) 

#define IWiaItem_DeviceDlg(This,hwndParent,lFlags,lIntent,plItemCount,ppIWiaItem)	\
    ( (This)->lpVtbl -> DeviceDlg(This,hwndParent,lFlags,lIntent,plItemCount,ppIWiaItem) ) 

#define IWiaItem_DeviceCommand(This,lFlags,pCmdGUID,pIWiaItem)	\
    ( (This)->lpVtbl -> DeviceCommand(This,lFlags,pCmdGUID,pIWiaItem) ) 

#define IWiaItem_GetRootItem(This,ppIWiaItem)	\
    ( (This)->lpVtbl -> GetRootItem(This,ppIWiaItem) ) 

#define IWiaItem_EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS)	\
    ( (This)->lpVtbl -> EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS) ) 

#define IWiaItem_DumpItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpItemData(This,bstrData) ) 

#define IWiaItem_DumpDrvItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpDrvItemData(This,bstrData) ) 

#define IWiaItem_DumpTreeItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpTreeItemData(This,bstrData) ) 

#define IWiaItem_Diagnostic(This,ulSize,pBuffer)	\
    ( (This)->lpVtbl -> Diagnostic(This,ulSize,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem_LocalDeviceDlg_Proxy( 
    __RPC__in IWiaItem * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ __RPC__out LONG *plItemCount,
    /* [out] */ __RPC__deref_out_opt IWiaItem ***pIWiaItem);


void __RPC_STUB IWiaItem_LocalDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaItem_INTERFACE_DEFINED__ */


#ifndef __IWiaPropertyStorage_INTERFACE_DEFINED__
#define __IWiaPropertyStorage_INTERFACE_DEFINED__

/* interface IWiaPropertyStorage */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98B5E8A0-29CC-491a-AAC0-E6DB4FDCCEB6")
    IWiaPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyAttributes( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) ULONG rgflags[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pulNumProps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyStream( 
            /* [out] */ __RPC__out GUID *pCompatibilityId,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetPropertyStream( 
            /* [in] */ GUID *pCompatibilityId,
            /* [unique][in] */ IStream *pIStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WriteMultiple )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMultiple )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyNames )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DeletePropertyNames )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            __RPC__in IWiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyAttributes )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) ULONG rgflags[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [out] */ __RPC__out ULONG *pulNumProps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyStream )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [out] */ __RPC__out GUID *pCompatibilityId,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetPropertyStream )( 
            IWiaPropertyStorage * This,
            /* [in] */ GUID *pCompatibilityId,
            /* [unique][in] */ IStream *pIStream);
        
        END_INTERFACE
    } IWiaPropertyStorageVtbl;

    interface IWiaPropertyStorage
    {
        CONST_VTBL struct IWiaPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaPropertyStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaPropertyStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgpropvar)	\
    ( (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgpropvar) ) 

#define IWiaPropertyStorage_WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)	\
    ( (This)->lpVtbl -> WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst) ) 

#define IWiaPropertyStorage_DeleteMultiple(This,cpspec,rgpspec)	\
    ( (This)->lpVtbl -> DeleteMultiple(This,cpspec,rgpspec) ) 

#define IWiaPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IWiaPropertyStorage_WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> WritePropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IWiaPropertyStorage_DeletePropertyNames(This,cpropid,rgpropid)	\
    ( (This)->lpVtbl -> DeletePropertyNames(This,cpropid,rgpropid) ) 

#define IWiaPropertyStorage_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IWiaPropertyStorage_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IWiaPropertyStorage_Enum(This,ppenum)	\
    ( (This)->lpVtbl -> Enum(This,ppenum) ) 

#define IWiaPropertyStorage_SetTimes(This,pctime,patime,pmtime)	\
    ( (This)->lpVtbl -> SetTimes(This,pctime,patime,pmtime) ) 

#define IWiaPropertyStorage_SetClass(This,clsid)	\
    ( (This)->lpVtbl -> SetClass(This,clsid) ) 

#define IWiaPropertyStorage_Stat(This,pstatpsstg)	\
    ( (This)->lpVtbl -> Stat(This,pstatpsstg) ) 

#define IWiaPropertyStorage_GetPropertyAttributes(This,cpspec,rgpspec,rgflags,rgpropvar)	\
    ( (This)->lpVtbl -> GetPropertyAttributes(This,cpspec,rgpspec,rgflags,rgpropvar) ) 

#define IWiaPropertyStorage_GetCount(This,pulNumProps)	\
    ( (This)->lpVtbl -> GetCount(This,pulNumProps) ) 

#define IWiaPropertyStorage_GetPropertyStream(This,pCompatibilityId,ppIStream)	\
    ( (This)->lpVtbl -> GetPropertyStream(This,pCompatibilityId,ppIStream) ) 

#define IWiaPropertyStorage_SetPropertyStream(This,pCompatibilityId,pIStream)	\
    ( (This)->lpVtbl -> SetPropertyStream(This,pCompatibilityId,pIStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_RemoteWriteMultiple_Proxy( 
    __RPC__in IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC *rgpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT *rgpropvar,
    /* [in] */ PROPID propidNameFirst);


void __RPC_STUB IWiaPropertyStorage_RemoteWriteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_RemoteSetPropertyStream_Proxy( 
    __RPC__in IWiaPropertyStorage * This,
    /* [in] */ __RPC__in GUID *pCompatibilityId,
    /* [unique][in] */ __RPC__in_opt IStream *pIStream);


void __RPC_STUB IWiaPropertyStorage_RemoteSetPropertyStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IEnumWiaItem_INTERFACE_DEFINED__
#define __IEnumWiaItem_INTERFACE_DEFINED__

/* interface IEnumWiaItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWiaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e8383fc-3391-11d2-9a33-00c04fa36145")
    IEnumWiaItem : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWiaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWiaItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWiaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWiaItem * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWiaItem * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWiaItem * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWiaItem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWiaItem * This,
            /* [out] */ __RPC__out ULONG *celt);
        
        END_INTERFACE
    } IEnumWiaItemVtbl;

    interface IEnumWiaItem
    {
        CONST_VTBL struct IEnumWiaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWiaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWiaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWiaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWiaItem_Next(This,celt,ppIWiaItem,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppIWiaItem,pceltFetched) ) 

#define IEnumWiaItem_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWiaItem_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWiaItem_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWiaItem_GetCount(This,celt)	\
    ( (This)->lpVtbl -> GetCount(This,celt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_RemoteNext_Proxy( 
    __RPC__in IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWiaItem_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWiaItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_xp_0000_0008 */
/* [local] */ 

typedef struct _WIA_DEV_CAP
    {
    GUID guid;
    ULONG ulFlags;
    BSTR bstrName;
    BSTR bstrDescription;
    BSTR bstrIcon;
    BSTR bstrCommandline;
    } 	WIA_DEV_CAP;

typedef struct _WIA_DEV_CAP *PWIA_DEV_CAP;

typedef struct _WIA_DEV_CAP WIA_EVENT_HANDLER;

typedef struct _WIA_DEV_CAP *PWIA_EVENT_HANDLER;



extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_xp_0000_0008_v0_0_s_ifspec;

#ifndef __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__
#define __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__

/* interface IEnumWIA_DEV_CAPS */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_DEV_CAPS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1fcc4287-aca6-11d2-a093-00c04f72dc3c")
    IEnumWIA_DEV_CAPS : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_DEV_CAPSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWIA_DEV_CAPS * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWIA_DEV_CAPS * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWIA_DEV_CAPS * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_DEV_CAPS * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWIA_DEV_CAPS * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWIA_DEV_CAPS * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWIA_DEV_CAPS * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWIA_DEV_CAPS * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumWIA_DEV_CAPSVtbl;

    interface IEnumWIA_DEV_CAPS
    {
        CONST_VTBL struct IEnumWIA_DEV_CAPSVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_DEV_CAPS_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_DEV_CAPS_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_DEV_CAPS_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_DEV_CAPS_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_DEV_CAPS_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_DEV_CAPS_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_DEV_CAPS_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_DEV_CAPS_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_RemoteNext_Proxy( 
    __RPC__in IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_DEV_CAPS_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__ */


#ifndef __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__
#define __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__

/* interface IEnumWIA_FORMAT_INFO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_FORMAT_INFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81BEFC5B-656D-44f1-B24C-D41D51B4DC81")
    IEnumWIA_FORMAT_INFO : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_FORMAT_INFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumWIA_FORMAT_INFOVtbl;

    interface IEnumWIA_FORMAT_INFO
    {
        CONST_VTBL struct IEnumWIA_FORMAT_INFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_FORMAT_INFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_FORMAT_INFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_FORMAT_INFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_FORMAT_INFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_FORMAT_INFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_FORMAT_INFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_FORMAT_INFO_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_FORMAT_INFO_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_RemoteNext_Proxy( 
    __RPC__in IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_FORMAT_INFO_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__ */


#ifndef __IWiaLog_INTERFACE_DEFINED__
#define __IWiaLog_INTERFACE_DEFINED__

/* interface IWiaLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A00C10B6-82A1-452f-8B6C-86062AAD6890")
    IWiaLog : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeLog( 
            /* [in] */ LONG hInstance) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResult( 
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaLog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaLog * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeLog )( 
            __RPC__in IWiaLog * This,
            /* [in] */ LONG hInstance);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResult )( 
            __RPC__in IWiaLog * This,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Log )( 
            __RPC__in IWiaLog * This,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        END_INTERFACE
    } IWiaLogVtbl;

    interface IWiaLog
    {
        CONST_VTBL struct IWiaLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaLog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaLog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaLog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaLog_InitializeLog(This,hInstance)	\
    ( (This)->lpVtbl -> InitializeLog(This,hInstance) ) 

#define IWiaLog_hResult(This,hResult)	\
    ( (This)->lpVtbl -> hResult(This,hResult) ) 

#define IWiaLog_Log(This,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> Log(This,lFlags,lResID,lDetail,bstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaLog_INTERFACE_DEFINED__ */


#ifndef __IWiaLogEx_INTERFACE_DEFINED__
#define __IWiaLogEx_INTERFACE_DEFINED__

/* interface IWiaLogEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaLogEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF1F22AC-7A40-4787-B421-AEb47A1FBD0B")
    IWiaLogEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeLogEx( 
            /* [in] */ __RPC__in BYTE *hInstance) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResult( 
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResultEx( 
            /* [in] */ LONG lMethodId,
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogEx( 
            /* [in] */ LONG lMethodId,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaLogExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaLogEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaLogEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeLogEx )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ __RPC__in BYTE *hInstance);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResult )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Log )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResultEx )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ LONG lMethodId,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogEx )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ LONG lMethodId,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        END_INTERFACE
    } IWiaLogExVtbl;

    interface IWiaLogEx
    {
        CONST_VTBL struct IWiaLogExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaLogEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaLogEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaLogEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaLogEx_InitializeLogEx(This,hInstance)	\
    ( (This)->lpVtbl -> InitializeLogEx(This,hInstance) ) 

#define IWiaLogEx_hResult(This,hResult)	\
    ( (This)->lpVtbl -> hResult(This,hResult) ) 

#define IWiaLogEx_Log(This,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> Log(This,lFlags,lResID,lDetail,bstrText) ) 

#define IWiaLogEx_hResultEx(This,lMethodId,hResult)	\
    ( (This)->lpVtbl -> hResultEx(This,lMethodId,hResult) ) 

#define IWiaLogEx_LogEx(This,lMethodId,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> LogEx(This,lMethodId,lFlags,lResID,lDetail,bstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaLogEx_INTERFACE_DEFINED__ */


#ifndef __IWiaNotifyDevMgr_INTERFACE_DEFINED__
#define __IWiaNotifyDevMgr_INTERFACE_DEFINED__

/* interface IWiaNotifyDevMgr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaNotifyDevMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70681EA0-E7BF-4291-9FB1-4E8813A3F78E")
    IWiaNotifyDevMgr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewDeviceArrival( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaNotifyDevMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaNotifyDevMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaNotifyDevMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaNotifyDevMgr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NewDeviceArrival )( 
            __RPC__in IWiaNotifyDevMgr * This);
        
        END_INTERFACE
    } IWiaNotifyDevMgrVtbl;

    interface IWiaNotifyDevMgr
    {
        CONST_VTBL struct IWiaNotifyDevMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaNotifyDevMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaNotifyDevMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaNotifyDevMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaNotifyDevMgr_NewDeviceArrival(This)	\
    ( (This)->lpVtbl -> NewDeviceArrival(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaNotifyDevMgr_INTERFACE_DEFINED__ */


#ifndef __IWiaItemExtras_INTERFACE_DEFINED__
#define __IWiaItemExtras_INTERFACE_DEFINED__

/* interface IWiaItemExtras */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItemExtras;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6291ef2c-36ef-4532-876a-8e132593778d")
    IWiaItemExtras : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedErrorInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrErrorText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ DWORD dwEscapeCode,
            /* [size_is][in] */ __RPC__in_ecount_full(cbInDataSize) BYTE *lpInData,
            /* [in] */ DWORD cbInDataSize,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutDataSize, pdwActualDataSize ? *pdwActualDataSize : dwOutDataSize) BYTE *pOutData,
            /* [in] */ DWORD dwOutDataSize,
            /* [out] */ __RPC__out DWORD *pdwActualDataSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CancelPendingIO( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItemExtrasVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaItemExtras * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaItemExtras * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaItemExtras * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedErrorInfo )( 
            __RPC__in IWiaItemExtras * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrErrorText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Escape )( 
            __RPC__in IWiaItemExtras * This,
            /* [in] */ DWORD dwEscapeCode,
            /* [size_is][in] */ __RPC__in_ecount_full(cbInDataSize) BYTE *lpInData,
            /* [in] */ DWORD cbInDataSize,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutDataSize, pdwActualDataSize ? *pdwActualDataSize : dwOutDataSize) BYTE *pOutData,
            /* [in] */ DWORD dwOutDataSize,
            /* [out] */ __RPC__out DWORD *pdwActualDataSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CancelPendingIO )( 
            __RPC__in IWiaItemExtras * This);
        
        END_INTERFACE
    } IWiaItemExtrasVtbl;

    interface IWiaItemExtras
    {
        CONST_VTBL struct IWiaItemExtrasVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItemExtras_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItemExtras_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItemExtras_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItemExtras_GetExtendedErrorInfo(This,bstrErrorText)	\
    ( (This)->lpVtbl -> GetExtendedErrorInfo(This,bstrErrorText) ) 

#define IWiaItemExtras_Escape(This,dwEscapeCode,lpInData,cbInDataSize,pOutData,dwOutDataSize,pdwActualDataSize)	\
    ( (This)->lpVtbl -> Escape(This,dwEscapeCode,lpInData,cbInDataSize,pOutData,dwOutDataSize,pdwActualDataSize) ) 

#define IWiaItemExtras_CancelPendingIO(This)	\
    ( (This)->lpVtbl -> CancelPendingIO(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaItemExtras_INTERFACE_DEFINED__ */



#ifndef __WiaDevMgr_LIBRARY_DEFINED__
#define __WiaDevMgr_LIBRARY_DEFINED__

/* library WiaDevMgr */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WiaDevMgr;

EXTERN_C const CLSID CLSID_WiaDevMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("a1f4e726-8cf1-11d1-bf92-0060081ed811")
WiaDevMgr;
#endif

EXTERN_C const CLSID CLSID_WiaLog;

#ifdef __cplusplus

class DECLSPEC_UUID("A1E75357-881A-419e-83E2-BB16DB197C68")
WiaLog;
#endif
#endif /* __WiaDevMgr_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree(     __RPC__in unsigned long *, __RPC__in STGMEDIUM * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree64(     __RPC__in unsigned long *, __RPC__in STGMEDIUM * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_CreateDevice_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ BSTR bstrDeviceID,
    /* [out] */ IWiaItem **ppWiaItemRoot);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_CreateDevice_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem **ppWiaItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ BSTR *pbstrDeviceID,
    /* [retval][out] */ IWiaItem **ppItemRoot);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlg_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem **ppItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlgID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ BSTR *pbstrDeviceID);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlgID_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_GetImageDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ IWiaItem *pItemRoot,
    /* [in] */ BSTR bstrFilename,
    /* [out][in] */ GUID *pguidFormat);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_GetImageDlg_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ __RPC__in_opt IWiaItem *pItemRoot,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out][in] */ __RPC__inout GUID *pguidFormat);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [in] */ BSTR bstrCommandline,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackProgram_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrCommandline,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ IUnknown **pEventObject);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackInterface_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ const GUID *pClsID,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackCLSID_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_Next_Proxy( 
    IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_Next_Stub( 
    __RPC__in IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_BandedDataCallback_Proxy( 
    IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [size_is][in] */ BYTE *pbBuffer);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_BandedDataCallback_Stub( 
    __RPC__in IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lResLength) BYTE *pbBuffer);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetData_Proxy( 
    IWiaDataTransfer * This,
    /* [out][in] */ LPSTGMEDIUM pMedium,
    /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetData_Stub( 
    __RPC__in IWiaDataTransfer * This,
    /* [out][in] */ __RPC__inout LPSTGMEDIUM pMedium,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedData_Proxy( 
    IWiaDataTransfer * This,
    /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedData_Stub( 
    __RPC__in IWiaDataTransfer * This,
    /* [unique][in] */ __RPC__in_opt PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem_DeviceDlg_Proxy( 
    IWiaItem * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ LONG *plItemCount,
    /* [out] */ IWiaItem ***ppIWiaItem);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem_DeviceDlg_Stub( 
    __RPC__in IWiaItem * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ __RPC__out LONG *plItemCount,
    /* [out] */ __RPC__deref_out_opt IWiaItem ***pIWiaItem);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_WriteMultiple_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC rgpspec[  ],
    /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
    /* [in] */ PROPID propidNameFirst);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_WriteMultiple_Stub( 
    __RPC__in IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC *rgpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT *rgpropvar,
    /* [in] */ PROPID propidNameFirst);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_SetPropertyStream_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ GUID *pCompatibilityId,
    /* [unique][in] */ IStream *pIStream);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_SetPropertyStream_Stub( 
    __RPC__in IWiaPropertyStorage * This,
    /* [in] */ __RPC__in GUID *pCompatibilityId,
    /* [unique][in] */ __RPC__in_opt IStream *pIStream);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_Next_Proxy( 
    IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_Next_Stub( 
    __RPC__in IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_Next_Proxy( 
    IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_Next_Stub( 
    __RPC__in IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_Next_Proxy( 
    IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_Next_Stub( 
    __RPC__in IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wia_lh.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wia_lh.idl, wia_lh.acf:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wia_lh_h__
#define __wia_lh_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWiaDevMgr_FWD_DEFINED__
#define __IWiaDevMgr_FWD_DEFINED__
typedef interface IWiaDevMgr IWiaDevMgr;
#endif 	/* __IWiaDevMgr_FWD_DEFINED__ */


#ifndef __IEnumWIA_DEV_INFO_FWD_DEFINED__
#define __IEnumWIA_DEV_INFO_FWD_DEFINED__
typedef interface IEnumWIA_DEV_INFO IEnumWIA_DEV_INFO;
#endif 	/* __IEnumWIA_DEV_INFO_FWD_DEFINED__ */


#ifndef __IWiaEventCallback_FWD_DEFINED__
#define __IWiaEventCallback_FWD_DEFINED__
typedef interface IWiaEventCallback IWiaEventCallback;
#endif 	/* __IWiaEventCallback_FWD_DEFINED__ */


#ifndef __IWiaDataCallback_FWD_DEFINED__
#define __IWiaDataCallback_FWD_DEFINED__
typedef interface IWiaDataCallback IWiaDataCallback;
#endif 	/* __IWiaDataCallback_FWD_DEFINED__ */


#ifndef __IWiaDataTransfer_FWD_DEFINED__
#define __IWiaDataTransfer_FWD_DEFINED__
typedef interface IWiaDataTransfer IWiaDataTransfer;
#endif 	/* __IWiaDataTransfer_FWD_DEFINED__ */


#ifndef __IWiaItem_FWD_DEFINED__
#define __IWiaItem_FWD_DEFINED__
typedef interface IWiaItem IWiaItem;
#endif 	/* __IWiaItem_FWD_DEFINED__ */


#ifndef __IWiaPropertyStorage_FWD_DEFINED__
#define __IWiaPropertyStorage_FWD_DEFINED__
typedef interface IWiaPropertyStorage IWiaPropertyStorage;
#endif 	/* __IWiaPropertyStorage_FWD_DEFINED__ */


#ifndef __IEnumWiaItem_FWD_DEFINED__
#define __IEnumWiaItem_FWD_DEFINED__
typedef interface IEnumWiaItem IEnumWiaItem;
#endif 	/* __IEnumWiaItem_FWD_DEFINED__ */


#ifndef __IEnumWIA_DEV_CAPS_FWD_DEFINED__
#define __IEnumWIA_DEV_CAPS_FWD_DEFINED__
typedef interface IEnumWIA_DEV_CAPS IEnumWIA_DEV_CAPS;
#endif 	/* __IEnumWIA_DEV_CAPS_FWD_DEFINED__ */


#ifndef __IEnumWIA_FORMAT_INFO_FWD_DEFINED__
#define __IEnumWIA_FORMAT_INFO_FWD_DEFINED__
typedef interface IEnumWIA_FORMAT_INFO IEnumWIA_FORMAT_INFO;
#endif 	/* __IEnumWIA_FORMAT_INFO_FWD_DEFINED__ */


#ifndef __IWiaLog_FWD_DEFINED__
#define __IWiaLog_FWD_DEFINED__
typedef interface IWiaLog IWiaLog;
#endif 	/* __IWiaLog_FWD_DEFINED__ */


#ifndef __IWiaLogEx_FWD_DEFINED__
#define __IWiaLogEx_FWD_DEFINED__
typedef interface IWiaLogEx IWiaLogEx;
#endif 	/* __IWiaLogEx_FWD_DEFINED__ */


#ifndef __IWiaNotifyDevMgr_FWD_DEFINED__
#define __IWiaNotifyDevMgr_FWD_DEFINED__
typedef interface IWiaNotifyDevMgr IWiaNotifyDevMgr;
#endif 	/* __IWiaNotifyDevMgr_FWD_DEFINED__ */


#ifndef __IWiaItemExtras_FWD_DEFINED__
#define __IWiaItemExtras_FWD_DEFINED__
typedef interface IWiaItemExtras IWiaItemExtras;
#endif 	/* __IWiaItemExtras_FWD_DEFINED__ */


#ifndef __IWiaAppErrorHandler_FWD_DEFINED__
#define __IWiaAppErrorHandler_FWD_DEFINED__
typedef interface IWiaAppErrorHandler IWiaAppErrorHandler;
#endif 	/* __IWiaAppErrorHandler_FWD_DEFINED__ */


#ifndef __IWiaErrorHandler_FWD_DEFINED__
#define __IWiaErrorHandler_FWD_DEFINED__
typedef interface IWiaErrorHandler IWiaErrorHandler;
#endif 	/* __IWiaErrorHandler_FWD_DEFINED__ */


#ifndef __IWiaTransfer_FWD_DEFINED__
#define __IWiaTransfer_FWD_DEFINED__
typedef interface IWiaTransfer IWiaTransfer;
#endif 	/* __IWiaTransfer_FWD_DEFINED__ */


#ifndef __IWiaTransferCallback_FWD_DEFINED__
#define __IWiaTransferCallback_FWD_DEFINED__
typedef interface IWiaTransferCallback IWiaTransferCallback;
#endif 	/* __IWiaTransferCallback_FWD_DEFINED__ */


#ifndef __IWiaSegmentationFilter_FWD_DEFINED__
#define __IWiaSegmentationFilter_FWD_DEFINED__
typedef interface IWiaSegmentationFilter IWiaSegmentationFilter;
#endif 	/* __IWiaSegmentationFilter_FWD_DEFINED__ */


#ifndef __IWiaImageFilter_FWD_DEFINED__
#define __IWiaImageFilter_FWD_DEFINED__
typedef interface IWiaImageFilter IWiaImageFilter;
#endif 	/* __IWiaImageFilter_FWD_DEFINED__ */


#ifndef __IWiaPreview_FWD_DEFINED__
#define __IWiaPreview_FWD_DEFINED__
typedef interface IWiaPreview IWiaPreview;
#endif 	/* __IWiaPreview_FWD_DEFINED__ */


#ifndef __IEnumWiaItem2_FWD_DEFINED__
#define __IEnumWiaItem2_FWD_DEFINED__
typedef interface IEnumWiaItem2 IEnumWiaItem2;
#endif 	/* __IEnumWiaItem2_FWD_DEFINED__ */


#ifndef __IWiaItem2_FWD_DEFINED__
#define __IWiaItem2_FWD_DEFINED__
typedef interface IWiaItem2 IWiaItem2;
#endif 	/* __IWiaItem2_FWD_DEFINED__ */


#ifndef __IWiaDevMgr2_FWD_DEFINED__
#define __IWiaDevMgr2_FWD_DEFINED__
typedef interface IWiaDevMgr2 IWiaDevMgr2;
#endif 	/* __IWiaDevMgr2_FWD_DEFINED__ */


#ifndef __WiaDevMgr_FWD_DEFINED__
#define __WiaDevMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaDevMgr WiaDevMgr;
#else
typedef struct WiaDevMgr WiaDevMgr;
#endif /* __cplusplus */

#endif 	/* __WiaDevMgr_FWD_DEFINED__ */


#ifndef __WiaDevMgr2_FWD_DEFINED__
#define __WiaDevMgr2_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaDevMgr2 WiaDevMgr2;
#else
typedef struct WiaDevMgr2 WiaDevMgr2;
#endif /* __cplusplus */

#endif 	/* __WiaDevMgr2_FWD_DEFINED__ */


#ifndef __WiaLog_FWD_DEFINED__
#define __WiaLog_FWD_DEFINED__

#ifdef __cplusplus
typedef class WiaLog WiaLog;
#else
typedef struct WiaLog WiaLog;
#endif /* __cplusplus */

#endif 	/* __WiaLog_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wia_lh_0000_0000 */
/* [local] */ 


















typedef struct _WIA_DITHER_PATTERN_DATA
    {
    LONG lSize;
    BSTR bstrPatternName;
    LONG lPatternWidth;
    LONG lPatternLength;
    LONG cbPattern;
    BYTE *pbPattern;
    } 	WIA_DITHER_PATTERN_DATA;

typedef struct _WIA_DITHER_PATTERN_DATA *PWIA_DITHER_PATTERN_DATA;

typedef struct _WIA_PROPID_TO_NAME
    {
    PROPID propid;
    LPOLESTR pszName;
    } 	WIA_PROPID_TO_NAME;

typedef struct _WIA_PROPID_TO_NAME *PWIA_PROPID_TO_NAME;

typedef struct _WIA_FORMAT_INFO
    {
    GUID guidFormatID;
    LONG lTymed;
    } 	WIA_FORMAT_INFO;

typedef struct _WIA_FORMAT_INFO *PWIA_FORMAT_INFO;

#include "wiadef.h"


extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0000_v0_0_s_ifspec;

#ifndef __IWiaDevMgr_INTERFACE_DEFINED__
#define __IWiaDevMgr_INTERFACE_DEFINED__

/* interface IWiaDevMgr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDevMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5eb2502a-8cf1-11d1-bf92-0060081ed811")
    IWiaDevMgr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceInfo( 
            /* [in] */ LONG lFlag,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateDevice( 
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem **ppWiaItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem **ppItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlgID( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetImageDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [in] */ IWiaItem *pItemRoot,
            /* [in] */ BSTR bstrFilename,
            /* [out][in] */ GUID *pguidFormat) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackProgram( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrCommandline,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackInterface( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackCLSID( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDeviceDlg( 
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDevMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaDevMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaDevMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaDevMgr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceInfo )( 
            __RPC__in IWiaDevMgr * This,
            /* [in] */ LONG lFlag,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateDevice )( 
            IWiaDevMgr * This,
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem **ppWiaItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlg )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem **ppItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlgID )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetImageDlg )( 
            IWiaDevMgr * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [in] */ IWiaItem *pItemRoot,
            /* [in] */ BSTR bstrFilename,
            /* [out][in] */ GUID *pguidFormat);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackProgram )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrCommandline,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackInterface )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackCLSID )( 
            IWiaDevMgr * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDeviceDlg )( 
            __RPC__in IWiaDevMgr * This,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IWiaDevMgrVtbl;

    interface IWiaDevMgr
    {
        CONST_VTBL struct IWiaDevMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDevMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDevMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDevMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDevMgr_EnumDeviceInfo(This,lFlag,ppIEnum)	\
    ( (This)->lpVtbl -> EnumDeviceInfo(This,lFlag,ppIEnum) ) 

#define IWiaDevMgr_CreateDevice(This,bstrDeviceID,ppWiaItemRoot)	\
    ( (This)->lpVtbl -> CreateDevice(This,bstrDeviceID,ppWiaItemRoot) ) 

#define IWiaDevMgr_SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot)	\
    ( (This)->lpVtbl -> SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot) ) 

#define IWiaDevMgr_SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID)	\
    ( (This)->lpVtbl -> SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID) ) 

#define IWiaDevMgr_GetImageDlg(This,hwndParent,lDeviceType,lFlags,lIntent,pItemRoot,bstrFilename,pguidFormat)	\
    ( (This)->lpVtbl -> GetImageDlg(This,hwndParent,lDeviceType,lFlags,lIntent,pItemRoot,bstrFilename,pguidFormat) ) 

#define IWiaDevMgr_RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrCommandline,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrCommandline,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr_RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject)	\
    ( (This)->lpVtbl -> RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject) ) 

#define IWiaDevMgr_RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr_AddDeviceDlg(This,hwndParent,lFlags)	\
    ( (This)->lpVtbl -> AddDeviceDlg(This,hwndParent,lFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalCreateDevice_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem **ppWiaItemRoot);


void __RPC_STUB IWiaDevMgr_LocalCreateDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalSelectDeviceDlg_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem **ppItemRoot);


void __RPC_STUB IWiaDevMgr_LocalSelectDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalSelectDeviceDlgID_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);


void __RPC_STUB IWiaDevMgr_LocalSelectDeviceDlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalGetImageDlg_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ __RPC__in_opt IWiaItem *pItemRoot,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out][in] */ __RPC__inout GUID *pguidFormat);


void __RPC_STUB IWiaDevMgr_LocalGetImageDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackProgram_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrCommandline,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackInterface_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_LocalRegisterEventCallbackCLSID_Proxy( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr_LocalRegisterEventCallbackCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDevMgr_INTERFACE_DEFINED__ */


#ifndef __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__
#define __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__

/* interface IEnumWIA_DEV_INFO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_DEV_INFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e38b83c-8cf1-11d1-bf92-0060081ed811")
    IEnumWIA_DEV_INFO : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_DEV_INFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWIA_DEV_INFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWIA_DEV_INFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWIA_DEV_INFO * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_DEV_INFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWIA_DEV_INFO * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWIA_DEV_INFO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWIA_DEV_INFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWIA_DEV_INFO * This,
            /* [out] */ __RPC__out ULONG *celt);
        
        END_INTERFACE
    } IEnumWIA_DEV_INFOVtbl;

    interface IEnumWIA_DEV_INFO
    {
        CONST_VTBL struct IEnumWIA_DEV_INFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_DEV_INFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_DEV_INFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_DEV_INFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_DEV_INFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_DEV_INFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_DEV_INFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_DEV_INFO_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_DEV_INFO_GetCount(This,celt)	\
    ( (This)->lpVtbl -> GetCount(This,celt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_RemoteNext_Proxy( 
    __RPC__in IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_DEV_INFO_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_DEV_INFO_INTERFACE_DEFINED__ */


#ifndef __IWiaEventCallback_INTERFACE_DEFINED__
#define __IWiaEventCallback_INTERFACE_DEFINED__

/* interface IWiaEventCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaEventCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae6287b0-0084-11d2-973b-00a0c9068f2e")
    IWiaEventCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ImageEventCallback( 
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrEventDescription,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrDeviceDescription,
            /* [in] */ DWORD dwDeviceType,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out][in] */ __RPC__inout ULONG *pulEventType,
            /* [in] */ ULONG ulReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaEventCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaEventCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaEventCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaEventCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ImageEventCallback )( 
            __RPC__in IWiaEventCallback * This,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [in] */ __RPC__in BSTR bstrEventDescription,
            /* [in] */ __RPC__in BSTR bstrDeviceID,
            /* [in] */ __RPC__in BSTR bstrDeviceDescription,
            /* [in] */ DWORD dwDeviceType,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out][in] */ __RPC__inout ULONG *pulEventType,
            /* [in] */ ULONG ulReserved);
        
        END_INTERFACE
    } IWiaEventCallbackVtbl;

    interface IWiaEventCallback
    {
        CONST_VTBL struct IWiaEventCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaEventCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaEventCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaEventCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaEventCallback_ImageEventCallback(This,pEventGUID,bstrEventDescription,bstrDeviceID,bstrDeviceDescription,dwDeviceType,bstrFullItemName,pulEventType,ulReserved)	\
    ( (This)->lpVtbl -> ImageEventCallback(This,pEventGUID,bstrEventDescription,bstrDeviceID,bstrDeviceDescription,dwDeviceType,bstrFullItemName,pulEventType,ulReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaEventCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_lh_0000_0003 */
/* [local] */ 

typedef struct _WIA_DATA_CALLBACK_HEADER
    {
    LONG lSize;
    GUID guidFormatID;
    LONG lBufferSize;
    LONG lPageCount;
    } 	WIA_DATA_CALLBACK_HEADER;

typedef struct _WIA_DATA_CALLBACK_HEADER *PWIA_DATA_CALLBACK_HEADER;



extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0003_v0_0_s_ifspec;

#ifndef __IWiaDataCallback_INTERFACE_DEFINED__
#define __IWiaDataCallback_INTERFACE_DEFINED__

/* interface IWiaDataCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDataCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a558a866-a5b0-11d2-a08f-00c04f72dc3c")
    IWiaDataCallback : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BandedDataCallback( 
            /* [in] */ LONG lMessage,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ LONG lReserved,
            /* [in] */ LONG lResLength,
            /* [size_is][in] */ BYTE *pbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDataCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaDataCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaDataCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaDataCallback * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BandedDataCallback )( 
            IWiaDataCallback * This,
            /* [in] */ LONG lMessage,
            /* [in] */ LONG lStatus,
            /* [in] */ LONG lPercentComplete,
            /* [in] */ LONG lOffset,
            /* [in] */ LONG lLength,
            /* [in] */ LONG lReserved,
            /* [in] */ LONG lResLength,
            /* [size_is][in] */ BYTE *pbBuffer);
        
        END_INTERFACE
    } IWiaDataCallbackVtbl;

    interface IWiaDataCallback
    {
        CONST_VTBL struct IWiaDataCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDataCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDataCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDataCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDataCallback_BandedDataCallback(This,lMessage,lStatus,lPercentComplete,lOffset,lLength,lReserved,lResLength,pbBuffer)	\
    ( (This)->lpVtbl -> BandedDataCallback(This,lMessage,lStatus,lPercentComplete,lOffset,lLength,lReserved,lResLength,pbBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_RemoteBandedDataCallback_Proxy( 
    __RPC__in IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lResLength) BYTE *pbBuffer);


void __RPC_STUB IWiaDataCallback_RemoteBandedDataCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDataCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_lh_0000_0004 */
/* [local] */ 

typedef struct _WIA_DATA_TRANSFER_INFO
    {
    ULONG ulSize;
    ULONG ulSection;
    ULONG ulBufferSize;
    BOOL bDoubleBuffer;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulReserved3;
    } 	WIA_DATA_TRANSFER_INFO;

typedef struct _WIA_DATA_TRANSFER_INFO *PWIA_DATA_TRANSFER_INFO;

typedef struct _WIA_EXTENDED_TRANSFER_INFO
    {
    ULONG ulSize;
    ULONG ulMinBufferSize;
    ULONG ulOptimalBufferSize;
    ULONG ulMaxBufferSize;
    ULONG ulNumBuffers;
    } 	WIA_EXTENDED_TRANSFER_INFO;

typedef struct _WIA_EXTENDED_TRANSFER_INFO *PWIA_EXTENDED_TRANSFER_INFO;



extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0004_v0_0_s_ifspec;

#ifndef __IWiaDataTransfer_INTERFACE_DEFINED__
#define __IWiaDataTransfer_INTERFACE_DEFINED__

/* interface IWiaDataTransfer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDataTransfer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6cef998-a5b0-11d2-a08f-00c04f72dc3c")
    IWiaDataTransfer : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE idtGetData( 
            /* [out][in] */ LPSTGMEDIUM pMedium,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE idtGetBandedData( 
            /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtQueryGetData( 
            /* [unique][in] */ __RPC__in_opt WIA_FORMAT_INFO *pfe) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtEnumWIA_FORMAT_INFO( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE idtGetExtendedTransferInfo( 
            /* [out] */ __RPC__out PWIA_EXTENDED_TRANSFER_INFO pExtendedTransferInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDataTransferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaDataTransfer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaDataTransfer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaDataTransfer * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *idtGetData )( 
            IWiaDataTransfer * This,
            /* [out][in] */ LPSTGMEDIUM pMedium,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *idtGetBandedData )( 
            IWiaDataTransfer * This,
            /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
            /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtQueryGetData )( 
            __RPC__in IWiaDataTransfer * This,
            /* [unique][in] */ __RPC__in_opt WIA_FORMAT_INFO *pfe);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtEnumWIA_FORMAT_INFO )( 
            __RPC__in IWiaDataTransfer * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *idtGetExtendedTransferInfo )( 
            __RPC__in IWiaDataTransfer * This,
            /* [out] */ __RPC__out PWIA_EXTENDED_TRANSFER_INFO pExtendedTransferInfo);
        
        END_INTERFACE
    } IWiaDataTransferVtbl;

    interface IWiaDataTransfer
    {
        CONST_VTBL struct IWiaDataTransferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDataTransfer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDataTransfer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDataTransfer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDataTransfer_idtGetData(This,pMedium,pIWiaDataCallback)	\
    ( (This)->lpVtbl -> idtGetData(This,pMedium,pIWiaDataCallback) ) 

#define IWiaDataTransfer_idtGetBandedData(This,pWiaDataTransInfo,pIWiaDataCallback)	\
    ( (This)->lpVtbl -> idtGetBandedData(This,pWiaDataTransInfo,pIWiaDataCallback) ) 

#define IWiaDataTransfer_idtQueryGetData(This,pfe)	\
    ( (This)->lpVtbl -> idtQueryGetData(This,pfe) ) 

#define IWiaDataTransfer_idtEnumWIA_FORMAT_INFO(This,ppEnum)	\
    ( (This)->lpVtbl -> idtEnumWIA_FORMAT_INFO(This,ppEnum) ) 

#define IWiaDataTransfer_idtGetExtendedTransferInfo(This,pExtendedTransferInfo)	\
    ( (This)->lpVtbl -> idtGetExtendedTransferInfo(This,pExtendedTransferInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetDataEx_Proxy( 
    __RPC__in IWiaDataTransfer * This,
    /* [out][in] */ __RPC__inout LPSTGMEDIUM pMedium,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);


void __RPC_STUB IWiaDataTransfer_idtGetDataEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedDataEx_Proxy( 
    __RPC__in IWiaDataTransfer * This,
    /* [unique][in] */ __RPC__in_opt PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);


void __RPC_STUB IWiaDataTransfer_idtGetBandedDataEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDataTransfer_INTERFACE_DEFINED__ */


#ifndef __IWiaItem_INTERFACE_DEFINED__
#define __IWiaItem_INTERFACE_DEFINED__

/* interface IWiaItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4db1ad10-3391-11d2-9a33-00c04fa36145")
    IWiaItem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemType( 
            /* [out] */ __RPC__out LONG *pItemType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AnalyzeItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumChildItems( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnumWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateChildItem( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumRegisterEventInfo( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByName( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [out] */ LONG *plItemCount,
            /* [out] */ IWiaItem ***ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeviceCommand( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem **pIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRootItem( 
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceCapabilities( 
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpDrvItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DumpTreeItemData( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Diagnostic( 
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaItem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__out LONG *pItemType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AnalyzeItem )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumChildItems )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnumWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateChildItem )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumRegisterEventInfo )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindItemByName )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DeviceDlg )( 
            IWiaItem * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lIntent,
            /* [out] */ LONG *plItemCount,
            /* [out] */ IWiaItem ***ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeviceCommand )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem **pIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRootItem )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IWiaItem **ppIWiaItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceCapabilities )( 
            __RPC__in IWiaItem * This,
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpItemData )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpDrvItemData )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DumpTreeItemData )( 
            __RPC__in IWiaItem * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Diagnostic )( 
            __RPC__in IWiaItem * This,
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer);
        
        END_INTERFACE
    } IWiaItemVtbl;

    interface IWiaItem
    {
        CONST_VTBL struct IWiaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItem_GetItemType(This,pItemType)	\
    ( (This)->lpVtbl -> GetItemType(This,pItemType) ) 

#define IWiaItem_AnalyzeItem(This,lFlags)	\
    ( (This)->lpVtbl -> AnalyzeItem(This,lFlags) ) 

#define IWiaItem_EnumChildItems(This,ppIEnumWiaItem)	\
    ( (This)->lpVtbl -> EnumChildItems(This,ppIEnumWiaItem) ) 

#define IWiaItem_DeleteItem(This,lFlags)	\
    ( (This)->lpVtbl -> DeleteItem(This,lFlags) ) 

#define IWiaItem_CreateChildItem(This,lFlags,bstrItemName,bstrFullItemName,ppIWiaItem)	\
    ( (This)->lpVtbl -> CreateChildItem(This,lFlags,bstrItemName,bstrFullItemName,ppIWiaItem) ) 

#define IWiaItem_EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum)	\
    ( (This)->lpVtbl -> EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum) ) 

#define IWiaItem_FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem)	\
    ( (This)->lpVtbl -> FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem) ) 

#define IWiaItem_DeviceDlg(This,hwndParent,lFlags,lIntent,plItemCount,ppIWiaItem)	\
    ( (This)->lpVtbl -> DeviceDlg(This,hwndParent,lFlags,lIntent,plItemCount,ppIWiaItem) ) 

#define IWiaItem_DeviceCommand(This,lFlags,pCmdGUID,pIWiaItem)	\
    ( (This)->lpVtbl -> DeviceCommand(This,lFlags,pCmdGUID,pIWiaItem) ) 

#define IWiaItem_GetRootItem(This,ppIWiaItem)	\
    ( (This)->lpVtbl -> GetRootItem(This,ppIWiaItem) ) 

#define IWiaItem_EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS)	\
    ( (This)->lpVtbl -> EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS) ) 

#define IWiaItem_DumpItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpItemData(This,bstrData) ) 

#define IWiaItem_DumpDrvItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpDrvItemData(This,bstrData) ) 

#define IWiaItem_DumpTreeItemData(This,bstrData)	\
    ( (This)->lpVtbl -> DumpTreeItemData(This,bstrData) ) 

#define IWiaItem_Diagnostic(This,ulSize,pBuffer)	\
    ( (This)->lpVtbl -> Diagnostic(This,ulSize,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem_LocalDeviceDlg_Proxy( 
    __RPC__in IWiaItem * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ __RPC__out LONG *plItemCount,
    /* [out] */ __RPC__deref_out_opt IWiaItem ***pIWiaItem);


void __RPC_STUB IWiaItem_LocalDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaItem_INTERFACE_DEFINED__ */


#ifndef __IWiaPropertyStorage_INTERFACE_DEFINED__
#define __IWiaPropertyStorage_INTERFACE_DEFINED__

/* interface IWiaPropertyStorage */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98B5E8A0-29CC-491a-AAC0-E6DB4FDCCEB6")
    IWiaPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ __RPC__in REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyAttributes( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) ULONG rgflags[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pulNumProps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyStream( 
            /* [out] */ __RPC__out GUID *pCompatibilityId,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetPropertyStream( 
            /* [in] */ GUID *pCompatibilityId,
            /* [unique][in] */ IStream *pIStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaPropertyStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMultiple )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WriteMultiple )( 
            IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMultiple )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC rgpspec[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyNames )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpropid) LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyNames )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const LPOLESTR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DeletePropertyNames )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ __RPC__in_ecount_full(cpropid) const PROPID rgpropid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            __RPC__in IWiaPropertyStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATPROPSTG **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimes )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ __RPC__in const FILETIME *pctime,
            /* [in] */ __RPC__in const FILETIME *patime,
            /* [in] */ __RPC__in const FILETIME *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE *SetClass )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ __RPC__in REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [out] */ __RPC__out STATPROPSETSTG *pstatpsstg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyAttributes )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ __RPC__in_ecount_full(cpspec) PROPSPEC rgpspec[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) ULONG rgflags[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(cpspec) PROPVARIANT rgpropvar[  ]);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [out] */ __RPC__out ULONG *pulNumProps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyStream )( 
            __RPC__in IWiaPropertyStorage * This,
            /* [out] */ __RPC__out GUID *pCompatibilityId,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetPropertyStream )( 
            IWiaPropertyStorage * This,
            /* [in] */ GUID *pCompatibilityId,
            /* [unique][in] */ IStream *pIStream);
        
        END_INTERFACE
    } IWiaPropertyStorageVtbl;

    interface IWiaPropertyStorage
    {
        CONST_VTBL struct IWiaPropertyStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaPropertyStorage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaPropertyStorage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgpropvar)	\
    ( (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgpropvar) ) 

#define IWiaPropertyStorage_WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)	\
    ( (This)->lpVtbl -> WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst) ) 

#define IWiaPropertyStorage_DeleteMultiple(This,cpspec,rgpspec)	\
    ( (This)->lpVtbl -> DeleteMultiple(This,cpspec,rgpspec) ) 

#define IWiaPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IWiaPropertyStorage_WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    ( (This)->lpVtbl -> WritePropertyNames(This,cpropid,rgpropid,rglpwstrName) ) 

#define IWiaPropertyStorage_DeletePropertyNames(This,cpropid,rgpropid)	\
    ( (This)->lpVtbl -> DeletePropertyNames(This,cpropid,rgpropid) ) 

#define IWiaPropertyStorage_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IWiaPropertyStorage_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IWiaPropertyStorage_Enum(This,ppenum)	\
    ( (This)->lpVtbl -> Enum(This,ppenum) ) 

#define IWiaPropertyStorage_SetTimes(This,pctime,patime,pmtime)	\
    ( (This)->lpVtbl -> SetTimes(This,pctime,patime,pmtime) ) 

#define IWiaPropertyStorage_SetClass(This,clsid)	\
    ( (This)->lpVtbl -> SetClass(This,clsid) ) 

#define IWiaPropertyStorage_Stat(This,pstatpsstg)	\
    ( (This)->lpVtbl -> Stat(This,pstatpsstg) ) 

#define IWiaPropertyStorage_GetPropertyAttributes(This,cpspec,rgpspec,rgflags,rgpropvar)	\
    ( (This)->lpVtbl -> GetPropertyAttributes(This,cpspec,rgpspec,rgflags,rgpropvar) ) 

#define IWiaPropertyStorage_GetCount(This,pulNumProps)	\
    ( (This)->lpVtbl -> GetCount(This,pulNumProps) ) 

#define IWiaPropertyStorage_GetPropertyStream(This,pCompatibilityId,ppIStream)	\
    ( (This)->lpVtbl -> GetPropertyStream(This,pCompatibilityId,ppIStream) ) 

#define IWiaPropertyStorage_SetPropertyStream(This,pCompatibilityId,pIStream)	\
    ( (This)->lpVtbl -> SetPropertyStream(This,pCompatibilityId,pIStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_RemoteWriteMultiple_Proxy( 
    __RPC__in IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC *rgpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT *rgpropvar,
    /* [in] */ PROPID propidNameFirst);


void __RPC_STUB IWiaPropertyStorage_RemoteWriteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_RemoteSetPropertyStream_Proxy( 
    __RPC__in IWiaPropertyStorage * This,
    /* [in] */ __RPC__in GUID *pCompatibilityId,
    /* [unique][in] */ __RPC__in_opt IStream *pIStream);


void __RPC_STUB IWiaPropertyStorage_RemoteSetPropertyStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IEnumWiaItem_INTERFACE_DEFINED__
#define __IEnumWiaItem_INTERFACE_DEFINED__

/* interface IEnumWiaItem */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWiaItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e8383fc-3391-11d2-9a33-00c04fa36145")
    IEnumWiaItem : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *celt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWiaItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWiaItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWiaItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWiaItem * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWiaItem * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWiaItem * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWiaItem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWiaItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWiaItem * This,
            /* [out] */ __RPC__out ULONG *celt);
        
        END_INTERFACE
    } IEnumWiaItemVtbl;

    interface IEnumWiaItem
    {
        CONST_VTBL struct IEnumWiaItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWiaItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWiaItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWiaItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWiaItem_Next(This,celt,ppIWiaItem,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppIWiaItem,pceltFetched) ) 

#define IEnumWiaItem_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWiaItem_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWiaItem_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWiaItem_GetCount(This,celt)	\
    ( (This)->lpVtbl -> GetCount(This,celt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_RemoteNext_Proxy( 
    __RPC__in IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWiaItem_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWiaItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_lh_0000_0008 */
/* [local] */ 

typedef struct _WIA_DEV_CAP
    {
    GUID guid;
    ULONG ulFlags;
    BSTR bstrName;
    BSTR bstrDescription;
    BSTR bstrIcon;
    BSTR bstrCommandline;
    } 	WIA_DEV_CAP;

typedef struct _WIA_DEV_CAP *PWIA_DEV_CAP;

typedef struct _WIA_DEV_CAP WIA_EVENT_HANDLER;

typedef struct _WIA_DEV_CAP *PWIA_EVENT_HANDLER;



extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0008_v0_0_s_ifspec;

#ifndef __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__
#define __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__

/* interface IEnumWIA_DEV_CAPS */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_DEV_CAPS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1fcc4287-aca6-11d2-a093-00c04f72dc3c")
    IEnumWIA_DEV_CAPS : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_DEV_CAPSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWIA_DEV_CAPS * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWIA_DEV_CAPS * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWIA_DEV_CAPS * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_DEV_CAPS * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWIA_DEV_CAPS * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWIA_DEV_CAPS * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWIA_DEV_CAPS * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWIA_DEV_CAPS * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumWIA_DEV_CAPSVtbl;

    interface IEnumWIA_DEV_CAPS
    {
        CONST_VTBL struct IEnumWIA_DEV_CAPSVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_DEV_CAPS_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_DEV_CAPS_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_DEV_CAPS_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_DEV_CAPS_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_DEV_CAPS_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_DEV_CAPS_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_DEV_CAPS_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_DEV_CAPS_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_RemoteNext_Proxy( 
    __RPC__in IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_DEV_CAPS_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_DEV_CAPS_INTERFACE_DEFINED__ */


#ifndef __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__
#define __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__

/* interface IEnumWIA_FORMAT_INFO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWIA_FORMAT_INFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81BEFC5B-656D-44f1-B24C-D41D51B4DC81")
    IEnumWIA_FORMAT_INFO : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWIA_FORMAT_INFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWIA_FORMAT_INFO * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWIA_FORMAT_INFO * This,
            /* [out] */ __RPC__out ULONG *pcelt);
        
        END_INTERFACE
    } IEnumWIA_FORMAT_INFOVtbl;

    interface IEnumWIA_FORMAT_INFO
    {
        CONST_VTBL struct IEnumWIA_FORMAT_INFOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWIA_FORMAT_INFO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWIA_FORMAT_INFO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWIA_FORMAT_INFO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWIA_FORMAT_INFO_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumWIA_FORMAT_INFO_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumWIA_FORMAT_INFO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWIA_FORMAT_INFO_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWIA_FORMAT_INFO_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_RemoteNext_Proxy( 
    __RPC__in IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumWIA_FORMAT_INFO_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWIA_FORMAT_INFO_INTERFACE_DEFINED__ */


#ifndef __IWiaLog_INTERFACE_DEFINED__
#define __IWiaLog_INTERFACE_DEFINED__

/* interface IWiaLog */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A00C10B6-82A1-452f-8B6C-86062AAD6890")
    IWiaLog : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeLog( 
            /* [in] */ LONG hInstance) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResult( 
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaLog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaLog * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeLog )( 
            __RPC__in IWiaLog * This,
            /* [in] */ LONG hInstance);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResult )( 
            __RPC__in IWiaLog * This,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Log )( 
            __RPC__in IWiaLog * This,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        END_INTERFACE
    } IWiaLogVtbl;

    interface IWiaLog
    {
        CONST_VTBL struct IWiaLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaLog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaLog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaLog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaLog_InitializeLog(This,hInstance)	\
    ( (This)->lpVtbl -> InitializeLog(This,hInstance) ) 

#define IWiaLog_hResult(This,hResult)	\
    ( (This)->lpVtbl -> hResult(This,hResult) ) 

#define IWiaLog_Log(This,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> Log(This,lFlags,lResID,lDetail,bstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaLog_INTERFACE_DEFINED__ */


#ifndef __IWiaLogEx_INTERFACE_DEFINED__
#define __IWiaLogEx_INTERFACE_DEFINED__

/* interface IWiaLogEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaLogEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF1F22AC-7A40-4787-B421-AEb47A1FBD0B")
    IWiaLogEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeLogEx( 
            /* [in] */ __RPC__in BYTE *hInstance) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResult( 
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE hResultEx( 
            /* [in] */ LONG lMethodId,
            /* [in] */ HRESULT hResult) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogEx( 
            /* [in] */ LONG lMethodId,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaLogExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaLogEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaLogEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeLogEx )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ __RPC__in BYTE *hInstance);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResult )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Log )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *hResultEx )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ LONG lMethodId,
            /* [in] */ HRESULT hResult);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogEx )( 
            __RPC__in IWiaLogEx * This,
            /* [in] */ LONG lMethodId,
            /* [in] */ LONG lFlags,
            /* [in] */ LONG lResID,
            /* [in] */ LONG lDetail,
            /* [in] */ __RPC__in BSTR bstrText);
        
        END_INTERFACE
    } IWiaLogExVtbl;

    interface IWiaLogEx
    {
        CONST_VTBL struct IWiaLogExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaLogEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaLogEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaLogEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaLogEx_InitializeLogEx(This,hInstance)	\
    ( (This)->lpVtbl -> InitializeLogEx(This,hInstance) ) 

#define IWiaLogEx_hResult(This,hResult)	\
    ( (This)->lpVtbl -> hResult(This,hResult) ) 

#define IWiaLogEx_Log(This,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> Log(This,lFlags,lResID,lDetail,bstrText) ) 

#define IWiaLogEx_hResultEx(This,lMethodId,hResult)	\
    ( (This)->lpVtbl -> hResultEx(This,lMethodId,hResult) ) 

#define IWiaLogEx_LogEx(This,lMethodId,lFlags,lResID,lDetail,bstrText)	\
    ( (This)->lpVtbl -> LogEx(This,lMethodId,lFlags,lResID,lDetail,bstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaLogEx_INTERFACE_DEFINED__ */


#ifndef __IWiaNotifyDevMgr_INTERFACE_DEFINED__
#define __IWiaNotifyDevMgr_INTERFACE_DEFINED__

/* interface IWiaNotifyDevMgr */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaNotifyDevMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70681EA0-E7BF-4291-9FB1-4E8813A3F78E")
    IWiaNotifyDevMgr : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewDeviceArrival( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaNotifyDevMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaNotifyDevMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaNotifyDevMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaNotifyDevMgr * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NewDeviceArrival )( 
            __RPC__in IWiaNotifyDevMgr * This);
        
        END_INTERFACE
    } IWiaNotifyDevMgrVtbl;

    interface IWiaNotifyDevMgr
    {
        CONST_VTBL struct IWiaNotifyDevMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaNotifyDevMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaNotifyDevMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaNotifyDevMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaNotifyDevMgr_NewDeviceArrival(This)	\
    ( (This)->lpVtbl -> NewDeviceArrival(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaNotifyDevMgr_INTERFACE_DEFINED__ */


#ifndef __IWiaItemExtras_INTERFACE_DEFINED__
#define __IWiaItemExtras_INTERFACE_DEFINED__

/* interface IWiaItemExtras */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItemExtras;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6291ef2c-36ef-4532-876a-8e132593778d")
    IWiaItemExtras : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtendedErrorInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *bstrErrorText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ DWORD dwEscapeCode,
            /* [size_is][in] */ __RPC__in_ecount_full(cbInDataSize) BYTE *lpInData,
            /* [in] */ DWORD cbInDataSize,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutDataSize, pdwActualDataSize ? *pdwActualDataSize : dwOutDataSize) BYTE *pOutData,
            /* [in] */ DWORD dwOutDataSize,
            /* [out] */ __RPC__out DWORD *pdwActualDataSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CancelPendingIO( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItemExtrasVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaItemExtras * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaItemExtras * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaItemExtras * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtendedErrorInfo )( 
            __RPC__in IWiaItemExtras * This,
            /* [out] */ __RPC__deref_out_opt BSTR *bstrErrorText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Escape )( 
            __RPC__in IWiaItemExtras * This,
            /* [in] */ DWORD dwEscapeCode,
            /* [size_is][in] */ __RPC__in_ecount_full(cbInDataSize) BYTE *lpInData,
            /* [in] */ DWORD cbInDataSize,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutDataSize, pdwActualDataSize ? *pdwActualDataSize : dwOutDataSize) BYTE *pOutData,
            /* [in] */ DWORD dwOutDataSize,
            /* [out] */ __RPC__out DWORD *pdwActualDataSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CancelPendingIO )( 
            __RPC__in IWiaItemExtras * This);
        
        END_INTERFACE
    } IWiaItemExtrasVtbl;

    interface IWiaItemExtras
    {
        CONST_VTBL struct IWiaItemExtrasVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItemExtras_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItemExtras_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItemExtras_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItemExtras_GetExtendedErrorInfo(This,bstrErrorText)	\
    ( (This)->lpVtbl -> GetExtendedErrorInfo(This,bstrErrorText) ) 

#define IWiaItemExtras_Escape(This,dwEscapeCode,lpInData,cbInDataSize,pOutData,dwOutDataSize,pdwActualDataSize)	\
    ( (This)->lpVtbl -> Escape(This,dwEscapeCode,lpInData,cbInDataSize,pOutData,dwOutDataSize,pdwActualDataSize) ) 

#define IWiaItemExtras_CancelPendingIO(This)	\
    ( (This)->lpVtbl -> CancelPendingIO(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaItemExtras_INTERFACE_DEFINED__ */


#ifndef __IWiaAppErrorHandler_INTERFACE_DEFINED__
#define __IWiaAppErrorHandler_INTERFACE_DEFINED__

/* interface IWiaAppErrorHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaAppErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6C16186C-D0A6-400c-80F4-D26986A0E734")
    IWiaAppErrorHandler : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReportStatus( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LONG lPercentComplete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaAppErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaAppErrorHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaAppErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaAppErrorHandler * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            __RPC__in IWiaAppErrorHandler * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReportStatus )( 
            __RPC__in IWiaAppErrorHandler * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LONG lPercentComplete);
        
        END_INTERFACE
    } IWiaAppErrorHandlerVtbl;

    interface IWiaAppErrorHandler
    {
        CONST_VTBL struct IWiaAppErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaAppErrorHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaAppErrorHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaAppErrorHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaAppErrorHandler_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IWiaAppErrorHandler_ReportStatus(This,lFlags,pWiaItem2,hrStatus,lPercentComplete)	\
    ( (This)->lpVtbl -> ReportStatus(This,lFlags,pWiaItem2,hrStatus,lPercentComplete) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaAppErrorHandler_INTERFACE_DEFINED__ */


#ifndef __IWiaErrorHandler_INTERFACE_DEFINED__
#define __IWiaErrorHandler_INTERFACE_DEFINED__

/* interface IWiaErrorHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0e4a51b1-bc1f-443d-a835-72e890759ef3")
    IWiaErrorHandler : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReportStatus( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LONG lPercentComplete) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStatusDescription( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaErrorHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaErrorHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaErrorHandler * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReportStatus )( 
            __RPC__in IWiaErrorHandler * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in HWND hwndParent,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LONG lPercentComplete);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStatusDescription )( 
            __RPC__in IWiaErrorHandler * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ HRESULT hrStatus,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription);
        
        END_INTERFACE
    } IWiaErrorHandlerVtbl;

    interface IWiaErrorHandler
    {
        CONST_VTBL struct IWiaErrorHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaErrorHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaErrorHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaErrorHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaErrorHandler_ReportStatus(This,lFlags,hwndParent,pWiaItem2,hrStatus,lPercentComplete)	\
    ( (This)->lpVtbl -> ReportStatus(This,lFlags,hwndParent,pWiaItem2,hrStatus,lPercentComplete) ) 

#define IWiaErrorHandler_GetStatusDescription(This,lFlags,pWiaItem2,hrStatus,pbstrDescription)	\
    ( (This)->lpVtbl -> GetStatusDescription(This,lFlags,pWiaItem2,hrStatus,pbstrDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaErrorHandler_INTERFACE_DEFINED__ */


#ifndef __IWiaTransfer_INTERFACE_DEFINED__
#define __IWiaTransfer_INTERFACE_DEFINED__

/* interface IWiaTransfer */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaTransfer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c39d6942-2f4e-4d04-92fe-4ef4d3a1de5a")
    IWiaTransfer : public IUnknown
    {
    public:
        virtual /* [helpstring][local] */ HRESULT STDMETHODCALLTYPE Download( 
            /* [in] */ LONG lFlags,
            /* [in] */ IWiaTransferCallback *pIWiaTransferCallback) = 0;
        
        virtual /* [helpstring][local] */ HRESULT STDMETHODCALLTYPE Upload( 
            /* [in] */ LONG lFlags,
            /* [in] */ IStream *pSource,
            /* [in] */ IWiaTransferCallback *pIWiaTransferCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumWIA_FORMAT_INFO( 
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaTransferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaTransfer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaTransfer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaTransfer * This);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Download )( 
            IWiaTransfer * This,
            /* [in] */ LONG lFlags,
            /* [in] */ IWiaTransferCallback *pIWiaTransferCallback);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Upload )( 
            IWiaTransfer * This,
            /* [in] */ LONG lFlags,
            /* [in] */ IStream *pSource,
            /* [in] */ IWiaTransferCallback *pIWiaTransferCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IWiaTransfer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumWIA_FORMAT_INFO )( 
            __RPC__in IWiaTransfer * This,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_FORMAT_INFO **ppEnum);
        
        END_INTERFACE
    } IWiaTransferVtbl;

    interface IWiaTransfer
    {
        CONST_VTBL struct IWiaTransferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaTransfer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaTransfer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaTransfer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaTransfer_Download(This,lFlags,pIWiaTransferCallback)	\
    ( (This)->lpVtbl -> Download(This,lFlags,pIWiaTransferCallback) ) 

#define IWiaTransfer_Upload(This,lFlags,pSource,pIWiaTransferCallback)	\
    ( (This)->lpVtbl -> Upload(This,lFlags,pSource,pIWiaTransferCallback) ) 

#define IWiaTransfer_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IWiaTransfer_EnumWIA_FORMAT_INFO(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumWIA_FORMAT_INFO(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_RemoteDownload_Proxy( 
    __RPC__in IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in_opt IWiaTransferCallback *pIWiaTransferCallback);


void __RPC_STUB IWiaTransfer_RemoteDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_RemoteUpload_Proxy( 
    __RPC__in IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in_opt IStream *pSource,
    /* [in] */ __RPC__in_opt IWiaTransferCallback *pIWiaTransferCallback);


void __RPC_STUB IWiaTransfer_RemoteUpload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaTransfer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wia_lh_0000_0017 */
/* [local] */ 

typedef struct _WiaTransferParams
    {
    LONG lMessage;
    LONG lPercentComplete;
    ULONG64 ulTransferredBytes;
    HRESULT hrErrorStatus;
    } 	WiaTransferParams;



extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wia_lh_0000_0017_v0_0_s_ifspec;

#ifndef __IWiaTransferCallback_INTERFACE_DEFINED__
#define __IWiaTransferCallback_INTERFACE_DEFINED__

/* interface IWiaTransferCallback */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaTransferCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27d4eaaf-28a6-4ca5-9aab-e678168b9527")
    IWiaTransferCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TransferCallback( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in WiaTransferParams *pWiaTransferParams) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextStream( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IStream **ppDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaTransferCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaTransferCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaTransferCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaTransferCallback * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *TransferCallback )( 
            __RPC__in IWiaTransferCallback * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in WiaTransferParams *pWiaTransferParams);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetNextStream )( 
            __RPC__in IWiaTransferCallback * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IStream **ppDestination);
        
        END_INTERFACE
    } IWiaTransferCallbackVtbl;

    interface IWiaTransferCallback
    {
        CONST_VTBL struct IWiaTransferCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaTransferCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaTransferCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaTransferCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaTransferCallback_TransferCallback(This,lFlags,pWiaTransferParams)	\
    ( (This)->lpVtbl -> TransferCallback(This,lFlags,pWiaTransferParams) ) 

#define IWiaTransferCallback_GetNextStream(This,lFlags,bstrItemName,bstrFullItemName,ppDestination)	\
    ( (This)->lpVtbl -> GetNextStream(This,lFlags,bstrItemName,bstrFullItemName,ppDestination) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaTransferCallback_INTERFACE_DEFINED__ */


#ifndef __IWiaSegmentationFilter_INTERFACE_DEFINED__
#define __IWiaSegmentationFilter_INTERFACE_DEFINED__

/* interface IWiaSegmentationFilter */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaSegmentationFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC46A697-AC04-4447-8F65-FF63D5154B21")
    IWiaSegmentationFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DetectRegions( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IStream *pInputStream,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaSegmentationFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaSegmentationFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaSegmentationFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaSegmentationFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DetectRegions )( 
            __RPC__in IWiaSegmentationFilter * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IStream *pInputStream,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2);
        
        END_INTERFACE
    } IWiaSegmentationFilterVtbl;

    interface IWiaSegmentationFilter
    {
        CONST_VTBL struct IWiaSegmentationFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaSegmentationFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaSegmentationFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaSegmentationFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaSegmentationFilter_DetectRegions(This,lFlags,pInputStream,pWiaItem2)	\
    ( (This)->lpVtbl -> DetectRegions(This,lFlags,pInputStream,pWiaItem2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaSegmentationFilter_INTERFACE_DEFINED__ */


#ifndef __IWiaImageFilter_INTERFACE_DEFINED__
#define __IWiaImageFilter_INTERFACE_DEFINED__

/* interface IWiaImageFilter */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaImageFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A8A79FFA-450B-41f1-8F87-849CCD94EBF6")
    IWiaImageFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFilter( 
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNewCallback( 
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterPreviewImage( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaChildItem2,
            /* [in] */ RECT InputImageExtents,
            /* [in] */ __RPC__in_opt IStream *pInputStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyProperties( 
            /* [in] */ __RPC__in_opt IWiaPropertyStorage *pWiaPropertyStorage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaImageFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaImageFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaImageFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaImageFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFilter )( 
            __RPC__in IWiaImageFilter * This,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback);
        
        HRESULT ( STDMETHODCALLTYPE *SetNewCallback )( 
            __RPC__in IWiaImageFilter * This,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback);
        
        HRESULT ( STDMETHODCALLTYPE *FilterPreviewImage )( 
            __RPC__in IWiaImageFilter * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaChildItem2,
            /* [in] */ RECT InputImageExtents,
            /* [in] */ __RPC__in_opt IStream *pInputStream);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyProperties )( 
            __RPC__in IWiaImageFilter * This,
            /* [in] */ __RPC__in_opt IWiaPropertyStorage *pWiaPropertyStorage);
        
        END_INTERFACE
    } IWiaImageFilterVtbl;

    interface IWiaImageFilter
    {
        CONST_VTBL struct IWiaImageFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaImageFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaImageFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaImageFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaImageFilter_InitializeFilter(This,pWiaItem2,pWiaTransferCallback)	\
    ( (This)->lpVtbl -> InitializeFilter(This,pWiaItem2,pWiaTransferCallback) ) 

#define IWiaImageFilter_SetNewCallback(This,pWiaTransferCallback)	\
    ( (This)->lpVtbl -> SetNewCallback(This,pWiaTransferCallback) ) 

#define IWiaImageFilter_FilterPreviewImage(This,lFlags,pWiaChildItem2,InputImageExtents,pInputStream)	\
    ( (This)->lpVtbl -> FilterPreviewImage(This,lFlags,pWiaChildItem2,InputImageExtents,pInputStream) ) 

#define IWiaImageFilter_ApplyProperties(This,pWiaPropertyStorage)	\
    ( (This)->lpVtbl -> ApplyProperties(This,pWiaPropertyStorage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaImageFilter_INTERFACE_DEFINED__ */


#ifndef __IWiaPreview_INTERFACE_DEFINED__
#define __IWiaPreview_INTERFACE_DEFINED__

/* interface IWiaPreview */
/* [helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaPreview;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95C2B4FD-33F2-4d86-AD40-9431F0DF08F7")
    IWiaPreview : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNewPreview( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdatePreview( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pChildWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetectRegions( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaPreviewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaPreview * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaPreview * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaPreview * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNewPreview )( 
            __RPC__in IWiaPreview * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback);
        
        HRESULT ( STDMETHODCALLTYPE *UpdatePreview )( 
            __RPC__in IWiaPreview * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in_opt IWiaItem2 *pChildWiaItem2,
            /* [in] */ __RPC__in_opt IWiaTransferCallback *pWiaTransferCallback);
        
        HRESULT ( STDMETHODCALLTYPE *DetectRegions )( 
            __RPC__in IWiaPreview * This,
            /* [in] */ LONG lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            __RPC__in IWiaPreview * This);
        
        END_INTERFACE
    } IWiaPreviewVtbl;

    interface IWiaPreview
    {
        CONST_VTBL struct IWiaPreviewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaPreview_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaPreview_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaPreview_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaPreview_GetNewPreview(This,lFlags,pWiaItem2,pWiaTransferCallback)	\
    ( (This)->lpVtbl -> GetNewPreview(This,lFlags,pWiaItem2,pWiaTransferCallback) ) 

#define IWiaPreview_UpdatePreview(This,lFlags,pChildWiaItem2,pWiaTransferCallback)	\
    ( (This)->lpVtbl -> UpdatePreview(This,lFlags,pChildWiaItem2,pWiaTransferCallback) ) 

#define IWiaPreview_DetectRegions(This,lFlags)	\
    ( (This)->lpVtbl -> DetectRegions(This,lFlags) ) 

#define IWiaPreview_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWiaPreview_INTERFACE_DEFINED__ */


#ifndef __IEnumWiaItem2_INTERFACE_DEFINED__
#define __IEnumWiaItem2_INTERFACE_DEFINED__

/* interface IEnumWiaItem2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumWiaItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59970AF4-CD0D-44d9-AB24-52295630E582")
    IEnumWiaItem2 : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IWiaItem2 **ppIWiaItem2,
            /* [unique][out][in] */ ULONG *pcEltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem2 **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *cElt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWiaItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumWiaItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumWiaItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumWiaItem2 * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWiaItem2 * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ IWiaItem2 **ppIWiaItem2,
            /* [unique][out][in] */ ULONG *pcEltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumWiaItem2 * This,
            /* [in] */ ULONG cElt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumWiaItem2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumWiaItem2 * This,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem2 **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumWiaItem2 * This,
            /* [out] */ __RPC__out ULONG *cElt);
        
        END_INTERFACE
    } IEnumWiaItem2Vtbl;

    interface IEnumWiaItem2
    {
        CONST_VTBL struct IEnumWiaItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWiaItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumWiaItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumWiaItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumWiaItem2_Next(This,cElt,ppIWiaItem2,pcEltFetched)	\
    ( (This)->lpVtbl -> Next(This,cElt,ppIWiaItem2,pcEltFetched) ) 

#define IEnumWiaItem2_Skip(This,cElt)	\
    ( (This)->lpVtbl -> Skip(This,cElt) ) 

#define IEnumWiaItem2_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumWiaItem2_Clone(This,ppIEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnum) ) 

#define IEnumWiaItem2_GetCount(This,cElt)	\
    ( (This)->lpVtbl -> GetCount(This,cElt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem2_RemoteNext_Proxy( 
    __RPC__in IEnumWiaItem2 * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cElt, *pcEltFetched) IWiaItem2 **ppIWiaItem2,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pcEltFetched);


void __RPC_STUB IEnumWiaItem2_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWiaItem2_INTERFACE_DEFINED__ */


#ifndef __IWiaItem2_INTERFACE_DEFINED__
#define __IWiaItem2_INTERFACE_DEFINED__

/* interface IWiaItem2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CBA0075-1287-407d-9B77-CF0E030435CC")
    IWiaItem2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateChildItem( 
            /* [in] */ LONG lItemFlags,
            /* [in] */ LONG lCreationFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ LONG lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumChildItems( 
            /* [unique][in] */ __RPC__in_opt const GUID *pCategoryGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem2 **ppIEnumWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByName( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemCategory( 
            /* [out] */ __RPC__out GUID *pItemCategoryGUID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItemType( 
            /* [out] */ __RPC__out LONG *pItemType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DeviceDlg( 
            /* [annotation][in] */ 
            __in  LONG lFlags,
            /* [annotation][in] */ 
            __in  HWND hwndParent,
            /* [annotation][in] */ 
            __in  BSTR bstrFolderName,
            /* [annotation][in] */ 
            __in  BSTR bstrFilename,
            /* [annotation][out] */ 
            __out  LONG *plNumFiles,
            /* [annotation][size_is][size_is][out] */ 
            __deref_out_ecount(*plNumFiles)  BSTR **ppbstrFilePaths,
            /* [annotation][out][in] */ 
            __out_opt  IWiaItem2 **ppItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeviceCommand( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceCapabilities( 
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CheckExtension( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrName,
            /* [in] */ REFIID riidExtensionInterface,
            /* [out] */ BOOL *pbExtensionExists) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetExtension( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrName,
            /* [in] */ REFIID riidExtensionInterface,
            /* [iid_is][out] */ void **ppOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetParentItem( 
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRootItem( 
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPreviewComponent( 
            /* [in] */ LONG lFlags,
            /* [out] */ IWiaPreview **ppWiaPreview) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumRegisterEventInfo( 
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Diagnostic( 
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaItem2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateChildItem )( 
            __RPC__in IWiaItem2 * This,
            /* [in] */ LONG lItemFlags,
            /* [in] */ LONG lCreationFlags,
            /* [in] */ __RPC__in BSTR bstrItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            __RPC__in IWiaItem2 * This,
            /* [in] */ LONG lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumChildItems )( 
            __RPC__in IWiaItem2 * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pCategoryGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWiaItem2 **ppIEnumWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindItemByName )( 
            __RPC__in IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in BSTR bstrFullItemName,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetItemCategory )( 
            __RPC__in IWiaItem2 * This,
            /* [out] */ __RPC__out GUID *pItemCategoryGUID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            __RPC__in IWiaItem2 * This,
            /* [out] */ __RPC__out LONG *pItemType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DeviceDlg )( 
            IWiaItem2 * This,
            /* [annotation][in] */ 
            __in  LONG lFlags,
            /* [annotation][in] */ 
            __in  HWND hwndParent,
            /* [annotation][in] */ 
            __in  BSTR bstrFolderName,
            /* [annotation][in] */ 
            __in  BSTR bstrFilename,
            /* [annotation][out] */ 
            __out  LONG *plNumFiles,
            /* [annotation][size_is][size_is][out] */ 
            __deref_out_ecount(*plNumFiles)  BSTR **ppbstrFilePaths,
            /* [annotation][out][in] */ 
            __out_opt  IWiaItem2 **ppItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeviceCommand )( 
            __RPC__in IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pCmdGUID,
            /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppIWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceCapabilities )( 
            __RPC__in IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnumWIA_DEV_CAPS);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CheckExtension )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrName,
            /* [in] */ REFIID riidExtensionInterface,
            /* [out] */ BOOL *pbExtensionExists);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetExtension )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrName,
            /* [in] */ REFIID riidExtensionInterface,
            /* [iid_is][out] */ void **ppOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetParentItem )( 
            __RPC__in IWiaItem2 * This,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRootItem )( 
            __RPC__in IWiaItem2 * This,
            /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppIWiaItem2);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetPreviewComponent )( 
            IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [out] */ IWiaPreview **ppWiaPreview);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumRegisterEventInfo )( 
            __RPC__in IWiaItem2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ __RPC__in const GUID *pEventGUID,
            /* [out] */ __RPC__deref_out_opt IEnumWIA_DEV_CAPS **ppIEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Diagnostic )( 
            __RPC__in IWiaItem2 * This,
            /* [in] */ ULONG ulSize,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pBuffer);
        
        END_INTERFACE
    } IWiaItem2Vtbl;

    interface IWiaItem2
    {
        CONST_VTBL struct IWiaItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaItem2_CreateChildItem(This,lItemFlags,lCreationFlags,bstrItemName,ppIWiaItem2)	\
    ( (This)->lpVtbl -> CreateChildItem(This,lItemFlags,lCreationFlags,bstrItemName,ppIWiaItem2) ) 

#define IWiaItem2_DeleteItem(This,lFlags)	\
    ( (This)->lpVtbl -> DeleteItem(This,lFlags) ) 

#define IWiaItem2_EnumChildItems(This,pCategoryGUID,ppIEnumWiaItem2)	\
    ( (This)->lpVtbl -> EnumChildItems(This,pCategoryGUID,ppIEnumWiaItem2) ) 

#define IWiaItem2_FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem2)	\
    ( (This)->lpVtbl -> FindItemByName(This,lFlags,bstrFullItemName,ppIWiaItem2) ) 

#define IWiaItem2_GetItemCategory(This,pItemCategoryGUID)	\
    ( (This)->lpVtbl -> GetItemCategory(This,pItemCategoryGUID) ) 

#define IWiaItem2_GetItemType(This,pItemType)	\
    ( (This)->lpVtbl -> GetItemType(This,pItemType) ) 

#define IWiaItem2_DeviceDlg(This,lFlags,hwndParent,bstrFolderName,bstrFilename,plNumFiles,ppbstrFilePaths,ppItem)	\
    ( (This)->lpVtbl -> DeviceDlg(This,lFlags,hwndParent,bstrFolderName,bstrFilename,plNumFiles,ppbstrFilePaths,ppItem) ) 

#define IWiaItem2_DeviceCommand(This,lFlags,pCmdGUID,ppIWiaItem2)	\
    ( (This)->lpVtbl -> DeviceCommand(This,lFlags,pCmdGUID,ppIWiaItem2) ) 

#define IWiaItem2_EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS)	\
    ( (This)->lpVtbl -> EnumDeviceCapabilities(This,lFlags,ppIEnumWIA_DEV_CAPS) ) 

#define IWiaItem2_CheckExtension(This,lFlags,bstrName,riidExtensionInterface,pbExtensionExists)	\
    ( (This)->lpVtbl -> CheckExtension(This,lFlags,bstrName,riidExtensionInterface,pbExtensionExists) ) 

#define IWiaItem2_GetExtension(This,lFlags,bstrName,riidExtensionInterface,ppOut)	\
    ( (This)->lpVtbl -> GetExtension(This,lFlags,bstrName,riidExtensionInterface,ppOut) ) 

#define IWiaItem2_GetParentItem(This,ppIWiaItem2)	\
    ( (This)->lpVtbl -> GetParentItem(This,ppIWiaItem2) ) 

#define IWiaItem2_GetRootItem(This,ppIWiaItem2)	\
    ( (This)->lpVtbl -> GetRootItem(This,ppIWiaItem2) ) 

#define IWiaItem2_GetPreviewComponent(This,lFlags,ppWiaPreview)	\
    ( (This)->lpVtbl -> GetPreviewComponent(This,lFlags,ppWiaPreview) ) 

#define IWiaItem2_EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum)	\
    ( (This)->lpVtbl -> EnumRegisterEventInfo(This,lFlags,pEventGUID,ppIEnum) ) 

#define IWiaItem2_Diagnostic(This,ulSize,pBuffer)	\
    ( (This)->lpVtbl -> Diagnostic(This,ulSize,pBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_LocalDeviceDlg_Proxy( 
    __RPC__in IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ __RPC__in BSTR bstrFolderName,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out] */ __RPC__out LONG *plNumFiles,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumFiles) BSTR **ppbstrFilePaths,
    /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppItem);


void __RPC_STUB IWiaItem2_LocalDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_RemoteCheckExtension_Proxy( 
    __RPC__in IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in REFIID riidExtensionInterface,
    /* [out] */ __RPC__out BOOL *pbExtensionExists);


void __RPC_STUB IWiaItem2_RemoteCheckExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_RemoteGetExtension_Proxy( 
    __RPC__in IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in REFIID riidExtensionInterface,
    /* [iid_is][out] */ __RPC__deref_out_opt void **ppOut);


void __RPC_STUB IWiaItem2_RemoteGetExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_RemoteGetPreviewComponent_Proxy( 
    __RPC__in IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [out] */ __RPC__deref_out_opt IWiaPreview **ppWiaPreview);


void __RPC_STUB IWiaItem2_RemoteGetPreviewComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaItem2_INTERFACE_DEFINED__ */


#ifndef __IWiaDevMgr2_INTERFACE_DEFINED__
#define __IWiaDevMgr2_INTERFACE_DEFINED__

/* interface IWiaDevMgr2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWiaDevMgr2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79C07CF1-CBDD-41ee-8EC3-F00080CADA7A")
    IWiaDevMgr2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDeviceInfo( 
            /* [in] */ LONG lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateDevice( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem2 **ppWiaItem2Root) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlg( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem2 **ppItemRoot) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SelectDeviceDlgID( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackInterface( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackProgram( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrFullAppName,
            /* [in] */ BSTR bstrCommandLineArg,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterEventCallbackCLSID( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetImageDlg( 
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ HWND hwndParent,
            /* [in] */ BSTR bstrFolderName,
            /* [in] */ BSTR bstrFilename,
            /* [out] */ LONG *plNumFiles,
            /* [size_is][size_is][out] */ BSTR **ppbstrFilePaths,
            /* [out][in] */ IWiaItem2 **ppItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWiaDevMgr2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWiaDevMgr2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWiaDevMgr2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWiaDevMgr2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDeviceInfo )( 
            __RPC__in IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IEnumWIA_DEV_INFO **ppIEnum);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateDevice )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [out] */ IWiaItem2 **ppWiaItem2Root);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlg )( 
            IWiaDevMgr2 * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [out][in] */ BSTR *pbstrDeviceID,
            /* [retval][out] */ IWiaItem2 **ppItemRoot);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SelectDeviceDlgID )( 
            IWiaDevMgr2 * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LONG lDeviceType,
            /* [in] */ LONG lFlags,
            /* [retval][out] */ BSTR *pbstrDeviceID);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackInterface )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
            /* [out] */ IUnknown **pEventObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackProgram )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [in] */ BSTR bstrFullAppName,
            /* [in] */ BSTR bstrCommandLineArg,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterEventCallbackCLSID )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ const GUID *pEventGUID,
            /* [unique][in] */ const GUID *pClsID,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrDescription,
            /* [in] */ BSTR bstrIcon);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetImageDlg )( 
            IWiaDevMgr2 * This,
            /* [in] */ LONG lFlags,
            /* [in] */ BSTR bstrDeviceID,
            /* [in] */ HWND hwndParent,
            /* [in] */ BSTR bstrFolderName,
            /* [in] */ BSTR bstrFilename,
            /* [out] */ LONG *plNumFiles,
            /* [size_is][size_is][out] */ BSTR **ppbstrFilePaths,
            /* [out][in] */ IWiaItem2 **ppItem);
        
        END_INTERFACE
    } IWiaDevMgr2Vtbl;

    interface IWiaDevMgr2
    {
        CONST_VTBL struct IWiaDevMgr2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWiaDevMgr2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWiaDevMgr2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWiaDevMgr2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWiaDevMgr2_EnumDeviceInfo(This,lFlags,ppIEnum)	\
    ( (This)->lpVtbl -> EnumDeviceInfo(This,lFlags,ppIEnum) ) 

#define IWiaDevMgr2_CreateDevice(This,lFlags,bstrDeviceID,ppWiaItem2Root)	\
    ( (This)->lpVtbl -> CreateDevice(This,lFlags,bstrDeviceID,ppWiaItem2Root) ) 

#define IWiaDevMgr2_SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot)	\
    ( (This)->lpVtbl -> SelectDeviceDlg(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID,ppItemRoot) ) 

#define IWiaDevMgr2_SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID)	\
    ( (This)->lpVtbl -> SelectDeviceDlgID(This,hwndParent,lDeviceType,lFlags,pbstrDeviceID) ) 

#define IWiaDevMgr2_RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject)	\
    ( (This)->lpVtbl -> RegisterEventCallbackInterface(This,lFlags,bstrDeviceID,pEventGUID,pIWiaEventCallback,pEventObject) ) 

#define IWiaDevMgr2_RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrFullAppName,bstrCommandLineArg,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackProgram(This,lFlags,bstrDeviceID,pEventGUID,bstrFullAppName,bstrCommandLineArg,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr2_RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon)	\
    ( (This)->lpVtbl -> RegisterEventCallbackCLSID(This,lFlags,bstrDeviceID,pEventGUID,pClsID,bstrName,bstrDescription,bstrIcon) ) 

#define IWiaDevMgr2_GetImageDlg(This,lFlags,bstrDeviceID,hwndParent,bstrFolderName,bstrFilename,plNumFiles,ppbstrFilePaths,ppItem)	\
    ( (This)->lpVtbl -> GetImageDlg(This,lFlags,bstrDeviceID,hwndParent,bstrFolderName,bstrFilename,plNumFiles,ppbstrFilePaths,ppItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalCreateDevice_Proxy( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppWiaItem2Root);


void __RPC_STUB IWiaDevMgr2_LocalCreateDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalSelectDeviceDlg_Proxy( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem2 **ppItemRoot);


void __RPC_STUB IWiaDevMgr2_LocalSelectDeviceDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalSelectDeviceDlgID_Proxy( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);


void __RPC_STUB IWiaDevMgr2_LocalSelectDeviceDlgID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalRegisterEventCallbackInterface_Proxy( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);


void __RPC_STUB IWiaDevMgr2_LocalRegisterEventCallbackInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalRegisterEventCallbackProgram_Proxy( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrFullAppName,
    /* [in] */ __RPC__in BSTR bstrCommandLineArg,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr2_LocalRegisterEventCallbackProgram_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalRegisterEventCallbackCLSID_Proxy( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);


void __RPC_STUB IWiaDevMgr2_LocalRegisterEventCallbackCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_LocalGetImageDlg_Proxy( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ __RPC__in BSTR bstrFolderName,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out] */ __RPC__out LONG *plNumFiles,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumFiles) BSTR **ppbstrFilePaths,
    /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppItem);


void __RPC_STUB IWiaDevMgr2_LocalGetImageDlg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWiaDevMgr2_INTERFACE_DEFINED__ */



#ifndef __WiaDevMgr_LIBRARY_DEFINED__
#define __WiaDevMgr_LIBRARY_DEFINED__

/* library WiaDevMgr */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WiaDevMgr;

EXTERN_C const CLSID CLSID_WiaDevMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("a1f4e726-8cf1-11d1-bf92-0060081ed811")
WiaDevMgr;
#endif

EXTERN_C const CLSID CLSID_WiaDevMgr2;

#ifdef __cplusplus

class DECLSPEC_UUID("B6C292BC-7C88-41ee-8B54-8EC92617E599")
WiaDevMgr2;
#endif

EXTERN_C const CLSID CLSID_WiaLog;

#ifdef __cplusplus

class DECLSPEC_UUID("A1E75357-881A-419e-83E2-BB16DB197C68")
WiaLog;
#endif
#endif /* __WiaDevMgr_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree(     __RPC__in unsigned long *, __RPC__in STGMEDIUM * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  STGMEDIUM_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in STGMEDIUM * ); 
unsigned char * __RPC_USER  STGMEDIUM_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out STGMEDIUM * ); 
void                      __RPC_USER  STGMEDIUM_UserFree64(     __RPC__in unsigned long *, __RPC__in STGMEDIUM * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_CreateDevice_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ BSTR bstrDeviceID,
    /* [out] */ IWiaItem **ppWiaItemRoot);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_CreateDevice_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem **ppWiaItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ BSTR *pbstrDeviceID,
    /* [retval][out] */ IWiaItem **ppItemRoot);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlg_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem **ppItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlgID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ BSTR *pbstrDeviceID);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_SelectDeviceDlgID_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_GetImageDlg_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ IWiaItem *pItemRoot,
    /* [in] */ BSTR bstrFilename,
    /* [out][in] */ GUID *pguidFormat);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_GetImageDlg_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [in] */ __RPC__in_opt IWiaItem *pItemRoot,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out][in] */ __RPC__inout GUID *pguidFormat);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [in] */ BSTR bstrCommandline,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackProgram_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrCommandline,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ IUnknown **pEventObject);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackInterface_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ const GUID *pClsID,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr_RegisterEventCallbackCLSID_Stub( 
    __RPC__in IWiaDevMgr * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_Next_Proxy( 
    IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_INFO_Next_Stub( 
    __RPC__in IEnumWIA_DEV_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaPropertyStorage **rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_BandedDataCallback_Proxy( 
    IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [size_is][in] */ BYTE *pbBuffer);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataCallback_BandedDataCallback_Stub( 
    __RPC__in IWiaDataCallback * This,
    /* [in] */ LONG lMessage,
    /* [in] */ LONG lStatus,
    /* [in] */ LONG lPercentComplete,
    /* [in] */ LONG lOffset,
    /* [in] */ LONG lLength,
    /* [in] */ LONG lReserved,
    /* [in] */ LONG lResLength,
    /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lResLength) BYTE *pbBuffer);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetData_Proxy( 
    IWiaDataTransfer * This,
    /* [out][in] */ LPSTGMEDIUM pMedium,
    /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetData_Stub( 
    __RPC__in IWiaDataTransfer * This,
    /* [out][in] */ __RPC__inout LPSTGMEDIUM pMedium,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedData_Proxy( 
    IWiaDataTransfer * This,
    /* [unique][in] */ PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ IWiaDataCallback *pIWiaDataCallback);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDataTransfer_idtGetBandedData_Stub( 
    __RPC__in IWiaDataTransfer * This,
    /* [unique][in] */ __RPC__in_opt PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo,
    /* [unique][in] */ __RPC__in_opt IWiaDataCallback *pIWiaDataCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem_DeviceDlg_Proxy( 
    IWiaItem * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ LONG *plItemCount,
    /* [out] */ IWiaItem ***ppIWiaItem);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem_DeviceDlg_Stub( 
    __RPC__in IWiaItem * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lFlags,
    /* [in] */ LONG lIntent,
    /* [out] */ __RPC__out LONG *plItemCount,
    /* [out] */ __RPC__deref_out_opt IWiaItem ***pIWiaItem);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_WriteMultiple_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC rgpspec[  ],
    /* [size_is][in] */ const PROPVARIANT rgpropvar[  ],
    /* [in] */ PROPID propidNameFirst);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_WriteMultiple_Stub( 
    __RPC__in IWiaPropertyStorage * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPSPEC *rgpspec,
    /* [size_is][in] */ __RPC__in_ecount_full(cpspec) const PROPVARIANT *rgpropvar,
    /* [in] */ PROPID propidNameFirst);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_SetPropertyStream_Proxy( 
    IWiaPropertyStorage * This,
    /* [in] */ GUID *pCompatibilityId,
    /* [unique][in] */ IStream *pIStream);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaPropertyStorage_SetPropertyStream_Stub( 
    __RPC__in IWiaPropertyStorage * This,
    /* [in] */ __RPC__in GUID *pCompatibilityId,
    /* [unique][in] */ __RPC__in_opt IStream *pIStream);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_Next_Proxy( 
    IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem_Next_Stub( 
    __RPC__in IEnumWiaItem * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) IWiaItem **ppIWiaItem,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_Next_Proxy( 
    IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_DEV_CAPS_Next_Stub( 
    __RPC__in IEnumWIA_DEV_CAPS * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_DEV_CAP *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_Next_Proxy( 
    IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWIA_FORMAT_INFO_Next_Stub( 
    __RPC__in IEnumWIA_FORMAT_INFO * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) WIA_FORMAT_INFO *rgelt,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pceltFetched);

/* [helpstring][local] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_Download_Proxy( 
    IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ IWiaTransferCallback *pIWiaTransferCallback);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_Download_Stub( 
    __RPC__in IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in_opt IWiaTransferCallback *pIWiaTransferCallback);

/* [helpstring][local] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_Upload_Proxy( 
    IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ IStream *pSource,
    /* [in] */ IWiaTransferCallback *pIWiaTransferCallback);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWiaTransfer_Upload_Stub( 
    __RPC__in IWiaTransfer * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in_opt IStream *pSource,
    /* [in] */ __RPC__in_opt IWiaTransferCallback *pIWiaTransferCallback);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem2_Next_Proxy( 
    IEnumWiaItem2 * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ IWiaItem2 **ppIWiaItem2,
    /* [unique][out][in] */ ULONG *pcEltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumWiaItem2_Next_Stub( 
    __RPC__in IEnumWiaItem2 * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cElt, *pcEltFetched) IWiaItem2 **ppIWiaItem2,
    /* [unique][out][in] */ __RPC__inout_opt ULONG *pcEltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem2_DeviceDlg_Proxy( 
    IWiaItem2 * This,
    /* [annotation][in] */ 
    __in  LONG lFlags,
    /* [annotation][in] */ 
    __in  HWND hwndParent,
    /* [annotation][in] */ 
    __in  BSTR bstrFolderName,
    /* [annotation][in] */ 
    __in  BSTR bstrFilename,
    /* [annotation][out] */ 
    __out  LONG *plNumFiles,
    /* [annotation][size_is][size_is][out] */ 
    __deref_out_ecount(*plNumFiles)  BSTR **ppbstrFilePaths,
    /* [annotation][out][in] */ 
    __out_opt  IWiaItem2 **ppItem);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_DeviceDlg_Stub( 
    __RPC__in IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ __RPC__in BSTR bstrFolderName,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out] */ __RPC__out LONG *plNumFiles,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumFiles) BSTR **ppbstrFilePaths,
    /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppItem);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem2_CheckExtension_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrName,
    /* [in] */ REFIID riidExtensionInterface,
    /* [out] */ BOOL *pbExtensionExists);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_CheckExtension_Stub( 
    __RPC__in IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in REFIID riidExtensionInterface,
    /* [out] */ __RPC__out BOOL *pbExtensionExists);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem2_GetExtension_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrName,
    /* [in] */ REFIID riidExtensionInterface,
    /* [iid_is][out] */ void **ppOut);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_GetExtension_Stub( 
    __RPC__in IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in REFIID riidExtensionInterface,
    /* [iid_is][out] */ __RPC__deref_out_opt void **ppOut);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaItem2_GetPreviewComponent_Proxy( 
    IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [out] */ IWiaPreview **ppWiaPreview);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaItem2_GetPreviewComponent_Stub( 
    __RPC__in IWiaItem2 * This,
    /* [in] */ LONG lFlags,
    /* [out] */ __RPC__deref_out_opt IWiaPreview **ppWiaPreview);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_CreateDevice_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [out] */ IWiaItem2 **ppWiaItem2Root);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_CreateDevice_Stub( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [out] */ __RPC__deref_out_opt IWiaItem2 **ppWiaItem2Root);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_SelectDeviceDlg_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ BSTR *pbstrDeviceID,
    /* [retval][out] */ IWiaItem2 **ppItemRoot);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_SelectDeviceDlg_Stub( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrDeviceID,
    /* [retval][out] */ __RPC__deref_out_opt IWiaItem2 **ppItemRoot);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_SelectDeviceDlgID_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ BSTR *pbstrDeviceID);


/* [nocode][helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_SelectDeviceDlgID_Stub( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ LONG lDeviceType,
    /* [in] */ LONG lFlags,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceID);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackInterface_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ IUnknown **pEventObject);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackInterface_Stub( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt IWiaEventCallback *pIWiaEventCallback,
    /* [out] */ __RPC__deref_out_opt IUnknown **pEventObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackProgram_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [in] */ BSTR bstrFullAppName,
    /* [in] */ BSTR bstrCommandLineArg,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackProgram_Stub( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [in] */ __RPC__in BSTR bstrFullAppName,
    /* [in] */ __RPC__in BSTR bstrCommandLineArg,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackCLSID_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ const GUID *pEventGUID,
    /* [unique][in] */ const GUID *pClsID,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrDescription,
    /* [in] */ BSTR bstrIcon);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_RegisterEventCallbackCLSID_Stub( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in const GUID *pEventGUID,
    /* [unique][in] */ __RPC__in_opt const GUID *pClsID,
    /* [in] */ __RPC__in BSTR bstrName,
    /* [in] */ __RPC__in BSTR bstrDescription,
    /* [in] */ __RPC__in BSTR bstrIcon);

/* [local] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_GetImageDlg_Proxy( 
    IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ BSTR bstrDeviceID,
    /* [in] */ HWND hwndParent,
    /* [in] */ BSTR bstrFolderName,
    /* [in] */ BSTR bstrFilename,
    /* [out] */ LONG *plNumFiles,
    /* [size_is][size_is][out] */ BSTR **ppbstrFilePaths,
    /* [out][in] */ IWiaItem2 **ppItem);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IWiaDevMgr2_GetImageDlg_Stub( 
    __RPC__in IWiaDevMgr2 * This,
    /* [in] */ LONG lFlags,
    /* [in] */ __RPC__in BSTR bstrDeviceID,
    /* [in] */ __RPC__in HWND hwndParent,
    /* [in] */ __RPC__in BSTR bstrFolderName,
    /* [in] */ __RPC__in BSTR bstrFilename,
    /* [out] */ __RPC__out LONG *plNumFiles,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumFiles) BSTR **ppbstrFilePaths,
    /* [out][in] */ __RPC__deref_inout_opt IWiaItem2 **ppItem);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WiaDevD.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1998-2000, MICROSOFT CORP.
*
*  FILE:        wiadevd.h
*
*  VERSION:     1.0
*
*  DATE:        7/5/1999
*
*  DESCRIPTION:
*    Device Dialog and UI extensibility declarations.
*
*****************************************************************************/

#if (_WIN32_WINNT >= 0x0501) // Windows XP and later

#ifndef _WIADEVD_H_INCLUDED
#define _WIADEVD_H_INCLUDED

#include "wia.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include <pshpack8.h>

#if (_WIN32_WINNT >= 0x0600) // Windows Vista and later

#undef  INTERFACE
#define INTERFACE IWiaUIExtension2
typedef struct tagDEVICEDIALOGDATA2
{
    DWORD           cbSize;           // Size of the structure in bytes
    IWiaItem2       *pIWiaItemRoot;   // Valid root item
    DWORD           dwFlags;          // Flags
    HWND            hwndParent;       // Parent window
    BSTR            bstrFolderName;   // Folder name where the files are transferred
    BSTR            bstrFilename;     // template file name.
    LONG            lNumFiles;        // Number of items in ppbstrFilePaths array.  Filled on return.
    BSTR            *pbstrFilePaths;  // file names created after successful transfers.
    IWiaItem2       *pWiaItem;        // IWiaItem2 interface pointer.  This is the IWiaItem2 used for transfer.
} DEVICEDIALOGDATA2, *LPDEVICEDIALOGDATA2, *PDEVICEDIALOGDATA2;

DECLARE_INTERFACE_IID_(IWiaUIExtension2, IUnknown, "305600d7-5088-46d7-9a15-b77b09cdba7a")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (__in THIS_ REFIID riid, __deref_out LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaUIExtension2 methods ***
    STDMETHOD(DeviceDialog)(__in THIS_ PDEVICEDIALOGDATA2 pDeviceDialogData ) PURE;
    STDMETHOD(GetDeviceIcon)(__in THIS_ BSTR bstrDeviceId, __out HICON *phIcon, ULONG nSize) PURE;
};

// {305600d7-5088-46d7-9a15-b77b09cdba7a}
DEFINE_GUID(IID_IWiaUIExtension2, 0x305600D7, 0x5088, 0x46D7, 0x9A, 0x15, 0xB7, 0x7B, 0x09, 0xCD, 0xBA, 0x7A);

#endif //#if (_WIN32_WINNT >= 0x0600)

typedef struct tagDEVICEDIALOGDATA
{
    DWORD            cbSize;           // Size of the structure in bytes
    HWND             hwndParent;       // Parent window
    IWiaItem         *pIWiaItemRoot;   // Valid root item
    DWORD            dwFlags;          // Flags
    LONG             lIntent;          // Intent flags
    LONG             lItemCount;       // Number of items in ppWiaItems array.  Filled on return.
    IWiaItem         **ppWiaItems;     // Array of IWiaItem interface pointers.  Array must
                                       // be allocated using CoTaskMemAlloc, and all interface pointers must be AddRef'ed
} DEVICEDIALOGDATA, *LPDEVICEDIALOGDATA, *PDEVICEDIALOGDATA;

HRESULT WINAPI DeviceDialog(__in PDEVICEDIALOGDATA pDeviceDialogData);

// IWiaUIExtension provides a means to replace a device's image acquisition dialog
// and to provide custom icons and logo bitmaps to appear on the standard dialog
#undef  INTERFACE
#define INTERFACE IWiaUIExtension
DECLARE_INTERFACE_IID_(IWiaUIExtension, IUnknown, "da319113-50ee-4c80-b460-57d005d44a2c")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (__in THIS_ REFIID riid, __deref_out LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaUIExtension methods ***
    STDMETHOD(DeviceDialog)(__in THIS_ PDEVICEDIALOGDATA pDeviceDialogData) PURE;
    STDMETHOD(GetDeviceIcon)(__in THIS_ BSTR bstrDeviceId, __out HICON *phIcon, ULONG nSize) PURE;
    STDMETHOD(GetDeviceBitmapLogo)(__in THIS_ BSTR bstrDeviceId, __out HBITMAP *phBitmap, ULONG nMaxWidth, ULONG nMaxHeight) PURE;
};

// {da319113-50ee-4c80-b460-57d005d44a2c}
DEFINE_GUID(IID_IWiaUIExtension, 0xDA319113, 0x50EE, 0x4C80, 0xB4, 0x60, 0x57, 0xD0, 0x05, 0xD4, 0x4A, 0x2C);

typedef HRESULT (WINAPI *DeviceDialogFunction)(PDEVICEDIALOGDATA);

#define SHELLEX_WIAUIEXTENSION_NAME TEXT("WiaDialogExtensionHandlers")

// Define clipboard format names for retrieving data from an IDataObject
#define CFSTR_WIAITEMNAMES TEXT("WIAItemNames")
#define CFSTR_WIAITEMPTR   TEXT("WIAItemPointer")

#include <poppack.h>

#if defined(__cplusplus)
};
#endif

#endif // !_WIADEVD_H_INCLUDED

#endif //#if (_WIN32_WINNT >= 0x0501)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WiaDef.h ===
/****************************************************************************
*
*  (C) Copyright 1998-2003, Microsoft Corp.
*
*  File:    wiadef.h
*
*  Version: 3.0
*
*  Description: WIA constant definitions
*
*****************************************************************************/

#if (_WIN32_WINNT >= 0x0501) // Windows XP and later

#pragma once

#ifndef _WIADEF_
#define _WIADEF_


#include <pshpack8.h>
#ifndef _NO_COM
#include <objbase.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// WIA property ID and string constants
//

#define WIA_DIP_DEV_ID                             2 // 0x2
#define WIA_DIP_DEV_ID_STR                         L"Unique Device ID"

#define WIA_DIP_VEND_DESC                          3 // 0x3
#define WIA_DIP_VEND_DESC_STR                      L"Manufacturer"

#define WIA_DIP_DEV_DESC                           4 // 0x4
#define WIA_DIP_DEV_DESC_STR                       L"Description"

#define WIA_DIP_DEV_TYPE                           5 // 0x5
#define WIA_DIP_DEV_TYPE_STR                       L"Type"

#define WIA_DIP_PORT_NAME                          6 // 0x6
#define WIA_DIP_PORT_NAME_STR                      L"Port"

#define WIA_DIP_DEV_NAME                           7 // 0x7
#define WIA_DIP_DEV_NAME_STR                       L"Name"

#define WIA_DIP_SERVER_NAME                        8 // 0x8
#define WIA_DIP_SERVER_NAME_STR                    L"Server"

#define WIA_DIP_REMOTE_DEV_ID                      9 // 0x9
#define WIA_DIP_REMOTE_DEV_ID_STR                  L"Remote Device ID"

#define WIA_DIP_UI_CLSID                           10 // 0xa
#define WIA_DIP_UI_CLSID_STR                       L"UI Class ID"

#define WIA_DIP_HW_CONFIG                          11 // 0xb
#define WIA_DIP_HW_CONFIG_STR                      L"Hardware Configuration"

#define WIA_DIP_BAUDRATE                           12 // 0xc
#define WIA_DIP_BAUDRATE_STR                       L"BaudRate"

#define WIA_DIP_STI_GEN_CAPABILITIES               13 // 0xd
#define WIA_DIP_STI_GEN_CAPABILITIES_STR           L"STI Generic Capabilities"

#define WIA_DIP_WIA_VERSION                        14 // 0xe
#define WIA_DIP_WIA_VERSION_STR                    L"WIA Version"

#define WIA_DIP_DRIVER_VERSION                     15 // 0xf
#define WIA_DIP_DRIVER_VERSION_STR                 L"Driver Version"

#define WIA_DIP_PNP_ID                             16 // 0x10
#define WIA_DIP_PNP_ID_STR                         L"PnP ID String"

#define WIA_DIP_STI_DRIVER_VERSION                 17 // 0x11
#define WIA_DIP_STI_DRIVER_VERSION_STR             L"STI Driver Version"

#define WIA_DPA_FIRMWARE_VERSION                   1026 // 0x402
#define WIA_DPA_FIRMWARE_VERSION_STR               L"Firmware Version"

#define WIA_DPA_CONNECT_STATUS                     1027 // 0x403
#define WIA_DPA_CONNECT_STATUS_STR                 L"Connect Status"

#define WIA_DPA_DEVICE_TIME                        1028 // 0x404
#define WIA_DPA_DEVICE_TIME_STR                    L"Device Time"

#define WIA_DPC_PICTURES_TAKEN                     2050 // 0x802
#define WIA_DPC_PICTURES_TAKEN_STR                 L"Pictures Taken"

#define WIA_DPC_PICTURES_REMAINING                 2051 // 0x803
#define WIA_DPC_PICTURES_REMAINING_STR             L"Pictures Remaining"

#define WIA_DPC_EXPOSURE_MODE                      2052 // 0x804
#define WIA_DPC_EXPOSURE_MODE_STR                  L"Exposure Mode"

#define WIA_DPC_EXPOSURE_COMP                      2053 // 0x805
#define WIA_DPC_EXPOSURE_COMP_STR                  L"Exposure Compensation"

#define WIA_DPC_EXPOSURE_TIME                      2054 // 0x806
#define WIA_DPC_EXPOSURE_TIME_STR                  L"Exposure Time"

#define WIA_DPC_FNUMBER                            2055 // 0x807
#define WIA_DPC_FNUMBER_STR                        L"F Number"

#define WIA_DPC_FLASH_MODE                         2056 // 0x808
#define WIA_DPC_FLASH_MODE_STR                     L"Flash Mode"

#define WIA_DPC_FOCUS_MODE                         2057 // 0x809
#define WIA_DPC_FOCUS_MODE_STR                     L"Focus Mode"

#define WIA_DPC_FOCUS_MANUAL_DIST                  2058 // 0x80a
#define WIA_DPC_FOCUS_MANUAL_DIST_STR              L"Focus Manual Dist"

#define WIA_DPC_ZOOM_POSITION                      2059 // 0x80b
#define WIA_DPC_ZOOM_POSITION_STR                  L"Zoom Position"

#define WIA_DPC_PAN_POSITION                       2060 // 0x80c
#define WIA_DPC_PAN_POSITION_STR                   L"Pan Position"

#define WIA_DPC_TILT_POSITION                      2061 // 0x80d
#define WIA_DPC_TILT_POSITION_STR                  L"Tilt Position"

#define WIA_DPC_TIMER_MODE                         2062 // 0x80e
#define WIA_DPC_TIMER_MODE_STR                     L"Timer Mode"

#define WIA_DPC_TIMER_VALUE                        2063 // 0x80f
#define WIA_DPC_TIMER_VALUE_STR                    L"Timer Value"

#define WIA_DPC_POWER_MODE                         2064 // 0x810
#define WIA_DPC_POWER_MODE_STR                     L"Power Mode"

#define WIA_DPC_BATTERY_STATUS                     2065 // 0x811
#define WIA_DPC_BATTERY_STATUS_STR                 L"Battery Status"

#define WIA_DPC_THUMB_WIDTH                        2066 // 0x812
#define WIA_DPC_THUMB_WIDTH_STR                    L"Thumbnail Width"

#define WIA_DPC_THUMB_HEIGHT                       2067 // 0x813
#define WIA_DPC_THUMB_HEIGHT_STR                   L"Thumbnail Height"

#define WIA_DPC_PICT_WIDTH                         2068 // 0x814
#define WIA_DPC_PICT_WIDTH_STR                     L"Picture Width"

#define WIA_DPC_PICT_HEIGHT                        2069 // 0x815
#define WIA_DPC_PICT_HEIGHT_STR                    L"Picture Height"

#define WIA_DPC_DIMENSION                          2070 // 0x816
#define WIA_DPC_DIMENSION_STR                      L"Dimension"

#define WIA_DPC_COMPRESSION_SETTING                2071 // 0x817
#define WIA_DPC_COMPRESSION_SETTING_STR            L"Compression Setting"

#define WIA_DPC_FOCUS_METERING                     2072 // 0x818
#define WIA_DPC_FOCUS_METERING_STR                 L"Focus Metering Mode"

#define WIA_DPC_TIMELAPSE_INTERVAL                 2073 // 0x819
#define WIA_DPC_TIMELAPSE_INTERVAL_STR             L"Timelapse Interval"

#define WIA_DPC_TIMELAPSE_NUMBER                   2074 // 0x81a
#define WIA_DPC_TIMELAPSE_NUMBER_STR               L"Timelapse Number"

#define WIA_DPC_BURST_INTERVAL                     2075 // 0x81b
#define WIA_DPC_BURST_INTERVAL_STR                 L"Burst Interval"

#define WIA_DPC_BURST_NUMBER                       2076 // 0x81c
#define WIA_DPC_BURST_NUMBER_STR                   L"Burst Number"

#define WIA_DPC_EFFECT_MODE                        2077 // 0x81d
#define WIA_DPC_EFFECT_MODE_STR                    L"Effect Mode"

#define WIA_DPC_DIGITAL_ZOOM                       2078 // 0x81e
#define WIA_DPC_DIGITAL_ZOOM_STR                   L"Digital Zoom"

#define WIA_DPC_SHARPNESS                          2079 // 0x81f
#define WIA_DPC_SHARPNESS_STR                      L"Sharpness"

#define WIA_DPC_CONTRAST                           2080 // 0x820
#define WIA_DPC_CONTRAST_STR                       L"Contrast"

#define WIA_DPC_CAPTURE_MODE                       2081 // 0x821
#define WIA_DPC_CAPTURE_MODE_STR                   L"Capture Mode"

#define WIA_DPC_CAPTURE_DELAY                      2082 // 0x822
#define WIA_DPC_CAPTURE_DELAY_STR                  L"Capture Delay"

#define WIA_DPC_EXPOSURE_INDEX                     2083 // 0x823
#define WIA_DPC_EXPOSURE_INDEX_STR                 L"Exposure Index"

#define WIA_DPC_EXPOSURE_METERING_MODE             2084 // 0x824
#define WIA_DPC_EXPOSURE_METERING_MODE_STR         L"Exposure Metering Mode"

#define WIA_DPC_FOCUS_METERING_MODE                2085 // 0x825
#define WIA_DPC_FOCUS_METERING_MODE_STR            L"Focus Metering Mode"

#define WIA_DPC_FOCUS_DISTANCE                     2086 // 0x826
#define WIA_DPC_FOCUS_DISTANCE_STR                 L"Focus Distance"

#define WIA_DPC_FOCAL_LENGTH                       2087 // 0x827
#define WIA_DPC_FOCAL_LENGTH_STR                   L"Focus Length"

#define WIA_DPC_RGB_GAIN                           2088 // 0x828
#define WIA_DPC_RGB_GAIN_STR                       L"RGB Gain"

#define WIA_DPC_WHITE_BALANCE                      2089 // 0x829
#define WIA_DPC_WHITE_BALANCE_STR                  L"White Balance"

#define WIA_DPC_UPLOAD_URL                         2090 // 0x82a
#define WIA_DPC_UPLOAD_URL_STR                     L"Upload URL"

#define WIA_DPC_ARTIST                             2091 // 0x82b
#define WIA_DPC_ARTIST_STR                         L"Artist"

#define WIA_DPC_COPYRIGHT_INFO                     2092 // 0x82c
#define WIA_DPC_COPYRIGHT_INFO_STR                 L"Copyright Info"

#define WIA_DPS_HORIZONTAL_BED_SIZE                3074 // 0xc02
#define WIA_DPS_HORIZONTAL_BED_SIZE_STR            L"Horizontal Bed Size"

#define WIA_DPS_VERTICAL_BED_SIZE                  3075 // 0xc03
#define WIA_DPS_VERTICAL_BED_SIZE_STR              L"Vertical Bed Size"

#define WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE         3076 // 0xc04
#define WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR     L"Horizontal Sheet Feed Size"

#define WIA_DPS_VERTICAL_SHEET_FEED_SIZE           3077 // 0xc05
#define WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR       L"Vertical Sheet Feed Size"

#define WIA_DPS_SHEET_FEEDER_REGISTRATION          3078 // 0xc06
#define WIA_DPS_SHEET_FEEDER_REGISTRATION_STR      L"Sheet Feeder Registration"

#define WIA_DPS_HORIZONTAL_BED_REGISTRATION        3079 // 0xc07
#define WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR    L"Horizontal Bed Registration"

#define WIA_DPS_VERTICAL_BED_REGISTRATION          3080 // 0xc08
#define WIA_DPS_VERTICAL_BED_REGISTRATION_STR      L"Vertical Bed Registration"

#define WIA_DPS_PLATEN_COLOR                       3081 // 0xc09
#define WIA_DPS_PLATEN_COLOR_STR                   L"Platen Color"

#define WIA_DPS_PAD_COLOR                          3082 // 0xc0a
#define WIA_DPS_PAD_COLOR_STR                      L"Pad Color"

#define WIA_DPS_FILTER_SELECT                      3083 // 0xc0b
#define WIA_DPS_FILTER_SELECT_STR                  L"Filter Select"

#define WIA_DPS_DITHER_SELECT                      3084 // 0xc0c
#define WIA_DPS_DITHER_SELECT_STR                  L"Dither Select"

#define WIA_DPS_DITHER_PATTERN_DATA                3085 // 0xc0d
#define WIA_DPS_DITHER_PATTERN_DATA_STR            L"Dither Pattern Data"

#define WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES     3086 // 0xc0e
#define WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR L"Document Handling Capabilities"

#define WIA_DPS_DOCUMENT_HANDLING_STATUS           3087 // 0xc0f
#define WIA_DPS_DOCUMENT_HANDLING_STATUS_STR       L"Document Handling Status"

#define WIA_DPS_DOCUMENT_HANDLING_SELECT           3088 // 0xc10
#define WIA_DPS_DOCUMENT_HANDLING_SELECT_STR       L"Document Handling Select"

#define WIA_DPS_DOCUMENT_HANDLING_CAPACITY         3089 // 0xc11
#define WIA_DPS_DOCUMENT_HANDLING_CAPACITY_STR     L"Document Handling Capacity"

#define WIA_DPS_OPTICAL_XRES                       3090 // 0xc12
#define WIA_DPS_OPTICAL_XRES_STR                   L"Horizontal Optical Resolution"

#define WIA_DPS_OPTICAL_YRES                       3091 // 0xc13
#define WIA_DPS_OPTICAL_YRES_STR                   L"Vertical Optical Resolution"

#define WIA_DPS_ENDORSER_CHARACTERS                3092 // 0xc14
#define WIA_DPS_ENDORSER_CHARACTERS_STR            L"Endorser Characters"

#define WIA_DPS_ENDORSER_STRING                    3093 // 0xc15
#define WIA_DPS_ENDORSER_STRING_STR                L"Endorser String"

#define WIA_DPS_SCAN_AHEAD_PAGES                   3094 // 0xc16
#define WIA_DPS_SCAN_AHEAD_PAGES_STR               L"Scan Ahead Pages"

#define WIA_DPS_MAX_SCAN_TIME                      3095 // 0xc17
#define WIA_DPS_MAX_SCAN_TIME_STR                  L"Max Scan Time"

#define WIA_DPS_PAGES                              3096 // 0xc18
#define WIA_DPS_PAGES_STR                          L"Pages"

#define WIA_DPS_PAGE_SIZE                          3097 // 0xc19
#define WIA_DPS_PAGE_SIZE_STR                      L"Page Size"

#define WIA_DPS_PAGE_WIDTH                         3098 // 0xc1a
#define WIA_DPS_PAGE_WIDTH_STR                     L"Page Width"

#define WIA_DPS_PAGE_HEIGHT                        3099 // 0xc1b
#define WIA_DPS_PAGE_HEIGHT_STR                    L"Page Height"

#define WIA_DPS_PREVIEW                            3100 // 0xc1c
#define WIA_DPS_PREVIEW_STR                        L"Preview"

#define WIA_DPS_TRANSPARENCY                       3101 // 0xc1d
#define WIA_DPS_TRANSPARENCY_STR                   L"Transparency Adapter"

#define WIA_DPS_TRANSPARENCY_SELECT                3102 // 0xc1e
#define WIA_DPS_TRANSPARENCY_SELECT_STR            L"Transparency Adapter Select"

#define WIA_DPS_SHOW_PREVIEW_CONTROL               3103 // 0xc1f
#define WIA_DPS_SHOW_PREVIEW_CONTROL_STR           L"Show preview control"

#define WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE     3104 // 0xc20
#define WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE_STR L"Minimum Horizontal Sheet Feed Size"

#define WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE       3105 // 0xc21
#define WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE_STR   L"Minimum Vertical Sheet Feed Size"

#define WIA_DPS_TRANSPARENCY_CAPABILITIES          3106 // 0xc22
#define WIA_DPS_TRANSPARENCY_CAPABILITIES_STR      L"Transparency Adapter Capabilities"

#define WIA_DPS_TRANSPARENCY_STATUS                3107 // 0xc23
#define WIA_DPS_TRANSPARENCY_STATUS_STR            L"Transparency Adapter Status"

#define WIA_DPF_MOUNT_POINT                        3330 // 0xd02
#define WIA_DPF_MOUNT_POINT_STR                    L"Directory mount point"

#define WIA_DPV_LAST_PICTURE_TAKEN                 3586 // 0xe02
#define WIA_DPV_LAST_PICTURE_TAKEN_STR             L"Last Picture Taken"

#define WIA_DPV_IMAGES_DIRECTORY                   3587 // 0xe03
#define WIA_DPV_IMAGES_DIRECTORY_STR               L"Images Directory"

#define WIA_DPV_DSHOW_DEVICE_PATH                  3588 // 0xe04
#define WIA_DPV_DSHOW_DEVICE_PATH_STR              L"Directshow Device Path"

#define WIA_IPA_ITEM_NAME                          4098 // 0x1002
#define WIA_IPA_ITEM_NAME_STR                      L"Item Name"

#define WIA_IPA_FULL_ITEM_NAME                     4099 // 0x1003
#define WIA_IPA_FULL_ITEM_NAME_STR                 L"Full Item Name"

#define WIA_IPA_ITEM_TIME                          4100 // 0x1004
#define WIA_IPA_ITEM_TIME_STR                      L"Item Time Stamp"

#define WIA_IPA_ITEM_FLAGS                         4101 // 0x1005
#define WIA_IPA_ITEM_FLAGS_STR                     L"Item Flags"

#define WIA_IPA_ACCESS_RIGHTS                      4102 // 0x1006
#define WIA_IPA_ACCESS_RIGHTS_STR                  L"Access Rights"

#define WIA_IPA_DATATYPE                           4103 // 0x1007
#define WIA_IPA_DATATYPE_STR                       L"Data Type"

#define WIA_IPA_DEPTH                              4104 // 0x1008
#define WIA_IPA_DEPTH_STR                          L"Bits Per Pixel"

#define WIA_IPA_PREFERRED_FORMAT                   4105 // 0x1009
#define WIA_IPA_PREFERRED_FORMAT_STR               L"Preferred Format"

#define WIA_IPA_FORMAT                             4106 // 0x100a
#define WIA_IPA_FORMAT_STR                         L"Format"

#define WIA_IPA_COMPRESSION                        4107 // 0x100b
#define WIA_IPA_COMPRESSION_STR                    L"Compression"

#define WIA_IPA_TYMED                              4108 // 0x100c
#define WIA_IPA_TYMED_STR                          L"Media Type"

#define WIA_IPA_CHANNELS_PER_PIXEL                 4109 // 0x100d
#define WIA_IPA_CHANNELS_PER_PIXEL_STR             L"Channels Per Pixel"

#define WIA_IPA_BITS_PER_CHANNEL                   4110 // 0x100e
#define WIA_IPA_BITS_PER_CHANNEL_STR               L"Bits Per Channel"

#define WIA_IPA_PLANAR                             4111 // 0x100f
#define WIA_IPA_PLANAR_STR                         L"Planar"

#define WIA_IPA_PIXELS_PER_LINE                    4112 // 0x1010
#define WIA_IPA_PIXELS_PER_LINE_STR                L"Pixels Per Line"

#define WIA_IPA_BYTES_PER_LINE                     4113 // 0x1011
#define WIA_IPA_BYTES_PER_LINE_STR                 L"Bytes Per Line"

#define WIA_IPA_NUMBER_OF_LINES                    4114 // 0x1012
#define WIA_IPA_NUMBER_OF_LINES_STR                L"Number of Lines"

#define WIA_IPA_GAMMA_CURVES                       4115 // 0x1013
#define WIA_IPA_GAMMA_CURVES_STR                   L"Gamma Curves"

#define WIA_IPA_ITEM_SIZE                          4116 // 0x1014
#define WIA_IPA_ITEM_SIZE_STR                      L"Item Size"

#define WIA_IPA_COLOR_PROFILE                      4117 // 0x1015
#define WIA_IPA_COLOR_PROFILE_STR                  L"Color Profiles"

#define WIA_IPA_MIN_BUFFER_SIZE                    4118 // 0x1016
#define WIA_IPA_MIN_BUFFER_SIZE_STR                L"Buffer Size"

#define WIA_IPA_BUFFER_SIZE                        4118 // 0x1016
#define WIA_IPA_BUFFER_SIZE_STR                    L"Buffer Size"

#define WIA_IPA_REGION_TYPE                        4119 // 0x1017
#define WIA_IPA_REGION_TYPE_STR                    L"Region Type"

#define WIA_IPA_ICM_PROFILE_NAME                   4120 // 0x1018
#define WIA_IPA_ICM_PROFILE_NAME_STR               L"Color Profile Name"

#define WIA_IPA_APP_COLOR_MAPPING                  4121 // 0x1019
#define WIA_IPA_APP_COLOR_MAPPING_STR              L"Application Applies Color Mapping"

#define WIA_IPA_PROP_STREAM_COMPAT_ID              4122 // 0x101a
#define WIA_IPA_PROP_STREAM_COMPAT_ID_STR          L"Stream Compatibility ID"

#define WIA_IPA_FILENAME_EXTENSION                 4123 // 0x101b
#define WIA_IPA_FILENAME_EXTENSION_STR             L"Filename extension"

#define WIA_IPA_SUPPRESS_PROPERTY_PAGE             4124 // 0x101c
#define WIA_IPA_SUPPRESS_PROPERTY_PAGE_STR         L"Suppress a property page"

#define WIA_IPC_THUMBNAIL                          5122 // 0x1402
#define WIA_IPC_THUMBNAIL_STR                      L"Thumbnail Data"

#define WIA_IPC_THUMB_WIDTH                        5123 // 0x1403
#define WIA_IPC_THUMB_WIDTH_STR                    L"Thumbnail Width"

#define WIA_IPC_THUMB_HEIGHT                       5124 // 0x1404
#define WIA_IPC_THUMB_HEIGHT_STR                   L"Thumbnail Height"

#define WIA_IPC_AUDIO_AVAILABLE                    5125 // 0x1405
#define WIA_IPC_AUDIO_AVAILABLE_STR                L"Audio Available"

#define WIA_IPC_AUDIO_DATA_FORMAT                  5126 // 0x1406
#define WIA_IPC_AUDIO_DATA_FORMAT_STR              L"Audio Format"

#define WIA_IPC_AUDIO_DATA                         5127 // 0x1407
#define WIA_IPC_AUDIO_DATA_STR                     L"Audio Data"

#define WIA_IPC_NUM_PICT_PER_ROW                   5128 // 0x1408
#define WIA_IPC_NUM_PICT_PER_ROW_STR               L"Pictures per Row"

#define WIA_IPC_SEQUENCE                           5129 // 0x1409
#define WIA_IPC_SEQUENCE_STR                       L"Sequence Number"

#define WIA_IPC_TIMEDELAY                          5130 // 0x140a
#define WIA_IPC_TIMEDELAY_STR                      L"Time Delay"

#define WIA_IPS_CUR_INTENT                         6146 // 0x1802
#define WIA_IPS_CUR_INTENT_STR                     L"Current Intent"

#define WIA_IPS_XRES                               6147 // 0x1803
#define WIA_IPS_XRES_STR                           L"Horizontal Resolution"

#define WIA_IPS_YRES                               6148 // 0x1804
#define WIA_IPS_YRES_STR                           L"Vertical Resolution"

#define WIA_IPS_XPOS                               6149 // 0x1805
#define WIA_IPS_XPOS_STR                           L"Horizontal Start Position"

#define WIA_IPS_YPOS                               6150 // 0x1806
#define WIA_IPS_YPOS_STR                           L"Vertical Start Position"

#define WIA_IPS_XEXTENT                            6151 // 0x1807
#define WIA_IPS_XEXTENT_STR                        L"Horizontal Extent"

#define WIA_IPS_YEXTENT                            6152 // 0x1808
#define WIA_IPS_YEXTENT_STR                        L"Vertical Extent"

#define WIA_IPS_PHOTOMETRIC_INTERP                 6153 // 0x1809
#define WIA_IPS_PHOTOMETRIC_INTERP_STR             L"Photometric Interpretation"

#define WIA_IPS_BRIGHTNESS                         6154 // 0x180a
#define WIA_IPS_BRIGHTNESS_STR                     L"Brightness"

#define WIA_IPS_CONTRAST                           6155 // 0x180b
#define WIA_IPS_CONTRAST_STR                       L"Contrast"

#define WIA_IPS_ORIENTATION                        6156 // 0x180c
#define WIA_IPS_ORIENTATION_STR                    L"Orientation"

#define WIA_IPS_ROTATION                           6157 // 0x180d
#define WIA_IPS_ROTATION_STR                       L"Rotation"

#define WIA_IPS_MIRROR                             6158 // 0x180e
#define WIA_IPS_MIRROR_STR                         L"Mirror"

#define WIA_IPS_THRESHOLD                          6159 // 0x180f
#define WIA_IPS_THRESHOLD_STR                      L"Threshold"

#define WIA_IPS_INVERT                             6160 // 0x1810
#define WIA_IPS_INVERT_STR                         L"Invert"

#define WIA_IPS_WARM_UP_TIME                       6161 // 0x1811
#define WIA_IPS_WARM_UP_TIME_STR                   L"Lamp Warm up Time"

#if (_WIN32_WINNT >= 0x0600)

//
// New properties, property names and values introduced in Windows Vista:
//

#define WIA_DPS_USER_NAME                          3112 // 0xc28
#define WIA_DPS_USER_NAME_STR                      L"User Name"

#define WIA_DPS_SERVICE_ID                         3113 // 0xc29
#define WIA_DPS_SERVICE_ID_STR                     L"Service ID"

#define WIA_DPS_DEVICE_ID                          3114 // 0xc2a
#define WIA_DPS_DEVICE_ID_STR                      L"Device ID"

#define WIA_DPS_GLOBAL_IDENTITY                    3115 // 0xc2b
#define WIA_DPS_GLOBAL_IDENTITY_STR                L"Global Identity"

#define WIA_DPS_SCAN_AVAILABLE_ITEM                3116 // 0xc2c
#define WIA_DPS_SCAN_AVAILABLE_ITEM_STR            L"Scan Available Item"

#define WIA_IPS_DESKEW_X                           6162 // 0x1812
#define WIA_IPS_DESKEW_X_STR                       L"DeskewX"

#define WIA_IPS_DESKEW_Y                           6163 // 0x1813
#define WIA_IPS_DESKEW_Y_STR                       L"DeskewY"

#define WIA_IPS_SEGMENTATION                       6164 // 0x1814
#define WIA_IPS_SEGMENTATION_STR                   L"Segmentation"

#define WIA_SEGMENTATION_FILTER_STR                L"SegmentationFilter"
#define WIA_IMAGEPROC_FILTER_STR                   L"ImageProcessingFilter"

#define WIA_IPS_MAX_HORIZONTAL_SIZE                6165 // 0x1815
#define WIA_IPS_MAX_HORIZONTAL_SIZE_STR            L"Maximum Horizontal Scan Size"

#define WIA_IPS_MAX_VERTICAL_SIZE                  6166 // 0x1816
#define WIA_IPS_MAX_VERTICAL_SIZE_STR              L"Maximum Vertical Scan Size"

#define WIA_IPS_MIN_HORIZONTAL_SIZE                6167 // 0x1817
#define WIA_IPS_MIN_HORIZONTAL_SIZE_STR            L"Minimum Horizontal Scan Size"

#define WIA_IPS_MIN_VERTICAL_SIZE                  6168 // 0x1818
#define WIA_IPS_MIN_VERTICAL_SIZE_STR              L"Minimum Vertical Scan Size"

#define WIA_IPS_TRANSFER_CAPABILITIES              6169 // 0x1819
#define WIA_IPS_TRANSFER_CAPABILITIES_STR          L"Transfer Capabilities"

#define WIA_IPS_SHEET_FEEDER_REGISTRATION          3078 // 0xc06
#define WIA_IPS_SHEET_FEEDER_REGISTRATION_STR      L"Sheet Feeder Registration"

#define WIA_IPS_DOCUMENT_HANDLING_SELECT           3088 // 0xc10
#define WIA_IPS_DOCUMENT_HANDLING_SELECT_STR       L"Document Handling Select"

#define WIA_IPS_OPTICAL_XRES                       3090 // 0xc12
#define WIA_IPS_OPTICAL_XRES_STR                   L"Horizontal Optical Resolution"

#define WIA_IPS_OPTICAL_YRES                       3091 // 0xc13
#define WIA_IPS_OPTICAL_YRES_STR                   L"Vertical Optical Resolution"

#define WIA_IPS_PAGES                              3096 // 0xc18
#define WIA_IPS_PAGES_STR                          L"Pages"

#define WIA_IPS_PAGE_SIZE                          3097 // 0xc19
#define WIA_IPS_PAGE_SIZE_STR                      L"Page Size"

#define WIA_IPS_PAGE_WIDTH                         3098 // 0xc1a
#define WIA_IPS_PAGE_WIDTH_STR                     L"Page Width"

#define WIA_IPS_PAGE_HEIGHT                        3099 // 0xc1b
#define WIA_IPS_PAGE_HEIGHT_STR                    L"Page Height"

#define WIA_IPS_PREVIEW                            3100 // 0xc1c
#define WIA_IPS_PREVIEW_STR                        L"Preview"

#define WIA_IPS_SHOW_PREVIEW_CONTROL               3103 // 0xc1f
#define WIA_IPS_SHOW_PREVIEW_CONTROL_STR           L"Show preview control"

#define WIA_IPS_FILM_SCAN_MODE                     3104 // 0xc20
#define WIA_IPS_FILM_SCAN_MODE_STR                 L"Film Scan Mode"

#define WIA_IPS_LAMP                               3105 // 0xc21
#define WIA_IPS_LAMP_STR                           L"Lamp"

#define WIA_IPS_LAMP_AUTO_OFF                      3106 // 0xc22
#define WIA_IPS_LAMP_AUTO_OFF_STR                  L"Lamp Auto Off"

#define WIA_IPS_AUTO_DESKEW                        3107 // 0xc23
#define WIA_IPS_AUTO_DESKEW_STR                    L"Automatic Deskew"

#define WIA_IPS_SUPPORTS_CHILD_ITEM_CREATION       3108 // 0xc24
#define WIA_IPS_SUPPORTS_CHILD_ITEM_CREATION_STR   L"Supports Child Item Creation"

#define WIA_IPS_XSCALING                           3109 // 0xc25
#define WIA_IPS_XSCALING_STR                       L"Horizontal Scaling"

#define WIA_IPS_YSCALING                           3110 // 0xc26
#define WIA_IPS_YSCALING_STR                       L"Vertical Scaling"

#define WIA_IPS_PREVIEW_TYPE                       3111 // 0xc27
#define WIA_IPS_PREVIEW_TYPE_STR                   L"Preview Type"

#define WIA_IPA_ITEM_CATEGORY                      4125 // 0x101d
#define WIA_IPA_ITEM_CATEGORY_STR                  L"Item Category"

#define WIA_IPA_UPLOAD_ITEM_SIZE                   4126 // 0x101e
#define WIA_IPA_UPLOAD_ITEM_SIZE_STR               L"Upload Item Size"

#define WIA_IPA_ITEMS_STORED                       4127 // 0x101f
#define WIA_IPA_ITEMS_STORED_STR                   L"Items Stored"

#define WIA_IPA_RAW_BITS_PER_CHANNEL               4128 // 0x1020
#define WIA_IPA_RAW_BITS_PER_CHANNEL_STR           L"Raw Bits Per Channel"

#define WIA_IPS_FILM_NODE_NAME                     4129 // 0x1021
#define WIA_IPS_FILM_NODE_NAME_STR                 L"Film Node Name"

//
// WIA_IPA_ITEM_CATEGORY constants
//
DEFINE_GUID(WIA_CATEGORY_FINISHED_FILE,0xff2b77ca, 0xcf84, 0x432b, 0xa7, 0x35, 0x3a, 0x13, 0x0d, 0xde, 0x2a, 0x88);
DEFINE_GUID(WIA_CATEGORY_FLATBED,      0xfb607b1f, 0x43f3, 0x488b, 0x85, 0x5b, 0xfb, 0x70, 0x3e, 0xc3, 0x42, 0xa6);
DEFINE_GUID(WIA_CATEGORY_FEEDER,       0xfe131934, 0xf84c, 0x42ad, 0x8d, 0xa4, 0x61, 0x29, 0xcd, 0xdd, 0x72, 0x88);
DEFINE_GUID(WIA_CATEGORY_FILM,         0xfcf65be7, 0x3ce3, 0x4473, 0xaf, 0x85, 0xf5, 0xd3, 0x7d, 0x21, 0xb6, 0x8a);
DEFINE_GUID(WIA_CATEGORY_ROOT,         0xf193526f, 0x59b8, 0x4a26, 0x98, 0x88, 0xe1, 0x6e, 0x4f, 0x97, 0xce, 0x10);
DEFINE_GUID(WIA_CATEGORY_FOLDER,       0xc692a446, 0x6f5a, 0x481d, 0x85, 0xbb, 0x92, 0xe2, 0xe8, 0x6f, 0xd3, 0xa);
DEFINE_GUID(WIA_CATEGORY_FEEDER_FRONT, 0x4823175c, 0x3b28, 0x487b, 0xa7, 0xe6, 0xee, 0xbc, 0x17, 0x61, 0x4f, 0xd1);
DEFINE_GUID(WIA_CATEGORY_FEEDER_BACK,  0x61ca74d4, 0x39db, 0x42aa, 0x89, 0xb1, 0x8c, 0x19, 0xc9, 0xcd, 0x4c, 0x23);
DEFINE_GUID(WIA_CATEGORY_AUTO,         0xdefe5fd8, 0x6c97, 0x4dde, 0xb1, 0x1e, 0xcb, 0x50, 0x9b, 0x27, 0x0e, 0x11);

//
// GUID for Default Segmentation Filter
//
DEFINE_GUID(CLSID_WiaDefaultSegFilter, 0xD4F4D30B, 0x0B29, 0x4508, 0x89, 0x22, 0x0C, 0x57, 0x97, 0xD4, 0x27, 0x65);

//
// WIA_IPS_TRANSFER_CAPABILITIES flags:
//
#define WIA_TRANSFER_CHILDREN_SINGLE_SCAN 0x00000001

//
// WIA_IPS_SEGMENTATION_FILTER constants
//
#define WIA_USE_SEGMENTATION_FILTER       0
#define WIA_DONT_USE_SEGMENTATION_FILTER  1

//
// WIA_IPS_FILM_SCAN_MODE constants
//
#define WIA_FILM_COLOR_SLIDE              0
#define WIA_FILM_COLOR_NEGATIVE           1
#define WIA_FILM_BW_NEGATIVE              2

//
// WIA_IPS_LAMP constants
//
#define WIA_LAMP_ON                       0
#define WIA_LAMP_OFF                      1

//
// WIA_IPS_AUTO_DESKEW constants:
//
#define WIA_AUTO_DESKEW_ON                0
#define WIA_AUTO_DESKEW_OFF               1

//
// WIA_IPS_PREVIEW_TYPE constants:
//
#define WIA_ADVANCED_PREVIEW              0
#define WIA_BASIC_PREVIEW                 1

//
// WIA Raw Format header:
//
typedef struct _WIA_RAW_HEADER
{
    DWORD Tag;
    DWORD Version;
    DWORD HeaderSize;
    DWORD XRes;
    DWORD YRes;
    DWORD XExtent;
    DWORD YExtent;
    DWORD BytesPerLine;
    DWORD BitsPerPixel;
    DWORD ChannelsPerPixel;
    DWORD DataType;
    BYTE  BitsPerChannel[8];
    DWORD Compression;
    DWORD PhotometricInterp;
    DWORD LineOrder;
    DWORD RawDataOffset;
    DWORD RawDataSize;
    DWORD PaletteOffset;
    DWORD PaletteSize;
} WIA_RAW_HEADER;

typedef struct _WIA_RAW_HEADER *PWIA_RAW_HEADER;

#endif //#if (_WIN32_WINNT >= 0x0600)

//
// Use the WIA property offsets to define private WIA properties.
//
// Example: (Creating a private WIA property)
//
// #define WIA_THE_PROP         (WIA_PRIVATE_DEVPROP + 1000)
// #define WIA_THE_PROP_STR     L"The Property")
//

//
// Private property offset constants
//

#define WIA_PRIVATE_DEVPROP  38914 // offset for private device (root) item properties
#define WIA_PRIVATE_ITEMPROP 71682 // offset for private item properties

//
// WIA image format constants
//

DEFINE_GUID(WiaImgFmt_UNDEFINED,0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_RAWRGB,   0xbca48b55,0xf272,0x4371,0xb0,0xf1,0x4a,0x15,0x0d,0x05,0x7b,0xb4);
DEFINE_GUID(WiaImgFmt_MEMORYBMP,0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_BMP,      0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_EMF,      0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_WMF,      0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_JPEG,     0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_PNG,      0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_GIF,      0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_TIFF,     0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_EXIF,     0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_PHOTOCD,  0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_ICO,      0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_CIFF,     0x9821a8ab,0x3a7e,0x4215,0x94,0xe0,0xd2,0x7a,0x46,0x0c,0x03,0xb2);
DEFINE_GUID(WiaImgFmt_PICT,     0xa6bc85d8,0x6b3e,0x40ee,0xa9,0x5c,0x25,0xd4,0x82,0xe4,0x1a,0xdc);
DEFINE_GUID(WiaImgFmt_JPEG2K,   0x344ee2b2,0x39db,0x4dde,0x81,0x73,0xc4,0xb7,0x5f,0x8f,0x1e,0x49);
DEFINE_GUID(WiaImgFmt_JPEG2KX,  0x43e14614,0xc80a,0x4850,0xba,0xf3,0x4b,0x15,0x2d,0xc8,0xda,0x27);
#if (_WIN32_WINNT >= 0x0600)
DEFINE_GUID(WiaImgFmt_RAW,      0x6f120719,0xf1a8,0x4e07,0x9a,0xde,0x9b,0x64,0xc6,0x3a,0x3d,0xcc);
DEFINE_GUID(WiaImgFmt_JBIG,     0x41e8dd92,0x2f0a,0x43d4,0x86,0x36,0xf1,0x61,0x4b,0xa1,0x1e,0x46);
#endif //#if (_WIN32_WINNT >= 0x0600)


//
// WIA document format constants
//

DEFINE_GUID(WiaImgFmt_RTF,      0x573dd6a3,0x4834,0x432d,0xa9,0xb5,0xe1,0x98,0xdd,0x9e,0x89,0x0d);
DEFINE_GUID(WiaImgFmt_XML,      0xb9171457,0xdac8,0x4884,0xb3,0x93,0x15,0xb4,0x71,0xd5,0xf0,0x7e);
DEFINE_GUID(WiaImgFmt_HTML,     0xc99a4e62,0x99de,0x4a94,0xac,0xca,0x71,0x95,0x6a,0xc2,0x97,0x7d);
DEFINE_GUID(WiaImgFmt_TXT,      0xfafd4d82,0x723f,0x421f,0x93,0x18,0x30,0x50,0x1a,0xc4,0x4b,0x59);
#if (_WIN32_WINNT >= 0x0600)
DEFINE_GUID(WiaImgFmt_PDFA,     0x9980bd5b,0x3463,0x43c7,0xbd,0xca,0x3c,0xaa,0x14,0x6f,0x22,0x9f);
DEFINE_GUID(WiaImgFmt_XPS,      0x700b4a0f,0x2011,0x411c,0xb4,0x30,0xd1,0xe0,0xb2,0xe1,0x0b,0x28);
#endif //#if (_WIN32_WINNT >= 0x0600)

//
// WIA video format constants
//

DEFINE_GUID(WiaImgFmt_MPG,      0xecd757e4,0xd2ec,0x4f57,0x95,0x5d,0xbc,0xf8,0xa9,0x7c,0x4e,0x52);
DEFINE_GUID(WiaImgFmt_AVI,      0x32f8ca14,0x087c,0x4908,0xb7,0xc4,0x67,0x57,0xfe,0x7e,0x90,0xab);

//
// WIA audio format constants
//

DEFINE_GUID(WiaAudFmt_WAV,      0xf818e146,0x07af,0x40ff,0xae,0x55,0xbe,0x8f,0x2c,0x06,0x5d,0xbe);
DEFINE_GUID(WiaAudFmt_MP3,      0x0fbc71fb,0x43bf,0x49f2,0x91,0x90,0xe6,0xfe,0xcf,0xf3,0x7e,0x54);
DEFINE_GUID(WiaAudFmt_AIFF,     0x66e2bf4f,0xb6fc,0x443f,0x94,0xc8,0x2f,0x33,0xc8,0xa6,0x5a,0xaf);
DEFINE_GUID(WiaAudFmt_WMA,      0xd61d6413,0x8bc2,0x438f,0x93,0xad,0x21,0xbd,0x48,0x4d,0xb6,0xa1);

//
// WIA misc format constants
//

DEFINE_GUID(WiaImgFmt_ASF,      0x8d948ee9,0xd0aa,0x4a12,0x9d,0x9a,0x9c,0xc5,0xde,0x36,0x19,0x9b);
DEFINE_GUID(WiaImgFmt_SCRIPT,   0xfe7d6c53,0x2dac,0x446a,0xb0,0xbd,0xd7,0x3e,0x21,0xe9,0x24,0xc9);
DEFINE_GUID(WiaImgFmt_EXEC,     0x485da097,0x141e,0x4aa5,0xbb,0x3b,0xa5,0x61,0x8d,0x95,0xd0,0x2b);
DEFINE_GUID(WiaImgFmt_UNICODE16,0x1b7639b6,0x6357,0x47d1,0x9a,0x07,0x12,0x45,0x2d,0xc0,0x73,0xe9);
DEFINE_GUID(WiaImgFmt_DPOF,     0x369eeeab,0xa0e8,0x45ca,0x86,0xa6,0xa8,0x3c,0xe5,0x69,0x7e,0x28);

//
// WIA event constants
//

DEFINE_GUID(WIA_EVENT_DEVICE_DISCONNECTED,0x143e4e83,0x6497,0x11d2,0xa2,0x31,0x00,0xc0,0x4f,0xa3,0x18,0x09);
DEFINE_GUID(WIA_EVENT_DEVICE_CONNECTED,   0xa28bbade,0x64b6,0x11d2,0xa2,0x31,0x00,0xc0,0x4f,0xa3,0x18,0x09);
DEFINE_GUID(WIA_EVENT_ITEM_DELETED,       0x1d22a559,0xe14f,0x11d2,0xb3,0x26,0x00,0xc0,0x4f,0x68,0xce,0x61);
DEFINE_GUID(WIA_EVENT_ITEM_CREATED,       0x4c8f4ef5,0xe14f,0x11d2,0xb3,0x26,0x00,0xc0,0x4f,0x68,0xce,0x61);
DEFINE_GUID(WIA_EVENT_TREE_UPDATED,       0xc9859b91,0x4ab2,0x4cd6,0xa1,0xfc,0x58,0x2e,0xec,0x55,0xe5,0x85);
DEFINE_GUID(WIA_EVENT_VOLUME_INSERT,      0x9638bbfd,0xd1bd,0x11d2,0xb3,0x1f,0x00,0xc0,0x4f,0x68,0xce,0x61);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE,         0xa6c5a715,0x8c6e,0x11d2,0x97,0x7a,0x00,0x00,0xf8,0x7a,0x92,0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_PRINT_IMAGE,   0xb441f425,0x8c6e,0x11d2,0x97,0x7a,0x00,0x00,0xf8,0x7a,0x92,0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_FAX_IMAGE,     0xc00eb793,0x8c6e,0x11d2,0x97,0x7a,0x00,0x00,0xf8,0x7a,0x92,0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_OCR_IMAGE,     0x9d095b89,0x37d6,0x4877,0xaf,0xed,0x62,0xa2,0x97,0xdc,0x6d,0xbe);
DEFINE_GUID(WIA_EVENT_SCAN_EMAIL_IMAGE,   0xc686dcee,0x54f2,0x419e,0x9a,0x27,0x2f,0xc7,0xf2,0xe9,0x8f,0x9e);
DEFINE_GUID(WIA_EVENT_SCAN_FILM_IMAGE,    0x9b2b662c,0x6185,0x438c,0xb6,0x8b,0xe3,0x9e,0xe2,0x5e,0x71,0xcb);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE2,        0xfc4767c1,0xc8b3,0x48a2,0x9c,0xfa,0x2e,0x90,0xcb,0x3d,0x35,0x90);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE3,        0x154e27be,0xb617,0x4653,0xac,0xc5,0x0f,0xd7,0xbd,0x4c,0x65,0xce);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE4,        0xa65b704a,0x7f3c,0x4447,0xa7,0x5d,0x8a,0x26,0xdf,0xca,0x1f,0xdf);
DEFINE_GUID(WIA_EVENT_STORAGE_CREATED,    0x353308b2,0xfe73,0x46c8,0x89,0x5e,0xfa,0x45,0x51,0xcc,0xc8,0x5a);
DEFINE_GUID(WIA_EVENT_STORAGE_DELETED,    0x5e41e75e,0x9390,0x44c5,0x9a,0x51,0xe4,0x70,0x19,0xe3,0x90,0xcf);
DEFINE_GUID(WIA_EVENT_STI_PROXY,          0xd711f81f,0x1f0d,0x422d,0x86,0x41,0x92,0x7d,0x1b,0x93,0xe5,0xe5);
DEFINE_GUID(WIA_EVENT_CANCEL_IO,          0xc860f7b8,0x9ccd,0x41ea,0xbb,0xbf,0x4d,0xd0,0x9c,0x5b,0x17,0x95);

//
// Power management event GUIDs, sent by the WIA service to drivers
//

DEFINE_GUID(WIA_EVENT_POWER_SUSPEND,      0xa0922ff9,0xc3b4,0x411c,0x9e,0x29,0x03,0xa6,0x69,0x93,0xd2,0xbe);
DEFINE_GUID(WIA_EVENT_POWER_RESUME,       0x618f153e,0xf686,0x4350,0x96,0x34,0x41,0x15,0xa3,0x04,0x83,0x0c);

//
// No action handler and prompt handler
//

DEFINE_GUID(WIA_EVENT_HANDLER_NO_ACTION,  0xe0372b7d,0xe115,0x4525,0xbc,0x55,0xb6,0x29,0xe6,0x8c,0x74,0x5a);
DEFINE_GUID(WIA_EVENT_HANDLER_PROMPT,     0x5f4baad0,0x4d59,0x4fcd,0xb2,0x13,0x78,0x3c,0xe7,0xa9,0x2f,0x22);

//
// WIA command constants
//

DEFINE_GUID(WIA_CMD_SYNCHRONIZE,          0x9b26b7b2,0xacad,0x11d2,0xa0,0x93,0x00,0xc0,0x4f,0x72,0xdc,0x3c);
DEFINE_GUID(WIA_CMD_TAKE_PICTURE,         0xaf933cac,0xacad,0x11d2,0xa0,0x93,0x00,0xc0,0x4f,0x72,0xdc,0x3c);
DEFINE_GUID(WIA_CMD_DELETE_ALL_ITEMS,     0xe208c170,0xacad,0x11d2,0xa0,0x93,0x00,0xc0,0x4f,0x72,0xdc,0x3c);
DEFINE_GUID(WIA_CMD_CHANGE_DOCUMENT,      0x04e725b0,0xacae,0x11d2,0xa0,0x93,0x00,0xc0,0x4f,0x72,0xdc,0x3c);
DEFINE_GUID(WIA_CMD_UNLOAD_DOCUMENT,      0x1f3b3d8e,0xacae,0x11d2,0xa0,0x93,0x00,0xc0,0x4f,0x72,0xdc,0x3c);
DEFINE_GUID(WIA_CMD_DIAGNOSTIC,           0x10ff52f5,0xde04,0x4cf0,0xa5,0xad,0x69,0x1f,0x8d,0xce,0x01,0x41);
DEFINE_GUID(WIA_CMD_FORMAT,               0xc3a693aa,0xf788,0x4d34,0xa5,0xb0,0xbe,0x71,0x90,0x75,0x9a,0x24);

//
// WIA command constants used for debugging only
//

DEFINE_GUID(WIA_CMD_DELETE_DEVICE_TREE,   0x73815942,0xdbea,0x11d2,0x84,0x16,0x00,0xc0,0x4f,0xa3,0x61,0x45);
DEFINE_GUID(WIA_CMD_BUILD_DEVICE_TREE,    0x9cba5ce0,0xdbea,0x11d2,0x84,0x16,0x00,0xc0,0x4f,0xa3,0x61,0x45);

#define FACILITY_WIA         33
#define BASE_VAL_WIA_ERROR   0x00000000
#define BASE_VAL_WIA_SUCCESS 0x00000000

#define WIA_ERROR_GENERAL_ERROR              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 1)
#define WIA_ERROR_PAPER_JAM                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 2)
#define WIA_ERROR_PAPER_EMPTY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 3)
#define WIA_ERROR_PAPER_PROBLEM              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 4)
#define WIA_ERROR_OFFLINE                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 5)
#define WIA_ERROR_BUSY                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 6)
#define WIA_ERROR_WARMING_UP                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 7)
#define WIA_ERROR_USER_INTERVENTION          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 8)
#define WIA_ERROR_ITEM_DELETED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 9)
#define WIA_ERROR_DEVICE_COMMUNICATION       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 10)
#define WIA_ERROR_INVALID_COMMAND            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 11)
#define WIA_ERROR_INCORRECT_HARDWARE_SETTING MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 12)
#define WIA_ERROR_DEVICE_LOCKED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 13)
#define WIA_ERROR_EXCEPTION_IN_DRIVER        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 14)
#define WIA_ERROR_INVALID_DRIVER_RESPONSE    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 15)
#define WIA_ERROR_COVER_OPEN                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 16)
#define WIA_ERROR_LAMP_OFF                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 17)
#define WIA_ERROR_DESTINATION                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 18)
#define WIA_ERROR_NETWORK_RESERVATION_FAILED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 19)
#define WIA_STATUS_END_OF_MEDIA              MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 1)

//
// Definitions for errors and status codes passed to IWiaDataTransfer::BandedDataCallback as the lReason parameter.
// These codes are in addition to the errors defined above; in some cases the SEVERITY_SUCCESS version of
// an error is meant to replace the SEVERITY_ERROR version listed above.
//

#define WIA_STATUS_WARMING_UP                MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 2)
#define WIA_STATUS_CALIBRATING               MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 3)
#define WIA_STATUS_RESERVING_NETWORK_DEVICE  MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 6)
#define WIA_STATUS_NETWORK_DEVICE_RESERVED   MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 7)
#define WIA_STATUS_CLEAR                     MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 8)
#define WIA_STATUS_SKIP_ITEM                 MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 9)
#define WIA_STATUS_NOT_HANDLED               MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 10)

//
// The value is returned by Scansetting.dll when the user chooses to change the scanner in scandialog
//

#define WIA_S_CHANGE_DEVICE                  MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, 11)

//
// SelectDeviceDlg and SelectDeviceDlgID status code when there are no devices available
//

#define WIA_S_NO_DEVICE_AVAILABLE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, 21)

//
// SelectDeviceDlg and GetImageDlg flag constants
//

#define WIA_SELECT_DEVICE_NODEFAULT          0x00000001

//
// DeviceDlg and GetImageDlg flags constants
//

#define WIA_DEVICE_DIALOG_SINGLE_IMAGE       0x00000002  // Only allow one image to be selected
#define WIA_DEVICE_DIALOG_USE_COMMON_UI      0x00000004  // Give preference to the system-provided UI, if available

//
// RegisterEventCallbackInterface and RegisterEventCallbackCLSID flag constants
//

#define  WIA_REGISTER_EVENT_CALLBACK         0x00000001
#define  WIA_UNREGISTER_EVENT_CALLBACK       0x00000002
#define  WIA_SET_DEFAULT_HANDLER             0x00000004

//
// WIA event type constants
//

#define  WIA_NOTIFICATION_EVENT              0x00000001
#define  WIA_ACTION_EVENT                    0x00000002

//
// Additional WIA raw format constants
//

#define  WIA_LINE_ORDER_TOP_TO_BOTTOM        0x00000001
#define  WIA_LINE_ORDER_BOTTOM_TO_TOP        0x00000002

//
// WIA event persistent handler flag constants
//

#define  WIA_IS_DEFAULT_HANDLER              0x00000001

//
// WIA connected and disconnected event description strings
//

#define WIA_EVENT_DEVICE_DISCONNECTED_STR L"Device Disconnected"
#define WIA_EVENT_DEVICE_CONNECTED_STR    L"Device Connected"

//
// WIA event and command icon resource identifier constants
//
// Events   : -1000 to -1499 (Standard), -1500 to -1999 (Custom)
// Commands : -2000 to -2499 (Standard), -2500 to -2999 (Custom)
//

#define WIA_ICON_DEVICE_DISCONNECTED (L"sti.dll,-1001")
#define WIA_ICON_DEVICE_CONNECTED    (L"sti.dll,-1001")
#define WIA_ICON_ITEM_DELETED        (L"sti.dll,-1001")
#define WIA_ICON_ITEM_CREATED        (L"sti.dll,-1001")
#define WIA_ICON_TREE_UPDATED        (L"sti.dll,-1001")
#define WIA_ICON_VOLUME_INSERT       (L"sti.dll,-1001")
#define WIA_ICON_SCAN_BUTTON_PRESS   (L"sti.dll,-1001")
#define WIA_ICON_SYNCHRONIZE         (L"sti.dll,-2000")
#define WIA_ICON_TAKE_PICTURE        (L"sti.dll,-2001")
#define WIA_ICON_DELETE_ALL_ITEMS    (L"sti.dll,-2002")
#define WIA_ICON_CHANGE_DOCUMENT     (L"sti.dll,-2003")
#define WIA_ICON_UNLOAD_DOCUMENT     (L"sti.dll,-2004")
#define WIA_ICON_DELETE_DEVICE_TREE  (L"sti.dll,-2005")
#define WIA_ICON_BUILD_DEVICE_TREE   (L"sti.dll,-2006")

//
// WIA TYMED constants
//

#define TYMED_CALLBACK                     128
#define TYMED_MULTIPAGE_FILE               256
#define TYMED_MULTIPAGE_CALLBACK           512

//
// IWiaDataCallback and IWiaMiniDrvCallBack message ID constants
//

#define IT_MSG_DATA_HEADER              0x0001
#define IT_MSG_DATA                     0x0002
#define IT_MSG_STATUS                   0x0003
#define IT_MSG_TERMINATION              0x0004
#define IT_MSG_NEW_PAGE                 0x0005
#define IT_MSG_FILE_PREVIEW_DATA        0x0006
#define IT_MSG_FILE_PREVIEW_DATA_HEADER 0x0007

//
// IWiaDataCallback and IWiaMiniDrvCallBack status flag constants
//

#define IT_STATUS_TRANSFER_FROM_DEVICE    0x0001
#define IT_STATUS_PROCESSING_DATA         0x0002
#define IT_STATUS_TRANSFER_TO_CLIENT      0x0004
#define IT_STATUS_MASK                    0x0007 // any status value that doesn't
                                                 // fit the mask is an HRESULT
//
// IWiaTransfer flags
//

#define WIA_TRANSFER_ACQUIRE_CHILDREN     0x0001

//
// IWiaTransferCallback Message types
//

#define WIA_TRANSFER_MSG_STATUS           0x00001
#define WIA_TRANSFER_MSG_END_OF_STREAM    0x00002
#define WIA_TRANSFER_MSG_END_OF_TRANSFER  0x00003
#define WIA_TRANSFER_MSG_DEVICE_STATUS    0x00005
#define WIA_TRANSFER_MSG_NEW_PAGE         0x00006

//
// IWiaEventCallback code constants
//

#define WIA_MAJOR_EVENT_DEVICE_CONNECT    0x01
#define WIA_MAJOR_EVENT_DEVICE_DISCONNECT 0x02
#define WIA_MAJOR_EVENT_PICTURE_TAKEN     0x03
#define WIA_MAJOR_EVENT_PICTURE_DELETED   0x04

//
// WIA device connection status constants
//

#define  WIA_DEVICE_NOT_CONNECTED         0
#define  WIA_DEVICE_CONNECTED             1

//
// EnumDeviceCapabilities and drvGetCapabilities flags
//

#define WIA_DEVICE_COMMANDS               1
#define WIA_DEVICE_EVENTS                 2

//
// EnumDeviceInfo Flags
//

#define WIA_DEVINFO_ENUM_ALL              0x0000000F
#define WIA_DEVINFO_ENUM_LOCAL            0x00000010


//
// WIA item type constants
//

#define WiaItemTypeFree                   0x00000000
#define WiaItemTypeImage                  0x00000001
#define WiaItemTypeFile                   0x00000002
#define WiaItemTypeFolder                 0x00000004
#define WiaItemTypeRoot                   0x00000008
#define WiaItemTypeAnalyze                0x00000010
#define WiaItemTypeAudio                  0x00000020
#define WiaItemTypeDevice                 0x00000040
#define WiaItemTypeDeleted                0x00000080
#define WiaItemTypeDisconnected           0x00000100
#define WiaItemTypeHPanorama              0x00000200
#define WiaItemTypeVPanorama              0x00000400
#define WiaItemTypeBurst                  0x00000800
#define WiaItemTypeStorage                0x00001000
#define WiaItemTypeTransfer               0x00002000
#define WiaItemTypeGenerated              0x00004000
#define WiaItemTypeHasAttachments         0x00008000
#define WiaItemTypeVideo                  0x00010000
#define WiaItemTypeRemoved                0x80000000
//
// 0x00020000 has been reserved for the TWAIN compatiblity layer
// pass-through feature.
//
#if (_WIN32_WINNT >= 0x0600)
#define WiaItemTypeDocument               0x00040000
#define WiaItemTypeProgrammableDataSource 0x00080000
#define WiaItemTypeMask                   0x800FFFFF
#else
#define WiaItemTypeMask                   0x8003FFFF
#endif

//
// Big max device specific item context
//

#define WIA_MAX_CTX_SIZE                  0x01000000

//
// WIA property access flag constants
//

#define WIA_PROP_READ            0x01
#define WIA_PROP_WRITE           0x02
#define WIA_PROP_RW              (WIA_PROP_READ | WIA_PROP_WRITE)
#define WIA_PROP_SYNC_REQUIRED   0x04

#define WIA_PROP_NONE            0x08
#define WIA_PROP_RANGE           0x10
#define WIA_PROP_LIST            0x20
#define WIA_PROP_FLAG            0x40

#define WIA_PROP_CACHEABLE       0x10000

//
// IWiaItem2 CreateChildItem flag constants
//

#define COPY_PARENT_PROPERTY_VALUES       0x40000000

//
// WIA item access flag constants
//

#define WIA_ITEM_CAN_BE_DELETED  0x80
#define WIA_ITEM_READ            WIA_PROP_READ
#define WIA_ITEM_WRITE           WIA_PROP_WRITE
#define WIA_ITEM_RD              (WIA_ITEM_READ | WIA_ITEM_CAN_BE_DELETED)
#define WIA_ITEM_RWD             (WIA_ITEM_READ | WIA_ITEM_WRITE | WIA_ITEM_CAN_BE_DELETED)

//
// WIA property container constants
//

#define  WIA_RANGE_MIN                          0
#define  WIA_RANGE_NOM                          1
#define  WIA_RANGE_MAX                          2
#define  WIA_RANGE_STEP                         3
#define  WIA_RANGE_NUM_ELEMS                    4

#define  WIA_LIST_COUNT                         0
#define  WIA_LIST_NOM                           1
#define  WIA_LIST_VALUES                        2
#define  WIA_LIST_NUM_ELEMS                     2

#define  WIA_FLAG_NOM                           0
#define  WIA_FLAG_VALUES                        1
#define  WIA_FLAG_NUM_ELEMS                     2

//
// WIA property LIST container MACROS
//

#define WIA_PROP_LIST_COUNT(ppv) (((PROPVARIANT*)ppv)->cal.cElems - WIA_LIST_VALUES)

#define WIA_PROP_LIST_VALUE(ppv, index)                              \\
     ((index > ((PROPVARIANT*) ppv)->cal.cElems - WIA_LIST_VALUES) || (index < -WIA_LIST_NOM)) ?\\
     NULL :                                                          \\
     (((PROPVARIANT*) ppv)->vt == VT_UI1) ?                          \\
     ((PROPVARIANT*) ppv)->caub.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_UI2) ?                          \\
     ((PROPVARIANT*) ppv)->caui.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_UI4) ?                          \\
     ((PROPVARIANT*) ppv)->caul.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_I2) ?                           \\
     ((PROPVARIANT*) ppv)->cai.pElems[WIA_LIST_VALUES + index] :     \\
     (((PROPVARIANT*) ppv)->vt == VT_I4) ?                           \\
     ((PROPVARIANT*) ppv)->cal.pElems[WIA_LIST_VALUES + index] :     \\
     (((PROPVARIANT*) ppv)->vt == VT_R4) ?                           \\
     ((PROPVARIANT*) ppv)->caflt.pElems[WIA_LIST_VALUES + index] :   \\
     (((PROPVARIANT*) ppv)->vt == VT_R8) ?                           \\
     ((PROPVARIANT*) ppv)->cadbl.pElems[WIA_LIST_VALUES + index] :   \\
     (((PROPVARIANT*) ppv)->vt == VT_BSTR) ?                         \\
     (LONG)(((PROPVARIANT*) ppv)->cabstr.pElems[WIA_LIST_VALUES + index]) : \\
     NULL

//
// Microsoft defined WIA property offset constants
//

#define WIA_DIP_FIRST                        2
#define WIA_IPA_FIRST                     4098
#define WIA_DPF_FIRST                     3330
#define WIA_IPS_FIRST                     6146
#define WIA_DPS_FIRST                     3074
#define WIA_IPC_FIRST                     5122
#define WIA_NUM_IPC                          9
#define WIA_RESERVED_FOR_NEW_PROPS        1024

//
// WIA_DPC_WHITE_BALANCE constants
//

#define WHITEBALANCE_MANUAL            1
#define WHITEBALANCE_AUTO              2
#define WHITEBALANCE_ONEPUSH_AUTO      3
#define WHITEBALANCE_DAYLIGHT          4
#define WHITEBALANCE_FLORESCENT        5
#define WHITEBALANCE_TUNGSTEN          6
#define WHITEBALANCE_FLASH             7

//
// WIA_DPC_FOCUS_MODE constants
//

#define FOCUSMODE_MANUAL               1
#define FOCUSMODE_AUTO                 2
#define FOCUSMODE_MACROAUTO            3

//
// WIA_DPC_EXPOSURE_METERING_MODE constants
//

#define EXPOSUREMETERING_AVERAGE       1
#define EXPOSUREMETERING_CENTERWEIGHT  2
#define EXPOSUREMETERING_MULTISPOT     3
#define EXPOSUREMETERING_CENTERSPOT    4

//
// WIA_DPC_FLASH_MODE constants
//

#define FLASHMODE_AUTO                 1
#define FLASHMODE_OFF                  2
#define FLASHMODE_FILL                 3
#define FLASHMODE_REDEYE_AUTO          4
#define FLASHMODE_REDEYE_FILL          5
#define FLASHMODE_EXTERNALSYNC         6

//
// WIA_DPC_EXPOSURE_MODE constants
//

#define EXPOSUREMODE_MANUAL            1
#define EXPOSUREMODE_AUTO              2
#define EXPOSUREMODE_APERTURE_PRIORITY 3
#define EXPOSUREMODE_SHUTTER_PRIORITY  4
#define EXPOSUREMODE_PROGRAM_CREATIVE  5
#define EXPOSUREMODE_PROGRAM_ACTION    6
#define EXPOSUREMODE_PORTRAIT          7

//
// WIA_DPC_CAPTURE_MODE constants
//

#define CAPTUREMODE_NORMAL             1
#define CAPTUREMODE_BURST              2
#define CAPTUREMODE_TIMELAPSE          3

//
// WIA_DPC_EFFECT_MODE constants
//

#define EFFECTMODE_STANDARD            1
#define EFFECTMODE_BW                  2
#define EFFECTMODE_SEPIA               3

//
// WIA_DPC_FOCUS_METERING_MODE constants
//

#define FOCUSMETERING_CENTERSPOT       1
#define FOCUSMETERING_MULTISPOT        2

//
// WIA_DPC_POWER_MODE constants
//

#define POWERMODE_LINE                 1
#define POWERMODE_BATTERY              2

//
// WIA_DPS_SHEET_FEEDER_REGISTRATION and
// WIA_DPS_HORIZONTAL_BED_REGISTRATION constants
//

#define  LEFT_JUSTIFIED                0
#define  CENTERED                      1
#define  RIGHT_JUSTIFIED               2

//
// WIA_DPS_VERTICAL_BED_REGISTRATION constants
//

#define  TOP_JUSTIFIED                 0
#define  CENTERED                      1
#define  BOTTOM_JUSTIFIED              2

//
// WIA_IPS_ORIENTATION and WIA_IPS_ROTATION constants
//

#define  PORTRAIT                      0
#define  LANSCAPE                      1
#if (_WIN32_WINNT >= 0x0600)
#define  LANDSCAPE                     LANSCAPE
#endif
#define  ROT180                        2
#define  ROT270                        3


//
// WIA_IPS_MIRROR flags
//

#define  MIRRORED                      0x01

//
// WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES flags
//

#define  FEED                          0x01
#define  FLAT                          0x02
#define  DUP                           0x04
#define  DETECT_FLAT                   0x08
#define  DETECT_SCAN                   0x10
#define  DETECT_FEED                   0x20
#define  DETECT_DUP                    0x40
#define  DETECT_FEED_AVAIL             0x80
#define  DETECT_DUP_AVAIL              0x100
#if (_WIN32_WINNT >= 0x0600)
#define  FILM_TPA                      0x200
#define  DETECT_FILM_TPA               0x400
#define  STOR                          0x800
#define  DETECT_STOR                   0x1000
#define  ADVANCED_DUP                  0x2000
#define  AUTO_SOURCE                   0x8000
#endif

//
// WIA_DPS_DOCUMENT_HANDLING_STATUS flags
//

#define  FEED_READY                    0x01
#define  FLAT_READY                    0x02
#define  DUP_READY                     0x04
#define  FLAT_COVER_UP                 0x08
#define  PATH_COVER_UP                 0x10
#define  PAPER_JAM                     0x20
#if (_WIN32_WINNT >= 0x0600)
#define  FILM_TPA_READY                0x40
#define  STORAGE_READY                 0x80
#define  STORAGE_FULL                  0x100
#define  MULTIPLE_FEED                 0x200
#define  DEVICE_ATTENTION              0x400
#define  LAMP_ERR                      0x800
#endif

//
// WIA_DPS_DOCUMENT_HANDLING_SELECT flags
//

#define  FEEDER                        0x001
#define  FLATBED                       0x002
#define  DUPLEX                        0x004
#define  FRONT_FIRST                   0x008
#define  BACK_FIRST                    0x010
#define  FRONT_ONLY                    0x020
#define  BACK_ONLY                     0x040
#define  NEXT_PAGE                     0x080
#define  PREFEED                       0x100
#define  AUTO_ADVANCE                  0x200
#if (_WIN32_WINNT >= 0x0600)
//
// New WIA_IPS_DOCUMENT_HANDLING_SELECT flag
//
#define  ADVANCED_DUPLEX               0x400
#endif //#if (_WIN32_WINNT >= 0x0600)

//
// WIA_DPS_TRANSPARENCY / WIA_DPS_TRANSPARENCY_STATUS flags
//

#define  LIGHT_SOURCE_PRESENT_DETECT   0x01
#define  LIGHT_SOURCE_PRESENT          0x02
#define  LIGHT_SOURCE_DETECT_READY     0x04
#define  LIGHT_SOURCE_READY            0x08

//
// WIA_DPS_TRANSPARENCY_CAPABILITIES
//

#define TRANSPARENCY_DYNAMIC_FRAME_SUPPORT 0x01
#define TRANSPARENCY_STATIC_FRAME_SUPPORT  0x02

//
// WIA_DPS_TRANSPARENCY_SELECT flags
//

#define  LIGHT_SOURCE_SELECT           0x001 // currently not used
#define  LIGHT_SOURCE_POSITIVE         0x002
#define  LIGHT_SOURCE_NEGATIVE         0x004

//
// WIA_DPS_SCAN_AHEAD_PAGES constants
//

#define  WIA_SCAN_AHEAD_ALL            0

//
// WIA_DPS_PAGES constants
//

#define  ALL_PAGES                     0

//
// WIA_DPS_PREVIEW constants
//

#define WIA_FINAL_SCAN                 0
#define WIA_PREVIEW_SCAN               1

//
// WIA_DPS_SHOW_PREVIEW_CONTROL constants
//

#define WIA_SHOW_PREVIEW_CONTROL       0
#define WIA_DONT_SHOW_PREVIEW_CONTROL  1

//
// Predefined strings for WIA_DPS_ENDORSER_STRING
//

#define WIA_ENDORSER_TOK_DATE          L"$DATE$"
#define WIA_ENDORSER_TOK_TIME          L"$TIME$"
#define WIA_ENDORSER_TOK_PAGE_COUNT    L"$PAGE_COUNT$"
#define WIA_ENDORSER_TOK_DAY           L"$DAY$"
#define WIA_ENDORSER_TOK_MONTH         L"$MONTH$"
#define WIA_ENDORSER_TOK_YEAR          L"$YEAR$"

//
// WIA_DPS_PAGE_SIZE/WIA_IPS_PAGE_SIZE constants
// Dimensions are defined as (WIDTH x HEIGHT) in 1/1000ths of an inch
//

#define WIA_PAGE_A4            0 //  8267 x 11692
#define WIA_PAGE_LETTER        1 //  8500 x 11000
#define WIA_PAGE_CUSTOM        2 // (current extent settings)

#define WIA_PAGE_USLEGAL       3 //  8500 x 14000
#define WIA_PAGE_USLETTER      WIA_PAGE_LETTER
#define WIA_PAGE_USLEDGER      4 // 11000 x 17000
#define WIA_PAGE_USSTATEMENT   5 //  5500 x  8500
#define WIA_PAGE_BUSINESSCARD  6 //  3543 x  2165

//
// ISO A page size constants
//

#define WIA_PAGE_ISO_A0        7 // 33110 x 46811
#define WIA_PAGE_ISO_A1        8 // 23385 x 33110
#define WIA_PAGE_ISO_A2        9 // 16535 x 23385
#define WIA_PAGE_ISO_A3       10 // 11692 x 16535
#define WIA_PAGE_ISO_A4       WIA_PAGE_A4
#define WIA_PAGE_ISO_A5       11 //  5826 x  8267
#define WIA_PAGE_ISO_A6       12 //  4133 x  5826
#define WIA_PAGE_ISO_A7       13 //  2913 x  4133
#define WIA_PAGE_ISO_A8       14 //  2047 x  2913
#define WIA_PAGE_ISO_A9       15 //  1456 x  2047
#define WIA_PAGE_ISO_A10      16 //  1023 x  1456

//
// ISO B page size constants
//

#define WIA_PAGE_ISO_B0       17 //  39370 x 55669
#define WIA_PAGE_ISO_B1       18 //  27834 x 39370
#define WIA_PAGE_ISO_B2       19 //  19685 x 27834
#define WIA_PAGE_ISO_B3       20 //  13897 x 19685
#define WIA_PAGE_ISO_B4       21 //   9842 x 13897
#define WIA_PAGE_ISO_B5       22 //   6929 x  9842
#define WIA_PAGE_ISO_B6       23 //   4921 x  6929
#define WIA_PAGE_ISO_B7       24 //   3464 x  4921
#define WIA_PAGE_ISO_B8       25 //   2440 x  3464
#define WIA_PAGE_ISO_B9       26 //   1732 x  2440
#define WIA_PAGE_ISO_B10      27 //   1220 x  1732

//
// ISO C page size constants
//

#define WIA_PAGE_ISO_C0       28 //  36102 x 51062
#define WIA_PAGE_ISO_C1       29 //  25511 x 36102
#define WIA_PAGE_ISO_C2       30 //  18031 x 25511
#define WIA_PAGE_ISO_C3       31 //  12755 x 18031
#define WIA_PAGE_ISO_C4       32 //   9015 x 12755 (unfolded)
#define WIA_PAGE_ISO_C5       33 //   6377 x  9015 (folded once)
#define WIA_PAGE_ISO_C6       34 //   4488 x  6377 (folded twice)
#define WIA_PAGE_ISO_C7       35 //   3188 x  4488
#define WIA_PAGE_ISO_C8       36 //   2244 x  3188
#define WIA_PAGE_ISO_C9       37 //   1574 x  2244
#define WIA_PAGE_ISO_C10      38 //   1102 x  1574

//
// JIS B page size constants
//

#define WIA_PAGE_JIS_B0       39 //  40551 x 57322
#define WIA_PAGE_JIS_B1       40 //  28661 x 40551
#define WIA_PAGE_JIS_B2       41 //  20275 x 28661
#define WIA_PAGE_JIS_B3       42 //  14330 x 20275
#define WIA_PAGE_JIS_B4       43 //  10118 x 14330
#define WIA_PAGE_JIS_B5       44 //   7165 x 10118
#define WIA_PAGE_JIS_B6       45 //   5039 x  7165
#define WIA_PAGE_JIS_B7       46 //   3582 x  5039
#define WIA_PAGE_JIS_B8       47 //   2519 x  3582
#define WIA_PAGE_JIS_B9       48 //   1771 x  2519
#define WIA_PAGE_JIS_B10      49 //   1259 x  1771

//
// JIS A page size constants
//

#define WIA_PAGE_JIS_2A       50 //  46811 x 66220
#define WIA_PAGE_JIS_4A       51 //  66220 x  93622

//
// DIN B page size constants
//

#define WIA_PAGE_DIN_2B       52 //  55669 x 78740
#define WIA_PAGE_DIN_4B       53 //  78740 x 111338

#if (_WIN32_WINNT >= 0x0600)
//
// Additional WIA_IPS_PAGE_SIZE constants:
//
#define WIA_PAGE_AUTO         100
#define WIA_PAGE_CUSTOM_BASE  0x8000
#endif //#if (_WIN32_WINNT >= 0x0600)


//
// WIA_IPA_COMPRESSION constants
//

#define WIA_COMPRESSION_NONE           0
#define WIA_COMPRESSION_BI_RLE4        1
#define WIA_COMPRESSION_BI_RLE8        2
#define WIA_COMPRESSION_G3             3
#define WIA_COMPRESSION_G4             4
#define WIA_COMPRESSION_JPEG           5
#if (_WIN32_WINNT >= 0x0600)
#define WIA_COMPRESSION_JBIG           6
#define WIA_COMPRESSION_JPEG2K         7
#define WIA_COMPRESSION_PNG            8
#endif //#if (_WIN32_WINNT >= 0x0600)

//
// WIA_IPA_PLANAR constants
//

#define WIA_PACKED_PIXEL               0
#define WIA_PLANAR                     1

//
// WIA_IPA_DATATYPE constants
//

#define WIA_DATA_THRESHOLD             0
#define WIA_DATA_DITHER                1
#define WIA_DATA_GRAYSCALE             2
#define WIA_DATA_COLOR                 3
#define WIA_DATA_COLOR_THRESHOLD       4
#define WIA_DATA_COLOR_DITHER          5
#if (_WIN32_WINNT >= 0x0600)
#define WIA_DATA_RAW_RGB               6
#define WIA_DATA_RAW_BGR               7
#define WIA_DATA_RAW_YUV               8
#define WIA_DATA_RAW_YUVK              9
#define WIA_DATA_RAW_CMY              10
#define WIA_DATA_RAW_CMYK             11
#endif //#if (_WIN32_WINNT >= 0x0600)


//
// WIA_IPS_PHOTOMETRIC_INTERP constants
//

#define WIA_PHOTO_WHITE_1              0 // white is 1, black is 0
#define WIA_PHOTO_WHITE_0              1 // white is 0, black is 1

//
// WIA_IPA_SUPPRESS_PROPERTY_PAGE flags
//

#define WIA_PROPPAGE_SCANNER_ITEM_GENERAL 0x00000001
#define WIA_PROPPAGE_CAMERA_ITEM_GENERAL  0x00000002
#define WIA_PROPPAGE_DEVICE_GENERAL       0x00000004

//
// WIA_IPS_CUR_INTENT flags
//
#define WIA_INTENT_NONE                   0x00000000
#define WIA_INTENT_IMAGE_TYPE_COLOR       0x00000001
#define WIA_INTENT_IMAGE_TYPE_GRAYSCALE   0x00000002
#define WIA_INTENT_IMAGE_TYPE_TEXT        0x00000004
#define WIA_INTENT_IMAGE_TYPE_MASK        0x0000000F
#define WIA_INTENT_MINIMIZE_SIZE          0x00010000
#define WIA_INTENT_MAXIMIZE_QUALITY       0x00020000
#define WIA_INTENT_BEST_PREVIEW           0x00040000
#define WIA_INTENT_SIZE_MASK              0x000F0000

//
// global WIA device informationproperty array
//

#define WIA_NUM_DIP 16

#ifdef WIA_DECLARE_DEVINFO_PROP_ARRAY

PROPSPEC g_psDeviceInfo[WIA_NUM_DIP] =
{
    {PRSPEC_PROPID, WIA_DIP_DEV_ID},
    {PRSPEC_PROPID, WIA_DIP_VEND_DESC},
    {PRSPEC_PROPID, WIA_DIP_DEV_DESC},
    {PRSPEC_PROPID, WIA_DIP_DEV_TYPE},
    {PRSPEC_PROPID, WIA_DIP_PORT_NAME},
    {PRSPEC_PROPID, WIA_DIP_DEV_NAME},
    {PRSPEC_PROPID, WIA_DIP_SERVER_NAME},
    {PRSPEC_PROPID, WIA_DIP_REMOTE_DEV_ID},
    {PRSPEC_PROPID, WIA_DIP_UI_CLSID},
    {PRSPEC_PROPID, WIA_DIP_HW_CONFIG},
    {PRSPEC_PROPID, WIA_DIP_BAUDRATE},
    {PRSPEC_PROPID, WIA_DIP_STI_GEN_CAPABILITIES},
    {PRSPEC_PROPID, WIA_DIP_WIA_VERSION},
    {PRSPEC_PROPID, WIA_DIP_DRIVER_VERSION},
    {PRSPEC_PROPID, WIA_DIP_PNP_ID},
    {PRSPEC_PROPID, WIA_DIP_STI_DRIVER_VERSION},
};

PROPID g_piDeviceInfo[WIA_NUM_DIP] =
{
    WIA_DIP_DEV_ID,
    WIA_DIP_VEND_DESC,
    WIA_DIP_DEV_DESC,
    WIA_DIP_DEV_TYPE,
    WIA_DIP_PORT_NAME,
    WIA_DIP_DEV_NAME,
    WIA_DIP_SERVER_NAME,
    WIA_DIP_REMOTE_DEV_ID,
    WIA_DIP_UI_CLSID,
    WIA_DIP_HW_CONFIG,
    WIA_DIP_BAUDRATE,
    WIA_DIP_STI_GEN_CAPABILITIES,
    WIA_DIP_WIA_VERSION,
    WIA_DIP_DRIVER_VERSION,
    WIA_DIP_PNP_ID,
    WIA_DIP_STI_DRIVER_VERSION,
};

LPOLESTR g_pszDeviceInfo[WIA_NUM_DIP] =
{
    WIA_DIP_DEV_ID_STR,
    WIA_DIP_VEND_DESC_STR,
    WIA_DIP_DEV_DESC_STR,
    WIA_DIP_DEV_TYPE_STR,
    WIA_DIP_PORT_NAME_STR,
    WIA_DIP_DEV_NAME_STR,
    WIA_DIP_SERVER_NAME_STR,
    WIA_DIP_REMOTE_DEV_ID_STR,
    WIA_DIP_UI_CLSID_STR,
    WIA_DIP_HW_CONFIG_STR,
    WIA_DIP_BAUDRATE_STR,
    WIA_DIP_STI_GEN_CAPABILITIES_STR,
    WIA_DIP_WIA_VERSION_STR,
    WIA_DIP_DRIVER_VERSION_STR,
    WIA_DIP_PNP_ID_STR,
    WIA_DIP_STI_DRIVER_VERSION_STR,
};

#else

extern PROPSPEC g_psDeviceInfo[WIA_NUM_DIP];
extern PROPID   g_piDeviceInfo[WIA_NUM_DIP];
extern LPOLESTR g_pszDeviceInfo[WIA_NUM_DIP];

#endif

//
// global WIA property ID to property name array
//

#ifdef DEFINE_WIA_PROPID_TO_NAME

WIA_PROPID_TO_NAME g_wiaPropIdToName[] =
{
    {WIA_DIP_DEV_ID,                          WIA_DIP_DEV_ID_STR},
    {WIA_DIP_VEND_DESC,                       WIA_DIP_VEND_DESC_STR},
    {WIA_DIP_DEV_DESC,                        WIA_DIP_DEV_DESC_STR},
    {WIA_DIP_DEV_TYPE,                        WIA_DIP_DEV_TYPE_STR},
    {WIA_DIP_PORT_NAME,                       WIA_DIP_PORT_NAME_STR},
    {WIA_DIP_DEV_NAME,                        WIA_DIP_DEV_NAME_STR},
    {WIA_DIP_SERVER_NAME,                     WIA_DIP_SERVER_NAME_STR},
    {WIA_DIP_REMOTE_DEV_ID,                   WIA_DIP_REMOTE_DEV_ID_STR},
    {WIA_DIP_UI_CLSID,                        WIA_DIP_UI_CLSID_STR},
    {WIA_DIP_HW_CONFIG,                       WIA_DIP_HW_CONFIG_STR},
    {WIA_DIP_BAUDRATE,                        WIA_DIP_BAUDRATE_STR},
    {WIA_DIP_STI_GEN_CAPABILITIES,            WIA_DIP_STI_GEN_CAPABILITIES_STR},
    {WIA_DIP_WIA_VERSION,                     WIA_DIP_WIA_VERSION_STR},
    {WIA_DIP_DRIVER_VERSION,                  WIA_DIP_DRIVER_VERSION_STR},
    {WIA_DIP_PNP_ID,                          WIA_DIP_PNP_ID_STR},
    {WIA_DIP_STI_DRIVER_VERSION,              WIA_DIP_STI_DRIVER_VERSION_STR},
    {WIA_DPA_FIRMWARE_VERSION,                WIA_DPA_FIRMWARE_VERSION_STR},
    {WIA_DPA_CONNECT_STATUS,                  WIA_DPA_CONNECT_STATUS_STR},
    {WIA_DPA_DEVICE_TIME,                     WIA_DPA_DEVICE_TIME_STR},
    {WIA_DPC_PICTURES_TAKEN,                  WIA_DPC_PICTURES_TAKEN_STR},
    {WIA_DPC_PICTURES_REMAINING,              WIA_DPC_PICTURES_REMAINING_STR},
    {WIA_DPC_EXPOSURE_MODE,                   WIA_DPC_EXPOSURE_MODE_STR},
    {WIA_DPC_EXPOSURE_COMP,                   WIA_DPC_EXPOSURE_COMP_STR},
    {WIA_DPC_EXPOSURE_TIME,                   WIA_DPC_EXPOSURE_TIME_STR},
    {WIA_DPC_FNUMBER,                         WIA_DPC_FNUMBER_STR},
    {WIA_DPC_FLASH_MODE,                      WIA_DPC_FLASH_MODE_STR},
    {WIA_DPC_FOCUS_MODE,                      WIA_DPC_FOCUS_MODE_STR},
    {WIA_DPC_FOCUS_MANUAL_DIST,               WIA_DPC_FOCUS_MANUAL_DIST_STR},
    {WIA_DPC_ZOOM_POSITION,                   WIA_DPC_ZOOM_POSITION_STR},
    {WIA_DPC_PAN_POSITION,                    WIA_DPC_PAN_POSITION_STR},
    {WIA_DPC_TILT_POSITION,                   WIA_DPC_TILT_POSITION_STR},
    {WIA_DPC_TIMER_MODE,                      WIA_DPC_TIMER_MODE_STR},
    {WIA_DPC_TIMER_VALUE,                     WIA_DPC_TIMER_VALUE_STR},
    {WIA_DPC_POWER_MODE,                      WIA_DPC_POWER_MODE_STR},
    {WIA_DPC_BATTERY_STATUS,                  WIA_DPC_BATTERY_STATUS_STR},
    {WIA_DPC_DIMENSION,                       WIA_DPC_DIMENSION_STR},
    {WIA_DPS_HORIZONTAL_BED_SIZE,             WIA_DPS_HORIZONTAL_BED_SIZE_STR},
    {WIA_DPS_VERTICAL_BED_SIZE,               WIA_DPS_VERTICAL_BED_SIZE_STR},
    {WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE,      WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_VERTICAL_SHEET_FEED_SIZE,        WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_SHEET_FEEDER_REGISTRATION,       WIA_DPS_SHEET_FEEDER_REGISTRATION_STR},
    {WIA_DPS_HORIZONTAL_BED_REGISTRATION,     WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR},
    {WIA_DPS_VERTICAL_BED_REGISTRATION,       WIA_DPS_VERTICAL_BED_REGISTRATION_STR},
    {WIA_DPS_PLATEN_COLOR,                    WIA_DPS_PLATEN_COLOR_STR},
    {WIA_DPS_PAD_COLOR,                       WIA_DPS_PAD_COLOR_STR},
    {WIA_DPS_FILTER_SELECT,                   WIA_DPS_FILTER_SELECT_STR},
    {WIA_DPS_DITHER_SELECT,                   WIA_DPS_DITHER_SELECT_STR},
    {WIA_DPS_DITHER_PATTERN_DATA,             WIA_DPS_DITHER_PATTERN_DATA_STR},
    {WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES,  WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR},
    {WIA_DPS_DOCUMENT_HANDLING_STATUS,        WIA_DPS_DOCUMENT_HANDLING_STATUS_STR},
    {WIA_DPS_DOCUMENT_HANDLING_SELECT,        WIA_DPS_DOCUMENT_HANDLING_SELECT_STR},
    {WIA_DPS_DOCUMENT_HANDLING_CAPACITY,      WIA_DPS_DOCUMENT_HANDLING_CAPACITY_STR},
    {WIA_DPS_OPTICAL_XRES,                    WIA_DPS_OPTICAL_XRES_STR},
    {WIA_DPS_OPTICAL_YRES,                    WIA_DPS_OPTICAL_YRES_STR},
    {WIA_DPS_ENDORSER_CHARACTERS,             WIA_DPS_ENDORSER_CHARACTERS_STR},
    {WIA_DPS_ENDORSER_STRING,                 WIA_DPS_ENDORSER_STRING_STR},
    {WIA_DPS_SCAN_AHEAD_PAGES,                WIA_DPS_SCAN_AHEAD_PAGES_STR},
    {WIA_DPS_MAX_SCAN_TIME,                   WIA_DPS_MAX_SCAN_TIME_STR},
    {WIA_DPS_PAGES,                           WIA_DPS_PAGES_STR},
    {WIA_DPS_PAGE_SIZE,                       WIA_DPS_PAGE_SIZE_STR},
    {WIA_DPS_PAGE_WIDTH,                      WIA_DPS_PAGE_WIDTH_STR},
    {WIA_DPS_PAGE_HEIGHT,                     WIA_DPS_PAGE_HEIGHT_STR},
    {WIA_DPS_PREVIEW,                         WIA_DPS_PREVIEW_STR},
    {WIA_DPS_TRANSPARENCY,                    WIA_DPS_TRANSPARENCY_STR},
    {WIA_DPS_TRANSPARENCY_SELECT,             WIA_DPS_TRANSPARENCY_SELECT_STR},
    {WIA_DPS_SHOW_PREVIEW_CONTROL,            WIA_DPS_SHOW_PREVIEW_CONTROL_STR},
    {WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE,  WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE,    WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_USER_NAME,                       WIA_DPS_USER_NAME_STR},
    {WIA_DPV_LAST_PICTURE_TAKEN,              WIA_DPV_LAST_PICTURE_TAKEN_STR},
    {WIA_DPV_IMAGES_DIRECTORY,                WIA_DPV_IMAGES_DIRECTORY_STR},
    {WIA_DPV_DSHOW_DEVICE_PATH,               WIA_DPV_DSHOW_DEVICE_PATH_STR},
    {WIA_DPF_MOUNT_POINT,                     WIA_DPF_MOUNT_POINT_STR},
    {WIA_IPA_ITEM_NAME,                       WIA_IPA_ITEM_NAME_STR},
    {WIA_IPA_FULL_ITEM_NAME,                  WIA_IPA_FULL_ITEM_NAME_STR},
    {WIA_IPA_ITEM_TIME,                       WIA_IPA_ITEM_TIME_STR},
    {WIA_IPA_ITEM_FLAGS,                      WIA_IPA_ITEM_FLAGS_STR},
    {WIA_IPA_ACCESS_RIGHTS,                   WIA_IPA_ACCESS_RIGHTS_STR},
    {WIA_IPA_DATATYPE,                        WIA_IPA_DATATYPE_STR},
    {WIA_IPA_DEPTH,                           WIA_IPA_DEPTH_STR},
    {WIA_IPA_PREFERRED_FORMAT,                WIA_IPA_PREFERRED_FORMAT_STR},
    {WIA_IPA_FORMAT,                          WIA_IPA_FORMAT_STR},
    {WIA_IPA_COMPRESSION,                     WIA_IPA_COMPRESSION_STR},
    {WIA_IPA_TYMED,                           WIA_IPA_TYMED_STR},
    {WIA_IPA_CHANNELS_PER_PIXEL,              WIA_IPA_CHANNELS_PER_PIXEL_STR},
    {WIA_IPA_BITS_PER_CHANNEL,                WIA_IPA_BITS_PER_CHANNEL_STR},
    {WIA_IPA_PLANAR,                          WIA_IPA_PLANAR_STR},
    {WIA_IPA_PIXELS_PER_LINE,                 WIA_IPA_PIXELS_PER_LINE_STR},
    {WIA_IPA_BYTES_PER_LINE,                  WIA_IPA_BYTES_PER_LINE_STR},
    {WIA_IPA_NUMBER_OF_LINES,                 WIA_IPA_NUMBER_OF_LINES_STR},
    {WIA_IPA_GAMMA_CURVES,                    WIA_IPA_GAMMA_CURVES_STR},
    {WIA_IPA_ITEM_SIZE,                       WIA_IPA_ITEM_SIZE_STR},
    {WIA_IPA_COLOR_PROFILE,                   WIA_IPA_COLOR_PROFILE_STR},
    {WIA_IPA_MIN_BUFFER_SIZE,                 WIA_IPA_MIN_BUFFER_SIZE_STR},
    {WIA_IPA_REGION_TYPE,                     WIA_IPA_REGION_TYPE_STR},
    {WIA_IPA_ICM_PROFILE_NAME,                WIA_IPA_ICM_PROFILE_NAME_STR},
    {WIA_IPA_APP_COLOR_MAPPING,               WIA_IPA_APP_COLOR_MAPPING_STR},
    {WIA_IPA_PROP_STREAM_COMPAT_ID,           WIA_IPA_PROP_STREAM_COMPAT_ID_STR},
    {WIA_IPA_FILENAME_EXTENSION,              WIA_IPA_FILENAME_EXTENSION_STR},
    {WIA_IPA_SUPPRESS_PROPERTY_PAGE,          WIA_IPA_SUPPRESS_PROPERTY_PAGE_STR},
    {WIA_IPC_THUMBNAIL,                       WIA_IPC_THUMBNAIL_STR},
    {WIA_IPC_THUMB_WIDTH,                     WIA_IPC_THUMB_WIDTH_STR},
    {WIA_IPC_THUMB_HEIGHT,                    WIA_IPC_THUMB_HEIGHT_STR},
    {WIA_IPC_AUDIO_AVAILABLE,                 WIA_IPC_AUDIO_AVAILABLE_STR},
    {WIA_IPC_AUDIO_DATA_FORMAT,               WIA_IPC_AUDIO_DATA_FORMAT_STR},
    {WIA_IPC_AUDIO_DATA,                      WIA_IPC_AUDIO_DATA_STR},
    {WIA_IPC_NUM_PICT_PER_ROW,                WIA_IPC_NUM_PICT_PER_ROW_STR},
    {WIA_IPC_SEQUENCE,                        WIA_IPC_SEQUENCE_STR},
    {WIA_IPC_TIMEDELAY,                       WIA_IPC_TIMEDELAY_STR},
    {WIA_IPS_CUR_INTENT,                      WIA_IPS_CUR_INTENT_STR},
    {WIA_IPS_XRES,                            WIA_IPS_XRES_STR},
    {WIA_IPS_YRES,                            WIA_IPS_YRES_STR},
    {WIA_IPS_XPOS,                            WIA_IPS_XPOS_STR},
    {WIA_IPS_YPOS,                            WIA_IPS_YPOS_STR},
    {WIA_IPS_XEXTENT,                         WIA_IPS_XEXTENT_STR},
    {WIA_IPS_YEXTENT,                         WIA_IPS_YEXTENT_STR},
    {WIA_IPS_PHOTOMETRIC_INTERP,              WIA_IPS_PHOTOMETRIC_INTERP_STR},
    {WIA_IPS_BRIGHTNESS,                      WIA_IPS_BRIGHTNESS_STR},
    {WIA_IPS_CONTRAST,                        WIA_IPS_CONTRAST_STR},
    {WIA_IPS_ORIENTATION,                     WIA_IPS_ORIENTATION_STR},
    {WIA_IPS_ROTATION,                        WIA_IPS_ROTATION_STR},
    {WIA_IPS_MIRROR,                          WIA_IPS_MIRROR_STR},
    {WIA_IPS_THRESHOLD,                       WIA_IPS_THRESHOLD_STR},
    {WIA_IPS_INVERT,                          WIA_IPS_INVERT_STR},
    {WIA_IPS_WARM_UP_TIME,                    WIA_IPS_WARM_UP_TIME_STR},
#if (_WIN32_WINNT >= 0x0600)
    {WIA_IPA_ITEM_CATEGORY,                   WIA_IPA_ITEM_CATEGORY_STR},
    {WIA_IPA_RAW_BITS_PER_CHANNEL,            WIA_IPA_RAW_BITS_PER_CHANNEL_STR},
    {WIA_IPS_DESKEW_X,                        WIA_IPS_DESKEW_X_STR},
    {WIA_IPS_DESKEW_Y,                        WIA_IPS_DESKEW_Y_STR},
    {WIA_IPS_SEGMENTATION,                    WIA_IPS_SEGMENTATION_STR},
    {WIA_IPS_MAX_HORIZONTAL_SIZE,             WIA_IPS_MAX_HORIZONTAL_SIZE_STR},
    {WIA_IPS_MAX_VERTICAL_SIZE,               WIA_IPS_MAX_VERTICAL_SIZE_STR},
    {WIA_IPS_MIN_HORIZONTAL_SIZE,             WIA_IPS_MIN_HORIZONTAL_SIZE_STR},
    {WIA_IPS_MIN_VERTICAL_SIZE,               WIA_IPS_MIN_VERTICAL_SIZE_STR},
    {WIA_IPS_SHEET_FEEDER_REGISTRATION,       WIA_IPS_SHEET_FEEDER_REGISTRATION_STR},
    {WIA_IPS_DOCUMENT_HANDLING_SELECT,        WIA_IPS_DOCUMENT_HANDLING_SELECT_STR},
    {WIA_IPS_OPTICAL_XRES,                    WIA_IPS_OPTICAL_XRES_STR},
    {WIA_IPS_OPTICAL_YRES,                    WIA_IPS_OPTICAL_YRES_STR},
    {WIA_IPS_PAGES,                           WIA_IPS_PAGES_STR},
    {WIA_IPS_PAGE_SIZE,                       WIA_IPS_PAGE_SIZE_STR},
    {WIA_IPS_PAGE_WIDTH,                      WIA_IPS_PAGE_WIDTH_STR},
    {WIA_IPS_PAGE_HEIGHT,                     WIA_IPS_PAGE_HEIGHT_STR},
    {WIA_IPS_PREVIEW,                         WIA_IPS_PREVIEW_STR},
    {WIA_IPS_SHOW_PREVIEW_CONTROL,            WIA_IPS_SHOW_PREVIEW_CONTROL_STR},
    {WIA_IPS_TRANSFER_CAPABILITIES,           WIA_IPS_TRANSFER_CAPABILITIES_STR},
    {WIA_IPS_FILM_SCAN_MODE,                  WIA_IPS_FILM_SCAN_MODE_STR},
    {WIA_IPS_LAMP,                            WIA_IPS_LAMP_STR},
    {WIA_IPS_LAMP_AUTO_OFF,                   WIA_IPS_LAMP_AUTO_OFF_STR},
    {WIA_IPS_AUTO_DESKEW,                     WIA_IPS_AUTO_DESKEW_STR},
    {WIA_IPS_SUPPORTS_CHILD_ITEM_CREATION,    WIA_IPS_SUPPORTS_CHILD_ITEM_CREATION_STR},
    {WIA_IPS_PREVIEW_TYPE,                    WIA_IPS_PREVIEW_TYPE_STR},
    {WIA_IPS_XSCALING,                        WIA_IPS_XSCALING_STR},
    {WIA_IPS_YSCALING,                        WIA_IPS_YSCALING_STR},
    {WIA_IPA_UPLOAD_ITEM_SIZE,                WIA_IPA_UPLOAD_ITEM_SIZE_STR},
    {WIA_IPA_ITEMS_STORED,                    WIA_IPA_ITEMS_STORED_STR},
#endif
    {0,                                       L"Not a WIA property"}
};

#else

extern WIA_PROPID_TO_NAME g_wiaPropIdToName[];

#endif

#ifdef __cplusplus
};
#endif

#include <poppack.h>

#endif // _WIADEF_

#endif //#if (_WIN32_WINNT >= 0x0501)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wiawsdsc.h ===
/**************************************************************************
*
*  Copyright (c) Microsoft Corporation
*
*  File: wiawsdsc.h
*
*  Version: 2.0
*
*  Description: contains custom WIA definitions for the WSD scan class driver
*
***************************************************************************/

#ifndef _WIAWSDSC_
#define _WIAWSDSC_

#ifndef _WIADEF_
#include <wiadef.h>
#endif

//
// Custom WIA property IDs (see wiadef.h)
//
// These custom properties describe PnP-X device properties
// read at run time from Function Discovery, along with:
//
// WIA_DPS_SERVICE_ID
// WIA_DPS_DEVICE_ID
// WIA_DPS_GLOBAL_IDENTITY
// WIA_DPS_FIRMWARE_VERSION
//
// All are read-only Root item properties maintained by the driver.
//
// Property Type: VT_BSTR
// Valid Values:  WIA_PROP_NONE
// Access Rights: READONLY
//

#define WIA_WSD_MANUFACTURER             WIA_PRIVATE_DEVPROP
#define WIA_WSD_MANUFACTURER_STR         L"Device manufacturer"

#define WIA_WSD_MANUFACTURER_URL         (WIA_PRIVATE_DEVPROP + 1)
#define WIA_WSD_MANUFACTURER_URL_STR     L"Manufacurer URL"

#define WIA_WSD_MODEL_NAME               (WIA_PRIVATE_DEVPROP + 2)
#define WIA_WSD_MODEL_NAME_STR           L"Model name"

#define WIA_WSD_MODEL_NUMBER             (WIA_PRIVATE_DEVPROP + 3)
#define WIA_WSD_MODEL_NUMBER_STR         L"Model number"

#define WIA_WSD_MODEL_URL                (WIA_PRIVATE_DEVPROP + 4)
#define WIA_WSD_MODEL_URL_STR            L"Model URL"

#define WIA_WSD_PRESENTATION_URL         (WIA_PRIVATE_DEVPROP + 5)
#define WIA_WSD_PRESENTATION_URL_STR     L"Presentation URL"

#define WIA_WSD_FRIENDLY_NAME            (WIA_PRIVATE_DEVPROP + 6)
#define WIA_WSD_FRIENDLY_NAME_STR        L"Friendly name"

#define WIA_WSD_SERIAL_NUMBER            (WIA_PRIVATE_DEVPROP + 7)
#define WIA_WSD_SERIAL_NUMBER_STR        L"Serial number"

//
// Obsolete custom WIA property for automatic input-source selection
// during programmed push (device initiated) scanning, currently
// replaced by the standard WIA_DPS_SCAN_AVAILABLE_ITEM (defined
// in wiadef.h) and kept only for backwards compatibility.
// Use WIA_DPS_SCAN_AVAILABLE_ITEM in all new code:
//
#define WIA_WSD_SCAN_AVAILABLE_ITEM      (WIA_PRIVATE_DEVPROP + 8)
#define WIA_WSD_SCAN_AVAILABLE_ITEM_STR  WIA_DPS_SCAN_AVAILABLE_ITEM_STR

#endif //_WIAWSDSC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinBase.Inl ===
/* Copyright (c) 2001-2009, Microsoft Corp. All rights reserved. */

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY


#ifndef _M_CEE_PURE
#define IsolationAwarePrivatenCv WINAPI
#else
#define IsolationAwarePrivatenCv __clrcall
#endif

/* These wrappers prevent warnings about taking the addresses of __declspec(dllimport) functions. */
#ifdef _M_IX86
ISOLATION_AWARE_INLINE HMODULE IsolationAwarePrivatenCv IsolationAwarePrivatezlybNQyVOeNeln(__in PCSTR s) { return LoadLibraryA(s); }
ISOLATION_AWARE_INLINE HMODULE IsolationAwarePrivatenCv IsolationAwarePrivatezltRgzbQhYRuNaQYRn(__in PCSTR s) { return GetModuleHandleA(s); }
#endif
ISOLATION_AWARE_INLINE HMODULE IsolationAwarePrivatenCv IsolationAwarePrivatezlybNQyVOeNelJ(__in PCWSTR s) { return LoadLibraryW(s); }
ISOLATION_AWARE_INLINE HMODULE IsolationAwarePrivatenCv IsolationAwarePrivatezltRgzbQhYRuNaQYRJ(__in PCWSTR s) { return GetModuleHandleW(s); }

BOOL
IsolationAwarePrivatenCv
IsolationAwarePrivatenPgViNgRzlnPgpgk(
    ULONG_PTR* pulpCookie
    );

/*
These are private.
*/
__declspec(selectany) HANDLE WinbaseIsolationAwarePrivateT_UnPgpgk = INVALID_HANDLE_VALUE;
#ifdef _M_IX86
__declspec(selectany) BOOL   IsolationAwarePrivateT_SqbjaYRiRY = FALSE;
#endif
__declspec(selectany) BOOL   WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk = FALSE;
__declspec(selectany) BOOL   WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ = FALSE;

FARPROC IsolationAwarePrivatenCv WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY(LPCSTR pszProcName);

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */
__out_opt HMODULE IsolationAwarePrivatenCv IsolationAwareLoadLibraryA(__in LPCSTR lpLibFileName);
__out_opt HMODULE IsolationAwarePrivatenCv IsolationAwareLoadLibraryW(__in LPCWSTR lpLibFileName);
__out_opt HMODULE IsolationAwarePrivatenCv IsolationAwareLoadLibraryExA(__in LPCSTR lpLibFileName,__reserved HANDLE hFile,__in DWORD dwFlags);
__out_opt HMODULE IsolationAwarePrivatenCv IsolationAwareLoadLibraryExW(__in LPCWSTR lpLibFileName,__reserved HANDLE hFile,__in DWORD dwFlags);
__out HANDLE IsolationAwarePrivatenCv IsolationAwareCreateActCtxW(__in PCACTCTXW pActCtx);
void IsolationAwarePrivatenCv IsolationAwareReleaseActCtx(__inout HANDLE hActCtx);
BOOL IsolationAwarePrivatenCv IsolationAwareActivateActCtx(__inout_opt HANDLE hActCtx,__out ULONG_PTR*lpCookie);
BOOL IsolationAwarePrivatenCv IsolationAwareDeactivateActCtx(__in DWORD dwFlags,__in ULONG_PTR ulCookie);
BOOL IsolationAwarePrivatenCv IsolationAwareFindActCtxSectionStringW(__in DWORD dwFlags,__reserved const GUID*lpExtensionGuid,__in ULONG ulSectionId,__in LPCWSTR lpStringToFind,__out PACTCTX_SECTION_KEYED_DATA ReturnedData);
BOOL IsolationAwarePrivatenCv IsolationAwareQueryActCtxW(__in DWORD dwFlags,__in HANDLE hActCtx,__in_opt PVOID pvSubInstance,__in ULONG ulInfoClass,__out_bcount_part_opt(cbBuffer,*pcbWrittenOrRequired) PVOID pvBuffer,__in SIZE_T cbBuffer,__out_opt SIZE_T*pcbWrittenOrRequired);

#if defined(UNICODE)

#define IsolationAwareLoadLibrary IsolationAwareLoadLibraryW
#define IsolationAwareLoadLibraryEx IsolationAwareLoadLibraryExW

#else /* UNICODE */

#define IsolationAwareLoadLibrary IsolationAwareLoadLibraryA
#define IsolationAwareLoadLibraryEx IsolationAwareLoadLibraryExA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE __out_opt HMODULE IsolationAwarePrivatenCv IsolationAwareLoadLibraryA(__in LPCSTR lpLibFileName)
{
    __out_opt HMODULE result = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        result = LoadLibraryA(lpLibFileName);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE __out_opt HMODULE IsolationAwarePrivatenCv IsolationAwareLoadLibraryW(__in LPCWSTR lpLibFileName)
{
    __out_opt HMODULE result = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        result = LoadLibraryW(lpLibFileName);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE __out_opt HMODULE IsolationAwarePrivatenCv IsolationAwareLoadLibraryExA(__in LPCSTR lpLibFileName,__reserved HANDLE hFile,__in DWORD dwFlags)
{
    __out_opt HMODULE result = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        result = LoadLibraryExA(lpLibFileName,hFile,dwFlags);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE __out_opt HMODULE IsolationAwarePrivatenCv IsolationAwareLoadLibraryExW(__in LPCWSTR lpLibFileName,__reserved HANDLE hFile,__in DWORD dwFlags)
{
    __out_opt HMODULE result = NULL;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        result = LoadLibraryExW(lpLibFileName,hFile,dwFlags);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE __out HANDLE IsolationAwarePrivatenCv IsolationAwareCreateActCtxW(__in PCACTCTXW pActCtx)
{
#ifdef _WIN64
    return CreateActCtxW(pActCtx);
#else
    __out HANDLE result = INVALID_HANDLE_VALUE;
    typedef __out HANDLE (WINAPI* PFN)(__in PCACTCTXW pActCtx);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    if (__IsolationAware_pfn == NULL)
    {
        __IsolationAware_pfn = (PFN) WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY("CreateActCtxW");
        if (__IsolationAware_pfn == NULL)
            return result;
        s_pfn = __IsolationAware_pfn;
    }
    result = __IsolationAware_pfn(pActCtx);
    return result;
#endif
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv IsolationAwareReleaseActCtx(__inout HANDLE hActCtx)
{
#ifdef _WIN64
    ReleaseActCtx(hActCtx);
#else
    typedef void (WINAPI* PFN)(__inout HANDLE hActCtx);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    if (__IsolationAware_pfn == NULL)
    {
        __IsolationAware_pfn = (PFN) WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY("ReleaseActCtx");
        if (__IsolationAware_pfn == NULL)
            return;
        s_pfn = __IsolationAware_pfn;
    }
    __IsolationAware_pfn(hActCtx);
    return;
#endif
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareActivateActCtx(__inout_opt HANDLE hActCtx,__out ULONG_PTR*lpCookie)
{
#ifdef _WIN64
    return ActivateActCtx(hActCtx,lpCookie);
#else
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__inout_opt HANDLE hActCtx,__out ULONG_PTR*lpCookie);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    if (__IsolationAware_pfn == NULL)
    {
        __IsolationAware_pfn = (PFN) WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY("ActivateActCtx");
        if (__IsolationAware_pfn == NULL)
            return fResult;
        s_pfn = __IsolationAware_pfn;
    }
    fResult = __IsolationAware_pfn(hActCtx,lpCookie);
    return fResult;
#endif
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDeactivateActCtx(__in DWORD dwFlags,__in ULONG_PTR ulCookie)
{
#ifdef _WIN64
    return DeactivateActCtx(dwFlags,ulCookie);
#else
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in DWORD dwFlags,__in ULONG_PTR ulCookie);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    if (__IsolationAware_pfn == NULL)
    {
        __IsolationAware_pfn = (PFN) WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY("DeactivateActCtx");
        if (__IsolationAware_pfn == NULL)
            return fResult;
        s_pfn = __IsolationAware_pfn;
    }
    fResult = __IsolationAware_pfn(dwFlags,ulCookie);
    return fResult;
#endif
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareFindActCtxSectionStringW(__in DWORD dwFlags,__reserved const GUID*lpExtensionGuid,__in ULONG ulSectionId,__in LPCWSTR lpStringToFind,__out PACTCTX_SECTION_KEYED_DATA ReturnedData)
{
#ifdef _WIN64
    return FindActCtxSectionStringW(dwFlags,lpExtensionGuid,ulSectionId,lpStringToFind,ReturnedData);
#else
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in DWORD dwFlags,__reserved const GUID*lpExtensionGuid,__in ULONG ulSectionId,__in LPCWSTR lpStringToFind,__out PACTCTX_SECTION_KEYED_DATA ReturnedData);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    if (__IsolationAware_pfn == NULL)
    {
        __IsolationAware_pfn = (PFN) WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY("FindActCtxSectionStringW");
        if (__IsolationAware_pfn == NULL)
            return fResult;
        s_pfn = __IsolationAware_pfn;
    }
    fResult = __IsolationAware_pfn(dwFlags,lpExtensionGuid,ulSectionId,lpStringToFind,ReturnedData);
    return fResult;
#endif
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareQueryActCtxW(__in DWORD dwFlags,__in HANDLE hActCtx,__in_opt PVOID pvSubInstance,__in ULONG ulInfoClass,__out_bcount_part_opt(cbBuffer,*pcbWrittenOrRequired) PVOID pvBuffer,__in SIZE_T cbBuffer,__out_opt SIZE_T*pcbWrittenOrRequired)
{
#ifdef _WIN64
    return QueryActCtxW(dwFlags,hActCtx,pvSubInstance,ulInfoClass,pvBuffer,cbBuffer,pcbWrittenOrRequired);
#else
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(__in DWORD dwFlags,__in HANDLE hActCtx,__in_opt PVOID pvSubInstance,__in ULONG ulInfoClass,__out_bcount_part_opt(cbBuffer,*pcbWrittenOrRequired) PVOID pvBuffer,__in SIZE_T cbBuffer,__out_opt SIZE_T*pcbWrittenOrRequired);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    if (__IsolationAware_pfn == NULL)
    {
        __IsolationAware_pfn = (PFN) WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY("QueryActCtxW");
        if (__IsolationAware_pfn == NULL)
            return fResult;
        s_pfn = __IsolationAware_pfn;
    }
    fResult = __IsolationAware_pfn(dwFlags,hActCtx,pvSubInstance,ulInfoClass,pvBuffer,cbBuffer,pcbWrittenOrRequired);
    return fResult;
#endif
}



#define WINBASE_NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))

typedef struct IsolationAwarePrivate_pBAFGnAG_zBqHyr_vAsB {
    HMODULE (IsolationAwarePrivatenCv * WinbaseIsolationAwarePrivateybNQJ)(__in PCWSTR w);
    PCWSTR WinbaseIsolationAwarePrivateANZRJ;
#ifdef _M_IX86
    HMODULE (IsolationAwarePrivatenCv * WinbaseIsolationAwarePrivateybNQn)(__in PCSTR w);
    PCSTR  WinbaseIsolationAwarePrivateANZRn;
#endif
} IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB;
typedef const IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB *IsolationAwarePrivateCpBAFGnAG_zBqHyr_vAsB;

typedef struct IsolationAwarePrivate_zHGnoyr_zBqHyr_vAsB {
    HMODULE WinbaseIsolationAwarePrivateybNQRQzbQhYR;
} IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB, *IsolationAwarePrivateCzHGnoyr_zBqHyr_vAsB;

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv
IsolationAwarePrivatezltRgCebPnQQeRff(
    __in IsolationAwarePrivateCpBAFGnAG_zBqHyr_vAsB c,
    __inout IsolationAwarePrivateCzHGnoyr_zBqHyr_vAsB m,
    __in PCSTR ProcName
    )
{
    FARPROC Proc = NULL;
    HMODULE hModule;
#ifdef _M_IX86
    static HMODULE s_moduleUnicows;
    static BOOL s_fUnicowsInitialized;

    /*
       get unicows.dll loaded on-demand
    */
    if (!s_fUnicowsInitialized)
    {
        if ((GetVersion() & 0x80000000) != 0)
        {
            GetFileAttributesW(L"???.???");
            s_moduleUnicows = GetModuleHandleA("Unicows.dll");
        }
        s_fUnicowsInitialized = TRUE;
    }

    /*
       always call GetProcAddress(unicows) before the usual .dll
    */
    if (s_moduleUnicows != NULL)
    {
        Proc = GetProcAddress(s_moduleUnicows, ProcName);
        if (Proc != NULL)
            goto Exit;
    }
#endif
    hModule = m->WinbaseIsolationAwarePrivateybNQRQzbQhYR;
    if (hModule == NULL)
    {
#ifdef _M_IX86
        hModule = (((GetVersion() & 0x80000000) != 0) ? (*c->WinbaseIsolationAwarePrivateybNQn)(c->WinbaseIsolationAwarePrivateANZRn) : (*c->WinbaseIsolationAwarePrivateybNQJ)(c->WinbaseIsolationAwarePrivateANZRJ));
#else
        hModule = (*c->WinbaseIsolationAwarePrivateybNQJ)(c->WinbaseIsolationAwarePrivateANZRJ);
#endif
        if (hModule == NULL)
            goto Exit;
        m->WinbaseIsolationAwarePrivateybNQRQzbQhYR = hModule;
    }
    Proc = GetProcAddress(hModule, ProcName);
Exit:
    return Proc;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv
WinbaseIsolationAwarePrivatetRgzlnPgpgk(void)
/*
The correctness of this function depends on it being statically
linked into its clients.

This function is private to functions present in this header.
Do not use it.
*/
{
    BOOL fResult = FALSE;
    ACTIVATION_CONTEXT_BASIC_INFORMATION actCtxBasicInfo;
    ULONG_PTR ulpCookie = 0;

#ifdef _M_IX86
    if (IsolationAwarePrivateT_SqbjaYRiRY)
    {
        fResult = TRUE;
        goto Exit;
    }
#endif

    if (WinbaseIsolationAwarePrivateT_UnPgpgk != INVALID_HANDLE_VALUE)
    {
        fResult = TRUE;
        goto Exit;
    }

    if (!IsolationAwareQueryActCtxW(
        QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS
        | QUERY_ACTCTX_FLAG_NO_ADDREF,
        &WinbaseIsolationAwarePrivateT_UnPgpgk,
        NULL,
        ActivationContextBasicInformation,
        &actCtxBasicInfo,
        sizeof(actCtxBasicInfo),
        NULL))
        goto Exit;

    /*
    If QueryActCtxW returns NULL, try CreateActCtx(3).
    */
    if (actCtxBasicInfo.hActCtx == NULL)
    {
        ACTCTXW actCtx;
        WCHAR rgchFullModulePath[MAX_PATH + 2];
        DWORD dw;
        HMODULE hmodSelf;
#ifdef _M_IX86
        PGET_MODULE_HANDLE_EXW pfnGetModuleHandleExW = (PGET_MODULE_HANDLE_EXW)WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY("GetModuleHandleExW");
        if (pfnGetModuleHandleExW == NULL)
            goto Exit;
#endif
        if (!
#ifdef _M_IX86
            (*pfnGetModuleHandleExW)
#else
            GetModuleHandleExW
#endif
            (     GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
                | GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
                (LPCWSTR)&WinbaseIsolationAwarePrivateT_UnPgpgk,
                &hmodSelf))
            goto Exit;

        rgchFullModulePath[WINBASE_NUMBER_OF(rgchFullModulePath) - 1] = 0;
        rgchFullModulePath[WINBASE_NUMBER_OF(rgchFullModulePath) - 2] = 0;
        dw = GetModuleFileNameW(hmodSelf, rgchFullModulePath, WINBASE_NUMBER_OF(rgchFullModulePath) - 1);
        if (dw == 0)
            goto Exit;
        if (rgchFullModulePath[WINBASE_NUMBER_OF(rgchFullModulePath) - 2] != 0)
        {
            SetLastError(ERROR_BUFFER_OVERFLOW);
            goto Exit;
        }

        actCtx.cbSize = sizeof(actCtx);
        actCtx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_HMODULE_VALID;
        actCtx.lpSource = rgchFullModulePath;
        actCtx.lpResourceName = (LPCWSTR)(ULONG_PTR)3;
        actCtx.hModule = hmodSelf;
        actCtxBasicInfo.hActCtx = IsolationAwareCreateActCtxW(&actCtx);
        if (actCtxBasicInfo.hActCtx == INVALID_HANDLE_VALUE)
        {
            const DWORD dwLastError = GetLastError();
            if ((dwLastError != ERROR_RESOURCE_DATA_NOT_FOUND) &&
                (dwLastError != ERROR_RESOURCE_TYPE_NOT_FOUND) &&
                (dwLastError != ERROR_RESOURCE_LANG_NOT_FOUND) &&
                (dwLastError != ERROR_RESOURCE_NAME_NOT_FOUND))
                goto Exit;

            actCtxBasicInfo.hActCtx = NULL;
        }

        WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk = TRUE;
    }

    WinbaseIsolationAwarePrivateT_UnPgpgk = actCtxBasicInfo.hActCtx;

#define ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION              (2)

    if (IsolationAwareActivateActCtx(actCtxBasicInfo.hActCtx, &ulpCookie))
    {
        __try
        {
            ACTCTX_SECTION_KEYED_DATA actCtxSectionKeyedData;

            actCtxSectionKeyedData.cbSize = sizeof(actCtxSectionKeyedData);
            if (IsolationAwareFindActCtxSectionStringW(0, NULL, ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, L"Comctl32.dll", &actCtxSectionKeyedData))
            {
                /* get button, edit, etc. registered */
                LoadLibraryW(L"Comctl32.dll");
            }
        }
        __finally
        {
            IsolationAwareDeactivateActCtx(0, ulpCookie);
        }
    }

    fResult = TRUE;
Exit:
    return fResult;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv
IsolationAwareInit(void)
/*
The correctness of this function depends on it being statically
linked into its clients.

Call this from DllMain(DLL_PROCESS_ATTACH) if you use id 3 and wish to avoid a race condition that
    can cause an hActCtx leak.
Call this from your .exe's initialization if you use id 3 and wish to avoid a race condition that
    can cause an hActCtx leak.
If you use id 2, this function fetches data from your .dll
    that you do not need to worry about cleaning up.
*/
{
    return WinbaseIsolationAwarePrivatetRgzlnPgpgk();
}

ISOLATION_AWARE_INLINE void IsolationAwarePrivatenCv
IsolationAwareCleanup(void)
/*
Call this from DllMain(DLL_PROCESS_DETACH), if you use id 3, to avoid a leak.
Call this from your .exe's cleanup to possibly avoid apparent (but not actual) leaks, if use id 3.
This function does nothing, safely, if you use id 2.
*/
{
    HANDLE hActCtx;

    if (WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ)
        return;

    /* IsolationAware* calls made from here on out will OutputDebugString
       and use the process default activation context instead of id 3 or will
       continue to successfully use id 2 (but still OutputDebugString).
    */
    WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ = TRUE;
    
    /* There is no cleanup to do if we did not CreateActCtx but only called QueryActCtx.
    */
    if (!WinbaseIsolationAwarePrivateT_SpeRNgRQnPgpgk)
        return;

    hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
    WinbaseIsolationAwarePrivateT_UnPgpgk = NULL; /* process default */

    if (hActCtx == INVALID_HANDLE_VALUE)
        return;
    if (hActCtx == NULL)
        return;
    IsolationAwareReleaseActCtx(hActCtx);
}

ISOLATION_AWARE_INLINE
BOOL
IsolationAwarePrivatenCv
IsolationAwarePrivatenPgViNgRzlnPgpgk(
    ULONG_PTR* pulpCookie
    )
/*
This function is private to functions present in this header and other headers.
*/
{
    BOOL fResult = FALSE;

    if (WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ)
    {
        const static char debugString[] = "IsolationAware function called after IsolationAwareCleanup\n";
        OutputDebugStringA(debugString);
    }

#ifdef _M_IX86
    if (IsolationAwarePrivateT_SqbjaYRiRY)
    {
        fResult = TRUE;
        goto Exit;
    }
#endif

    /* Do not call Init if Cleanup has been called. */
    if (!WinbaseIsolationAwarePrivateT_SpYRNahcpNYYRQ)
    {
        if (!WinbaseIsolationAwarePrivatetRgzlnPgpgk())
            goto Exit;
    }
    /* If Cleanup has been called and id3 was in use, this will activate NULL. */
    if (!IsolationAwareActivateActCtx(WinbaseIsolationAwarePrivateT_UnPgpgk, pulpCookie))
        goto Exit;

    fResult = TRUE;
Exit:
#ifdef _M_IX86
    if (!fResult)
    {
        const DWORD dwLastError = GetLastError();
        if (dwLastError == ERROR_PROC_NOT_FOUND
            || dwLastError == ERROR_MOD_NOT_FOUND
            || dwLastError == ERROR_CALL_NOT_IMPLEMENTED)
        {
            IsolationAwarePrivateT_SqbjaYRiRY = TRUE;
            fResult = TRUE;
        }
    }
#endif
    return fResult;
}

#undef WINBASE_NUMBER_OF

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv WinbaseIsolationAwarePrivatetRgCebPnQQeRff_xReaRYQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    static HMODULE s_module;
    /* Use GetModuleHandle instead of LoadLibrary on kernel32.dll because */
    /* we already necessarily have a reference on kernel32.dll. */
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezltRgzbQhYRuNaQYRJ, L"Kernel32.dll"
#ifdef _M_IX86
             , IsolationAwarePrivatezltRgzbQhYRuNaQYRn, "Kernel32.dll"
#endif
    };
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    return IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define ActivateActCtx IsolationAwareActivateActCtx
#define CreateActCtxW IsolationAwareCreateActCtxW
#define DeactivateActCtx IsolationAwareDeactivateActCtx
#define FindActCtxSectionStringW IsolationAwareFindActCtxSectionStringW
#define LoadLibraryA IsolationAwareLoadLibraryA
#define LoadLibraryExA IsolationAwareLoadLibraryExA
#define LoadLibraryExW IsolationAwareLoadLibraryExW
#define LoadLibraryW IsolationAwareLoadLibraryW
#define QueryActCtxW IsolationAwareQueryActCtxW
#define ReleaseActCtx IsolationAwareReleaseActCtx

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */


#if defined(__cplusplus)
} /* __cplusplus */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinBase.h ===
/************************************************************************
*                                                                       *
*   winbase.h -- This module defines the 32-Bit Windows Base APIs       *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/
#ifndef _WINBASE_
#define _WINBASE_


#if _MSC_VER > 1000
#pragma once
#endif

#ifdef _MAC
#include <macwin32.h>
#endif //_MAC

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_ADVAPI32_)
#define WINADVAPI DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif

#if !defined(_KERNEL32_)
#define WINBASEAPI DECLSPEC_IMPORT
#else
#define WINBASEAPI
#endif

#if !defined(_ZAWPROXY_)
#define ZAWPROXYAPI DECLSPEC_IMPORT
#else
#define ZAWPROXYAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Compatibility macros
 */

#define DefineHandleTable(w)            ((w),TRUE)
#define LimitEmsPages(dw)
#define SetSwapAreaSize(w)              (w)
#define LockSegment(w)                  GlobalFix((HANDLE)(w))
#define UnlockSegment(w)                GlobalUnfix((HANDLE)(w))
#define GetCurrentTime()                GetTickCount()

#define Yield()

#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)
#define INVALID_SET_FILE_POINTER ((DWORD)-1)
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)

#define FILE_BEGIN           0
#define FILE_CURRENT         1
#define FILE_END             2

#define TIME_ZONE_ID_INVALID ((DWORD)0xFFFFFFFF)

#define WAIT_FAILED ((DWORD)0xFFFFFFFF)
#define WAIT_OBJECT_0       ((STATUS_WAIT_0 ) + 0 )

#define WAIT_ABANDONED         ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_ABANDONED_0       ((STATUS_ABANDONED_WAIT_0 ) + 0 )

#define WAIT_IO_COMPLETION                  STATUS_USER_APC
#define STILL_ACTIVE                        STATUS_PENDING
#define EXCEPTION_ACCESS_VIOLATION          STATUS_ACCESS_VIOLATION
#define EXCEPTION_DATATYPE_MISALIGNMENT     STATUS_DATATYPE_MISALIGNMENT
#define EXCEPTION_BREAKPOINT                STATUS_BREAKPOINT
#define EXCEPTION_SINGLE_STEP               STATUS_SINGLE_STEP
#define EXCEPTION_ARRAY_BOUNDS_EXCEEDED     STATUS_ARRAY_BOUNDS_EXCEEDED
#define EXCEPTION_FLT_DENORMAL_OPERAND      STATUS_FLOAT_DENORMAL_OPERAND
#define EXCEPTION_FLT_DIVIDE_BY_ZERO        STATUS_FLOAT_DIVIDE_BY_ZERO
#define EXCEPTION_FLT_INEXACT_RESULT        STATUS_FLOAT_INEXACT_RESULT
#define EXCEPTION_FLT_INVALID_OPERATION     STATUS_FLOAT_INVALID_OPERATION
#define EXCEPTION_FLT_OVERFLOW              STATUS_FLOAT_OVERFLOW
#define EXCEPTION_FLT_STACK_CHECK           STATUS_FLOAT_STACK_CHECK
#define EXCEPTION_FLT_UNDERFLOW             STATUS_FLOAT_UNDERFLOW
#define EXCEPTION_INT_DIVIDE_BY_ZERO        STATUS_INTEGER_DIVIDE_BY_ZERO
#define EXCEPTION_INT_OVERFLOW              STATUS_INTEGER_OVERFLOW
#define EXCEPTION_PRIV_INSTRUCTION          STATUS_PRIVILEGED_INSTRUCTION
#define EXCEPTION_IN_PAGE_ERROR             STATUS_IN_PAGE_ERROR
#define EXCEPTION_ILLEGAL_INSTRUCTION       STATUS_ILLEGAL_INSTRUCTION
#define EXCEPTION_NONCONTINUABLE_EXCEPTION  STATUS_NONCONTINUABLE_EXCEPTION
#define EXCEPTION_STACK_OVERFLOW            STATUS_STACK_OVERFLOW
#define EXCEPTION_INVALID_DISPOSITION       STATUS_INVALID_DISPOSITION
#define EXCEPTION_GUARD_PAGE                STATUS_GUARD_PAGE_VIOLATION
#define EXCEPTION_INVALID_HANDLE            STATUS_INVALID_HANDLE
#define EXCEPTION_POSSIBLE_DEADLOCK         STATUS_POSSIBLE_DEADLOCK
#define CONTROL_C_EXIT                      STATUS_CONTROL_C_EXIT

#define MoveMemory RtlMoveMemory
#define CopyMemory RtlCopyMemory
#define FillMemory RtlFillMemory
#define ZeroMemory RtlZeroMemory
#define SecureZeroMemory RtlSecureZeroMemory
#define CaptureStackBackTrace RtlCaptureStackBackTrace

//
// File creation flags must start at the high end since they
// are combined with the attributes
//

#define FILE_FLAG_WRITE_THROUGH         0x80000000
#define FILE_FLAG_OVERLAPPED            0x40000000
#define FILE_FLAG_NO_BUFFERING          0x20000000
#define FILE_FLAG_RANDOM_ACCESS         0x10000000
#define FILE_FLAG_SEQUENTIAL_SCAN       0x08000000
#define FILE_FLAG_DELETE_ON_CLOSE       0x04000000
#define FILE_FLAG_BACKUP_SEMANTICS      0x02000000
#define FILE_FLAG_POSIX_SEMANTICS       0x01000000
#define FILE_FLAG_OPEN_REPARSE_POINT    0x00200000
#define FILE_FLAG_OPEN_NO_RECALL        0x00100000
#define FILE_FLAG_FIRST_PIPE_INSTANCE   0x00080000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

#if(_WIN32_WINNT >= 0x0400)
//
// Define possible return codes from the CopyFileEx callback routine
//

#define PROGRESS_CONTINUE   0
#define PROGRESS_CANCEL     1
#define PROGRESS_STOP       2
#define PROGRESS_QUIET      3

//
// Define CopyFileEx callback routine state change values
//

#define CALLBACK_CHUNK_FINISHED         0x00000000
#define CALLBACK_STREAM_SWITCH          0x00000001

//
// Define CopyFileEx option flags
//

#define COPY_FILE_FAIL_IF_EXISTS              0x00000001
#define COPY_FILE_RESTARTABLE                 0x00000002
#define COPY_FILE_OPEN_SOURCE_FOR_WRITE       0x00000004
#define COPY_FILE_ALLOW_DECRYPTED_DESTINATION 0x00000008

//
//  Gap for private copyfile flags
//

#if (_WIN32_WINNT >= 0x0600)
#define COPY_FILE_COPY_SYMLINK                0x00000800
#define COPY_FILE_NO_BUFFERING                0x00001000
#endif
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0500)
//
// Define ReplaceFile option flags
//

#define REPLACEFILE_WRITE_THROUGH       0x00000001
#define REPLACEFILE_IGNORE_MERGE_ERRORS 0x00000002

#if (_WIN32_WINNT >= 0x0600)
#define REPLACEFILE_IGNORE_ACL_ERRORS   0x00000004
#endif

#endif // #if (_WIN32_WINNT >= 0x0500)

//
// Define the NamedPipe definitions
//


//
// Define the dwOpenMode values for CreateNamedPipe
//

#define PIPE_ACCESS_INBOUND         0x00000001
#define PIPE_ACCESS_OUTBOUND        0x00000002
#define PIPE_ACCESS_DUPLEX          0x00000003

//
// Define the Named Pipe End flags for GetNamedPipeInfo
//

#define PIPE_CLIENT_END             0x00000000
#define PIPE_SERVER_END             0x00000001

//
// Define the dwPipeMode values for CreateNamedPipe
//

#define PIPE_WAIT                   0x00000000
#define PIPE_NOWAIT                 0x00000001
#define PIPE_READMODE_BYTE          0x00000000
#define PIPE_READMODE_MESSAGE       0x00000002
#define PIPE_TYPE_BYTE              0x00000000
#define PIPE_TYPE_MESSAGE           0x00000004
#define PIPE_ACCEPT_REMOTE_CLIENTS  0x00000000
#define PIPE_REJECT_REMOTE_CLIENTS  0x00000008

//
// Define the well known values for CreateNamedPipe nMaxInstances
//

#define PIPE_UNLIMITED_INSTANCES    255

//
// Define the Security Quality of Service bits to be passed
// into CreateFile
//

#define SECURITY_ANONYMOUS          ( SecurityAnonymous      << 16 )
#define SECURITY_IDENTIFICATION     ( SecurityIdentification << 16 )
#define SECURITY_IMPERSONATION      ( SecurityImpersonation  << 16 )
#define SECURITY_DELEGATION         ( SecurityDelegation     << 16 )

#define SECURITY_CONTEXT_TRACKING  0x00040000
#define SECURITY_EFFECTIVE_ONLY    0x00080000

#define SECURITY_SQOS_PRESENT      0x00100000
#define SECURITY_VALID_SQOS_FLAGS  0x001F0000

//
//  File structures
//

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        } DUMMYSTRUCTNAME;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;

typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

//
//  File System time stamps are represented with the following structure:
//


#ifndef _FILETIME_
#define _FILETIME_
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;
#endif

//
// System time is represented with the following structure:
//


typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;


typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

#if(_WIN32_WINNT >= 0x0400)
typedef VOID (WINAPI *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;
#endif /* _WIN32_WINNT >= 0x0400 */

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

#if (_WIN32_WINNT >= 0x0600)

//
// Define one-time initialization primitive
//

typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;

#define INIT_ONCE_STATIC_INIT   RTL_RUN_ONCE_INIT

//
// Run once flags
//

#define INIT_ONCE_CHECK_ONLY        RTL_RUN_ONCE_CHECK_ONLY
#define INIT_ONCE_ASYNC             RTL_RUN_ONCE_ASYNC
#define INIT_ONCE_INIT_FAILED       RTL_RUN_ONCE_INIT_FAILED

//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//

#define INIT_ONCE_CTX_RESERVED_BITS RTL_RUN_ONCE_CTX_RESERVED_BITS

//
// FailFast Exception Flags
//

#define FAIL_FAST_GENERATE_EXCEPTION_ADDRESS    0x1
#define FAIL_FAST_NO_HARD_ERROR_DLG             0x2

typedef
BOOL
(WINAPI *PINIT_ONCE_FN) (
    __inout PINIT_ONCE InitOnce,
    __inout_opt PVOID Parameter,
    __deref_opt_out_opt PVOID *Context
    );

WINBASEAPI
VOID
WINAPI
InitOnceInitialize (
    __out PINIT_ONCE InitOnce
    );

WINBASEAPI
BOOL
WINAPI
InitOnceExecuteOnce (
    __inout PINIT_ONCE InitOnce,
    __in __callback PINIT_ONCE_FN InitFn,
    __inout_opt PVOID Parameter,
    __deref_opt_out_opt LPVOID *Context
    );

WINBASEAPI
BOOL
WINAPI
InitOnceBeginInitialize (
    __inout LPINIT_ONCE lpInitOnce,
    __in DWORD dwFlags,
    __out PBOOL fPending,
    __deref_opt_out_opt LPVOID *lpContext
    );

WINBASEAPI
BOOL
WINAPI
InitOnceComplete (
    __inout LPINIT_ONCE lpInitOnce,
    __in DWORD dwFlags,
    __in_opt LPVOID lpContext
    );

#endif

//
// Define the slim r/w lock
//

typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;

#define SRWLOCK_INIT RTL_SRWLOCK_INIT

WINBASEAPI
VOID
WINAPI
InitializeSRWLock (
     __out PSRWLOCK SRWLock
     );

WINBASEAPI
VOID
WINAPI
ReleaseSRWLockExclusive (
     __inout PSRWLOCK SRWLock
     );

WINBASEAPI
VOID
WINAPI
ReleaseSRWLockShared (
     __inout PSRWLOCK SRWLock
     );

WINBASEAPI
VOID
WINAPI
AcquireSRWLockExclusive (
     __inout PSRWLOCK SRWLock
     );

WINBASEAPI
VOID
WINAPI
AcquireSRWLockShared (
     __inout PSRWLOCK SRWLock
     );

WINBASEAPI
BOOLEAN
WINAPI
TryAcquireSRWLockExclusive (
    __inout PSRWLOCK SRWLock
    );

WINBASEAPI
BOOLEAN
WINAPI
TryAcquireSRWLockShared (
    __inout PSRWLOCK SRWLock
    );

//
// Define condition variable
//

typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;

WINBASEAPI
VOID
WINAPI
InitializeConditionVariable (
    __out PCONDITION_VARIABLE ConditionVariable
    );

WINBASEAPI
VOID
WINAPI
WakeConditionVariable (
    __inout PCONDITION_VARIABLE ConditionVariable
    );

WINBASEAPI
VOID
WINAPI
WakeAllConditionVariable (
    __inout PCONDITION_VARIABLE ConditionVariable
    );

WINBASEAPI
BOOL
WINAPI
SleepConditionVariableCS (
    __inout PCONDITION_VARIABLE ConditionVariable,
    __inout PCRITICAL_SECTION CriticalSection,
    __in DWORD dwMilliseconds
    );

WINBASEAPI
BOOL
WINAPI
SleepConditionVariableSRW (
    __inout PCONDITION_VARIABLE ConditionVariable,
    __inout PSRWLOCK SRWLock,
    __in DWORD dwMilliseconds,
    __in ULONG Flags
    );

//
// Static initializer for the condition variable
//

#define CONDITION_VARIABLE_INIT RTL_CONDITION_VARIABLE_INIT

//
// Flags for condition variables
//
#define CONDITION_VARIABLE_LOCKMODE_SHARED RTL_CONDITION_VARIABLE_LOCKMODE_SHARED


WINBASEAPI
__out_opt
PVOID
WINAPI
EncodePointer (
    __in_opt PVOID Ptr
    );

WINBASEAPI
__out_opt
PVOID
WINAPI
DecodePointer (
    __in_opt PVOID Ptr
    );

WINBASEAPI
__out_opt
PVOID
WINAPI
EncodeSystemPointer (
    __in_opt PVOID Ptr
    );

WINBASEAPI
__out_opt
PVOID
WINAPI
DecodeSystemPointer (
    __in_opt PVOID Ptr
    );

#if defined(_X86_)
typedef PLDT_ENTRY LPLDT_ENTRY;
#else
typedef LPVOID LPLDT_ENTRY;
#endif

#define MUTEX_MODIFY_STATE MUTANT_QUERY_STATE
#define MUTEX_ALL_ACCESS MUTANT_ALL_ACCESS

//
// Serial provider type.
//

#define SP_SERIALCOMM    ((DWORD)0x00000001)

//
// Provider SubTypes
//

#define PST_UNSPECIFIED      ((DWORD)0x00000000)
#define PST_RS232            ((DWORD)0x00000001)
#define PST_PARALLELPORT     ((DWORD)0x00000002)
#define PST_RS422            ((DWORD)0x00000003)
#define PST_RS423            ((DWORD)0x00000004)
#define PST_RS449            ((DWORD)0x00000005)
#define PST_MODEM            ((DWORD)0x00000006)
#define PST_FAX              ((DWORD)0x00000021)
#define PST_SCANNER          ((DWORD)0x00000022)
#define PST_NETWORK_BRIDGE   ((DWORD)0x00000100)
#define PST_LAT              ((DWORD)0x00000101)
#define PST_TCPIP_TELNET     ((DWORD)0x00000102)
#define PST_X25              ((DWORD)0x00000103)


//
// Provider capabilities flags.
//

#define PCF_DTRDSR        ((DWORD)0x0001)
#define PCF_RTSCTS        ((DWORD)0x0002)
#define PCF_RLSD          ((DWORD)0x0004)
#define PCF_PARITY_CHECK  ((DWORD)0x0008)
#define PCF_XONXOFF       ((DWORD)0x0010)
#define PCF_SETXCHAR      ((DWORD)0x0020)
#define PCF_TOTALTIMEOUTS ((DWORD)0x0040)
#define PCF_INTTIMEOUTS   ((DWORD)0x0080)
#define PCF_SPECIALCHARS  ((DWORD)0x0100)
#define PCF_16BITMODE     ((DWORD)0x0200)

//
// Comm provider settable parameters.
//

#define SP_PARITY         ((DWORD)0x0001)
#define SP_BAUD           ((DWORD)0x0002)
#define SP_DATABITS       ((DWORD)0x0004)
#define SP_STOPBITS       ((DWORD)0x0008)
#define SP_HANDSHAKING    ((DWORD)0x0010)
#define SP_PARITY_CHECK   ((DWORD)0x0020)
#define SP_RLSD           ((DWORD)0x0040)

//
// Settable baud rates in the provider.
//

#define BAUD_075          ((DWORD)0x00000001)
#define BAUD_110          ((DWORD)0x00000002)
#define BAUD_134_5        ((DWORD)0x00000004)
#define BAUD_150          ((DWORD)0x00000008)
#define BAUD_300          ((DWORD)0x00000010)
#define BAUD_600          ((DWORD)0x00000020)
#define BAUD_1200         ((DWORD)0x00000040)
#define BAUD_1800         ((DWORD)0x00000080)
#define BAUD_2400         ((DWORD)0x00000100)
#define BAUD_4800         ((DWORD)0x00000200)
#define BAUD_7200         ((DWORD)0x00000400)
#define BAUD_9600         ((DWORD)0x00000800)
#define BAUD_14400        ((DWORD)0x00001000)
#define BAUD_19200        ((DWORD)0x00002000)
#define BAUD_38400        ((DWORD)0x00004000)
#define BAUD_56K          ((DWORD)0x00008000)
#define BAUD_128K         ((DWORD)0x00010000)
#define BAUD_115200       ((DWORD)0x00020000)
#define BAUD_57600        ((DWORD)0x00040000)
#define BAUD_USER         ((DWORD)0x10000000)

//
// Settable Data Bits
//

#define DATABITS_5        ((WORD)0x0001)
#define DATABITS_6        ((WORD)0x0002)
#define DATABITS_7        ((WORD)0x0004)
#define DATABITS_8        ((WORD)0x0008)
#define DATABITS_16       ((WORD)0x0010)
#define DATABITS_16X      ((WORD)0x0020)

//
// Settable Stop and Parity bits.
//

#define STOPBITS_10       ((WORD)0x0001)
#define STOPBITS_15       ((WORD)0x0002)
#define STOPBITS_20       ((WORD)0x0004)
#define PARITY_NONE       ((WORD)0x0100)
#define PARITY_ODD        ((WORD)0x0200)
#define PARITY_EVEN       ((WORD)0x0400)
#define PARITY_MARK       ((WORD)0x0800)
#define PARITY_SPACE      ((WORD)0x1000)

typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;

//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//
#define COMMPROP_INITIALIZED ((DWORD)0xE73CF52E)

typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;

//
// DTR Control Flow Values.
//
#define DTR_CONTROL_DISABLE    0x00
#define DTR_CONTROL_ENABLE     0x01
#define DTR_CONTROL_HANDSHAKE  0x02

//
// RTS Control Flow Values
//
#define RTS_CONTROL_DISABLE    0x00
#define RTS_CONTROL_ENABLE     0x01
#define RTS_CONTROL_HANDSHAKE  0x02
#define RTS_CONTROL_TOGGLE     0x03

typedef struct _DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */
    DWORD BaudRate;       /* Baudrate at which running       */
    DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1;     /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2;  /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1;  /* Enable Err Replacement          */
    DWORD fNull: 1;       /* Enable Null stripping           */
    DWORD fRtsControl:2;  /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17;     /* Reserved                        */
    WORD wReserved;       /* Not currently used              */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    char ErrorChar;       /* Error replacement char          */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Received Event character        */
    WORD wReserved1;      /* Fill for now.                   */
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          /* Maximum time between read chars. */
    DWORD ReadTotalTimeoutMultiplier;   /* Multiplier of characters.        */
    DWORD ReadTotalTimeoutConstant;     /* Constant in milliseconds.        */
    DWORD WriteTotalTimeoutMultiplier;  /* Multiplier of characters.        */
    DWORD WriteTotalTimeoutConstant;    /* Constant in milliseconds.        */
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;               /* Size of the entire struct */
    WORD wVersion;              /* version of the structure */
    WORD wReserved;             /* alignment */
    DCB dcb;                    /* device control block */
    DWORD dwProviderSubType;    /* ordinal value for identifying
                                   provider-defined data structure format*/
    DWORD dwProviderOffset;     /* Specifies the offset of provider specific
                                   data field in bytes from the start */
    DWORD dwProviderSize;       /* size of the provider-specific data field */
    WCHAR wcProviderData[1];    /* provider-specific data */
} COMMCONFIG,*LPCOMMCONFIG;

typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

//
//


#define FreeModule(hLibModule) FreeLibrary((hLibModule))
#define MakeProcInstance(lpProc,hInstance) (lpProc)
#define FreeProcInstance(lpProc) (lpProc)

/* Global Memory Flags */
#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED
#define GMEM_VALID_FLAGS    0x7F72
#define GMEM_INVALID_HANDLE 0x8000

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalLRUNewest( h )    ((HANDLE)(h))
#define GlobalLRUOldest( h )    ((HANDLE)(h))
#define GlobalDiscard( h )      GlobalReAlloc( (h), 0, GMEM_MOVEABLE )

/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED      0x4000
#define GMEM_LOCKCOUNT      0x00FF

typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00
#define LMEM_VALID_FLAGS    0x0F72
#define LMEM_INVALID_HANDLE 0x8000

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

#define LocalDiscard( h )   LocalReAlloc( (h), 0, LMEM_MOVEABLE )

/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

//
// NUMA values
//
#define NUMA_NO_PREFERRED_NODE ((DWORD) -1)

//
// Process dwCreationFlag values
//

#define DEBUG_PROCESS                     0x00000001
#define DEBUG_ONLY_THIS_PROCESS           0x00000002
#define CREATE_SUSPENDED                  0x00000004
#define DETACHED_PROCESS                  0x00000008

#define CREATE_NEW_CONSOLE                0x00000010
#define NORMAL_PRIORITY_CLASS             0x00000020
#define IDLE_PRIORITY_CLASS               0x00000040
#define HIGH_PRIORITY_CLASS               0x00000080

#define REALTIME_PRIORITY_CLASS           0x00000100
#define CREATE_NEW_PROCESS_GROUP          0x00000200
#define CREATE_UNICODE_ENVIRONMENT        0x00000400
#define CREATE_SEPARATE_WOW_VDM           0x00000800

#define CREATE_SHARED_WOW_VDM             0x00001000
#define CREATE_FORCEDOS                   0x00002000
#define BELOW_NORMAL_PRIORITY_CLASS       0x00004000
#define ABOVE_NORMAL_PRIORITY_CLASS       0x00008000

#define INHERIT_PARENT_AFFINITY           0x00010000
#define INHERIT_CALLER_PRIORITY           0x00020000    // Deprecated
#define CREATE_PROTECTED_PROCESS          0x00040000
#define EXTENDED_STARTUPINFO_PRESENT      0x00080000

#define PROCESS_MODE_BACKGROUND_BEGIN     0x00100000
#define PROCESS_MODE_BACKGROUND_END       0x00200000

#define CREATE_BREAKAWAY_FROM_JOB         0x01000000
#define CREATE_PRESERVE_CODE_AUTHZ_LEVEL  0x02000000
#define CREATE_DEFAULT_ERROR_MODE         0x04000000
#define CREATE_NO_WINDOW                  0x08000000

#define PROFILE_USER                      0x10000000
#define PROFILE_KERNEL                    0x20000000
#define PROFILE_SERVER                    0x40000000
#define CREATE_IGNORE_SYSTEM_DEFAULT      0x80000000

//
// Thread dwCreationFlag values
//

//#define CREATE_SUSPENDED                  0x00000004

#define STACK_SIZE_PARAM_IS_A_RESERVATION   0x00010000    // Threads only

//
// Priority flags
//

#define THREAD_PRIORITY_LOWEST          THREAD_BASE_PRIORITY_MIN
#define THREAD_PRIORITY_BELOW_NORMAL    (THREAD_PRIORITY_LOWEST+1)
#define THREAD_PRIORITY_NORMAL          0
#define THREAD_PRIORITY_HIGHEST         THREAD_BASE_PRIORITY_MAX
#define THREAD_PRIORITY_ABOVE_NORMAL    (THREAD_PRIORITY_HIGHEST-1)
#define THREAD_PRIORITY_ERROR_RETURN    (MAXLONG)

#define THREAD_PRIORITY_TIME_CRITICAL   THREAD_BASE_PRIORITY_LOWRT
#define THREAD_PRIORITY_IDLE            THREAD_BASE_PRIORITY_IDLE

#define THREAD_MODE_BACKGROUND_BEGIN    0x00010000
#define THREAD_MODE_BACKGROUND_END      0x00020000

//
// GetFinalPathNameByHandle
//

#define VOLUME_NAME_DOS  0x0      //default
#define VOLUME_NAME_GUID 0x1
#define VOLUME_NAME_NT   0x2
#define VOLUME_NAME_NONE 0x4

#define FILE_NAME_NORMALIZED 0x0  //default
#define FILE_NAME_OPENED     0x8

//
// Debug APIs
//
#define EXCEPTION_DEBUG_EVENT       1
#define CREATE_THREAD_DEBUG_EVENT   2
#define CREATE_PROCESS_DEBUG_EVENT  3
#define EXIT_THREAD_DEBUG_EVENT     4
#define EXIT_PROCESS_DEBUG_EVENT    5
#define LOAD_DLL_DEBUG_EVENT        6
#define UNLOAD_DLL_DEBUG_EVENT      7
#define OUTPUT_DEBUG_STRING_EVENT   8
#define RIP_EVENT                   9

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;

//
// JIT Debugging Info. This structure is defined to have constant size in
// both the emulated and native environment.
//

typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;

typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;

#if !defined(MIDL_PASS)
typedef PCONTEXT LPCONTEXT;
typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
#endif

#define DRIVE_UNKNOWN     0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED       3
#define DRIVE_REMOTE      4
#define DRIVE_CDROM       5
#define DRIVE_RAMDISK     6


#ifndef _MAC
#define GetFreeSpace(w)                 (0x100000L)
#else
WINBASEAPI DWORD WINAPI GetFreeSpace(__in UINT);
#endif


#define FILE_TYPE_UNKNOWN   0x0000
#define FILE_TYPE_DISK      0x0001
#define FILE_TYPE_CHAR      0x0002
#define FILE_TYPE_PIPE      0x0003
#define FILE_TYPE_REMOTE    0x8000


#define STD_INPUT_HANDLE    ((DWORD)-10)
#define STD_OUTPUT_HANDLE   ((DWORD)-11)
#define STD_ERROR_HANDLE    ((DWORD)-12)

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0       // Ignore signal
#define INFINITE            0xFFFFFFFF  // Infinite timeout

//
// Baud rates at which the communication device operates
//

#define CBR_110             110
#define CBR_300             300
#define CBR_600             600
#define CBR_1200            1200
#define CBR_2400            2400
#define CBR_4800            4800
#define CBR_9600            9600
#define CBR_14400           14400
#define CBR_19200           19200
#define CBR_38400           38400
#define CBR_56000           56000
#define CBR_57600           57600
#define CBR_115200          115200
#define CBR_128000          128000
#define CBR_256000          256000

//
// Error Flags
//

#define CE_RXOVER           0x0001  // Receive Queue overflow
#define CE_OVERRUN          0x0002  // Receive Overrun Error
#define CE_RXPARITY         0x0004  // Receive Parity Error
#define CE_FRAME            0x0008  // Receive Framing error
#define CE_BREAK            0x0010  // Break Detected
#define CE_TXFULL           0x0100  // TX Queue is full
#define CE_PTO              0x0200  // LPTx Timeout
#define CE_IOE              0x0400  // LPTx I/O Error
#define CE_DNS              0x0800  // LPTx Device not selected
#define CE_OOP              0x1000  // LPTx Out-Of-Paper
#define CE_MODE             0x8000  // Requested mode unsupported

#define IE_BADID            (-1)    // Invalid or unsupported id
#define IE_OPEN             (-2)    // Device Already Open
#define IE_NOPEN            (-3)    // Device Not Open
#define IE_MEMORY           (-4)    // Unable to allocate queues
#define IE_DEFAULT          (-5)    // Error in default parameters
#define IE_HARDWARE         (-10)   // Hardware Not Present
#define IE_BYTESIZE         (-11)   // Illegal Byte Size
#define IE_BAUDRATE         (-12)   // Unsupported BaudRate

//
// Events
//

#define EV_RXCHAR           0x0001  // Any Character received
#define EV_RXFLAG           0x0002  // Received certain character
#define EV_TXEMPTY          0x0004  // Transmitt Queue Empty
#define EV_CTS              0x0008  // CTS changed state
#define EV_DSR              0x0010  // DSR changed state
#define EV_RLSD             0x0020  // RLSD changed state
#define EV_BREAK            0x0040  // BREAK received
#define EV_ERR              0x0080  // Line status error occurred
#define EV_RING             0x0100  // Ring signal detected
#define EV_PERR             0x0200  // Printer error occured
#define EV_RX80FULL         0x0400  // Receive buffer is 80 percent full
#define EV_EVENT1           0x0800  // Provider specific event 1
#define EV_EVENT2           0x1000  // Provider specific event 2

//
// Escape Functions
//

#define SETXOFF             1       // Simulate XOFF received
#define SETXON              2       // Simulate XON received
#define SETRTS              3       // Set RTS high
#define CLRRTS              4       // Set RTS low
#define SETDTR              5       // Set DTR high
#define CLRDTR              6       // Set DTR low
#define RESETDEV            7       // Reset device if possible
#define SETBREAK            8       // Set the device break line.
#define CLRBREAK            9       // Clear the device break line.

//
// PURGE function flags.
//
#define PURGE_TXABORT       0x0001  // Kill the pending/current writes to the comm port.
#define PURGE_RXABORT       0x0002  // Kill the pending/current reads to the comm port.
#define PURGE_TXCLEAR       0x0004  // Kill the transmit queue if there.
#define PURGE_RXCLEAR       0x0008  // Kill the typeahead buffer if there.

#define LPTx                0x80    // Set if ID is for LPT device

//
// Modem Status Flags
//
#define MS_CTS_ON           ((DWORD)0x0010)
#define MS_DSR_ON           ((DWORD)0x0020)
#define MS_RING_ON          ((DWORD)0x0040)
#define MS_RLSD_ON          ((DWORD)0x0080)

//
// WaitSoundState() Constants
//

#define S_QUEUEEMPTY        0
#define S_THRESHOLD         1
#define S_ALLTHRESHOLD      2

//
// Accent Modes
//

#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

//
// SetSoundNoise() Sources
//

#define S_PERIOD512   0     // Freq = N/512 high pitch, less coarse hiss
#define S_PERIOD1024  1     // Freq = N/1024
#define S_PERIOD2048  2     // Freq = N/2048 low pitch, more coarse hiss
#define S_PERIODVOICE 3     // Source is frequency from voice channel (3)
#define S_WHITE512    4     // Freq = N/512 high pitch, less coarse hiss
#define S_WHITE1024   5     // Freq = N/1024
#define S_WHITE2048   6     // Freq = N/2048 low pitch, more coarse hiss
#define S_WHITEVOICE  7     // Source is frequency from voice channel (3)

#define S_SERDVNA     (-1)  // Device not available
#define S_SEROFM      (-2)  // Out of memory
#define S_SERMACT     (-3)  // Music active
#define S_SERQFUL     (-4)  // Queue full
#define S_SERBDNT     (-5)  // Invalid note
#define S_SERDLN      (-6)  // Invalid note length
#define S_SERDCC      (-7)  // Invalid note count
#define S_SERDTP      (-8)  // Invalid tempo
#define S_SERDVL      (-9)  // Invalid volume
#define S_SERDMD      (-10) // Invalid mode
#define S_SERDSH      (-11) // Invalid shape
#define S_SERDPT      (-12) // Invalid pitch
#define S_SERDFQ      (-13) // Invalid frequency
#define S_SERDDR      (-14) // Invalid duration
#define S_SERDSR      (-15) // Invalid source
#define S_SERDST      (-16) // Invalid state

#define NMPWAIT_WAIT_FOREVER            0xffffffff
#define NMPWAIT_NOWAIT                  0x00000001
#define NMPWAIT_USE_DEFAULT_WAIT        0x00000000

#define FS_CASE_IS_PRESERVED            FILE_CASE_PRESERVED_NAMES
#define FS_CASE_SENSITIVE               FILE_CASE_SENSITIVE_SEARCH
#define FS_UNICODE_STORED_ON_DISK       FILE_UNICODE_ON_DISK
#define FS_PERSISTENT_ACLS              FILE_PERSISTENT_ACLS
#define FS_VOL_IS_COMPRESSED            FILE_VOLUME_IS_COMPRESSED
#define FS_FILE_COMPRESSION             FILE_FILE_COMPRESSION
#define FS_FILE_ENCRYPTION              FILE_SUPPORTS_ENCRYPTION

#define FILE_MAP_COPY       SECTION_QUERY
#define FILE_MAP_WRITE      SECTION_MAP_WRITE
#define FILE_MAP_READ       SECTION_MAP_READ
#define FILE_MAP_ALL_ACCESS SECTION_ALL_ACCESS
#define FILE_MAP_EXECUTE    SECTION_MAP_EXECUTE_EXPLICIT    // not included in FILE_MAP_ALL_ACCESS

#define OF_READ             0x00000000
#define OF_WRITE            0x00000001
#define OF_READWRITE        0x00000002
#define OF_SHARE_COMPAT     0x00000000
#define OF_SHARE_EXCLUSIVE  0x00000010
#define OF_SHARE_DENY_WRITE 0x00000020
#define OF_SHARE_DENY_READ  0x00000030
#define OF_SHARE_DENY_NONE  0x00000040
#define OF_PARSE            0x00000100
#define OF_DELETE           0x00000200
#define OF_VERIFY           0x00000400
#define OF_CANCEL           0x00000800
#define OF_CREATE           0x00001000
#define OF_PROMPT           0x00002000
#define OF_EXIST            0x00004000
#define OF_REOPEN           0x00008000

#define OFS_MAXPATHNAME 128
typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[OFS_MAXPATHNAME];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;

#ifndef NOWINBASEINTERLOCK

#ifndef _NTOS_

#if defined(_M_IA64) && !defined(RC_INVOKED)

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedIncrementAcquire _InterlockedIncrement_acq
#define InterlockedIncrementRelease _InterlockedIncrement_rel
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedDecrementAcquire _InterlockedDecrement_acq
#define InterlockedDecrementRelease _InterlockedDecrement_rel
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire _InterlockedCompareExchange_acq
#define InterlockedCompareExchangeRelease _InterlockedCompareExchange_rel
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer_rel
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer_acq

#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAcquire64 _InterlockedExchange64_acq
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 _InterlockedCompareExchange64_acq
#define InterlockedCompareExchangeRelease64 _InterlockedCompareExchange64_rel
#define InterlockedCompare64Exchange128     _InterlockedCompare64Exchange128
#define InterlockedCompare64ExchangeAcquire128  _InterlockedCompare64Exchange128_acq
#define InterlockedCompare64ExchangeRelease128  _InterlockedCompare64Exchange128_rel

#define InterlockedOr _InterlockedOr
#define InterlockedOrAcquire _InterlockedOr_acq
#define InterlockedOrRelease _InterlockedOr_rel
#define InterlockedOr8 _InterlockedOr8
#define InterlockedOr8Acquire _InterlockedOr8_acq
#define InterlockedOr8Release _InterlockedOr8_rel
#define InterlockedOr16 _InterlockedOr16
#define InterlockedOr16Acquire _InterlockedOr16_acq
#define InterlockedOr16Release _InterlockedOr16_rel
#define InterlockedOr64 _InterlockedOr64
#define InterlockedOr64Acquire _InterlockedOr64_acq
#define InterlockedOr64Release _InterlockedOr64_rel
#define InterlockedXor _InterlockedXor
#define InterlockedXorAcquire _InterlockedXor_acq
#define InterlockedXorRelease _InterlockedXor_rel
#define InterlockedXor8 _InterlockedXor8
#define InterlockedXor8Acquire _InterlockedXor8_acq
#define InterlockedXor8Release _InterlockedXor8_rel
#define InterlockedXor16 _InterlockedXor16
#define InterlockedXor16Acquire _InterlockedXor16_acq
#define InterlockedXor16Release _InterlockedXor16_rel
#define InterlockedXor64 _InterlockedXor64
#define InterlockedXor64Acquire _InterlockedXor64_acq
#define InterlockedXor64Release _InterlockedXor64_rel
#define InterlockedAnd _InterlockedAnd
#define InterlockedAndAcquire _InterlockedAnd_acq
#define InterlockedAndRelease _InterlockedAnd_rel
#define InterlockedAnd8 _InterlockedAnd8
#define InterlockedAnd8Acquire _InterlockedAnd8_acq
#define InterlockedAnd8Release _InterlockedAnd8_rel
#define InterlockedAnd16 _InterlockedAnd16
#define InterlockedAnd16Acquire _InterlockedAnd16_acq
#define InterlockedAnd16Release _InterlockedAnd16_rel
#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedAnd64Acquire _InterlockedAnd64_acq
#define InterlockedAnd64Release _InterlockedAnd64_rel

LONG
__cdecl
InterlockedOr (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

LONG
__cdecl
InterlockedOrAcquire (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

LONG
__cdecl
InterlockedOrRelease (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

char
__cdecl
InterlockedOr8 (
    __inout char volatile *Destination,
    __in    char Value
    );

char
__cdecl
InterlockedOr8Acquire (
    __inout char volatile *Destination,
    __in    char Value
    );

char
__cdecl
InterlockedOr8Release (
    __inout char volatile *Destination,
    __in    char Value
    );

SHORT
__cdecl
InterlockedOr16(
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

SHORT
__cdecl
InterlockedOr16Acquire (
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

SHORT
__cdecl
InterlockedOr16Release (
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

LONGLONG
__cdecl
InterlockedOr64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedOr64Acquire (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedOr64Release (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONG
__cdecl
InterlockedXor (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

LONG
__cdecl
InterlockedXorAcquire (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

LONG
__cdecl
InterlockedXorRelease (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

char
__cdecl
InterlockedXor8 (
    __inout char volatile *Destination,
    __in    char Value
    );

char
__cdecl
InterlockedXor8Acquire (
    __inout char volatile *Destination,
    __in    char Value
    );

char
__cdecl
InterlockedXor8Release (
    __inout char volatile *Destination,
    __in    char Value
    );

SHORT
__cdecl
InterlockedXor16(
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

SHORT
__cdecl
InterlockedXor16Acquire (
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

SHORT
__cdecl
InterlockedXor16Release (
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

LONGLONG
__cdecl
InterlockedXor64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedXor64Acquire (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedXor64Release (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONG
__cdecl
InterlockedAnd (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

LONG
__cdecl
InterlockedAndAcquire (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

LONG
__cdecl
InterlockedAndRelease (
    __inout LONG volatile *Destination,
    __in    LONG Value
    );

char
__cdecl
InterlockedAnd8 (
    __inout char volatile *Destination,
    __in    char Value
    );

char
__cdecl
InterlockedAnd8Acquire (
    __inout char volatile *Destination,
    __in    char Value
    );

char
__cdecl
InterlockedAnd8Release (
    __inout char volatile *Destination,
    __in    char Value
    );

SHORT
__cdecl
InterlockedAnd16(
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

SHORT
__cdecl
InterlockedAnd16Acquire (
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

SHORT
__cdecl
InterlockedAnd16Release (
    __inout SHORT volatile *Destination,
    __in    SHORT Value
    );

LONGLONG
__cdecl
InterlockedAnd64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAnd64Acquire (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedAnd64Release (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedIncrement64 (
    __inout LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64 (
    __inout LONGLONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementAcquire (
    __inout LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementAcquire (
    __inout LONG volatile *Addend
    );

LONG
__cdecl
InterlockedIncrementRelease (
    __inout LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrementRelease (
    __inout LONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedExchange64 (
    __inout LONGLONG volatile *Target,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAcquire64 (
    __inout LONGLONG volatile *Target,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64 (
    __inout LONGLONG volatile *Addend,
    __in    LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG ExChange,
    __in    LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeAcquire64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG ExChange,
    __in    LONGLONG Comperand
    );

LONGLONG
__cdecl
InterlockedCompareExchangeRelease64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG ExChange,
    __in    LONGLONG Comperand
    );

LONG64
__cdecl
InterlockedCompare64Exchange128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeAcquire128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG64
__cdecl
InterlockedCompare64ExchangeRelease128(
    __inout LONG64 volatile * Destination,
    __in LONG64 ExchangeHigh,
    __in LONG64 ExchangeLow,
    __in LONG64 Comperand
    );

LONG
__cdecl
InterlockedIncrement (
    __inout LONG volatile *lpAddend
    );

LONG
__cdecl
InterlockedDecrement (
    __inout LONG volatile *lpAddend
    );

LONG
__cdecl
InterlockedExchange (
    __inout LONG volatile *Target,
    __in    LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd (
    __inout LONG volatile *Addend,
    __in    LONG Value
    );

LONG
__cdecl
InterlockedCompareExchange (
    __inout LONG volatile *Destination,
    __in    LONG ExChange,
    __in    LONG Comperand
    );

LONG
__cdecl
InterlockedCompareExchangeRelease (
    __inout LONG volatile *Destination,
    __in    LONG ExChange,
    __in    LONG Comperand
    );

LONG
__cdecl
InterlockedCompareExchangeAcquire (
    __inout LONG volatile *Destination,
    __in    LONG ExChange,
    __in    LONG Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer (
    __inout  PVOID volatile *Target,
    __in_opt PVOID Value
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    __inout  PVOID volatile *Destination,
    __in_opt PVOID ExChange,
    __in_opt PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerAcquire (
    __inout  PVOID volatile *Destination,
    __in_opt PVOID Exchange,
    __in_opt PVOID Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointerRelease (
    __inout  PVOID volatile *Destination,
    __in_opt PVOID Exchange,
    __in_opt PVOID Comperand
    );


#if !defined(MIDL_PASS)

#if !defined (InterlockedAnd)

#define InterlockedAnd InterlockedAnd_Inline

FORCEINLINE
LONG
InterlockedAnd_Inline (
    __inout LONG volatile *Target,
    __in    LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i & Set,
                                       i);

    } while (i != j);

    return j;
}

#endif

#if !defined (InterlockedOr)

#define InterlockedOr InterlockedOr_Inline

FORCEINLINE
LONG
InterlockedOr_Inline (
    __inout LONG volatile *Target,
    __in    LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i | Set,
                                       i);

    } while (i != j);

    return j;
}

#endif

#if !defined (InterlockedXor)

#define InterlockedXor InterlockedXor_Inline

FORCEINLINE
LONG
InterlockedXor_Inline (
    __inout LONG volatile *Target,
    __in    LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i ^ Set,
                                       i);

    } while (i != j);

    return j;
}

#endif

#if !defined (InterlockedAnd64)

#define InterlockedAnd64 InterlockedAnd64_Inline

FORCEINLINE
LONGLONG
InterlockedAnd64_Inline (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

#endif

#if !defined (InterlockedOr64)

#define InterlockedOr64 InterlockedOr64_Inline

FORCEINLINE
LONGLONG
InterlockedOr64_Inline (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

#endif

#if !defined (InterlockedXor64)

#define InterlockedXor64 InterlockedXor64_Inline

FORCEINLINE
LONGLONG
InterlockedXor64_Inline (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

#endif

#if !defined (InterlockedBitTestAndSet)

#define InterlockedBitTestAndSet InterlockedBitTestAndSet_Inline

FORCEINLINE
BOOLEAN
InterlockedBitTestAndSet_Inline (
    __inout LONG volatile *Base,
    __in LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN)((InterlockedOr(&Base[Bit/(sizeof(*Base)*8)], tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndReset)

#define InterlockedBitTestAndReset InterlockedBitTestAndReset_Inline

FORCEINLINE
BOOLEAN
InterlockedBitTestAndReset_Inline (
    __inout LONG volatile *Base,
    __in LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN)((InterlockedAnd(&Base[Bit/(sizeof(*Base)*8)], ~tBit)&tBit) != 0);
}

#endif

#if !defined (InterlockedBitTestAndComplement)

#define InterlockedBitTestAndComplement InterlockedBitTestAndComplement_Inline

FORCEINLINE
BOOLEAN
InterlockedBitTestAndComplement_Inline (
    __inout LONG volatile *Base,
    __in LONG Bit
    )
{
    LONG tBit;

    tBit = 1<<(Bit & (sizeof (*Base)*8-1));
    return (BOOLEAN)((InterlockedXor(&Base[Bit/(sizeof(*Base)*8)], tBit)&tBit) != 0);
}

#endif
#endif

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedIncrement_acq)
#pragma intrinsic(_InterlockedIncrement_rel)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedDecrement_acq)
#pragma intrinsic(_InterlockedDecrement_rel)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedCompareExchange_acq)
#pragma intrinsic(_InterlockedCompareExchange_rel)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer_acq)
#pragma intrinsic(_InterlockedCompareExchangePointer_rel)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedCompareExchange64_acq)
#pragma intrinsic(_InterlockedCompareExchange64_rel)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic (_InterlockedOr)
#pragma intrinsic (_InterlockedOr_acq)
#pragma intrinsic (_InterlockedOr_rel)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedOr8_acq)
#pragma intrinsic (_InterlockedOr8_rel)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedOr16_acq)
#pragma intrinsic (_InterlockedOr16_rel)
#pragma intrinsic (_InterlockedOr64)
#pragma intrinsic (_InterlockedOr64_acq)
#pragma intrinsic (_InterlockedOr64_rel)
#pragma intrinsic (_InterlockedXor)
#pragma intrinsic (_InterlockedXor_acq)
#pragma intrinsic (_InterlockedXor_rel)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedXor8_acq)
#pragma intrinsic (_InterlockedXor8_rel)
#pragma intrinsic (_InterlockedXor16)
#pragma intrinsic (_InterlockedXor16_acq)
#pragma intrinsic (_InterlockedXor16_rel)
#pragma intrinsic (_InterlockedXor64)
#pragma intrinsic (_InterlockedXor64_acq)
#pragma intrinsic (_InterlockedXor64_rel)
#pragma intrinsic (_InterlockedAnd)
#pragma intrinsic (_InterlockedAnd_acq)
#pragma intrinsic (_InterlockedAnd_rel)
#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedAnd8_acq)
#pragma intrinsic (_InterlockedAnd8_rel)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedAnd16_acq)
#pragma intrinsic (_InterlockedAnd16_rel)
#pragma intrinsic (_InterlockedAnd64)
#pragma intrinsic (_InterlockedAnd64_acq)
#pragma intrinsic (_InterlockedAnd64_rel)

#elif defined(_M_AMD64) && !defined(RC_INVOKED)

#define InterlockedAnd _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerAcquire _InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease _InterlockedCompareExchangePointer

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64


LONG
InterlockedAnd (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedOr (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedXor (
    __inout LONG volatile *Destination,
    __in LONG Value
    );

LONG
InterlockedIncrement (
    __inout LONG volatile *Addend
    );

LONG
InterlockedDecrement (
    __inout LONG volatile *Addend
    );

LONG
InterlockedExchange (
    __inout LONG volatile *Target,
    __in LONG Value
    );

LONG
InterlockedExchangeAdd (
    __inout LONG volatile *Addend,
    __in LONG Value
    );

LONG
InterlockedCompareExchange (
    __inout LONG volatile *Destination,
    __in LONG ExChange,
    __in LONG Comperand
    );

PVOID
InterlockedCompareExchangePointer (
    __inout  PVOID volatile *Destination,
    __in_opt PVOID Exchange,
    __in_opt PVOID Comperand
    );

PVOID
InterlockedExchangePointer (
    __inout  PVOID volatile *Target,
    __in_opt PVOID Value
    );

LONG64
InterlockedAnd64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedOr64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedXor64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 Value
    );

LONG64
InterlockedIncrement64 (
    __inout LONG64 volatile *Addend
    );

LONG64
InterlockedDecrement64 (
    __inout LONG64 volatile *Addend
    );

LONG64
InterlockedExchange64 (
    __inout LONG64 volatile *Target,
    __in LONG64 Value
    );

LONG64
InterlockedExchangeAdd64 (
    __inout LONG64 volatile *Addend,
    __in LONG64 Value
    );

LONG64
InterlockedCompareExchange64 (
    __inout LONG64 volatile *Destination,
    __in LONG64 ExChange,
    __in LONG64 Comperand
    );

#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)

#if _MSC_FULL_VER >= 140041204

#define InterlockedAnd8 _InterlockedAnd8
#define InterlockedOr8 _InterlockedOr8
#define InterlockedXor8 _InterlockedXor8
#define InterlockedAnd16 _InterlockedAnd16
#define InterlockedOr16 _InterlockedOr16
#define InterlockedXor16 _InterlockedXor16

char
InterlockedAnd8 (
    __inout char volatile *Destination,
    __in char Value
    );

char
InterlockedOr8 (
    __inout char volatile *Destination,
    __in char Value
    );

char
InterlockedXor8 (
    __inout char volatile *Destination,
    __in char Value
    );

SHORT
InterlockedAnd16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
InterlockedOr16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );

SHORT
InterlockedXor16(
    __inout SHORT volatile *Destination,
    __in SHORT Value
    );

#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)

#endif

#else           // X86 interlocked definitions

WINBASEAPI
LONG
WINAPI
InterlockedIncrement (
    __inout LONG volatile *lpAddend
    );

WINBASEAPI
LONG
WINAPI
InterlockedDecrement (
    __inout LONG volatile *lpAddend
    );

WINBASEAPI
LONG
WINAPI
InterlockedExchange (
    __inout LONG volatile *Target,
    __in    LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
    (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

WINBASEAPI
LONG
WINAPI
InterlockedExchangeAdd (
    __inout LONG volatile *Addend,
    __in    LONG Value
    );

WINBASEAPI
LONG
WINAPI
InterlockedCompareExchange (
    __inout LONG volatile *Destination,
    __in    LONG Exchange,
    __in    LONG Comperand
    );

#if (_WIN32_WINNT >= 0x0502)

WINBASEAPI
LONGLONG
WINAPI
InterlockedCompareExchange64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Exchange,
    __in    LONGLONG Comperand
    );

#endif

#if !defined(MIDL_PASS)

#if (_WIN32_WINNT >= 0x0502)

FORCEINLINE
LONGLONG
InterlockedAnd64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}

FORCEINLINE
LONGLONG
InterlockedOr64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}

FORCEINLINE
LONGLONG
InterlockedXor64 (
    __inout LONGLONG volatile *Destination,
    __in    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}

FORCEINLINE
LONGLONG
InterlockedIncrement64 (
    __inout LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old + 1,
                                          Old) != Old);

    return Old + 1;
}

FORCEINLINE
LONGLONG
InterlockedDecrement64 (
    __inout LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old - 1,
                                          Old) != Old);

    return Old - 1;
}

FORCEINLINE
LONGLONG
InterlockedExchange64 (
    __inout LONGLONG volatile *Target,
    __in    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Target;
    } while (InterlockedCompareExchange64(Target,
                                          Value,
                                          Old) != Old);

    return Old;
}

FORCEINLINE
LONGLONG
InterlockedExchangeAdd64(
    __inout LONGLONG volatile *Addend,
    __in    LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend,
                                          Old + Value,
                                          Old) != Old);

    return Old;
}

#endif


#endif

//
// Use a function for C++ so X86 will generate the same errors as RISC.
//

#ifdef __cplusplus

FORCEINLINE
PVOID
#if !defined(_M_CEE_PURE)
__cdecl
#endif
__InlineInterlockedCompareExchangePointer (
    __inout  PVOID volatile *Destination,
    __in_opt PVOID ExChange,
    __in_opt PVOID Comperand
    )
{
    return((PVOID)(LONG_PTR)InterlockedCompareExchange((LONG volatile *)Destination, (LONG)(LONG_PTR)ExChange, (LONG)(LONG_PTR)Comperand));
}

#define InterlockedCompareExchangePointer __InlineInterlockedCompareExchangePointer

#else

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)(LONG_PTR)InterlockedCompareExchange((LONG volatile *)(Destination), (LONG)(LONG_PTR)(ExChange), (LONG)(LONG_PTR)(Comperand))

#endif /* __cplusplus */

#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedDecrementAcquire InterlockedDecrement
#define InterlockedDecrementRelease InterlockedDecrement
#define InterlockedIncrementAcquire InterlockedIncrement
#define InterlockedIncrementRelease InterlockedIncrement
#define InterlockedCompareExchangeAcquire InterlockedCompareExchange
#define InterlockedCompareExchangeRelease InterlockedCompareExchange
#define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
#define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64
#define InterlockedCompareExchangePointerAcquire InterlockedCompareExchangePointer
#define InterlockedCompareExchangePointerRelease InterlockedCompareExchangePointer

#endif /* X86 | IA64 */

#if defined(_SLIST_HEADER_) && !defined(_NTOSP_)

WINBASEAPI
VOID
WINAPI
InitializeSListHead (
    __inout PSLIST_HEADER ListHead
    );

WINBASEAPI
PSLIST_ENTRY
WINAPI
InterlockedPopEntrySList (
    __inout PSLIST_HEADER ListHead
    );

WINBASEAPI
PSLIST_ENTRY
WINAPI
InterlockedPushEntrySList (
    __inout PSLIST_HEADER ListHead,
    __inout PSLIST_ENTRY ListEntry
    );

WINBASEAPI
PSLIST_ENTRY
WINAPI
InterlockedFlushSList (
    __inout PSLIST_HEADER ListHead
    );

WINBASEAPI
USHORT
WINAPI
QueryDepthSList (
    __in PSLIST_HEADER ListHead
    );

#endif /* _SLIST_HEADER_ */

#endif /* _NTOS_ */

#endif /* NOWINBASEINTERLOCK */

WINBASEAPI
BOOL
WINAPI
FreeResource(
    __in HGLOBAL hResData
    );

WINBASEAPI
LPVOID
WINAPI
LockResource(
    __in HGLOBAL hResData
    );

#define UnlockResource(hResData) ((hResData), 0)
#define MAXINTATOM 0xC000
#define MAKEINTATOM(i)  (LPTSTR)((ULONG_PTR)((WORD)(i)))
#define INVALID_ATOM ((ATOM)0)

int
#if !defined(_MAC)
#if defined(_M_CEE_PURE)
__clrcall
#else
WINAPI
#endif
#else
CALLBACK
#endif
WinMain (
    __in HINSTANCE hInstance,
    __in_opt HINSTANCE hPrevInstance,
    __in LPSTR lpCmdLine,
    __in int nShowCmd
    );

int
#if defined(_M_CEE_PURE)
__clrcall
#else
WINAPI
#endif
wWinMain(
    __in HINSTANCE hInstance,
    __in_opt HINSTANCE hPrevInstance,
    __in LPWSTR lpCmdLine,
    __in int nShowCmd
    );

WINBASEAPI
BOOL
WINAPI
FreeLibrary (
    __in HMODULE hLibModule
    );


WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
FreeLibraryAndExitThread (
    __in HMODULE hLibModule,
    __in DWORD dwExitCode
    );

WINBASEAPI
BOOL
WINAPI
DisableThreadLibraryCalls (
    __in HMODULE hLibModule
    );

WINBASEAPI
FARPROC
WINAPI
GetProcAddress (
    __in HMODULE hModule,
    __in LPCSTR lpProcName
    );

WINBASEAPI
DWORD
WINAPI
GetVersion (
    VOID
    );

WINBASEAPI
__out_opt
HGLOBAL
WINAPI
GlobalAlloc (
    __in UINT uFlags,
    __in SIZE_T dwBytes
    );

WINBASEAPI
__out_opt
HGLOBAL
WINAPI
GlobalReAlloc (
    __in HGLOBAL hMem,
    __in SIZE_T dwBytes,
    __in UINT uFlags
    );

WINBASEAPI
SIZE_T
WINAPI
GlobalSize (
    __in HGLOBAL hMem
    );

WINBASEAPI
UINT
WINAPI
GlobalFlags (
    __in HGLOBAL hMem
    );

WINBASEAPI
__out_opt
LPVOID
WINAPI
GlobalLock (
    __in HGLOBAL hMem
    );

WINBASEAPI
__out_opt
HGLOBAL
WINAPI
GlobalHandle (
    __in LPCVOID pMem
    );

WINBASEAPI
BOOL
WINAPI
GlobalUnlock(
    __in HGLOBAL hMem
    );

WINBASEAPI
__out_opt
HGLOBAL
WINAPI
GlobalFree(
    __deref HGLOBAL hMem
    );

WINBASEAPI
SIZE_T
WINAPI
GlobalCompact(
    __in DWORD dwMinFree
    );

WINBASEAPI
VOID
WINAPI
GlobalFix(
    __in HGLOBAL hMem
    );

WINBASEAPI
VOID
WINAPI
GlobalUnfix(
    __in HGLOBAL hMem
    );

WINBASEAPI
__out
LPVOID
WINAPI
GlobalWire(
    __in HGLOBAL hMem
    );

WINBASEAPI
BOOL
WINAPI
GlobalUnWire(
    __in HGLOBAL hMem
    );

WINBASEAPI
VOID
WINAPI
GlobalMemoryStatus(
    __out LPMEMORYSTATUS lpBuffer
    );

typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

WINBASEAPI
BOOL
WINAPI
GlobalMemoryStatusEx(
    __out LPMEMORYSTATUSEX lpBuffer
    );

WINBASEAPI
__out_bcount_opt( (uFlags&LMEM_FIXED) ? uBytes : 0 )
HLOCAL
WINAPI
LocalAlloc(
    __in UINT uFlags,
    __in SIZE_T uBytes
    );

WINBASEAPI
__out_opt
HLOCAL
WINAPI
LocalReAlloc(
    __in HLOCAL hMem,
    __in SIZE_T uBytes,
    __in UINT uFlags
    );

WINBASEAPI
__out_opt
LPVOID
WINAPI
LocalLock(
    __in HLOCAL hMem
    );

WINBASEAPI
__out_opt
HLOCAL
WINAPI
LocalHandle(
    __in LPCVOID pMem
    );

WINBASEAPI
BOOL
WINAPI
LocalUnlock(
    __in HLOCAL hMem
    );

WINBASEAPI
SIZE_T
WINAPI
LocalSize(
    __in HLOCAL hMem
    );

WINBASEAPI
UINT
WINAPI
LocalFlags(
    __in HLOCAL hMem
    );

WINBASEAPI
HLOCAL
WINAPI
LocalFree(
    __deref HLOCAL hMem
    );

WINBASEAPI
SIZE_T
WINAPI
LocalShrink(
    __in HLOCAL hMem,
    __in UINT cbNewSize
    );

WINBASEAPI
SIZE_T
WINAPI
LocalCompact(
    __in UINT uMinFree
    );

WINBASEAPI
BOOL
WINAPI
FlushInstructionCache(
    __in HANDLE hProcess,
    __in_bcount_opt(dwSize) LPCVOID lpBaseAddress,
    __in SIZE_T dwSize
    );

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
VOID
WINAPI
FlushProcessWriteBuffers(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
QueryThreadCycleTime (
    __in HANDLE ThreadHandle,
    __out PULONG64 CycleTime
    );

WINBASEAPI
BOOL
WINAPI
QueryProcessCycleTime (
    __in HANDLE ProcessHandle,
    __out PULONG64 CycleTime
    );

WINBASEAPI
BOOL
WINAPI
QueryIdleProcessorCycleTime (
    __inout PULONG BufferLength,
    __out_bcount_opt(*BufferLength) PULONG64 ProcessorIdleCycleTime
    );

#endif

#if (_WIN32_WINNT >= 0x0601)

WINBASEAPI
BOOL
WINAPI
QueryIdleProcessorCycleTimeEx (
    __in USHORT Group,
    __inout PULONG BufferLength,
    __out_bcount_opt(*BufferLength) PULONG64 ProcessorIdleCycleTime
    );

WINBASEAPI
BOOL
WINAPI
QueryUnbiasedInterruptTime (
    __out PULONGLONG UnbiasedTime
    );

WINBASEAPI
BOOL
WINAPI
GetProcessorSystemCycleTime (
    __in USHORT Group,
    __out_bcount_part_opt(*ReturnedLength, *ReturnedLength) PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer,
    __inout PDWORD ReturnedLength
    );

#endif // (_WIN32_WINNT >= 0x0601)

WINBASEAPI
__bcount_opt(dwSize)
LPVOID
WINAPI
VirtualAlloc(
    __in_opt LPVOID lpAddress,
    __in     SIZE_T dwSize,
    __in     DWORD flAllocationType,
    __in     DWORD flProtect
    );

__drv_when(((dwFreeType&(MEM_RELEASE|MEM_DECOMMIT)))==(MEM_RELEASE|MEM_DECOMMIT),
    __drv_reportError("Passing both MEM_RELEASE and MEM_DECOMMIT to VirtualFree is not allowed. This results in the failure of this call"))

__drv_when(dwFreeType==0,
    __drv_reportError("Passing zero as the dwFreeType parameter to VirtualFree is not allowed. This results in the failure of this call"))

__drv_when(((dwFreeType&MEM_RELEASE))!=0 && dwSize!=0,
    __drv_reportError("Passing MEM_RELEASE and a non-zero dwSize parameter to VirtualFree is not allowed. This results in the failure of this call"))
WINBASEAPI
BOOL
WINAPI
VirtualFree(
    __in LPVOID lpAddress,
    __in SIZE_T dwSize,
    __in DWORD dwFreeType
    );

WINBASEAPI
BOOL
WINAPI
VirtualProtect(
    __in  LPVOID lpAddress,
    __in  SIZE_T dwSize,
    __in  DWORD flNewProtect,
    __out PDWORD lpflOldProtect
    );

WINBASEAPI
SIZE_T
WINAPI
VirtualQuery(
    __in_opt LPCVOID lpAddress,
    __out_bcount_part(dwLength, return) PMEMORY_BASIC_INFORMATION lpBuffer,
    __in     SIZE_T dwLength
    );

WINBASEAPI
__bcount_opt(dwSize)
LPVOID
WINAPI
VirtualAllocEx(
    __in     HANDLE hProcess,
    __in_opt LPVOID lpAddress,
    __in     SIZE_T dwSize,
    __in     DWORD flAllocationType,
    __in     DWORD flProtect
    );

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
__bcount(dwSize)
LPVOID
WINAPI
VirtualAllocExNuma(
    __in     HANDLE hProcess,
    __in_opt LPVOID lpAddress,
    __in     SIZE_T dwSize,
    __in     DWORD  flAllocationType,
    __in     DWORD  flProtect,
    __in     DWORD  nndPreferred
    );

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
UINT
WINAPI
GetWriteWatch(
    __in DWORD dwFlags,
    __in PVOID lpBaseAddress,
    __in SIZE_T dwRegionSize,
    __out_ecount_part(*lpdwCount, *lpdwCount) PVOID *lpAddresses,
    __inout ULONG_PTR *lpdwCount,
    __out PULONG lpdwGranularity
    );

WINBASEAPI
UINT
WINAPI
ResetWriteWatch(
    __in LPVOID lpBaseAddress,
    __in SIZE_T dwRegionSize
    );

WINBASEAPI
SIZE_T
WINAPI
GetLargePageMinimum(
    VOID
    );

WINBASEAPI
UINT
WINAPI
EnumSystemFirmwareTables(
    __in DWORD FirmwareTableProviderSignature,
    __out_bcount_part_opt(BufferSize, return) PVOID pFirmwareTableEnumBuffer,
    __in DWORD BufferSize
    );

WINBASEAPI
UINT
WINAPI
GetSystemFirmwareTable(
    __in DWORD FirmwareTableProviderSignature,
    __in DWORD FirmwareTableID,
    __out_bcount_part_opt(BufferSize, return) PVOID pFirmwareTableBuffer,
    __in DWORD BufferSize
    );

WINBASEAPI
BOOL
WINAPI
GetPhysicallyInstalledSystemMemory(
    __out PULONGLONG TotalMemoryInKilobytes
    );

__drv_when(((dwFreeType&(MEM_RELEASE|MEM_DECOMMIT)))==(MEM_RELEASE|MEM_DECOMMIT),
    __drv_reportError("Passing both MEM_RELEASE and MEM_DECOMMIT to VirtualFree is not allowed. This results in the failure of this call"))

__drv_when(dwFreeType==0,
    __drv_reportError("Passing zero as the dwFreeType parameter to VirtualFree is not allowed. This results in the failure of this call"))

__drv_when(((dwFreeType&MEM_RELEASE))!=0 && dwSize!=0,
    __drv_reportError("Passing MEM_RELEASE and a non-zero dwSize parameter to VirtualFree is not allowed. This results in the failure of this call"))

__drv_when(((dwFreeType&MEM_DECOMMIT))!=0,
    __drv_reportError("Calling VirtualFreeEx without the MEM_RELEASE flag frees memory but not address descriptors (VADs); results in address space leaks"))
WINBASEAPI
BOOL
WINAPI
VirtualFreeEx(
    __in HANDLE hProcess,
    __in LPVOID lpAddress,
    __in SIZE_T dwSize,
    __in DWORD  dwFreeType
    );

WINBASEAPI
BOOL
WINAPI
VirtualProtectEx(
    __in  HANDLE hProcess,
    __in  LPVOID lpAddress,
    __in  SIZE_T dwSize,
    __in  DWORD flNewProtect,
    __out PDWORD lpflOldProtect
    );

WINBASEAPI
SIZE_T
WINAPI
VirtualQueryEx(
    __in     HANDLE hProcess,
    __in_opt LPCVOID lpAddress,
    __out_bcount_part(dwLength, return) PMEMORY_BASIC_INFORMATION lpBuffer,
    __in     SIZE_T dwLength
    );

WINBASEAPI
__out_opt
HANDLE
WINAPI
HeapCreate(
    __in DWORD flOptions,
    __in SIZE_T dwInitialSize,
    __in SIZE_T dwMaximumSize
    );

WINBASEAPI
BOOL
WINAPI
HeapDestroy(
    __in HANDLE hHeap
    );

WINBASEAPI
__bcount(dwBytes)
LPVOID
WINAPI
HeapAlloc(
    __in HANDLE hHeap,
    __in DWORD dwFlags,
    __in SIZE_T dwBytes
    );

WINBASEAPI
__bcount(dwBytes)
LPVOID
WINAPI
HeapReAlloc(
    __inout HANDLE hHeap,
    __in    DWORD dwFlags,
    __deref LPVOID lpMem,
    __in    SIZE_T dwBytes
    );

WINBASEAPI
BOOL
WINAPI
HeapFree(
    __inout HANDLE hHeap,
    __in    DWORD dwFlags,
    __drv_freesMem(Mem) __post __notvalid __deref LPVOID lpMem
    );

WINBASEAPI
SIZE_T
WINAPI
HeapSize(
    __in HANDLE hHeap,
    __in DWORD dwFlags,
    __in LPCVOID lpMem
    );

WINBASEAPI
BOOL
WINAPI
HeapValidate(
    __in     HANDLE hHeap,
    __in     DWORD dwFlags,
    __in_opt LPCVOID lpMem
    );

WINBASEAPI
SIZE_T
WINAPI
HeapCompact(
    __in HANDLE hHeap,
    __in DWORD dwFlags
    );

WINBASEAPI
__out
HANDLE
WINAPI
GetProcessHeap( VOID );

WINBASEAPI
DWORD
WINAPI
GetProcessHeaps(
    __in DWORD NumberOfHeaps,
    __out_ecount_part(NumberOfHeaps, return) PHANDLE ProcessHeaps
    );

typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    } DUMMYUNIONNAME;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;

#define PROCESS_HEAP_REGION             0x0001
#define PROCESS_HEAP_UNCOMMITTED_RANGE  0x0002
#define PROCESS_HEAP_ENTRY_BUSY         0x0004
#define PROCESS_HEAP_ENTRY_MOVEABLE     0x0010
#define PROCESS_HEAP_ENTRY_DDESHARE     0x0020

WINBASEAPI
BOOL
WINAPI
HeapLock(
    __in HANDLE hHeap
    );

WINBASEAPI
BOOL
WINAPI
HeapUnlock(
    __in HANDLE hHeap
    );


WINBASEAPI
BOOL
WINAPI
HeapWalk(
    __in    HANDLE hHeap,
    __inout LPPROCESS_HEAP_ENTRY lpEntry
    );

WINBASEAPI
BOOL
WINAPI
HeapSetInformation (
    __in_opt HANDLE HeapHandle,
    __in HEAP_INFORMATION_CLASS HeapInformationClass,
    __in_bcount_opt(HeapInformationLength) PVOID HeapInformation,
    __in SIZE_T HeapInformationLength
    );

WINBASEAPI
BOOL
WINAPI
HeapQueryInformation (
    __in_opt HANDLE HeapHandle,
    __in HEAP_INFORMATION_CLASS HeapInformationClass,
    __out_bcount_part_opt(HeapInformationLength, *ReturnLength) PVOID HeapInformation,
    __in SIZE_T HeapInformationLength,
    __out_opt PSIZE_T ReturnLength
    );

// GetBinaryType return values.

#define SCS_32BIT_BINARY    0
#define SCS_DOS_BINARY      1
#define SCS_WOW_BINARY      2
#define SCS_PIF_BINARY      3
#define SCS_POSIX_BINARY    4
#define SCS_OS216_BINARY    5
#define SCS_64BIT_BINARY    6

#if defined(_WIN64)
# define SCS_THIS_PLATFORM_BINARY SCS_64BIT_BINARY
#else
# define SCS_THIS_PLATFORM_BINARY SCS_32BIT_BINARY
#endif

WINBASEAPI
BOOL
WINAPI
GetBinaryTypeA(
    __in  LPCSTR lpApplicationName,
    __out LPDWORD  lpBinaryType
    );
WINBASEAPI
BOOL
WINAPI
GetBinaryTypeW(
    __in  LPCWSTR lpApplicationName,
    __out LPDWORD  lpBinaryType
    );
#ifdef UNICODE
#define GetBinaryType  GetBinaryTypeW
#else
#define GetBinaryType  GetBinaryTypeA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetShortPathNameA(
    __in LPCSTR lpszLongPath,
    __out_ecount_part_opt(cchBuffer, return + 1) LPSTR  lpszShortPath,
    __in DWORD cchBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetShortPathNameW(
    __in LPCWSTR lpszLongPath,
    __out_ecount_part_opt(cchBuffer, return + 1) LPWSTR  lpszShortPath,
    __in DWORD cchBuffer
    );
#ifdef UNICODE
#define GetShortPathName  GetShortPathNameW
#else
#define GetShortPathName  GetShortPathNameA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetLongPathNameA(
    __in LPCSTR lpszShortPath,
    __out_ecount_part_opt(cchBuffer, return + 1) LPSTR  lpszLongPath,
    __in DWORD cchBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetLongPathNameW(
    __in LPCWSTR lpszShortPath,
    __out_ecount_part_opt(cchBuffer, return + 1) LPWSTR  lpszLongPath,
    __in DWORD cchBuffer
    );
#ifdef UNICODE
#define GetLongPathName  GetLongPathNameW
#else
#define GetLongPathName  GetLongPathNameA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
DWORD
WINAPI
GetLongPathNameTransactedA(
    __in     LPCSTR lpszShortPath,
    __out_ecount_part_opt(cchBuffer, return + 1) LPSTR  lpszLongPath,
    __in     DWORD cchBuffer,
    __in     HANDLE hTransaction
    );
WINBASEAPI
DWORD
WINAPI
GetLongPathNameTransactedW(
    __in     LPCWSTR lpszShortPath,
    __out_ecount_part_opt(cchBuffer, return + 1) LPWSTR  lpszLongPath,
    __in     DWORD cchBuffer,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define GetLongPathNameTransacted  GetLongPathNameTransactedW
#else
#define GetLongPathNameTransacted  GetLongPathNameTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
GetProcessAffinityMask(
    __in  HANDLE hProcess,
    __out PDWORD_PTR lpProcessAffinityMask,
    __out PDWORD_PTR lpSystemAffinityMask
    );

WINBASEAPI
BOOL
WINAPI
SetProcessAffinityMask(
    __in HANDLE hProcess,
    __in DWORD_PTR dwProcessAffinityMask
    );

#if _WIN32_WINNT >= 0x0601

BOOL
WINAPI
GetProcessGroupAffinity(
    __in HANDLE hProcess,
    __inout PUSHORT GroupCount,
    __out_ecount(*GroupCount) PUSHORT GroupArray
    );

#endif // _WIN32_WINNT >= 0x0601

#if _WIN32_WINNT >= 0x0501

WINBASEAPI
BOOL
WINAPI
GetProcessHandleCount(
    __in  HANDLE hProcess,
    __out PDWORD pdwHandleCount
    );

#endif // (_WIN32_WINNT >= 0x0501)

WINBASEAPI
BOOL
WINAPI
GetProcessTimes(
    __in  HANDLE hProcess,
    __out LPFILETIME lpCreationTime,
    __out LPFILETIME lpExitTime,
    __out LPFILETIME lpKernelTime,
    __out LPFILETIME lpUserTime
    );

WINBASEAPI
BOOL
WINAPI
GetProcessIoCounters(
    __in  HANDLE hProcess,
    __out PIO_COUNTERS lpIoCounters
    );

WINBASEAPI
BOOL
WINAPI
GetProcessWorkingSetSize(
    __in  HANDLE hProcess,
    __out PSIZE_T lpMinimumWorkingSetSize,
    __out PSIZE_T lpMaximumWorkingSetSize
    );

WINBASEAPI
BOOL
WINAPI
GetProcessWorkingSetSizeEx(
    __in  HANDLE hProcess,
    __out PSIZE_T lpMinimumWorkingSetSize,
    __out PSIZE_T lpMaximumWorkingSetSize,
    __out PDWORD Flags
    );

WINBASEAPI
BOOL
WINAPI
SetProcessWorkingSetSize(
    __in HANDLE hProcess,
    __in SIZE_T dwMinimumWorkingSetSize,
    __in SIZE_T dwMaximumWorkingSetSize
    );

WINBASEAPI
BOOL
WINAPI
SetProcessWorkingSetSizeEx(
    __in HANDLE hProcess,
    __in SIZE_T dwMinimumWorkingSetSize,
    __in SIZE_T dwMaximumWorkingSetSize,
    __in DWORD Flags
    );

#if (_WIN32_WINNT >= 0x0600)

#define PROCESS_AFFINITY_ENABLE_AUTO_UPDATE 0x00000001UL

WINBASEAPI
BOOL
WINAPI
SetProcessAffinityUpdateMode(
    __in HANDLE hProcess,
    __in DWORD dwFlags
    );

WINBASEAPI
BOOL
WINAPI
QueryProcessAffinityUpdateMode(
    __in HANDLE hProcess,
    __out_opt LPDWORD lpdwFlags
    );

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
HANDLE
WINAPI
OpenProcess(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in DWORD dwProcessId
    );

WINBASEAPI
__out
HANDLE
WINAPI
GetCurrentProcess(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetCurrentProcessId(
    VOID
    );

WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
ExitProcess(
    __in UINT uExitCode
    );

WINBASEAPI
BOOL
WINAPI
TerminateProcess(
    __in HANDLE hProcess,
    __in UINT uExitCode
    );

WINBASEAPI
BOOL
WINAPI
GetExitCodeProcess(
    __in  HANDLE hProcess,
    __out LPDWORD lpExitCode
    );

WINBASEAPI
VOID
WINAPI
FatalExit(
    __in int ExitCode
    );

WINBASEAPI
__out
__nullnullterminated
LPCH
WINAPI
GetEnvironmentStrings(
    VOID
    );

WINBASEAPI
__out
__nullnullterminated
LPWCH
WINAPI
GetEnvironmentStringsW(
    VOID
    );

#ifdef UNICODE
#define GetEnvironmentStrings  GetEnvironmentStringsW
#else
#define GetEnvironmentStringsA  GetEnvironmentStrings
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetEnvironmentStringsA(
    __in __nullnullterminated LPCH NewEnvironment
    );
WINBASEAPI
BOOL
WINAPI
SetEnvironmentStringsW(
    __in __nullnullterminated LPWCH NewEnvironment
    );
#ifdef UNICODE
#define SetEnvironmentStrings  SetEnvironmentStringsW
#else
#define SetEnvironmentStrings  SetEnvironmentStringsA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FreeEnvironmentStringsA(
    __in __nullnullterminated LPCH
    );
WINBASEAPI
BOOL
WINAPI
FreeEnvironmentStringsW(
    __in __nullnullterminated LPWCH
    );
#ifdef UNICODE
#define FreeEnvironmentStrings  FreeEnvironmentStringsW
#else
#define FreeEnvironmentStrings  FreeEnvironmentStringsA
#endif // !UNICODE

WINBASEAPI
VOID
WINAPI
RaiseException(
    __in DWORD dwExceptionCode,
    __in DWORD dwExceptionFlags,
    __in DWORD nNumberOfArguments,
    __in_ecount_opt(nNumberOfArguments) CONST ULONG_PTR *lpArguments
    );

WINBASEAPI
VOID
WINAPI
RaiseFailFastException(
    __in_opt PEXCEPTION_RECORD pExceptionRecord,
    __in PCONTEXT pContextRecord,
    __in DWORD dwFlags
    );

__callback
WINBASEAPI
LONG
WINAPI
UnhandledExceptionFilter(
    __in struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef LONG (WINAPI *PTOP_LEVEL_EXCEPTION_FILTER)(
    __in struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

WINBASEAPI
LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    __in_opt LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );

#if(_WIN32_WINNT >= 0x0400)

//
// Fiber creation flags
//

#define FIBER_FLAG_FLOAT_SWITCH 0x1     // context switch floating point

WINBASEAPI
__out_opt
LPVOID
WINAPI
CreateFiber(
    __in     SIZE_T dwStackSize,
    __in     LPFIBER_START_ROUTINE lpStartAddress,
    __in_opt LPVOID lpParameter
    );

WINBASEAPI
__out_opt
LPVOID
WINAPI
CreateFiberEx(
    __in     SIZE_T dwStackCommitSize,
    __in     SIZE_T dwStackReserveSize,
    __in     DWORD dwFlags,
    __in     LPFIBER_START_ROUTINE lpStartAddress,
    __in_opt LPVOID lpParameter
    );

WINBASEAPI
VOID
WINAPI
DeleteFiber(
    __in LPVOID lpFiber
    );

WINBASEAPI
__out_opt
LPVOID
WINAPI
ConvertThreadToFiber(
    __in_opt LPVOID lpParameter
    );

WINBASEAPI
__out_opt
LPVOID
WINAPI
ConvertThreadToFiberEx(
    __in_opt LPVOID lpParameter,
    __in     DWORD dwFlags
    );

#if (_WIN32_WINNT >= 0x0501)

WINBASEAPI
BOOL
WINAPI
ConvertFiberToThread(
    VOID
    );

#endif

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
BOOL
WINAPI
IsThreadAFiber(
    VOID
    );

#endif

WINBASEAPI
VOID
WINAPI
SwitchToFiber(
    __in LPVOID lpFiber
    );

WINBASEAPI
BOOL
WINAPI
SwitchToThread(
    VOID
    );

//
// UMS begin
//

#if (_WIN32_WINNT >= 0x0601) && !defined(MIDL_PASS)

#define UMS_VERSION RTL_UMS_VERSION

typedef void *PUMS_CONTEXT;

typedef void *PUMS_COMPLETION_LIST;

typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;

typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;

typedef struct _UMS_SCHEDULER_STARTUP_INFO {

    //
    // UMS Version the application was built to. Should be set to UMS_VERSION
    //
    ULONG UmsVersion;

    //
    // Completion List to associate the new User Scheduler to.
    //
    PUMS_COMPLETION_LIST CompletionList;

    //
    // A pointer to the application-defined function that represents the starting
    // address of the Sheduler.
    //
    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;

    //
    // pointer to a variable to be passed to the scheduler uppon first activation.
    //
    PVOID SchedulerParam;

} UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;

__checkReturn
WINBASEAPI
BOOL
WINAPI
CreateUmsCompletionList(
    __deref_out PUMS_COMPLETION_LIST* UmsCompletionList
    );

WINBASEAPI
BOOL
WINAPI
DequeueUmsCompletionListItems(
    __in PUMS_COMPLETION_LIST UmsCompletionList,
    __in DWORD WaitTimeOut,
    __out PUMS_CONTEXT* UmsThreadList
    );

WINBASEAPI
BOOL
WINAPI
GetUmsCompletionListEvent(
    __in PUMS_COMPLETION_LIST UmsCompletionList,
    __inout PHANDLE UmsCompletionEvent
    );

WINBASEAPI
BOOL
WINAPI
ExecuteUmsThread(
    __inout PUMS_CONTEXT UmsThread
    );

WINBASEAPI
BOOL
WINAPI
UmsThreadYield(
    __in PVOID SchedulerParam
    );

WINBASEAPI
BOOL
WINAPI
DeleteUmsCompletionList(
    __in PUMS_COMPLETION_LIST UmsCompletionList
    );

WINBASEAPI
PUMS_CONTEXT
WINAPI
GetCurrentUmsThread(
    VOID
    );

WINBASEAPI
PUMS_CONTEXT
WINAPI
GetNextUmsListItem(
    __inout PUMS_CONTEXT UmsContext
    );

WINBASEAPI
BOOL
WINAPI
QueryUmsThreadInformation(
    __in PUMS_CONTEXT UmsThread,
    __in UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
    __out_bcount_part(UmsThreadInformationLength, *ReturnLength) PVOID UmsThreadInformation,
    __in ULONG UmsThreadInformationLength,
    __out_opt PULONG ReturnLength
    );

WINBASEAPI
BOOL
WINAPI
SetUmsThreadInformation(
    __in PUMS_CONTEXT UmsThread,
    __in UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
    __in PVOID UmsThreadInformation,
    __in ULONG UmsThreadInformationLength
    );

WINBASEAPI
BOOL
WINAPI
DeleteUmsThreadContext(
    __in PUMS_CONTEXT UmsThread
    );

WINBASEAPI
BOOL
WINAPI
CreateUmsThreadContext(
    __deref_out PUMS_CONTEXT *lpUmsThread
    );

WINBASEAPI
BOOL
WINAPI
EnterUmsSchedulingMode(
    __in PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo
    );

#endif // (_WIN32_WINNT >= 0x0601) && !defined(MIDL_PASS)

//
// UMS end
//

#endif /* _WIN32_WINNT >= 0x0400 */

typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateThread(
    __in_opt  LPSECURITY_ATTRIBUTES lpThreadAttributes,
    __in      SIZE_T dwStackSize,
    __in      LPTHREAD_START_ROUTINE lpStartAddress,
    __in_opt __deref __drv_aliasesMem LPVOID lpParameter,
    __in      DWORD dwCreationFlags,
    __out_opt LPDWORD lpThreadId
    );

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateRemoteThread(
    __in      HANDLE hProcess,
    __in_opt  LPSECURITY_ATTRIBUTES lpThreadAttributes,
    __in      SIZE_T dwStackSize,
    __in      LPTHREAD_START_ROUTINE lpStartAddress,
    __in_opt  LPVOID lpParameter,
    __in      DWORD dwCreationFlags,
    __out_opt LPDWORD lpThreadId
    );

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateRemoteThreadEx(
    __in      HANDLE hProcess,
    __in_opt  LPSECURITY_ATTRIBUTES lpThreadAttributes,
    __in      SIZE_T dwStackSize,
    __in      LPTHREAD_START_ROUTINE lpStartAddress,
    __in_opt  LPVOID lpParameter,
    __in      DWORD dwCreationFlags,
    __in_opt  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    __out_opt LPDWORD lpThreadId
    );

WINBASEAPI
__out
HANDLE
WINAPI
GetCurrentThread(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetCurrentThreadId(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
SetThreadStackGuarantee (
    __inout PULONG StackSizeInBytes
    );

WINBASEAPI
DWORD
WINAPI
GetProcessIdOfThread(
    __in HANDLE Thread
    );

#if (_WIN32_WINNT >= 0x0502)

WINBASEAPI
DWORD
WINAPI
GetThreadId(
    __in HANDLE Thread
    );

#endif // _WIN32_WINNT >= 0x0502

WINBASEAPI
DWORD
WINAPI
GetProcessId(
    __in HANDLE Process
    );

WINBASEAPI
DWORD
WINAPI
GetCurrentProcessorNumber(
    VOID
    );

#if (_WIN32_WINNT >= 0x0601)
WINBASEAPI
VOID
WINAPI
GetCurrentProcessorNumberEx(
    __out PPROCESSOR_NUMBER ProcNumber
    );
#endif

#if (_WIN32_WINNT >= 0x0601)
WINBASEAPI
BOOL
WINAPI
GetThreadGroupAffinity(
    __in HANDLE hThread,
    __out PGROUP_AFFINITY GroupAffinity
    );
#endif // _WIN32_WINNT >= 0x0601

WINBASEAPI
DWORD_PTR
WINAPI
SetThreadAffinityMask(
    __in HANDLE hThread,
    __in DWORD_PTR dwThreadAffinityMask
    );

#if (_WIN32_WINNT >= 0x0601)
WINBASEAPI
BOOL
WINAPI
SetThreadGroupAffinity(
    __in HANDLE hThread,
    __in CONST GROUP_AFFINITY *GroupAffinity,
    __out_opt PGROUP_AFFINITY PreviousGroupAffinity
    );

WINBASEAPI
BOOL
WINAPI
SetThreadIdealProcessorEx (
    __in HANDLE hThread,
    __in PPROCESSOR_NUMBER lpIdealProcessor,
    __out_opt PPROCESSOR_NUMBER lpPreviousIdealProcessor
    );

WINBASEAPI
BOOL
WINAPI
GetThreadIdealProcessorEx (
    __in HANDLE hThread,
    __out PPROCESSOR_NUMBER lpIdealProcessor
    );

#endif // _WIN32_WINNT >= 0x0601

#if(_WIN32_WINNT >= 0x0400)
WINBASEAPI
DWORD
WINAPI
SetThreadIdealProcessor(
    __in HANDLE hThread,
    __in DWORD dwIdealProcessor
    );
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x0600)

#define PROCESS_DEP_ENABLE                          0x00000001
#define PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION     0x00000002

WINBASEAPI
BOOL
WINAPI
SetProcessDEPPolicy(
    __in DWORD dwFlags
    );

WINBASEAPI
BOOL
WINAPI
GetProcessDEPPolicy(
    __in HANDLE hProcess,
    __out LPDWORD lpFlags,
    __out PBOOL lpPermanent
    );

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
SetProcessPriorityBoost(
    __in HANDLE hProcess,
    __in BOOL bDisablePriorityBoost
    );

WINBASEAPI
BOOL
WINAPI
GetProcessPriorityBoost(
    __in  HANDLE hProcess,
    __out PBOOL  pDisablePriorityBoost
    );

WINBASEAPI
BOOL
WINAPI
RequestWakeupLatency(
    __in LATENCY_TIME latency
    );

WINBASEAPI
BOOL
WINAPI
IsSystemResumeAutomatic(
    VOID
    );

WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenThread(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in DWORD dwThreadId
    );

WINBASEAPI
BOOL
WINAPI
SetThreadPriority(
    __in HANDLE hThread,
    __in int nPriority
    );

WINBASEAPI
BOOL
WINAPI
SetThreadPriorityBoost(
    __in HANDLE hThread,
    __in BOOL bDisablePriorityBoost
    );

WINBASEAPI
BOOL
WINAPI
GetThreadPriorityBoost(
    __in  HANDLE hThread,
    __out PBOOL pDisablePriorityBoost
    );

WINBASEAPI
int
WINAPI
GetThreadPriority(
    __in HANDLE hThread
    );

WINBASEAPI
BOOL
WINAPI
GetThreadTimes(
    __in  HANDLE hThread,
    __out LPFILETIME lpCreationTime,
    __out LPFILETIME lpExitTime,
    __out LPFILETIME lpKernelTime,
    __out LPFILETIME lpUserTime
    );

#if _WIN32_WINNT >= 0x0501

WINBASEAPI
BOOL
WINAPI
GetThreadIOPendingFlag(
    __in  HANDLE hThread,
    __out PBOOL  lpIOIsPending
    );

#endif // (_WIN32_WINNT >= 0x0501)

WINBASEAPI
DECLSPEC_NORETURN
VOID
WINAPI
ExitThread(
    __in DWORD dwExitCode
    );

WINBASEAPI
BOOL
WINAPI
TerminateThread(
    __in HANDLE hThread,
    __in DWORD dwExitCode
    );

WINBASEAPI
__success(return != 0)
BOOL
WINAPI
GetExitCodeThread(
    __in  HANDLE hThread,
    __out LPDWORD lpExitCode
    );

WINBASEAPI
BOOL
WINAPI
GetThreadSelectorEntry(
    __in  HANDLE hThread,
    __in  DWORD dwSelector,
    __out LPLDT_ENTRY lpSelectorEntry
    );

WINBASEAPI
EXECUTION_STATE
WINAPI
SetThreadExecutionState(
    __in EXECUTION_STATE esFlags
    );

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR *ReasonStrings;

        } Detailed;

        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;

//
// Power Request APIs
//

typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;

WINBASEAPI
HANDLE
WINAPI
PowerCreateRequest (
    __in PREASON_CONTEXT Context
    );

WINBASEAPI
BOOL
WINAPI
PowerSetRequest (
    __in HANDLE PowerRequest,
    __in POWER_REQUEST_TYPE RequestType
    );

WINBASEAPI
BOOL
WINAPI
PowerClearRequest (
    __in HANDLE PowerRequest,
    __in POWER_REQUEST_TYPE RequestType
    );

#endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

#ifdef _M_CEE_PURE
#define GetLastError System::Runtime::InteropServices::Marshal::GetLastWin32Error
#else
WINBASEAPI
__checkReturn
DWORD
WINAPI
GetLastError(
    VOID
    );
#endif

WINBASEAPI
VOID
WINAPI
SetLastError(
    __in DWORD dwErrCode
    );

#if !defined(RC_INVOKED) // RC warns because "WINBASE_DECLARE_RESTORE_LAST_ERROR" is a bit long.
//#if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)
#if defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)

WINBASEAPI
VOID
WINAPI
RestoreLastError(
    __in DWORD dwErrCode
    );

typedef VOID (WINAPI* PRESTORE_LAST_ERROR)(DWORD);
#define RESTORE_LAST_ERROR_NAME_A      "RestoreLastError"
#define RESTORE_LAST_ERROR_NAME_W     L"RestoreLastError"
#define RESTORE_LAST_ERROR_NAME   TEXT("RestoreLastError")

#endif
#endif

#define HasOverlappedIoCompleted(lpOverlapped) (((DWORD)(lpOverlapped)->Internal) != STATUS_PENDING)

WINBASEAPI
BOOL
WINAPI
GetOverlappedResult(
    __in  HANDLE hFile,
    __in  LPOVERLAPPED lpOverlapped,
    __out LPDWORD lpNumberOfBytesTransferred,
    __in  BOOL bWait
    );

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateIoCompletionPort(
    __in     HANDLE FileHandle,
    __in_opt HANDLE ExistingCompletionPort,
    __in     ULONG_PTR CompletionKey,
    __in     DWORD NumberOfConcurrentThreads
    );

WINBASEAPI
BOOL
WINAPI
GetQueuedCompletionStatus(
    __in  HANDLE CompletionPort,
    __out LPDWORD lpNumberOfBytesTransferred,
    __out PULONG_PTR lpCompletionKey,
    __out LPOVERLAPPED *lpOverlapped,
    __in  DWORD dwMilliseconds
    );

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
BOOL
WINAPI
GetQueuedCompletionStatusEx(
    __in  HANDLE CompletionPort,
    __out_ecount_part(ulCount, *ulNumEntriesRemoved) LPOVERLAPPED_ENTRY lpCompletionPortEntries,
    __in  ULONG ulCount,
    __out PULONG ulNumEntriesRemoved,
    __in  DWORD dwMilliseconds,
    __in  BOOL fAlertable
    );

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
PostQueuedCompletionStatus(
    __in     HANDLE CompletionPort,
    __in     DWORD dwNumberOfBytesTransferred,
    __in     ULONG_PTR dwCompletionKey,
    __in_opt LPOVERLAPPED lpOverlapped
    );

#if (_WIN32_WINNT >= 0x0600)

//
// The following flags allows an application to change
// the semantics of IO completion notification.
//

//
// Don't queue an entry to an associated completion port if returning success
// synchronously.
//
#define FILE_SKIP_COMPLETION_PORT_ON_SUCCESS    0x1

//
// Don't set the file handle event on IO completion.
//
#define FILE_SKIP_SET_EVENT_ON_HANDLE           0x2

WINBASEAPI
BOOL
WINAPI
SetFileCompletionNotificationModes(
    __in HANDLE FileHandle,
    __in UCHAR Flags
    );

WINBASEAPI
BOOL
WINAPI
SetFileIoOverlappedRange(
    __in HANDLE FileHandle,
    __in PUCHAR OverlappedRangeStart,
    __in ULONG Length
    );

#endif // _WIN32_WINNT >= 0x0600

#define SEM_FAILCRITICALERRORS      0x0001
#define SEM_NOGPFAULTERRORBOX       0x0002
#define SEM_NOALIGNMENTFAULTEXCEPT  0x0004
#define SEM_NOOPENFILEERRORBOX      0x8000

WINBASEAPI
UINT
WINAPI
GetErrorMode(
    VOID
    );

WINBASEAPI
UINT
WINAPI
SetErrorMode(
    __in UINT uMode
    );

//
// Thread error mode support
//

WINBASEAPI
DWORD
WINAPI
GetThreadErrorMode(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
SetThreadErrorMode(
    __in DWORD dwNewMode,
    __in_opt LPDWORD lpOldMode
    );

WINBASEAPI
BOOL
WINAPI
ReadProcessMemory(
    __in      HANDLE hProcess,
    __in      LPCVOID lpBaseAddress,
    __out_bcount_part(nSize, *lpNumberOfBytesRead) LPVOID lpBuffer,
    __in      SIZE_T nSize,
    __out_opt SIZE_T * lpNumberOfBytesRead
    );

WINBASEAPI
BOOL
WINAPI
WriteProcessMemory(
    __in      HANDLE hProcess,
    __in      LPVOID lpBaseAddress,
    __in_bcount(nSize) LPCVOID lpBuffer,
    __in      SIZE_T nSize,
    __out_opt SIZE_T * lpNumberOfBytesWritten
    );

#if !defined(MIDL_PASS)
WINBASEAPI
BOOL
WINAPI
GetThreadContext(
    __in    HANDLE hThread,
    __inout LPCONTEXT lpContext
    );

WINBASEAPI
BOOL
WINAPI
SetThreadContext(
    __in HANDLE hThread,
    __in CONST CONTEXT *lpContext
    );

WINBASEAPI
BOOL
WINAPI
Wow64GetThreadContext(
    __in    HANDLE hThread,
    __inout PWOW64_CONTEXT lpContext
    );

#if(_WIN32_WINNT >= 0x0601)

WINBASEAPI
BOOL
WINAPI
Wow64GetThreadSelectorEntry(
    __in HANDLE hThread,
    __in DWORD dwSelector,
    __out PWOW64_LDT_ENTRY lpSelectorEntry
    );

#endif /* _WIN32_WINNT >= 0x0601 */

WINBASEAPI
BOOL
WINAPI
Wow64SetThreadContext(
    __in HANDLE hThread,
    __in CONST WOW64_CONTEXT *lpContext
    );

#endif

WINBASEAPI
DWORD
WINAPI
SuspendThread(
    __in HANDLE hThread
    );

WINBASEAPI
DWORD
WINAPI
Wow64SuspendThread(
    __in HANDLE hThread
    );

WINBASEAPI
DWORD
WINAPI
ResumeThread(
    __in HANDLE hThread
    );


#if(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

WINBASEAPI
DWORD
WINAPI
QueueUserAPC(
    __in PAPCFUNC pfnAPC,
    __in HANDLE hThread,
    __in ULONG_PTR dwData
    );

#endif /* _WIN32_WINNT >= 0x0400 || _WIN32_WINDOWS > 0x0400 */

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
WINBASEAPI
BOOL
WINAPI
IsDebuggerPresent(
    VOID
    );
#endif

#if _WIN32_WINNT >= 0x0501

WINBASEAPI
BOOL
WINAPI
CheckRemoteDebuggerPresent(
    __in  HANDLE hProcess,
    __out PBOOL pbDebuggerPresent
    );

#endif // (_WIN32_WINNT >= 0x0501)

WINBASEAPI
VOID
WINAPI
DebugBreak(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
WaitForDebugEvent(
    __in LPDEBUG_EVENT lpDebugEvent,
    __in DWORD dwMilliseconds
    );

WINBASEAPI
BOOL
WINAPI
ContinueDebugEvent(
    __in DWORD dwProcessId,
    __in DWORD dwThreadId,
    __in DWORD dwContinueStatus
    );

WINBASEAPI
BOOL
WINAPI
DebugActiveProcess(
    __in DWORD dwProcessId
    );

WINBASEAPI
BOOL
WINAPI
DebugActiveProcessStop(
    __in DWORD dwProcessId
    );

WINBASEAPI
BOOL
WINAPI
DebugSetProcessKillOnExit(
    __in BOOL KillOnExit
    );

WINBASEAPI
BOOL
WINAPI
DebugBreakProcess (
    __in HANDLE Process
    );

#if (_WIN32_WINNT < _WIN32_WINNT_LONGHORN)
__drv_inTry
#endif
WINBASEAPI
VOID
WINAPI
InitializeCriticalSection(
    __out LPCRITICAL_SECTION lpCriticalSection
    );

WINBASEAPI
VOID
WINAPI
EnterCriticalSection(
    __inout LPCRITICAL_SECTION lpCriticalSection
    );

WINBASEAPI
VOID
WINAPI
LeaveCriticalSection(
    __inout LPCRITICAL_SECTION lpCriticalSection
    );

#if (_WIN32_WINNT >= 0x0403)
#define CRITICAL_SECTION_NO_DEBUG_INFO  RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO

WINBASEAPI
BOOL
WINAPI
InitializeCriticalSectionAndSpinCount(
    __out LPCRITICAL_SECTION lpCriticalSection,
    __in  DWORD dwSpinCount
    );

WINBASEAPI
BOOL
WINAPI
InitializeCriticalSectionEx(
    __out LPCRITICAL_SECTION lpCriticalSection,
    __in  DWORD dwSpinCount,
    __in  DWORD Flags
    );

WINBASEAPI
DWORD
WINAPI
SetCriticalSectionSpinCount(
    __inout LPCRITICAL_SECTION lpCriticalSection,
    __in    DWORD dwSpinCount
    );
#endif

#if(_WIN32_WINNT >= 0x0400)
WINBASEAPI
BOOL
WINAPI
TryEnterCriticalSection(
    __inout LPCRITICAL_SECTION lpCriticalSection
    );
#endif /* _WIN32_WINNT >= 0x0400 */

WINBASEAPI
VOID
WINAPI
DeleteCriticalSection(
    __inout LPCRITICAL_SECTION lpCriticalSection
    );

WINBASEAPI
BOOL
WINAPI
SetEvent(
    __in HANDLE hEvent
    );

WINBASEAPI
BOOL
WINAPI
ResetEvent(
    __in HANDLE hEvent
    );

WINBASEAPI
BOOL
WINAPI
PulseEvent(
    __in HANDLE hEvent
    );

WINBASEAPI
BOOL
WINAPI
ReleaseSemaphore(
    __in      HANDLE hSemaphore,
    __in      LONG lReleaseCount,
    __out_opt LPLONG lpPreviousCount
    );

WINBASEAPI
BOOL
WINAPI
ReleaseMutex(
    __in HANDLE hMutex
    );

WINBASEAPI
DWORD
WINAPI
WaitForSingleObject(
    __in HANDLE hHandle,
    __in DWORD dwMilliseconds
    );

WINBASEAPI
DWORD
WINAPI
WaitForMultipleObjects(
    __in DWORD nCount,
    __in_ecount(nCount) CONST HANDLE *lpHandles,
    __in BOOL bWaitAll,
    __in DWORD dwMilliseconds
    );

WINBASEAPI
VOID
WINAPI
Sleep(
    __in DWORD dwMilliseconds
    );

WINBASEAPI
__out_opt
HGLOBAL
WINAPI
LoadResource(
    __in_opt HMODULE hModule,
    __in HRSRC hResInfo
    );

WINBASEAPI
DWORD
WINAPI
SizeofResource(
    __in_opt HMODULE hModule,
    __in HRSRC hResInfo
    );


WINBASEAPI
ATOM
WINAPI
GlobalDeleteAtom(
    __in ATOM nAtom
    );

WINBASEAPI
BOOL
WINAPI
InitAtomTable(
    __in DWORD nSize
    );

WINBASEAPI
ATOM
WINAPI
DeleteAtom(
    __in ATOM nAtom
    );

WINBASEAPI
UINT
WINAPI
SetHandleCount(
    __in UINT uNumber
    );

WINBASEAPI
DWORD
WINAPI
GetLogicalDrives(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
LockFile(
    __in HANDLE hFile,
    __in DWORD dwFileOffsetLow,
    __in DWORD dwFileOffsetHigh,
    __in DWORD nNumberOfBytesToLockLow,
    __in DWORD nNumberOfBytesToLockHigh
    );

WINBASEAPI
BOOL
WINAPI
UnlockFile(
    __in HANDLE hFile,
    __in DWORD dwFileOffsetLow,
    __in DWORD dwFileOffsetHigh,
    __in DWORD nNumberOfBytesToUnlockLow,
    __in DWORD nNumberOfBytesToUnlockHigh
    );

WINBASEAPI
BOOL
WINAPI
LockFileEx(
    __in       HANDLE hFile,
    __in       DWORD dwFlags,
    __reserved DWORD dwReserved,
    __in       DWORD nNumberOfBytesToLockLow,
    __in       DWORD nNumberOfBytesToLockHigh,
    __inout    LPOVERLAPPED lpOverlapped
    );

#define LOCKFILE_FAIL_IMMEDIATELY   0x00000001
#define LOCKFILE_EXCLUSIVE_LOCK     0x00000002

WINBASEAPI
BOOL
WINAPI
UnlockFileEx(
    __in       HANDLE hFile,
    __reserved DWORD dwReserved,
    __in       DWORD nNumberOfBytesToUnlockLow,
    __in       DWORD nNumberOfBytesToUnlockHigh,
    __inout    LPOVERLAPPED lpOverlapped
    );

typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

WINBASEAPI
BOOL
WINAPI
GetFileInformationByHandle(
    __in  HANDLE hFile,
    __out LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );

WINBASEAPI
DWORD
WINAPI
GetFileType(
    __in HANDLE hFile
    );

WINBASEAPI
DWORD
WINAPI
GetFileSize(
    __in      HANDLE hFile,
    __out_opt LPDWORD lpFileSizeHigh
    );

WINBASEAPI
BOOL
WINAPI
GetFileSizeEx(
    __in  HANDLE hFile,
    __out PLARGE_INTEGER lpFileSize
    );


WINBASEAPI
HANDLE
WINAPI
GetStdHandle(
    __in DWORD nStdHandle
    );

WINBASEAPI
BOOL
WINAPI
SetStdHandle(
    __in DWORD nStdHandle,
    __in HANDLE hHandle
    );

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
BOOL
WINAPI
SetStdHandleEx(
    __in      DWORD nStdHandle,
    __in      HANDLE hHandle,
    __out_opt PHANDLE phPrevValue
    );

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
WriteFile(
    __in        HANDLE hFile,
    __in_bcount_opt(nNumberOfBytesToWrite) LPCVOID lpBuffer,
    __in        DWORD nNumberOfBytesToWrite,
    __out_opt   LPDWORD lpNumberOfBytesWritten,
    __inout_opt LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
ReadFile(
    __in        HANDLE hFile,
    __out_bcount_part_opt(nNumberOfBytesToRead, *lpNumberOfBytesRead) __out_data_source(FILE) LPVOID lpBuffer,
    __in        DWORD nNumberOfBytesToRead,
    __out_opt   LPDWORD lpNumberOfBytesRead,
    __inout_opt LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
FlushFileBuffers(
    __in HANDLE hFile
    );

WINBASEAPI
BOOL
WINAPI
DeviceIoControl(
    __in        HANDLE hDevice,
    __in        DWORD dwIoControlCode,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in        DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesReturned) LPVOID lpOutBuffer,
    __in        DWORD nOutBufferSize,
    __out_opt   LPDWORD lpBytesReturned,
    __inout_opt LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
RequestDeviceWakeup(
    __in HANDLE hDevice
    );

WINBASEAPI
BOOL
WINAPI
CancelDeviceWakeupRequest(
    __in HANDLE hDevice
    );

WINBASEAPI
BOOL
WINAPI
GetDevicePowerState(
    __in  HANDLE hDevice,
    __out BOOL *pfOn
    );

WINBASEAPI
BOOL
WINAPI
SetMessageWaitingIndicator(
    __in HANDLE hMsgIndicator,
    __in ULONG ulMsgCount
    );

WINBASEAPI
BOOL
WINAPI
SetEndOfFile(
    __in HANDLE hFile
    );

WINBASEAPI
DWORD
WINAPI
SetFilePointer(
    __in        HANDLE hFile,
    __in        LONG lDistanceToMove,
    __inout_opt PLONG lpDistanceToMoveHigh,
    __in        DWORD dwMoveMethod
    );

WINBASEAPI
BOOL
WINAPI
SetFilePointerEx(
    __in      HANDLE hFile,
    __in      LARGE_INTEGER liDistanceToMove,
    __out_opt PLARGE_INTEGER lpNewFilePointer,
    __in      DWORD dwMoveMethod
    );

WINBASEAPI
BOOL
WINAPI
FindClose(
    __inout HANDLE hFindFile
    );

WINBASEAPI
BOOL
WINAPI
GetFileTime(
    __in      HANDLE hFile,
    __out_opt LPFILETIME lpCreationTime,
    __out_opt LPFILETIME lpLastAccessTime,
    __out_opt LPFILETIME lpLastWriteTime
    );

WINBASEAPI
BOOL
WINAPI
SetFileTime(
    __in     HANDLE hFile,
    __in_opt CONST FILETIME *lpCreationTime,
    __in_opt CONST FILETIME *lpLastAccessTime,
    __in_opt CONST FILETIME *lpLastWriteTime
    );


#if _WIN32_WINNT >= 0x0501

WINBASEAPI
BOOL
WINAPI
SetFileValidData(
    __in HANDLE hFile,
    __in LONGLONG ValidDataLength
    );

#endif // (_WIN32_WINNT >= 0x0501)


WINBASEAPI
BOOL
WINAPI
SetFileShortNameA(
    __in HANDLE hFile,
    __in LPCSTR lpShortName
    );
WINBASEAPI
BOOL
WINAPI
SetFileShortNameW(
    __in HANDLE hFile,
    __in LPCWSTR lpShortName
    );
#ifdef UNICODE
#define SetFileShortName  SetFileShortNameW
#else
#define SetFileShortName  SetFileShortNameA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CloseHandle(
    __in HANDLE hObject
    );

WINBASEAPI
BOOL
WINAPI
DuplicateHandle(
    __in        HANDLE hSourceProcessHandle,
    __in        HANDLE hSourceHandle,
    __in        HANDLE hTargetProcessHandle,
    __deref_out LPHANDLE lpTargetHandle,
    __in        DWORD dwDesiredAccess,
    __in        BOOL bInheritHandle,
    __in        DWORD dwOptions
    );

WINBASEAPI
BOOL
WINAPI
GetHandleInformation(
    __in  HANDLE hObject,
    __out LPDWORD lpdwFlags
    );

WINBASEAPI
BOOL
WINAPI
SetHandleInformation(
    __in HANDLE hObject,
    __in DWORD dwMask,
    __in DWORD dwFlags
    );

#define HANDLE_FLAG_INHERIT             0x00000001
#define HANDLE_FLAG_PROTECT_FROM_CLOSE  0x00000002

#define HINSTANCE_ERROR 32

WINBASEAPI
DWORD
WINAPI
LoadModule(
    __in LPCSTR lpModuleName,
    __in LPVOID lpParameterBlock
    );


__drv_preferredFunction("CreateProcess","Deprecated. See MSDN for details")
WINBASEAPI
UINT
WINAPI
WinExec(
    __in LPCSTR lpCmdLine,
    __in UINT uCmdShow
    );

WINBASEAPI
BOOL
WINAPI
ClearCommBreak(
    __in HANDLE hFile
    );

WINBASEAPI
BOOL
WINAPI
ClearCommError(
    __in      HANDLE hFile,
    __out_opt LPDWORD lpErrors,
    __out_opt LPCOMSTAT lpStat
    );

WINBASEAPI
BOOL
WINAPI
SetupComm(
    __in HANDLE hFile,
    __in DWORD dwInQueue,
    __in DWORD dwOutQueue
    );

WINBASEAPI
BOOL
WINAPI
EscapeCommFunction(
    __in HANDLE hFile,
    __in DWORD dwFunc
    );

WINBASEAPI
__success(return == TRUE)
BOOL
WINAPI
GetCommConfig(
    __in      HANDLE hCommDev,
    __out_bcount_opt(*lpdwSize) LPCOMMCONFIG lpCC,
    __inout   LPDWORD lpdwSize
    );

WINBASEAPI
BOOL
WINAPI
GetCommMask(
    __in  HANDLE hFile,
    __out LPDWORD lpEvtMask
    );

WINBASEAPI
BOOL
WINAPI
GetCommProperties(
    __in    HANDLE hFile,
    __inout LPCOMMPROP lpCommProp
    );

WINBASEAPI
BOOL
WINAPI
GetCommModemStatus(
    __in  HANDLE hFile,
    __out LPDWORD lpModemStat
    );

WINBASEAPI
BOOL
WINAPI
GetCommState(
    __in  HANDLE hFile,
    __out LPDCB lpDCB
    );

WINBASEAPI
BOOL
WINAPI
GetCommTimeouts(
    __in  HANDLE hFile,
    __out LPCOMMTIMEOUTS lpCommTimeouts
    );

WINBASEAPI
BOOL
WINAPI
PurgeComm(
    __in HANDLE hFile,
    __in DWORD dwFlags
    );

WINBASEAPI
BOOL
WINAPI
SetCommBreak(
    __in HANDLE hFile
    );

WINBASEAPI
BOOL
WINAPI
SetCommConfig(
    __in HANDLE hCommDev,
    __in_bcount(dwSize) LPCOMMCONFIG lpCC,
    __in DWORD dwSize
    );

WINBASEAPI
BOOL
WINAPI
SetCommMask(
    __in HANDLE hFile,
    __in DWORD dwEvtMask
    );

WINBASEAPI
BOOL
WINAPI
SetCommState(
    __in HANDLE hFile,
    __in LPDCB lpDCB
    );

WINBASEAPI
BOOL
WINAPI
SetCommTimeouts(
    __in HANDLE hFile,
    __in LPCOMMTIMEOUTS lpCommTimeouts
    );

WINBASEAPI
BOOL
WINAPI
TransmitCommChar(
    __in HANDLE hFile,
    __in char cChar
    );

WINBASEAPI
BOOL
WINAPI
WaitCommEvent(
    __in        HANDLE hFile,
    __inout     LPDWORD lpEvtMask,
    __inout_opt LPOVERLAPPED lpOverlapped
    );


WINBASEAPI
DWORD
WINAPI
SetTapePosition(
    __in HANDLE hDevice,
    __in DWORD dwPositionMethod,
    __in DWORD dwPartition,
    __in DWORD dwOffsetLow,
    __in DWORD dwOffsetHigh,
    __in BOOL bImmediate
    );

WINBASEAPI
DWORD
WINAPI
GetTapePosition(
    __in  HANDLE hDevice,
    __in  DWORD dwPositionType,
    __out LPDWORD lpdwPartition,
    __out LPDWORD lpdwOffsetLow,
    __out LPDWORD lpdwOffsetHigh
    );

WINBASEAPI
DWORD
WINAPI
PrepareTape(
    __in HANDLE hDevice,
    __in DWORD dwOperation,
    __in BOOL bImmediate
    );

WINBASEAPI
DWORD
WINAPI
EraseTape(
    __in HANDLE hDevice,
    __in DWORD dwEraseType,
    __in BOOL bImmediate
    );

WINBASEAPI
DWORD
WINAPI
CreateTapePartition(
    __in HANDLE hDevice,
    __in DWORD dwPartitionMethod,
    __in DWORD dwCount,
    __in DWORD dwSize
    );

WINBASEAPI
DWORD
WINAPI
WriteTapemark(
    __in HANDLE hDevice,
    __in DWORD dwTapemarkType,
    __in DWORD dwTapemarkCount,
    __in BOOL bImmediate
    );

WINBASEAPI
DWORD
WINAPI
GetTapeStatus(
    __in HANDLE hDevice
    );

WINBASEAPI
DWORD
WINAPI
GetTapeParameters(
    __in    HANDLE hDevice,
    __in    DWORD dwOperation,
    __inout LPDWORD lpdwSize,
    __out_bcount(*lpdwSize) LPVOID lpTapeInformation
    );

#define GET_TAPE_MEDIA_INFORMATION 0
#define GET_TAPE_DRIVE_INFORMATION 1

WINBASEAPI
DWORD
WINAPI
SetTapeParameters(
    __in HANDLE hDevice,
    __in DWORD dwOperation,
    __in LPVOID lpTapeInformation
    );

#define SET_TAPE_MEDIA_INFORMATION 0
#define SET_TAPE_DRIVE_INFORMATION 1

WINBASEAPI
BOOL
WINAPI
Beep(
    __in DWORD dwFreq,
    __in DWORD dwDuration
    );

WINBASEAPI
int
WINAPI
MulDiv(
    __in int nNumber,
    __in int nNumerator,
    __in int nDenominator
    );

WINBASEAPI
VOID
WINAPI
GetSystemTime(
    __out LPSYSTEMTIME lpSystemTime
    );

WINBASEAPI
VOID
WINAPI
GetSystemTimeAsFileTime(
    __out LPFILETIME lpSystemTimeAsFileTime
    );

WINBASEAPI
BOOL
WINAPI
SetSystemTime(
    __in CONST SYSTEMTIME *lpSystemTime
    );

WINBASEAPI
VOID
WINAPI
GetLocalTime(
    __out LPSYSTEMTIME lpSystemTime
    );

WINBASEAPI
BOOL
WINAPI
SetLocalTime(
    __in CONST SYSTEMTIME *lpSystemTime
    );

WINBASEAPI
VOID
WINAPI
GetSystemInfo(
    __out LPSYSTEM_INFO lpSystemInfo
    );

typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;

WINBASEAPI
DEP_SYSTEM_POLICY_TYPE
WINAPI
GetSystemDEPPolicy(
    VOID
    );

#if _WIN32_WINNT >= 0x0502

#define FILE_CACHE_FLAGS_DEFINED

#define FILE_CACHE_MAX_HARD_ENABLE      0x00000001
#define FILE_CACHE_MAX_HARD_DISABLE     0x00000002
#define FILE_CACHE_MIN_HARD_ENABLE      0x00000004
#define FILE_CACHE_MIN_HARD_DISABLE     0x00000008

WINBASEAPI
BOOL
WINAPI
SetSystemFileCacheSize (
    __in SIZE_T MinimumFileCacheSize,
    __in SIZE_T MaximumFileCacheSize,
    __in DWORD Flags
    );

WINBASEAPI
BOOL
WINAPI
GetSystemFileCacheSize (
    __out PSIZE_T lpMinimumFileCacheSize,
    __out PSIZE_T lpMaximumFileCacheSize,
    __out PDWORD lpFlags
    );

#endif // (_WIN32_WINNT >= 0x0502)

#if _WIN32_WINNT >= 0x0501

WINBASEAPI
BOOL
WINAPI
GetSystemRegistryQuota(
    __out_opt PDWORD pdwQuotaAllowed,
    __out_opt PDWORD pdwQuotaUsed
    );

BOOL
WINAPI
GetSystemTimes(
    __out_opt LPFILETIME lpIdleTime,
    __out_opt LPFILETIME lpKernelTime,
    __out_opt LPFILETIME lpUserTime
    );

#endif // (_WIN32_WINNT >= 0x0501)

#if _WIN32_WINNT >= 0x0501
WINBASEAPI
VOID
WINAPI
GetNativeSystemInfo(
    __out LPSYSTEM_INFO lpSystemInfo
    );
#endif

WINBASEAPI
BOOL
WINAPI
IsProcessorFeaturePresent(
    __in DWORD ProcessorFeature
    );

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;


WINBASEAPI
BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    __in_opt CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation,
    __in     CONST SYSTEMTIME *lpUniversalTime,
    __out    LPSYSTEMTIME lpLocalTime
    );

WINBASEAPI
BOOL
WINAPI
TzSpecificLocalTimeToSystemTime(
    __in_opt CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation,
    __in     CONST SYSTEMTIME *lpLocalTime,
    __out    LPSYSTEMTIME lpUniversalTime
    );

BOOL
WINAPI
GetTimeZoneInformationForYear(
    __in USHORT wYear,
    __in_opt PDYNAMIC_TIME_ZONE_INFORMATION pdtzi,
    __out LPTIME_ZONE_INFORMATION ptzi
    );

WINBASEAPI
DWORD
WINAPI
GetTimeZoneInformation(
    __out LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

WINBASEAPI
BOOL
WINAPI
SetTimeZoneInformation(
    __in CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );

WINBASEAPI
DWORD
WINAPI
GetDynamicTimeZoneInformation(
    __out PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
    );

WINBASEAPI
BOOL
WINAPI
SetDynamicTimeZoneInformation(
    __in CONST DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation
    );



//
// Routines to convert back and forth between system time and file time
//

WINBASEAPI
BOOL
WINAPI
SystemTimeToFileTime(
    __in  CONST SYSTEMTIME *lpSystemTime,
    __out LPFILETIME lpFileTime
    );

WINBASEAPI
BOOL
WINAPI
FileTimeToLocalFileTime(
    __in  CONST FILETIME *lpFileTime,
    __out LPFILETIME lpLocalFileTime
    );

WINBASEAPI
BOOL
WINAPI
LocalFileTimeToFileTime(
    __in  CONST FILETIME *lpLocalFileTime,
    __out LPFILETIME lpFileTime
    );

WINBASEAPI
BOOL
WINAPI
FileTimeToSystemTime(
    __in  CONST FILETIME *lpFileTime,
    __out LPSYSTEMTIME lpSystemTime
    );

WINBASEAPI
LONG
WINAPI
CompareFileTime(
    __in CONST FILETIME *lpFileTime1,
    __in CONST FILETIME *lpFileTime2
    );

WINBASEAPI
BOOL
WINAPI
FileTimeToDosDateTime(
    __in  CONST FILETIME *lpFileTime,
    __out LPWORD lpFatDate,
    __out LPWORD lpFatTime
    );

WINBASEAPI
BOOL
WINAPI
DosDateTimeToFileTime(
    __in  WORD wFatDate,
    __in  WORD wFatTime,
    __out LPFILETIME lpFileTime
    );

__drv_preferredFunction("GetTickCount64", "GetTickCount overflows roughly every 49 days.  Code that does not take that into account can loop indefinitely.  GetTickCount64 operates on 64 bit values and does not have that problem")
WINBASEAPI
DWORD
WINAPI
GetTickCount(
    VOID
    );

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
ULONGLONG
WINAPI
GetTickCount64(
    VOID
    );

#endif

WINBASEAPI
BOOL
WINAPI
SetSystemTimeAdjustment(
    __in DWORD dwTimeAdjustment,
    __in BOOL  bTimeAdjustmentDisabled
    );

WINBASEAPI
BOOL
WINAPI
GetSystemTimeAdjustment(
    __out PDWORD lpTimeAdjustment,
    __out PDWORD lpTimeIncrement,
    __out PBOOL  lpTimeAdjustmentDisabled
    );

#if !defined(MIDL_PASS)
WINBASEAPI
DWORD
WINAPI
FormatMessageA(
    __in     DWORD dwFlags,
    __in_opt LPCVOID lpSource,
    __in     DWORD dwMessageId,
    __in     DWORD dwLanguageId,
    __out    LPSTR lpBuffer,
    __in     DWORD nSize,
    __in_opt va_list *Arguments
    );
WINBASEAPI
DWORD
WINAPI
FormatMessageW(
    __in     DWORD dwFlags,
    __in_opt LPCVOID lpSource,
    __in     DWORD dwMessageId,
    __in     DWORD dwLanguageId,
    __out    LPWSTR lpBuffer,
    __in     DWORD nSize,
    __in_opt va_list *Arguments
    );
#ifdef UNICODE
#define FormatMessage  FormatMessageW
#else
#define FormatMessage  FormatMessageA
#endif // !UNICODE

#if defined(_M_CEE)
#undef FormatMessage
__inline
DWORD
FormatMessage(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPTSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    )
{
#ifdef UNICODE
    return FormatMessageW(
#else
    return FormatMessageA(
#endif
        dwFlags,
        lpSource,
        dwMessageId,
        dwLanguageId,
        lpBuffer,
        nSize,
        Arguments
        );
}
#endif  /* _M_CEE */
#endif  /* MIDL_PASS */

#define FORMAT_MESSAGE_ALLOCATE_BUFFER 0x00000100
#define FORMAT_MESSAGE_IGNORE_INSERTS  0x00000200
#define FORMAT_MESSAGE_FROM_STRING     0x00000400
#define FORMAT_MESSAGE_FROM_HMODULE    0x00000800
#define FORMAT_MESSAGE_FROM_SYSTEM     0x00001000
#define FORMAT_MESSAGE_ARGUMENT_ARRAY  0x00002000
#define FORMAT_MESSAGE_MAX_WIDTH_MASK  0x000000FF



WINBASEAPI
BOOL
WINAPI
CreatePipe(
    __out_ecount_full(1) PHANDLE hReadPipe,
    __out_ecount_full(1) PHANDLE hWritePipe,
    __in_opt LPSECURITY_ATTRIBUTES lpPipeAttributes,
    __in     DWORD nSize
    );

WINBASEAPI
BOOL
WINAPI
ConnectNamedPipe(
    __in        HANDLE hNamedPipe,
    __inout_opt LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
DisconnectNamedPipe(
    __in HANDLE hNamedPipe
    );

WINBASEAPI
BOOL
WINAPI
SetNamedPipeHandleState(
    __in     HANDLE hNamedPipe,
    __in_opt LPDWORD lpMode,
    __in_opt LPDWORD lpMaxCollectionCount,
    __in_opt LPDWORD lpCollectDataTimeout
    );

WINBASEAPI
BOOL
WINAPI
GetNamedPipeInfo(
    __in      HANDLE hNamedPipe,
    __out_opt LPDWORD lpFlags,
    __out_opt LPDWORD lpOutBufferSize,
    __out_opt LPDWORD lpInBufferSize,
    __out_opt LPDWORD lpMaxInstances
    );

WINBASEAPI
BOOL
WINAPI
PeekNamedPipe(
    __in      HANDLE hNamedPipe,
    __out_bcount_part_opt(nBufferSize, *lpBytesRead) LPVOID lpBuffer,
    __in      DWORD nBufferSize,
    __out_opt LPDWORD lpBytesRead,
    __out_opt LPDWORD lpTotalBytesAvail,
    __out_opt LPDWORD lpBytesLeftThisMessage
    );

WINBASEAPI
BOOL
WINAPI
TransactNamedPipe(
    __in        HANDLE hNamedPipe,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in        DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesRead) LPVOID lpOutBuffer,
    __in        DWORD nOutBufferSize,
    __out       LPDWORD lpBytesRead,
    __inout_opt LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
__out
HANDLE
WINAPI
CreateMailslotA(
    __in     LPCSTR lpName,
    __in     DWORD nMaxMessageSize,
    __in     DWORD lReadTimeout,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
__out
HANDLE
WINAPI
CreateMailslotW(
    __in     LPCWSTR lpName,
    __in     DWORD nMaxMessageSize,
    __in     DWORD lReadTimeout,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateMailslot  CreateMailslotW
#else
#define CreateMailslot  CreateMailslotA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetMailslotInfo(
    __in      HANDLE hMailslot,
    __out_opt LPDWORD lpMaxMessageSize,
    __out_opt LPDWORD lpNextSize,
    __out_opt LPDWORD lpMessageCount,
    __out_opt LPDWORD lpReadTimeout
    );

WINBASEAPI
BOOL
WINAPI
SetMailslotInfo(
    __in HANDLE hMailslot,
    __in DWORD lReadTimeout
    );

WINBASEAPI
__out_opt __out_data_source(FILE)
LPVOID
WINAPI
MapViewOfFile(
    __in HANDLE hFileMappingObject,
    __in DWORD dwDesiredAccess,
    __in DWORD dwFileOffsetHigh,
    __in DWORD dwFileOffsetLow,
    __in SIZE_T dwNumberOfBytesToMap
    );

WINBASEAPI
BOOL
WINAPI
FlushViewOfFile(
    __in LPCVOID lpBaseAddress,
    __in SIZE_T dwNumberOfBytesToFlush
    );

WINBASEAPI
BOOL
WINAPI
UnmapViewOfFile(
    __in LPCVOID lpBaseAddress
    );

//
// File Encryption API
//

WINADVAPI
BOOL
WINAPI
EncryptFileA(
    __in LPCSTR lpFileName
    );
WINADVAPI
BOOL
WINAPI
EncryptFileW(
    __in LPCWSTR lpFileName
    );
#ifdef UNICODE
#define EncryptFile  EncryptFileW
#else
#define EncryptFile  EncryptFileA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
DecryptFileA(
    __in       LPCSTR lpFileName,
    __reserved DWORD dwReserved
    );
WINADVAPI
BOOL
WINAPI
DecryptFileW(
    __in       LPCWSTR lpFileName,
    __reserved DWORD dwReserved
    );
#ifdef UNICODE
#define DecryptFile  DecryptFileW
#else
#define DecryptFile  DecryptFileA
#endif // !UNICODE

//
//  Encryption Status Value
//

#define FILE_ENCRYPTABLE                0
#define FILE_IS_ENCRYPTED               1
#define FILE_SYSTEM_ATTR                2
#define FILE_ROOT_DIR                   3
#define FILE_SYSTEM_DIR                 4
#define FILE_UNKNOWN                    5
#define FILE_SYSTEM_NOT_SUPPORT         6
#define FILE_USER_DISALLOWED            7
#define FILE_READ_ONLY                  8
#define FILE_DIR_DISALLOWED             9

WINADVAPI
BOOL
WINAPI
FileEncryptionStatusA(
    __in  LPCSTR lpFileName,
    __out LPDWORD  lpStatus
    );
WINADVAPI
BOOL
WINAPI
FileEncryptionStatusW(
    __in  LPCWSTR lpFileName,
    __out LPDWORD  lpStatus
    );
#ifdef UNICODE
#define FileEncryptionStatus  FileEncryptionStatusW
#else
#define FileEncryptionStatus  FileEncryptionStatusA
#endif // !UNICODE

//
// Currently defined recovery flags
//

#define EFS_USE_RECOVERY_KEYS  (0x1)

typedef
DWORD
(WINAPI *PFE_EXPORT_FUNC)(
    __in_bcount(ulLength) PBYTE pbData,
    __in_opt PVOID pvCallbackContext,
    __in     ULONG ulLength
    );

typedef
DWORD
(WINAPI *PFE_IMPORT_FUNC)(
    __out_bcount_part(*ulLength, *ulLength) PBYTE pbData,
    __in_opt PVOID pvCallbackContext,
    __inout  PULONG ulLength
    );


//
//  OpenRaw flag values
//

#define CREATE_FOR_IMPORT  (1)
#define CREATE_FOR_DIR     (2)
#define OVERWRITE_HIDDEN   (4)
#define EFSRPC_SECURE_ONLY (8)


WINADVAPI
DWORD
WINAPI
OpenEncryptedFileRawA(
    __in        LPCSTR lpFileName,
    __in        ULONG    ulFlags,
    __deref_out PVOID   *pvContext
    );
WINADVAPI
DWORD
WINAPI
OpenEncryptedFileRawW(
    __in        LPCWSTR lpFileName,
    __in        ULONG    ulFlags,
    __deref_out PVOID   *pvContext
    );
#ifdef UNICODE
#define OpenEncryptedFileRaw  OpenEncryptedFileRawW
#else
#define OpenEncryptedFileRaw  OpenEncryptedFileRawA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
ReadEncryptedFileRaw(
    __in     PFE_EXPORT_FUNC pfExportCallback,
    __in_opt PVOID           pvCallbackContext,
    __in     PVOID           pvContext
    );

WINADVAPI
DWORD
WINAPI
WriteEncryptedFileRaw(
    __in     PFE_IMPORT_FUNC pfImportCallback,
    __in_opt PVOID           pvCallbackContext,
    __in     PVOID           pvContext
    );

WINADVAPI
VOID
WINAPI
CloseEncryptedFileRaw(
    __in PVOID           pvContext
    );

//
// _l Compat Functions
//

WINBASEAPI
int
WINAPI
lstrcmpA(
    __in LPCSTR lpString1,
    __in LPCSTR lpString2
    );
WINBASEAPI
int
WINAPI
lstrcmpW(
    __in LPCWSTR lpString1,
    __in LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcmp  lstrcmpW
#else
#define lstrcmp  lstrcmpA
#endif // !UNICODE

WINBASEAPI
int
WINAPI
lstrcmpiA(
    __in LPCSTR lpString1,
    __in LPCSTR lpString2
    );
WINBASEAPI
int
WINAPI
lstrcmpiW(
    __in LPCWSTR lpString1,
    __in LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcmpi  lstrcmpiW
#else
#define lstrcmpi  lstrcmpiA
#endif // !UNICODE

WINBASEAPI
__out
LPSTR
WINAPI
lstrcpynA(
    __out_ecount(iMaxLength) LPSTR lpString1,
    __in LPCSTR lpString2,
    __in int iMaxLength
    );
WINBASEAPI
__out
LPWSTR
WINAPI
lstrcpynW(
    __out_ecount(iMaxLength) LPWSTR lpString1,
    __in LPCWSTR lpString2,
    __in int iMaxLength
    );
#ifdef UNICODE
#define lstrcpyn  lstrcpynW
#else
#define lstrcpyn  lstrcpynA
#endif // !UNICODE

#if defined(DEPRECATE_SUPPORTED)
#pragma warning(push)
#pragma warning(disable:4995)
#endif

WINBASEAPI
__out
LPSTR
WINAPI
lstrcpyA(
    __out_z LPSTR lpString1, // deprecated: annotation is as good as it gets
    __in  LPCSTR lpString2
    );
WINBASEAPI
__out
LPWSTR
WINAPI
lstrcpyW(
    __out_z LPWSTR lpString1, // deprecated: annotation is as good as it gets
    __in  LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcpy  lstrcpyW
#else
#define lstrcpy  lstrcpyA
#endif // !UNICODE

WINBASEAPI
__out
LPSTR
WINAPI
lstrcatA(
    __inout LPSTR lpString1,
    __in    LPCSTR lpString2
    );
WINBASEAPI
__out
LPWSTR
WINAPI
lstrcatW(
    __inout LPWSTR lpString1,
    __in    LPCWSTR lpString2
    );
#ifdef UNICODE
#define lstrcat  lstrcatW
#else
#define lstrcat  lstrcatA
#endif // !UNICODE

#if defined(DEPRECATE_SUPPORTED)
#pragma warning(pop)
#endif

WINBASEAPI
int
WINAPI
lstrlenA(
    __in LPCSTR lpString
    );
WINBASEAPI
int
WINAPI
lstrlenW(
    __in LPCWSTR lpString
    );
#ifdef UNICODE
#define lstrlen  lstrlenW
#else
#define lstrlen  lstrlenA
#endif // !UNICODE

WINBASEAPI
HFILE
WINAPI
OpenFile(
    __in    LPCSTR lpFileName,
    __inout LPOFSTRUCT lpReOpenBuff,
    __in    UINT uStyle
    );

WINBASEAPI
HFILE
WINAPI
_lopen(
    __in LPCSTR lpPathName,
    __in int iReadWrite
    );

WINBASEAPI
HFILE
WINAPI
_lcreat(
    __in LPCSTR lpPathName,
    __in int  iAttribute
    );

WINBASEAPI
UINT
WINAPI
_lread(
    __in HFILE hFile,
    __out_bcount_part(uBytes, return) LPVOID lpBuffer,
    __in UINT uBytes
    );

WINBASEAPI
UINT
WINAPI
_lwrite(
    __in HFILE hFile,
    __in_bcount(uBytes) LPCCH lpBuffer,
    __in UINT uBytes
    );

WINBASEAPI
long
WINAPI
_hread(
    __in HFILE hFile,
    __out_bcount_part(lBytes, return) LPVOID lpBuffer,
    __in long lBytes
    );

WINBASEAPI
long
WINAPI
_hwrite(
    __in HFILE hFile,
    __in_bcount(lBytes) LPCCH lpBuffer,
    __in long lBytes
    );

WINBASEAPI
HFILE
WINAPI
_lclose(
    __in HFILE hFile
    );

WINBASEAPI
LONG
WINAPI
_llseek(
    __in HFILE hFile,
    __in LONG lOffset,
    __in int iOrigin
    );

WINADVAPI
BOOL
WINAPI
IsTextUnicode(
    __in_bcount(iSize) CONST VOID* lpv,
    __in        int iSize,
    __inout_opt LPINT lpiResult
    );

#define FLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)

WINBASEAPI
DWORD
WINAPI
FlsAlloc(
    __in_opt PFLS_CALLBACK_FUNCTION lpCallback
    );

WINBASEAPI
PVOID
WINAPI
FlsGetValue(
    __in DWORD dwFlsIndex
    );

WINBASEAPI
BOOL
WINAPI
FlsSetValue(
    __in     DWORD dwFlsIndex,
    __in_opt PVOID lpFlsData
    );

WINBASEAPI
BOOL
WINAPI
FlsFree(
    __in DWORD dwFlsIndex
    );

#define TLS_OUT_OF_INDEXES ((DWORD)0xFFFFFFFF)

WINBASEAPI
DWORD
WINAPI
TlsAlloc(
    VOID
    );

WINBASEAPI
LPVOID
WINAPI
TlsGetValue(
    __in DWORD dwTlsIndex
    );

WINBASEAPI
BOOL
WINAPI
TlsSetValue(
    __in     DWORD dwTlsIndex,
    __in_opt LPVOID lpTlsValue
    );

WINBASEAPI
BOOL
WINAPI
TlsFree(
    __in DWORD dwTlsIndex
    );

typedef
VOID
(WINAPI *LPOVERLAPPED_COMPLETION_ROUTINE)(
    __in    DWORD dwErrorCode,
    __in    DWORD dwNumberOfBytesTransfered,
    __inout LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
DWORD
WINAPI
SleepEx(
    __in DWORD dwMilliseconds,
    __in BOOL bAlertable
    );

WINBASEAPI
DWORD
WINAPI
WaitForSingleObjectEx(
    __in HANDLE hHandle,
    __in DWORD dwMilliseconds,
    __in BOOL bAlertable
    );

WINBASEAPI
DWORD
WINAPI
WaitForMultipleObjectsEx(
    __in DWORD nCount,
    __in_ecount(nCount) CONST HANDLE *lpHandles,
    __in BOOL bWaitAll,
    __in DWORD dwMilliseconds,
    __in BOOL bAlertable
    );

#if(_WIN32_WINNT >= 0x0400)
WINBASEAPI
DWORD
WINAPI
SignalObjectAndWait(
    __in HANDLE hObjectToSignal,
    __in HANDLE hObjectToWaitOn,
    __in DWORD dwMilliseconds,
    __in BOOL bAlertable
    );
#endif /* _WIN32_WINNT >= 0x0400 */

WINBASEAPI
BOOL
WINAPI
ReadFileEx(
    __in     HANDLE hFile,
    __out_bcount_opt(nNumberOfBytesToRead) __out_data_source(FILE) LPVOID lpBuffer,
    __in     DWORD nNumberOfBytesToRead,
    __inout  LPOVERLAPPED lpOverlapped,
    __in_opt LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

WINBASEAPI
BOOL
WINAPI
WriteFileEx(
    __in     HANDLE hFile,
    __in_bcount_opt(nNumberOfBytesToWrite) LPCVOID lpBuffer,
    __in     DWORD nNumberOfBytesToWrite,
    __inout  LPOVERLAPPED lpOverlapped,
    __in_opt LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

WINBASEAPI
BOOL
WINAPI
BackupRead(
    __in    HANDLE hFile,
    __out_bcount_part(nNumberOfBytesToRead, *lpNumberOfBytesRead) LPBYTE lpBuffer,
    __in    DWORD nNumberOfBytesToRead,
    __out   LPDWORD lpNumberOfBytesRead,
    __in    BOOL bAbort,
    __in    BOOL bProcessSecurity,
    __inout LPVOID *lpContext
    );

WINBASEAPI
BOOL
WINAPI
BackupSeek(
    __in    HANDLE hFile,
    __in    DWORD  dwLowBytesToSeek,
    __in    DWORD  dwHighBytesToSeek,
    __out   LPDWORD lpdwLowByteSeeked,
    __out   LPDWORD lpdwHighByteSeeked,
    __inout LPVOID *lpContext
    );

WINBASEAPI
BOOL
WINAPI
BackupWrite(
    __in    HANDLE hFile,
    __in_bcount(nNumberOfBytesToWrite) LPBYTE lpBuffer,
    __in    DWORD nNumberOfBytesToWrite,
    __out   LPDWORD lpNumberOfBytesWritten,
    __in    BOOL bAbort,
    __in    BOOL bProcessSecurity,
    __inout LPVOID *lpContext
    );

//
//  Stream id structure
//
typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ ANYSIZE_ARRAY ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;

//
//  Stream Ids
//

#define BACKUP_INVALID          0x00000000
#define BACKUP_DATA             0x00000001
#define BACKUP_EA_DATA          0x00000002
#define BACKUP_SECURITY_DATA    0x00000003
#define BACKUP_ALTERNATE_DATA   0x00000004
#define BACKUP_LINK             0x00000005
#define BACKUP_PROPERTY_DATA    0x00000006
#define BACKUP_OBJECT_ID        0x00000007
#define BACKUP_REPARSE_DATA     0x00000008
#define BACKUP_SPARSE_BLOCK     0x00000009
#define BACKUP_TXFS_DATA        0x0000000a


//
//  Stream Attributes
//

#define STREAM_NORMAL_ATTRIBUTE         0x00000000
#define STREAM_MODIFIED_WHEN_READ       0x00000001
#define STREAM_CONTAINS_SECURITY        0x00000002
#define STREAM_CONTAINS_PROPERTIES      0x00000004
#define STREAM_SPARSE_ATTRIBUTE         0x00000008

WINBASEAPI
BOOL
WINAPI
ReadFileScatter(
    __in       HANDLE hFile,
    __in       FILE_SEGMENT_ELEMENT aSegmentArray[],
    __in       DWORD nNumberOfBytesToRead,
    __reserved LPDWORD lpReserved,
    __inout    LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
WriteFileGather(
    __in       HANDLE hFile,
    __in       FILE_SEGMENT_ELEMENT aSegmentArray[],
    __in       DWORD nNumberOfBytesToWrite,
    __reserved LPDWORD lpReserved,
    __inout    LPOVERLAPPED lpOverlapped
    );

//
// Dual Mode API below this line. Dual Mode Structures also included.
//

#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_USECOUNTCHARS    0x00000008
#define STARTF_USEFILLATTRIBUTE 0x00000010
#define STARTF_RUNFULLSCREEN    0x00000020  // ignored for non-x86 platforms
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USESTDHANDLES    0x00000100

#if(WINVER >= 0x0400)

#define STARTF_USEHOTKEY        0x00000200
#define STARTF_TITLEISLINKNAME  0x00000800
#define STARTF_TITLEISAPPID     0x00001000
#define STARTF_PREVENTPINNING   0x00002000
#endif /* WINVER >= 0x0400 */

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;
#ifdef UNICODE
typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;
#else
typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#endif // UNICODE

#if (_WIN32_WINNT >= 0x0600)

typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;
#ifdef UNICODE
typedef STARTUPINFOEXW STARTUPINFOEX;
typedef LPSTARTUPINFOEXW LPSTARTUPINFOEX;
#else
typedef STARTUPINFOEXA STARTUPINFOEX;
typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX;
#endif // UNICODE

#endif // (_WIN32_WINNT >= 0x0600)

#define SHUTDOWN_NORETRY                0x00000001

typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR   cFileName[ MAX_PATH ];
    CHAR   cAlternateFileName[ 14 ];
#ifdef _MAC
    DWORD dwFileType;
    DWORD dwCreatorType;
    WORD  wFinderFlags;
#endif
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR  cFileName[ MAX_PATH ];
    WCHAR  cAlternateFileName[ 14 ];
#ifdef _MAC
    DWORD dwFileType;
    DWORD dwCreatorType;
    WORD  wFinderFlags;
#endif
} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;
#ifdef UNICODE
typedef WIN32_FIND_DATAW WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;
#else
typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
#endif // UNICODE

typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

//
// Synchronization APIs
//

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateMutexA(
    __in_opt LPSECURITY_ATTRIBUTES lpMutexAttributes,
    __in     BOOL bInitialOwner,
    __in_opt LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateMutexW(
    __in_opt LPSECURITY_ATTRIBUTES lpMutexAttributes,
    __in     BOOL bInitialOwner,
    __in_opt LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateMutex  CreateMutexW
#else
#define CreateMutex  CreateMutexA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenMutexA(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenMutexW(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenMutex  OpenMutexW
#else
#define OpenMutex  OpenMutexA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateEventA(
    __in_opt LPSECURITY_ATTRIBUTES lpEventAttributes,
    __in     BOOL bManualReset,
    __in     BOOL bInitialState,
    __in_opt LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateEventW(
    __in_opt LPSECURITY_ATTRIBUTES lpEventAttributes,
    __in     BOOL bManualReset,
    __in     BOOL bInitialState,
    __in_opt LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateEvent  CreateEventW
#else
#define CreateEvent  CreateEventA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenEventA(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenEventW(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenEvent  OpenEventW
#else
#define OpenEvent  OpenEventA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateSemaphoreA(
    __in_opt LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    __in     LONG lInitialCount,
    __in     LONG lMaximumCount,
    __in_opt LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateSemaphoreW(
    __in_opt LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    __in     LONG lInitialCount,
    __in     LONG lMaximumCount,
    __in_opt LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateSemaphore  CreateSemaphoreW
#else
#define CreateSemaphore  CreateSemaphoreA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenSemaphoreA(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenSemaphoreW(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenSemaphore  OpenSemaphoreW
#else
#define OpenSemaphore  OpenSemaphoreA
#endif // !UNICODE

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
typedef
VOID
(APIENTRY *PTIMERAPCROUTINE)(
    __in_opt LPVOID lpArgToCompletionRoutine,
    __in     DWORD dwTimerLowValue,
    __in     DWORD dwTimerHighValue
    );

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateWaitableTimerA(
    __in_opt LPSECURITY_ATTRIBUTES lpTimerAttributes,
    __in     BOOL bManualReset,
    __in_opt LPCSTR lpTimerName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateWaitableTimerW(
    __in_opt LPSECURITY_ATTRIBUTES lpTimerAttributes,
    __in     BOOL bManualReset,
    __in_opt LPCWSTR lpTimerName
    );
#ifdef UNICODE
#define CreateWaitableTimer  CreateWaitableTimerW
#else
#define CreateWaitableTimer  CreateWaitableTimerA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenWaitableTimerA(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCSTR lpTimerName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenWaitableTimerW(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCWSTR lpTimerName
    );
#ifdef UNICODE
#define OpenWaitableTimer  OpenWaitableTimerW
#else
#define OpenWaitableTimer  OpenWaitableTimerA
#endif // !UNICODE

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

BOOL
WINAPI
SetWaitableTimerEx(
    __in     HANDLE hTimer,
    __in     const LARGE_INTEGER *lpDueTime,
    __in     LONG lPeriod,
    __in_opt PTIMERAPCROUTINE pfnCompletionRoutine,
    __in_opt LPVOID lpArgToCompletionRoutine,
    __in_opt PREASON_CONTEXT WakeContext,
    __in     ULONG TolerableDelay
    );

#endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

WINBASEAPI
BOOL
WINAPI
SetWaitableTimer(
    __in     HANDLE hTimer,
    __in     const LARGE_INTEGER *lpDueTime,
    __in     LONG lPeriod,
    __in_opt PTIMERAPCROUTINE pfnCompletionRoutine,
    __in_opt LPVOID lpArgToCompletionRoutine,
    __in     BOOL fResume
    );

WINBASEAPI
BOOL
WINAPI
CancelWaitableTimer(
    __in HANDLE hTimer
    );

#if (_WIN32_WINNT >= 0x0600)

#define CREATE_MUTEX_INITIAL_OWNER  0x00000001

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateMutexExA(
    __in_opt LPSECURITY_ATTRIBUTES lpMutexAttributes,
    __in_opt LPCSTR lpName,
    __in     DWORD dwFlags,
    __in     DWORD dwDesiredAccess
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateMutexExW(
    __in_opt LPSECURITY_ATTRIBUTES lpMutexAttributes,
    __in_opt LPCWSTR lpName,
    __in     DWORD dwFlags,
    __in     DWORD dwDesiredAccess
    );
#ifdef UNICODE
#define CreateMutexEx  CreateMutexExW
#else
#define CreateMutexEx  CreateMutexExA
#endif // !UNICODE

#define CREATE_EVENT_MANUAL_RESET   0x00000001
#define CREATE_EVENT_INITIAL_SET    0x00000002

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateEventExA(
    __in_opt LPSECURITY_ATTRIBUTES lpEventAttributes,
    __in_opt LPCSTR lpName,
    __in     DWORD dwFlags,
    __in     DWORD dwDesiredAccess
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateEventExW(
    __in_opt LPSECURITY_ATTRIBUTES lpEventAttributes,
    __in_opt LPCWSTR lpName,
    __in     DWORD dwFlags,
    __in     DWORD dwDesiredAccess
    );
#ifdef UNICODE
#define CreateEventEx  CreateEventExW
#else
#define CreateEventEx  CreateEventExA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateSemaphoreExA(
    __in_opt    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    __in        LONG lInitialCount,
    __in        LONG lMaximumCount,
    __in_opt    LPCSTR lpName,
    __reserved  DWORD dwFlags,
    __in        DWORD dwDesiredAccess
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateSemaphoreExW(
    __in_opt    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    __in        LONG lInitialCount,
    __in        LONG lMaximumCount,
    __in_opt    LPCWSTR lpName,
    __reserved  DWORD dwFlags,
    __in        DWORD dwDesiredAccess
    );
#ifdef UNICODE
#define CreateSemaphoreEx  CreateSemaphoreExW
#else
#define CreateSemaphoreEx  CreateSemaphoreExA
#endif // !UNICODE

#define CREATE_WAITABLE_TIMER_MANUAL_RESET  0x00000001

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateWaitableTimerExA(
    __in_opt LPSECURITY_ATTRIBUTES lpTimerAttributes,
    __in_opt LPCSTR lpTimerName,
    __in     DWORD dwFlags,
    __in     DWORD dwDesiredAccess
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateWaitableTimerExW(
    __in_opt LPSECURITY_ATTRIBUTES lpTimerAttributes,
    __in_opt LPCWSTR lpTimerName,
    __in     DWORD dwFlags,
    __in     DWORD dwDesiredAccess
    );
#ifdef UNICODE
#define CreateWaitableTimerEx  CreateWaitableTimerExW
#else
#define CreateWaitableTimerEx  CreateWaitableTimerExA
#endif // !UNICODE

#endif /* (_WIN32_WINNT >= 0x0600) */

#endif /* (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400) */

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateFileMappingA(
    __in     HANDLE hFile,
    __in_opt LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    __in     DWORD flProtect,
    __in     DWORD dwMaximumSizeHigh,
    __in     DWORD dwMaximumSizeLow,
    __in_opt LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateFileMappingW(
    __in     HANDLE hFile,
    __in_opt LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    __in     DWORD flProtect,
    __in     DWORD dwMaximumSizeHigh,
    __in     DWORD dwMaximumSizeLow,
    __in_opt LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateFileMapping  CreateFileMappingW
#else
#define CreateFileMapping  CreateFileMappingA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateFileMappingNumaA(
    __in     HANDLE hFile,
    __in_opt LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    __in     DWORD flProtect,
    __in     DWORD dwMaximumSizeHigh,
    __in     DWORD dwMaximumSizeLow,
    __in_opt LPCSTR lpName,
    __in     DWORD nndPreferred
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateFileMappingNumaW(
    __in     HANDLE hFile,
    __in_opt LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    __in     DWORD flProtect,
    __in     DWORD dwMaximumSizeHigh,
    __in     DWORD dwMaximumSizeLow,
    __in_opt LPCWSTR lpName,
    __in     DWORD nndPreferred
    );
#ifdef UNICODE
#define CreateFileMappingNuma  CreateFileMappingNumaW
#else
#define CreateFileMappingNuma  CreateFileMappingNumaA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
__out
HANDLE
WINAPI
OpenFileMappingA(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCSTR lpName
    );
WINBASEAPI
__out
HANDLE
WINAPI
OpenFileMappingW(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenFileMapping  OpenFileMappingW
#else
#define OpenFileMapping  OpenFileMappingA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetLogicalDriveStringsA(
    __in DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPSTR lpBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetLogicalDriveStringsW(
    __in DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetLogicalDriveStrings  GetLogicalDriveStringsW
#else
#define GetLogicalDriveStrings  GetLogicalDriveStringsA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0501

typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateMemoryResourceNotification(
    __in MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    );

WINBASEAPI
BOOL
WINAPI
QueryMemoryResourceNotification(
    __in  HANDLE ResourceNotificationHandle,
    __out PBOOL  ResourceState
    );

#endif // _WIN32_WINNT >= 0x0501


WINBASEAPI
__out_opt
HMODULE
WINAPI
LoadLibraryA(
    __in LPCSTR lpLibFileName
    );
WINBASEAPI
__out_opt
HMODULE
WINAPI
LoadLibraryW(
    __in LPCWSTR lpLibFileName
    );
#ifdef UNICODE
#define LoadLibrary  LoadLibraryW
#else
#define LoadLibrary  LoadLibraryA
#endif // !UNICODE

WINBASEAPI
__out_opt
HMODULE
WINAPI
LoadLibraryExA(
    __in       LPCSTR lpLibFileName,
    __reserved HANDLE hFile,
    __in       DWORD dwFlags
    );
WINBASEAPI
__out_opt
HMODULE
WINAPI
LoadLibraryExW(
    __in       LPCWSTR lpLibFileName,
    __reserved HANDLE hFile,
    __in       DWORD dwFlags
    );
#ifdef UNICODE
#define LoadLibraryEx  LoadLibraryExW
#else
#define LoadLibraryEx  LoadLibraryExA
#endif // !UNICODE

#define DONT_RESOLVE_DLL_REFERENCES         0x00000001
#define LOAD_LIBRARY_AS_DATAFILE            0x00000002
#define LOAD_WITH_ALTERED_SEARCH_PATH       0x00000008
#define LOAD_IGNORE_CODE_AUTHZ_LEVEL        0x00000010
#define LOAD_LIBRARY_AS_IMAGE_RESOURCE      0x00000020
#define LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE  0x00000040
#define LOAD_LIBRARY_REQUIRE_SIGNED_TARGET  0x00000080

WINBASEAPI
DWORD
WINAPI
GetModuleFileNameA(
    __in_opt HMODULE hModule,
    __out_ecount_part(nSize, return + 1) LPSTR lpFilename,
    __in     DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetModuleFileNameW(
    __in_opt HMODULE hModule,
    __out_ecount_part(nSize, return + 1) LPWSTR lpFilename,
    __in     DWORD nSize
    );
#ifdef UNICODE
#define GetModuleFileName  GetModuleFileNameW
#else
#define GetModuleFileName  GetModuleFileNameA
#endif // !UNICODE

WINBASEAPI
__out_opt
HMODULE
WINAPI
GetModuleHandleA(
    __in_opt LPCSTR lpModuleName
    );
WINBASEAPI
__out_opt
HMODULE
WINAPI
GetModuleHandleW(
    __in_opt LPCWSTR lpModuleName
    );
#ifdef UNICODE
#define GetModuleHandle  GetModuleHandleW
#else
#define GetModuleHandle  GetModuleHandleA
#endif // !UNICODE

#if !defined(RC_INVOKED)
#if _WIN32_WINNT > 0x0500 || defined(WINBASE_DECLARE_GET_MODULE_HANDLE_EX) || ISOLATION_AWARE_ENABLED

#define GET_MODULE_HANDLE_EX_FLAG_PIN                 (0x00000001)
#define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT  (0x00000002)
#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS        (0x00000004)

typedef
BOOL
(WINAPI*
PGET_MODULE_HANDLE_EXA)(
    __in        DWORD        dwFlags,
    __in_opt    LPCSTR     lpModuleName,
    __deref_out HMODULE*    phModule
    );
typedef
BOOL
(WINAPI*
PGET_MODULE_HANDLE_EXW)(
    __in        DWORD        dwFlags,
    __in_opt    LPCWSTR     lpModuleName,
    __deref_out HMODULE*    phModule
    );
#ifdef UNICODE
#define PGET_MODULE_HANDLE_EX  PGET_MODULE_HANDLE_EXW
#else
#define PGET_MODULE_HANDLE_EX  PGET_MODULE_HANDLE_EXA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetModuleHandleExA(
    __in        DWORD    dwFlags,
    __in_opt    LPCSTR lpModuleName,
    __out HMODULE* phModule
    );
WINBASEAPI
BOOL
WINAPI
GetModuleHandleExW(
    __in        DWORD    dwFlags,
    __in_opt    LPCWSTR lpModuleName,
    __out HMODULE* phModule
    );
#ifdef UNICODE
#define GetModuleHandleEx  GetModuleHandleExW
#else
#define GetModuleHandleEx  GetModuleHandleExA
#endif // !UNICODE

#endif
#endif

#if _WIN32_WINNT >= 0x0502

WINBASEAPI
BOOL
WINAPI
NeedCurrentDirectoryForExePathA(
    __in LPCSTR ExeName
    );
WINBASEAPI
BOOL
WINAPI
NeedCurrentDirectoryForExePathW(
    __in LPCWSTR ExeName
    );
#ifdef UNICODE
#define NeedCurrentDirectoryForExePath  NeedCurrentDirectoryForExePathW
#else
#define NeedCurrentDirectoryForExePath  NeedCurrentDirectoryForExePathA
#endif // !UNICODE

#endif

#if _WIN32_WINNT >= 0x0600

#define PROCESS_NAME_NATIVE     0x00000001

WINBASEAPI
BOOL
WINAPI
QueryFullProcessImageNameA(
    __in HANDLE hProcess,
    __in DWORD dwFlags,
    __out_ecount_part(*lpdwSize, *lpdwSize) LPSTR lpExeName,
    __inout PDWORD lpdwSize
    );
WINBASEAPI
BOOL
WINAPI
QueryFullProcessImageNameW(
    __in HANDLE hProcess,
    __in DWORD dwFlags,
    __out_ecount_part(*lpdwSize, *lpdwSize) LPWSTR lpExeName,
    __inout PDWORD lpdwSize
    );
#ifdef UNICODE
#define QueryFullProcessImageName  QueryFullProcessImageNameW
#else
#define QueryFullProcessImageName  QueryFullProcessImageNameA
#endif // !UNICODE

#endif

#if (_WIN32_WINNT >= 0x0600)

//
// Extended process and thread attribute support
//

#define PROC_THREAD_ATTRIBUTE_NUMBER    0x0000FFFF
#define PROC_THREAD_ATTRIBUTE_THREAD    0x00010000  // Attribute may be used with thread creation
#define PROC_THREAD_ATTRIBUTE_INPUT     0x00020000  // Attribute is input only
#define PROC_THREAD_ATTRIBUTE_ADDITIVE  0x00040000  // Attribute may be "accumulated," e.g. bitmasks, counters, etc.

typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeExtendedFlags,
    ProcThreadAttributeHandleList,
    ProcThreadAttributeGroupAffinity,
    ProcThreadAttributePreferredNode,
    ProcThreadAttributeIdealProcessor,
    ProcThreadAttributeUmsThread,
    ProcThreadAttributeMitigationPolicy,
    ProcThreadAttributeMax
} PROC_THREAD_ATTRIBUTE_NUM;

#define ProcThreadAttributeValue(Number, Thread, Input, Additive) \
    (((Number) & PROC_THREAD_ATTRIBUTE_NUMBER) | \
     ((Thread != FALSE) ? PROC_THREAD_ATTRIBUTE_THREAD : 0) | \
     ((Input != FALSE) ? PROC_THREAD_ATTRIBUTE_INPUT : 0) | \
     ((Additive != FALSE) ? PROC_THREAD_ATTRIBUTE_ADDITIVE : 0))

#define PROC_THREAD_ATTRIBUTE_PARENT_PROCESS \
    ProcThreadAttributeValue (ProcThreadAttributeParentProcess, FALSE, TRUE, FALSE)
#define PROC_THREAD_ATTRIBUTE_EXTENDED_FLAGS \
    ProcThreadAttributeValue (ProcThreadAttributeExtendedFlags, FALSE, TRUE, TRUE)
#define PROC_THREAD_ATTRIBUTE_HANDLE_LIST \
    ProcThreadAttributeValue (ProcThreadAttributeHandleList, FALSE, TRUE, FALSE)
#define PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY \
    ProcThreadAttributeValue (ProcThreadAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PROC_THREAD_ATTRIBUTE_PREFERRED_NODE \
    ProcThreadAttributeValue (ProcThreadAttributePreferredNode, FALSE, TRUE, FALSE)
#define PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR \
    ProcThreadAttributeValue (ProcThreadAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PROC_THREAD_ATTRIBUTE_UMS_THREAD \
    ProcThreadAttributeValue (ProcThreadAttributeUmsThread, TRUE, TRUE, FALSE)
#define PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY \
    ProcThreadAttributeValue (ProcThreadAttributeMitigationPolicy, FALSE, TRUE, FALSE)


#define PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE            0x01
#define PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE  0x02
#define PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE          0x04

WINBASEAPI
BOOL
WINAPI
InitializeProcThreadAttributeList(
    __out_xcount_opt(*lpSize) LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    __in DWORD dwAttributeCount,
    __reserved DWORD dwFlags,
    __inout PSIZE_T lpSize
    );

WINBASEAPI
VOID
WINAPI
DeleteProcThreadAttributeList(
    __inout LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );

#define PROC_THREAD_ATTRIBUTE_REPLACE_VALUE     0x00000001

WINBASEAPI
BOOL
WINAPI
UpdateProcThreadAttribute(
    __inout LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    __in DWORD dwFlags,
    __in DWORD_PTR Attribute,
    __in_bcount_opt(cbSize) PVOID lpValue,
    __in SIZE_T cbSize,
    __out_bcount_opt(cbSize) PVOID lpPreviousValue,
    __in_opt PSIZE_T lpReturnSize
    );

#endif // (_WIN32_WINNT >= 0x0600)


WINBASEAPI
BOOL
WINAPI
CreateProcessA(
    __in_opt    LPCSTR lpApplicationName,
    __inout_opt LPSTR lpCommandLine,
    __in_opt    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    __in_opt    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    __in        BOOL bInheritHandles,
    __in        DWORD dwCreationFlags,
    __in_opt    LPVOID lpEnvironment,
    __in_opt    LPCSTR lpCurrentDirectory,
    __in        LPSTARTUPINFOA lpStartupInfo,
    __out       LPPROCESS_INFORMATION lpProcessInformation
    );
WINBASEAPI
BOOL
WINAPI
CreateProcessW(
    __in_opt    LPCWSTR lpApplicationName,
    __inout_opt LPWSTR lpCommandLine,
    __in_opt    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    __in_opt    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    __in        BOOL bInheritHandles,
    __in        DWORD dwCreationFlags,
    __in_opt    LPVOID lpEnvironment,
    __in_opt    LPCWSTR lpCurrentDirectory,
    __in        LPSTARTUPINFOW lpStartupInfo,
    __out       LPPROCESS_INFORMATION lpProcessInformation
    );
#ifdef UNICODE
#define CreateProcess  CreateProcessW
#else
#define CreateProcess  CreateProcessA
#endif // !UNICODE



WINBASEAPI
BOOL
WINAPI
SetProcessShutdownParameters(
    __in DWORD dwLevel,
    __in DWORD dwFlags
    );

WINBASEAPI
BOOL
WINAPI
GetProcessShutdownParameters(
    __out LPDWORD lpdwLevel,
    __out LPDWORD lpdwFlags
    );

WINBASEAPI
DWORD
WINAPI
GetProcessVersion(
    __in DWORD ProcessId
    );

WINBASEAPI
VOID
WINAPI
FatalAppExitA(
    __in UINT uAction,
    __in LPCSTR lpMessageText
    );
WINBASEAPI
VOID
WINAPI
FatalAppExitW(
    __in UINT uAction,
    __in LPCWSTR lpMessageText
    );
#ifdef UNICODE
#define FatalAppExit  FatalAppExitW
#else
#define FatalAppExit  FatalAppExitA
#endif // !UNICODE

WINBASEAPI
VOID
WINAPI
GetStartupInfoA(
    __out LPSTARTUPINFOA lpStartupInfo
    );
WINBASEAPI
VOID
WINAPI
GetStartupInfoW(
    __out LPSTARTUPINFOW lpStartupInfo
    );
#ifdef UNICODE
#define GetStartupInfo  GetStartupInfoW
#else
#define GetStartupInfo  GetStartupInfoA
#endif // !UNICODE

WINBASEAPI
__out
LPSTR
WINAPI
GetCommandLineA(
    VOID
    );
WINBASEAPI
__out
LPWSTR
WINAPI
GetCommandLineW(
    VOID
    );
#ifdef UNICODE
#define GetCommandLine  GetCommandLineW
#else
#define GetCommandLine  GetCommandLineA
#endif // !UNICODE

WINBASEAPI
__success(return < nSize)
__success(return != 0)
DWORD
WINAPI
GetEnvironmentVariableA(
    __in_opt LPCSTR lpName,
    __out_ecount_part_opt(nSize, return + 1) LPSTR lpBuffer,
    __in DWORD nSize
    );
WINBASEAPI
__success(return < nSize)
__success(return != 0)
DWORD
WINAPI
GetEnvironmentVariableW(
    __in_opt LPCWSTR lpName,
    __out_ecount_part_opt(nSize, return + 1) LPWSTR lpBuffer,
    __in DWORD nSize
    );
#ifdef UNICODE
#define GetEnvironmentVariable  GetEnvironmentVariableW
#else
#define GetEnvironmentVariable  GetEnvironmentVariableA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetEnvironmentVariable
__inline
DWORD
GetEnvironmentVariable(
    __in_opt LPCTSTR lpName,
    __out_ecount_part_opt(nSize, return + 1) LPTSTR lpBuffer,
    __in DWORD nSize
    )
{
#ifdef UNICODE
    return GetEnvironmentVariableW(
#else
    return GetEnvironmentVariableA(
#endif
        lpName,
        lpBuffer,
        nSize
        );
}
#endif  /* _M_CEE */

WINBASEAPI
BOOL
WINAPI
SetEnvironmentVariableA(
    __in     LPCSTR lpName,
    __in_opt LPCSTR lpValue
    );
WINBASEAPI
BOOL
WINAPI
SetEnvironmentVariableW(
    __in     LPCWSTR lpName,
    __in_opt LPCWSTR lpValue
    );
#ifdef UNICODE
#define SetEnvironmentVariable  SetEnvironmentVariableW
#else
#define SetEnvironmentVariable  SetEnvironmentVariableA
#endif // !UNICODE

#if defined(_M_CEE)
#undef SetEnvironmentVariable
__inline
BOOL
SetEnvironmentVariable(
    LPCTSTR lpName,
    LPCTSTR lpValue
    )
{
#ifdef UNICODE
    return SetEnvironmentVariableW(
#else
    return SetEnvironmentVariableA(
#endif
        lpName,
        lpValue
        );
}
#endif  /* _M_CEE */

WINBASEAPI
__success(return <= nSize)
__success(return != 0)
DWORD
WINAPI
ExpandEnvironmentStringsA(
    __in LPCSTR lpSrc,
    __out_ecount_part_opt(nSize, return) LPSTR lpDst,
    __in DWORD nSize
    );
WINBASEAPI
__success(return <= nSize)
__success(return != 0)
DWORD
WINAPI
ExpandEnvironmentStringsW(
    __in LPCWSTR lpSrc,
    __out_ecount_part_opt(nSize, return) LPWSTR lpDst,
    __in DWORD nSize
    );
#ifdef UNICODE
#define ExpandEnvironmentStrings  ExpandEnvironmentStringsW
#else
#define ExpandEnvironmentStrings  ExpandEnvironmentStringsA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetFirmwareEnvironmentVariableA(
    __in LPCSTR lpName,
    __in LPCSTR lpGuid,
    __out_bcount_part_opt(nSize, return) PVOID pBuffer,
    __in DWORD    nSize
    );
WINBASEAPI
DWORD
WINAPI
GetFirmwareEnvironmentVariableW(
    __in LPCWSTR lpName,
    __in LPCWSTR lpGuid,
    __out_bcount_part_opt(nSize, return) PVOID pBuffer,
    __in DWORD    nSize
    );
#ifdef UNICODE
#define GetFirmwareEnvironmentVariable  GetFirmwareEnvironmentVariableW
#else
#define GetFirmwareEnvironmentVariable  GetFirmwareEnvironmentVariableA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetFirmwareEnvironmentVariableA(
    __in LPCSTR lpName,
    __in LPCSTR lpGuid,
    __in_bcount_opt(nSize) PVOID pValue,
    __in DWORD    nSize
    );
WINBASEAPI
BOOL
WINAPI
SetFirmwareEnvironmentVariableW(
    __in LPCWSTR lpName,
    __in LPCWSTR lpGuid,
    __in_bcount_opt(nSize) PVOID pValue,
    __in DWORD    nSize
    );
#ifdef UNICODE
#define SetFirmwareEnvironmentVariable  SetFirmwareEnvironmentVariableW
#else
#define SetFirmwareEnvironmentVariable  SetFirmwareEnvironmentVariableA
#endif // !UNICODE


WINBASEAPI
VOID
WINAPI
OutputDebugStringA(
    __in_opt LPCSTR lpOutputString
    );
WINBASEAPI
VOID
WINAPI
OutputDebugStringW(
    __in_opt LPCWSTR lpOutputString
    );
#ifdef UNICODE
#define OutputDebugString  OutputDebugStringW
#else
#define OutputDebugString  OutputDebugStringA
#endif // !UNICODE

WINBASEAPI
__out_opt
HRSRC
WINAPI
FindResourceA(
    __in_opt HMODULE hModule,
    __in     LPCSTR lpName,
    __in     LPCSTR lpType
    );
WINBASEAPI
__out_opt
HRSRC
WINAPI
FindResourceW(
    __in_opt HMODULE hModule,
    __in     LPCWSTR lpName,
    __in     LPCWSTR lpType
    );
#ifdef UNICODE
#define FindResource  FindResourceW
#else
#define FindResource  FindResourceA
#endif // !UNICODE

WINBASEAPI
__out_opt
HRSRC
WINAPI
FindResourceExA(
    __in_opt HMODULE hModule,
    __in     LPCSTR lpType,
    __in     LPCSTR lpName,
    __in     WORD    wLanguage
    );
WINBASEAPI
__out_opt
HRSRC
WINAPI
FindResourceExW(
    __in_opt HMODULE hModule,
    __in     LPCWSTR lpType,
    __in     LPCWSTR lpName,
    __in     WORD    wLanguage
    );
#ifdef UNICODE
#define FindResourceEx  FindResourceExW
#else
#define FindResourceEx  FindResourceExA
#endif // !UNICODE

#ifdef STRICT
typedef BOOL (CALLBACK* ENUMRESTYPEPROCA)(__in_opt HMODULE hModule, __in LPSTR lpType,
__in LONG_PTR lParam);
typedef BOOL (CALLBACK* ENUMRESTYPEPROCW)(__in_opt HMODULE hModule, __in LPWSTR lpType,
__in LONG_PTR lParam);
#ifdef UNICODE
#define ENUMRESTYPEPROC  ENUMRESTYPEPROCW
#else
#define ENUMRESTYPEPROC  ENUMRESTYPEPROCA
#endif // !UNICODE
typedef BOOL (CALLBACK* ENUMRESNAMEPROCA)(__in_opt HMODULE hModule, __in LPCSTR lpType,
__in LPSTR lpName, __in LONG_PTR lParam);
typedef BOOL (CALLBACK* ENUMRESNAMEPROCW)(__in_opt HMODULE hModule, __in LPCWSTR lpType,
__in LPWSTR lpName, __in LONG_PTR lParam);
#ifdef UNICODE
#define ENUMRESNAMEPROC  ENUMRESNAMEPROCW
#else
#define ENUMRESNAMEPROC  ENUMRESNAMEPROCA
#endif // !UNICODE
typedef BOOL (CALLBACK* ENUMRESLANGPROCA)(__in_opt HMODULE hModule, __in LPCSTR lpType,
__in LPCSTR lpName, __in WORD  wLanguage, __in LONG_PTR lParam);
typedef BOOL (CALLBACK* ENUMRESLANGPROCW)(__in_opt HMODULE hModule, __in LPCWSTR lpType,
__in LPCWSTR lpName, __in WORD  wLanguage, __in LONG_PTR lParam);
#ifdef UNICODE
#define ENUMRESLANGPROC  ENUMRESLANGPROCW
#else
#define ENUMRESLANGPROC  ENUMRESLANGPROCA
#endif // !UNICODE
#else
typedef FARPROC ENUMRESTYPEPROCA;
typedef FARPROC ENUMRESTYPEPROCW;
#ifdef UNICODE
typedef ENUMRESTYPEPROCW ENUMRESTYPEPROC;
#else
typedef ENUMRESTYPEPROCA ENUMRESTYPEPROC;
#endif // UNICODE
typedef FARPROC ENUMRESNAMEPROCA;
typedef FARPROC ENUMRESNAMEPROCW;
#ifdef UNICODE
typedef ENUMRESNAMEPROCW ENUMRESNAMEPROC;
#else
typedef ENUMRESNAMEPROCA ENUMRESNAMEPROC;
#endif // UNICODE
typedef FARPROC ENUMRESLANGPROCA;
typedef FARPROC ENUMRESLANGPROCW;
#ifdef UNICODE
typedef ENUMRESLANGPROCW ENUMRESLANGPROC;
#else
typedef ENUMRESLANGPROCA ENUMRESLANGPROC;
#endif // UNICODE
#endif

WINBASEAPI
BOOL
WINAPI
EnumResourceTypesA(
    __in_opt HMODULE hModule,
    __in     ENUMRESTYPEPROCA lpEnumFunc,
    __in     LONG_PTR lParam
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceTypesW(
    __in_opt HMODULE hModule,
    __in     ENUMRESTYPEPROCW lpEnumFunc,
    __in     LONG_PTR lParam
    );
#ifdef UNICODE
#define EnumResourceTypes  EnumResourceTypesW
#else
#define EnumResourceTypes  EnumResourceTypesA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumResourceNamesA(
    __in_opt HMODULE hModule,
    __in     LPCSTR lpType,
    __in     ENUMRESNAMEPROCA lpEnumFunc,
    __in     LONG_PTR lParam
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceNamesW(
    __in_opt HMODULE hModule,
    __in     LPCWSTR lpType,
    __in     ENUMRESNAMEPROCW lpEnumFunc,
    __in     LONG_PTR lParam
    );
#ifdef UNICODE
#define EnumResourceNames  EnumResourceNamesW
#else
#define EnumResourceNames  EnumResourceNamesA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumResourceLanguagesA(
    __in_opt HMODULE hModule,
    __in     LPCSTR lpType,
    __in     LPCSTR lpName,
    __in     ENUMRESLANGPROCA lpEnumFunc,
    __in     LONG_PTR lParam
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceLanguagesW(
    __in_opt HMODULE hModule,
    __in     LPCWSTR lpType,
    __in     LPCWSTR lpName,
    __in     ENUMRESLANGPROCW lpEnumFunc,
    __in     LONG_PTR lParam
    );
#ifdef UNICODE
#define EnumResourceLanguages  EnumResourceLanguagesW
#else
#define EnumResourceLanguages  EnumResourceLanguagesA
#endif // !UNICODE

#define  RESOURCE_ENUM_LN               (0x0001)
#define  RESOURCE_ENUM_MUI              (0x0002)
#define  RESOURCE_ENUM_MUI_SYSTEM       (0x0004)
#define  RESOURCE_ENUM_VALIDATE         (0x0008)
#define  RESOURCE_ENUM_MODULE_EXACT     (0x0010)

WINBASEAPI
BOOL
WINAPI
EnumResourceTypesExA(
    __in_opt HMODULE hModule,
    __in ENUMRESTYPEPROCA lpEnumFunc,
    __in LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceTypesExW(
    __in_opt HMODULE hModule,
    __in ENUMRESTYPEPROCW lpEnumFunc,
    __in LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
#ifdef UNICODE
#define EnumResourceTypesEx  EnumResourceTypesExW
#else
#define EnumResourceTypesEx  EnumResourceTypesExA
#endif // !UNICODE


WINBASEAPI
BOOL
WINAPI
EnumResourceNamesExA(
    __in_opt HMODULE hModule,
    __in LPCSTR lpType,
    __in ENUMRESNAMEPROCA lpEnumFunc,
    __in LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceNamesExW(
    __in_opt HMODULE hModule,
    __in LPCWSTR lpType,
    __in ENUMRESNAMEPROCW lpEnumFunc,
    __in LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
#ifdef UNICODE
#define EnumResourceNamesEx  EnumResourceNamesExW
#else
#define EnumResourceNamesEx  EnumResourceNamesExA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EnumResourceLanguagesExA(
    __in_opt HMODULE hModule,
    __in LPCSTR lpType,
    __in LPCSTR lpName,
    __in ENUMRESLANGPROCA lpEnumFunc,
    __in LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
WINBASEAPI
BOOL
WINAPI
EnumResourceLanguagesExW(
    __in_opt HMODULE hModule,
    __in LPCWSTR lpType,
    __in LPCWSTR lpName,
    __in ENUMRESLANGPROCW lpEnumFunc,
    __in LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
#ifdef UNICODE
#define EnumResourceLanguagesEx  EnumResourceLanguagesExW
#else
#define EnumResourceLanguagesEx  EnumResourceLanguagesExA
#endif // !UNICODE

WINBASEAPI
HANDLE
WINAPI
BeginUpdateResourceA(
    __in LPCSTR pFileName,
    __in BOOL bDeleteExistingResources
    );
WINBASEAPI
HANDLE
WINAPI
BeginUpdateResourceW(
    __in LPCWSTR pFileName,
    __in BOOL bDeleteExistingResources
    );
#ifdef UNICODE
#define BeginUpdateResource  BeginUpdateResourceW
#else
#define BeginUpdateResource  BeginUpdateResourceA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
UpdateResourceA(
    __in HANDLE hUpdate,
    __in LPCSTR lpType,
    __in LPCSTR lpName,
    __in WORD wLanguage,
    __in_bcount_opt(cb) LPVOID lpData,
    __in DWORD cb
    );
WINBASEAPI
BOOL
WINAPI
UpdateResourceW(
    __in HANDLE hUpdate,
    __in LPCWSTR lpType,
    __in LPCWSTR lpName,
    __in WORD wLanguage,
    __in_bcount_opt(cb) LPVOID lpData,
    __in DWORD cb
    );
#ifdef UNICODE
#define UpdateResource  UpdateResourceW
#else
#define UpdateResource  UpdateResourceA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
EndUpdateResourceA(
    __in HANDLE hUpdate,
    __in BOOL   fDiscard
    );
WINBASEAPI
BOOL
WINAPI
EndUpdateResourceW(
    __in HANDLE hUpdate,
    __in BOOL   fDiscard
    );
#ifdef UNICODE
#define EndUpdateResource  EndUpdateResourceW
#else
#define EndUpdateResource  EndUpdateResourceA
#endif // !UNICODE


WINBASEAPI
ATOM
WINAPI
GlobalAddAtomA(
    __in_opt LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
GlobalAddAtomW(
    __in_opt LPCWSTR lpString
    );
#ifdef UNICODE
#define GlobalAddAtom  GlobalAddAtomW
#else
#define GlobalAddAtom  GlobalAddAtomA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
GlobalFindAtomA(
    __in_opt LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
GlobalFindAtomW(
    __in_opt LPCWSTR lpString
    );
#ifdef UNICODE
#define GlobalFindAtom  GlobalFindAtomW
#else
#define GlobalFindAtom  GlobalFindAtomA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GlobalGetAtomNameA(
    __in ATOM nAtom,
    __out_ecount_part(nSize, return + 1) LPSTR lpBuffer,
    __in int nSize
    );
WINBASEAPI
UINT
WINAPI
GlobalGetAtomNameW(
    __in ATOM nAtom,
    __out_ecount_part(nSize, return + 1) LPWSTR lpBuffer,
    __in int nSize
    );
#ifdef UNICODE
#define GlobalGetAtomName  GlobalGetAtomNameW
#else
#define GlobalGetAtomName  GlobalGetAtomNameA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
AddAtomA(
    __in_opt LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
AddAtomW(
    __in_opt LPCWSTR lpString
    );
#ifdef UNICODE
#define AddAtom  AddAtomW
#else
#define AddAtom  AddAtomA
#endif // !UNICODE

WINBASEAPI
ATOM
WINAPI
FindAtomA(
    __in_opt LPCSTR lpString
    );
WINBASEAPI
ATOM
WINAPI
FindAtomW(
    __in_opt LPCWSTR lpString
    );
#ifdef UNICODE
#define FindAtom  FindAtomW
#else
#define FindAtom  FindAtomA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetAtomNameA(
    __in ATOM nAtom,
    __out_ecount_part(nSize, return + 1) LPSTR lpBuffer,
    __in int nSize
    );
WINBASEAPI
UINT
WINAPI
GetAtomNameW(
    __in ATOM nAtom,
    __out_ecount_part(nSize, return + 1) LPWSTR lpBuffer,
    __in int nSize
    );
#ifdef UNICODE
#define GetAtomName  GetAtomNameW
#else
#define GetAtomName  GetAtomNameA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetProfileIntA(
    __in LPCSTR lpAppName,
    __in LPCSTR lpKeyName,
    __in INT nDefault
    );
WINBASEAPI
UINT
WINAPI
GetProfileIntW(
    __in LPCWSTR lpAppName,
    __in LPCWSTR lpKeyName,
    __in INT nDefault
    );
#ifdef UNICODE
#define GetProfileInt  GetProfileIntW
#else
#define GetProfileInt  GetProfileIntA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetProfileStringA(
    __in_opt LPCSTR lpAppName,
    __in_opt LPCSTR lpKeyName,
    __in_opt LPCSTR lpDefault,
    __out_ecount_part_opt(nSize, return + 1) LPSTR lpReturnedString,
    __in     DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetProfileStringW(
    __in_opt LPCWSTR lpAppName,
    __in_opt LPCWSTR lpKeyName,
    __in_opt LPCWSTR lpDefault,
    __out_ecount_part_opt(nSize, return + 1) LPWSTR lpReturnedString,
    __in     DWORD nSize
    );
#ifdef UNICODE
#define GetProfileString  GetProfileStringW
#else
#define GetProfileString  GetProfileStringA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteProfileStringA(
    __in_opt LPCSTR lpAppName,
    __in_opt LPCSTR lpKeyName,
    __in_opt LPCSTR lpString
    );
WINBASEAPI
BOOL
WINAPI
WriteProfileStringW(
    __in_opt LPCWSTR lpAppName,
    __in_opt LPCWSTR lpKeyName,
    __in_opt LPCWSTR lpString
    );
#ifdef UNICODE
#define WriteProfileString  WriteProfileStringW
#else
#define WriteProfileString  WriteProfileStringA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetProfileSectionA(
    __in LPCSTR lpAppName,
    __out_ecount_part_opt(nSize, return + 1) LPSTR lpReturnedString,
    __in DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetProfileSectionW(
    __in LPCWSTR lpAppName,
    __out_ecount_part_opt(nSize, return + 1) LPWSTR lpReturnedString,
    __in DWORD nSize
    );
#ifdef UNICODE
#define GetProfileSection  GetProfileSectionW
#else
#define GetProfileSection  GetProfileSectionA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteProfileSectionA(
    __in LPCSTR lpAppName,
    __in LPCSTR lpString
    );
WINBASEAPI
BOOL
WINAPI
WriteProfileSectionW(
    __in LPCWSTR lpAppName,
    __in LPCWSTR lpString
    );
#ifdef UNICODE
#define WriteProfileSection  WriteProfileSectionW
#else
#define WriteProfileSection  WriteProfileSectionA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetPrivateProfileIntA(
    __in     LPCSTR lpAppName,
    __in     LPCSTR lpKeyName,
    __in     INT nDefault,
    __in_opt LPCSTR lpFileName
    );
WINBASEAPI
UINT
WINAPI
GetPrivateProfileIntW(
    __in     LPCWSTR lpAppName,
    __in     LPCWSTR lpKeyName,
    __in     INT nDefault,
    __in_opt LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileInt  GetPrivateProfileIntW
#else
#define GetPrivateProfileInt  GetPrivateProfileIntA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetPrivateProfileInt
__inline
UINT
GetPrivateProfileInt(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    INT nDefault,
    LPCTSTR lpFileName
    )
{
#ifdef UNICODE
    return GetPrivateProfileIntW(
#else
    return GetPrivateProfileIntA(
#endif
        lpAppName,
        lpKeyName,
        nDefault,
        lpFileName
        );
}
#endif  /* _M_CEE */

WINBASEAPI
DWORD
WINAPI
GetPrivateProfileStringA(
    __in_opt LPCSTR lpAppName,
    __in_opt LPCSTR lpKeyName,
    __in_opt LPCSTR lpDefault,
    __out_ecount_part_opt(nSize, return + 1) LPSTR lpReturnedString,
    __in     DWORD nSize,
    __in_opt LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileStringW(
    __in_opt LPCWSTR lpAppName,
    __in_opt LPCWSTR lpKeyName,
    __in_opt LPCWSTR lpDefault,
    __out_ecount_part_opt(nSize, return + 1) LPWSTR lpReturnedString,
    __in     DWORD nSize,
    __in_opt LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileString  GetPrivateProfileStringW
#else
#define GetPrivateProfileString  GetPrivateProfileStringA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetPrivateProfileString
__inline
DWORD
GetPrivateProfileString(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    LPCTSTR lpDefault,
    LPTSTR lpReturnedString,
    DWORD nSize,
    LPCTSTR lpFileName
    )
{
#ifdef UNICODE
    return GetPrivateProfileStringW(
#else
    return GetPrivateProfileStringA(
#endif
        lpAppName,
        lpKeyName,
        lpDefault,
        lpReturnedString,
        nSize,
        lpFileName
        );
}
#endif  /* _M_CEE */

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStringA(
    __in_opt LPCSTR lpAppName,
    __in_opt LPCSTR lpKeyName,
    __in_opt LPCSTR lpString,
    __in_opt LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStringW(
    __in_opt LPCWSTR lpAppName,
    __in_opt LPCWSTR lpKeyName,
    __in_opt LPCWSTR lpString,
    __in_opt LPCWSTR lpFileName
    );
#ifdef UNICODE
#define WritePrivateProfileString  WritePrivateProfileStringW
#else
#define WritePrivateProfileString  WritePrivateProfileStringA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionA(
    __in     LPCSTR lpAppName,
    __out_ecount_part_opt(nSize, return + 1) LPSTR lpReturnedString,
    __in     DWORD nSize,
    __in_opt LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionW(
    __in     LPCWSTR lpAppName,
    __out_ecount_part_opt(nSize, return + 1) LPWSTR lpReturnedString,
    __in     DWORD nSize,
    __in_opt LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileSection  GetPrivateProfileSectionW
#else
#define GetPrivateProfileSection  GetPrivateProfileSectionA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetPrivateProfileSection
__inline
DWORD
GetPrivateProfileSection(
    LPCTSTR lpAppName,
    LPTSTR lpReturnedString,
    DWORD nSize,
    LPCTSTR lpFileName
    )
{
#ifdef UNICODE
    return GetPrivateProfileSectionW(
#else
    return GetPrivateProfileSectionA(
#endif
        lpAppName,
        lpReturnedString,
        nSize,
        lpFileName
        );
}
#endif  /* _M_CEE */

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileSectionA(
    __in_opt LPCSTR lpAppName,
    __in_opt LPCSTR lpString,
    __in_opt LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileSectionW(
    __in_opt LPCWSTR lpAppName,
    __in_opt LPCWSTR lpString,
    __in_opt LPCWSTR lpFileName
    );
#ifdef UNICODE
#define WritePrivateProfileSection  WritePrivateProfileSectionW
#else
#define WritePrivateProfileSection  WritePrivateProfileSectionA
#endif // !UNICODE


WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionNamesA(
    __out_ecount_part_opt(nSize, return + 1) LPSTR lpszReturnBuffer,
    __in     DWORD nSize,
    __in_opt LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionNamesW(
    __out_ecount_part_opt(nSize, return + 1) LPWSTR lpszReturnBuffer,
    __in     DWORD nSize,
    __in_opt LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileSectionNames  GetPrivateProfileSectionNamesW
#else
#define GetPrivateProfileSectionNames  GetPrivateProfileSectionNamesA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetPrivateProfileSectionNames
__inline
DWORD
GetPrivateProfileSectionNames(
    LPTSTR lpszReturnBuffer,
    DWORD nSize,
    LPCTSTR lpFileName
    )
{
#ifdef UNICODE
    return GetPrivateProfileSectionNamesW(
#else
    return GetPrivateProfileSectionNamesA(
#endif
        lpszReturnBuffer,
        nSize,
        lpFileName
        );
}
#endif  /* _M_CEE */

WINBASEAPI
BOOL
WINAPI
GetPrivateProfileStructA(
    __in     LPCSTR lpszSection,
    __in     LPCSTR lpszKey,
    __out_bcount_opt(uSizeStruct) LPVOID   lpStruct,
    __in     UINT     uSizeStruct,
    __in_opt LPCSTR szFile
    );
WINBASEAPI
BOOL
WINAPI
GetPrivateProfileStructW(
    __in     LPCWSTR lpszSection,
    __in     LPCWSTR lpszKey,
    __out_bcount_opt(uSizeStruct) LPVOID   lpStruct,
    __in     UINT     uSizeStruct,
    __in_opt LPCWSTR szFile
    );
#ifdef UNICODE
#define GetPrivateProfileStruct  GetPrivateProfileStructW
#else
#define GetPrivateProfileStruct  GetPrivateProfileStructA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetPrivateProfileStruct
__inline
BOOL
GetPrivateProfileStruct(
    LPCTSTR lpszSection,
    LPCTSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCTSTR szFile
    )
{
#ifdef UNICODE
    return GetPrivateProfileStructW(
#else
    return GetPrivateProfileStructA(
#endif
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile
        );
}
#endif  /* _M_CEE */

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStructA(
    __in     LPCSTR lpszSection,
    __in     LPCSTR lpszKey,
    __in_bcount_opt(uSizeStruct) LPVOID lpStruct,
    __in     UINT     uSizeStruct,
    __in_opt LPCSTR szFile
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStructW(
    __in     LPCWSTR lpszSection,
    __in     LPCWSTR lpszKey,
    __in_bcount_opt(uSizeStruct) LPVOID lpStruct,
    __in     UINT     uSizeStruct,
    __in_opt LPCWSTR szFile
    );
#ifdef UNICODE
#define WritePrivateProfileStruct  WritePrivateProfileStructW
#else
#define WritePrivateProfileStruct  WritePrivateProfileStructA
#endif // !UNICODE


WINBASEAPI
UINT
WINAPI
GetDriveTypeA(
    __in_opt LPCSTR lpRootPathName
    );
WINBASEAPI
UINT
WINAPI
GetDriveTypeW(
    __in_opt LPCWSTR lpRootPathName
    );
#ifdef UNICODE
#define GetDriveType  GetDriveTypeW
#else
#define GetDriveType  GetDriveTypeA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetSystemDirectoryA(
    __out_ecount_part_opt(uSize, return + 1) LPSTR lpBuffer,
    __in UINT uSize
    );
WINBASEAPI
UINT
WINAPI
GetSystemDirectoryW(
    __out_ecount_part_opt(uSize, return + 1) LPWSTR lpBuffer,
    __in UINT uSize
    );
#ifdef UNICODE
#define GetSystemDirectory  GetSystemDirectoryW
#else
#define GetSystemDirectory  GetSystemDirectoryA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetTempPathA(
    __in DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPSTR lpBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetTempPathW(
    __in DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetTempPath  GetTempPathW
#else
#define GetTempPath  GetTempPathA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetTempFileNameA(
    __in LPCSTR lpPathName,
    __in LPCSTR lpPrefixString,
    __in UINT uUnique,
    __out_ecount(MAX_PATH) LPSTR lpTempFileName
    );
WINBASEAPI
UINT
WINAPI
GetTempFileNameW(
    __in LPCWSTR lpPathName,
    __in LPCWSTR lpPrefixString,
    __in UINT uUnique,
    __out_ecount(MAX_PATH) LPWSTR lpTempFileName
    );
#ifdef UNICODE
#define GetTempFileName  GetTempFileNameW
#else
#define GetTempFileName  GetTempFileNameA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetTempFileName
__inline
UINT
GetTempFileName(
    LPCTSTR lpPathName,
    LPCTSTR lpPrefixString,
    UINT uUnique,
    LPTSTR lpTempFileName
    )
{
#ifdef UNICODE
    return GetTempFileNameW(
#else
    return GetTempFileNameA(
#endif
        lpPathName,
        lpPrefixString,
        uUnique,
        lpTempFileName
        );
}
#endif  /* _M_CEE */

WINBASEAPI
UINT
WINAPI
GetWindowsDirectoryA(
    __out_ecount_part_opt(uSize, return + 1) LPSTR lpBuffer,
    __in UINT uSize
    );
WINBASEAPI
UINT
WINAPI
GetWindowsDirectoryW(
    __out_ecount_part_opt(uSize, return + 1) LPWSTR lpBuffer,
    __in UINT uSize
    );
#ifdef UNICODE
#define GetWindowsDirectory  GetWindowsDirectoryW
#else
#define GetWindowsDirectory  GetWindowsDirectoryA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetSystemWindowsDirectoryA(
    __out_ecount_part_opt(uSize, return + 1) LPSTR lpBuffer,
    __in UINT uSize
    );
WINBASEAPI
UINT
WINAPI
GetSystemWindowsDirectoryW(
    __out_ecount_part_opt(uSize, return + 1) LPWSTR lpBuffer,
    __in UINT uSize
    );
#ifdef UNICODE
#define GetSystemWindowsDirectory  GetSystemWindowsDirectoryW
#else
#define GetSystemWindowsDirectory  GetSystemWindowsDirectoryA
#endif // !UNICODE

#if !defined(RC_INVOKED) // RC warns because "WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY" is a bit long.
#if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY)

WINBASEAPI
UINT
WINAPI
GetSystemWow64DirectoryA(
    __out_ecount_part_opt(uSize, return + 1) LPSTR lpBuffer,
    __in UINT uSize
    );
WINBASEAPI
UINT
WINAPI
GetSystemWow64DirectoryW(
    __out_ecount_part_opt(uSize, return + 1) LPWSTR lpBuffer,
    __in UINT uSize
    );
#ifdef UNICODE
#define GetSystemWow64Directory  GetSystemWow64DirectoryW
#else
#define GetSystemWow64Directory  GetSystemWow64DirectoryA
#endif // !UNICODE

WINBASEAPI
BOOLEAN
WINAPI
Wow64EnableWow64FsRedirection (
    __in BOOLEAN Wow64FsEnableRedirection
    );

WINBASEAPI
BOOL
WINAPI
Wow64DisableWow64FsRedirection (
    __out PVOID *OldValue
    );

WINBASEAPI
BOOL
WINAPI
Wow64RevertWow64FsRedirection (
    __in PVOID OlValue
    );


//
// for GetProcAddress
//
typedef UINT (WINAPI* PGET_SYSTEM_WOW64_DIRECTORY_A)(__out_ecount_part_opt(uSize, return + 1) LPSTR lpBuffer, __in UINT uSize);
typedef UINT (WINAPI* PGET_SYSTEM_WOW64_DIRECTORY_W)(__out_ecount_part_opt(uSize, return + 1) LPWSTR lpBuffer, __in UINT uSize);

//
// GetProcAddress only accepts GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A,
// GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A.
// The others are if you want to use the strings in some other way.
//
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A      "GetSystemWow64DirectoryA"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W     L"GetSystemWow64DirectoryA"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T TEXT("GetSystemWow64DirectoryA")
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A      "GetSystemWow64DirectoryW"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W     L"GetSystemWow64DirectoryW"
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T TEXT("GetSystemWow64DirectoryW")

#ifdef UNICODE
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T
#else
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W
#define GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T
#endif

#endif // _WIN32_WINNT >= 0x0501
#endif

WINBASEAPI
BOOL
WINAPI
SetCurrentDirectoryA(
    __in LPCSTR lpPathName
    );
WINBASEAPI
BOOL
WINAPI
SetCurrentDirectoryW(
    __in LPCWSTR lpPathName
    );
#ifdef UNICODE
#define SetCurrentDirectory  SetCurrentDirectoryW
#else
#define SetCurrentDirectory  SetCurrentDirectoryA
#endif // !UNICODE

#if defined(_M_CEE)
#undef SetCurrentDirectory
__inline
BOOL
SetCurrentDirectory(
    LPCTSTR lpPathName
    )
{
#ifdef UNICODE
    return SetCurrentDirectoryW(
#else
    return SetCurrentDirectoryA(
#endif
        lpPathName
        );
}
#endif  /* _M_CEE */

WINBASEAPI
DWORD
WINAPI
GetCurrentDirectoryA(
    __in DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPSTR lpBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetCurrentDirectoryW(
    __in DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetCurrentDirectory  GetCurrentDirectoryW
#else
#define GetCurrentDirectory  GetCurrentDirectoryA
#endif // !UNICODE

#if defined(_M_CEE)
#undef GetCurrentDirectory
__inline
DWORD
GetCurrentDirectory(
    DWORD nBufferLength,
    LPTSTR lpBuffer
    )
{
#ifdef UNICODE
    return GetCurrentDirectoryW(
#else
    return GetCurrentDirectoryA(
#endif
        nBufferLength,
        lpBuffer
        );
}
#endif  /* _M_CEE */

#if _WIN32_WINNT >= 0x0502

WINBASEAPI
BOOL
WINAPI
SetDllDirectoryA(
    __in_opt LPCSTR lpPathName
    );
WINBASEAPI
BOOL
WINAPI
SetDllDirectoryW(
    __in_opt LPCWSTR lpPathName
    );
#ifdef UNICODE
#define SetDllDirectory  SetDllDirectoryW
#else
#define SetDllDirectory  SetDllDirectoryA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetDllDirectoryA(
    __in DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPSTR lpBuffer
    );
WINBASEAPI
DWORD
WINAPI
GetDllDirectoryW(
    __in DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetDllDirectory  GetDllDirectoryW
#else
#define GetDllDirectory  GetDllDirectoryA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0502

#define BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE 0x1
#define BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE 0x10000
#define BASE_SEARCH_PATH_PERMANENT 0x8000
#define BASE_SEARCH_PATH_INVALID_FLAGS ~0x18001

WINBASEAPI
BOOL
WINAPI
SetSearchPathMode (
    __in DWORD Flags
    );

WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceA(
    __in_opt  LPCSTR lpRootPathName,
    __out_opt LPDWORD lpSectorsPerCluster,
    __out_opt LPDWORD lpBytesPerSector,
    __out_opt LPDWORD lpNumberOfFreeClusters,
    __out_opt LPDWORD lpTotalNumberOfClusters
    );
WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceW(
    __in_opt  LPCWSTR lpRootPathName,
    __out_opt LPDWORD lpSectorsPerCluster,
    __out_opt LPDWORD lpBytesPerSector,
    __out_opt LPDWORD lpNumberOfFreeClusters,
    __out_opt LPDWORD lpTotalNumberOfClusters
    );
#ifdef UNICODE
#define GetDiskFreeSpace  GetDiskFreeSpaceW
#else
#define GetDiskFreeSpace  GetDiskFreeSpaceA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceExA(
    __in_opt  LPCSTR lpDirectoryName,
    __out_opt PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    __out_opt PULARGE_INTEGER lpTotalNumberOfBytes,
    __out_opt PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceExW(
    __in_opt  LPCWSTR lpDirectoryName,
    __out_opt PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    __out_opt PULARGE_INTEGER lpTotalNumberOfBytes,
    __out_opt PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
#ifdef UNICODE
#define GetDiskFreeSpaceEx  GetDiskFreeSpaceExW
#else
#define GetDiskFreeSpaceEx  GetDiskFreeSpaceExA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CreateDirectoryA(
    __in     LPCSTR lpPathName,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
BOOL
WINAPI
CreateDirectoryW(
    __in     LPCWSTR lpPathName,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateDirectory  CreateDirectoryW
#else
#define CreateDirectory  CreateDirectoryA
#endif // !UNICODE

#if defined(_M_CEE)
#undef CreateDirectory
__inline
BOOL
CreateDirectory(
    LPCTSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
#ifdef UNICODE
    return CreateDirectoryW(
#else
    return CreateDirectoryA(
#endif
        lpPathName,
        lpSecurityAttributes
        );
}
#endif  /* _M_CEE */

WINBASEAPI
BOOL
WINAPI
CreateDirectoryExA(
    __in     LPCSTR lpTemplateDirectory,
    __in     LPCSTR lpNewDirectory,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
BOOL
WINAPI
CreateDirectoryExW(
    __in     LPCWSTR lpTemplateDirectory,
    __in     LPCWSTR lpNewDirectory,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateDirectoryEx  CreateDirectoryExW
#else
#define CreateDirectoryEx  CreateDirectoryExA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
CreateDirectoryTransactedA(
    __in_opt LPCSTR lpTemplateDirectory,
    __in     LPCSTR lpNewDirectory,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in     HANDLE hTransaction
    );
WINBASEAPI
BOOL
WINAPI
CreateDirectoryTransactedW(
    __in_opt LPCWSTR lpTemplateDirectory,
    __in     LPCWSTR lpNewDirectory,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define CreateDirectoryTransacted  CreateDirectoryTransactedW
#else
#define CreateDirectoryTransacted  CreateDirectoryTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
RemoveDirectoryA(
    __in LPCSTR lpPathName
    );
WINBASEAPI
BOOL
WINAPI
RemoveDirectoryW(
    __in LPCWSTR lpPathName
    );
#ifdef UNICODE
#define RemoveDirectory  RemoveDirectoryW
#else
#define RemoveDirectory  RemoveDirectoryA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
RemoveDirectoryTransactedA(
    __in LPCSTR lpPathName,
    __in     HANDLE hTransaction
    );
WINBASEAPI
BOOL
WINAPI
RemoveDirectoryTransactedW(
    __in LPCWSTR lpPathName,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define RemoveDirectoryTransacted  RemoveDirectoryTransactedW
#else
#define RemoveDirectoryTransacted  RemoveDirectoryTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
DWORD
WINAPI
GetFullPathNameA(
    __in            LPCSTR lpFileName,
    __in            DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPSTR lpBuffer,
    __deref_opt_out LPSTR *lpFilePart
    );
WINBASEAPI
DWORD
WINAPI
GetFullPathNameW(
    __in            LPCWSTR lpFileName,
    __in            DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPWSTR lpBuffer,
    __deref_opt_out LPWSTR *lpFilePart
    );
#ifdef UNICODE
#define GetFullPathName  GetFullPathNameW
#else
#define GetFullPathName  GetFullPathNameA
#endif // !UNICODE
#if _WIN32_WINNT >= 0x0600

WINBASEAPI
DWORD
WINAPI
GetFullPathNameTransactedA(
    __in            LPCSTR lpFileName,
    __in            DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPSTR lpBuffer,
    __deref_opt_out LPSTR *lpFilePart,
    __in            HANDLE hTransaction
    );
WINBASEAPI
DWORD
WINAPI
GetFullPathNameTransactedW(
    __in            LPCWSTR lpFileName,
    __in            DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPWSTR lpBuffer,
    __deref_opt_out LPWSTR *lpFilePart,
    __in            HANDLE hTransaction
    );
#ifdef UNICODE
#define GetFullPathNameTransacted  GetFullPathNameTransactedW
#else
#define GetFullPathNameTransacted  GetFullPathNameTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

#define DDD_RAW_TARGET_PATH         0x00000001
#define DDD_REMOVE_DEFINITION       0x00000002
#define DDD_EXACT_MATCH_ON_REMOVE   0x00000004
#define DDD_NO_BROADCAST_SYSTEM     0x00000008
#define DDD_LUID_BROADCAST_DRIVE    0x00000010

WINBASEAPI
BOOL
WINAPI
DefineDosDeviceA(
    __in     DWORD dwFlags,
    __in     LPCSTR lpDeviceName,
    __in_opt LPCSTR lpTargetPath
    );
WINBASEAPI
BOOL
WINAPI
DefineDosDeviceW(
    __in     DWORD dwFlags,
    __in     LPCWSTR lpDeviceName,
    __in_opt LPCWSTR lpTargetPath
    );
#ifdef UNICODE
#define DefineDosDevice  DefineDosDeviceW
#else
#define DefineDosDevice  DefineDosDeviceA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
QueryDosDeviceA(
    __in_opt LPCSTR lpDeviceName,
    __out_ecount_part_opt(ucchMax, return) LPSTR lpTargetPath,
    __in     DWORD ucchMax
    );
WINBASEAPI
DWORD
WINAPI
QueryDosDeviceW(
    __in_opt LPCWSTR lpDeviceName,
    __out_ecount_part_opt(ucchMax, return) LPWSTR lpTargetPath,
    __in     DWORD ucchMax
    );
#ifdef UNICODE
#define QueryDosDevice  QueryDosDeviceW
#else
#define QueryDosDevice  QueryDosDeviceA
#endif // !UNICODE

#define EXPAND_LOCAL_DRIVES

WINBASEAPI
__out
HANDLE
WINAPI
CreateFileA(
    __in     LPCSTR lpFileName,
    __in     DWORD dwDesiredAccess,
    __in     DWORD dwShareMode,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in     DWORD dwCreationDisposition,
    __in     DWORD dwFlagsAndAttributes,
    __in_opt HANDLE hTemplateFile
    );
WINBASEAPI
__out
HANDLE
WINAPI
CreateFileW(
    __in     LPCWSTR lpFileName,
    __in     DWORD dwDesiredAccess,
    __in     DWORD dwShareMode,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in     DWORD dwCreationDisposition,
    __in     DWORD dwFlagsAndAttributes,
    __in_opt HANDLE hTemplateFile
    );
#ifdef UNICODE
#define CreateFile  CreateFileW
#else
#define CreateFile  CreateFileA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
__out
HANDLE
WINAPI
CreateFileTransactedA(
    __in       LPCSTR lpFileName,
    __in       DWORD dwDesiredAccess,
    __in       DWORD dwShareMode,
    __in_opt   LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in       DWORD dwCreationDisposition,
    __in       DWORD dwFlagsAndAttributes,
    __in_opt   HANDLE hTemplateFile,
    __in       HANDLE hTransaction,
    __in_opt   PUSHORT pusMiniVersion,
    __reserved PVOID  lpExtendedParameter
    );
WINBASEAPI
__out
HANDLE
WINAPI
CreateFileTransactedW(
    __in       LPCWSTR lpFileName,
    __in       DWORD dwDesiredAccess,
    __in       DWORD dwShareMode,
    __in_opt   LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in       DWORD dwCreationDisposition,
    __in       DWORD dwFlagsAndAttributes,
    __in_opt   HANDLE hTemplateFile,
    __in       HANDLE hTransaction,
    __in_opt   PUSHORT pusMiniVersion,
    __reserved PVOID  lpExtendedParameter
    );
#ifdef UNICODE
#define CreateFileTransacted  CreateFileTransactedW
#else
#define CreateFileTransacted  CreateFileTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600


#if _WIN32_WINNT >= 0x0502

WINBASEAPI
__out
HANDLE
WINAPI
ReOpenFile(
    __in HANDLE  hOriginalFile,
    __in DWORD   dwDesiredAccess,
    __in DWORD   dwShareMode,
    __in DWORD   dwFlagsAndAttributes
    );

#endif // _WIN32_WINNT >= 0x0502

WINBASEAPI
BOOL
WINAPI
SetFileAttributesA(
    __in LPCSTR lpFileName,
    __in DWORD dwFileAttributes
    );
WINBASEAPI
BOOL
WINAPI
SetFileAttributesW(
    __in LPCWSTR lpFileName,
    __in DWORD dwFileAttributes
    );
#ifdef UNICODE
#define SetFileAttributes  SetFileAttributesW
#else
#define SetFileAttributes  SetFileAttributesA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetFileAttributesA(
    __in LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetFileAttributesW(
    __in LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetFileAttributes  GetFileAttributesW
#else
#define GetFileAttributes  GetFileAttributesA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
SetFileAttributesTransactedA(
    __in     LPCSTR lpFileName,
    __in     DWORD dwFileAttributes,
    __in     HANDLE hTransaction
    );
WINBASEAPI
BOOL
WINAPI
SetFileAttributesTransactedW(
    __in     LPCWSTR lpFileName,
    __in     DWORD dwFileAttributes,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define SetFileAttributesTransacted  SetFileAttributesTransactedW
#else
#define SetFileAttributesTransacted  SetFileAttributesTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
GetFileAttributesTransactedA(
    __in  LPCSTR lpFileName,
    __in  GET_FILEEX_INFO_LEVELS fInfoLevelId,
    __out LPVOID lpFileInformation,
    __in     HANDLE hTransaction
    );
WINBASEAPI
BOOL
WINAPI
GetFileAttributesTransactedW(
    __in  LPCWSTR lpFileName,
    __in  GET_FILEEX_INFO_LEVELS fInfoLevelId,
    __out LPVOID lpFileInformation,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define GetFileAttributesTransacted  GetFileAttributesTransactedW
#else
#define GetFileAttributesTransacted  GetFileAttributesTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
GetFileAttributesExA(
    __in  LPCSTR lpFileName,
    __in  GET_FILEEX_INFO_LEVELS fInfoLevelId,
    __out LPVOID lpFileInformation
    );
WINBASEAPI
BOOL
WINAPI
GetFileAttributesExW(
    __in  LPCWSTR lpFileName,
    __in  GET_FILEEX_INFO_LEVELS fInfoLevelId,
    __out LPVOID lpFileInformation
    );
#ifdef UNICODE
#define GetFileAttributesEx  GetFileAttributesExW
#else
#define GetFileAttributesEx  GetFileAttributesExA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetCompressedFileSizeA(
    __in  LPCSTR lpFileName,
    __out_opt LPDWORD  lpFileSizeHigh
    );
WINBASEAPI
DWORD
WINAPI
GetCompressedFileSizeW(
    __in  LPCWSTR lpFileName,
    __out_opt LPDWORD  lpFileSizeHigh
    );
#ifdef UNICODE
#define GetCompressedFileSize  GetCompressedFileSizeW
#else
#define GetCompressedFileSize  GetCompressedFileSizeA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
DWORD
WINAPI
GetCompressedFileSizeTransactedA(
    __in      LPCSTR lpFileName,
    __out_opt LPDWORD  lpFileSizeHigh,
    __in      HANDLE hTransaction
    );
WINBASEAPI
DWORD
WINAPI
GetCompressedFileSizeTransactedW(
    __in      LPCWSTR lpFileName,
    __out_opt LPDWORD  lpFileSizeHigh,
    __in      HANDLE hTransaction
    );
#ifdef UNICODE
#define GetCompressedFileSizeTransacted  GetCompressedFileSizeTransactedW
#else
#define GetCompressedFileSizeTransacted  GetCompressedFileSizeTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
DeleteFileA(
    __in LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
DeleteFileW(
    __in LPCWSTR lpFileName
    );
#ifdef UNICODE
#define DeleteFile  DeleteFileW
#else
#define DeleteFile  DeleteFileA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
DeleteFileTransactedA(
    __in     LPCSTR lpFileName,
    __in     HANDLE hTransaction
    );
WINBASEAPI
BOOL
WINAPI
DeleteFileTransactedW(
    __in     LPCWSTR lpFileName,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define DeleteFileTransacted  DeleteFileTransactedW
#else
#define DeleteFileTransacted  DeleteFileTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600

#if defined(_M_CEE)
#undef DeleteFile
__inline
BOOL
DeleteFile(
    LPCTSTR lpFileName
    )
{
#ifdef UNICODE
    return DeleteFileW(
#else
    return DeleteFileA(
#endif
        lpFileName
        );
}
#endif  /* _M_CEE */


#if _WIN32_WINNT >= 0x0501

WINBASEAPI
BOOL
WINAPI
CheckNameLegalDOS8Dot3A(
    __in      LPCSTR lpName,
    __out_ecount_opt(OemNameSize) LPSTR lpOemName,
    __in      DWORD OemNameSize,
    __out_opt PBOOL pbNameContainsSpaces OPTIONAL,
    __out     PBOOL pbNameLegal
    );
WINBASEAPI
BOOL
WINAPI
CheckNameLegalDOS8Dot3W(
    __in      LPCWSTR lpName,
    __out_ecount_opt(OemNameSize) LPSTR lpOemName,
    __in      DWORD OemNameSize,
    __out_opt PBOOL pbNameContainsSpaces OPTIONAL,
    __out     PBOOL pbNameLegal
    );
#ifdef UNICODE
#define CheckNameLegalDOS8Dot3  CheckNameLegalDOS8Dot3W
#else
#define CheckNameLegalDOS8Dot3  CheckNameLegalDOS8Dot3A
#endif // !UNICODE

#endif // (_WIN32_WINNT >= 0x0501)

#if(_WIN32_WINNT >= 0x0400)
typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;

typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;

#define FIND_FIRST_EX_CASE_SENSITIVE   0x00000001
#define FIND_FIRST_EX_LARGE_FETCH      0x00000002

WINBASEAPI
__out
HANDLE
WINAPI
FindFirstFileExA(
    __in       LPCSTR lpFileName,
    __in       FINDEX_INFO_LEVELS fInfoLevelId,
    __out      LPVOID lpFindFileData,
    __in       FINDEX_SEARCH_OPS fSearchOp,
    __reserved LPVOID lpSearchFilter,
    __in       DWORD dwAdditionalFlags
    );
WINBASEAPI
__out
HANDLE
WINAPI
FindFirstFileExW(
    __in       LPCWSTR lpFileName,
    __in       FINDEX_INFO_LEVELS fInfoLevelId,
    __out      LPVOID lpFindFileData,
    __in       FINDEX_SEARCH_OPS fSearchOp,
    __reserved LPVOID lpSearchFilter,
    __in       DWORD dwAdditionalFlags
    );
#ifdef UNICODE
#define FindFirstFileEx  FindFirstFileExW
#else
#define FindFirstFileEx  FindFirstFileExA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
__out
HANDLE
WINAPI
FindFirstFileTransactedA(
    __in       LPCSTR lpFileName,
    __in       FINDEX_INFO_LEVELS fInfoLevelId,
    __out      LPVOID lpFindFileData,
    __in       FINDEX_SEARCH_OPS fSearchOp,
    __reserved LPVOID lpSearchFilter,
    __in       DWORD dwAdditionalFlags,
    __in       HANDLE hTransaction
    );
WINBASEAPI
__out
HANDLE
WINAPI
FindFirstFileTransactedW(
    __in       LPCWSTR lpFileName,
    __in       FINDEX_INFO_LEVELS fInfoLevelId,
    __out      LPVOID lpFindFileData,
    __in       FINDEX_SEARCH_OPS fSearchOp,
    __reserved LPVOID lpSearchFilter,
    __in       DWORD dwAdditionalFlags,
    __in       HANDLE hTransaction
    );
#ifdef UNICODE
#define FindFirstFileTransacted  FindFirstFileTransactedW
#else
#define FindFirstFileTransacted  FindFirstFileTransactedA
#endif // !UNICODE

#endif

#endif /* _WIN32_WINNT >= 0x0400 */

WINBASEAPI
__out
HANDLE
WINAPI
FindFirstFileA(
    __in  LPCSTR lpFileName,
    __out LPWIN32_FIND_DATAA lpFindFileData
    );
WINBASEAPI
__out
HANDLE
WINAPI
FindFirstFileW(
    __in  LPCWSTR lpFileName,
    __out LPWIN32_FIND_DATAW lpFindFileData
    );
#ifdef UNICODE
#define FindFirstFile  FindFirstFileW
#else
#define FindFirstFile  FindFirstFileA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextFileA(
    __in  HANDLE hFindFile,
    __out LPWIN32_FIND_DATAA lpFindFileData
    );
WINBASEAPI
BOOL
WINAPI
FindNextFileW(
    __in  HANDLE hFindFile,
    __out LPWIN32_FIND_DATAW lpFindFileData
    );
#ifdef UNICODE
#define FindNextFile  FindNextFileW
#else
#define FindNextFile  FindNextFileA
#endif // !UNICODE


WINBASEAPI
DWORD
WINAPI
SearchPathA(
    __in_opt  LPCSTR lpPath,
    __in      LPCSTR lpFileName,
    __in_opt  LPCSTR lpExtension,
    __in      DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPSTR lpBuffer,
    __out_opt LPSTR *lpFilePart
    );
WINBASEAPI
DWORD
WINAPI
SearchPathW(
    __in_opt  LPCWSTR lpPath,
    __in      LPCWSTR lpFileName,
    __in_opt  LPCWSTR lpExtension,
    __in      DWORD nBufferLength,
    __out_ecount_part_opt(nBufferLength, return + 1) LPWSTR lpBuffer,
    __out_opt LPWSTR *lpFilePart
    );
#ifdef UNICODE
#define SearchPath  SearchPathW
#else
#define SearchPath  SearchPathA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CopyFileA(
    __in LPCSTR lpExistingFileName,
    __in LPCSTR lpNewFileName,
    __in BOOL bFailIfExists
    );
WINBASEAPI
BOOL
WINAPI
CopyFileW(
    __in LPCWSTR lpExistingFileName,
    __in LPCWSTR lpNewFileName,
    __in BOOL bFailIfExists
    );
#ifdef UNICODE
#define CopyFile  CopyFileW
#else
#define CopyFile  CopyFileA
#endif // !UNICODE

#if defined(_M_CEE)
#undef CopyFile
__inline
BOOL
CopyFile(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
#ifdef UNICODE
    return CopyFileW(
#else
    return CopyFileA(
#endif
        lpExistingFileName,
        lpNewFileName,
        bFailIfExists
        );
}
#endif  /* _M_CEE */

#if(_WIN32_WINNT >= 0x0400)
typedef
DWORD
(WINAPI *LPPROGRESS_ROUTINE)(
    __in     LARGE_INTEGER TotalFileSize,
    __in     LARGE_INTEGER TotalBytesTransferred,
    __in     LARGE_INTEGER StreamSize,
    __in     LARGE_INTEGER StreamBytesTransferred,
    __in     DWORD dwStreamNumber,
    __in     DWORD dwCallbackReason,
    __in     HANDLE hSourceFile,
    __in     HANDLE hDestinationFile,
    __in_opt LPVOID lpData
    );

WINBASEAPI
BOOL
WINAPI
CopyFileExA(
    __in     LPCSTR lpExistingFileName,
    __in     LPCSTR lpNewFileName,
    __in_opt LPPROGRESS_ROUTINE lpProgressRoutine,
    __in_opt LPVOID lpData,
    __in_opt LPBOOL pbCancel,
    __in     DWORD dwCopyFlags
    );
WINBASEAPI
BOOL
WINAPI
CopyFileExW(
    __in     LPCWSTR lpExistingFileName,
    __in     LPCWSTR lpNewFileName,
    __in_opt LPPROGRESS_ROUTINE lpProgressRoutine,
    __in_opt LPVOID lpData,
    __in_opt LPBOOL pbCancel,
    __in     DWORD dwCopyFlags
    );
#ifdef UNICODE
#define CopyFileEx  CopyFileExW
#else
#define CopyFileEx  CopyFileExA
#endif // !UNICODE

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
CopyFileTransactedA(
    __in     LPCSTR lpExistingFileName,
    __in     LPCSTR lpNewFileName,
    __in_opt LPPROGRESS_ROUTINE lpProgressRoutine,
    __in_opt LPVOID lpData,
    __in_opt LPBOOL pbCancel,
    __in     DWORD dwCopyFlags,
    __in     HANDLE hTransaction
    );
WINBASEAPI
BOOL
WINAPI
CopyFileTransactedW(
    __in     LPCWSTR lpExistingFileName,
    __in     LPCWSTR lpNewFileName,
    __in_opt LPPROGRESS_ROUTINE lpProgressRoutine,
    __in_opt LPVOID lpData,
    __in_opt LPBOOL pbCancel,
    __in     DWORD dwCopyFlags,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define CopyFileTransacted  CopyFileTransactedW
#else
#define CopyFileTransacted  CopyFileTransactedA
#endif // !UNICODE

#endif // _WIN32_WINNT >= 0x0600
#endif /* _WIN32_WINNT >= 0x0400 */

WINBASEAPI
BOOL
WINAPI
MoveFileA(
    __in LPCSTR lpExistingFileName,
    __in LPCSTR lpNewFileName
    );
WINBASEAPI
BOOL
WINAPI
MoveFileW(
    __in LPCWSTR lpExistingFileName,
    __in LPCWSTR lpNewFileName
    );
#ifdef UNICODE
#define MoveFile  MoveFileW
#else
#define MoveFile  MoveFileA
#endif // !UNICODE

#if defined(_M_CEE)
#undef MoveFile
__inline
BOOL
MoveFile(
    LPCTSTR lpExistingFileName,
    LPCTSTR lpNewFileName
    )
{
#ifdef UNICODE
    return MoveFileW(
#else
    return MoveFileA(
#endif
        lpExistingFileName,
        lpNewFileName
        );
}
#endif  /* _M_CEE */

WINBASEAPI
BOOL
WINAPI
MoveFileExA(
    __in     LPCSTR lpExistingFileName,
    __in_opt LPCSTR lpNewFileName,
    __in     DWORD    dwFlags
    );
WINBASEAPI
BOOL
WINAPI
MoveFileExW(
    __in     LPCWSTR lpExistingFileName,
    __in_opt LPCWSTR lpNewFileName,
    __in     DWORD    dwFlags
    );
#ifdef UNICODE
#define MoveFileEx  MoveFileExW
#else
#define MoveFileEx  MoveFileExA
#endif // !UNICODE

#if (_WIN32_WINNT >= 0x0500)
WINBASEAPI
BOOL
WINAPI
MoveFileWithProgressA(
    __in     LPCSTR lpExistingFileName,
    __in_opt LPCSTR lpNewFileName,
    __in_opt LPPROGRESS_ROUTINE lpProgressRoutine,
    __in_opt LPVOID lpData,
    __in     DWORD dwFlags
    );
WINBASEAPI
BOOL
WINAPI
MoveFileWithProgressW(
    __in     LPCWSTR lpExistingFileName,
    __in_opt LPCWSTR lpNewFileName,
    __in_opt LPPROGRESS_ROUTINE lpProgressRoutine,
    __in_opt LPVOID lpData,
    __in     DWORD dwFlags
    );
#ifdef UNICODE
#define MoveFileWithProgress  MoveFileWithProgressW
#else
#define MoveFileWithProgress  MoveFileWithProgressA
#endif // !UNICODE
#endif // (_WIN32_WINNT >= 0x0500)

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI
BOOL
WINAPI
MoveFileTransactedA(
    __in     LPCSTR lpExistingFileName,
    __in_opt LPCSTR lpNewFileName,
    __in_opt LPPROGRESS_ROUTINE lpProgressRoutine,
    __in_opt LPVOID lpData,
    __in     DWORD dwFlags,
    __in     HANDLE hTransaction
    );
WINBASEAPI
BOOL
WINAPI
MoveFileTransactedW(
    __in     LPCWSTR lpExistingFileName,
    __in_opt LPCWSTR lpNewFileName,
    __in_opt LPPROGRESS_ROUTINE lpProgressRoutine,
    __in_opt LPVOID lpData,
    __in     DWORD dwFlags,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define MoveFileTransacted  MoveFileTransactedW
#else
#define MoveFileTransacted  MoveFileTransactedA
#endif // !UNICODE
#endif // (_WIN32_WINNT >= 0x0600)

#define MOVEFILE_REPLACE_EXISTING       0x00000001
#define MOVEFILE_COPY_ALLOWED           0x00000002
#define MOVEFILE_DELAY_UNTIL_REBOOT     0x00000004
#define MOVEFILE_WRITE_THROUGH          0x00000008
#if (_WIN32_WINNT >= 0x0500)
#define MOVEFILE_CREATE_HARDLINK        0x00000010
#define MOVEFILE_FAIL_IF_NOT_TRACKABLE  0x00000020
#endif // (_WIN32_WINNT >= 0x0500)



#if (_WIN32_WINNT >= 0x0500)

WINBASEAPI
BOOL
WINAPI
ReplaceFileA(
    __in       LPCSTR lpReplacedFileName,
    __in       LPCSTR lpReplacementFileName,
    __in_opt   LPCSTR lpBackupFileName,
    __in       DWORD    dwReplaceFlags,
    __reserved LPVOID   lpExclude,
    __reserved LPVOID  lpReserved
    );
WINBASEAPI
BOOL
WINAPI
ReplaceFileW(
    __in       LPCWSTR lpReplacedFileName,
    __in       LPCWSTR lpReplacementFileName,
    __in_opt   LPCWSTR lpBackupFileName,
    __in       DWORD    dwReplaceFlags,
    __reserved LPVOID   lpExclude,
    __reserved LPVOID  lpReserved
    );
#ifdef UNICODE
#define ReplaceFile  ReplaceFileW
#else
#define ReplaceFile  ReplaceFileA
#endif // !UNICODE
#endif // (_WIN32_WINNT >= 0x0500)


#if (_WIN32_WINNT >= 0x0500)
//
// API call to create hard links.
//

WINBASEAPI
BOOL
WINAPI
CreateHardLinkA(
    __in       LPCSTR lpFileName,
    __in       LPCSTR lpExistingFileName,
    __reserved LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
BOOL
WINAPI
CreateHardLinkW(
    __in       LPCWSTR lpFileName,
    __in       LPCWSTR lpExistingFileName,
    __reserved LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateHardLink  CreateHardLinkW
#else
#define CreateHardLink  CreateHardLinkA
#endif // !UNICODE

#endif // (_WIN32_WINNT >= 0x0500)

#if (_WIN32_WINNT >= 0x0600)
//
// API call to create hard links.
//

WINBASEAPI
BOOL
WINAPI
CreateHardLinkTransactedA(
    __in       LPCSTR lpFileName,
    __in       LPCSTR lpExistingFileName,
    __reserved LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in       HANDLE hTransaction
    );
WINBASEAPI
BOOL
WINAPI
CreateHardLinkTransactedW(
    __in       LPCWSTR lpFileName,
    __in       LPCWSTR lpExistingFileName,
    __reserved LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in       HANDLE hTransaction
    );
#ifdef UNICODE
#define CreateHardLinkTransacted  CreateHardLinkTransactedW
#else
#define CreateHardLinkTransacted  CreateHardLinkTransactedA
#endif // !UNICODE

#endif // (_WIN32_WINNT >= 0x0600)


#if (_WIN32_WINNT >= 0x0501)

//
// API call to enumerate for streams within a file
//

typedef enum _STREAM_INFO_LEVELS {

    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel

} STREAM_INFO_LEVELS;

typedef struct _WIN32_FIND_STREAM_DATA {

    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[ MAX_PATH + 36 ];

} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;

WINBASEAPI
__out
HANDLE
WINAPI
FindFirstStreamW(
    __in       LPCWSTR lpFileName,
    __in       STREAM_INFO_LEVELS InfoLevel,
    __out      LPVOID lpFindStreamData,
    __reserved DWORD dwFlags
    );

#if _WIN32_WINNT >= 0x0600
WINBASEAPI
HANDLE
WINAPI
FindFirstStreamTransactedW (
    __in       LPCWSTR lpFileName,
    __in       STREAM_INFO_LEVELS InfoLevel,
    __out      LPVOID lpFindStreamData,
    __reserved DWORD dwFlags,
    __in       HANDLE hTransaction
    );
#endif // _WIN32_WINNT >= 0x600

WINBASEAPI
BOOL
APIENTRY
FindNextStreamW(
    __in  HANDLE hFindStream,
    __out LPVOID lpFindStreamData
    );
#endif // (_WIN32_WINNT >= 0x0501)

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
HANDLE
WINAPI
FindFirstFileNameW (
    __in    LPCWSTR lpFileName,
    __in    DWORD dwFlags,
    __inout LPDWORD StringLength,
    __inout_ecount(*StringLength) PWCHAR LinkName
    );

WINBASEAPI
BOOL
APIENTRY
FindNextFileNameW (
    __in    HANDLE hFindStream,
    __inout LPDWORD StringLength,
    __inout_ecount(*StringLength) PWCHAR LinkName
    );

WINBASEAPI
HANDLE
WINAPI
FindFirstFileNameTransactedW (
    __in     LPCWSTR lpFileName,
    __in     DWORD dwFlags,
    __inout  LPDWORD StringLength,
    __inout_ecount(*StringLength) PWCHAR LinkName,
    __in_opt HANDLE hTransaction
    );

#endif


WINBASEAPI
__out
HANDLE
WINAPI
CreateNamedPipeA(
    __in     LPCSTR lpName,
    __in     DWORD dwOpenMode,
    __in     DWORD dwPipeMode,
    __in     DWORD nMaxInstances,
    __in     DWORD nOutBufferSize,
    __in     DWORD nInBufferSize,
    __in     DWORD nDefaultTimeOut,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
WINBASEAPI
__out
HANDLE
WINAPI
CreateNamedPipeW(
    __in     LPCWSTR lpName,
    __in     DWORD dwOpenMode,
    __in     DWORD dwPipeMode,
    __in     DWORD nMaxInstances,
    __in     DWORD nOutBufferSize,
    __in     DWORD nInBufferSize,
    __in     DWORD nDefaultTimeOut,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#ifdef UNICODE
#define CreateNamedPipe  CreateNamedPipeW
#else
#define CreateNamedPipe  CreateNamedPipeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetNamedPipeHandleStateA(
    __in      HANDLE hNamedPipe,
    __out_opt LPDWORD lpState,
    __out_opt LPDWORD lpCurInstances,
    __out_opt LPDWORD lpMaxCollectionCount,
    __out_opt LPDWORD lpCollectDataTimeout,
    __out_ecount_opt(nMaxUserNameSize) LPSTR lpUserName,
    __in      DWORD nMaxUserNameSize
    );
WINBASEAPI
BOOL
WINAPI
GetNamedPipeHandleStateW(
    __in      HANDLE hNamedPipe,
    __out_opt LPDWORD lpState,
    __out_opt LPDWORD lpCurInstances,
    __out_opt LPDWORD lpMaxCollectionCount,
    __out_opt LPDWORD lpCollectDataTimeout,
    __out_ecount_opt(nMaxUserNameSize) LPWSTR lpUserName,
    __in      DWORD nMaxUserNameSize
    );
#ifdef UNICODE
#define GetNamedPipeHandleState  GetNamedPipeHandleStateW
#else
#define GetNamedPipeHandleState  GetNamedPipeHandleStateA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CallNamedPipeA(
    __in  LPCSTR lpNamedPipeName,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in  DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesRead) LPVOID lpOutBuffer,
    __in  DWORD nOutBufferSize,
    __out LPDWORD lpBytesRead,
    __in  DWORD nTimeOut
    );
WINBASEAPI
BOOL
WINAPI
CallNamedPipeW(
    __in  LPCWSTR lpNamedPipeName,
    __in_bcount_opt(nInBufferSize) LPVOID lpInBuffer,
    __in  DWORD nInBufferSize,
    __out_bcount_part_opt(nOutBufferSize, *lpBytesRead) LPVOID lpOutBuffer,
    __in  DWORD nOutBufferSize,
    __out LPDWORD lpBytesRead,
    __in  DWORD nTimeOut
    );
#ifdef UNICODE
#define CallNamedPipe  CallNamedPipeW
#else
#define CallNamedPipe  CallNamedPipeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WaitNamedPipeA(
    __in LPCSTR lpNamedPipeName,
    __in DWORD nTimeOut
    );
WINBASEAPI
BOOL
WINAPI
WaitNamedPipeW(
    __in LPCWSTR lpNamedPipeName,
    __in DWORD nTimeOut
    );
#ifdef UNICODE
#define WaitNamedPipe  WaitNamedPipeW
#else
#define WaitNamedPipe  WaitNamedPipeA
#endif // !UNICODE

typedef enum {
    PipeAttribute,
    PipeConnectionAttribute,
    PipeHandleAttribute
} PIPE_ATTRIBUTE_TYPE;

WINBASEAPI
BOOL
WINAPI
GetNamedPipeAttribute(
    __in HANDLE Pipe,
    __in PIPE_ATTRIBUTE_TYPE AttributeType,
    __in PSTR AttributeName,
    __out_bcount(*AttributeValueLength) PVOID AttributeValue,
    __inout PSIZE_T AttributeValueLength
    );

WINBASEAPI
BOOL
WINAPI
SetNamedPipeAttribute(
    __in HANDLE Pipe,
    __in PIPE_ATTRIBUTE_TYPE AttributeType,
    __in PSTR AttributeName,
    __in PVOID AttributeValue,
    __in SIZE_T AttributeValueLength
    );

WINBASEAPI
BOOL
WINAPI
GetNamedPipeClientComputerNameA(
    __in HANDLE Pipe,
    __out_bcount(ClientComputerNameLength)  LPSTR ClientComputerName,
    __in ULONG ClientComputerNameLength
    );
WINBASEAPI
BOOL
WINAPI
GetNamedPipeClientComputerNameW(
    __in HANDLE Pipe,
    __out_bcount(ClientComputerNameLength)  LPWSTR ClientComputerName,
    __in ULONG ClientComputerNameLength
    );
#ifdef UNICODE
#define GetNamedPipeClientComputerName  GetNamedPipeClientComputerNameW
#else
#define GetNamedPipeClientComputerName  GetNamedPipeClientComputerNameA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetNamedPipeClientProcessId(
    __in HANDLE Pipe,
    __out PULONG ClientProcessId
    );

WINBASEAPI
BOOL
WINAPI
GetNamedPipeClientSessionId(
    __in HANDLE Pipe,
    __out PULONG ClientSessionId
    );

WINBASEAPI
BOOL
WINAPI
GetNamedPipeServerProcessId(
    __in HANDLE Pipe,
    __out PULONG ServerProcessId
    );

WINBASEAPI
BOOL
WINAPI
GetNamedPipeServerSessionId(
    __in HANDLE Pipe,
    __out PULONG ServerSessionId
    );

WINBASEAPI
BOOL
WINAPI
SetVolumeLabelA(
    __in_opt LPCSTR lpRootPathName,
    __in_opt LPCSTR lpVolumeName
    );
WINBASEAPI
BOOL
WINAPI
SetVolumeLabelW(
    __in_opt LPCWSTR lpRootPathName,
    __in_opt LPCWSTR lpVolumeName
    );
#ifdef UNICODE
#define SetVolumeLabel  SetVolumeLabelW
#else
#define SetVolumeLabel  SetVolumeLabelA
#endif // !UNICODE

WINBASEAPI
VOID
WINAPI
SetFileApisToOEM( VOID );

WINBASEAPI
VOID
WINAPI
SetFileApisToANSI( VOID );

WINBASEAPI
BOOL
WINAPI
AreFileApisANSI( VOID );

WINBASEAPI
BOOL
WINAPI
GetVolumeInformationA(
    __in_opt  LPCSTR lpRootPathName,
    __out_ecount_opt(nVolumeNameSize) LPSTR lpVolumeNameBuffer,
    __in      DWORD nVolumeNameSize,
    __out_opt LPDWORD lpVolumeSerialNumber,
    __out_opt LPDWORD lpMaximumComponentLength,
    __out_opt LPDWORD lpFileSystemFlags,
    __out_ecount_opt(nFileSystemNameSize) LPSTR lpFileSystemNameBuffer,
    __in      DWORD nFileSystemNameSize
    );
WINBASEAPI
BOOL
WINAPI
GetVolumeInformationW(
    __in_opt  LPCWSTR lpRootPathName,
    __out_ecount_opt(nVolumeNameSize) LPWSTR lpVolumeNameBuffer,
    __in      DWORD nVolumeNameSize,
    __out_opt LPDWORD lpVolumeSerialNumber,
    __out_opt LPDWORD lpMaximumComponentLength,
    __out_opt LPDWORD lpFileSystemFlags,
    __out_ecount_opt(nFileSystemNameSize) LPWSTR lpFileSystemNameBuffer,
    __in      DWORD nFileSystemNameSize
    );
#ifdef UNICODE
#define GetVolumeInformation  GetVolumeInformationW
#else
#define GetVolumeInformation  GetVolumeInformationA
#endif // !UNICODE

#if(_WIN32_WINNT >= 0x0600)
WINBASEAPI
BOOL
WINAPI
GetVolumeInformationByHandleW(
    __in      HANDLE hFile,
    __out_ecount_opt(nVolumeNameSize) LPWSTR lpVolumeNameBuffer,
    __in      DWORD nVolumeNameSize,
    __out_opt LPDWORD lpVolumeSerialNumber,
    __out_opt LPDWORD lpMaximumComponentLength,
    __out_opt LPDWORD lpFileSystemFlags,
    __out_ecount_opt(nFileSystemNameSize) LPWSTR lpFileSystemNameBuffer,
    __in      DWORD nFileSystemNameSize
    );
#endif /* _WIN32_WINNT >=  0x0600 */

WINBASEAPI
BOOL
WINAPI
CancelSynchronousIo(
    __in HANDLE hThread
    );

WINBASEAPI
BOOL
WINAPI
CancelIoEx(
    __in HANDLE hFile,
    __in_opt LPOVERLAPPED lpOverlapped
    );

WINBASEAPI
BOOL
WINAPI
CancelIo(
    __in HANDLE hFile
    );

WINBASEAPI
BOOL
WINAPI
SetFileBandwidthReservation(
    __in  HANDLE  hFile,
    __in  DWORD   nPeriodMilliseconds,
    __in  DWORD   nBytesPerPeriod,
    __in  BOOL    bDiscardable,
    __out LPDWORD lpTransferSize,
    __out LPDWORD lpNumOutstandingRequests
    );

WINBASEAPI
BOOL
WINAPI
GetFileBandwidthReservation(
    __in  HANDLE  hFile,
    __out LPDWORD lpPeriodMilliseconds,
    __out LPDWORD lpBytesPerPeriod,
    __out LPBOOL  pDiscardable,
    __out LPDWORD lpTransferSize,
    __out LPDWORD lpNumOutstandingRequests
    );

//
// Event logging APIs
//

WINADVAPI
BOOL
WINAPI
ClearEventLogA (
    __in     HANDLE hEventLog,
    __in_opt LPCSTR lpBackupFileName
    );
WINADVAPI
BOOL
WINAPI
ClearEventLogW (
    __in     HANDLE hEventLog,
    __in_opt LPCWSTR lpBackupFileName
    );
#ifdef UNICODE
#define ClearEventLog  ClearEventLogW
#else
#define ClearEventLog  ClearEventLogA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
BackupEventLogA (
    __in HANDLE hEventLog,
    __in LPCSTR lpBackupFileName
    );
WINADVAPI
BOOL
WINAPI
BackupEventLogW (
    __in HANDLE hEventLog,
    __in LPCWSTR lpBackupFileName
    );
#ifdef UNICODE
#define BackupEventLog  BackupEventLogW
#else
#define BackupEventLog  BackupEventLogA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
CloseEventLog (
    __in HANDLE hEventLog
    );

WINADVAPI
BOOL
WINAPI
DeregisterEventSource (
    __in HANDLE hEventLog
    );

WINADVAPI
BOOL
WINAPI
NotifyChangeEventLog(
    __in HANDLE  hEventLog,
    __in HANDLE  hEvent
    );

WINADVAPI
BOOL
WINAPI
GetNumberOfEventLogRecords (
    __in  HANDLE hEventLog,
    __out PDWORD NumberOfRecords
    );

WINADVAPI
BOOL
WINAPI
GetOldestEventLogRecord (
    __in  HANDLE hEventLog,
    __out PDWORD OldestRecord
    );

WINADVAPI
__out
HANDLE
WINAPI
OpenEventLogA (
    __in_opt LPCSTR lpUNCServerName,
    __in     LPCSTR lpSourceName
    );
WINADVAPI
__out
HANDLE
WINAPI
OpenEventLogW (
    __in_opt LPCWSTR lpUNCServerName,
    __in     LPCWSTR lpSourceName
    );
#ifdef UNICODE
#define OpenEventLog  OpenEventLogW
#else
#define OpenEventLog  OpenEventLogA
#endif // !UNICODE

WINADVAPI
__out
HANDLE
WINAPI
RegisterEventSourceA (
    __in_opt LPCSTR lpUNCServerName,
    __in     LPCSTR lpSourceName
    );
WINADVAPI
__out
HANDLE
WINAPI
RegisterEventSourceW (
    __in_opt LPCWSTR lpUNCServerName,
    __in     LPCWSTR lpSourceName
    );
#ifdef UNICODE
#define RegisterEventSource  RegisterEventSourceW
#else
#define RegisterEventSource  RegisterEventSourceA
#endif // !UNICODE

WINADVAPI
__out
HANDLE
WINAPI
OpenBackupEventLogA (
    __in_opt LPCSTR lpUNCServerName,
    __in     LPCSTR lpFileName
    );
WINADVAPI
__out
HANDLE
WINAPI
OpenBackupEventLogW (
    __in_opt LPCWSTR lpUNCServerName,
    __in     LPCWSTR lpFileName
    );
#ifdef UNICODE
#define OpenBackupEventLog  OpenBackupEventLogW
#else
#define OpenBackupEventLog  OpenBackupEventLogA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ReadEventLogA (
    __in  HANDLE     hEventLog,
    __in  DWORD      dwReadFlags,
    __in  DWORD      dwRecordOffset,
    __out_bcount_part(nNumberOfBytesToRead, *pnBytesRead) LPVOID     lpBuffer,
    __in  DWORD      nNumberOfBytesToRead,
    __out DWORD      *pnBytesRead,
    __out DWORD      *pnMinNumberOfBytesNeeded
    );
WINADVAPI
BOOL
WINAPI
ReadEventLogW (
    __in  HANDLE     hEventLog,
    __in  DWORD      dwReadFlags,
    __in  DWORD      dwRecordOffset,
    __out_bcount_part(nNumberOfBytesToRead, *pnBytesRead) LPVOID     lpBuffer,
    __in  DWORD      nNumberOfBytesToRead,
    __out DWORD      *pnBytesRead,
    __out DWORD      *pnMinNumberOfBytesNeeded
    );
#ifdef UNICODE
#define ReadEventLog  ReadEventLogW
#else
#define ReadEventLog  ReadEventLogA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ReportEventA (
    __in     HANDLE     hEventLog,
    __in     WORD       wType,
    __in     WORD       wCategory,
    __in     DWORD      dwEventID,
    __in_opt PSID       lpUserSid,
    __in     WORD       wNumStrings,
    __in     DWORD      dwDataSize,
    __in_ecount_opt(wNumStrings) LPCSTR *lpStrings,
    __in_bcount_opt(dwDataSize) LPVOID lpRawData
    );
WINADVAPI
BOOL
WINAPI
ReportEventW (
    __in     HANDLE     hEventLog,
    __in     WORD       wType,
    __in     WORD       wCategory,
    __in     DWORD      dwEventID,
    __in_opt PSID       lpUserSid,
    __in     WORD       wNumStrings,
    __in     DWORD      dwDataSize,
    __in_ecount_opt(wNumStrings) LPCWSTR *lpStrings,
    __in_bcount_opt(dwDataSize) LPVOID lpRawData
    );
#ifdef UNICODE
#define ReportEvent  ReportEventW
#else
#define ReportEvent  ReportEventA
#endif // !UNICODE


#define EVENTLOG_FULL_INFO      0

typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD    dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;

WINADVAPI
BOOL
WINAPI
GetEventLogInformation (
    __in  HANDLE     hEventLog,
    __in  DWORD      dwInfoLevel,
    __out_bcount_part(cbBufSize, *pcbBytesNeeded) LPVOID lpBuffer,
    __in  DWORD      cbBufSize,
    __out LPDWORD    pcbBytesNeeded
    );

//
//
// Security APIs
//


WINADVAPI
BOOL
WINAPI
DuplicateToken(
    __in        HANDLE ExistingTokenHandle,
    __in        SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    __deref_out PHANDLE DuplicateTokenHandle
    );

WINADVAPI
BOOL
WINAPI
GetKernelObjectSecurity (
    __in  HANDLE Handle,
    __in  SECURITY_INFORMATION RequestedInformation,
    __out_bcount_opt(nLength) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in  DWORD nLength,
    __out LPDWORD lpnLengthNeeded
    );

WINADVAPI
BOOL
WINAPI
ImpersonateNamedPipeClient(
    __in HANDLE hNamedPipe
    );

WINADVAPI
BOOL
WINAPI
ImpersonateSelf(
    __in SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


WINADVAPI
BOOL
WINAPI
RevertToSelf (
    VOID
    );

WINADVAPI
BOOL
APIENTRY
SetThreadToken (
    __in_opt PHANDLE Thread,
    __in_opt HANDLE Token
    );

WINADVAPI
BOOL
WINAPI
AccessCheck (
    __in    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in    HANDLE ClientToken,
    __in    DWORD DesiredAccess,
    __in    PGENERIC_MAPPING GenericMapping,
    __out_bcount_part_opt(*PrivilegeSetLength, *PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    __inout LPDWORD PrivilegeSetLength,
    __out   LPDWORD GrantedAccess,
    __out   LPBOOL AccessStatus
    );

#if(_WIN32_WINNT >= 0x0500)
WINADVAPI
BOOL
WINAPI
AccessCheckByType (
    __in     PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in     HANDLE ClientToken,
    __in     DWORD DesiredAccess,
    __inout_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in     DWORD ObjectTypeListLength,
    __in     PGENERIC_MAPPING GenericMapping,
    __out_bcount_part_opt(*PrivilegeSetLength, *PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    __inout  LPDWORD PrivilegeSetLength,
    __out    LPDWORD GrantedAccess,
    __out    LPBOOL AccessStatus
    );

WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultList (
    __in     PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in     HANDLE ClientToken,
    __in     DWORD DesiredAccess,
    __inout_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in     DWORD ObjectTypeListLength,
    __in     PGENERIC_MAPPING GenericMapping,
    __out_bcount_part_opt(*PrivilegeSetLength, *PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    __inout  LPDWORD PrivilegeSetLength,
    __out    LPDWORD GrantedAccessList,
    __out    LPDWORD AccessStatusList
    );
#endif /* _WIN32_WINNT >=  0x0500 */


WINADVAPI
BOOL
WINAPI
OpenProcessToken (
    __in        HANDLE ProcessHandle,
    __in        DWORD DesiredAccess,
    __deref_out PHANDLE TokenHandle
    );


WINADVAPI
BOOL
WINAPI
OpenThreadToken (
    __in        HANDLE ThreadHandle,
    __in        DWORD DesiredAccess,
    __in        BOOL OpenAsSelf,
    __deref_out PHANDLE TokenHandle
    );


WINADVAPI
BOOL
WINAPI
GetTokenInformation (
    __in      HANDLE TokenHandle,
    __in      TOKEN_INFORMATION_CLASS TokenInformationClass,
    __out_bcount_part_opt(TokenInformationLength, *ReturnLength) LPVOID TokenInformation,
    __in      DWORD TokenInformationLength,
    __out     PDWORD ReturnLength
    );


WINADVAPI
BOOL
WINAPI
SetTokenInformation (
    __in HANDLE TokenHandle,
    __in TOKEN_INFORMATION_CLASS TokenInformationClass,
    __in_bcount(TokenInformationLength) LPVOID TokenInformation,
    __in DWORD TokenInformationLength
    );


WINADVAPI
BOOL
WINAPI
AdjustTokenPrivileges (
    __in      HANDLE TokenHandle,
    __in      BOOL DisableAllPrivileges,
    __in_opt  PTOKEN_PRIVILEGES NewState,
    __in      DWORD BufferLength,
    __out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    __out_opt PDWORD ReturnLength
    );


WINADVAPI
BOOL
WINAPI
AdjustTokenGroups (
    __in      HANDLE TokenHandle,
    __in      BOOL ResetToDefault,
    __in_opt  PTOKEN_GROUPS NewState,
    __in      DWORD BufferLength,
    __out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    __out_opt PDWORD ReturnLength
    );


WINADVAPI
BOOL
WINAPI
PrivilegeCheck (
    __in    HANDLE ClientToken,
    __inout PPRIVILEGE_SET RequiredPrivileges,
    __out   LPBOOL pfResult
    );


WINADVAPI
BOOL
WINAPI
AccessCheckAndAuditAlarmA (
    __in     LPCSTR SubsystemName,
    __in_opt LPVOID HandleId,
    __in     LPSTR ObjectTypeName,
    __in_opt LPSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in     DWORD DesiredAccess,
    __in     PGENERIC_MAPPING GenericMapping,
    __in     BOOL ObjectCreation,
    __out    LPDWORD GrantedAccess,
    __out    LPBOOL AccessStatus,
    __out    LPBOOL pfGenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
AccessCheckAndAuditAlarmW (
    __in     LPCWSTR SubsystemName,
    __in_opt LPVOID HandleId,
    __in     LPWSTR ObjectTypeName,
    __in_opt LPWSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in     DWORD DesiredAccess,
    __in     PGENERIC_MAPPING GenericMapping,
    __in     BOOL ObjectCreation,
    __out    LPDWORD GrantedAccess,
    __out    LPBOOL AccessStatus,
    __out    LPBOOL pfGenerateOnClose
    );
#ifdef UNICODE
#define AccessCheckAndAuditAlarm  AccessCheckAndAuditAlarmW
#else
#define AccessCheckAndAuditAlarm  AccessCheckAndAuditAlarmA
#endif // !UNICODE

#if(_WIN32_WINNT >= 0x0500)

WINADVAPI
BOOL
WINAPI
AccessCheckByTypeAndAuditAlarmA (
    __in     LPCSTR SubsystemName,
    __in     LPVOID HandleId,
    __in     LPCSTR ObjectTypeName,
    __in_opt LPCSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in     DWORD DesiredAccess,
    __in     AUDIT_EVENT_TYPE AuditType,
    __in     DWORD Flags,
    __inout_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in     DWORD ObjectTypeListLength,
    __in     PGENERIC_MAPPING GenericMapping,
    __in     BOOL ObjectCreation,
    __out    LPDWORD GrantedAccess,
    __out    LPBOOL AccessStatus,
    __out    LPBOOL pfGenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
AccessCheckByTypeAndAuditAlarmW (
    __in     LPCWSTR SubsystemName,
    __in     LPVOID HandleId,
    __in     LPCWSTR ObjectTypeName,
    __in_opt LPCWSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in     DWORD DesiredAccess,
    __in     AUDIT_EVENT_TYPE AuditType,
    __in     DWORD Flags,
    __inout_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in     DWORD ObjectTypeListLength,
    __in     PGENERIC_MAPPING GenericMapping,
    __in     BOOL ObjectCreation,
    __out    LPDWORD GrantedAccess,
    __out    LPBOOL AccessStatus,
    __out    LPBOOL pfGenerateOnClose
    );
#ifdef UNICODE
#define AccessCheckByTypeAndAuditAlarm  AccessCheckByTypeAndAuditAlarmW
#else
#define AccessCheckByTypeAndAuditAlarm  AccessCheckByTypeAndAuditAlarmA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultListAndAuditAlarmA (
    __in     LPCSTR SubsystemName,
    __in     LPVOID HandleId,
    __in     LPCSTR ObjectTypeName,
    __in_opt LPCSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in     DWORD DesiredAccess,
    __in     AUDIT_EVENT_TYPE AuditType,
    __in     DWORD Flags,
    __inout_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in     DWORD ObjectTypeListLength,
    __in     PGENERIC_MAPPING GenericMapping,
    __in     BOOL ObjectCreation,
    __out    LPDWORD GrantedAccess,
    __out    LPDWORD AccessStatusList,
    __out    LPBOOL pfGenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultListAndAuditAlarmW (
    __in     LPCWSTR SubsystemName,
    __in     LPVOID HandleId,
    __in     LPCWSTR ObjectTypeName,
    __in_opt LPCWSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in     DWORD DesiredAccess,
    __in     AUDIT_EVENT_TYPE AuditType,
    __in     DWORD Flags,
    __inout_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in     DWORD ObjectTypeListLength,
    __in     PGENERIC_MAPPING GenericMapping,
    __in     BOOL ObjectCreation,
    __out    LPDWORD GrantedAccess,
    __out    LPDWORD AccessStatusList,
    __out    LPBOOL pfGenerateOnClose
    );
#ifdef UNICODE
#define AccessCheckByTypeResultListAndAuditAlarm  AccessCheckByTypeResultListAndAuditAlarmW
#else
#define AccessCheckByTypeResultListAndAuditAlarm  AccessCheckByTypeResultListAndAuditAlarmA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
    __in     LPCSTR SubsystemName,
    __in     LPVOID HandleId,
    __in     HANDLE ClientToken,
    __in     LPCSTR ObjectTypeName,
    __in_opt LPCSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in     DWORD DesiredAccess,
    __in     AUDIT_EVENT_TYPE AuditType,
    __in     DWORD Flags,
    __inout_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in     DWORD ObjectTypeListLength,
    __in     PGENERIC_MAPPING GenericMapping,
    __in     BOOL ObjectCreation,
    __out    LPDWORD GrantedAccess,
    __out    LPDWORD AccessStatusList,
    __out    LPBOOL pfGenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultListAndAuditAlarmByHandleW (
    __in     LPCWSTR SubsystemName,
    __in     LPVOID HandleId,
    __in     HANDLE ClientToken,
    __in     LPCWSTR ObjectTypeName,
    __in_opt LPCWSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PSID PrincipalSelfSid,
    __in     DWORD DesiredAccess,
    __in     AUDIT_EVENT_TYPE AuditType,
    __in     DWORD Flags,
    __inout_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    __in     DWORD ObjectTypeListLength,
    __in     PGENERIC_MAPPING GenericMapping,
    __in     BOOL ObjectCreation,
    __out    LPDWORD GrantedAccess,
    __out    LPDWORD AccessStatusList,
    __out    LPBOOL pfGenerateOnClose
    );
#ifdef UNICODE
#define AccessCheckByTypeResultListAndAuditAlarmByHandle  AccessCheckByTypeResultListAndAuditAlarmByHandleW
#else
#define AccessCheckByTypeResultListAndAuditAlarmByHandle  AccessCheckByTypeResultListAndAuditAlarmByHandleA
#endif // !UNICODE

#endif //(_WIN32_WINNT >= 0x0500)

WINADVAPI
BOOL
WINAPI
ObjectOpenAuditAlarmA (
    __in     LPCSTR SubsystemName,
    __in     LPVOID HandleId,
    __in     LPSTR ObjectTypeName,
    __in_opt LPSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in     HANDLE ClientToken,
    __in     DWORD DesiredAccess,
    __in     DWORD GrantedAccess,
    __in_opt PPRIVILEGE_SET Privileges,
    __in     BOOL ObjectCreation,
    __in     BOOL AccessGranted,
    __out    LPBOOL GenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
ObjectOpenAuditAlarmW (
    __in     LPCWSTR SubsystemName,
    __in     LPVOID HandleId,
    __in     LPWSTR ObjectTypeName,
    __in_opt LPWSTR ObjectName,
    __in     PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in     HANDLE ClientToken,
    __in     DWORD DesiredAccess,
    __in     DWORD GrantedAccess,
    __in_opt PPRIVILEGE_SET Privileges,
    __in     BOOL ObjectCreation,
    __in     BOOL AccessGranted,
    __out    LPBOOL GenerateOnClose
    );
#ifdef UNICODE
#define ObjectOpenAuditAlarm  ObjectOpenAuditAlarmW
#else
#define ObjectOpenAuditAlarm  ObjectOpenAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
ObjectPrivilegeAuditAlarmA (
    __in LPCSTR SubsystemName,
    __in LPVOID HandleId,
    __in HANDLE ClientToken,
    __in DWORD DesiredAccess,
    __in PPRIVILEGE_SET Privileges,
    __in BOOL AccessGranted
    );
WINADVAPI
BOOL
WINAPI
ObjectPrivilegeAuditAlarmW (
    __in LPCWSTR SubsystemName,
    __in LPVOID HandleId,
    __in HANDLE ClientToken,
    __in DWORD DesiredAccess,
    __in PPRIVILEGE_SET Privileges,
    __in BOOL AccessGranted
    );
#ifdef UNICODE
#define ObjectPrivilegeAuditAlarm  ObjectPrivilegeAuditAlarmW
#else
#define ObjectPrivilegeAuditAlarm  ObjectPrivilegeAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
ObjectCloseAuditAlarmA (
    __in LPCSTR SubsystemName,
    __in LPVOID HandleId,
    __in BOOL GenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
ObjectCloseAuditAlarmW (
    __in LPCWSTR SubsystemName,
    __in LPVOID HandleId,
    __in BOOL GenerateOnClose
    );
#ifdef UNICODE
#define ObjectCloseAuditAlarm  ObjectCloseAuditAlarmW
#else
#define ObjectCloseAuditAlarm  ObjectCloseAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
ObjectDeleteAuditAlarmA (
    __in LPCSTR SubsystemName,
    __in LPVOID HandleId,
    __in BOOL GenerateOnClose
    );
WINADVAPI
BOOL
WINAPI
ObjectDeleteAuditAlarmW (
    __in LPCWSTR SubsystemName,
    __in LPVOID HandleId,
    __in BOOL GenerateOnClose
    );
#ifdef UNICODE
#define ObjectDeleteAuditAlarm  ObjectDeleteAuditAlarmW
#else
#define ObjectDeleteAuditAlarm  ObjectDeleteAuditAlarmA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
PrivilegedServiceAuditAlarmA (
    __in LPCSTR SubsystemName,
    __in LPCSTR ServiceName,
    __in HANDLE ClientToken,
    __in PPRIVILEGE_SET Privileges,
    __in BOOL AccessGranted
    );
WINADVAPI
BOOL
WINAPI
PrivilegedServiceAuditAlarmW (
    __in LPCWSTR SubsystemName,
    __in LPCWSTR ServiceName,
    __in HANDLE ClientToken,
    __in PPRIVILEGE_SET Privileges,
    __in BOOL AccessGranted
    );
#ifdef UNICODE
#define PrivilegedServiceAuditAlarm  PrivilegedServiceAuditAlarmW
#else
#define PrivilegedServiceAuditAlarm  PrivilegedServiceAuditAlarmA
#endif // !UNICODE



#if(_WIN32_WINNT >= 0x0501)


WINADVAPI
BOOL
WINAPI
IsWellKnownSid (
    __in PSID pSid,
    __in WELL_KNOWN_SID_TYPE WellKnownSidType
    );

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
CreateWellKnownSid(
    __in     WELL_KNOWN_SID_TYPE WellKnownSidType,
    __in_opt PSID DomainSid,
    __out_bcount_part_opt(*cbSid, *cbSid) PSID pSid,
    __inout  DWORD *cbSid
    );

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
EqualDomainSid(
    __in  PSID pSid1,
    __in  PSID pSid2,
    __out BOOL *pfEqual
    );

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
GetWindowsAccountDomainSid(
    __in    PSID pSid,
    __out_bcount_part_opt(*cbDomainSid, *cbDomainSid) PSID pDomainSid,
    __inout DWORD* cbDomainSid
    );

#endif //(_WIN32_WINNT >= 0x0501)

WINADVAPI
BOOL
WINAPI
IsValidSid (
    __in PSID pSid
    );


WINADVAPI
BOOL
WINAPI
EqualSid (
    __in PSID pSid1,
    __in PSID pSid2
    );


WINADVAPI
BOOL
WINAPI
EqualPrefixSid (
    __in PSID pSid1,
    __in PSID pSid2
    );


WINADVAPI
DWORD
WINAPI
GetSidLengthRequired (
    __in UCHAR nSubAuthorityCount
    );


WINADVAPI
BOOL
WINAPI
AllocateAndInitializeSid (
    __in        PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    __in        BYTE nSubAuthorityCount,
    __in        DWORD nSubAuthority0,
    __in        DWORD nSubAuthority1,
    __in        DWORD nSubAuthority2,
    __in        DWORD nSubAuthority3,
    __in        DWORD nSubAuthority4,
    __in        DWORD nSubAuthority5,
    __in        DWORD nSubAuthority6,
    __in        DWORD nSubAuthority7,
    __deref_out PSID *pSid
    );

WINADVAPI
PVOID
WINAPI
FreeSid(
    __in PSID pSid
    );

WINADVAPI
BOOL
WINAPI
InitializeSid (
    __out PSID Sid,
    __in  PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    __in  BYTE nSubAuthorityCount
    );


WINADVAPI
__out
PSID_IDENTIFIER_AUTHORITY
WINAPI
GetSidIdentifierAuthority (
    __in PSID pSid
    );


WINADVAPI
__out
PDWORD
WINAPI
GetSidSubAuthority (
    __in PSID pSid,
    __in DWORD nSubAuthority
    );


WINADVAPI
__out
PUCHAR
WINAPI
GetSidSubAuthorityCount (
    __in PSID pSid
    );


WINADVAPI
DWORD
WINAPI
GetLengthSid (
    __in PSID pSid
    );


WINADVAPI
BOOL
WINAPI
CopySid (
    __in DWORD nDestinationSidLength,
    __out_bcount(nDestinationSidLength) PSID pDestinationSid,
    __in PSID pSourceSid
    );


WINADVAPI
BOOL
WINAPI
AreAllAccessesGranted (
    __in DWORD GrantedAccess,
    __in DWORD DesiredAccess
    );


WINADVAPI
BOOL
WINAPI
AreAnyAccessesGranted (
    __in DWORD GrantedAccess,
    __in DWORD DesiredAccess
    );


WINADVAPI
VOID
WINAPI
MapGenericMask (
    __inout PDWORD AccessMask,
    __in    PGENERIC_MAPPING GenericMapping
    );


WINADVAPI
BOOL
WINAPI
IsValidAcl (
    __in PACL pAcl
    );


WINADVAPI
BOOL
WINAPI
InitializeAcl (
    __out_bcount(nAclLength) PACL pAcl,
    __in DWORD nAclLength,
    __in DWORD dwAclRevision
    );


WINADVAPI
BOOL
WINAPI
GetAclInformation (
    __in PACL pAcl,
    __out_bcount(nAclInformationLength) LPVOID pAclInformation,
    __in DWORD nAclInformationLength,
    __in ACL_INFORMATION_CLASS dwAclInformationClass
    );


WINADVAPI
BOOL
WINAPI
SetAclInformation (
    __inout PACL pAcl,
    __in_bcount(nAclInformationLength) LPVOID pAclInformation,
    __in    DWORD nAclInformationLength,
    __in    ACL_INFORMATION_CLASS dwAclInformationClass
    );


WINADVAPI
BOOL
WINAPI
AddAce (
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD dwStartingAceIndex,
    __in_bcount(nAceListLength) LPVOID pAceList,
    __in    DWORD nAceListLength
    );


WINADVAPI
BOOL
WINAPI
DeleteAce (
    __inout PACL pAcl,
    __in    DWORD dwAceIndex
    );


WINADVAPI
BOOL
WINAPI
GetAce (
    __in        PACL pAcl,
    __in        DWORD dwAceIndex,
    __deref_out LPVOID *pAce
    );


WINADVAPI
BOOL
WINAPI
AddAccessAllowedAce (
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD AccessMask,
    __in    PSID pSid
    );

#if(_WIN32_WINNT >= 0x0500)
WINADVAPI
BOOL
WINAPI
AddAccessAllowedAceEx (
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD AceFlags,
    __in    DWORD AccessMask,
    __in    PSID pSid
    );
#endif /* _WIN32_WINNT >=  0x0500 */

#if(_WIN32_WINNT >= 0x0600)
WINADVAPI
BOOL
WINAPI
AddMandatoryAce (
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD AceFlags,
    __in    DWORD MandatoryPolicy,
    __in    PSID pLabelSid
    );
#endif /* _WIN32_WINNT >=  0x0600 */

#if(_WIN32_WINNT >= 0x0601)
WINADVAPI
BOOL
WINAPI
AddConditionalAce (
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD AceFlags,
    __in    UCHAR AceType,
    __in    DWORD AccessMask,
    __in    PSID pSid,
    __in    PWCHAR ConditionStr,
    __out DWORD *ReturnLength
    );
#endif /* _WIN32_WINNT >=  0x0601 */

WINADVAPI
BOOL
WINAPI
AddAccessDeniedAce (
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD AccessMask,
    __in    PSID pSid
    );

#if(_WIN32_WINNT >= 0x0500)
WINADVAPI
BOOL
WINAPI
AddAccessDeniedAceEx (
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD AceFlags,
    __in    DWORD AccessMask,
    __in    PSID pSid
    );
#endif /* _WIN32_WINNT >=  0x0500 */

WINADVAPI
BOOL
WINAPI
AddAuditAccessAce(
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD dwAccessMask,
    __in    PSID pSid,
    __in    BOOL bAuditSuccess,
    __in    BOOL bAuditFailure
    );

#if(_WIN32_WINNT >= 0x0500)
WINADVAPI
BOOL
WINAPI
AddAuditAccessAceEx(
    __inout PACL pAcl,
    __in    DWORD dwAceRevision,
    __in    DWORD AceFlags,
    __in    DWORD dwAccessMask,
    __in    PSID pSid,
    __in    BOOL bAuditSuccess,
    __in    BOOL bAuditFailure
    );

WINADVAPI
BOOL
WINAPI
AddAccessAllowedObjectAce (
    __inout  PACL pAcl,
    __in     DWORD dwAceRevision,
    __in     DWORD AceFlags,
    __in     DWORD AccessMask,
    __in_opt GUID *ObjectTypeGuid,
    __in_opt GUID *InheritedObjectTypeGuid,
    __in     PSID pSid
    );

WINADVAPI
BOOL
WINAPI
AddAccessDeniedObjectAce (
    __inout  PACL pAcl,
    __in     DWORD dwAceRevision,
    __in     DWORD AceFlags,
    __in     DWORD AccessMask,
    __in_opt GUID *ObjectTypeGuid,
    __in_opt GUID *InheritedObjectTypeGuid,
    __in     PSID pSid
    );

WINADVAPI
BOOL
WINAPI
AddAuditAccessObjectAce (
    __inout  PACL pAcl,
    __in     DWORD dwAceRevision,
    __in     DWORD AceFlags,
    __in     DWORD AccessMask,
    __in_opt GUID *ObjectTypeGuid,
    __in_opt GUID *InheritedObjectTypeGuid,
    __in     PSID pSid,
    __in     BOOL bAuditSuccess,
    __in     BOOL bAuditFailure
    );
#endif /* _WIN32_WINNT >=  0x0500 */

WINADVAPI
BOOL
WINAPI
FindFirstFreeAce (
    __in        PACL pAcl,
    __deref_out LPVOID *pAce
    );


WINADVAPI
BOOL
WINAPI
InitializeSecurityDescriptor (
    __out PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in  DWORD dwRevision
    );


WINADVAPI
BOOL
WINAPI
IsValidSecurityDescriptor (
    __in PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

WINADVAPI
BOOL
WINAPI
IsValidRelativeSecurityDescriptor (
    __in PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in ULONG SecurityDescriptorLength,
    __in SECURITY_INFORMATION RequiredInformation
    );

WINADVAPI
DWORD
WINAPI
GetSecurityDescriptorLength (
    __in PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorControl (
    __in  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __out PSECURITY_DESCRIPTOR_CONTROL pControl,
    __out LPDWORD lpdwRevision
    );

#if(_WIN32_WINNT >= 0x0500)
WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorControl (
    __in PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    __in SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );
#endif /* _WIN32_WINNT >=  0x0500 */

WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorDacl (
    __inout  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in     BOOL bDaclPresent,
    __in_opt PACL pDacl,
    __in     BOOL bDaclDefaulted
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorDacl (
    __in        PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __out       LPBOOL lpbDaclPresent,
    __deref_out PACL *pDacl,
    __out       LPBOOL lpbDaclDefaulted
    );


WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorSacl (
    __inout  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in     BOOL bSaclPresent,
    __in_opt PACL pSacl,
    __in     BOOL bSaclDefaulted
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorSacl (
    __in        PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __out       LPBOOL lpbSaclPresent,
    __deref_out PACL *pSacl,
    __out       LPBOOL lpbSaclDefaulted
    );


WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorOwner (
    __inout  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in_opt PSID pOwner,
    __in     BOOL bOwnerDefaulted
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorOwner (
    __in        PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __deref_out PSID *pOwner,
    __out       LPBOOL lpbOwnerDefaulted
    );


WINADVAPI
BOOL
WINAPI
SetSecurityDescriptorGroup (
    __inout  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in_opt PSID pGroup,
    __in     BOOL bGroupDefaulted
    );


WINADVAPI
BOOL
WINAPI
GetSecurityDescriptorGroup (
    __in        PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __deref_out PSID *pGroup,
    __out       LPBOOL lpbGroupDefaulted
    );


WINADVAPI
DWORD
WINAPI
SetSecurityDescriptorRMControl(
    __inout  PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in_opt PUCHAR RMControl
    );

WINADVAPI
DWORD
WINAPI
GetSecurityDescriptorRMControl(
    __in  PSECURITY_DESCRIPTOR SecurityDescriptor,
    __out PUCHAR RMControl
    );

WINADVAPI
BOOL
WINAPI
CreatePrivateObjectSecurity (
    __in_opt    PSECURITY_DESCRIPTOR ParentDescriptor,
    __in_opt    PSECURITY_DESCRIPTOR CreatorDescriptor,
    __deref_out PSECURITY_DESCRIPTOR * NewDescriptor,
    __in        BOOL IsDirectoryObject,
    __in_opt    HANDLE Token,
    __in        PGENERIC_MAPPING GenericMapping
    );

#if(_WIN32_WINNT >= 0x0500)
WINADVAPI
BOOL
WINAPI
ConvertToAutoInheritPrivateObjectSecurity(
    __in_opt    PSECURITY_DESCRIPTOR ParentDescriptor,
    __in        PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    __deref_out PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    __in_opt    GUID *ObjectType,
    __in        BOOLEAN IsDirectoryObject,
    __in        PGENERIC_MAPPING GenericMapping
    );

WINADVAPI
BOOL
WINAPI
CreatePrivateObjectSecurityEx (
    __in_opt    PSECURITY_DESCRIPTOR ParentDescriptor,
    __in_opt    PSECURITY_DESCRIPTOR CreatorDescriptor,
    __deref_out PSECURITY_DESCRIPTOR * NewDescriptor,
    __in_opt    GUID *ObjectType,
    __in        BOOL IsContainerObject,
    __in        ULONG AutoInheritFlags,
    __in_opt    HANDLE Token,
    __in        PGENERIC_MAPPING GenericMapping
    );

WINADVAPI
BOOL
WINAPI
CreatePrivateObjectSecurityWithMultipleInheritance (
    __in_opt    PSECURITY_DESCRIPTOR ParentDescriptor,
    __in_opt    PSECURITY_DESCRIPTOR CreatorDescriptor,
    __deref_out PSECURITY_DESCRIPTOR * NewDescriptor,
    __in_ecount_opt(GuidCount) GUID **ObjectTypes,
    __in        ULONG GuidCount,
    __in        BOOL IsContainerObject,
    __in        ULONG AutoInheritFlags,
    __in_opt    HANDLE Token,
    __in        PGENERIC_MAPPING GenericMapping
    );
#endif /* _WIN32_WINNT >=  0x0500 */

WINADVAPI
BOOL
WINAPI
SetPrivateObjectSecurity (
    __in          SECURITY_INFORMATION SecurityInformation,
    __in          PSECURITY_DESCRIPTOR ModificationDescriptor,
    __deref_inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    __in          PGENERIC_MAPPING GenericMapping,
    __in_opt      HANDLE Token
    );

#if(_WIN32_WINNT >= 0x0500)
WINADVAPI
BOOL
WINAPI
SetPrivateObjectSecurityEx (
    __in          SECURITY_INFORMATION SecurityInformation,
    __in          PSECURITY_DESCRIPTOR ModificationDescriptor,
    __deref_inout PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    __in          ULONG AutoInheritFlags,
    __in          PGENERIC_MAPPING GenericMapping,
    __in_opt      HANDLE Token
    );
#endif /* _WIN32_WINNT >=  0x0500 */

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
GetPrivateObjectSecurity (
    __in  PSECURITY_DESCRIPTOR ObjectDescriptor,
    __in  SECURITY_INFORMATION SecurityInformation,
    __out_bcount_part_opt(DescriptorLength, *ReturnLength) PSECURITY_DESCRIPTOR ResultantDescriptor,
    __in  DWORD DescriptorLength,
    __out PDWORD ReturnLength
    );


WINADVAPI
BOOL
WINAPI
DestroyPrivateObjectSecurity (
    __deref PSECURITY_DESCRIPTOR * ObjectDescriptor
    );


WINADVAPI
__success(return != FALSE) BOOL
WINAPI
MakeSelfRelativeSD (
    __in    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    __out_bcount_part_opt(*lpdwBufferLength, *lpdwBufferLength) PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    __inout LPDWORD lpdwBufferLength
    );


WINADVAPI
__success(return != FALSE) BOOL
WINAPI
MakeAbsoluteSD (
    __in    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    __out_bcount_part_opt(*lpdwAbsoluteSecurityDescriptorSize, *lpdwAbsoluteSecurityDescriptorSize) PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    __inout LPDWORD lpdwAbsoluteSecurityDescriptorSize,
    __out_bcount_part_opt(*lpdwDaclSize, *lpdwDaclSize) PACL pDacl,
    __inout LPDWORD lpdwDaclSize,
    __out_bcount_part_opt(*lpdwSaclSize, *lpdwSaclSize) PACL pSacl,
    __inout LPDWORD lpdwSaclSize,
    __out_bcount_part_opt(*lpdwOwnerSize, *lpdwOwnerSize) PSID pOwner,
    __inout LPDWORD lpdwOwnerSize,
    __out_bcount_part_opt(*lpdwPrimaryGroupSize, *lpdwPrimaryGroupSize) PSID pPrimaryGroup,
    __inout LPDWORD lpdwPrimaryGroupSize
    );


WINADVAPI
__success(return != FALSE) BOOL
WINAPI
MakeAbsoluteSD2 (
    __inout_bcount_part(*lpdwBufferSize, *lpdwBufferSize) PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    __inout LPDWORD lpdwBufferSize
    );

WINADVAPI
VOID
WINAPI
QuerySecurityAccessMask(
    __in SECURITY_INFORMATION SecurityInformation,
    __out LPDWORD DesiredAccess
    );

WINADVAPI
VOID
WINAPI
SetSecurityAccessMask(
    __in SECURITY_INFORMATION SecurityInformation,
    __out LPDWORD DesiredAccess
    );

WINADVAPI
BOOL
WINAPI
SetFileSecurityA (
    __in LPCSTR lpFileName,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
WINADVAPI
BOOL
WINAPI
SetFileSecurityW (
    __in LPCWSTR lpFileName,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
#ifdef UNICODE
#define SetFileSecurity  SetFileSecurityW
#else
#define SetFileSecurity  SetFileSecurityA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
GetFileSecurityA (
    __in  LPCSTR lpFileName,
    __in  SECURITY_INFORMATION RequestedInformation,
    __out_bcount_part_opt(nLength, *lpnLengthNeeded) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in  DWORD nLength,
    __out LPDWORD lpnLengthNeeded
    );
WINADVAPI
BOOL
WINAPI
GetFileSecurityW (
    __in  LPCWSTR lpFileName,
    __in  SECURITY_INFORMATION RequestedInformation,
    __out_bcount_part_opt(nLength, *lpnLengthNeeded) PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in  DWORD nLength,
    __out LPDWORD lpnLengthNeeded
    );
#ifdef UNICODE
#define GetFileSecurity  GetFileSecurityW
#else
#define GetFileSecurity  GetFileSecurityA
#endif // !UNICODE


WINADVAPI
BOOL
WINAPI
SetKernelObjectSecurity (
    __in HANDLE Handle,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );

WINBASEAPI
__out
HANDLE
WINAPI
FindFirstChangeNotificationA(
    __in LPCSTR lpPathName,
    __in BOOL bWatchSubtree,
    __in DWORD dwNotifyFilter
    );
WINBASEAPI
__out
HANDLE
WINAPI
FindFirstChangeNotificationW(
    __in LPCWSTR lpPathName,
    __in BOOL bWatchSubtree,
    __in DWORD dwNotifyFilter
    );
#ifdef UNICODE
#define FindFirstChangeNotification  FindFirstChangeNotificationW
#else
#define FindFirstChangeNotification  FindFirstChangeNotificationA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextChangeNotification(
    __in HANDLE hChangeHandle
    );

WINBASEAPI
BOOL
WINAPI
FindCloseChangeNotification(
    __in HANDLE hChangeHandle
    );

#if(_WIN32_WINNT >= 0x0400)
WINBASEAPI
BOOL
WINAPI
ReadDirectoryChangesW(
    __in        HANDLE hDirectory,
    __out_bcount_part(nBufferLength, *lpBytesReturned) LPVOID lpBuffer,
    __in        DWORD nBufferLength,
    __in        BOOL bWatchSubtree,
    __in        DWORD dwNotifyFilter,
    __out_opt   LPDWORD lpBytesReturned,
    __inout_opt LPOVERLAPPED lpOverlapped,
    __in_opt    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#endif /* _WIN32_WINNT >= 0x0400 */

WINBASEAPI
BOOL
WINAPI
VirtualLock(
    __in LPVOID lpAddress,
    __in SIZE_T dwSize
    );

WINBASEAPI
BOOL
WINAPI
VirtualUnlock(
    __in LPVOID lpAddress,
    __in SIZE_T dwSize
    );

WINBASEAPI
__out_opt __out_data_source(FILE)
LPVOID
WINAPI
MapViewOfFileEx(
    __in     HANDLE hFileMappingObject,
    __in     DWORD dwDesiredAccess,
    __in     DWORD dwFileOffsetHigh,
    __in     DWORD dwFileOffsetLow,
    __in     SIZE_T dwNumberOfBytesToMap,
    __in_opt LPVOID lpBaseAddress
    );

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
__out __out_data_source(FILE)
LPVOID
WINAPI
MapViewOfFileExNuma(
    __in     HANDLE hFileMappingObject,
    __in     DWORD dwDesiredAccess,
    __in     DWORD dwFileOffsetHigh,
    __in     DWORD dwFileOffsetLow,
    __in     SIZE_T dwNumberOfBytesToMap,
    __in_opt LPVOID lpBaseAddress,
    __in     DWORD nndPreferred
    );

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
SetPriorityClass(
    __in HANDLE hProcess,
    __in DWORD dwPriorityClass
    );

WINBASEAPI
DWORD
WINAPI
GetPriorityClass(
    __in HANDLE hProcess
    );

WINBASEAPI
BOOL
WINAPI
IsBadReadPtr(
    __in_opt CONST VOID *lp,
    __in     UINT_PTR ucb
    );

WINBASEAPI
BOOL
WINAPI
IsBadWritePtr(
    __in_opt LPVOID lp,
    __in     UINT_PTR ucb
    );

WINBASEAPI
BOOL
WINAPI
IsBadHugeReadPtr(
    __in_opt CONST VOID *lp,
    __in     UINT_PTR ucb
    );

WINBASEAPI
BOOL
WINAPI
IsBadHugeWritePtr(
    __in_opt LPVOID lp,
    __in     UINT_PTR ucb
    );

WINBASEAPI
BOOL
WINAPI
IsBadCodePtr(
    __in_opt FARPROC lpfn
    );

WINBASEAPI
BOOL
WINAPI
IsBadStringPtrA(
    __in_opt LPCSTR lpsz,
    __in     UINT_PTR ucchMax
    );
WINBASEAPI
BOOL
WINAPI
IsBadStringPtrW(
    __in_opt LPCWSTR lpsz,
    __in     UINT_PTR ucchMax
    );
#ifdef UNICODE
#define IsBadStringPtr  IsBadStringPtrW
#else
#define IsBadStringPtr  IsBadStringPtrA
#endif // !UNICODE

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupAccountSidA(
    __in_opt LPCSTR lpSystemName,
    __in PSID Sid,
    __out_ecount_part_opt(*cchName, *cchName + 1) LPSTR Name,
    __inout  LPDWORD cchName,
    __out_ecount_part_opt(*cchReferencedDomainName, *cchReferencedDomainName + 1) LPSTR ReferencedDomainName,
    __inout LPDWORD cchReferencedDomainName,
    __out PSID_NAME_USE peUse
    );
WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupAccountSidW(
    __in_opt LPCWSTR lpSystemName,
    __in PSID Sid,
    __out_ecount_part_opt(*cchName, *cchName + 1) LPWSTR Name,
    __inout  LPDWORD cchName,
    __out_ecount_part_opt(*cchReferencedDomainName, *cchReferencedDomainName + 1) LPWSTR ReferencedDomainName,
    __inout LPDWORD cchReferencedDomainName,
    __out PSID_NAME_USE peUse
    );
#ifdef UNICODE
#define LookupAccountSid  LookupAccountSidW
#else
#define LookupAccountSid  LookupAccountSidA
#endif // !UNICODE

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupAccountSidLocalA(
    __in PSID Sid,
    __out_ecount_part_opt(*cchName, *cchName + 1) LPSTR Name,
    __inout  LPDWORD cchName,
    __out_ecount_part_opt(*cchReferencedDomainName, *cchReferencedDomainName + 1) LPSTR ReferencedDomainName,
    __inout LPDWORD cchReferencedDomainName,
    __out PSID_NAME_USE peUse
    );
WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupAccountSidLocalW(
    __in PSID Sid,
    __out_ecount_part_opt(*cchName, *cchName + 1) LPWSTR Name,
    __inout  LPDWORD cchName,
    __out_ecount_part_opt(*cchReferencedDomainName, *cchReferencedDomainName + 1) LPWSTR ReferencedDomainName,
    __inout LPDWORD cchReferencedDomainName,
    __out PSID_NAME_USE peUse
    );
#ifdef UNICODE
#define LookupAccountSidLocal  LookupAccountSidLocalW
#else
#define LookupAccountSidLocal  LookupAccountSidLocalA
#endif // !UNICODE

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupAccountNameA(
    __in_opt LPCSTR lpSystemName,
    __in     LPCSTR lpAccountName,
    __out_bcount_part_opt(*cbSid, *cbSid) PSID Sid,
    __inout  LPDWORD cbSid,
    __out_ecount_part_opt(*cchReferencedDomainName, *cchReferencedDomainName + 1) LPSTR ReferencedDomainName,
    __inout  LPDWORD cchReferencedDomainName,
    __out    PSID_NAME_USE peUse
    );
WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupAccountNameW(
    __in_opt LPCWSTR lpSystemName,
    __in     LPCWSTR lpAccountName,
    __out_bcount_part_opt(*cbSid, *cbSid) PSID Sid,
    __inout  LPDWORD cbSid,
    __out_ecount_part_opt(*cchReferencedDomainName, *cchReferencedDomainName + 1) LPWSTR ReferencedDomainName,
    __inout  LPDWORD cchReferencedDomainName,
    __out    PSID_NAME_USE peUse
    );
#ifdef UNICODE
#define LookupAccountName  LookupAccountNameW
#else
#define LookupAccountName  LookupAccountNameA
#endif // !UNICODE

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupAccountNameLocalA(
    __in     LPCSTR lpAccountName,
    __out_bcount_part_opt(*cbSid, *cbSid) PSID Sid,
    __inout  LPDWORD cbSid,
    __out_ecount_part_opt(*cchReferencedDomainName, *cchReferencedDomainName + 1) LPSTR ReferencedDomainName,
    __inout  LPDWORD cchReferencedDomainName,
    __out    PSID_NAME_USE peUse
    );
WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupAccountNameLocalW(
    __in     LPCWSTR lpAccountName,
    __out_bcount_part_opt(*cbSid, *cbSid) PSID Sid,
    __inout  LPDWORD cbSid,
    __out_ecount_part_opt(*cchReferencedDomainName, *cchReferencedDomainName + 1) LPWSTR ReferencedDomainName,
    __inout  LPDWORD cchReferencedDomainName,
    __out    PSID_NAME_USE peUse
    );
#ifdef UNICODE
#define LookupAccountNameLocal  LookupAccountNameLocalW
#else
#define LookupAccountNameLocal  LookupAccountNameLocalA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
LookupPrivilegeValueA(
    __in_opt LPCSTR lpSystemName,
    __in     LPCSTR lpName,
    __out    PLUID   lpLuid
    );
WINADVAPI
BOOL
WINAPI
LookupPrivilegeValueW(
    __in_opt LPCWSTR lpSystemName,
    __in     LPCWSTR lpName,
    __out    PLUID   lpLuid
    );
#ifdef UNICODE
#define LookupPrivilegeValue  LookupPrivilegeValueW
#else
#define LookupPrivilegeValue  LookupPrivilegeValueA
#endif // !UNICODE

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupPrivilegeNameA(
    __in_opt LPCSTR lpSystemName,
    __in     PLUID   lpLuid,
    __out_ecount_part_opt(*cchName, *cchName + 1) LPSTR lpName,
    __inout  LPDWORD cchName
    );
WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupPrivilegeNameW(
    __in_opt LPCWSTR lpSystemName,
    __in     PLUID   lpLuid,
    __out_ecount_part_opt(*cchName, *cchName + 1) LPWSTR lpName,
    __inout  LPDWORD cchName
    );
#ifdef UNICODE
#define LookupPrivilegeName  LookupPrivilegeNameW
#else
#define LookupPrivilegeName  LookupPrivilegeNameA
#endif // !UNICODE

WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupPrivilegeDisplayNameA(
    __in_opt LPCSTR lpSystemName,
    __in     LPCSTR lpName,
    __out_ecount_part_opt(*cchDisplayName, *cchDisplayName + 1) LPSTR lpDisplayName,
    __inout  LPDWORD cchDisplayName,
    __out    LPDWORD lpLanguageId
    );
WINADVAPI
__success(return != FALSE) BOOL
WINAPI
LookupPrivilegeDisplayNameW(
    __in_opt LPCWSTR lpSystemName,
    __in     LPCWSTR lpName,
    __out_ecount_part_opt(*cchDisplayName, *cchDisplayName + 1) LPWSTR lpDisplayName,
    __inout  LPDWORD cchDisplayName,
    __out    LPDWORD lpLanguageId
    );
#ifdef UNICODE
#define LookupPrivilegeDisplayName  LookupPrivilegeDisplayNameW
#else
#define LookupPrivilegeDisplayName  LookupPrivilegeDisplayNameA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
AllocateLocallyUniqueId(
    __out PLUID Luid
    );

WINBASEAPI
BOOL
WINAPI
BuildCommDCBA(
    __in  LPCSTR lpDef,
    __out LPDCB lpDCB
    );
WINBASEAPI
BOOL
WINAPI
BuildCommDCBW(
    __in  LPCWSTR lpDef,
    __out LPDCB lpDCB
    );
#ifdef UNICODE
#define BuildCommDCB  BuildCommDCBW
#else
#define BuildCommDCB  BuildCommDCBA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
BuildCommDCBAndTimeoutsA(
    __in  LPCSTR lpDef,
    __out LPDCB lpDCB,
    __out LPCOMMTIMEOUTS lpCommTimeouts
    );
WINBASEAPI
BOOL
WINAPI
BuildCommDCBAndTimeoutsW(
    __in  LPCWSTR lpDef,
    __out LPDCB lpDCB,
    __out LPCOMMTIMEOUTS lpCommTimeouts
    );
#ifdef UNICODE
#define BuildCommDCBAndTimeouts  BuildCommDCBAndTimeoutsW
#else
#define BuildCommDCBAndTimeouts  BuildCommDCBAndTimeoutsA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
CommConfigDialogA(
    __in     LPCSTR lpszName,
    __in_opt HWND hWnd,
    __inout  LPCOMMCONFIG lpCC
    );
WINBASEAPI
BOOL
WINAPI
CommConfigDialogW(
    __in     LPCWSTR lpszName,
    __in_opt HWND hWnd,
    __inout  LPCOMMCONFIG lpCC
    );
#ifdef UNICODE
#define CommConfigDialog  CommConfigDialogW
#else
#define CommConfigDialog  CommConfigDialogA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetDefaultCommConfigA(
    __in    LPCSTR lpszName,
    __out_bcount_part(*lpdwSize, *lpdwSize) LPCOMMCONFIG lpCC,
    __inout LPDWORD lpdwSize
    );
WINBASEAPI
BOOL
WINAPI
GetDefaultCommConfigW(
    __in    LPCWSTR lpszName,
    __out_bcount_part(*lpdwSize, *lpdwSize) LPCOMMCONFIG lpCC,
    __inout LPDWORD lpdwSize
    );
#ifdef UNICODE
#define GetDefaultCommConfig  GetDefaultCommConfigW
#else
#define GetDefaultCommConfig  GetDefaultCommConfigA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetDefaultCommConfigA(
    __in LPCSTR lpszName,
    __in_bcount(dwSize) LPCOMMCONFIG lpCC,
    __in DWORD dwSize
    );
WINBASEAPI
BOOL
WINAPI
SetDefaultCommConfigW(
    __in LPCWSTR lpszName,
    __in_bcount(dwSize) LPCOMMCONFIG lpCC,
    __in DWORD dwSize
    );
#ifdef UNICODE
#define SetDefaultCommConfig  SetDefaultCommConfigW
#else
#define SetDefaultCommConfig  SetDefaultCommConfigA
#endif // !UNICODE

#ifndef _MAC
#define MAX_COMPUTERNAME_LENGTH 15
#else
#define MAX_COMPUTERNAME_LENGTH 31
#endif

WINBASEAPI
__success(return != 0)
BOOL
WINAPI
GetComputerNameA (
    __out_ecount_part_opt(*nSize, *nSize + 1) LPSTR lpBuffer,
    __inout LPDWORD nSize
    );
WINBASEAPI
__success(return != 0)
BOOL
WINAPI
GetComputerNameW (
    __out_ecount_part_opt(*nSize, *nSize + 1) LPWSTR lpBuffer,
    __inout LPDWORD nSize
    );
#ifdef UNICODE
#define GetComputerName  GetComputerNameW
#else
#define GetComputerName  GetComputerNameA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetComputerNameA (
    __in LPCSTR lpComputerName
    );
WINBASEAPI
BOOL
WINAPI
SetComputerNameW (
    __in LPCWSTR lpComputerName
    );
#ifdef UNICODE
#define SetComputerName  SetComputerNameW
#else
#define SetComputerName  SetComputerNameA
#endif // !UNICODE


#if (_WIN32_WINNT >= 0x0500)

typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

WINBASEAPI
__success(return != 0)
BOOL
WINAPI
GetComputerNameExA (
    __in    COMPUTER_NAME_FORMAT NameType,
    __out_ecount_part_opt(*nSize, *nSize + 1) LPSTR lpBuffer,
    __inout LPDWORD nSize
    );
WINBASEAPI
__success(return != 0)
BOOL
WINAPI
GetComputerNameExW (
    __in    COMPUTER_NAME_FORMAT NameType,
    __out_ecount_part_opt(*nSize, *nSize + 1) LPWSTR lpBuffer,
    __inout LPDWORD nSize
    );
#ifdef UNICODE
#define GetComputerNameEx  GetComputerNameExW
#else
#define GetComputerNameEx  GetComputerNameExA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetComputerNameExA (
    __in COMPUTER_NAME_FORMAT NameType,
    __in LPCSTR lpBuffer
    );
WINBASEAPI
BOOL
WINAPI
SetComputerNameExW (
    __in COMPUTER_NAME_FORMAT NameType,
    __in LPCWSTR lpBuffer
    );
#ifdef UNICODE
#define SetComputerNameEx  SetComputerNameExW
#else
#define SetComputerNameEx  SetComputerNameExA
#endif // !UNICODE


WINBASEAPI
__success(return == TRUE)
BOOL
WINAPI
DnsHostnameToComputerNameA (
    __in    LPCSTR Hostname,
    __out_ecount_part_opt(*nSize, *nSize + 1) LPSTR ComputerName,
    __inout LPDWORD nSize
    );
WINBASEAPI
__success(return == TRUE)
BOOL
WINAPI
DnsHostnameToComputerNameW (
    __in    LPCWSTR Hostname,
    __out_ecount_part_opt(*nSize, *nSize + 1) LPWSTR ComputerName,
    __inout LPDWORD nSize
    );
#ifdef UNICODE
#define DnsHostnameToComputerName  DnsHostnameToComputerNameW
#else
#define DnsHostnameToComputerName  DnsHostnameToComputerNameA
#endif // !UNICODE

#endif // _WIN32_WINNT

WINADVAPI
BOOL
WINAPI
GetUserNameA (
    __out_ecount_part_opt(*pcbBuffer, *pcbBuffer) LPSTR lpBuffer,
    __inout LPDWORD pcbBuffer
    );
WINADVAPI
BOOL
WINAPI
GetUserNameW (
    __out_ecount_part_opt(*pcbBuffer, *pcbBuffer) LPWSTR lpBuffer,
    __inout LPDWORD pcbBuffer
    );
#ifdef UNICODE
#define GetUserName  GetUserNameW
#else
#define GetUserName  GetUserNameA
#endif // !UNICODE

//
// Logon Support APIs
//

#define LOGON32_LOGON_INTERACTIVE       2
#define LOGON32_LOGON_NETWORK           3
#define LOGON32_LOGON_BATCH             4
#define LOGON32_LOGON_SERVICE           5
#define LOGON32_LOGON_UNLOCK            7
#if(_WIN32_WINNT >= 0x0500)
#define LOGON32_LOGON_NETWORK_CLEARTEXT 8
#define LOGON32_LOGON_NEW_CREDENTIALS   9
#endif // (_WIN32_WINNT >= 0x0500)

#define LOGON32_PROVIDER_DEFAULT    0
#define LOGON32_PROVIDER_WINNT35    1
#if(_WIN32_WINNT >= 0x0400)
#define LOGON32_PROVIDER_WINNT40    2
#endif /* _WIN32_WINNT >= 0x0400 */
#if(_WIN32_WINNT >= 0x0500)
#define LOGON32_PROVIDER_WINNT50    3
#endif // (_WIN32_WINNT >= 0x0500)
#if(_WIN32_WINNT >= 0x0600)
#define LOGON32_PROVIDER_VIRTUAL    4
#endif // (_WIN32_WINNT >= 0x0600)



WINADVAPI
BOOL
WINAPI
LogonUserA (
    __in        LPCSTR lpszUsername,
    __in_opt    LPCSTR lpszDomain,
    __in        LPCSTR lpszPassword,
    __in        DWORD dwLogonType,
    __in        DWORD dwLogonProvider,
    __deref_out PHANDLE phToken
    );
WINADVAPI
BOOL
WINAPI
LogonUserW (
    __in        LPCWSTR lpszUsername,
    __in_opt    LPCWSTR lpszDomain,
    __in        LPCWSTR lpszPassword,
    __in        DWORD dwLogonType,
    __in        DWORD dwLogonProvider,
    __deref_out PHANDLE phToken
    );
#ifdef UNICODE
#define LogonUser  LogonUserW
#else
#define LogonUser  LogonUserA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
LogonUserExA (
    __in            LPCSTR lpszUsername,
    __in_opt        LPCSTR lpszDomain,
    __in            LPCSTR lpszPassword,
    __in            DWORD dwLogonType,
    __in            DWORD dwLogonProvider,
    __deref_opt_out PHANDLE phToken,
    __deref_opt_out PSID  *ppLogonSid,
    __deref_opt_out_bcount_full(*pdwProfileLength) PVOID *ppProfileBuffer,
    __out_opt       LPDWORD pdwProfileLength,
    __out_opt       PQUOTA_LIMITS pQuotaLimits
    );
WINADVAPI
BOOL
WINAPI
LogonUserExW (
    __in            LPCWSTR lpszUsername,
    __in_opt        LPCWSTR lpszDomain,
    __in            LPCWSTR lpszPassword,
    __in            DWORD dwLogonType,
    __in            DWORD dwLogonProvider,
    __deref_opt_out PHANDLE phToken,
    __deref_opt_out PSID  *ppLogonSid,
    __deref_opt_out_bcount_full(*pdwProfileLength) PVOID *ppProfileBuffer,
    __out_opt       LPDWORD pdwProfileLength,
    __out_opt       PQUOTA_LIMITS pQuotaLimits
    );
#ifdef UNICODE
#define LogonUserEx  LogonUserExW
#else
#define LogonUserEx  LogonUserExA
#endif // !UNICODE


#if(_WIN32_WINNT >= 0x0600)


#endif // (_WIN32_WINNT >= 0x0600)

WINADVAPI
BOOL
WINAPI
ImpersonateLoggedOnUser(
    __in HANDLE  hToken
    );

WINADVAPI
BOOL
WINAPI
CreateProcessAsUserA (
    __in_opt    HANDLE hToken,
    __in_opt    LPCSTR lpApplicationName,
    __inout_opt LPSTR lpCommandLine,
    __in_opt    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    __in_opt    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    __in        BOOL bInheritHandles,
    __in        DWORD dwCreationFlags,
    __in_opt    LPVOID lpEnvironment,
    __in_opt    LPCSTR lpCurrentDirectory,
    __in        LPSTARTUPINFOA lpStartupInfo,
    __out       LPPROCESS_INFORMATION lpProcessInformation
    );
WINADVAPI
BOOL
WINAPI
CreateProcessAsUserW (
    __in_opt    HANDLE hToken,
    __in_opt    LPCWSTR lpApplicationName,
    __inout_opt LPWSTR lpCommandLine,
    __in_opt    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    __in_opt    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    __in        BOOL bInheritHandles,
    __in        DWORD dwCreationFlags,
    __in_opt    LPVOID lpEnvironment,
    __in_opt    LPCWSTR lpCurrentDirectory,
    __in        LPSTARTUPINFOW lpStartupInfo,
    __out       LPPROCESS_INFORMATION lpProcessInformation
    );
#ifdef UNICODE
#define CreateProcessAsUser  CreateProcessAsUserW
#else
#define CreateProcessAsUser  CreateProcessAsUserA
#endif // !UNICODE


#if(_WIN32_WINNT >= 0x0500)

//
// LogonFlags
//
#define LOGON_WITH_PROFILE              0x00000001
#define LOGON_NETCREDENTIALS_ONLY       0x00000002
#define LOGON_ZERO_PASSWORD_BUFFER      0x80000000

WINADVAPI
__checkReturn BOOL
WINAPI
CreateProcessWithLogonW(
    __in        LPCWSTR lpUsername,
    __in_opt    LPCWSTR lpDomain,
    __in        LPCWSTR lpPassword,
    __in        DWORD dwLogonFlags,
    __in_opt    LPCWSTR lpApplicationName,
    __inout_opt LPWSTR lpCommandLine,
    __in        DWORD dwCreationFlags,
    __in_opt    LPVOID lpEnvironment,
    __in_opt    LPCWSTR lpCurrentDirectory,
    __in        LPSTARTUPINFOW lpStartupInfo,
    __out       LPPROCESS_INFORMATION lpProcessInformation
      );

WINADVAPI
__checkReturn BOOL
WINAPI
CreateProcessWithTokenW(
    __in        HANDLE hToken,
    __in        DWORD dwLogonFlags,
    __in_opt    LPCWSTR lpApplicationName,
    __inout_opt LPWSTR lpCommandLine,
    __in        DWORD dwCreationFlags,
    __in_opt    LPVOID lpEnvironment,
    __in_opt    LPCWSTR lpCurrentDirectory,
    __in        LPSTARTUPINFOW lpStartupInfo,
    __out       LPPROCESS_INFORMATION lpProcessInformation
      );

#endif // (_WIN32_WINNT >= 0x0500)

WINADVAPI
BOOL
APIENTRY
ImpersonateAnonymousToken(
    __in HANDLE ThreadHandle
    );

WINADVAPI
BOOL
WINAPI
DuplicateTokenEx(
    __in        HANDLE hExistingToken,
    __in        DWORD dwDesiredAccess,
    __in_opt    LPSECURITY_ATTRIBUTES lpTokenAttributes,
    __in        SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    __in        TOKEN_TYPE TokenType,
    __deref_out PHANDLE phNewToken);

WINADVAPI
BOOL
APIENTRY
CreateRestrictedToken(
    __in        HANDLE ExistingTokenHandle,
    __in        DWORD Flags,
    __in        DWORD DisableSidCount,
    __in_ecount_opt(DisableSidCount) PSID_AND_ATTRIBUTES SidsToDisable,
    __in        DWORD DeletePrivilegeCount,
    __in_ecount_opt(DeletePrivilegeCount) PLUID_AND_ATTRIBUTES PrivilegesToDelete,
    __in        DWORD RestrictedSidCount,
    __in_ecount_opt(RestrictedSidCount) PSID_AND_ATTRIBUTES SidsToRestrict,
    __deref_out PHANDLE NewTokenHandle
    );


WINADVAPI
BOOL
WINAPI
IsTokenRestricted(
    __in HANDLE TokenHandle
    );

WINADVAPI
BOOL
WINAPI
IsTokenUntrusted(
    __in HANDLE TokenHandle
    );

WINADVAPI
BOOL
APIENTRY
CheckTokenMembership(
    __in_opt HANDLE TokenHandle,
    __in     PSID SidToCheck,
    __out    PBOOL IsMember
    );

//
// Thread pool API's
//

#if (_WIN32_WINNT >= 0x0500)

typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;

WINBASEAPI
BOOL
WINAPI
RegisterWaitForSingleObject(
    __deref_out PHANDLE phNewWaitObject,
    __in        HANDLE hObject,
    __in        WAITORTIMERCALLBACK Callback,
    __in_opt    PVOID Context,
    __in        ULONG dwMilliseconds,
    __in        ULONG dwFlags
    );

WINBASEAPI
HANDLE
WINAPI
RegisterWaitForSingleObjectEx(
    __in     HANDLE hObject,
    __in     WAITORTIMERCALLBACK Callback,
    __in_opt PVOID Context,
    __in     ULONG dwMilliseconds,
    __in     ULONG dwFlags
    );

WINBASEAPI
__checkReturn
BOOL
WINAPI
UnregisterWait(
    __in HANDLE WaitHandle
    );

WINBASEAPI
__checkReturn
BOOL
WINAPI
UnregisterWaitEx(
    __in     HANDLE WaitHandle,
    __in_opt HANDLE CompletionEvent
    );

WINBASEAPI
BOOL
WINAPI
QueueUserWorkItem(
    __in     LPTHREAD_START_ROUTINE Function,
    __in_opt PVOID Context,
    __in     ULONG Flags
    );

WINBASEAPI
BOOL
WINAPI
BindIoCompletionCallback (
    __in HANDLE FileHandle,
    __in LPOVERLAPPED_COMPLETION_ROUTINE Function,
    __in ULONG Flags
    );

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateTimerQueue(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
CreateTimerQueueTimer(
    __deref_out PHANDLE phNewTimer,
    __in_opt    HANDLE TimerQueue,
    __in        WAITORTIMERCALLBACK Callback,
    __in_opt    PVOID Parameter,
    __in        DWORD DueTime,
    __in        DWORD Period,
    __in        ULONG Flags
    ) ;

WINBASEAPI
__checkReturn
BOOL
WINAPI
ChangeTimerQueueTimer(
    __in_opt HANDLE TimerQueue,
    __inout  HANDLE Timer,
    __in     ULONG DueTime,
    __in     ULONG Period
    );

WINBASEAPI
__checkReturn
BOOL
WINAPI
DeleteTimerQueueTimer(
    __in_opt HANDLE TimerQueue,
    __in     HANDLE Timer,
    __in_opt HANDLE CompletionEvent
    );

WINBASEAPI
__checkReturn
BOOL
WINAPI
DeleteTimerQueueEx(
    __in     HANDLE TimerQueue,
    __in_opt HANDLE CompletionEvent
    );

WINBASEAPI
HANDLE
WINAPI
SetTimerQueueTimer(
    __in_opt HANDLE TimerQueue,
    __in     WAITORTIMERCALLBACK Callback,
    __in_opt PVOID Parameter,
    __in     DWORD DueTime,
    __in     DWORD Period,
    __in     BOOL PreferIo
    );

WINBASEAPI
__checkReturn
BOOL
WINAPI
CancelTimerQueueTimer(
    __in_opt HANDLE TimerQueue,
    __in     HANDLE Timer
    );

WINBASEAPI
__checkReturn
BOOL
WINAPI
DeleteTimerQueue(
    __in HANDLE TimerQueue
    );

#if (_WIN32_WINNT >= 0x0600)

typedef VOID (WINAPI *PTP_WIN32_IO_CALLBACK)(
    __inout     PTP_CALLBACK_INSTANCE Instance,
    __inout_opt PVOID                 Context,
    __inout_opt PVOID                 Overlapped,
    __in        ULONG                 IoResult,
    __in        ULONG_PTR             NumberOfBytesTransferred,
    __inout     PTP_IO                Io
    );

WINBASEAPI
__checkReturn
__out
PTP_POOL
WINAPI
CreateThreadpool(
    __reserved PVOID reserved
    );

WINBASEAPI
VOID
WINAPI
SetThreadpoolThreadMaximum(
    __inout PTP_POOL ptpp,
    __in    DWORD    cthrdMost
    );

WINBASEAPI
BOOL
WINAPI
SetThreadpoolThreadMinimum(
    __inout PTP_POOL ptpp,
    __in    DWORD    cthrdMic
    );

WINBASEAPI
BOOL
WINAPI
SetThreadpoolStackInformation(
    __inout PTP_POOL           ptpp,
    __in    PTP_POOL_STACK_INFORMATION ptpsi
    );

WINBASEAPI
BOOL
WINAPI
QueryThreadpoolStackInformation(
    __in    PTP_POOL           ptpp,
    __out   PTP_POOL_STACK_INFORMATION ptpsi
    );

WINBASEAPI
VOID
WINAPI
CloseThreadpool(
    __inout PTP_POOL ptpp
    );

WINBASEAPI
__checkReturn
__out
PTP_CLEANUP_GROUP
WINAPI
CreateThreadpoolCleanupGroup(
    VOID
    );

WINBASEAPI
VOID
WINAPI
CloseThreadpoolCleanupGroupMembers(
    __inout     PTP_CLEANUP_GROUP ptpcg,
    __in        BOOL              fCancelPendingCallbacks,
    __inout_opt PVOID             pvCleanupContext
    );

WINBASEAPI
VOID
WINAPI
CloseThreadpoolCleanupGroup(
    __inout PTP_CLEANUP_GROUP ptpcg
    );

#if !defined(MIDL_PASS)

FORCEINLINE
VOID
InitializeThreadpoolEnvironment(
    __out PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpInitializeCallbackEnviron(pcbe);
}

FORCEINLINE
VOID
SetThreadpoolCallbackPool(
    __inout PTP_CALLBACK_ENVIRON pcbe,
    __in    PTP_POOL             ptpp
    )
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}

FORCEINLINE
VOID
SetThreadpoolCallbackCleanupGroup(
    __inout  PTP_CALLBACK_ENVIRON              pcbe,
    __in     PTP_CLEANUP_GROUP                 ptpcg,
    __in_opt PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    )
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}

FORCEINLINE
VOID
SetThreadpoolCallbackRunsLong(
    __inout PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackLongFunction(pcbe);
}

FORCEINLINE
VOID
SetThreadpoolCallbackLibrary(
    __inout PTP_CALLBACK_ENVIRON pcbe,
    __in    PVOID                mod
    )
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

FORCEINLINE
VOID
SetThreadpoolCallbackPriority(
    __inout PTP_CALLBACK_ENVIRON pcbe,
    __in    TP_CALLBACK_PRIORITY Priority
    )
{
    TpSetCallbackPriority(pcbe, Priority);
}

#endif

FORCEINLINE
VOID
SetThreadpoolCallbackPersistent(
    __inout PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackPersistent(pcbe);
}

FORCEINLINE
VOID
DestroyThreadpoolEnvironment(
    __inout PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpDestroyCallbackEnviron(pcbe);
}

#endif // !defined(MIDL_PASS)

WINBASEAPI
VOID
WINAPI
SetEventWhenCallbackReturns(
    __inout PTP_CALLBACK_INSTANCE pci,
    __in    HANDLE                evt
    );

WINBASEAPI
VOID
WINAPI
ReleaseSemaphoreWhenCallbackReturns(
    __inout PTP_CALLBACK_INSTANCE pci,
    __in    HANDLE                sem,
    __in    DWORD                 crel
    );

WINBASEAPI
VOID
WINAPI
ReleaseMutexWhenCallbackReturns(
    __inout PTP_CALLBACK_INSTANCE pci,
    __in    HANDLE                mut
    );

WINBASEAPI
VOID
WINAPI
LeaveCriticalSectionWhenCallbackReturns(
    __inout PTP_CALLBACK_INSTANCE pci,
    __inout PCRITICAL_SECTION     pcs
    );

WINBASEAPI
VOID
WINAPI
FreeLibraryWhenCallbackReturns(
    __inout PTP_CALLBACK_INSTANCE pci,
    __in    HMODULE               mod
    );

WINBASEAPI
BOOL
WINAPI
CallbackMayRunLong(
    __inout PTP_CALLBACK_INSTANCE pci
    );

WINBASEAPI
VOID
WINAPI
DisassociateCurrentThreadFromCallback(
    __inout PTP_CALLBACK_INSTANCE pci
    );

WINBASEAPI
__checkReturn
BOOL
WINAPI
TrySubmitThreadpoolCallback(
    __in        PTP_SIMPLE_CALLBACK  pfns,
    __inout_opt PVOID                pv,
    __in_opt    PTP_CALLBACK_ENVIRON pcbe
    );

WINBASEAPI
__checkReturn
__out
PTP_WORK
WINAPI
CreateThreadpoolWork(
    __in        PTP_WORK_CALLBACK    pfnwk,
    __inout_opt PVOID                pv,
    __in_opt    PTP_CALLBACK_ENVIRON pcbe
    );

WINBASEAPI
VOID
WINAPI
SubmitThreadpoolWork(
    __inout PTP_WORK pwk
    );

WINBASEAPI
VOID
WINAPI
WaitForThreadpoolWorkCallbacks(
    __inout PTP_WORK pwk,
    __in    BOOL     fCancelPendingCallbacks
    );

WINBASEAPI
VOID
WINAPI
CloseThreadpoolWork(
    __inout PTP_WORK pwk
    );

WINBASEAPI
__checkReturn
__out
PTP_TIMER
WINAPI
CreateThreadpoolTimer(
    __in        PTP_TIMER_CALLBACK   pfnti,
    __inout_opt PVOID                pv,
    __in_opt    PTP_CALLBACK_ENVIRON pcbe
    );

WINBASEAPI
VOID
WINAPI
SetThreadpoolTimer(
    __inout  PTP_TIMER pti,
    __in_opt PFILETIME pftDueTime,
    __in     DWORD     msPeriod,
    __in_opt DWORD     msWindowLength
    );

WINBASEAPI
BOOL
WINAPI
IsThreadpoolTimerSet(
    __inout PTP_TIMER pti
    );

WINBASEAPI
VOID
WINAPI
WaitForThreadpoolTimerCallbacks(
    __inout PTP_TIMER pti,
    __in    BOOL      fCancelPendingCallbacks
    );

WINBASEAPI
VOID
WINAPI
CloseThreadpoolTimer(
    __inout PTP_TIMER pti
    );

WINBASEAPI
__checkReturn
__out
PTP_WAIT
WINAPI
CreateThreadpoolWait(
    __in        PTP_WAIT_CALLBACK    pfnwa,
    __inout_opt PVOID                pv,
    __in_opt    PTP_CALLBACK_ENVIRON pcbe
    );

WINBASEAPI
VOID
WINAPI
SetThreadpoolWait(
    __inout  PTP_WAIT  pwa,
    __in_opt HANDLE    h,
    __in_opt PFILETIME pftTimeout
    );

WINBASEAPI
VOID
WINAPI
WaitForThreadpoolWaitCallbacks(
    __inout PTP_WAIT pwa,
    __in    BOOL     fCancelPendingCallbacks
    );

WINBASEAPI
VOID
WINAPI
CloseThreadpoolWait(
    __inout PTP_WAIT pwa
    );

WINBASEAPI
__checkReturn
__out
PTP_IO
WINAPI
CreateThreadpoolIo(
    __in        HANDLE                fl,
    __in        PTP_WIN32_IO_CALLBACK pfnio,
    __inout_opt PVOID                 pv,
    __in_opt    PTP_CALLBACK_ENVIRON  pcbe
    );

WINBASEAPI
VOID
WINAPI
StartThreadpoolIo(
    __inout PTP_IO pio
    );

WINBASEAPI
VOID
WINAPI
CancelThreadpoolIo(
    __inout PTP_IO pio
    );

WINBASEAPI
VOID
WINAPI
WaitForThreadpoolIoCallbacks(
    __inout PTP_IO pio,
    __in    BOOL   fCancelPendingCallbacks
    );

WINBASEAPI
VOID
WINAPI
CloseThreadpoolIo(
    __inout PTP_IO pio
    );

//
//  Private Namespaces support
//

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreatePrivateNamespaceA(
    __in_opt LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    __in     LPVOID lpBoundaryDescriptor,
    __in     LPCSTR lpAliasPrefix
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreatePrivateNamespaceW(
    __in_opt LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    __in     LPVOID lpBoundaryDescriptor,
    __in     LPCWSTR lpAliasPrefix
    );
#ifdef UNICODE
#define CreatePrivateNamespace  CreatePrivateNamespaceW
#else
#define CreatePrivateNamespace  CreatePrivateNamespaceA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenPrivateNamespaceA(
    __in     LPVOID lpBoundaryDescriptor,
    __in     LPCSTR lpAliasPrefix
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenPrivateNamespaceW(
    __in     LPVOID lpBoundaryDescriptor,
    __in     LPCWSTR lpAliasPrefix
    );
#ifdef UNICODE
#define OpenPrivateNamespace  OpenPrivateNamespaceW
#else
#define OpenPrivateNamespace  OpenPrivateNamespaceA
#endif // !UNICODE


#define PRIVATE_NAMESPACE_FLAG_DESTROY      0x00000001

WINBASEAPI
BOOLEAN
WINAPI
ClosePrivateNamespace(
    __in HANDLE Handle,
    __in ULONG Flags
    );


//
//  Boundary descriptors support
//

WINBASEAPI
__out_opt
HANDLE
APIENTRY
CreateBoundaryDescriptorA(
    __in LPCSTR Name,
    __in ULONG Flags
    );
WINBASEAPI
__out_opt
HANDLE
APIENTRY
CreateBoundaryDescriptorW(
    __in LPCWSTR Name,
    __in ULONG Flags
    );
#ifdef UNICODE
#define CreateBoundaryDescriptor  CreateBoundaryDescriptorW
#else
#define CreateBoundaryDescriptor  CreateBoundaryDescriptorA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
AddSIDToBoundaryDescriptor(
    __inout HANDLE * BoundaryDescriptor,
    __in PSID RequiredSid
    );

WINBASEAPI
BOOL
WINAPI
AddIntegrityLabelToBoundaryDescriptor(
    __inout HANDLE * BoundaryDescriptor,
    __in PSID IntegrityLabel
    );


WINBASEAPI
VOID
WINAPI
DeleteBoundaryDescriptor(
    __in HANDLE BoundaryDescriptor
    );


#endif // _WIN32_WINNT >= 0x0600

#endif // _WIN32_WINNT >= 0x0500


#if(_WIN32_WINNT >= 0x0400)
//
// Plug-and-Play API's
//

#define HW_PROFILE_GUIDLEN         39      // 36-characters plus NULL terminator
#define MAX_PROFILE_LEN            80

#define DOCKINFO_UNDOCKED          (0x1)
#define DOCKINFO_DOCKED            (0x2)
#define DOCKINFO_USER_SUPPLIED     (0x4)
#define DOCKINFO_USER_UNDOCKED     (DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED)
#define DOCKINFO_USER_DOCKED       (DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED)

typedef struct tagHW_PROFILE_INFOA {
    DWORD  dwDockInfo;
    CHAR   szHwProfileGuid[HW_PROFILE_GUIDLEN];
    CHAR   szHwProfileName[MAX_PROFILE_LEN];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD  dwDockInfo;
    WCHAR  szHwProfileGuid[HW_PROFILE_GUIDLEN];
    WCHAR  szHwProfileName[MAX_PROFILE_LEN];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;
#ifdef UNICODE
typedef HW_PROFILE_INFOW HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOW LPHW_PROFILE_INFO;
#else
typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;
#endif // UNICODE


WINADVAPI
BOOL
WINAPI
GetCurrentHwProfileA (
    __out LPHW_PROFILE_INFOA  lpHwProfileInfo
    );
WINADVAPI
BOOL
WINAPI
GetCurrentHwProfileW (
    __out LPHW_PROFILE_INFOW  lpHwProfileInfo
    );
#ifdef UNICODE
#define GetCurrentHwProfile  GetCurrentHwProfileW
#else
#define GetCurrentHwProfile  GetCurrentHwProfileA
#endif // !UNICODE
#endif /* _WIN32_WINNT >= 0x0400 */

//
// Performance counter API's
//

WINBASEAPI
BOOL
WINAPI
QueryPerformanceCounter(
    __out LARGE_INTEGER *lpPerformanceCount
    );

WINBASEAPI
BOOL
WINAPI
QueryPerformanceFrequency(
    __out LARGE_INTEGER *lpFrequency
    );



WINBASEAPI
BOOL
WINAPI
GetVersionExA(
    __inout LPOSVERSIONINFOA lpVersionInformation
    );
WINBASEAPI
BOOL
WINAPI
GetVersionExW(
    __inout LPOSVERSIONINFOW lpVersionInformation
    );
#ifdef UNICODE
#define GetVersionEx  GetVersionExW
#else
#define GetVersionEx  GetVersionExA
#endif // !UNICODE



WINBASEAPI
BOOL
WINAPI
VerifyVersionInfoA(
    __inout LPOSVERSIONINFOEXA lpVersionInformation,
    __in    DWORD dwTypeMask,
    __in    DWORDLONG dwlConditionMask
    );
WINBASEAPI
BOOL
WINAPI
VerifyVersionInfoW(
    __inout LPOSVERSIONINFOEXW lpVersionInformation,
    __in    DWORD dwTypeMask,
    __in    DWORDLONG dwlConditionMask
    );
#ifdef UNICODE
#define VerifyVersionInfo  VerifyVersionInfoW
#else
#define VerifyVersionInfo  VerifyVersionInfoA
#endif // !UNICODE

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
BOOL
WINAPI
GetProductInfo(
    __in  DWORD  dwOSMajorVersion,
    __in  DWORD  dwOSMinorVersion,
    __in  DWORD  dwSpMajorVersion,
    __in  DWORD  dwSpMinorVersion,
    __out PDWORD pdwReturnedProductType
    );

#endif

// DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
// API functions.
//

#include <winerror.h>

/* Abnormal termination codes */

#define TC_NORMAL       0
#define TC_HARDERR      1
#define TC_GP_TRAP      2
#define TC_SIGNAL       3

#if(WINVER >= 0x0400)
//
// Power Management APIs
//

#define AC_LINE_OFFLINE                 0x00
#define AC_LINE_ONLINE                  0x01
#define AC_LINE_BACKUP_POWER            0x02
#define AC_LINE_UNKNOWN                 0xFF

#define BATTERY_FLAG_HIGH               0x01
#define BATTERY_FLAG_LOW                0x02
#define BATTERY_FLAG_CRITICAL           0x04
#define BATTERY_FLAG_CHARGING           0x08
#define BATTERY_FLAG_NO_BATTERY         0x80
#define BATTERY_FLAG_UNKNOWN            0xFF

#define BATTERY_PERCENTAGE_UNKNOWN      0xFF

#define BATTERY_LIFE_UNKNOWN        0xFFFFFFFF

typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
}   SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

WINBASEAPI
BOOL
WINAPI
GetSystemPowerStatus(
    __out LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );

WINBASEAPI
BOOL
WINAPI
SetSystemPowerState(
    __in BOOL fSuspend,
    __in BOOL fForce
    );

#endif /* WINVER >= 0x0400 */

#if (_WIN32_WINNT >= 0x0500)
//
// Very Large Memory API Subset
//

WINBASEAPI
BOOL
WINAPI
AllocateUserPhysicalPages(
    __in    HANDLE hProcess,
    __inout PULONG_PTR NumberOfPages,
    __out_ecount_part(*NumberOfPages, *NumberOfPages) PULONG_PTR PageArray
    );

#if _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
AllocateUserPhysicalPagesNuma(
    __in    HANDLE hProcess,
    __inout PULONG_PTR NumberOfPages,
    __out_ecount_part(*NumberOfPages, *NumberOfPages) PULONG_PTR PageArray,
    __in    DWORD nndPreferred
    );

#endif // _WIN32_WINNT >= 0x0600

WINBASEAPI
BOOL
WINAPI
FreeUserPhysicalPages(
    __in    HANDLE hProcess,
    __inout PULONG_PTR NumberOfPages,
    __in_ecount(*NumberOfPages) PULONG_PTR PageArray
    );

WINBASEAPI
BOOL
WINAPI
MapUserPhysicalPages(
    __in PVOID VirtualAddress,
    __in ULONG_PTR NumberOfPages,
    __in_ecount_opt(NumberOfPages) PULONG_PTR PageArray
    );

WINBASEAPI
BOOL
WINAPI
MapUserPhysicalPagesScatter(
    __in_ecount(NumberOfPages) PVOID *VirtualAddresses,
    __in ULONG_PTR NumberOfPages,
    __in_ecount_opt(NumberOfPages) PULONG_PTR PageArray
    );

WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateJobObjectA(
    __in_opt LPSECURITY_ATTRIBUTES lpJobAttributes,
    __in_opt LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
CreateJobObjectW(
    __in_opt LPSECURITY_ATTRIBUTES lpJobAttributes,
    __in_opt LPCWSTR lpName
    );
#ifdef UNICODE
#define CreateJobObject  CreateJobObjectW
#else
#define CreateJobObject  CreateJobObjectA
#endif // !UNICODE

WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenJobObjectA(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCSTR lpName
    );
WINBASEAPI
__out_opt
HANDLE
WINAPI
OpenJobObjectW(
    __in DWORD dwDesiredAccess,
    __in BOOL bInheritHandle,
    __in LPCWSTR lpName
    );
#ifdef UNICODE
#define OpenJobObject  OpenJobObjectW
#else
#define OpenJobObject  OpenJobObjectA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
AssignProcessToJobObject(
    __in HANDLE hJob,
    __in HANDLE hProcess
    );

WINBASEAPI
BOOL
WINAPI
TerminateJobObject(
    __in HANDLE hJob,
    __in UINT uExitCode
    );

WINBASEAPI
BOOL
WINAPI
QueryInformationJobObject(
    __in_opt  HANDLE hJob,
    __in      JOBOBJECTINFOCLASS JobObjectInformationClass,
    __out_bcount_part(cbJobObjectInformationLength, *lpReturnLength) LPVOID lpJobObjectInformation,
    __in      DWORD cbJobObjectInformationLength,
    __out_opt LPDWORD lpReturnLength
    );

WINBASEAPI
BOOL
WINAPI
SetInformationJobObject(
    __in HANDLE hJob,
    __in JOBOBJECTINFOCLASS JobObjectInformationClass,
    __in_bcount(cbJobObjectInformationLength) LPVOID lpJobObjectInformation,
    __in DWORD cbJobObjectInformationLength
    );

#if (_WIN32_WINNT >= 0x0501)

WINBASEAPI
BOOL
WINAPI
IsProcessInJob (
    __in     HANDLE ProcessHandle,
    __in_opt HANDLE JobHandle,
    __out    PBOOL Result
    );

#endif

WINBASEAPI
BOOL
WINAPI
CreateJobSet (
    __in ULONG NumJob,
    __in_ecount(NumJob) PJOB_SET_ARRAY UserJobSet,
    __in ULONG Flags);

WINBASEAPI
__out_opt
PVOID
WINAPI
AddVectoredExceptionHandler (
    __in ULONG First,
    __in PVECTORED_EXCEPTION_HANDLER Handler
    );

WINBASEAPI
ULONG
WINAPI
RemoveVectoredExceptionHandler (
    __in PVOID Handle
    );

WINBASEAPI
__out_opt
PVOID
WINAPI
AddVectoredContinueHandler (
    __in ULONG First,
    __in PVECTORED_EXCEPTION_HANDLER Handler
    );

WINBASEAPI
ULONG
WINAPI
RemoveVectoredContinueHandler (
    __in PVOID Handle
    );

//
// New Volume Mount Point API.
//

WINBASEAPI
__out
HANDLE
WINAPI
FindFirstVolumeA(
    __out_ecount(cchBufferLength) LPSTR lpszVolumeName,
    __in DWORD cchBufferLength
    );
WINBASEAPI
__out
HANDLE
WINAPI
FindFirstVolumeW(
    __out_ecount(cchBufferLength) LPWSTR lpszVolumeName,
    __in DWORD cchBufferLength
    );
#ifdef UNICODE
#define FindFirstVolume FindFirstVolumeW
#else
#define FindFirstVolume FindFirstVolumeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextVolumeA(
    __inout HANDLE hFindVolume,
    __out_ecount(cchBufferLength) LPSTR lpszVolumeName,
    __in    DWORD cchBufferLength
    );
WINBASEAPI
BOOL
WINAPI
FindNextVolumeW(
    __inout HANDLE hFindVolume,
    __out_ecount(cchBufferLength) LPWSTR lpszVolumeName,
    __in    DWORD cchBufferLength
    );
#ifdef UNICODE
#define FindNextVolume FindNextVolumeW
#else
#define FindNextVolume FindNextVolumeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindVolumeClose(
    __in HANDLE hFindVolume
    );

WINBASEAPI
__out
HANDLE
WINAPI
FindFirstVolumeMountPointA(
    __in LPCSTR lpszRootPathName,
    __out_ecount(cchBufferLength) LPSTR lpszVolumeMountPoint,
    __in DWORD cchBufferLength
    );
WINBASEAPI
__out
HANDLE
WINAPI
FindFirstVolumeMountPointW(
    __in LPCWSTR lpszRootPathName,
    __out_ecount(cchBufferLength) LPWSTR lpszVolumeMountPoint,
    __in DWORD cchBufferLength
    );
#ifdef UNICODE
#define FindFirstVolumeMountPoint FindFirstVolumeMountPointW
#else
#define FindFirstVolumeMountPoint FindFirstVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextVolumeMountPointA(
    __in HANDLE hFindVolumeMountPoint,
    __out_ecount(cchBufferLength) LPSTR lpszVolumeMountPoint,
    __in DWORD cchBufferLength
    );
WINBASEAPI
BOOL
WINAPI
FindNextVolumeMountPointW(
    __in HANDLE hFindVolumeMountPoint,
    __out_ecount(cchBufferLength) LPWSTR lpszVolumeMountPoint,
    __in DWORD cchBufferLength
    );
#ifdef UNICODE
#define FindNextVolumeMountPoint FindNextVolumeMountPointW
#else
#define FindNextVolumeMountPoint FindNextVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindVolumeMountPointClose(
    __in HANDLE hFindVolumeMountPoint
    );

WINBASEAPI
BOOL
WINAPI
SetVolumeMountPointA(
    __in LPCSTR lpszVolumeMountPoint,
    __in LPCSTR lpszVolumeName
    );
WINBASEAPI
BOOL
WINAPI
SetVolumeMountPointW(
    __in LPCWSTR lpszVolumeMountPoint,
    __in LPCWSTR lpszVolumeName
    );
#ifdef UNICODE
#define SetVolumeMountPoint  SetVolumeMountPointW
#else
#define SetVolumeMountPoint  SetVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
DeleteVolumeMountPointA(
    __in LPCSTR lpszVolumeMountPoint
    );
WINBASEAPI
BOOL
WINAPI
DeleteVolumeMountPointW(
    __in LPCWSTR lpszVolumeMountPoint
    );
#ifdef UNICODE
#define DeleteVolumeMountPoint  DeleteVolumeMountPointW
#else
#define DeleteVolumeMountPoint  DeleteVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetVolumeNameForVolumeMountPointA(
    __in LPCSTR lpszVolumeMountPoint,
    __out_ecount(cchBufferLength) LPSTR lpszVolumeName,
    __in DWORD cchBufferLength
    );
WINBASEAPI
BOOL
WINAPI
GetVolumeNameForVolumeMountPointW(
    __in LPCWSTR lpszVolumeMountPoint,
    __out_ecount(cchBufferLength) LPWSTR lpszVolumeName,
    __in DWORD cchBufferLength
    );
#ifdef UNICODE
#define GetVolumeNameForVolumeMountPoint  GetVolumeNameForVolumeMountPointW
#else
#define GetVolumeNameForVolumeMountPoint  GetVolumeNameForVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetVolumePathNameA(
    __in LPCSTR lpszFileName,
    __out_ecount(cchBufferLength) LPSTR lpszVolumePathName,
    __in DWORD cchBufferLength
    );
WINBASEAPI
BOOL
WINAPI
GetVolumePathNameW(
    __in LPCWSTR lpszFileName,
    __out_ecount(cchBufferLength) LPWSTR lpszVolumePathName,
    __in DWORD cchBufferLength
    );
#ifdef UNICODE
#define GetVolumePathName  GetVolumePathNameW
#else
#define GetVolumePathName  GetVolumePathNameA
#endif // !UNICODE

#endif

#if(_WIN32_WINNT >= 0x0501)

WINBASEAPI
BOOL
WINAPI
GetVolumePathNamesForVolumeNameA(
    __in  LPCSTR lpszVolumeName,
    __out_ecount_part_opt(cchBufferLength, *lpcchReturnLength) __nullnullterminated LPCH lpszVolumePathNames,
    __in  DWORD cchBufferLength,
    __out PDWORD lpcchReturnLength
    );
WINBASEAPI
BOOL
WINAPI
GetVolumePathNamesForVolumeNameW(
    __in  LPCWSTR lpszVolumeName,
    __out_ecount_part_opt(cchBufferLength, *lpcchReturnLength) __nullnullterminated LPWCH lpszVolumePathNames,
    __in  DWORD cchBufferLength,
    __out PDWORD lpcchReturnLength
    );
#ifdef UNICODE
#define GetVolumePathNamesForVolumeName  GetVolumePathNamesForVolumeNameW
#else
#define GetVolumePathNamesForVolumeName  GetVolumePathNamesForVolumeNameA
#endif // !UNICODE

#endif // (_WIN32_WINNT >= 0x0501)

#if (_WIN32_WINNT >= 0x0500) || (_WIN32_FUSION >= 0x0100) || ISOLATION_AWARE_ENABLED

#define ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID    (0x00000001)
#define ACTCTX_FLAG_LANGID_VALID                    (0x00000002)
#define ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID        (0x00000004)
#define ACTCTX_FLAG_RESOURCE_NAME_VALID             (0x00000008)
#define ACTCTX_FLAG_SET_PROCESS_DEFAULT             (0x00000010)
#define ACTCTX_FLAG_APPLICATION_NAME_VALID          (0x00000020)
#define ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF           (0x00000040)
#define ACTCTX_FLAG_HMODULE_VALID                   (0x00000080)

typedef struct tagACTCTXA {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCSTR      lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCSTR      lpAssemblyDirectory;
    LPCSTR      lpResourceName;
    LPCSTR      lpApplicationName;
    HMODULE     hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCWSTR     lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCWSTR     lpAssemblyDirectory;
    LPCWSTR     lpResourceName;
    LPCWSTR     lpApplicationName;
    HMODULE     hModule;
} ACTCTXW, *PACTCTXW;
#ifdef UNICODE
typedef ACTCTXW ACTCTX;
typedef PACTCTXW PACTCTX;
#else
typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;
#endif // UNICODE

typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;
#ifdef UNICODE
typedef PCACTCTXW PCACTCTX;
#else
typedef PCACTCTXA PCACTCTX;
#endif // UNICODE



WINBASEAPI
__out
HANDLE
WINAPI
CreateActCtxA(
    __in PCACTCTXA pActCtx
    );
WINBASEAPI
__out
HANDLE
WINAPI
CreateActCtxW(
    __in PCACTCTXW pActCtx
    );
#ifdef UNICODE
#define CreateActCtx  CreateActCtxW
#else
#define CreateActCtx  CreateActCtxA
#endif // !UNICODE

WINBASEAPI
VOID
WINAPI
AddRefActCtx(
    __inout HANDLE hActCtx
    );


WINBASEAPI
VOID
WINAPI
ReleaseActCtx(
    __inout HANDLE hActCtx
    );

WINBASEAPI
BOOL
WINAPI
ZombifyActCtx(
    __inout HANDLE hActCtx
    );


WINBASEAPI
BOOL
WINAPI
ActivateActCtx(
    __inout_opt HANDLE hActCtx,
    __out   ULONG_PTR *lpCookie
    );


#define DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION (0x00000001)

WINBASEAPI
BOOL
WINAPI
DeactivateActCtx(
    __in DWORD dwFlags,
    __in ULONG_PTR ulCookie
    );

WINBASEAPI
BOOL
WINAPI
GetCurrentActCtx(
    __deref_out HANDLE *lphActCtx);


typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
// 2600 stops here
    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;

#define FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX (0x00000001)
#define FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS   (0x00000002)
#define FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA (0x00000004)



WINBASEAPI
BOOL
WINAPI
FindActCtxSectionStringA(
    __in       DWORD dwFlags,
    __reserved const GUID *lpExtensionGuid,
    __in       ULONG ulSectionId,
    __in       LPCSTR lpStringToFind,
    __out      PACTCTX_SECTION_KEYED_DATA ReturnedData
    );
WINBASEAPI
BOOL
WINAPI
FindActCtxSectionStringW(
    __in       DWORD dwFlags,
    __reserved const GUID *lpExtensionGuid,
    __in       ULONG ulSectionId,
    __in       LPCWSTR lpStringToFind,
    __out      PACTCTX_SECTION_KEYED_DATA ReturnedData
    );
#ifdef UNICODE
#define FindActCtxSectionString  FindActCtxSectionStringW
#else
#define FindActCtxSectionString  FindActCtxSectionStringA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindActCtxSectionGuid(
    __in       DWORD dwFlags,
    __reserved const GUID *lpExtensionGuid,
    __in       ULONG ulSectionId,
    __in_opt   const GUID *lpGuidToFind,
    __out      PACTCTX_SECTION_KEYED_DATA ReturnedData
    );


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if !defined(ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED)

typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE  hActCtx;
    DWORD   dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;

#define ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED 1

#endif // !defined(ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED)
#endif

#define QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX (0x00000004)
#define QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE (0x00000008)
#define QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS (0x00000010)
#define QUERY_ACTCTX_FLAG_NO_ADDREF         (0x80000000)



//
// switch (ulInfoClass)
//
//  case ActivationContextBasicInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_BASIC_INFORMATION
//
//  case ActivationContextDetailedInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_DETAILED_INFORMATION
//
//  case AssemblyDetailedInformationInActivationContext:
//    pvSubInstance is of type PULONG
//      *pvSubInstance < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//    pvBuffer is of type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
//
//  case FileInformationInAssemblyOfAssemblyInActivationContext:
//    pvSubInstance is of type PACTIVATION_CONTEXT_QUERY_INDEX
//      pvSubInstance->ulAssemblyIndex < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//      pvSubInstance->ulFileIndexInAssembly < ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION::ulFileCount
//    pvBuffer is of type PASSEMBLY_FILE_DETAILED_INFORMATION
//
//  case RunlevelInformationInActivationContext :
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
//
// String are placed after the structs.
//
WINBASEAPI
BOOL
WINAPI
QueryActCtxW(
    __in      DWORD dwFlags,
    __in      HANDLE hActCtx,
    __in_opt  PVOID pvSubInstance,
    __in      ULONG ulInfoClass,
    __out_bcount_part_opt(cbBuffer, *pcbWrittenOrRequired) PVOID pvBuffer,
    __in      SIZE_T cbBuffer,
    __out_opt SIZE_T *pcbWrittenOrRequired
    );

typedef BOOL (WINAPI * PQUERYACTCTXW_FUNC)(
    __in      DWORD dwFlags,
    __in      HANDLE hActCtx,
    __in_opt  PVOID pvSubInstance,
    __in      ULONG ulInfoClass,
    __out_bcount_part_opt(cbBuffer, *pcbWrittenOrRequired) PVOID pvBuffer,
    __in      SIZE_T cbBuffer,
    __out_opt SIZE_T *pcbWrittenOrRequired
    );

#endif // (_WIN32_WINNT > 0x0500) || (_WIN32_FUSION >= 0x0100) || ISOLATION_AWARE_ENABLED


WINBASEAPI
BOOL
WINAPI
ProcessIdToSessionId(
    __in  DWORD dwProcessId,
    __out DWORD *pSessionId
    );

#if _WIN32_WINNT >= 0x0501

WINBASEAPI
DWORD
WINAPI
WTSGetActiveConsoleSessionId(
    VOID
    );

WINBASEAPI
BOOL
WINAPI
IsWow64Process(
    __in  HANDLE hProcess,
    __out PBOOL Wow64Process
    );

#endif // (_WIN32_WINNT >= 0x0501)

WINBASEAPI
BOOL
WINAPI
GetLogicalProcessorInformation(
    __out_bcount_part_opt(*ReturnedLength, *ReturnedLength) PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
    __inout PDWORD ReturnedLength
    );

#if _WIN32_WINNT >= 0x0601

WINBASEAPI
BOOL
WINAPI
GetLogicalProcessorInformationEx(
    __in LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
    __out_bcount_part_opt(*ReturnedLength, *ReturnedLength) PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
    __inout PDWORD ReturnedLength
    );

WINBASEAPI
WORD
WINAPI
GetActiveProcessorGroupCount(
    VOID
    );

WINBASEAPI
WORD
WINAPI
GetMaximumProcessorGroupCount(
    VOID
    );

WINBASEAPI
DWORD
WINAPI
GetActiveProcessorCount(
    __in WORD GroupNumber
    );

WINBASEAPI
DWORD
WINAPI
GetMaximumProcessorCount(
    __in WORD GroupNumber
    );

#endif // (_WIN32_WINNT >=0x0601)

//
// NUMA Information routines.
//

WINBASEAPI
BOOL
WINAPI
GetNumaHighestNodeNumber(
    __out PULONG HighestNodeNumber
    );

WINBASEAPI
BOOL
WINAPI
GetNumaProcessorNode(
    __in  UCHAR Processor,
    __out PUCHAR NodeNumber
    );

#if _WIN32_WINNT >= 0x0601

WINBASEAPI
BOOL
WINAPI
GetNumaNodeNumberFromHandle(
    __in  HANDLE hFile,
    __out PUSHORT NodeNumber
    );

#endif // (_WIN32_WINNT >=0x0601)

#if _WIN32_WINNT >= 0x0601

WINBASEAPI
BOOL
WINAPI
GetNumaProcessorNodeEx(
    __in  PPROCESSOR_NUMBER Processor,
    __out PUSHORT NodeNumber
    );

#endif // (_WIN32_WINNT >=0x0601)

WINBASEAPI
BOOL
WINAPI
GetNumaNodeProcessorMask(
    __in  UCHAR Node,
    __out PULONGLONG ProcessorMask
    );

#if _WIN32_WINNT >= 0x0601

WINBASEAPI
BOOL
WINAPI
GetNumaNodeProcessorMaskEx(
    __in  USHORT Node,
    __out PGROUP_AFFINITY ProcessorMask
    );

#endif // (_WIN32_WINNT >=0x0601)

WINBASEAPI
BOOL
WINAPI
GetNumaAvailableMemoryNode(
    __in  UCHAR Node,
    __out PULONGLONG AvailableBytes
    );

#if _WIN32_WINNT >= 0x0601

WINBASEAPI
BOOL
WINAPI
GetNumaAvailableMemoryNodeEx(
    __in  USHORT Node,
    __out PULONGLONG AvailableBytes
    );

#endif // (_WIN32_WINNT >=0x0601)

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
BOOL
WINAPI
GetNumaProximityNode(
    __in  ULONG ProximityId,
    __out PUCHAR NodeNumber
    );

#endif

#if _WIN32_WINNT >= 0x0601

WINBASEAPI
BOOL
WINAPI
GetNumaProximityNodeEx(
    __in  ULONG ProximityId,
    __out PUSHORT NodeNumber
    );

#endif // (_WIN32_WINNT >=0x0601)

//
// Application restart and data recovery callback
//
typedef DWORD (WINAPI *APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);

//
// Max length of commandline in characters (including the NULL character that can be registered for restart)
//
#define RESTART_MAX_CMD_LINE    1024

//
// Do not restart the process for termination due to application crashes
//
#define RESTART_NO_CRASH        1

//
// Do not restart the process for termination due to application hangs
//
#define RESTART_NO_HANG         2

//
// Do not restart the process for termination due to patch installations
//
#define RESTART_NO_PATCH        4

//
// Do not restart the process when the system is rebooted due to patch installations
//
#define RESTART_NO_REBOOT        8

WINBASEAPI
HRESULT
WINAPI
RegisterApplicationRecoveryCallback(
    __in  APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
    __in_opt  PVOID pvParameter,
    __in DWORD dwPingInterval,
    __in DWORD dwFlags
    );

WINBASEAPI
HRESULT
WINAPI
UnregisterApplicationRecoveryCallback(void);

WINBASEAPI
HRESULT
WINAPI
RegisterApplicationRestart(
    __in_opt PCWSTR pwzCommandline,
    __in DWORD dwFlags
    );

WINBASEAPI
HRESULT
WINAPI
UnregisterApplicationRestart(void);

#define RECOVERY_DEFAULT_PING_INTERVAL  5000
#define RECOVERY_MAX_PING_INTERVAL      (5 * 60 * 1000)

WINBASEAPI
HRESULT
WINAPI
GetApplicationRecoveryCallback(
    __in  HANDLE hProcess,
    __out APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
    __deref_opt_out_opt PVOID* ppvParameter,
    __out_opt PDWORD pdwPingInterval,
    __out_opt PDWORD pdwFlags
    );

WINBASEAPI
HRESULT
WINAPI
GetApplicationRestartSettings(
    __in HANDLE hProcess,
    __out_ecount_opt(*pcchSize) PWSTR pwzCommandline,
    __inout PDWORD pcchSize,
    __out_opt PDWORD pdwFlags
    );

WINBASEAPI
HRESULT
WINAPI
ApplicationRecoveryInProgress(
    __out PBOOL pbCancelled
    );

WINBASEAPI
VOID
WINAPI
ApplicationRecoveryFinished(
    __in BOOL bSuccess
    );

#if (_WIN32_WINNT >= 0x0600)
typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo, 
    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;

typedef struct _FILE_BASIC_INFO {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    DWORD FileAttributes;
} FILE_BASIC_INFO, *PFILE_BASIC_INFO;

typedef struct _FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORD NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;

typedef struct _FILE_NAME_INFO {
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFO, *PFILE_NAME_INFO;

typedef struct _FILE_RENAME_INFO {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;

typedef struct _FILE_ALLOCATION_INFO {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;

typedef struct _FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;

typedef struct _FILE_STREAM_INFO {
    DWORD NextEntryOffset;
    DWORD StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFO, *PFILE_STREAM_INFO;

typedef struct _FILE_COMPRESSION_INFO {
    LARGE_INTEGER CompressedFileSize;
    WORD CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;

typedef struct _FILE_ATTRIBUTE_TAG_INFO {
    DWORD FileAttributes;
    DWORD ReparseTag;
} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;

typedef struct _FILE_DISPOSITION_INFO {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;

typedef struct _FILE_ID_BOTH_DIR_INFO {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    DWORD FileAttributes;
    DWORD FileNameLength;
    DWORD EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;

typedef enum _PRIORITY_HINT {
      IoPriorityHintVeryLow = 0,
      IoPriorityHintLow,
      IoPriorityHintNormal,
      MaximumIoPriorityHintType
} PRIORITY_HINT;

typedef struct _FILE_IO_PRIORITY_HINT_INFO {
    PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;

// Structure and constants must match those in ntioapi_x.w

#define REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK       0x00000001
#define REMOTE_PROTOCOL_INFO_FLAG_OFFLINE        0x00000002

typedef struct _FILE_REMOTE_PROTOCOL_INFO
{
    // Structure Version
    USHORT StructureVersion;     // 1
    USHORT StructureSize;        // sizeof(FILE_REMOTE_PROTOCOL_INFO)
    
    DWORD  Protocol;             // Protocol (WNNC_NET_*) defined in wnnc.h or ntifs.h.
    
    // Protocol Version & Type
    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;
    
    USHORT Reserved;
    
    // Protocol-Generic Information
    DWORD  Flags;
    
    struct {
        DWORD Reserved[8];
    } GenericReserved;

    // Protocol specific information
    
    struct {
        DWORD Reserved[16];
    } ProtocolSpecificReserved;
    
} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;


WINBASEAPI
BOOL
WINAPI
SetFileInformationByHandle(
    __in  HANDLE hFile,
    __in  FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
    __in_bcount(dwBufferSize)  LPVOID lpFileInformation,
    __in  DWORD dwBufferSize
);

WINBASEAPI
BOOL
WINAPI
GetFileInformationByHandleEx(
    __in  HANDLE hFile,
    __in  FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
    __out_bcount(dwBufferSize) LPVOID lpFileInformation,
    __in  DWORD dwBufferSize
);

typedef enum _FILE_ID_TYPE {
      FileIdType,
      ObjectIdType,
      MaximumFileIdType
} FILE_ID_TYPE, *PFILE_ID_TYPE;

typedef struct FILE_ID_DESCRIPTOR {
    DWORD dwSize;  // Size of the struct
    FILE_ID_TYPE Type; // Describes the type of identifier passed in.
    union {
        LARGE_INTEGER FileId;
        GUID ObjectId;
    } DUMMYUNIONNAME;
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;

WINBASEAPI
__out
HANDLE
WINAPI
OpenFileById (
    __in     HANDLE hVolumeHint,
    __in     LPFILE_ID_DESCRIPTOR lpFileId,
    __in     DWORD dwDesiredAccess,
    __in     DWORD dwShareMode,
    __in_opt LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    __in     DWORD dwFlagsAndAttributes
    );
#endif

#if (_WIN32_WINNT >= 0x0600)

//
//  Flags to be passed into CREATE_SYMBOLIC_LINK
//

#define SYMBOLIC_LINK_FLAG_DIRECTORY            (0x1)

#define VALID_SYMBOLIC_LINK_FLAGS  SYMBOLIC_LINK_FLAG_DIRECTORY // & whatever other flags we think of!

WINBASEAPI
BOOLEAN
APIENTRY
CreateSymbolicLinkA (
    __in LPCSTR lpSymlinkFileName,
    __in LPCSTR lpTargetFileName,
    __in DWORD dwFlags
    );
WINBASEAPI
BOOLEAN
APIENTRY
CreateSymbolicLinkW (
    __in LPCWSTR lpSymlinkFileName,
    __in LPCWSTR lpTargetFileName,
    __in DWORD dwFlags
    );
#ifdef UNICODE
#define CreateSymbolicLink  CreateSymbolicLinkW
#else
#define CreateSymbolicLink  CreateSymbolicLinkA
#endif // !UNICODE

WINBASEAPI
BOOLEAN
APIENTRY
CreateSymbolicLinkTransactedA (
    __in     LPCSTR lpSymlinkFileName,
    __in     LPCSTR lpTargetFileName,
    __in     DWORD dwFlags,
    __in     HANDLE hTransaction
    );
WINBASEAPI
BOOLEAN
APIENTRY
CreateSymbolicLinkTransactedW (
    __in     LPCWSTR lpSymlinkFileName,
    __in     LPCWSTR lpTargetFileName,
    __in     DWORD dwFlags,
    __in     HANDLE hTransaction
    );
#ifdef UNICODE
#define CreateSymbolicLinkTransacted  CreateSymbolicLinkTransactedW
#else
#define CreateSymbolicLinkTransacted  CreateSymbolicLinkTransactedA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetFinalPathNameByHandleA (
    __in HANDLE hFile,
    __out_ecount(cchFilePath) LPSTR lpszFilePath,
    __in DWORD cchFilePath,
    __in DWORD dwFlags
);
WINBASEAPI
DWORD
WINAPI
GetFinalPathNameByHandleW (
    __in HANDLE hFile,
    __out_ecount(cchFilePath) LPWSTR lpszFilePath,
    __in DWORD cchFilePath,
    __in DWORD dwFlags
);
#ifdef UNICODE
#define GetFinalPathNameByHandle  GetFinalPathNameByHandleW
#else
#define GetFinalPathNameByHandle  GetFinalPathNameByHandleA
#endif // !UNICODE

#endif // (_WIN32_WINNT >= 0x0600)


#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
BOOL
WINAPI
QueryActCtxSettingsW(
    __in_opt      DWORD dwFlags,
    __in_opt      HANDLE hActCtx,
    __in_opt      PCWSTR settingsNameSpace,
    __in          PCWSTR settingName,
    __out_bcount_part_opt(dwBuffer, *pdwWrittenOrRequired) PWSTR pvBuffer,
    __in      SIZE_T dwBuffer,
    __out_opt SIZE_T *pdwWrittenOrRequired
    );

#endif

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
BOOL
WINAPI
ReplacePartitionUnit (
    __in PWSTR TargetPartition,
    __in PWSTR SparePartition,
    __in ULONG Flags
    );

#endif


#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI
BOOL
WINAPI
AddSecureMemoryCacheCallback(
    __in __callback PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

WINBASEAPI
BOOL
WINAPI
RemoveSecureMemoryCacheCallback(
    __in __callback PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

#endif

#if (_WIN32_WINNT >= 0x0601)

__checkReturn
WINBASEAPI
BOOL
WINAPI
CopyExtendedContext(
    __out PCONTEXT_EX Destination,
    __in DWORD ContextFlags,
    __in PCONTEXT_EX Source
    );

__checkReturn
WINBASEAPI
BOOL
WINAPI
InitializeExtendedContext(
    __out PVOID Context,
    __in DWORD ContextFlags,
    __out PCONTEXT_EX* ContextEx
    );

WINBASEAPI
DWORD64
WINAPI
GetEnabledExtendedFeatures(
    __in DWORD64 FeatureMask
    );


WINBASEAPI
BOOL
WINAPI
GetExtendedContextLength(
    __in DWORD ContextFlags,
    __out PDWORD ContextLength
    );

WINBASEAPI
DWORD64
WINAPI
GetExtendedFeaturesMask(
    __in PCONTEXT_EX ContextEx
    );

WINBASEAPI
PVOID
WINAPI
LocateExtendedFeature(
    __in PCONTEXT_EX ContextEx,
    __in DWORD FeatureId,
    __out_opt PDWORD Length
    );

WINBASEAPI
PCONTEXT
WINAPI
LocateLegacyContext(
    __in PCONTEXT_EX ContextEx,
    __out_opt PDWORD Length
    );

WINBASEAPI
VOID
WINAPI
SetExtendedFeaturesMask(
    __out PCONTEXT_EX ContextEx,
    __in DWORD64 FeatureMask
    );

WINBASEAPI
DWORD
APIENTRY
EnableThreadProfiling(
    __in HANDLE ThreadHandle,
    __in DWORD Flags,
    __in DWORD64 HardwareCounters,
    __out HANDLE *PerformanceDataHandle
    );

WINBASEAPI
DWORD
APIENTRY
DisableThreadProfiling(
    __in HANDLE PerformanceDataHandle
    );

WINBASEAPI
DWORD
APIENTRY
QueryThreadProfiling(
    __in HANDLE ThreadHandle,
    __out PBOOLEAN Enabled
    );

WINBASEAPI
DWORD
APIENTRY
ReadThreadProfilingData(
    __in HANDLE PerformanceDataHandle,
    __in DWORD Flags,
    __out PPERFORMANCE_DATA PerformanceData
    );

#endif



#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
#include "winbase.inl"
#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */

#ifdef __cplusplus
}
#endif



#endif // _WINBASE_

#if !defined(RC_INVOKED)
#if !defined(NOWINBASEINTERLOCK)
#if !defined(_NTOS_)
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winbase_interlockedcplusplus.h

Abstract:

    C++ function overloads in place of "manual name mangling".
    This file is meant to be #included by winbase.h or any other file declaring the signed interlocked functions.

Author:

    Jay Krell (JayKrell) April 2002

--*/

#if !defined(RC_INVOKED) /* { */

#if !defined(MICROSOFT_WINDOWS_WINBASE_INTERLOCKED_CPLUSPLUS_H_INCLUDED) /* { */
#define MICROSOFT_WINDOWS_WINBASE_INTERLOCKED_CPLUSPLUS_H_INCLUDED
#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(MIDL_PASS) /* { */

/*
To turn off/hide the contents of this file:
 #define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
*/

#if !defined(MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS)
#define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS (_WIN32_WINNT >= 0x0502 || !defined(_WINBASE_))
#endif

#if MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS  /* { */

#if defined(__cplusplus) /* { */

extern "C++" {

FORCEINLINE
unsigned
InterlockedIncrement(
    __inout __drv_interlocked unsigned volatile *Addend
    )
{
    return (unsigned) InterlockedIncrement((volatile long*) Addend);
}

FORCEINLINE
unsigned long
InterlockedIncrement(
    __inout __drv_interlocked unsigned long volatile *Addend
    )
{
    return (unsigned long) InterlockedIncrement((volatile long*) Addend);
}

#if defined(_WIN64) || ((_WIN32_WINNT >= 0x0502) && defined(_WINBASE_))

FORCEINLINE
unsigned __int64
InterlockedIncrement(
    __inout __drv_interlocked unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) InterlockedIncrement64((volatile __int64*) Addend);
}

#endif

FORCEINLINE
unsigned
InterlockedDecrement(
    __inout __drv_interlocked unsigned volatile *Addend
    )
{
    return (unsigned long) InterlockedDecrement((volatile long*) Addend);
}

FORCEINLINE
unsigned long
InterlockedDecrement(
    __inout __drv_interlocked unsigned long volatile *Addend
    )
{
    return (unsigned long) InterlockedDecrement((volatile long*) Addend);
}

#if defined(_WIN64) || ((_WIN32_WINNT >= 0x0502) && defined(_WINBASE_))

FORCEINLINE
unsigned __int64
InterlockedDecrement(
    __inout __drv_interlocked unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) InterlockedDecrement64((volatile __int64*) Addend);
}

#endif

FORCEINLINE
unsigned
InterlockedExchange(
    __inout __drv_interlocked unsigned volatile *Target,
    __in unsigned Value
    )
{
    return (unsigned) InterlockedExchange((volatile long*) Target, (long) Value);
}

FORCEINLINE
unsigned long
InterlockedExchange(
    __inout __drv_interlocked unsigned long volatile *Target,
    __in unsigned long Value
    )
{
    return (unsigned long) InterlockedExchange((volatile long*) Target, (long) Value);
}

#if defined(_WIN64) || ((_WIN32_WINNT >= 0x0502) && defined(_WINBASE_))

FORCEINLINE
unsigned __int64
InterlockedExchange(
    __inout __drv_interlocked unsigned __int64 volatile *Target,
    __in unsigned __int64 Value
    )
{
    return (unsigned __int64) InterlockedExchange64((volatile __int64*) Target, (__int64) Value);
}

#endif

FORCEINLINE
unsigned
InterlockedExchangeAdd(
    __inout __drv_interlocked unsigned volatile *Addend,
    __in unsigned Value
    )
{
    return (unsigned) InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

FORCEINLINE
unsigned
InterlockedExchangeSubtract(
    __inout __drv_interlocked unsigned volatile *Addend,
    __in unsigned Value
    )
{
    return (unsigned) InterlockedExchangeAdd((volatile long*) Addend,  - (long) Value);
}

FORCEINLINE
unsigned long
InterlockedExchangeAdd(
    __inout __drv_interlocked unsigned long volatile *Addend,
    __in unsigned long Value
    )
{
    return (unsigned long) InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

FORCEINLINE
unsigned long
InterlockedExchangeSubtract(
    __inout __drv_interlocked unsigned long volatile *Addend,
    __in unsigned long Value
    )
{
    return (unsigned long) InterlockedExchangeAdd((volatile long*) Addend,  - (long) Value);
}

#if defined(_WIN64) || ((_WIN32_WINNT >= 0x0502) && defined(_WINBASE_))

FORCEINLINE
unsigned __int64
InterlockedExchangeAdd(
    __inout __drv_interlocked unsigned __int64 volatile *Addend,
    __in unsigned __int64 Value
    )
{
    return (unsigned __int64) InterlockedExchangeAdd64((volatile __int64*) Addend,  (__int64) Value);
}

FORCEINLINE
unsigned __int64
InterlockedExchangeSubtract(
    __inout __drv_interlocked unsigned __int64 volatile *Addend,
    __in unsigned __int64 Value
    )
{
    return (unsigned __int64) InterlockedExchangeAdd64((volatile __int64*) Addend,  - (__int64) Value);
}

#endif

FORCEINLINE
unsigned
InterlockedCompareExchange(
    __inout __drv_interlocked unsigned volatile *Destination,
    __in unsigned Exchange,
    __in unsigned Comperand
    )
{
    return (unsigned) InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}

FORCEINLINE
unsigned long
InterlockedCompareExchange(
    __inout __drv_interlocked unsigned long volatile *Destination,
    __in unsigned long Exchange,
    __in unsigned long Comperand
    )
{
    return (unsigned long) InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}

#if defined(_WIN64) || ((_WIN32_WINNT >= 0x0502) && defined(_WINBASE_))

FORCEINLINE
unsigned __int64
InterlockedCompareExchange(
    __inout __drv_interlocked unsigned __int64 volatile *Destination,
    __in unsigned __int64 Exchange,
    __in unsigned __int64 Comperand
    )
{
    return (unsigned __int64) InterlockedCompareExchange64((volatile __int64*) Destination, (__int64) Exchange, (__int64) Comperand);
}

FORCEINLINE
unsigned __int64
InterlockedAnd(
    __inout __drv_interlocked unsigned __int64 volatile *Destination,
    __in unsigned __int64 Value
    )
{
    return (unsigned __int64) InterlockedAnd64((volatile __int64*) Destination, (__int64) Value);
}

FORCEINLINE
unsigned __int64
InterlockedOr(
    __inout __drv_interlocked unsigned __int64 volatile *Destination,
    __in unsigned __int64 Value
    )
{
    return (unsigned __int64) InterlockedOr64((volatile __int64*) Destination, (__int64) Value);
}

FORCEINLINE
unsigned __int64
InterlockedXor(
    __inout __drv_interlocked unsigned __int64 volatile *Destination,
    __in unsigned __int64 Value
    )
{
    return (unsigned __int64) InterlockedXor64((volatile __int64*) Destination, (__int64) Value);
}

#endif

} /* extern "C++" */
#endif /* } __cplusplus */

#endif /* } MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS */

#undef MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS
#define MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0

#endif /* } MIDL_PASS */
#endif /* } MICROSOFT_WINDOWS_WINBASE_INTERLOCKED_CPLUSPLUS_H_INCLUDED */
#endif /* } RC_INVOKED */
#endif /* _NTOS_ */
#endif /* NOWINBASEINTERLOCK */
#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinBio.h ===
/*++

Copyright (c) 2007 Microsoft Corporation


Module Name:

    winbio.h

Abstract:

    WinBio public API.


Environment:

    User mode only.

Revision History:

--*/

#ifndef _WINBIO_H_9B9AD1F6_97B1_4647_923D_583FD7428C4C_
#define _WINBIO_H_9B9AD1F6_97B1_4647_923D_583FD7428C4C_

#if (NTDDI_VERSION >= NTDDI_WIN7)

//
// Dependencies...
//
#include "winbio_types.h"
#include "winbio_err.h"

#ifdef __cplusplus
extern "C"{
#endif


///////////////////////////////////////////////////////////////////////////////
//
// Capability discovery
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioEnumServiceProviders(
    __in WINBIO_BIOMETRIC_TYPE Factor,
    __deref_out_ecount(*BspCount) WINBIO_BSP_SCHEMA **BspSchemaArray,
    __out SIZE_T *BspCount
    );

HRESULT WINAPI
WinBioEnumBiometricUnits(
    __in WINBIO_BIOMETRIC_TYPE Factor,
    __deref_out_ecount(*UnitCount) WINBIO_UNIT_SCHEMA **UnitSchemaArray,
    __out SIZE_T *UnitCount
    );

HRESULT WINAPI
WinBioEnumDatabases(
    __in WINBIO_BIOMETRIC_TYPE Factor,
    __deref_out_ecount(*StorageCount) WINBIO_STORAGE_SCHEMA **StorageSchemaArray,
    __out SIZE_T *StorageCount
    );


///////////////////////////////////////////////////////////////////////////////
//
// Session management
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioOpenSession(
    __in WINBIO_BIOMETRIC_TYPE Factor,
    __in WINBIO_POOL_TYPE PoolType,
    __in WINBIO_SESSION_FLAGS Flags,
    __in_ecount_opt(UnitCount) WINBIO_UNIT_ID *UnitArray,
    __in_opt SIZE_T UnitCount,
    __in_opt GUID *DatabaseId,
    __out WINBIO_SESSION_HANDLE *SessionHandle
    );

HRESULT WINAPI
WinBioCloseSession(
    __in WINBIO_SESSION_HANDLE SessionHandle
    );


///////////////////////////////////////////////////////////////////////////////
//
// High-level biometric operations
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioVerify(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_IDENTITY *Identity,
    __in WINBIO_BIOMETRIC_SUBTYPE SubFactor,
    __out WINBIO_UNIT_ID *UnitId,
    __out BOOLEAN *Match,
    __out WINBIO_REJECT_DETAIL *RejectDetail
    );

typedef
VOID
(CALLBACK *PWINBIO_VERIFY_CALLBACK)(
    __in_opt PVOID VerifyCallbackContext,
    __in HRESULT OperationStatus,
    __in WINBIO_UNIT_ID UnitId,
    __in BOOLEAN Match,
    __in WINBIO_REJECT_DETAIL RejectDetail
    );

HRESULT WINAPI
WinBioVerifyWithCallback(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_IDENTITY *Identity,
    __in WINBIO_BIOMETRIC_SUBTYPE SubFactor,
    __in PWINBIO_VERIFY_CALLBACK VerifyCallback,
    __in_opt PVOID VerifyCallbackContext
    );

HRESULT WINAPI
WinBioIdentify(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __out WINBIO_UNIT_ID *UnitId,
    __out WINBIO_IDENTITY *Identity,
    __out WINBIO_BIOMETRIC_SUBTYPE *SubFactor,
    __out WINBIO_REJECT_DETAIL *RejectDetail
    );

typedef
VOID
(CALLBACK *PWINBIO_IDENTIFY_CALLBACK)(
    __in_opt PVOID IdentifyCallbackContext,
    __in HRESULT OperationStatus,
    __in WINBIO_UNIT_ID UnitId,
    __in WINBIO_IDENTITY *Identity,
    __in WINBIO_BIOMETRIC_SUBTYPE SubFactor,
    __in WINBIO_REJECT_DETAIL RejectDetail
    );

HRESULT WINAPI
WinBioIdentifyWithCallback(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in PWINBIO_IDENTIFY_CALLBACK IdentifyCallback,
    __in_opt PVOID IdentifyCallbackContext
    );

HRESULT WINAPI
WinBioWait(
    __in WINBIO_SESSION_HANDLE SessionHandle
    );

HRESULT WINAPI
WinBioCancel(
    __in WINBIO_SESSION_HANDLE SessionHandle
    );


///////////////////////////////////////////////////////////////////////////////
//
// Sensor-location operations
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioLocateSensor(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __out WINBIO_UNIT_ID *UnitId
    );

typedef
VOID
(CALLBACK *PWINBIO_LOCATE_SENSOR_CALLBACK)(
    __in_opt PVOID LocateCallbackContext,
    __in HRESULT OperationStatus,
    __in WINBIO_UNIT_ID UnitId
    );

HRESULT WINAPI
WinBioLocateSensorWithCallback(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in PWINBIO_LOCATE_SENSOR_CALLBACK LocateCallback,
    __in_opt PVOID LocateCallbackContext
    );

///////////////////////////////////////////////////////////////////////////////
//
// Enrollment operations
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioEnrollBegin(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_BIOMETRIC_SUBTYPE SubFactor,
    __in WINBIO_UNIT_ID UnitId
    );

HRESULT WINAPI
WinBioEnrollCapture(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __out WINBIO_REJECT_DETAIL *RejectDetail
    );

typedef
VOID
(CALLBACK *PWINBIO_ENROLL_CAPTURE_CALLBACK)(
    __in_opt PVOID EnrollCallbackContext,
    __in HRESULT OperationStatus,
    __in WINBIO_REJECT_DETAIL RejectDetail
    );

HRESULT WINAPI
WinBioEnrollCaptureWithCallback(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in PWINBIO_ENROLL_CAPTURE_CALLBACK EnrollCallback,
    __in_opt PVOID EnrollCallbackContext
    );

HRESULT WINAPI
WinBioEnrollCommit(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __out WINBIO_IDENTITY *Identity,
    __out BOOLEAN *IsNewTemplate
    );

HRESULT WINAPI
WinBioEnrollDiscard(
    __in WINBIO_SESSION_HANDLE SessionHandle
    );

HRESULT WINAPI
WinBioEnumEnrollments(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_UNIT_ID UnitId,
    __in WINBIO_IDENTITY *Identity,
    __deref_out_ecount(*SubFactorCount) WINBIO_BIOMETRIC_SUBTYPE **SubFactorArray,
    __out SIZE_T *SubFactorCount
    );


///////////////////////////////////////////////////////////////////////////////
//
// Event monitors
//
///////////////////////////////////////////////////////////////////////////////
typedef
VOID
(CALLBACK *PWINBIO_EVENT_CALLBACK)(
    __in_opt PVOID EventCallbackContext,
    __in HRESULT OperationStatus,
    __in PWINBIO_EVENT Event
    );

HRESULT WINAPI
WinBioRegisterEventMonitor(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_EVENT_TYPE EventMask,
    __in PWINBIO_EVENT_CALLBACK EventCallback,
    __in_opt PVOID EventCallbackContext
    );

HRESULT WINAPI
WinBioUnregisterEventMonitor(
    __in WINBIO_SESSION_HANDLE SessionHandle
    );


///////////////////////////////////////////////////////////////////////////////
//
// Raw biometric operations
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioCaptureSample(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_BIR_PURPOSE Purpose,
    __in WINBIO_BIR_DATA_FLAGS Flags,
    __out WINBIO_UNIT_ID *UnitId,
    __deref_out_bcount(*SampleSize) PWINBIO_BIR *Sample,
    __out SIZE_T *SampleSize,
    __out WINBIO_REJECT_DETAIL *RejectDetail
    );

typedef
VOID
(CALLBACK *PWINBIO_CAPTURE_CALLBACK)(
    __in_opt PVOID CaptureCallbackContext,
    __in HRESULT OperationStatus,
    __in WINBIO_UNIT_ID UnitId,
    __in_bcount(SampleSize) PWINBIO_BIR Sample,
    __in SIZE_T SampleSize,
    __in WINBIO_REJECT_DETAIL RejectDetail
    );

HRESULT WINAPI
WinBioCaptureSampleWithCallback(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_BIR_PURPOSE Purpose,
    __in WINBIO_BIR_DATA_FLAGS Flags,
    __in PWINBIO_CAPTURE_CALLBACK CaptureCallback,
    __in_opt PVOID CaptureCallbackContext
    );


///////////////////////////////////////////////////////////////////////////////
//
// Storage management
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioDeleteTemplate(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_UNIT_ID UnitId,
    __in WINBIO_IDENTITY *Identity,
    __in WINBIO_BIOMETRIC_SUBTYPE SubFactor
    );


///////////////////////////////////////////////////////////////////////////////
//
// Extension interface
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioLockUnit(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_UNIT_ID UnitId
    );

HRESULT WINAPI
WinBioUnlockUnit(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_UNIT_ID UnitId
    );

HRESULT WINAPI
WinBioControlUnit(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_UNIT_ID UnitId,
    __in WINBIO_COMPONENT Component,
    __in ULONG ControlCode,
    __in PUCHAR SendBuffer,
    __in SIZE_T SendBufferSize,
    __in PUCHAR ReceiveBuffer,
    __in SIZE_T ReceiveBufferSize,
    __out SIZE_T *ReceiveDataSize,
    __out ULONG *OperationStatus
    );

HRESULT WINAPI
WinBioControlUnitPrivileged(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_UNIT_ID UnitId,
    __in WINBIO_COMPONENT Component,
    __in ULONG ControlCode,
    __in PUCHAR SendBuffer,
    __in SIZE_T SendBufferSize,
    __in PUCHAR ReceiveBuffer,
    __in SIZE_T ReceiveBufferSize,
    __out SIZE_T *ReceiveDataSize,
    __out ULONG *OperationStatus
    );


///////////////////////////////////////////////////////////////////////////////
//
// Get/set property operations
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioGetProperty(
    __in WINBIO_SESSION_HANDLE SessionHandle,
    __in WINBIO_PROPERTY_TYPE PropertyType,
    __in WINBIO_PROPERTY_ID PropertyId,
    __in_opt WINBIO_UNIT_ID UnitId,
    __in_opt WINBIO_IDENTITY *Identity,
    __in_opt WINBIO_BIOMETRIC_SUBTYPE SubFactor,
    __deref_out_bcount(*PropertyBufferSize) PVOID *PropertyBuffer,
    __out SIZE_T *PropertyBufferSize
    );


///////////////////////////////////////////////////////////////////////////////
//
// Resource management
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioFree(
    __in PVOID Address
    );


///////////////////////////////////////////////////////////////////////////////
//
// Credential management
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI
WinBioSetCredential(
    __in WINBIO_CREDENTIAL_TYPE Type,
    __in_bcount(CredentialSize) PUCHAR Credential,
    __in SIZE_T CredentialSize,
    __in WINBIO_CREDENTIAL_FORMAT Format
    );

HRESULT WINAPI
WinBioRemoveCredential(
    __in WINBIO_IDENTITY Identity,
    __in WINBIO_CREDENTIAL_TYPE Type
    );

HRESULT WINAPI
WinBioRemoveAllCredentials(
    void
    );


HRESULT WINAPI
WinBioRemoveAllDomainCredentials(
    void
    );

HRESULT WINAPI
WinBioGetCredentialState(
    __in WINBIO_IDENTITY Identity,
    __in WINBIO_CREDENTIAL_TYPE Type,
    __out WINBIO_CREDENTIAL_STATE *CredentialState
    );

HRESULT WINAPI
WinBioLogonIdentifiedUser(
    __in WINBIO_SESSION_HANDLE SessionHandle
    );


///////////////////////////////////////////////////////////////////////////////
//
// Settings
//
///////////////////////////////////////////////////////////////////////////////
VOID WINAPI
WinBioGetEnabledSetting(
    __out BOOLEAN* Value,
    __out PWINBIO_SETTING_SOURCE_TYPE Source
    );

VOID WINAPI
WinBioGetLogonSetting(
    __out BOOLEAN* Value,
    __out PWINBIO_SETTING_SOURCE_TYPE Source
    );

VOID WINAPI
WinBioGetDomainLogonSetting(
    __out BOOLEAN* Value,
    __out PWINBIO_SETTING_SOURCE_TYPE Source
    );

///////////////////////////////////////////////////////////////////////////////
//
// Focus tracking management
//
///////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
WinBioAcquireFocus(
    void
    );

HRESULT WINAPI
WinBioReleaseFocus(
    void
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#endif // _WINBIO_H_9B9AD1F6_97B1_4647_923D_583FD7428C4C_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinBio_Types.h ===
/*++

Copyright (c) 2007 Microsoft Corporation


Module Name:

    winbio_types.h

Abstract:

    Type definitions, constants, and structures used
    by Windows Biometrics components.


Environment:

    User or Kernel mode.

Revision History:

--*/

#ifndef _WINBIO_TYPES_H_712486DB_3EF5_41da_937A_55DCB7B66A53_
#define _WINBIO_TYPES_H_712486DB_3EF5_41da_937A_55DCB7B66A53_

#if (NTDDI_VERSION >= NTDDI_VISTA)

#pragma warning( push )
#pragma warning( disable : 4324 ) // structure-padding message

#ifdef __cplusplus
extern "C"{
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Types used throughout WinBio
//
///////////////////////////////////////////////////////////////////////////////

typedef ULONG WINBIO_UNIT_ID, *PWINBIO_UNIT_ID;
typedef ULONG WINBIO_SESSION_HANDLE, *PWINBIO_SESSION_HANDLE;

//
// A GUID
//
typedef GUID WINBIO_UUID, *PWINBIO_UUID;

//
// Represents a NULL-terminated Unicode character
// string inside a fixed-length buffer.
//
#define WINBIO_MAX_STRING_LEN 256
typedef WCHAR WINBIO_STRING[WINBIO_MAX_STRING_LEN];
typedef WINBIO_STRING *PWINBIO_STRING;

//
// Version
//
typedef struct _WINBIO_VERSION {
    DWORD MajorVersion;
    DWORD MinorVersion;
} WINBIO_VERSION, *PWINBIO_VERSION;

///////////////////////////////////////////////////////////////////////////////
//
// Enumeration for template identity types...
//

typedef ULONG WINBIO_IDENTITY_TYPE, *PWINBIO_IDENTITY_TYPE;

#ifdef MIDL_PASS

const WINBIO_IDENTITY_TYPE  WINBIO_ID_TYPE_NULL     = (WINBIO_IDENTITY_TYPE)0;  // The Identity structure is empty.
const WINBIO_IDENTITY_TYPE  WINBIO_ID_TYPE_WILDCARD = (WINBIO_IDENTITY_TYPE)1;  // The Identity matches "all identities".
const WINBIO_IDENTITY_TYPE  WINBIO_ID_TYPE_GUID     = (WINBIO_IDENTITY_TYPE)2;  // A GUID identifies the template.
const WINBIO_IDENTITY_TYPE  WINBIO_ID_TYPE_SID      = (WINBIO_IDENTITY_TYPE)3;  // An account SID identifies the template.

const ULONG SECURITY_MAX_SID_SIZE = (ULONG)68;

typedef union switch(WINBIO_IDENTITY_TYPE Type) _WINBIO_IDENTITY {
    case WINBIO_ID_TYPE_NULL:       ULONG Null;
    case WINBIO_ID_TYPE_WILDCARD:   ULONG Wildcard;
    case WINBIO_ID_TYPE_GUID:       GUID TemplateGuid;
    case WINBIO_ID_TYPE_SID:        struct {
                                        ULONG Size;
                                        UCHAR Data[SECURITY_MAX_SID_SIZE];
                                    } AccountSid;
} WINBIO_IDENTITY;

#else // MIDL_PASS

#define WINBIO_ID_TYPE_NULL     ((WINBIO_IDENTITY_TYPE)0)  // The Identity structure is empty.
#define WINBIO_ID_TYPE_WILDCARD ((WINBIO_IDENTITY_TYPE)1)  // The Identity matches "all identities"
#define WINBIO_ID_TYPE_GUID     ((WINBIO_IDENTITY_TYPE)2)  // A GUID identifies the template.
#define WINBIO_ID_TYPE_SID      ((WINBIO_IDENTITY_TYPE)3)  // An account SID identifies the template.

//
// Structure that contains the identity value associated
// with a biometric template.
//
//#ifndef SECURITY_MAX_SID_SIZE
//#define SECURITY_MAX_SID_SIZE 68
//#endif
typedef struct _WINBIO_IDENTITY {
    WINBIO_IDENTITY_TYPE Type;
    union {
        ULONG Null;
        ULONG Wildcard;
        GUID TemplateGuid;
        struct {
            ULONG Size;
            UCHAR Data[SECURITY_MAX_SID_SIZE];
        } AccountSid;
    } Value;
} WINBIO_IDENTITY;

#endif // MIDL_PASS

typedef WINBIO_IDENTITY *PWINBIO_IDENTITY;

#define WINBIO_IDENTITY_WILDCARD  ((ULONG)0x25066282)

///////////////////////////////////////////////////////////////////////////////
//
// Things related to get/set property operations
//
typedef ULONG32 WINBIO_PROPERTY_TYPE, *PWINBIO_PROPERTY_TYPE;

#define WINBIO_PROPERTY_TYPE_SESSION    ((WINBIO_PROPERTY_TYPE)1)
#define WINBIO_PROPERTY_TYPE_UNIT       ((WINBIO_PROPERTY_TYPE)2)
#define WINBIO_PROPERTY_TYPE_TEMPLATE   ((WINBIO_PROPERTY_TYPE)3)


typedef ULONG32 WINBIO_PROPERTY_ID, *PWINBIO_PROPERTY_ID;

#define WINBIO_PROPERTY_SAMPLE_HINT     ((WINBIO_PROPERTY_ID)1)  //(read-only)

///////////////////////////////////////////////////////////////////////////////
//
// Bitmask describing the supported set of biometric types (factors).
//
typedef ULONG32 WINBIO_BIOMETRIC_TYPE, *PWINBIO_BIOMETRIC_TYPE;

#define WINBIO_STANDARD_TYPE_MASK           ((WINBIO_BIOMETRIC_TYPE)0x00FFFFFF)

#define WINBIO_NO_TYPE_AVAILABLE            ((WINBIO_BIOMETRIC_TYPE)0x00000000)
//
// Standard biometric types (from NISTIR 6529-A)
//
#define WINBIO_TYPE_MULTIPLE                ((WINBIO_BIOMETRIC_TYPE)0x00000001)
#define WINBIO_TYPE_FACIAL_FEATURES         ((WINBIO_BIOMETRIC_TYPE)0x00000002)
#define WINBIO_TYPE_VOICE                   ((WINBIO_BIOMETRIC_TYPE)0x00000004)
#define WINBIO_TYPE_FINGERPRINT             ((WINBIO_BIOMETRIC_TYPE)0x00000008)
#define WINBIO_TYPE_IRIS                    ((WINBIO_BIOMETRIC_TYPE)0x00000010)
#define WINBIO_TYPE_RETINA                  ((WINBIO_BIOMETRIC_TYPE)0x00000020)
#define WINBIO_TYPE_HAND_GEOMETRY           ((WINBIO_BIOMETRIC_TYPE)0x00000040)
#define WINBIO_TYPE_SIGNATURE_DYNAMICS      ((WINBIO_BIOMETRIC_TYPE)0x00000080)
#define WINBIO_TYPE_KEYSTROKE_DYNAMICS      ((WINBIO_BIOMETRIC_TYPE)0x00000100)
#define WINBIO_TYPE_LIP_MOVEMENT            ((WINBIO_BIOMETRIC_TYPE)0x00000200)
#define WINBIO_TYPE_THERMAL_FACE_IMAGE      ((WINBIO_BIOMETRIC_TYPE)0x00000400)
#define WINBIO_TYPE_THERMAL_HAND_IMAGE      ((WINBIO_BIOMETRIC_TYPE)0x00000800)
#define WINBIO_TYPE_GAIT                    ((WINBIO_BIOMETRIC_TYPE)0x00001000)
#define WINBIO_TYPE_SCENT                   ((WINBIO_BIOMETRIC_TYPE)0x00002000)
#define WINBIO_TYPE_DNA                     ((WINBIO_BIOMETRIC_TYPE)0x00004000)
#define WINBIO_TYPE_EAR_SHAPE               ((WINBIO_BIOMETRIC_TYPE)0x00008000)
#define WINBIO_TYPE_FINGER_GEOMETRY         ((WINBIO_BIOMETRIC_TYPE)0x00010000)
#define WINBIO_TYPE_PALM_PRINT              ((WINBIO_BIOMETRIC_TYPE)0x00020000)
#define WINBIO_TYPE_VEIN_PATTERN            ((WINBIO_BIOMETRIC_TYPE)0x00040000)
#define WINBIO_TYPE_FOOT_PRINT              ((WINBIO_BIOMETRIC_TYPE)0x00080000)
//
// WinBio extended types
//
#define WINBIO_TYPE_OTHER                   ((WINBIO_BIOMETRIC_TYPE)0x40000000)
#define WINBIO_TYPE_PASSWORD                ((WINBIO_BIOMETRIC_TYPE)0x80000000)

#define WINBIO_TYPE_ANY                     ((WINBIO_BIOMETRIC_TYPE)(WINBIO_STANDARD_TYPE_MASK |    \
                                                                     WINBIO_TYPE_OTHER |            \
                                                                     WINBIO_TYPE_PASSWORD))


//
// WinBio sensor sub-types.  These are defined per Biometric type, and are
// defined only for fingerprints in this version.
//
typedef ULONG WINBIO_BIOMETRIC_SENSOR_SUBTYPE, *PWINBIO_BIOMETRIC_SENSOR_SUBTYPE;

#define WINBIO_SENSOR_SUBTYPE_UNKNOWN       ((WINBIO_BIOMETRIC_SENSOR_SUBTYPE)0x00000000)

#define WINBIO_FP_SENSOR_SUBTYPE_SWIPE      ((WINBIO_BIOMETRIC_SENSOR_SUBTYPE)0x00000001)
#define WINBIO_FP_SENSOR_SUBTYPE_TOUCH      ((WINBIO_BIOMETRIC_SENSOR_SUBTYPE)0x00000002)

//
// Bitmask of sensor capabilities
//
typedef ULONG WINBIO_CAPABILITIES, *PWINBIO_CAPABILITIES;

#define WINBIO_CAPABILITY_SENSOR        ((WINBIO_CAPABILITIES)0x00000001)
#define WINBIO_CAPABILITY_MATCHING      ((WINBIO_CAPABILITIES)0x00000002)
#define WINBIO_CAPABILITY_DATABASE      ((WINBIO_CAPABILITIES)0x00000004)
#define WINBIO_CAPABILITY_PROCESSING    ((WINBIO_CAPABILITIES)0x00000008)
#define WINBIO_CAPABILITY_ENCRYPTION    ((WINBIO_CAPABILITIES)0x00000010)
#define WINBIO_CAPABILITY_NAVIGATION    ((WINBIO_CAPABILITIES)0x00000020)
#define WINBIO_CAPABILITY_INDICATOR     ((WINBIO_CAPABILITIES)0x00000040)

//
// Values used to set the indicator on or off
//
// By default, sensors will not have a light on.
// Applications can use these values to enable
// or disable indicator lights on the sensor.
// WINBIO_SENSOR_STATUS will provide more detail
// about the status of the light when it is "on."
//
typedef DWORD WINBIO_INDICATOR_STATUS, *PWINBIO_INDICATOR_STATUS;

#define WINBIO_INDICATOR_ON     ((WINBIO_INDICATOR_STATUS)1)
#define WINBIO_INDICATOR_OFF    ((WINBIO_INDICATOR_STATUS)2)

///////////////////////////////////////////////////////////////////////////////
//
// Sensor operating modes
//
typedef ULONG WINBIO_SENSOR_MODE, *PWINBIO_SENSOR_MODE;

#define WINBIO_SENSOR_UNKNOWN_MODE      ((WINBIO_SENSOR_MODE)0)
#define WINBIO_SENSOR_BASIC_MODE        ((WINBIO_SENSOR_MODE)1)
#define WINBIO_SENSOR_ADVANCED_MODE     ((WINBIO_SENSOR_MODE)2)
#define WINBIO_SENSOR_NAVIGATION_MODE   ((WINBIO_SENSOR_MODE)3)
#define WINBIO_SENSOR_SLEEP_MODE        ((WINBIO_SENSOR_MODE)4)

///////////////////////////////////////////////////////////////////////////////
//
// Factor-specific value giving additional information about
// a biometric measurement (e.g., *which* finger a fingerprint
// sample was taken from).
//
typedef UCHAR WINBIO_BIOMETRIC_SUBTYPE, *PWINBIO_BIOMETRIC_SUBTYPE;

#define WINBIO_SUBTYPE_NO_INFORMATION       ((WINBIO_BIOMETRIC_SUBTYPE)0x00)
#define WINBIO_SUBTYPE_ANY                  ((WINBIO_BIOMETRIC_SUBTYPE)0xFF)
//
// If the biometric type is WINBIO_TYPE_FINGERPRINT, WinBio uses
// 'WINBIO_ANSI_381_POS_xyz' constants to represent fingerprint sub-type
// information. (These are defined below in the WINBIO_BDB_ANSI_381_RECORD.)
//

///////////////////////////////////////////////////////////////////////////////
//
// Factor-specific value that describes the reason a
// biometric sampling operation failed.
//
typedef ULONG WINBIO_REJECT_DETAIL, *PWINBIO_REJECT_DETAIL;

//
// Failure detail values for WINBIO_TYPE_FINGERPRINT
//
#define WINBIO_FP_TOO_HIGH          ((WINBIO_REJECT_DETAIL)1)
#define WINBIO_FP_TOO_LOW           ((WINBIO_REJECT_DETAIL)2)
#define WINBIO_FP_TOO_LEFT          ((WINBIO_REJECT_DETAIL)3)
#define WINBIO_FP_TOO_RIGHT         ((WINBIO_REJECT_DETAIL)4)
#define WINBIO_FP_TOO_FAST          ((WINBIO_REJECT_DETAIL)5)
#define WINBIO_FP_TOO_SLOW          ((WINBIO_REJECT_DETAIL)6)
#define WINBIO_FP_POOR_QUALITY      ((WINBIO_REJECT_DETAIL)7)
#define WINBIO_FP_TOO_SKEWED        ((WINBIO_REJECT_DETAIL)8)
#define WINBIO_FP_TOO_SHORT         ((WINBIO_REJECT_DETAIL)9)
#define WINBIO_FP_MERGE_FAILURE     ((WINBIO_REJECT_DETAIL)10)


///////////////////////////////////////////////////////////////////////////////
//
// Biometric Information Record (BIR)
//
///////////////////////////////////////////////////////////////////////////////
//
//      +---------------------------------------+
// 1.   |   WINBIO_BIR                          |
//      +---------------------------------------+
// 2.   |   WINBIO_BIR_HEADER                   |
//      +---------------------------------------+
// 3.   |   Standard Data Block (optional)      |
//      |                                       |
//      |       WINBIO_BDB_ANSI_381_HEADER      |
//      |       [0] WINBIO_BDB_ANSI_381_RECORD  |
//      |           :                           |
//      |       [N] WINBIO_BDB_ANSI_381_RECORD  |
//      +---------------------------------------+
// 4.   |   Vendor Data Block (optional)        |
//      +---------------------------------------+
// 5.   |   Signature Block (optional)          |
//      +---------------------------------------+
//
// NOTES:
//      - The format of the Standard Data Block is determined
//      by the 'BiometricDataFormat' field of WINBIO_BIR_HEADER.
//
//      - Currently, the only supported format for the Standard
//      Data Block is ANSI 381 fingerprint image data. Data in
//      any other form must go into the Vendor Data Block instead.
//
//      - It's vital that BIR structures and sub-structures be aligned
//      on 8-byte boundaries. This means both C++ and MIDL compilation
//      with at least /Zp8 alignment. This also applies to BIRs that
//      are allocated dynamically from the heap.
//
#define WINBIO_BIR_ALIGN_SIZE   (8)
//
// Also define legacy typo to be synonymous
//
#define WINBIO_BIR_ALGIN_SIZE   WINBIO_BIR_ALIGN_SIZE

//
// The following gives the location and size of a block
// in a BIR. The offset is measured from the beginning of
// the WINBIO_BIR structure.
//
typedef struct _WINBIO_BIR_DATA {
    ULONG Size;
    ULONG Offset;
} WINBIO_BIR_DATA;

typedef WINBIO_BIR_DATA *PWINBIO_BIR_DATA;

//
// Top-level structure contains offset/size
// information needed to find other items.
//
typedef struct _WINBIO_BIR {
    WINBIO_BIR_DATA HeaderBlock;
    WINBIO_BIR_DATA StandardDataBlock;
    WINBIO_BIR_DATA VendorDataBlock;
    WINBIO_BIR_DATA SignatureBlock;
} WINBIO_BIR;

typedef WINBIO_BIR *PWINBIO_BIR;

///////////////////////////////////////////////////////////////////////////////
//
// Elements used in a BIR header
//
///////////////////////////////////////////////////////////////////////////////
//
// BIR 'ValidFields' flags...
//
#define WINBIO_BIR_FIELD_SUBHEAD_COUNT          ((USHORT)0x0001)
#define WINBIO_BIR_FIELD_PRODUCT_ID             ((USHORT)0x0002)
#define WINBIO_BIR_FIELD_PATRON_ID              ((USHORT)0x0004)
#define WINBIO_BIR_FIELD_INDEX                  ((USHORT)0x0008)

#define WINBIO_BIR_FIELD_CREATION_DATE          ((USHORT)0x0010)
#define WINBIO_BIR_FIELD_VALIDITY_PERIOD        ((USHORT)0x0020)
#define WINBIO_BIR_FIELD_BIOMETRIC_TYPE         ((USHORT)0x0040)
#define WINBIO_BIR_FIELD_BIOMETRIC_SUBTYPE      ((USHORT)0x0080)

#define WINBIO_BIR_FIELD_CBEFF_HEADER_VERSION   ((USHORT)0x0100)
#define WINBIO_BIR_FIELD_PATRON_HEADER_VERSION  ((USHORT)0x0200)
#define WINBIO_BIR_FIELD_BIOMETRIC_PURPOSE      ((USHORT)0x0400)
#define WINBIO_BIR_FIELD_BIOMETRIC_CONDITION    ((USHORT)0x0800)

#define WINBIO_BIR_FIELD_QUALITY                ((USHORT)0x1000)
#define WINBIO_BIR_FIELD_CREATOR                ((USHORT)0x2000)
#define WINBIO_BIR_FIELD_CHALLENGE              ((USHORT)0x4000)
#define WINBIO_BIR_FIELD_PAYLOAD                ((USHORT)0x8000)

//
// The following collection of optional fields will NEVER be
// part of a WinBio BIR. If any of these bits are asserted,
// the BIR is malformed.
//
#define WINBIO_BIR_FIELD_NEVER_VALID    (WINBIO_BIR_FIELD_SUBHEAD_COUNT |   \
                                         WINBIO_BIR_FIELD_PATRON_ID |       \
                                         WINBIO_BIR_FIELD_INDEX |           \
                                         WINBIO_BIR_FIELD_CHALLENGE |       \
                                         WINBIO_BIR_FIELD_PAYLOAD )

///////////////////////////////////////////////////////////////////////////////
//
// BIR 'HeaderVersion' and 'PatronHeaderVersion' fields:
//
// Versions are represented as 8-bit values of the
// form: 0xNM, where 'N' is the major version and 'M'
// is the minor version.
//
typedef UCHAR WINBIO_BIR_VERSION, *PWINBIO_BIR_VERSION;

#define WINBIO_CBEFF_HEADER_VERSION     ((WINBIO_BIR_VERSION)0x11)
#define WINBIO_PATRON_HEADER_VERSION    ((WINBIO_BIR_VERSION)0x11)

///////////////////////////////////////////////////////////////////////////////
//
// BIR 'DataFlags' field:
//      * Security and integrity-checking options
//          PRIVACY     - BDB is encrypted
//          INTEGRITY   - BDB is signed or MAC'ed
//          SIGNED      - 1 -> BDB is signed; 0 -> BDB is MAC'ed
//      * Processing level of the data
//
typedef UCHAR WINBIO_BIR_DATA_FLAGS, *PWINBIO_BIR_DATA_FLAGS;

#define WINBIO_DATA_FLAG_PRIVACY                ((UCHAR)0x02)
#define WINBIO_DATA_FLAG_INTEGRITY              ((UCHAR)0x01)
#define WINBIO_DATA_FLAG_SIGNED                 ((UCHAR)0x04)

#define WINBIO_DATA_FLAG_RAW                    ((UCHAR)0x20)
#define WINBIO_DATA_FLAG_INTERMEDIATE           ((UCHAR)0x40)
#define WINBIO_DATA_FLAG_PROCESSED              ((UCHAR)0x80)

#define WINBIO_DATA_FLAG_OPTION_MASK_PRESENT    ((UCHAR)0x08)   // Always '1'.

///////////////////////////////////////////////////////////////////////////////
//
// BIR 'Purpose' field:
//
// A value defining the purpose for which the BIR
//
//  - is intended, when used as input to a WinBio function
//
//  - is suitable, when used as output from a WinBio function
//  or within a BIR header.
//
// NOTE:
//  In a WINBIO BIR, the 'Purpose' field is defined as a set of flag bits
//  rather than an enumerated type (as specified in NISTIR 6529-A). Transferring
//  a WINBIO BIR to another environment (e.g., BioAPI) will require conversion.
//
//  The suggested way to handle this conversion is to generate a set of nested
//  BIRs for any WINBIO BIRs that have multiple 'Purpose' bits set.
//
typedef UCHAR WINBIO_BIR_PURPOSE, *PWINBIO_BIR_PURPOSE;

#define WINBIO_NO_PURPOSE_AVAILABLE                     ((WINBIO_BIR_PURPOSE)0x00)
#define WINBIO_PURPOSE_VERIFY                           ((WINBIO_BIR_PURPOSE)0x01)
#define WINBIO_PURPOSE_IDENTIFY                         ((WINBIO_BIR_PURPOSE)0x02)
#define WINBIO_PURPOSE_ENROLL                           ((WINBIO_BIR_PURPOSE)0x04)
#define WINBIO_PURPOSE_ENROLL_FOR_VERIFICATION          ((WINBIO_BIR_PURPOSE)0x08)
#define WINBIO_PURPOSE_ENROLL_FOR_IDENTIFICATION        ((WINBIO_BIR_PURPOSE)0x10)
#define WINBIO_PURPOSE_AUDIT                            ((WINBIO_BIR_PURPOSE)0x80)

///////////////////////////////////////////////////////////////////////////////
//
// BIR 'DataQuality' field:
//
// FIndicates the relative quality of the biometric
// data in the BIR.
//
// Quality measurements are represented as signed
// integers in the range 0-100, except:
//
//      -1  Quality measurements are supported by the
//          BIR creator, but no value is set in the BIR.
//
//      -2  Quality measurements are not supported
//          by the BIR creator.
//
typedef CHAR WINBIO_BIR_QUALITY, *PWINBIO_BIR_QUALITY;

#define WINBIO_DATA_QUALITY_NOT_SET         ((WINBIO_BIR_QUALITY)-1)
#define WINBIO_DATA_QUALITY_NOT_SUPPORTED   ((WINBIO_BIR_QUALITY)-2)

///////////////////////////////////////////////////////////////////////////////
//
// BIR 'BiometricDataFormat' and 'ProductId' fields:
//
// Identifies a registered data format as a pair consisting of
// an IBIA-assigned owner value plus an owner-assigned format-type
// value.
//
typedef struct _WINBIO_REGISTERED_FORMAT {
    USHORT Owner;
    USHORT Type;
} WINBIO_REGISTERED_FORMAT, *PWINBIO_REGISTERED_FORMAT;

#define WINBIO_NO_FORMAT_OWNER_AVAILABLE    ((USHORT)0)
#define WINBIO_NO_FORMAT_TYPE_AVAILABLE     ((USHORT)0)

///////////////////////////////////////////////////////////////////////////////
//
// NISTIR 6529-A -- Common Biometric Exchange Formats Framework (CBEFF)
// April 5, 2004
//
// CBEFF Patron Format A: Standard Biometric Header Block
//
// NOTE:
//      This structure is COMPATIBLE with CBEFF Patron Format A in that
//      it can be transformed to/from a fully-conformant Format A record.
//      The following fields are NOT part of this structure:
//          - Subheader -- WinBio doesn't support nested CBEFF structures
//          - Patron format owner/type -- used only for nested CBEFF structures
//          - Index
//          - Creator
//          - Challenge/response
//          - Payload
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _WINBIO_BIR_HEADER {
    //
    // Mask indicating which fields are valid
    //
    // Annex A -- Note (1) to Table A.1
    //
    USHORT ValidFields;

    //
    // CBEFF Header version
    //
    // SECTION 5.2.1.3
    //
    WINBIO_BIR_VERSION HeaderVersion;   // = WINBIO_CBEFF_HEADER_VERSION

    //
    // Patron header version
    //
    // SECTION 5.2.1.4
    //
    WINBIO_BIR_VERSION PatronHeaderVersion; // = WINBIO_PATRON_HEADER_VERSION

    //
    // 'DataFlags' is a combination of the 'Security
    // Options' field and the 'Biometric Data Type'
    // (RAW, INTERMEDIATE,PROCESSED) field.
    //
    // SECTION 5.2.1.1, 5.2.1.2, and 5.2.1.7
    //
    WINBIO_BIR_DATA_FLAGS DataFlags;

    //
    // Biometric type
    //
    // SECTION 5.2.1.5
    //
    WINBIO_BIOMETRIC_TYPE Type;

    //
    // Biometric subtype
    //
    // SECTION 5.2.1.6
    //
    WINBIO_BIOMETRIC_SUBTYPE Subtype;

    //
    // Intended use of the data
    //
    // SECTION 5.2.1.8
    //
    WINBIO_BIR_PURPOSE Purpose;

    //
    // Biometric data quality
    //
    // SECTION 5.2.1.9
    //
    WINBIO_BIR_QUALITY DataQuality;

    //
    // Creation date and time of this BIR (in UTC)
    //
    // SECTION 5.2.1.10
    //
    LARGE_INTEGER CreationDate;

    //
    // Validity period of this BIR (in UTC)
    //
    // SECTION 5.2.1.11
    //
    struct {
        LARGE_INTEGER BeginDate;
        LARGE_INTEGER EndDate;
    } ValidityPeriod;

    ///////////////////////////////////////////////////////////////////////////
    //
    // Data format of Standard Data Block.
    //
    // NOTE: If BIR doesn't contain 'StandardDataBlock'
    // element, this is set to "no owner/type available".
    //
    WINBIO_REGISTERED_FORMAT BiometricDataFormat;

    //
    // Product identifier for the component that
    // generated the 'StandardDataBlock' element.
    //
    // NOTE: If BIR doesn't contain 'StandardDataBlock'
    // element, this is set to "no owner/type available".
    //
    WINBIO_REGISTERED_FORMAT ProductId;

} WINBIO_BIR_HEADER;

typedef WINBIO_BIR_HEADER *PWINBIO_BIR_HEADER;


///////////////////////////////////////////////////////////////////////////////
//
// ANSI INCITS 381-2004 -- Finger Image-Based Data Interchange Format
//
///////////////////////////////////////////////////////////////////////////////
//
// SECTION 7 -- Registered Format
//
// WINBIO_BIR_HEADER.BiometricDataFormat.Owner = WINBIO_ANSI_381_FORMAT_OWNER
// WINBIO_BIR_HEADER.BiometricDataFormat.Type  = WINBIO_ANSI_381_FORMAT_TYPE
//
#define WINBIO_ANSI_381_FORMAT_OWNER    ((USHORT)0x001B)    // INCITS Technical Committee M1
#define WINBIO_ANSI_381_FORMAT_TYPE     ((USHORT)0x0401)    // ANSI-381

//
// SECTION 7.1 -- General Record Header
//
typedef struct _WINBIO_BDB_ANSI_381_HEADER {
    ULONG64 RecordLength;               // Only the low 6 bytes of this number are valid.
                                        // sizeof(WINBIO_BDB_ANSI_381_HEADER)
                                        // + sizeof( all WINBIO_BDB_ANSI_381_RECORD records)

    ULONG FormatIdentifier;             // Must be 0x46495200 (ASCII: 'F' 'I' 'R' 0x0)
    ULONG VersionNumber;                // Must be 0x30313000 (ASCII: '0' '1' '0' 0x0)

    WINBIO_REGISTERED_FORMAT ProductId;

    USHORT CaptureDeviceId;
    USHORT ImageAcquisitionLevel;
    USHORT HorizontalScanResolution;
    USHORT VerticalScanResolution;
    USHORT HorizontalImageResolution;
    USHORT VerticalImageResolution;

    UCHAR ElementCount;                 // Number of finger/palm records in the block
    UCHAR ScaleUnits;                   // cm or inch
    UCHAR PixelDepth;                   // 1-16 bits per pixel (2-64K gray levels)
    UCHAR ImageCompressionAlg;

    USHORT Reserved;
    // 38 bytes (because of unused 2 bytes in ULONG64) vs. 36 bytes defined in ANSI INCITS spec

} WINBIO_BDB_ANSI_381_HEADER;

typedef WINBIO_BDB_ANSI_381_HEADER *PWINBIO_BDB_ANSI_381_HEADER;

//
// SECTION 7.1.6 Image acquistion level
//
// Table 1 -- Image acquistion setting levels
//
#define WINBIO_ANSI_381_IMG_ACQ_LEVEL_10    ((USHORT)10)
#define WINBIO_ANSI_381_IMG_ACQ_LEVEL_20    ((USHORT)20)
#define WINBIO_ANSI_381_IMG_ACQ_LEVEL_30    ((USHORT)30)
#define WINBIO_ANSI_381_IMG_ACQ_LEVEL_31    ((USHORT)31)
#define WINBIO_ANSI_381_IMG_ACQ_LEVEL_40    ((USHORT)40)
#define WINBIO_ANSI_381_IMG_ACQ_LEVEL_41    ((USHORT)41)

//
// SECTION 7.1.8 -- Scale units
//
#define WINBIO_ANSI_381_PIXELS_PER_INCH     ((UCHAR)0x01)
#define WINBIO_ANSI_381_PIXELS_PER_CM       ((UCHAR)0x02)

//
// SECTION 7.1.14 -- Image compression algorithm
//
// Table 3 -- Compression algorithm codes
//
#define WINBIO_ANSI_381_IMG_UNCOMPRESSED            ((UCHAR)0)
#define WINBIO_ANSI_381_IMG_BIT_PACKED              ((UCHAR)1)
#define WINBIO_ANSI_381_IMG_COMPRESSED_WSQ          ((UCHAR)2)
#define WINBIO_ANSI_381_IMG_COMPRESSED_JPEG         ((UCHAR)3)
#define WINBIO_ANSI_381_IMG_COMPRESSED_JPEG2000     ((UCHAR)4)
#define WINBIO_ANSI_381_IMG_COMPRESSED_PNG          ((UCHAR)5)

//
// SECTION 7.2 -- Finger Record Header
//
typedef struct _WINBIO_BDB_ANSI_381_RECORD {
    ULONG BlockLength;                  // sizeof(WINBIO_BDB_ANSI_381_RECORD)
                                        // + sizeof(image data)
    USHORT HorizontalLineLength;        // Number of pixels in a horizontal line
    USHORT VerticalLineLength;          // Number of horizontal lines in the image
    WINBIO_BIOMETRIC_SUBTYPE Position;
    UCHAR CountOfViews;                 // Must be set to one (1)
    UCHAR ViewNumber;                   // Must be set to one (1)
    UCHAR ImageQuality;                 // Reserved -- must be set to 254 (0xFE)
    UCHAR ImpressionType;
    UCHAR Reserved;                     // Must be set to zero
    // 14 bytes of header data
} WINBIO_BDB_ANSI_381_RECORD;
//
// Followed immediately by compressed/uncompressed image data.
// (Image data must be < 43 * 10^8 bytes in length.)
//

typedef WINBIO_BDB_ANSI_381_RECORD *PWINBIO_BDB_ANSI_381_RECORD;

//
// SECTION 7.2.2 -- Finger position codes
//
// Table 5 -- Finger position codes, areas, and maximum dimensions
//
#define WINBIO_ANSI_381_POS_UNKNOWN             ((WINBIO_BIOMETRIC_SUBTYPE)0)
#define WINBIO_ANSI_381_POS_RH_THUMB            ((WINBIO_BIOMETRIC_SUBTYPE)1)
#define WINBIO_ANSI_381_POS_RH_INDEX_FINGER     ((WINBIO_BIOMETRIC_SUBTYPE)2)
#define WINBIO_ANSI_381_POS_RH_MIDDLE_FINGER    ((WINBIO_BIOMETRIC_SUBTYPE)3)
#define WINBIO_ANSI_381_POS_RH_RING_FINGER      ((WINBIO_BIOMETRIC_SUBTYPE)4)
#define WINBIO_ANSI_381_POS_RH_LITTLE_FINGER    ((WINBIO_BIOMETRIC_SUBTYPE)5)
#define WINBIO_ANSI_381_POS_LH_THUMB            ((WINBIO_BIOMETRIC_SUBTYPE)6)
#define WINBIO_ANSI_381_POS_LH_INDEX_FINGER     ((WINBIO_BIOMETRIC_SUBTYPE)7)
#define WINBIO_ANSI_381_POS_LH_MIDDLE_FINGER    ((WINBIO_BIOMETRIC_SUBTYPE)8)
#define WINBIO_ANSI_381_POS_LH_RING_FINGER      ((WINBIO_BIOMETRIC_SUBTYPE)9)
#define WINBIO_ANSI_381_POS_LH_LITTLE_FINGER    ((WINBIO_BIOMETRIC_SUBTYPE)10)

#define WINBIO_ANSI_381_POS_RH_FOUR_FINGERS     ((WINBIO_BIOMETRIC_SUBTYPE)13)
#define WINBIO_ANSI_381_POS_LH_FOUR_FINGERS     ((WINBIO_BIOMETRIC_SUBTYPE)14)
#define WINBIO_ANSI_381_POS_TWO_THUMBS          ((WINBIO_BIOMETRIC_SUBTYPE)15)
//
// Table 6 -- Palm codes, areas, and maximum dimensions
//
#define WINBIO_ANSI_381_POS_UNKNOWN_PALM        ((WINBIO_BIOMETRIC_SUBTYPE)20)
#define WINBIO_ANSI_381_POS_RH_FULL_PALM        ((WINBIO_BIOMETRIC_SUBTYPE)21)
#define WINBIO_ANSI_381_POS_RH_WRITERS_PALM     ((WINBIO_BIOMETRIC_SUBTYPE)22)
#define WINBIO_ANSI_381_POS_LH_FULL_PALM        ((WINBIO_BIOMETRIC_SUBTYPE)23)
#define WINBIO_ANSI_381_POS_LH_WRITERS_PALM     ((WINBIO_BIOMETRIC_SUBTYPE)24)
#define WINBIO_ANSI_381_POS_RH_LOWER_PALM       ((WINBIO_BIOMETRIC_SUBTYPE)25)
#define WINBIO_ANSI_381_POS_RH_UPPER_PALM       ((WINBIO_BIOMETRIC_SUBTYPE)26)
#define WINBIO_ANSI_381_POS_LH_LOWER_PALM       ((WINBIO_BIOMETRIC_SUBTYPE)27)
#define WINBIO_ANSI_381_POS_LH_UPPER_PALM       ((WINBIO_BIOMETRIC_SUBTYPE)28)
#define WINBIO_ANSI_381_POS_RH_OTHER            ((WINBIO_BIOMETRIC_SUBTYPE)29)
#define WINBIO_ANSI_381_POS_LH_OTHER            ((WINBIO_BIOMETRIC_SUBTYPE)30)
#define WINBIO_ANSI_381_POS_RH_INTERDIGITAL     ((WINBIO_BIOMETRIC_SUBTYPE)31)
#define WINBIO_ANSI_381_POS_RH_THENAR           ((WINBIO_BIOMETRIC_SUBTYPE)32)
#define WINBIO_ANSI_381_POS_RH_HYPOTHENAR       ((WINBIO_BIOMETRIC_SUBTYPE)33)
#define WINBIO_ANSI_381_POS_LH_INTERDIGITAL     ((WINBIO_BIOMETRIC_SUBTYPE)34)
#define WINBIO_ANSI_381_POS_LH_THENAR           ((WINBIO_BIOMETRIC_SUBTYPE)35)
#define WINBIO_ANSI_381_POS_LH_HYPOTHENAR       ((WINBIO_BIOMETRIC_SUBTYPE)36)

//
// SECTION 7.2.6 -- Impression-Type Codes
//
// Table 7 -- Finger and palm impression types
//
#define WINBIO_ANSI_381_IMP_TYPE_LIVE_SCAN_PLAIN        ((UCHAR)0)
#define WINBIO_ANSI_381_IMP_TYPE_LIVE_SCAN_ROLLED       ((UCHAR)1)
#define WINBIO_ANSI_381_IMP_TYPE_NONLIVE_SCAN_PLAIN     ((UCHAR)2)
#define WINBIO_ANSI_381_IMP_TYPE_NONLIVE_SCAN_ROLLED    ((UCHAR)3)
#define WINBIO_ANSI_381_IMP_TYPE_LATENT                 ((UCHAR)7)
#define WINBIO_ANSI_381_IMP_TYPE_SWIPE                  ((UCHAR)8)
#define WINBIO_ANSI_381_IMP_TYPE_LIVE_SCAN_CONTACTLESS  ((UCHAR)9)


//
//
//
typedef ULONG WINBIO_POOL_TYPE, *PWINBIO_POOL_TYPE;

#define WINBIO_POOL_UNKNOWN         ((WINBIO_POOL_TYPE)0)
#define WINBIO_POOL_SYSTEM          ((WINBIO_POOL_TYPE)1)
#define WINBIO_POOL_PRIVATE         ((WINBIO_POOL_TYPE)2)
#define WINBIO_POOL_UNASSIGNED      ((WINBIO_POOL_TYPE)3) // Reserved for Microsoft - do not use.

//
// Specific access rights for Biometric Units
//
#define BIO_UNIT_RAW                ((USHORT)0x0001)
#define BIO_UNIT_MAINTENANCE        ((USHORT)0x0002)
#define BIO_UNIT_OPEN_SESSION       ((USHORT)0x0004)
#define BIO_UNIT_EXTENDED_ACCESS    ((USHORT)0x0008)
#define BIO_UNIT_ENROLL             ((USHORT)0x0010)

//
// OpenSession parameter that controls session attributes...
//
typedef ULONG WINBIO_SESSION_FLAGS, *PWINBIO_SESSION_FLAGS;
//
// Sensor configuration flags...
//
#define WINBIO_FLAG_DEFAULT         ((WINBIO_SESSION_FLAGS)0x00000000)
#define WINBIO_FLAG_BASIC           ((WINBIO_SESSION_FLAGS)((WINBIO_SENSOR_BASIC_MODE & 0xFFFF)<<16))
#define WINBIO_FLAG_ADVANCED        ((WINBIO_SESSION_FLAGS)((WINBIO_SENSOR_ADVANCED_MODE & 0xFFFF)<<16))
//
// Desired access flags...
//
#define WINBIO_FLAG_RAW             ((WINBIO_SESSION_FLAGS)BIO_UNIT_RAW)
#define WINBIO_FLAG_MAINTENANCE     ((WINBIO_SESSION_FLAGS)BIO_UNIT_MAINTENANCE)

//
// Well-known database IDs used by WinBioOpenSession
//
#define WINBIO_DB_DEFAULT           ((GUID *)1)
#define WINBIO_DB_BOOTSTRAP         ((GUID *)2)
#define WINBIO_DB_ONCHIP            ((GUID *)3)

//
// Identify one of the components in a Biometric Unit's
// processing pipeline (for ControlUnit operations)...
//
typedef ULONG WINBIO_COMPONENT, *PWINBIO_COMPONENT;

#define WINBIO_COMPONENT_SENSOR     ((WINBIO_COMPONENT)1)
#define WINBIO_COMPONENT_ENGINE     ((WINBIO_COMPONENT)2)
#define WINBIO_COMPONENT_STORAGE    ((WINBIO_COMPONENT)3)

//
// Event Monitor stuff...
//
typedef ULONG WINBIO_EVENT_TYPE, *PWINBIO_EVENT_TYPE;

#ifdef MIDL_PASS

//
// Generic events
//
const WINBIO_EVENT_TYPE WINBIO_EVENT_ERROR                  = (WINBIO_EVENT_TYPE)0xFFFFFFFF;

//
// Fingerprint events.
//
const WINBIO_EVENT_TYPE WINBIO_EVENT_FP_UNCLAIMED           = (WINBIO_EVENT_TYPE)0x00000001;
const WINBIO_EVENT_TYPE WINBIO_EVENT_FP_UNCLAIMED_IDENTIFY  = (WINBIO_EVENT_TYPE)0x00000002;

typedef union switch(WINBIO_EVENT_TYPE Type) _WINBIO_EVENT {

    case WINBIO_EVENT_FP_UNCLAIMED:             struct {
                                                    WINBIO_UNIT_ID UnitId;
                                                    WINBIO_REJECT_DETAIL RejectDetail;
                                                } Unclaimed;

    case WINBIO_EVENT_FP_UNCLAIMED_IDENTIFY:    struct {
                                                    WINBIO_UNIT_ID UnitId;
                                                    WINBIO_IDENTITY Identity;
                                                    WINBIO_BIOMETRIC_SUBTYPE SubFactor;
                                                    WINBIO_REJECT_DETAIL RejectDetail;
                                                } UnclaimedIdentify;

    case WINBIO_EVENT_ERROR:                    struct {
                                                    HRESULT ErrorCode;
                                                } Error;
} WINBIO_EVENT, *PWINBIO_EVENT;

#else // MIDL_PASS

//
// Generic events
//
#define WINBIO_EVENT_ERROR                  ((WINBIO_EVENT_TYPE)0xFFFFFFFF)

//
// Fingerprint events.
//
#define WINBIO_EVENT_FP_UNCLAIMED           ((WINBIO_EVENT_TYPE)0x00000001)
#define WINBIO_EVENT_FP_UNCLAIMED_IDENTIFY  ((WINBIO_EVENT_TYPE)0x00000002)


//
// Event structure passed back to applications.
//
typedef struct _WINBIO_EVENT {
    WINBIO_EVENT_TYPE Type;
    union {
        struct {
            WINBIO_UNIT_ID UnitId;
            WINBIO_REJECT_DETAIL RejectDetail;
        } Unclaimed;
        struct {
            WINBIO_UNIT_ID UnitId;
            WINBIO_IDENTITY Identity;
            WINBIO_BIOMETRIC_SUBTYPE SubFactor;
            WINBIO_REJECT_DETAIL RejectDetail;
        } UnclaimedIdentify;
        struct {
            HRESULT ErrorCode;
        } Error;
    } Parameters;
} WINBIO_EVENT, *PWINBIO_EVENT;

#endif // MIDL_PASS

///////////////////////////////////////////////////////////////////////////////
//
// Schemata returned by enumeration APIs...
//
///////////////////////////////////////////////////////////////////////////////
//
// Results from EnumServiceProviders...
//
typedef struct _WINBIO_BSP_SCHEMA {
    WINBIO_BIOMETRIC_TYPE BiometricFactor;
    WINBIO_UUID BspId;
    WINBIO_STRING Description;
    WINBIO_STRING Vendor;
    WINBIO_VERSION Version;
} WINBIO_BSP_SCHEMA, *PWINBIO_BSP_SCHEMA;

//
// Results from EnumBiometricUnits...
//
typedef struct _WINBIO_UNIT_SCHEMA {
    WINBIO_UNIT_ID UnitId;
    WINBIO_POOL_TYPE PoolType;
    WINBIO_BIOMETRIC_TYPE BiometricFactor;
    WINBIO_BIOMETRIC_SENSOR_SUBTYPE SensorSubType;
    WINBIO_CAPABILITIES Capabilities;
    WINBIO_STRING DeviceInstanceId;
    WINBIO_STRING Description;
    WINBIO_STRING Manufacturer;
    WINBIO_STRING Model;
    WINBIO_STRING SerialNumber;
    WINBIO_VERSION FirmwareVersion;
} WINBIO_UNIT_SCHEMA, *PWINBIO_UNIT_SCHEMA;

///////////////////////////////////////////////////////////////////////////////
//
// Definitions for the 'Attributes' database value...
//
///////////////////////////////////////////////////////////////////////////////
#define WINBIO_DATABASE_TYPE_MASK       ((ULONG)0x0000FFFF)
//
// Type values...
//
#define WINBIO_DATABASE_TYPE_FILE       ((ULONG)0x00000001)
#define WINBIO_DATABASE_TYPE_DBMS       ((ULONG)0x00000002)
#define WINBIO_DATABASE_TYPE_ONCHIP     ((ULONG)0x00000003)
#define WINBIO_DATABASE_TYPE_SMARTCARD  ((ULONG)0x00000004)

#define WINBIO_DATABASE_FLAG_MASK       ((ULONG)0xFFFF0000)
//
// Flag values...
//
#define WINBIO_DATABASE_FLAG_REMOVABLE  ((ULONG)0x00010000)
#define WINBIO_DATABASE_FLAG_REMOTE     ((ULONG)0x00020000)

//
// Results from EnumDatabases...
//
typedef struct _WINBIO_STORAGE_SCHEMA {
    WINBIO_BIOMETRIC_TYPE BiometricFactor;
    WINBIO_UUID DatabaseId;
    WINBIO_UUID DataFormat;
    ULONG Attributes;
    WINBIO_STRING FilePath;
    WINBIO_STRING ConnectionString;
} WINBIO_STORAGE_SCHEMA, *PWINBIO_STORAGE_SCHEMA;

///////////////////////////////////////////////////////////////////////////////
//
// Credential management
//
///////////////////////////////////////////////////////////////////////////////

typedef enum _WINBIO_CREDENTIAL_TYPE
{
    WINBIO_CREDENTIAL_PASSWORD  = 0x00000001,
    WINBIO_CREDENTIAL_ALL = 0xffffffff,
} WINBIO_CREDENTIAL_TYPE;

typedef enum _WINBIO_CREDENTIAL_FORMAT
{
    WINBIO_PASSWORD_GENERIC     = 0x00000001,
    WINBIO_PASSWORD_PACKED      = 0x00000002,
} WINBIO_CREDENTIAL_FORMAT;

typedef enum _WINBIO_CREDENTIAL_STATE {
    WINBIO_CREDENTIAL_NOT_SET   = 0x00000001,
    WINBIO_CREDENTIAL_SET       = 0x00000002,
} WINBIO_CREDENTIAL_STATE, *PWINBIO_CREDENTIAL_STATE;

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// Settings
//
///////////////////////////////////////////////////////////////////////////////

typedef ULONG32 WINBIO_SETTING_SOURCE_TYPE, *PWINBIO_SETTING_SOURCE_TYPE;

#define WINBIO_SETTING_SOURCE_INVALID    ((WINBIO_SETTING_SOURCE_TYPE)0)
#define WINBIO_SETTING_SOURCE_DEFAULT    ((WINBIO_SETTING_SOURCE_TYPE)1)
#define WINBIO_SETTING_SOURCE_POLICY     ((WINBIO_SETTING_SOURCE_TYPE)2)
#define WINBIO_SETTING_SOURCE_LOCAL      ((WINBIO_SETTING_SOURCE_TYPE)3)


#ifdef __cplusplus
} // extern "C"
#endif

#pragma warning( pop )

#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#endif // _WINBIO_TYPES_H_712486DB_3EF5_41da_937A_55DCB7B66A53_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinBer.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    winber.h   Basic Encoding Rules (BER) API header file

Abstract:

   This module is the header file for the 32 bit BER library on
   Windows NT and Windows 95.

Updates :

Environments :

    Win32 user mode

--*/

//
// Only pull in this header file once.
//

#ifndef _WINBER_DEFINED_
#define _WINBER_DEFINED_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_WINBER_)
#define WINBERAPI DECLSPEC_IMPORT
#else
//#define WINBERAPI __declspec(dllexport)
#define WINBERAPI
#endif

#ifndef BERAPI
#define BERAPI __cdecl
#endif

#define LBER_ERROR   0xffffffffL
#define LBER_DEFAULT 0xffffffffL

typedef unsigned int ber_tag_t;   /* for BER tags */
typedef int ber_int_t;            /* for BER ints, enums, and Booleans */
typedef unsigned int ber_uint_t;  /* unsigned equivalent of ber_int_t */
typedef unsigned int ber_len_t;   /* for BER octet strings and bit strings */
typedef int ber_slen_t;           /* signed equivalent of ber_len_t */

//
// This constructs a new BerElement structure containing a copy of the
// data in the supplied berval structure.
//

WINBERAPI BerElement * BERAPI ber_init( BERVAL *pBerVal );

//
// This frees a BerElement which is returned from ber_alloc_t()
// or ber_init(). The second argument - fbuf should always be set
// to 1.
//
//

WINBERAPI VOID BERAPI ber_free( BerElement *pBerElement, INT fbuf );

//
// Frees a BERVAL structure. Applications should not call
// this API to free BERVAL structures which they themselves
// have allocated
//

WINBERAPI VOID BERAPI ber_bvfree( BERVAL *pBerVal );


//
// Frees an array of BERVAL structures.
//

WINBERAPI VOID BERAPI ber_bvecfree( PBERVAL *pBerVal );

//
// Returns a copy of a the supplied berval structure
//

WINBERAPI BERVAL * BERAPI ber_bvdup( BERVAL *pBerVal );


//
// Constructs and returns a BerElement structure. The options field
// contains a bitwise-or of options which are to be used when generating
// the encoding of the BerElement
//
// The LBER_USE_DER options should always be specified.
//

WINBERAPI BerElement * BERAPI ber_alloc_t( INT options );


//
// This skips over the current tag and returns the tag of the next
// element in the supplied BerElement. The lenght of this element is
// stored in the pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//
// The difference between ber_skip_tag() and ber_peek_tag() is that the
// state pointer is advanced past the first tag+lenght and is pointed to
// the value part of the next element
//

WINBERAPI ULONG BERAPI ber_skip_tag( BerElement *pBerElement, ULONG *pLen );

//
// This returns the tag of the next element to be parsed in the
// supplied BerElement. The length of this element is stored in the
// pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//

WINBERAPI ULONG BERAPI ber_peek_tag( BerElement *pBerElement, ULONG *pLen);

//
// This returns the tag and length of the first element in a SET, SET OF
// or SEQUENCE OF data value.
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned. It also returns an opaque cookie which has to be passed to
// subsequent invocations of ber_next_element().
//

WINBERAPI ULONG BERAPI ber_first_element( BerElement *pBerElement, ULONG *pLen, __out CHAR **ppOpaque );

//
// This positions the state at the start of the next element in the
// constructed type.
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned.
//

WINBERAPI ULONG BERAPI ber_next_element( BerElement *pBerElement, ULONG *pLen, __in CHAR *opaque );

//
// This allocates a BerVal structure whose contents are taken from the
// supplied BerElement structure.
//
// The return values are 0 on success and -1 on error.
//

WINBERAPI INT BERAPI ber_flatten( BerElement *pBerElement, PBERVAL *pBerVal );


/*
The ber_printf() routine is used to encode a BER element in much the
same way that sprintf() works.  One important difference, though, is
that state information is kept in the ber argument so that multiple
calls can be made to ber_printf() to append to the end of the BER ele-
ment. ber MUST be a pointer to a BerElement returned by ber_alloc_t().
ber_printf() interprets and formats its arguments according to the for-
mat string fmt.  ber_printf() returns -1 if there is an error during
encoding and a non-negative number if successful.  As with sprintf(),
each character in fmt refers to an argument to ber_printf().
 
The format string can contain the following format characters:

't'     Tag.  The next argument is a ber_tag_t specifying the tag to
        override the next element to be written to the ber.  This works
        across calls.  The integer tag value SHOULD contain the tag
        class, constructed bit, and tag value.  For example, a tag of
        "[3]" for a constructed type is 0xA3U.  All implementations MUST
        support tags that fit in a single octet (i.e., where the tag
        value is less than 32) and they MAY support larger tags.

'b'     Boolean.  The next argument is an ber_int_t, containing either 0
        for FALSE or 0xff for TRUE.  A boolean element is output.  If
        this format character is not preceded by the 't' format modif-
        ier, the tag 0x01U is used for the element.

'e'     Enumerated.  The next argument is a ber_int_t, containing the
        enumerated value in the host's byte order.  An enumerated ele-
        ment is output.  If this format character is not preceded by the
        't' format modifier, the tag 0x0AU is used for the element.

'i'     Integer.  The next argument is a ber_int_t, containing the
        integer in the host's byte order.  An integer element is output.
        If this format character is not preceded by the 't' format
        modifier, the tag 0x02U is used for the element.

'n'     Null.  No argument is needed.  An ASN.1 NULL element is output.
        If this format character is not preceded by the 't' format
        modifier, the tag 0x05U is used for the element.
        
'o'     Octet string.  The next two arguments are a char *, followed by
        a ber_len_t with the length of the string.  The string MAY con-
        tain null bytes and are do not have to be zero-terminated.   An
        octet string element is output, in primitive form.  If this for-
        mat character is not preceded by the 't' format modifier, the
        tag 0x04U is used for the element.

's'     Octet string.  The next argument is a char * pointing to a
        zero-terminated string.  An octet string element in primitive
        form is output, which does not include the trailing '\0' (null)
        byte. If this format character is not preceded by the 't' format
        modifier, the tag 0x04U is used for the element.

'v'     Several octet strings.  The next argument is a char **, an array
        of char * pointers to zero-terminated strings.  The last element
        in the array MUST be a NULL pointer. The octet strings do not
        include the trailing '\0' (null) byte.  Note that a construct
        like '{v}' is used to get an actual SEQUENCE OF octet strings.
        The 't' format modifier cannot be used with this format charac-
        ter.

'V'     Several octet strings.  A NULL-terminated array of struct berval
        *'s is supplied.  Note that a construct like '{V}' is used to
        get an actual SEQUENCE OF octet strings. The 't' format modifier
        cannot be used with this format character.

'{'     Begin sequence.  No argument is needed.  If this format charac-
        ter is not preceded by the 't' format modifier, the tag 0x30U is
        used.

'}'     End sequence.  No argument is needed.  The 't' format modifier
        cannot be used with this format character.

'['     Begin set.  No argument is needed.  If this format character is
        not preceded by the 't' format modifier, the tag 0x31U is used.

']'     End set.  No argument is needed.  The 't' format modifier cannot
        be used with this format character.
*/

WINBERAPI INT BERAPI ber_printf( BerElement *pBerElement, __in PCHAR fmt, ... );

/*
The ber_scanf() routine is used to decode a BER element in much the same
way that sscanf() works.  One important difference, though, is that some
state information is kept with the ber argument so that multiple calls
can be made to ber_scanf() to sequentially read from the BER element.
The ber argument SHOULD be a pointer to a BerElement returned by
ber_init().  ber_scanf interprets the bytes according to the format
string fmt, and stores the results in its additional arguments.
ber_scanf() returns LBER_ERROR on error, and a different value on suc-
cess.

The format string contains conversion specifications which are used to
direct the interpretation of the BER element.  The format string can
contain the following characters:

'a'     Octet string.  A char ** argument MUST be supplied.  Memory is
        allocated, filled with the contents of the octet string, zero-
        terminated, and the pointer to the string is stored in the argu-
        ment.  The returned value SHOULD be freed using ldap_memfree.
        The tag of the element MUST indicate the primitive form
        (constructed strings are not supported) but is otherwise ignored
        and discarded during the decoding.  This format cannot be used
        with octet strings which could contain null bytes.        
        
'O'     Octet string.  A struct berval ** argument MUST be supplied,
        which upon return points to an allocated struct berval contain-
        ing the octet string and its length.  ber_bvfree() SHOULD be
        called to free the allocated memory.  The tag of the element
        MUST indicate the primitive form (constructed strings are not
        supported) but is otherwise ignored during the decoding.

'b'     Boolean.  A pointer to a ber_int_t MUST be supplied. The
        ber_int_t value stored will be 0 for FALSE or nonzero for TRUE.
        The tag of the element MUST indicate the primitive form but is
        otherwise ignored during the decoding.

'e'     Enumerated.  A pointer to a ber_int_t MUST be supplied. The
        enumerated value stored will be in host byte order.  The tag of
        the element MUST indicate the primitive form but is otherwise
        ignored during the decoding.  ber_scanf() will return an error
        if the value of the enumerated value cannot be stored in a
        ber_int_t.

'i'     Integer.  A pointer to a ber_int_t MUST be supplied. The
        ber_int_t value stored will be in host byte order.  The tag of
        the element MUST indicate the primitive form but is otherwise
        ignored during the decoding.  ber_scanf() will return an error
        if the integer cannot be stored in a ber_int_t.

'B'     Bitstring.  A char ** argument MUST be supplied which will point
        to the allocated bits, followed by a ber_len_t * argument, which
        will point to the length (in bits) of the bitstring returned.
        ldap_memfree SHOULD be called to free the bitstring.  The tag of
        the element MUST indicate the primitive form (constructed bit-
        strings are not supported) but is otherwise ignored during the
        decoding.

'n'     Null.  No argument is needed.  The element is verified to have a
        zero-length value and is skipped.  The tag is ignored.

'v'     Several octet strings.  A char *** argument MUST be supplied,
        which upon return points to an allocated NULL-terminated array
        of char *'s containing the octet strings.  NULL is stored if the
        sequence is empty.  ldap_memfree SHOULD be called to free each
        element of the array and the array itself.  The tag of the
        sequence and of the octet strings are ignored.

'V'     Several octet strings (which could contain null bytes).  A
        struct berval *** MUST be supplied, which upon return points to
        a allocated NULL-terminated array of struct berval *'s contain-
        ing the octet strings and their lengths.  NULL is stored if the
        sequence is empty. ber_bvecfree() can be called to free the
        allocated memory.  The tag of the sequence and of the octet
        strings are ignored.

'x'     Skip element.  The next element is skipped.  No argument is
        needed.

'{'     Begin sequence.  No argument is needed.  The initial sequence
        tag and length are skipped.

'}'     End sequence.  No argument is needed.

'['     Begin set.  No argument is needed.  The initial set tag and
        length are skipped.

']'     End set.  No argument is needed.

*/

WINBERAPI ULONG BERAPI ber_scanf( BerElement *pBerElement, __in PCHAR fmt, ... );


#ifdef __cplusplus
}
#endif


#endif  // _WINBER_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wincodecsdk.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wincodecsdk.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wincodecsdk_h__
#define __wincodecsdk_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWICMetadataBlockReader_FWD_DEFINED__
#define __IWICMetadataBlockReader_FWD_DEFINED__
typedef interface IWICMetadataBlockReader IWICMetadataBlockReader;
#endif 	/* __IWICMetadataBlockReader_FWD_DEFINED__ */


#ifndef __IWICMetadataBlockWriter_FWD_DEFINED__
#define __IWICMetadataBlockWriter_FWD_DEFINED__
typedef interface IWICMetadataBlockWriter IWICMetadataBlockWriter;
#endif 	/* __IWICMetadataBlockWriter_FWD_DEFINED__ */


#ifndef __IWICMetadataReader_FWD_DEFINED__
#define __IWICMetadataReader_FWD_DEFINED__
typedef interface IWICMetadataReader IWICMetadataReader;
#endif 	/* __IWICMetadataReader_FWD_DEFINED__ */


#ifndef __IWICMetadataWriter_FWD_DEFINED__
#define __IWICMetadataWriter_FWD_DEFINED__
typedef interface IWICMetadataWriter IWICMetadataWriter;
#endif 	/* __IWICMetadataWriter_FWD_DEFINED__ */


#ifndef __IWICStreamProvider_FWD_DEFINED__
#define __IWICStreamProvider_FWD_DEFINED__
typedef interface IWICStreamProvider IWICStreamProvider;
#endif 	/* __IWICStreamProvider_FWD_DEFINED__ */


#ifndef __IWICPersistStream_FWD_DEFINED__
#define __IWICPersistStream_FWD_DEFINED__
typedef interface IWICPersistStream IWICPersistStream;
#endif 	/* __IWICPersistStream_FWD_DEFINED__ */


#ifndef __IWICMetadataHandlerInfo_FWD_DEFINED__
#define __IWICMetadataHandlerInfo_FWD_DEFINED__
typedef interface IWICMetadataHandlerInfo IWICMetadataHandlerInfo;
#endif 	/* __IWICMetadataHandlerInfo_FWD_DEFINED__ */


#ifndef __IWICMetadataReaderInfo_FWD_DEFINED__
#define __IWICMetadataReaderInfo_FWD_DEFINED__
typedef interface IWICMetadataReaderInfo IWICMetadataReaderInfo;
#endif 	/* __IWICMetadataReaderInfo_FWD_DEFINED__ */


#ifndef __IWICMetadataWriterInfo_FWD_DEFINED__
#define __IWICMetadataWriterInfo_FWD_DEFINED__
typedef interface IWICMetadataWriterInfo IWICMetadataWriterInfo;
#endif 	/* __IWICMetadataWriterInfo_FWD_DEFINED__ */


#ifndef __IWICComponentFactory_FWD_DEFINED__
#define __IWICComponentFactory_FWD_DEFINED__
typedef interface IWICComponentFactory IWICComponentFactory;
#endif 	/* __IWICComponentFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "wincodec.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wincodecsdk_0000_0000 */
/* [local] */ 

DEFINE_GUID(GUID_MetadataFormatUnknown, 0xA45E592F, 0x9078, 0x4A7C, 0xAD, 0xB5, 0x4E, 0xDC, 0x4F, 0xD6, 0x1B, 0x1F);
DEFINE_GUID(GUID_MetadataFormatIfd, 0x537396C6, 0x2D8A, 0x4BB6, 0x9B, 0xF8, 0x2F, 0x0A, 0x8E, 0x2A, 0x3A, 0xDF);
DEFINE_GUID(GUID_MetadataFormatSubIfd, 0x58A2E128, 0x2DB9, 0x4E57, 0xBB, 0x14, 0x51, 0x77, 0x89, 0x1E, 0xD3, 0x31);
DEFINE_GUID(GUID_MetadataFormatExif, 0x1C3C4F9D, 0xB84A, 0x467D, 0x94, 0x93, 0x36, 0xCF, 0xBD, 0x59, 0xEA, 0x57);
DEFINE_GUID(GUID_MetadataFormatGps, 0x7134AB8A, 0x9351, 0x44AD, 0xAF, 0x62, 0x44, 0x8D, 0xB6, 0xB5, 0x02, 0xEC);
DEFINE_GUID(GUID_MetadataFormatInterop, 0xED686F8E, 0x681F, 0x4C8B, 0xBD, 0x41, 0xA8, 0xAD, 0xDB, 0xF6, 0xB3, 0xFC);
DEFINE_GUID(GUID_MetadataFormatApp0, 0x79007028, 0x268D, 0x45d6, 0xA3, 0xC2, 0x35, 0x4E, 0x6A, 0x50, 0x4B, 0xC9);
DEFINE_GUID(GUID_MetadataFormatApp1,  0x8FD3DFC3, 0xF951, 0x492B, 0x81, 0x7F, 0x69, 0xC2, 0xE6, 0xD9, 0xA5, 0xB0);
DEFINE_GUID(GUID_MetadataFormatApp13, 0x326556A2, 0xF502, 0x4354, 0x9C, 0xC0, 0x8E, 0x3F, 0x48, 0xEA, 0xF6, 0xB5);
DEFINE_GUID(GUID_MetadataFormatIPTC, 0x4FAB0914, 0xE129, 0x4087, 0xA1, 0xD1, 0xBC, 0x81, 0x2D, 0x45, 0xA7, 0xB5);
DEFINE_GUID(GUID_MetadataFormatIRB,      0x16100D66, 0x8570, 0x4BB9, 0xB9, 0x2D, 0xFD, 0xA4, 0xB2, 0x3E, 0xCE, 0x67);
DEFINE_GUID(GUID_MetadataFormat8BIMIPTC, 0x0010568c, 0x0852, 0x4e6a, 0xb1, 0x91, 0x5c, 0x33, 0xac, 0x5b, 0x04, 0x30);
DEFINE_GUID(GUID_MetadataFormat8BIMResolutionInfo, 0x739F305D, 0x81DB, 0x43CB, 0xAC, 0x5E, 0x55, 0x01, 0x3E, 0xF9, 0xF0, 0x03);
DEFINE_GUID(GUID_MetadataFormat8BIMIPTCDigest,     0x1CA32285, 0x9CCD, 0x4786, 0x8B, 0xD8, 0x79, 0x53, 0x9D, 0xB6, 0xA0, 0x06);
DEFINE_GUID(GUID_MetadataFormatXMP, 0xBB5ACC38, 0xF216, 0x4CEC, 0xA6, 0xC5, 0x5F, 0x6E, 0x73, 0x97, 0x63, 0xA9);
DEFINE_GUID(GUID_MetadataFormatThumbnail, 0x243dcee9, 0x8703, 0x40ee, 0x8e, 0xf0, 0x22, 0xa6, 0x0, 0xb8, 0x5, 0x8c);
DEFINE_GUID(GUID_MetadataFormatChunktEXt, 0x568d8936, 0xc0a9, 0x4923, 0x90, 0x5d, 0xdf, 0x2b, 0x38, 0x23, 0x8f, 0xbc);
DEFINE_GUID(GUID_MetadataFormatXMPStruct, 0x22383CF1, 0xED17, 0x4E2E, 0xAF, 0x17, 0xD8, 0x5B, 0x8F, 0x6B, 0x30, 0xD0);
DEFINE_GUID(GUID_MetadataFormatXMPBag, 0x833CCA5F, 0xDCB7, 0x4516, 0x80, 0x6F, 0x65, 0x96, 0xAB, 0x26, 0xDC, 0xE4);
DEFINE_GUID(GUID_MetadataFormatXMPSeq, 0x63E8DF02, 0xEB6C,0x456C, 0xA2, 0x24, 0xB2, 0x5E, 0x79, 0x4F, 0xD6, 0x48);
DEFINE_GUID(GUID_MetadataFormatXMPAlt, 0x7B08A675, 0x91AA, 0x481B, 0xA7, 0x98, 0x4D, 0xA9, 0x49, 0x08, 0x61, 0x3B);
DEFINE_GUID(GUID_MetadataFormatLSD, 0xE256031E, 0x6299, 0x4929, 0xB9, 0x8D, 0x5A, 0xC8, 0x84, 0xAF, 0xBA, 0x92);
DEFINE_GUID(GUID_MetadataFormatIMD, 0xBD2BB086, 0x4D52, 0x48DD, 0x96, 0x77, 0xDB, 0x48, 0x3E, 0x85, 0xAE, 0x8F);
DEFINE_GUID(GUID_MetadataFormatGCE, 0x2A25CAD8, 0xDEEB, 0x4C69, 0xA7, 0x88, 0xE, 0xC2, 0x26, 0x6D, 0xCA, 0xFD);
DEFINE_GUID(GUID_MetadataFormatAPE, 0x2E043DC2, 0xC967, 0x4E05, 0x87, 0x5E, 0x61, 0x8B, 0xF6, 0x7E, 0x85, 0xC3);
DEFINE_GUID(GUID_MetadataFormatJpegChrominance, 0xF73D0DCF, 0xCEC6, 0x4F85, 0x9B, 0x0E, 0x1C, 0x39, 0x56, 0xB1, 0xBE, 0xF7);
DEFINE_GUID(GUID_MetadataFormatJpegLuminance, 0x86908007, 0xEDFC, 0x4860, 0x8D, 0x4B, 0x4E, 0xE6, 0xE8, 0x3E, 0x60, 0x58);
DEFINE_GUID(GUID_MetadataFormatJpegComment, 0x220E5F33, 0xAFD3, 0x474E, 0x9D, 0x31, 0x7D, 0x4F, 0xE7, 0x30, 0xF5, 0x57);
DEFINE_GUID(GUID_MetadataFormatGifComment, 0xC4B6E0E0, 0xCFB4, 0x4AD3, 0xAB, 0x33, 0x9A, 0xAD, 0x23, 0x55, 0xA3, 0x4A);
DEFINE_GUID(GUID_MetadataFormatChunkgAMA, 0xF00935A5, 0x1D5D, 0x4CD1, 0x81, 0xB2, 0x93, 0x24, 0xD7, 0xEC, 0xA7, 0x81);
DEFINE_GUID(GUID_MetadataFormatChunkbKGD, 0xE14D3571, 0x6B47, 0x4DEA, 0xB6, 0xA, 0x87, 0xCE, 0xA, 0x78, 0xDF, 0xB7);
DEFINE_GUID(GUID_MetadataFormatChunkiTXt, 0xC2BEC729, 0xB68, 0x4B77, 0xAA, 0xE, 0x62, 0x95, 0xA6, 0xAC, 0x18, 0x14);
DEFINE_GUID(GUID_MetadataFormatChunkcHRM, 0x9DB3655B, 0x2842, 0x44B3, 0x80, 0x67, 0x12, 0xE9, 0xB3, 0x75, 0x55, 0x6A);
DEFINE_GUID(GUID_MetadataFormatChunkhIST, 0xC59A82DA, 0xDB74, 0x48A4, 0xBD, 0x6A, 0xB6, 0x9C, 0x49, 0x31, 0xEF, 0x95);
DEFINE_GUID(GUID_MetadataFormatChunkiCCP, 0xEB4349AB, 0xB685, 0x450F, 0x91, 0xB5, 0xE8, 0x2, 0xE8, 0x92, 0x53, 0x6C);
DEFINE_GUID(GUID_MetadataFormatChunksRGB, 0xC115FD36, 0xCC6F, 0x4E3F, 0x83, 0x63, 0x52, 0x4B, 0x87, 0xC6, 0xB0, 0xD9);
DEFINE_GUID(GUID_MetadataFormatChunktIME, 0x6B00AE2D, 0xE24B, 0x460A, 0x98, 0xB6, 0x87, 0x8B, 0xD0, 0x30, 0x72, 0xFD);
DEFINE_GUID(CLSID_WICUnknownMetadataReader, 0x699745c2, 0x5066, 0x4b82, 0xa8, 0xe3, 0xd4, 0x4, 0x78, 0xdb, 0xec, 0x8c);
DEFINE_GUID(CLSID_WICUnknownMetadataWriter, 0xa09cca86, 0x27ba, 0x4f39, 0x90, 0x53, 0x12, 0x1f, 0xa4, 0xdc, 0x8, 0xfc);
DEFINE_GUID(CLSID_WICApp0MetadataWriter, 0xF3C633A2, 0x46C8, 0x498e, 0x8F, 0xBB, 0xCC, 0x6F, 0x72, 0x1B, 0xBC, 0xDE);
DEFINE_GUID(CLSID_WICApp0MetadataReader, 0x43324B33, 0xA78F, 0x480f, 0x91, 0x11, 0x96, 0x38, 0xAA, 0xCC, 0xC8, 0x32);
DEFINE_GUID(CLSID_WICApp1MetadataWriter, 0xee366069, 0x1832, 0x420f, 0xb3, 0x81, 0x04, 0x79, 0xad, 0x06, 0x6f, 0x19);
DEFINE_GUID(CLSID_WICApp1MetadataReader, 0xdde33513, 0x774e, 0x4bcd, 0xae, 0x79, 0x02, 0xf4, 0xad, 0xfe, 0x62, 0xfc);
DEFINE_GUID(CLSID_WICApp13MetadataWriter, 0x7B19A919, 0xA9D6, 0x49E5, 0xBD, 0x45, 0x02, 0xC3, 0x4E, 0x4E, 0x4C, 0xD5);
DEFINE_GUID(CLSID_WICApp13MetadataReader, 0xAA7E3C50, 0x864C, 0x4604, 0xBC, 0x04, 0x8B, 0x0B, 0x76, 0xE6, 0x37, 0xF6);
DEFINE_GUID(CLSID_WICIfdMetadataReader, 0x8f914656, 0x9d0a, 0x4eb2, 0x90, 0x19, 0xb, 0xf9, 0x6d, 0x8a, 0x9e, 0xe6);
DEFINE_GUID(CLSID_WICIfdMetadataWriter, 0xb1ebfc28, 0xc9bd, 0x47a2, 0x8d, 0x33, 0xb9, 0x48, 0x76, 0x97, 0x77, 0xa7);
DEFINE_GUID(CLSID_WICSubIfdMetadataReader, 0x50D42F09, 0xECD1, 0x4B41, 0xB6, 0x5D, 0xDA, 0x1F, 0xDA, 0xA7, 0x56, 0x63);
DEFINE_GUID(CLSID_WICSubIfdMetadataWriter, 0x8ADE5386, 0x8E9B, 0x4F4C, 0xAC, 0xF2, 0xF0, 0x00, 0x87, 0x06, 0xB2, 0x38);
DEFINE_GUID(CLSID_WICExifMetadataReader, 0xd9403860, 0x297f, 0x4a49, 0xbf, 0x9b, 0x77, 0x89, 0x81, 0x50, 0xa4, 0x42);
DEFINE_GUID(CLSID_WICExifMetadataWriter, 0xc9a14cda, 0xc339, 0x460b, 0x90, 0x78, 0xd4, 0xde, 0xbc, 0xfa, 0xbe, 0x91);
DEFINE_GUID(CLSID_WICGpsMetadataReader, 0x3697790B, 0x223B, 0x484E, 0x99, 0x25, 0xC4, 0x86, 0x92, 0x18, 0xF1, 0x7A);
DEFINE_GUID(CLSID_WICGpsMetadataWriter, 0xCB8C13E4, 0x62B5, 0x4C96, 0xA4, 0x8B, 0x6B, 0xA6, 0xAC, 0xE3, 0x9C, 0x76);
DEFINE_GUID(CLSID_WICInteropMetadataReader, 0xB5C8B898, 0x0074, 0x459F, 0xB7, 0x00, 0x86, 0x0D, 0x46, 0x51, 0xEA, 0x14);
DEFINE_GUID(CLSID_WICInteropMetadataWriter, 0x122EC645, 0xCD7E, 0x44D8, 0xB1, 0x86, 0x2C, 0x8C, 0x20, 0xC3, 0xB5, 0x0F);
DEFINE_GUID(CLSID_WICThumbnailMetadataReader, 0xfb012959, 0xf4f6, 0x44d7, 0x9d, 0x9, 0xda, 0xa0, 0x87, 0xa9, 0xdb, 0x57);
DEFINE_GUID(CLSID_WICThumbnailMetadataWriter, 0xd049b20c, 0x5dd0, 0x44fe, 0xb0, 0xb3, 0x8f, 0x92, 0xc8, 0xe6, 0xd0, 0x80);
DEFINE_GUID(CLSID_WICIPTCMetadataReader, 0x03012959, 0xf4f6, 0x44d7, 0x9d, 0x9, 0xda, 0xa0, 0x87, 0xa9, 0xdb, 0x57);
DEFINE_GUID(CLSID_WICIPTCMetadataWriter, 0x1249b20c, 0x5dd0, 0x44fe, 0xb0, 0xb3, 0x8f, 0x92, 0xc8, 0xe6, 0xd0, 0x80);
DEFINE_GUID(CLSID_WICIRBMetadataReader, 0xD4DCD3D7, 0xB4C2, 0x47D9, 0xA6, 0xBF, 0xB8, 0x9B, 0xA3, 0x96, 0xA4, 0xA3);
DEFINE_GUID(CLSID_WICIRBMetadataWriter,      0x5C5C1935, 0x0235, 0x4434, 0x80, 0xBC, 0x25, 0x1B, 0xC1, 0xEC, 0x39, 0xC6);
DEFINE_GUID(CLSID_WIC8BIMIPTCMetadataReader, 0x0010668c, 0x0801, 0x4da6, 0xa4, 0xa4, 0x82, 0x65, 0x22, 0xb6, 0xd2, 0x8f);
DEFINE_GUID(CLSID_WIC8BIMIPTCMetadataWriter, 0x00108226, 0xee41, 0x44a2, 0x9e, 0x9c, 0x4b, 0xe4, 0xd5, 0xb1, 0xd2, 0xcd);
DEFINE_GUID(CLSID_WIC8BIMResolutionInfoMetadataReader, 0x5805137A, 0xE348, 0x4F7C, 0xB3, 0xCC, 0x6D, 0xB9, 0x96, 0x5A, 0x05, 0x99);
DEFINE_GUID(CLSID_WIC8BIMResolutionInfoMetadataWriter, 0x4ff2fe0e, 0xe74a, 0x4b71, 0x98, 0xc4, 0xab, 0x7d, 0xc1, 0x67, 0x7, 0xba);
DEFINE_GUID(CLSID_WIC8BIMIPTCDigestMetadataReader, 0x02805F1E, 0xD5AA, 0x415b, 0x82, 0xC5, 0x61, 0xC0, 0x33, 0xA9, 0x88, 0xA6);
DEFINE_GUID(CLSID_WIC8BIMIPTCDigestMetadataWriter, 0x2DB5E62B, 0x0D67, 0x495f, 0x8F, 0x9D, 0xC2, 0xF0, 0x18, 0x86, 0x47, 0xAC);
DEFINE_GUID(CLSID_WICPngTextMetadataReader, 0x4b59afcc, 0xb8c3, 0x408a, 0xb6, 0x70, 0x89, 0xe5, 0xfa, 0xb6, 0xfd, 0xa7); 
DEFINE_GUID(CLSID_WICPngTextMetadataWriter, 0xb5ebafb9, 0x253e, 0x4a72, 0xa7, 0x44, 0x7, 0x62, 0xd2, 0x68, 0x56, 0x83); 
DEFINE_GUID(CLSID_WICXMPMetadataReader, 0x72B624DF, 0xAE11, 0x4948, 0xA6, 0x5C, 0x35, 0x1E, 0xB0, 0x82, 0x94, 0x19);
DEFINE_GUID(CLSID_WICXMPMetadataWriter, 0x1765E14E, 0x1BD4, 0x462E, 0xB6, 0xB1, 0x59, 0x0B, 0xF1, 0x26, 0x2A, 0xC6);
DEFINE_GUID(CLSID_WICXMPStructMetadataReader, 0x01B90D9A, 0x8209, 0x47F7, 0x9C, 0x52, 0xE1, 0x24, 0x4B, 0xF5, 0x0C, 0xED);
DEFINE_GUID(CLSID_WICXMPStructMetadataWriter, 0x22C21F93, 0x7DDB, 0x411C, 0x9B, 0x17, 0xC5, 0xB7, 0xBD, 0x06, 0x4A, 0xBC);
DEFINE_GUID(CLSID_WICXMPBagMetadataReader, 0xE7E79A30, 0x4F2C, 0x4FAB, 0x8D, 0x00, 0x39, 0x4F, 0x2D, 0x6B, 0xBE, 0xBE);
DEFINE_GUID(CLSID_WICXMPBagMetadataWriter, 0xED822C8C, 0xD6BE, 0x4301, 0xA6, 0x31, 0x0E, 0x14, 0x16, 0xBA, 0xD2, 0x8F);
DEFINE_GUID(CLSID_WICXMPSeqMetadataReader, 0x7F12E753, 0xFC71, 0x43D7, 0xA5, 0x1D, 0x92, 0xF3, 0x59, 0x77, 0xAB, 0xB5);
DEFINE_GUID(CLSID_WICXMPSeqMetadataWriter, 0x6D68D1DE, 0xD432, 0x4B0F, 0x92, 0x3A, 0x09, 0x11, 0x83, 0xA9, 0xBD, 0xA7);
DEFINE_GUID(CLSID_WICXMPAltMetadataReader, 0xAA94DCC2, 0xB8B0, 0x4898, 0xB8, 0x35, 0x00, 0x0A, 0xAB, 0xD7, 0x43, 0x93);
DEFINE_GUID(CLSID_WICXMPAltMetadataWriter, 0x076C2A6C, 0xF78F, 0x4C46, 0xA7, 0x23, 0x35, 0x83, 0xE7, 0x08, 0x76, 0xEA);
DEFINE_GUID(CLSID_WICLSDMetadataReader, 0x41070793, 0x59E4, 0x479A, 0xA1, 0xF7, 0x95, 0x4A, 0xDC, 0x2E, 0xF5, 0xFC);
DEFINE_GUID(CLSID_WICLSDMetadataWriter, 0x73C037E7, 0xE5D9, 0x4954, 0x87, 0x6A, 0x6D, 0xA8, 0x1D, 0x6E, 0x57, 0x68);
DEFINE_GUID(CLSID_WICGCEMetadataReader, 0xB92E345D, 0xF52D, 0x41F3, 0xB5, 0x62, 0x8, 0x1B, 0xC7, 0x72, 0xE3, 0xB9);
DEFINE_GUID(CLSID_WICGCEMetadataWriter, 0xAF95DC76, 0x16B2, 0x47F4, 0xB3, 0xEA, 0x3C, 0x31, 0x79, 0x66, 0x93, 0xE7);
DEFINE_GUID(CLSID_WICIMDMetadataReader, 0x7447A267, 0x15, 0x42C8, 0xA8, 0xF1, 0xFB, 0x3B, 0x94, 0xC6, 0x83, 0x61);
DEFINE_GUID(CLSID_WICIMDMetadataWriter, 0x8C89071F, 0x452E, 0x4E95, 0x96, 0x82, 0x9D, 0x10, 0x24, 0x62, 0x71, 0x72);
DEFINE_GUID(CLSID_WICAPEMetadataReader, 0x1767B93A, 0xB021, 0x44EA, 0x92, 0xF, 0x86, 0x3C, 0x11, 0xF4, 0xF7, 0x68);
DEFINE_GUID(CLSID_WICAPEMetadataWriter, 0xBD6EDFCA, 0x2890, 0x482F, 0xB2, 0x33, 0x8D, 0x73, 0x39, 0xA1, 0xCF, 0x8D);
DEFINE_GUID(CLSID_WICJpegChrominanceMetadataReader, 0x50B1904B, 0xF28F, 0x4574, 0x93, 0xF4, 0x0B, 0xAD, 0xE8, 0x2C, 0x69, 0xE9);
DEFINE_GUID(CLSID_WICJpegChrominanceMetadataWriter, 0x3FF566F0, 0x6E6B, 0x49D4, 0x96, 0xE6, 0xB7, 0x88, 0x86, 0x69, 0x2C, 0x62);
DEFINE_GUID(CLSID_WICJpegLuminanceMetadataReader, 0x356F2F88, 0x5A6, 0x4728, 0xB9, 0xA4, 0x1B, 0xFB, 0xCE, 0x04, 0xD8, 0x38);
DEFINE_GUID(CLSID_WICJpegLuminanceMetadataWriter, 0x1D583ABC, 0x8A0E, 0x4657, 0x99, 0x82, 0xA3, 0x80, 0xCA, 0x58, 0xFB, 0x4B);
DEFINE_GUID(CLSID_WICJpegCommentMetadataReader, 0x9f66347C, 0x60C4, 0x4C4D, 0xAB, 0x58, 0xD2, 0x35, 0x86, 0x85, 0xf6, 0x07);
DEFINE_GUID(CLSID_WICJpegCommentMetadataWriter, 0xE573236F, 0x55B1, 0x4EDA, 0x81, 0xEA, 0x9F, 0x65, 0xDB, 0x02, 0x90, 0xD3);
DEFINE_GUID(CLSID_WICGifCommentMetadataReader, 0x32557D3B, 0x69DC, 0x4F95, 0x83, 0x6E, 0xF5, 0x97, 0x2B, 0x2F, 0x61, 0x59);
DEFINE_GUID(CLSID_WICGifCommentMetadataWriter, 0xA02797fC, 0xC4AE, 0x418C, 0xAF, 0x95, 0xE6, 0x37, 0xC7, 0xEA, 0xD2, 0xA1);
DEFINE_GUID(CLSID_WICPngGamaMetadataReader, 0x3692CA39, 0xE082, 0x4350, 0x9E, 0x1F, 0x37, 0x4, 0xCB, 0x8, 0x3C, 0xD5);
DEFINE_GUID(CLSID_WICPngGamaMetadataWriter, 0xFF036D13, 0x5D4B, 0x46DD, 0xB1, 0xF, 0x10, 0x66, 0x93, 0xD9, 0xFE, 0x4F);
DEFINE_GUID(CLSID_WICPngBkgdMetadataReader, 0xCE7A4A6, 0x3E8, 0x4A60, 0x9D, 0x15, 0x28, 0x2E, 0xF3, 0x2E, 0xE7, 0xDA);
DEFINE_GUID(CLSID_WICPngBkgdMetadataWriter, 0x68E3F2FD, 0x31AE, 0x4441, 0xBB, 0x6A, 0xFD, 0x70, 0x47, 0x52, 0x5F, 0x90);
DEFINE_GUID(CLSID_WICPngItxtMetadataReader, 0xAABFB2FA, 0x3E1E, 0x4A8F, 0x89, 0x77, 0x55, 0x56, 0xFB, 0x94, 0xEA, 0x23);
DEFINE_GUID(CLSID_WICPngItxtMetadataWriter, 0x31879719, 0xE751, 0x4DF8, 0x98, 0x1D, 0x68, 0xDF, 0xF6, 0x77, 0x4, 0xED);
DEFINE_GUID(CLSID_WICPngChrmMetadataReader, 0xF90B5F36, 0x367B, 0x402A, 0x9D, 0xD1, 0xBC, 0xF, 0xD5, 0x9D, 0x8F, 0x62);
DEFINE_GUID(CLSID_WICPngChrmMetadataWriter, 0xE23CE3EB, 0x5608, 0x4E83, 0xBC, 0xEF, 0x27, 0xB1, 0x98, 0x7E, 0x51, 0xD7);
DEFINE_GUID(CLSID_WICPngHistMetadataReader, 0x877A0BB7, 0xA313, 0x4491, 0x87, 0xB5, 0x2E, 0x6D, 0x5, 0x94, 0xF5, 0x20);
DEFINE_GUID(CLSID_WICPngHistMetadataWriter, 0x8A03E749, 0x672E, 0x446E, 0xBF, 0x1F, 0x2C, 0x11, 0xD2, 0x33, 0xB6, 0xFF);
DEFINE_GUID(CLSID_WICPngIccpMetadataReader, 0xF5D3E63B, 0xCB0F, 0x4628, 0xA4, 0x78, 0x6D, 0x82, 0x44, 0xBE, 0x36, 0xB1);
DEFINE_GUID(CLSID_WICPngIccpMetadataWriter, 0x16671E5F, 0xCE6, 0x4CC4, 0x97, 0x68, 0xE8, 0x9F, 0xE5, 0x1, 0x8A, 0xDE);
DEFINE_GUID(CLSID_WICPngSrgbMetadataReader, 0xFB40360C, 0x547E, 0x4956, 0xA3, 0xB9, 0xD4, 0x41, 0x88, 0x59, 0xBA, 0x66);
DEFINE_GUID(CLSID_WICPngSrgbMetadataWriter, 0xA6EE35C6, 0x87EC, 0x47DF, 0x9F, 0x22, 0x1D, 0x5A, 0xAD, 0x84, 0xC, 0x82);
DEFINE_GUID(CLSID_WICPngTimeMetadataReader, 0xD94EDF02, 0xEFE5, 0x4F0D, 0x85, 0xC8, 0xF5, 0xA6, 0x8B, 0x30, 0x0, 0xB1);
DEFINE_GUID(CLSID_WICPngTimeMetadataWriter, 0x1AB78400, 0xB5A3, 0x4D91, 0x8A, 0xCE, 0x33, 0xFC, 0xD1, 0x49, 0x9B, 0xE6);









typedef /* [public] */ 
enum WICMetadataCreationOptions
    {	WICMetadataCreationDefault	= 0,
	WICMetadataCreationAllowUnknown	= WICMetadataCreationDefault,
	WICMetadataCreationFailUnknown	= 0x10000,
	WICMetadataCreationMask	= 0xffff0000
    } 	WICMetadataCreationOptions;

typedef /* [public] */ 
enum WICPersistOptions
    {	WICPersistOptionDefault	= 0,
	WICPersistOptionLittleEndian	= 0,
	WICPersistOptionBigEndian	= 0x1,
	WICPersistOptionStrictFormat	= 0x2,
	WICPersistOptionNoCacheStream	= 0x4,
	WICPersistOptionPreferUTF8	= 0x8,
	WICPersistOptionMask	= 0xffff
    } 	WICPersistOptions;



extern RPC_IF_HANDLE __MIDL_itf_wincodecsdk_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wincodecsdk_0000_0000_v0_0_s_ifspec;

#ifndef __IWICMetadataBlockReader_INTERFACE_DEFINED__
#define __IWICMetadataBlockReader_INTERFACE_DEFINED__

/* interface IWICMetadataBlockReader */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataBlockReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FEAA2A8D-B3F3-43E4-B25C-D1DE990A1AE1")
    IWICMetadataBlockReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContainerFormat( 
            /* [out] */ __RPC__out GUID *pguidContainerFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pcCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReaderByIndex( 
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIMetadataReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumerator( 
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppIEnumMetadata) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataBlockReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataBlockReader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataBlockReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataBlockReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICMetadataBlockReader * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IWICMetadataBlockReader * This,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderByIndex )( 
            __RPC__in IWICMetadataBlockReader * This,
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIMetadataReader);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumerator )( 
            __RPC__in IWICMetadataBlockReader * This,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppIEnumMetadata);
        
        END_INTERFACE
    } IWICMetadataBlockReaderVtbl;

    interface IWICMetadataBlockReader
    {
        CONST_VTBL struct IWICMetadataBlockReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataBlockReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataBlockReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataBlockReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataBlockReader_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICMetadataBlockReader_GetCount(This,pcCount)	\
    ( (This)->lpVtbl -> GetCount(This,pcCount) ) 

#define IWICMetadataBlockReader_GetReaderByIndex(This,nIndex,ppIMetadataReader)	\
    ( (This)->lpVtbl -> GetReaderByIndex(This,nIndex,ppIMetadataReader) ) 

#define IWICMetadataBlockReader_GetEnumerator(This,ppIEnumMetadata)	\
    ( (This)->lpVtbl -> GetEnumerator(This,ppIEnumMetadata) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICMetadataBlockReader_INTERFACE_DEFINED__ */


#ifndef __IWICMetadataBlockWriter_INTERFACE_DEFINED__
#define __IWICMetadataBlockWriter_INTERFACE_DEFINED__

/* interface IWICMetadataBlockWriter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataBlockWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08FB9676-B444-41E8-8DBE-6A53A542BFF1")
    IWICMetadataBlockWriter : public IWICMetadataBlockReader
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromBlockReader( 
            /* [in] */ __RPC__in_opt IWICMetadataBlockReader *pIMDBlockReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriterByIndex( 
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt IWICMetadataWriter **ppIMetadataWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddWriter( 
            /* [in] */ __RPC__in_opt IWICMetadataWriter *pIMetadataWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWriterByIndex( 
            /* [in] */ UINT nIndex,
            /* [in] */ __RPC__in_opt IWICMetadataWriter *pIMetadataWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveWriterByIndex( 
            /* [in] */ UINT nIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataBlockWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataBlockWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataBlockWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderByIndex )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIMetadataReader);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumerator )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppIEnumMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromBlockReader )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [in] */ __RPC__in_opt IWICMetadataBlockReader *pIMDBlockReader);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriterByIndex )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [in] */ UINT nIndex,
            /* [out] */ __RPC__deref_out_opt IWICMetadataWriter **ppIMetadataWriter);
        
        HRESULT ( STDMETHODCALLTYPE *AddWriter )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [in] */ __RPC__in_opt IWICMetadataWriter *pIMetadataWriter);
        
        HRESULT ( STDMETHODCALLTYPE *SetWriterByIndex )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [in] */ UINT nIndex,
            /* [in] */ __RPC__in_opt IWICMetadataWriter *pIMetadataWriter);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveWriterByIndex )( 
            __RPC__in IWICMetadataBlockWriter * This,
            /* [in] */ UINT nIndex);
        
        END_INTERFACE
    } IWICMetadataBlockWriterVtbl;

    interface IWICMetadataBlockWriter
    {
        CONST_VTBL struct IWICMetadataBlockWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataBlockWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataBlockWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataBlockWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataBlockWriter_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICMetadataBlockWriter_GetCount(This,pcCount)	\
    ( (This)->lpVtbl -> GetCount(This,pcCount) ) 

#define IWICMetadataBlockWriter_GetReaderByIndex(This,nIndex,ppIMetadataReader)	\
    ( (This)->lpVtbl -> GetReaderByIndex(This,nIndex,ppIMetadataReader) ) 

#define IWICMetadataBlockWriter_GetEnumerator(This,ppIEnumMetadata)	\
    ( (This)->lpVtbl -> GetEnumerator(This,ppIEnumMetadata) ) 


#define IWICMetadataBlockWriter_InitializeFromBlockReader(This,pIMDBlockReader)	\
    ( (This)->lpVtbl -> InitializeFromBlockReader(This,pIMDBlockReader) ) 

#define IWICMetadataBlockWriter_GetWriterByIndex(This,nIndex,ppIMetadataWriter)	\
    ( (This)->lpVtbl -> GetWriterByIndex(This,nIndex,ppIMetadataWriter) ) 

#define IWICMetadataBlockWriter_AddWriter(This,pIMetadataWriter)	\
    ( (This)->lpVtbl -> AddWriter(This,pIMetadataWriter) ) 

#define IWICMetadataBlockWriter_SetWriterByIndex(This,nIndex,pIMetadataWriter)	\
    ( (This)->lpVtbl -> SetWriterByIndex(This,nIndex,pIMetadataWriter) ) 

#define IWICMetadataBlockWriter_RemoveWriterByIndex(This,nIndex)	\
    ( (This)->lpVtbl -> RemoveWriterByIndex(This,nIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICMetadataBlockWriter_INTERFACE_DEFINED__ */


#ifndef __IWICMetadataReader_INTERFACE_DEFINED__
#define __IWICMetadataReader_INTERFACE_DEFINED__

/* interface IWICMetadataReader */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9204FE99-D8FC-4FD5-A001-9536B067A899")
    IWICMetadataReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMetadataFormat( 
            /* [out] */ __RPC__out GUID *pguidMetadataFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetadataHandlerInfo( 
            /* [out] */ __RPC__deref_out_opt IWICMetadataHandlerInfo **ppIHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pcCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueByIndex( 
            /* [in] */ UINT nIndex,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarSchema,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarId,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumerator( 
            /* [out] */ __RPC__deref_out_opt IWICEnumMetadataItem **ppIEnumMetadata) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataReader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataFormat )( 
            __RPC__in IWICMetadataReader * This,
            /* [out] */ __RPC__out GUID *pguidMetadataFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataHandlerInfo )( 
            __RPC__in IWICMetadataReader * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataHandlerInfo **ppIHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IWICMetadataReader * This,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueByIndex )( 
            __RPC__in IWICMetadataReader * This,
            /* [in] */ UINT nIndex,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarSchema,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarId,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in IWICMetadataReader * This,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumerator )( 
            __RPC__in IWICMetadataReader * This,
            /* [out] */ __RPC__deref_out_opt IWICEnumMetadataItem **ppIEnumMetadata);
        
        END_INTERFACE
    } IWICMetadataReaderVtbl;

    interface IWICMetadataReader
    {
        CONST_VTBL struct IWICMetadataReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataReader_GetMetadataFormat(This,pguidMetadataFormat)	\
    ( (This)->lpVtbl -> GetMetadataFormat(This,pguidMetadataFormat) ) 

#define IWICMetadataReader_GetMetadataHandlerInfo(This,ppIHandler)	\
    ( (This)->lpVtbl -> GetMetadataHandlerInfo(This,ppIHandler) ) 

#define IWICMetadataReader_GetCount(This,pcCount)	\
    ( (This)->lpVtbl -> GetCount(This,pcCount) ) 

#define IWICMetadataReader_GetValueByIndex(This,nIndex,pvarSchema,pvarId,pvarValue)	\
    ( (This)->lpVtbl -> GetValueByIndex(This,nIndex,pvarSchema,pvarId,pvarValue) ) 

#define IWICMetadataReader_GetValue(This,pvarSchema,pvarId,pvarValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvarSchema,pvarId,pvarValue) ) 

#define IWICMetadataReader_GetEnumerator(This,ppIEnumMetadata)	\
    ( (This)->lpVtbl -> GetEnumerator(This,ppIEnumMetadata) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICMetadataReader_INTERFACE_DEFINED__ */


#ifndef __IWICMetadataWriter_INTERFACE_DEFINED__
#define __IWICMetadataWriter_INTERFACE_DEFINED__

/* interface IWICMetadataWriter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7836E16-3BE0-470B-86BB-160D0AECD7DE")
    IWICMetadataWriter : public IWICMetadataReader
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId,
            /* [in] */ __RPC__in const PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueByIndex( 
            /* [in] */ UINT nIndex,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId,
            /* [in] */ __RPC__in const PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveValue( 
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveValueByIndex( 
            /* [in] */ UINT nIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataWriter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataFormat )( 
            __RPC__in IWICMetadataWriter * This,
            /* [out] */ __RPC__out GUID *pguidMetadataFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataHandlerInfo )( 
            __RPC__in IWICMetadataWriter * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataHandlerInfo **ppIHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IWICMetadataWriter * This,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueByIndex )( 
            __RPC__in IWICMetadataWriter * This,
            /* [in] */ UINT nIndex,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarSchema,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarId,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in IWICMetadataWriter * This,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumerator )( 
            __RPC__in IWICMetadataWriter * This,
            /* [out] */ __RPC__deref_out_opt IWICEnumMetadataItem **ppIEnumMetadata);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IWICMetadataWriter * This,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId,
            /* [in] */ __RPC__in const PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueByIndex )( 
            __RPC__in IWICMetadataWriter * This,
            /* [in] */ UINT nIndex,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId,
            /* [in] */ __RPC__in const PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveValue )( 
            __RPC__in IWICMetadataWriter * This,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarSchema,
            /* [in] */ __RPC__in const PROPVARIANT *pvarId);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveValueByIndex )( 
            __RPC__in IWICMetadataWriter * This,
            /* [in] */ UINT nIndex);
        
        END_INTERFACE
    } IWICMetadataWriterVtbl;

    interface IWICMetadataWriter
    {
        CONST_VTBL struct IWICMetadataWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataWriter_GetMetadataFormat(This,pguidMetadataFormat)	\
    ( (This)->lpVtbl -> GetMetadataFormat(This,pguidMetadataFormat) ) 

#define IWICMetadataWriter_GetMetadataHandlerInfo(This,ppIHandler)	\
    ( (This)->lpVtbl -> GetMetadataHandlerInfo(This,ppIHandler) ) 

#define IWICMetadataWriter_GetCount(This,pcCount)	\
    ( (This)->lpVtbl -> GetCount(This,pcCount) ) 

#define IWICMetadataWriter_GetValueByIndex(This,nIndex,pvarSchema,pvarId,pvarValue)	\
    ( (This)->lpVtbl -> GetValueByIndex(This,nIndex,pvarSchema,pvarId,pvarValue) ) 

#define IWICMetadataWriter_GetValue(This,pvarSchema,pvarId,pvarValue)	\
    ( (This)->lpVtbl -> GetValue(This,pvarSchema,pvarId,pvarValue) ) 

#define IWICMetadataWriter_GetEnumerator(This,ppIEnumMetadata)	\
    ( (This)->lpVtbl -> GetEnumerator(This,ppIEnumMetadata) ) 


#define IWICMetadataWriter_SetValue(This,pvarSchema,pvarId,pvarValue)	\
    ( (This)->lpVtbl -> SetValue(This,pvarSchema,pvarId,pvarValue) ) 

#define IWICMetadataWriter_SetValueByIndex(This,nIndex,pvarSchema,pvarId,pvarValue)	\
    ( (This)->lpVtbl -> SetValueByIndex(This,nIndex,pvarSchema,pvarId,pvarValue) ) 

#define IWICMetadataWriter_RemoveValue(This,pvarSchema,pvarId)	\
    ( (This)->lpVtbl -> RemoveValue(This,pvarSchema,pvarId) ) 

#define IWICMetadataWriter_RemoveValueByIndex(This,nIndex)	\
    ( (This)->lpVtbl -> RemoveValueByIndex(This,nIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICMetadataWriter_INTERFACE_DEFINED__ */


#ifndef __IWICStreamProvider_INTERFACE_DEFINED__
#define __IWICStreamProvider_INTERFACE_DEFINED__

/* interface IWICStreamProvider */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICStreamProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("449494BC-B468-4927-96D7-BA90D31AB505")
    IWICStreamProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPersistOptions( 
            /* [out] */ __RPC__out DWORD *pdwPersistOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreferredVendorGUID( 
            /* [out] */ __RPC__out GUID *pguidPreferredVendor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshStream( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICStreamProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICStreamProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICStreamProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICStreamProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in IWICStreamProvider * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppIStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetPersistOptions )( 
            __RPC__in IWICStreamProvider * This,
            /* [out] */ __RPC__out DWORD *pdwPersistOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferredVendorGUID )( 
            __RPC__in IWICStreamProvider * This,
            /* [out] */ __RPC__out GUID *pguidPreferredVendor);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshStream )( 
            __RPC__in IWICStreamProvider * This);
        
        END_INTERFACE
    } IWICStreamProviderVtbl;

    interface IWICStreamProvider
    {
        CONST_VTBL struct IWICStreamProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICStreamProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICStreamProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICStreamProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICStreamProvider_GetStream(This,ppIStream)	\
    ( (This)->lpVtbl -> GetStream(This,ppIStream) ) 

#define IWICStreamProvider_GetPersistOptions(This,pdwPersistOptions)	\
    ( (This)->lpVtbl -> GetPersistOptions(This,pdwPersistOptions) ) 

#define IWICStreamProvider_GetPreferredVendorGUID(This,pguidPreferredVendor)	\
    ( (This)->lpVtbl -> GetPreferredVendorGUID(This,pguidPreferredVendor) ) 

#define IWICStreamProvider_RefreshStream(This)	\
    ( (This)->lpVtbl -> RefreshStream(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICStreamProvider_INTERFACE_DEFINED__ */


#ifndef __IWICPersistStream_INTERFACE_DEFINED__
#define __IWICPersistStream_INTERFACE_DEFINED__

/* interface IWICPersistStream */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICPersistStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00675040-6908-45F8-86A3-49C7DFD6D9AD")
    IWICPersistStream : public IPersistStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadEx( 
            /* [unique][in] */ __RPC__in_opt IStream *pIStream,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidPreferredVendor,
            /* [in] */ DWORD dwPersistOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveEx( 
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [in] */ DWORD dwPersistOptions,
            /* [in] */ BOOL fClearDirty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICPersistStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICPersistStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICPersistStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICPersistStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            __RPC__in IWICPersistStream * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            __RPC__in IWICPersistStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            __RPC__in IWICPersistStream * This,
            /* [unique][in] */ __RPC__in_opt IStream *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            __RPC__in IWICPersistStream * This,
            /* [unique][in] */ __RPC__in_opt IStream *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( STDMETHODCALLTYPE *GetSizeMax )( 
            __RPC__in IWICPersistStream * This,
            /* [out] */ __RPC__out ULARGE_INTEGER *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *LoadEx )( 
            __RPC__in IWICPersistStream * This,
            /* [unique][in] */ __RPC__in_opt IStream *pIStream,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidPreferredVendor,
            /* [in] */ DWORD dwPersistOptions);
        
        HRESULT ( STDMETHODCALLTYPE *SaveEx )( 
            __RPC__in IWICPersistStream * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [in] */ DWORD dwPersistOptions,
            /* [in] */ BOOL fClearDirty);
        
        END_INTERFACE
    } IWICPersistStreamVtbl;

    interface IWICPersistStream
    {
        CONST_VTBL struct IWICPersistStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICPersistStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICPersistStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICPersistStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICPersistStream_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IWICPersistStream_IsDirty(This)	\
    ( (This)->lpVtbl -> IsDirty(This) ) 

#define IWICPersistStream_Load(This,pStm)	\
    ( (This)->lpVtbl -> Load(This,pStm) ) 

#define IWICPersistStream_Save(This,pStm,fClearDirty)	\
    ( (This)->lpVtbl -> Save(This,pStm,fClearDirty) ) 

#define IWICPersistStream_GetSizeMax(This,pcbSize)	\
    ( (This)->lpVtbl -> GetSizeMax(This,pcbSize) ) 


#define IWICPersistStream_LoadEx(This,pIStream,pguidPreferredVendor,dwPersistOptions)	\
    ( (This)->lpVtbl -> LoadEx(This,pIStream,pguidPreferredVendor,dwPersistOptions) ) 

#define IWICPersistStream_SaveEx(This,pIStream,dwPersistOptions,fClearDirty)	\
    ( (This)->lpVtbl -> SaveEx(This,pIStream,dwPersistOptions,fClearDirty) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICPersistStream_INTERFACE_DEFINED__ */


#ifndef __IWICMetadataHandlerInfo_INTERFACE_DEFINED__
#define __IWICMetadataHandlerInfo_INTERFACE_DEFINED__

/* interface IWICMetadataHandlerInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataHandlerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ABA958BF-C672-44D1-8D61-CE6DF2E682C2")
    IWICMetadataHandlerInfo : public IWICComponentInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMetadataFormat( 
            /* [out] */ __RPC__out GUID *pguidMetadataFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerFormats( 
            /* [in] */ UINT cContainerFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cContainerFormats) GUID *pguidContainerFormats,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceManufacturer( 
            /* [in] */ UINT cchDeviceManufacturer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceManufacturer) WCHAR *wzDeviceManufacturer,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceModels( 
            /* [in] */ UINT cchDeviceModels,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceModels) WCHAR *wzDeviceModels,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesRequireFullStream( 
            /* [out] */ __RPC__out BOOL *pfRequiresFullStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesSupportPadding( 
            /* [out] */ __RPC__out BOOL *pfSupportsPadding) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesRequireFixedSize( 
            /* [out] */ __RPC__out BOOL *pfFixedSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataHandlerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataHandlerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataHandlerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataFormat )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [out] */ __RPC__out GUID *pguidMetadataFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormats )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [in] */ UINT cContainerFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cContainerFormats) GUID *pguidContainerFormats,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceManufacturer )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [in] */ UINT cchDeviceManufacturer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceManufacturer) WCHAR *wzDeviceManufacturer,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceModels )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [in] */ UINT cchDeviceModels,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceModels) WCHAR *wzDeviceModels,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesRequireFullStream )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [out] */ __RPC__out BOOL *pfRequiresFullStream);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportPadding )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportsPadding);
        
        HRESULT ( STDMETHODCALLTYPE *DoesRequireFixedSize )( 
            __RPC__in IWICMetadataHandlerInfo * This,
            /* [out] */ __RPC__out BOOL *pfFixedSize);
        
        END_INTERFACE
    } IWICMetadataHandlerInfoVtbl;

    interface IWICMetadataHandlerInfo
    {
        CONST_VTBL struct IWICMetadataHandlerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataHandlerInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataHandlerInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataHandlerInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataHandlerInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICMetadataHandlerInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICMetadataHandlerInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICMetadataHandlerInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICMetadataHandlerInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICMetadataHandlerInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICMetadataHandlerInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICMetadataHandlerInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICMetadataHandlerInfo_GetMetadataFormat(This,pguidMetadataFormat)	\
    ( (This)->lpVtbl -> GetMetadataFormat(This,pguidMetadataFormat) ) 

#define IWICMetadataHandlerInfo_GetContainerFormats(This,cContainerFormats,pguidContainerFormats,pcchActual)	\
    ( (This)->lpVtbl -> GetContainerFormats(This,cContainerFormats,pguidContainerFormats,pcchActual) ) 

#define IWICMetadataHandlerInfo_GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual) ) 

#define IWICMetadataHandlerInfo_GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual) ) 

#define IWICMetadataHandlerInfo_DoesRequireFullStream(This,pfRequiresFullStream)	\
    ( (This)->lpVtbl -> DoesRequireFullStream(This,pfRequiresFullStream) ) 

#define IWICMetadataHandlerInfo_DoesSupportPadding(This,pfSupportsPadding)	\
    ( (This)->lpVtbl -> DoesSupportPadding(This,pfSupportsPadding) ) 

#define IWICMetadataHandlerInfo_DoesRequireFixedSize(This,pfFixedSize)	\
    ( (This)->lpVtbl -> DoesRequireFixedSize(This,pfFixedSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICMetadataHandlerInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wincodecsdk_0000_0007 */
/* [local] */ 

typedef struct WICMetadataPattern
    {
    ULARGE_INTEGER Position;
    ULONG Length;
    BYTE *Pattern;
    BYTE *Mask;
    ULARGE_INTEGER DataOffset;
    } 	WICMetadataPattern;



extern RPC_IF_HANDLE __MIDL_itf_wincodecsdk_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wincodecsdk_0000_0007_v0_0_s_ifspec;

#ifndef __IWICMetadataReaderInfo_INTERFACE_DEFINED__
#define __IWICMetadataReaderInfo_INTERFACE_DEFINED__

/* interface IWICMetadataReaderInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataReaderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EEBF1F5B-07C1-4447-A3AB-22ACAF78A804")
    IWICMetadataReaderInfo : public IWICMetadataHandlerInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPatterns( 
            /* [in] */ REFGUID guidContainerFormat,
            /* [in] */ UINT cbSize,
            /* [annotation][unique][size_is][out] */ 
            __out_bcount_part_opt(cbSize, *pcbActual)  WICMetadataPattern *pPattern,
            /* [annotation][unique][out] */ 
            __out_opt  UINT *pcCount,
            /* [annotation][unique][out] */ 
            __out_opt  UINT *pcbActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchesPattern( 
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__out BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIReader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataReaderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataReaderInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataReaderInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataFormat )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__out GUID *pguidMetadataFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormats )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ UINT cContainerFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cContainerFormats) GUID *pguidContainerFormats,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceManufacturer )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ UINT cchDeviceManufacturer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceManufacturer) WCHAR *wzDeviceManufacturer,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceModels )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ UINT cchDeviceModels,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceModels) WCHAR *wzDeviceModels,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesRequireFullStream )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__out BOOL *pfRequiresFullStream);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportPadding )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportsPadding);
        
        HRESULT ( STDMETHODCALLTYPE *DoesRequireFixedSize )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__out BOOL *pfFixedSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetPatterns )( 
            IWICMetadataReaderInfo * This,
            /* [in] */ REFGUID guidContainerFormat,
            /* [in] */ UINT cbSize,
            /* [annotation][unique][size_is][out] */ 
            __out_bcount_part_opt(cbSize, *pcbActual)  WICMetadataPattern *pPattern,
            /* [annotation][unique][out] */ 
            __out_opt  UINT *pcCount,
            /* [annotation][unique][out] */ 
            __out_opt  UINT *pcbActual);
        
        HRESULT ( STDMETHODCALLTYPE *MatchesPattern )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__out BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            __RPC__in IWICMetadataReaderInfo * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIReader);
        
        END_INTERFACE
    } IWICMetadataReaderInfoVtbl;

    interface IWICMetadataReaderInfo
    {
        CONST_VTBL struct IWICMetadataReaderInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataReaderInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataReaderInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataReaderInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataReaderInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICMetadataReaderInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICMetadataReaderInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICMetadataReaderInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICMetadataReaderInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICMetadataReaderInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICMetadataReaderInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICMetadataReaderInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICMetadataReaderInfo_GetMetadataFormat(This,pguidMetadataFormat)	\
    ( (This)->lpVtbl -> GetMetadataFormat(This,pguidMetadataFormat) ) 

#define IWICMetadataReaderInfo_GetContainerFormats(This,cContainerFormats,pguidContainerFormats,pcchActual)	\
    ( (This)->lpVtbl -> GetContainerFormats(This,cContainerFormats,pguidContainerFormats,pcchActual) ) 

#define IWICMetadataReaderInfo_GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual) ) 

#define IWICMetadataReaderInfo_GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual) ) 

#define IWICMetadataReaderInfo_DoesRequireFullStream(This,pfRequiresFullStream)	\
    ( (This)->lpVtbl -> DoesRequireFullStream(This,pfRequiresFullStream) ) 

#define IWICMetadataReaderInfo_DoesSupportPadding(This,pfSupportsPadding)	\
    ( (This)->lpVtbl -> DoesSupportPadding(This,pfSupportsPadding) ) 

#define IWICMetadataReaderInfo_DoesRequireFixedSize(This,pfFixedSize)	\
    ( (This)->lpVtbl -> DoesRequireFixedSize(This,pfFixedSize) ) 


#define IWICMetadataReaderInfo_GetPatterns(This,guidContainerFormat,cbSize,pPattern,pcCount,pcbActual)	\
    ( (This)->lpVtbl -> GetPatterns(This,guidContainerFormat,cbSize,pPattern,pcCount,pcbActual) ) 

#define IWICMetadataReaderInfo_MatchesPattern(This,guidContainerFormat,pIStream,pfMatches)	\
    ( (This)->lpVtbl -> MatchesPattern(This,guidContainerFormat,pIStream,pfMatches) ) 

#define IWICMetadataReaderInfo_CreateInstance(This,ppIReader)	\
    ( (This)->lpVtbl -> CreateInstance(This,ppIReader) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICMetadataReaderInfo_Remote_GetPatterns_Proxy( 
    __RPC__in IWICMetadataReaderInfo * This,
    /* [in] */ __RPC__in REFGUID guidContainerFormat,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcPatterns) WICMetadataPattern **ppPatterns,
    /* [out] */ __RPC__out UINT *pcPatterns);


void __RPC_STUB IWICMetadataReaderInfo_Remote_GetPatterns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWICMetadataReaderInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wincodecsdk_0000_0008 */
/* [local] */ 

typedef struct WICMetadataHeader
    {
    ULARGE_INTEGER Position;
    ULONG Length;
    BYTE *Header;
    ULARGE_INTEGER DataOffset;
    } 	WICMetadataHeader;



extern RPC_IF_HANDLE __MIDL_itf_wincodecsdk_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wincodecsdk_0000_0008_v0_0_s_ifspec;

#ifndef __IWICMetadataWriterInfo_INTERFACE_DEFINED__
#define __IWICMetadataWriterInfo_INTERFACE_DEFINED__

/* interface IWICMetadataWriterInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataWriterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B22E3FBA-3925-4323-B5C1-9EBFC430F236")
    IWICMetadataWriterInfo : public IWICMetadataHandlerInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetHeader( 
            /* [in] */ REFGUID guidContainerFormat,
            /* [in] */ UINT cbSize,
            /* [annotation][unique][out][in] */ 
            __out_bcount_opt(cbSize)  WICMetadataHeader *pHeader,
            /* [annotation][unique][out][in] */ 
            __out_opt  UINT *pcbActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [out] */ __RPC__deref_out_opt IWICMetadataWriter **ppIWriter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataWriterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataWriterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataWriterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataFormat )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__out GUID *pguidMetadataFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormats )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [in] */ UINT cContainerFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cContainerFormats) GUID *pguidContainerFormats,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceManufacturer )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [in] */ UINT cchDeviceManufacturer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceManufacturer) WCHAR *wzDeviceManufacturer,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceModels )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [in] */ UINT cchDeviceModels,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceModels) WCHAR *wzDeviceModels,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesRequireFullStream )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__out BOOL *pfRequiresFullStream);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportPadding )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportsPadding);
        
        HRESULT ( STDMETHODCALLTYPE *DoesRequireFixedSize )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__out BOOL *pfFixedSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetHeader )( 
            IWICMetadataWriterInfo * This,
            /* [in] */ REFGUID guidContainerFormat,
            /* [in] */ UINT cbSize,
            /* [annotation][unique][out][in] */ 
            __out_bcount_opt(cbSize)  WICMetadataHeader *pHeader,
            /* [annotation][unique][out][in] */ 
            __out_opt  UINT *pcbActual);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            __RPC__in IWICMetadataWriterInfo * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataWriter **ppIWriter);
        
        END_INTERFACE
    } IWICMetadataWriterInfoVtbl;

    interface IWICMetadataWriterInfo
    {
        CONST_VTBL struct IWICMetadataWriterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataWriterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataWriterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataWriterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataWriterInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICMetadataWriterInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICMetadataWriterInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICMetadataWriterInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICMetadataWriterInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICMetadataWriterInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICMetadataWriterInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICMetadataWriterInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICMetadataWriterInfo_GetMetadataFormat(This,pguidMetadataFormat)	\
    ( (This)->lpVtbl -> GetMetadataFormat(This,pguidMetadataFormat) ) 

#define IWICMetadataWriterInfo_GetContainerFormats(This,cContainerFormats,pguidContainerFormats,pcchActual)	\
    ( (This)->lpVtbl -> GetContainerFormats(This,cContainerFormats,pguidContainerFormats,pcchActual) ) 

#define IWICMetadataWriterInfo_GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual) ) 

#define IWICMetadataWriterInfo_GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual) ) 

#define IWICMetadataWriterInfo_DoesRequireFullStream(This,pfRequiresFullStream)	\
    ( (This)->lpVtbl -> DoesRequireFullStream(This,pfRequiresFullStream) ) 

#define IWICMetadataWriterInfo_DoesSupportPadding(This,pfSupportsPadding)	\
    ( (This)->lpVtbl -> DoesSupportPadding(This,pfSupportsPadding) ) 

#define IWICMetadataWriterInfo_DoesRequireFixedSize(This,pfFixedSize)	\
    ( (This)->lpVtbl -> DoesRequireFixedSize(This,pfFixedSize) ) 


#define IWICMetadataWriterInfo_GetHeader(This,guidContainerFormat,cbSize,pHeader,pcbActual)	\
    ( (This)->lpVtbl -> GetHeader(This,guidContainerFormat,cbSize,pHeader,pcbActual) ) 

#define IWICMetadataWriterInfo_CreateInstance(This,ppIWriter)	\
    ( (This)->lpVtbl -> CreateInstance(This,ppIWriter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICMetadataWriterInfo_Remote_GetHeader_Proxy( 
    __RPC__in IWICMetadataWriterInfo * This,
    /* [in] */ __RPC__in REFGUID guidContainerFormat,
    /* [out] */ __RPC__out WICMetadataHeader *pHeader);


void __RPC_STUB IWICMetadataWriterInfo_Remote_GetHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWICMetadataWriterInfo_INTERFACE_DEFINED__ */


#ifndef __IWICComponentFactory_INTERFACE_DEFINED__
#define __IWICComponentFactory_INTERFACE_DEFINED__

/* interface IWICComponentFactory */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICComponentFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("412D0C3A-9650-44FA-AF5B-DD2A06C8E8FB")
    IWICComponentFactory : public IWICImagingFactory
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMetadataReader( 
            /* [in] */ __RPC__in REFGUID guidMetadataFormat,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(1) const GUID *pguidVendor,
            /* [in] */ DWORD dwOptions,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMetadataReaderFromContainer( 
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(1) const GUID *pguidVendor,
            /* [in] */ DWORD dwOptions,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMetadataWriter( 
            /* [in] */ __RPC__in REFGUID guidMetadataFormat,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(1) const GUID *pguidVendor,
            /* [in] */ DWORD dwMetadataOptions,
            /* [out] */ __RPC__deref_out_opt IWICMetadataWriter **ppIWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMetadataWriterFromReader( 
            /* [in] */ __RPC__in_opt IWICMetadataReader *pIReader,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [out] */ __RPC__deref_out_opt IWICMetadataWriter **ppIWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateQueryReaderFromBlockReader( 
            /* [in] */ __RPC__in_opt IWICMetadataBlockReader *pIBlockReader,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryReader **ppIQueryReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateQueryWriterFromBlockWriter( 
            /* [in] */ __RPC__in_opt IWICMetadataBlockWriter *pIBlockWriter,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIQueryWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEncoderPropertyBag( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cCount) PROPBAG2 *ppropOptions,
            /* [in] */ UINT cCount,
            /* [out] */ __RPC__deref_out_opt IPropertyBag2 **ppIPropertyBag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICComponentFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICComponentFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICComponentFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDecoderFromFilename )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in LPCWSTR wzFilename,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDecoderFromStream )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDecoderFromFileHandle )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ ULONG_PTR hFile,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateComponentInfo )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in REFCLSID clsidComponent,
            /* [out] */ __RPC__deref_out_opt IWICComponentInfo **ppIInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDecoder )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEncoder )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapEncoder **ppIEncoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePalette )( 
            __RPC__in IWICComponentFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICPalette **ppIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFormatConverter )( 
            __RPC__in IWICComponentFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICFormatConverter **ppIFormatConverter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapScaler )( 
            __RPC__in IWICComponentFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapScaler **ppIBitmapScaler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapClipper )( 
            __RPC__in IWICComponentFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapClipper **ppIBitmapClipper);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFlipRotator )( 
            __RPC__in IWICComponentFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapFlipRotator **ppIBitmapFlipRotator);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            __RPC__in IWICComponentFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICStream **ppIWICStream);
        
        HRESULT ( STDMETHODCALLTYPE *CreateColorContext )( 
            __RPC__in IWICComponentFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICColorContext **ppIWICColorContext);
        
        HRESULT ( STDMETHODCALLTYPE *CreateColorTransformer )( 
            __RPC__in IWICComponentFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICColorTransform **ppIWICColorTransform);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmap )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [in] */ __RPC__in REFWICPixelFormatGUID pixelFormat,
            /* [in] */ WICBitmapCreateCacheOption option,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromSource )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [in] */ WICBitmapCreateCacheOption option,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromSourceRect )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [in] */ UINT x,
            /* [in] */ UINT y,
            /* [in] */ UINT width,
            /* [in] */ UINT height,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromMemory )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [in] */ __RPC__in REFWICPixelFormatGUID pixelFormat,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) BYTE *pbBuffer,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromHBITMAP )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in HBITMAP hBitmap,
            /* [unique][in] */ __RPC__in_opt HPALETTE hPalette,
            /* [in] */ WICBitmapAlphaChannelOption options,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromHICON )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in HICON hIcon,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateComponentEnumerator )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ DWORD componentTypes,
            /* [in] */ DWORD options,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppIEnumUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFastMetadataEncoderFromDecoder )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IWICBitmapDecoder *pIDecoder,
            /* [out] */ __RPC__deref_out_opt IWICFastMetadataEncoder **ppIFastEncoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFastMetadataEncoderFromFrameDecode )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IWICBitmapFrameDecode *pIFrameDecoder,
            /* [out] */ __RPC__deref_out_opt IWICFastMetadataEncoder **ppIFastEncoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateQueryWriter )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in REFGUID guidMetadataFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIQueryWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateQueryWriterFromReader )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IWICMetadataQueryReader *pIQueryReader,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIQueryWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMetadataReader )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in REFGUID guidMetadataFormat,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(1) const GUID *pguidVendor,
            /* [in] */ DWORD dwOptions,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIReader);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMetadataReaderFromContainer )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(1) const GUID *pguidVendor,
            /* [in] */ DWORD dwOptions,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__deref_out_opt IWICMetadataReader **ppIReader);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMetadataWriter )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in REFGUID guidMetadataFormat,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(1) const GUID *pguidVendor,
            /* [in] */ DWORD dwMetadataOptions,
            /* [out] */ __RPC__deref_out_opt IWICMetadataWriter **ppIWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMetadataWriterFromReader )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IWICMetadataReader *pIReader,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [out] */ __RPC__deref_out_opt IWICMetadataWriter **ppIWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateQueryReaderFromBlockReader )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IWICMetadataBlockReader *pIBlockReader,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryReader **ppIQueryReader);
        
        HRESULT ( STDMETHODCALLTYPE *CreateQueryWriterFromBlockWriter )( 
            __RPC__in IWICComponentFactory * This,
            /* [in] */ __RPC__in_opt IWICMetadataBlockWriter *pIBlockWriter,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIQueryWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEncoderPropertyBag )( 
            __RPC__in IWICComponentFactory * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(cCount) PROPBAG2 *ppropOptions,
            /* [in] */ UINT cCount,
            /* [out] */ __RPC__deref_out_opt IPropertyBag2 **ppIPropertyBag);
        
        END_INTERFACE
    } IWICComponentFactoryVtbl;

    interface IWICComponentFactory
    {
        CONST_VTBL struct IWICComponentFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICComponentFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICComponentFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICComponentFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICComponentFactory_CreateDecoderFromFilename(This,wzFilename,pguidVendor,dwDesiredAccess,metadataOptions,ppIDecoder)	\
    ( (This)->lpVtbl -> CreateDecoderFromFilename(This,wzFilename,pguidVendor,dwDesiredAccess,metadataOptions,ppIDecoder) ) 

#define IWICComponentFactory_CreateDecoderFromStream(This,pIStream,pguidVendor,metadataOptions,ppIDecoder)	\
    ( (This)->lpVtbl -> CreateDecoderFromStream(This,pIStream,pguidVendor,metadataOptions,ppIDecoder) ) 

#define IWICComponentFactory_CreateDecoderFromFileHandle(This,hFile,pguidVendor,metadataOptions,ppIDecoder)	\
    ( (This)->lpVtbl -> CreateDecoderFromFileHandle(This,hFile,pguidVendor,metadataOptions,ppIDecoder) ) 

#define IWICComponentFactory_CreateComponentInfo(This,clsidComponent,ppIInfo)	\
    ( (This)->lpVtbl -> CreateComponentInfo(This,clsidComponent,ppIInfo) ) 

#define IWICComponentFactory_CreateDecoder(This,guidContainerFormat,pguidVendor,ppIDecoder)	\
    ( (This)->lpVtbl -> CreateDecoder(This,guidContainerFormat,pguidVendor,ppIDecoder) ) 

#define IWICComponentFactory_CreateEncoder(This,guidContainerFormat,pguidVendor,ppIEncoder)	\
    ( (This)->lpVtbl -> CreateEncoder(This,guidContainerFormat,pguidVendor,ppIEncoder) ) 

#define IWICComponentFactory_CreatePalette(This,ppIPalette)	\
    ( (This)->lpVtbl -> CreatePalette(This,ppIPalette) ) 

#define IWICComponentFactory_CreateFormatConverter(This,ppIFormatConverter)	\
    ( (This)->lpVtbl -> CreateFormatConverter(This,ppIFormatConverter) ) 

#define IWICComponentFactory_CreateBitmapScaler(This,ppIBitmapScaler)	\
    ( (This)->lpVtbl -> CreateBitmapScaler(This,ppIBitmapScaler) ) 

#define IWICComponentFactory_CreateBitmapClipper(This,ppIBitmapClipper)	\
    ( (This)->lpVtbl -> CreateBitmapClipper(This,ppIBitmapClipper) ) 

#define IWICComponentFactory_CreateBitmapFlipRotator(This,ppIBitmapFlipRotator)	\
    ( (This)->lpVtbl -> CreateBitmapFlipRotator(This,ppIBitmapFlipRotator) ) 

#define IWICComponentFactory_CreateStream(This,ppIWICStream)	\
    ( (This)->lpVtbl -> CreateStream(This,ppIWICStream) ) 

#define IWICComponentFactory_CreateColorContext(This,ppIWICColorContext)	\
    ( (This)->lpVtbl -> CreateColorContext(This,ppIWICColorContext) ) 

#define IWICComponentFactory_CreateColorTransformer(This,ppIWICColorTransform)	\
    ( (This)->lpVtbl -> CreateColorTransformer(This,ppIWICColorTransform) ) 

#define IWICComponentFactory_CreateBitmap(This,uiWidth,uiHeight,pixelFormat,option,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmap(This,uiWidth,uiHeight,pixelFormat,option,ppIBitmap) ) 

#define IWICComponentFactory_CreateBitmapFromSource(This,pIBitmapSource,option,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromSource(This,pIBitmapSource,option,ppIBitmap) ) 

#define IWICComponentFactory_CreateBitmapFromSourceRect(This,pIBitmapSource,x,y,width,height,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromSourceRect(This,pIBitmapSource,x,y,width,height,ppIBitmap) ) 

#define IWICComponentFactory_CreateBitmapFromMemory(This,uiWidth,uiHeight,pixelFormat,cbStride,cbBufferSize,pbBuffer,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromMemory(This,uiWidth,uiHeight,pixelFormat,cbStride,cbBufferSize,pbBuffer,ppIBitmap) ) 

#define IWICComponentFactory_CreateBitmapFromHBITMAP(This,hBitmap,hPalette,options,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromHBITMAP(This,hBitmap,hPalette,options,ppIBitmap) ) 

#define IWICComponentFactory_CreateBitmapFromHICON(This,hIcon,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromHICON(This,hIcon,ppIBitmap) ) 

#define IWICComponentFactory_CreateComponentEnumerator(This,componentTypes,options,ppIEnumUnknown)	\
    ( (This)->lpVtbl -> CreateComponentEnumerator(This,componentTypes,options,ppIEnumUnknown) ) 

#define IWICComponentFactory_CreateFastMetadataEncoderFromDecoder(This,pIDecoder,ppIFastEncoder)	\
    ( (This)->lpVtbl -> CreateFastMetadataEncoderFromDecoder(This,pIDecoder,ppIFastEncoder) ) 

#define IWICComponentFactory_CreateFastMetadataEncoderFromFrameDecode(This,pIFrameDecoder,ppIFastEncoder)	\
    ( (This)->lpVtbl -> CreateFastMetadataEncoderFromFrameDecode(This,pIFrameDecoder,ppIFastEncoder) ) 

#define IWICComponentFactory_CreateQueryWriter(This,guidMetadataFormat,pguidVendor,ppIQueryWriter)	\
    ( (This)->lpVtbl -> CreateQueryWriter(This,guidMetadataFormat,pguidVendor,ppIQueryWriter) ) 

#define IWICComponentFactory_CreateQueryWriterFromReader(This,pIQueryReader,pguidVendor,ppIQueryWriter)	\
    ( (This)->lpVtbl -> CreateQueryWriterFromReader(This,pIQueryReader,pguidVendor,ppIQueryWriter) ) 


#define IWICComponentFactory_CreateMetadataReader(This,guidMetadataFormat,pguidVendor,dwOptions,pIStream,ppIReader)	\
    ( (This)->lpVtbl -> CreateMetadataReader(This,guidMetadataFormat,pguidVendor,dwOptions,pIStream,ppIReader) ) 

#define IWICComponentFactory_CreateMetadataReaderFromContainer(This,guidContainerFormat,pguidVendor,dwOptions,pIStream,ppIReader)	\
    ( (This)->lpVtbl -> CreateMetadataReaderFromContainer(This,guidContainerFormat,pguidVendor,dwOptions,pIStream,ppIReader) ) 

#define IWICComponentFactory_CreateMetadataWriter(This,guidMetadataFormat,pguidVendor,dwMetadataOptions,ppIWriter)	\
    ( (This)->lpVtbl -> CreateMetadataWriter(This,guidMetadataFormat,pguidVendor,dwMetadataOptions,ppIWriter) ) 

#define IWICComponentFactory_CreateMetadataWriterFromReader(This,pIReader,pguidVendor,ppIWriter)	\
    ( (This)->lpVtbl -> CreateMetadataWriterFromReader(This,pIReader,pguidVendor,ppIWriter) ) 

#define IWICComponentFactory_CreateQueryReaderFromBlockReader(This,pIBlockReader,ppIQueryReader)	\
    ( (This)->lpVtbl -> CreateQueryReaderFromBlockReader(This,pIBlockReader,ppIQueryReader) ) 

#define IWICComponentFactory_CreateQueryWriterFromBlockWriter(This,pIBlockWriter,ppIQueryWriter)	\
    ( (This)->lpVtbl -> CreateQueryWriterFromBlockWriter(This,pIBlockWriter,ppIQueryWriter) ) 

#define IWICComponentFactory_CreateEncoderPropertyBag(This,ppropOptions,cCount,ppIPropertyBag)	\
    ( (This)->lpVtbl -> CreateEncoderPropertyBag(This,ppropOptions,cCount,ppIPropertyBag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICComponentFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wincodecsdk_0000_0010 */
/* [local] */ 

HRESULT WINAPI WICMatchMetadataContent(
    __in_ecount(1) REFGUID guidContainerFormat,
    __in_ecount_opt(1)  const GUID *pguidVendor,
    __in_ecount(1)  IStream *pIStream,
    __out_ecount(1) GUID *pguidMetadataFormat
    );
HRESULT WINAPI WICSerializeMetadataContent(
    __in_ecount(1) REFGUID guidContainerFormat,
    __in_ecount(1) IWICMetadataWriter *pIWriter,
    __in DWORD dwPersistOptions,
    __in_ecount(1)  IStream *pIStream
    );
HRESULT WINAPI WICGetMetadataContentSize(
    __in_ecount(1) REFGUID guidContainerFormat,
    __in_ecount(1) IWICMetadataWriter *pIWriter,
    __out_ecount(1) ULARGE_INTEGER *pcbSize
    );


extern RPC_IF_HANDLE __MIDL_itf_wincodecsdk_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wincodecsdk_0000_0010_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  CLIPFORMAT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in CLIPFORMAT * ); 
unsigned char * __RPC_USER  CLIPFORMAT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out CLIPFORMAT * ); 
void                      __RPC_USER  CLIPFORMAT_UserFree(     __RPC__in unsigned long *, __RPC__in CLIPFORMAT * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IWICMetadataReaderInfo_GetPatterns_Proxy( 
    IWICMetadataReaderInfo * This,
    /* [in] */ REFGUID guidContainerFormat,
    /* [in] */ UINT cbSize,
    /* [annotation][unique][size_is][out] */ 
    __out_bcount_part_opt(cbSize, *pcbActual)  WICMetadataPattern *pPattern,
    /* [annotation][unique][out] */ 
    __out_opt  UINT *pcCount,
    /* [annotation][unique][out] */ 
    __out_opt  UINT *pcbActual);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICMetadataReaderInfo_GetPatterns_Stub( 
    __RPC__in IWICMetadataReaderInfo * This,
    /* [in] */ __RPC__in REFGUID guidContainerFormat,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcPatterns) WICMetadataPattern **ppPatterns,
    /* [out] */ __RPC__out UINT *pcPatterns);

/* [local] */ HRESULT STDMETHODCALLTYPE IWICMetadataWriterInfo_GetHeader_Proxy( 
    IWICMetadataWriterInfo * This,
    /* [in] */ REFGUID guidContainerFormat,
    /* [in] */ UINT cbSize,
    /* [annotation][unique][out][in] */ 
    __out_bcount_opt(cbSize)  WICMetadataHeader *pHeader,
    /* [annotation][unique][out][in] */ 
    __out_opt  UINT *pcbActual);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICMetadataWriterInfo_GetHeader_Stub( 
    __RPC__in IWICMetadataWriterInfo * This,
    /* [in] */ __RPC__in REFGUID guidContainerFormat,
    /* [out] */ __RPC__out WICMetadataHeader *pHeader);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinCon.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wincon.h

Abstract:

    This module contains the public data structures, data types,
    and procedures exported by the NT console subsystem.

Created:

    26-Oct-1990

Revision History:

--*/

#ifndef _WINCON_
#define _WINCON_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NOGDI
#include <wingdi.h>
#endif

typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;

//
// ControlKeyState flags
//

#define RIGHT_ALT_PRESSED     0x0001 // the right alt key is pressed.
#define LEFT_ALT_PRESSED      0x0002 // the left alt key is pressed.
#define RIGHT_CTRL_PRESSED    0x0004 // the right ctrl key is pressed.
#define LEFT_CTRL_PRESSED     0x0008 // the left ctrl key is pressed.
#define SHIFT_PRESSED         0x0010 // the shift key is pressed.
#define NUMLOCK_ON            0x0020 // the numlock light is on.
#define SCROLLLOCK_ON         0x0040 // the scrolllock light is on.
#define CAPSLOCK_ON           0x0080 // the capslock light is on.
#define ENHANCED_KEY          0x0100 // the key is enhanced.
#define NLS_DBCSCHAR          0x00010000 // DBCS for JPN: SBCS/DBCS mode.
#define NLS_ALPHANUMERIC      0x00000000 // DBCS for JPN: Alphanumeric mode.
#define NLS_KATAKANA          0x00020000 // DBCS for JPN: Katakana mode.
#define NLS_HIRAGANA          0x00040000 // DBCS for JPN: Hiragana mode.
#define NLS_ROMAN             0x00400000 // DBCS for JPN: Roman/Noroman mode.
#define NLS_IME_CONVERSION    0x00800000 // DBCS for JPN: IME conversion.
#define NLS_IME_DISABLE       0x20000000 // DBCS for JPN: IME enable/disable.

typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;

//
// ButtonState flags
//

#define FROM_LEFT_1ST_BUTTON_PRESSED    0x0001
#define RIGHTMOST_BUTTON_PRESSED        0x0002
#define FROM_LEFT_2ND_BUTTON_PRESSED    0x0004
#define FROM_LEFT_3RD_BUTTON_PRESSED    0x0008
#define FROM_LEFT_4TH_BUTTON_PRESSED    0x0010

//
// EventFlags
//

#define MOUSE_MOVED   0x0001
#define DOUBLE_CLICK  0x0002
#define MOUSE_WHEELED 0x0004
#if(_WIN32_WINNT >= 0x0600)
#define MOUSE_HWHEELED 0x0008
#endif /* _WIN32_WINNT >= 0x0600 */

typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;

//
//  EventType flags:
//

#define KEY_EVENT         0x0001 // Event contains key event record
#define MOUSE_EVENT       0x0002 // Event contains mouse event record
#define WINDOW_BUFFER_SIZE_EVENT 0x0004 // Event contains window change event record
#define MENU_EVENT 0x0008 // Event contains menu event record
#define FOCUS_EVENT 0x0010 // event contains focus change

typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;

//
// Attributes flags:
//

#define FOREGROUND_BLUE      0x0001 // text color contains blue.
#define FOREGROUND_GREEN     0x0002 // text color contains green.
#define FOREGROUND_RED       0x0004 // text color contains red.
#define FOREGROUND_INTENSITY 0x0008 // text color is intensified.
#define BACKGROUND_BLUE      0x0010 // background color contains blue.
#define BACKGROUND_GREEN     0x0020 // background color contains green.
#define BACKGROUND_RED       0x0040 // background color contains red.
#define BACKGROUND_INTENSITY 0x0080 // background color is intensified.
#define COMMON_LVB_LEADING_BYTE    0x0100 // Leading Byte of DBCS
#define COMMON_LVB_TRAILING_BYTE   0x0200 // Trailing Byte of DBCS
#define COMMON_LVB_GRID_HORIZONTAL 0x0400 // DBCS: Grid attribute: top horizontal.
#define COMMON_LVB_GRID_LVERTICAL  0x0800 // DBCS: Grid attribute: left vertical.
#define COMMON_LVB_GRID_RVERTICAL  0x1000 // DBCS: Grid attribute: right vertical.
#define COMMON_LVB_REVERSE_VIDEO   0x4000 // DBCS: Reverse fore/back ground attribute.
#define COMMON_LVB_UNDERSCORE      0x8000 // DBCS: Underscore.

#define COMMON_LVB_SBCSDBCS        0x0300 // SBCS or DBCS flag.


typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD  wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;

typedef struct _CONSOLE_CURSOR_INFO {
    DWORD  dwSize;
    BOOL   bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

typedef struct _CONSOLE_FONT_INFO {
    DWORD  nFont;
    COORD  dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;

#ifndef NOGDI
typedef struct _CONSOLE_FONT_INFOEX {
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[LF_FACESIZE];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;
#endif

#define HISTORY_NO_DUP_FLAG 0x1

typedef struct _CONSOLE_HISTORY_INFO {
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;

#if(_WIN32_WINNT >= 0x0500)
typedef struct _CONSOLE_SELECTION_INFO {
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;

//
// Selection flags
//

#define CONSOLE_NO_SELECTION            0x0000
#define CONSOLE_SELECTION_IN_PROGRESS   0x0001   // selection has begun
#define CONSOLE_SELECTION_NOT_EMPTY     0x0002   // non-null select rectangle
#define CONSOLE_MOUSE_SELECTION         0x0004   // selecting with mouse
#define CONSOLE_MOUSE_DOWN              0x0008   // mouse is down
#endif /* _WIN32_WINNT >= 0x0500 */

//
// typedef for ctrl-c handler routines
//

typedef
BOOL
(WINAPI *PHANDLER_ROUTINE)(
    __in DWORD CtrlType
    );

#define CTRL_C_EVENT        0
#define CTRL_BREAK_EVENT    1
#define CTRL_CLOSE_EVENT    2
// 3 is reserved!
// 4 is reserved!
#define CTRL_LOGOFF_EVENT   5
#define CTRL_SHUTDOWN_EVENT 6

//
//  Input Mode flags:
//

#define ENABLE_PROCESSED_INPUT  0x0001
#define ENABLE_LINE_INPUT       0x0002
#define ENABLE_ECHO_INPUT       0x0004
#define ENABLE_WINDOW_INPUT     0x0008
#define ENABLE_MOUSE_INPUT      0x0010
#define ENABLE_INSERT_MODE      0x0020
#define ENABLE_QUICK_EDIT_MODE  0x0040
#define ENABLE_EXTENDED_FLAGS   0x0080
#define ENABLE_AUTO_POSITION    0x0100

//
// Output Mode flags:
//

#define ENABLE_PROCESSED_OUTPUT    0x0001
#define ENABLE_WRAP_AT_EOL_OUTPUT  0x0002

//
// direct API definitions.
//

WINBASEAPI
BOOL
WINAPI
PeekConsoleInputA(
    __in HANDLE hConsoleInput,
    __out_ecount(nLength) PINPUT_RECORD lpBuffer,
    __in DWORD nLength,
    __out LPDWORD lpNumberOfEventsRead
    );
WINBASEAPI
BOOL
WINAPI
PeekConsoleInputW(
    __in HANDLE hConsoleInput,
    __out_ecount(nLength) PINPUT_RECORD lpBuffer,
    __in DWORD nLength,
    __out LPDWORD lpNumberOfEventsRead
    );
#ifdef UNICODE
#define PeekConsoleInput  PeekConsoleInputW
#else
#define PeekConsoleInput  PeekConsoleInputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleInputA(
    __in HANDLE hConsoleInput,
    __out_ecount(nLength) PINPUT_RECORD lpBuffer,
    __in DWORD nLength,
    __out LPDWORD lpNumberOfEventsRead
    );
WINBASEAPI
BOOL
WINAPI
ReadConsoleInputW(
    __in HANDLE hConsoleInput,
    __out_ecount(nLength) PINPUT_RECORD lpBuffer,
    __in DWORD nLength,
    __out LPDWORD lpNumberOfEventsRead
    );
#ifdef UNICODE
#define ReadConsoleInput  ReadConsoleInputW
#else
#define ReadConsoleInput  ReadConsoleInputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteConsoleInputA(
    __in HANDLE hConsoleInput,
    __in_ecount(nLength) CONST INPUT_RECORD *lpBuffer,
    __in DWORD nLength,
    __out LPDWORD lpNumberOfEventsWritten
    );
WINBASEAPI
BOOL
WINAPI
WriteConsoleInputW(
    __in HANDLE hConsoleInput,
    __in_ecount(nLength) CONST INPUT_RECORD *lpBuffer,
    __in DWORD nLength,
    __out LPDWORD lpNumberOfEventsWritten
    );
#ifdef UNICODE
#define WriteConsoleInput  WriteConsoleInputW
#else
#define WriteConsoleInput  WriteConsoleInputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputA(
    __in HANDLE hConsoleOutput,
    __out_ecount(dwBufferSize.X * dwBufferSize.Y) PCHAR_INFO lpBuffer,
    __in COORD dwBufferSize,
    __in COORD dwBufferCoord,
    __inout PSMALL_RECT lpReadRegion
    );
WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputW(
    __in HANDLE hConsoleOutput,
    __out_ecount(dwBufferSize.X * dwBufferSize.Y) PCHAR_INFO lpBuffer,
    __in COORD dwBufferSize,
    __in COORD dwBufferCoord,
    __inout PSMALL_RECT lpReadRegion
    );
#ifdef UNICODE
#define ReadConsoleOutput  ReadConsoleOutputW
#else
#define ReadConsoleOutput  ReadConsoleOutputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputA(
    __in HANDLE hConsoleOutput,
    __in_ecount(dwBufferSize.X * dwBufferSize.Y) CONST CHAR_INFO *lpBuffer,
    __in COORD dwBufferSize,
    __in COORD dwBufferCoord,
    __inout PSMALL_RECT lpWriteRegion
    );
WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputW(
    __in HANDLE hConsoleOutput,
    __in_ecount(dwBufferSize.X * dwBufferSize.Y) CONST CHAR_INFO *lpBuffer,
    __in COORD dwBufferSize,
    __in COORD dwBufferCoord,
    __inout PSMALL_RECT lpWriteRegion
    );
#ifdef UNICODE
#define WriteConsoleOutput  WriteConsoleOutputW
#else
#define WriteConsoleOutput  WriteConsoleOutputA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputCharacterA(
    __in HANDLE hConsoleOutput,
    __out_ecount(nLength) LPSTR lpCharacter,
    __in DWORD nLength,
    __in COORD dwReadCoord,
    __out LPDWORD lpNumberOfCharsRead
    );
WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputCharacterW(
    __in HANDLE hConsoleOutput,
    __out_ecount(nLength) LPWSTR lpCharacter,
    __in DWORD nLength,
    __in COORD dwReadCoord,
    __out LPDWORD lpNumberOfCharsRead
    );
#ifdef UNICODE
#define ReadConsoleOutputCharacter  ReadConsoleOutputCharacterW
#else
#define ReadConsoleOutputCharacter  ReadConsoleOutputCharacterA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
ReadConsoleOutputAttribute(
    __in HANDLE hConsoleOutput,
    __out_ecount(nLength) LPWORD lpAttribute,
    __in DWORD nLength,
    __in COORD dwReadCoord,
    __out LPDWORD lpNumberOfAttrsRead
    );

WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputCharacterA(
    __in HANDLE hConsoleOutput,
    __in_ecount(nLength) LPCSTR lpCharacter,
    __in DWORD nLength,
    __in COORD dwWriteCoord,
    __out LPDWORD lpNumberOfCharsWritten
    );
WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputCharacterW(
    __in HANDLE hConsoleOutput,
    __in_ecount(nLength) LPCWSTR lpCharacter,
    __in DWORD nLength,
    __in COORD dwWriteCoord,
    __out LPDWORD lpNumberOfCharsWritten
    );
#ifdef UNICODE
#define WriteConsoleOutputCharacter  WriteConsoleOutputCharacterW
#else
#define WriteConsoleOutputCharacter  WriteConsoleOutputCharacterA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteConsoleOutputAttribute(
    __in HANDLE hConsoleOutput,
    __in_ecount(nLength) CONST WORD *lpAttribute,
    __in DWORD nLength,
    __in COORD dwWriteCoord,
    __out LPDWORD lpNumberOfAttrsWritten
    );

WINBASEAPI
BOOL
WINAPI
FillConsoleOutputCharacterA(
    __in HANDLE hConsoleOutput,
    __in CHAR  cCharacter,
    __in DWORD  nLength,
    __in COORD  dwWriteCoord,
    __out LPDWORD lpNumberOfCharsWritten
    );
WINBASEAPI
BOOL
WINAPI
FillConsoleOutputCharacterW(
    __in HANDLE hConsoleOutput,
    __in WCHAR  cCharacter,
    __in DWORD  nLength,
    __in COORD  dwWriteCoord,
    __out LPDWORD lpNumberOfCharsWritten
    );
#ifdef UNICODE
#define FillConsoleOutputCharacter  FillConsoleOutputCharacterW
#else
#define FillConsoleOutputCharacter  FillConsoleOutputCharacterA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FillConsoleOutputAttribute(
    __in HANDLE hConsoleOutput,
    __in WORD   wAttribute,
    __in DWORD  nLength,
    __in COORD  dwWriteCoord,
    __out LPDWORD lpNumberOfAttrsWritten
    );

WINBASEAPI
BOOL
WINAPI
GetConsoleMode(
    __in HANDLE hConsoleHandle,
    __out LPDWORD lpMode
    );

WINBASEAPI
BOOL
WINAPI
GetNumberOfConsoleInputEvents(
    __in HANDLE hConsoleInput,
    __out LPDWORD lpNumberOfEvents
    );

#define CONSOLE_REAL_OUTPUT_HANDLE (LongToHandle(-2))
#define CONSOLE_REAL_INPUT_HANDLE (LongToHandle(-3))

WINBASEAPI
BOOL
WINAPI
GetConsoleScreenBufferInfo(
    __in HANDLE hConsoleOutput,
    __out PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );

WINBASEAPI
BOOL
WINAPI
GetConsoleScreenBufferInfoEx(
    __in HANDLE hConsoleOutput,
    __inout_bcount_part(sizeof(ULONG), sizeof(CONSOLE_SCREEN_BUFFER_INFOEX) - sizeof(ULONG)) PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);

WINBASEAPI
BOOL
WINAPI
SetConsoleScreenBufferInfoEx(
    __in HANDLE hConsoleOutput,
    __in PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);

WINBASEAPI
COORD
WINAPI
GetLargestConsoleWindowSize(
    __in HANDLE hConsoleOutput
    );

WINBASEAPI
BOOL
WINAPI
GetConsoleCursorInfo(
    __in HANDLE hConsoleOutput,
    __out PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );

#if(_WIN32_WINNT >= 0x0500)

WINBASEAPI
BOOL
WINAPI
GetCurrentConsoleFont(
    __in HANDLE hConsoleOutput,
    __in BOOL bMaximumWindow,
    __out PCONSOLE_FONT_INFO lpConsoleCurrentFont
    );

#ifndef NOGDI
WINBASEAPI
BOOL
WINAPI
GetCurrentConsoleFontEx(
    __in HANDLE hConsoleOutput,
    __in BOOL bMaximumWindow,
    __out PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);

WINBASEAPI
BOOL
WINAPI
SetCurrentConsoleFontEx(
    __in HANDLE hConsoleOutput,
    __in BOOL bMaximumWindow,
    __in PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
#endif

WINBASEAPI
BOOL
WINAPI
GetConsoleHistoryInfo(
    __out PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);

WINBASEAPI
BOOL
WINAPI
SetConsoleHistoryInfo(
    __in PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);

WINBASEAPI
COORD
WINAPI
GetConsoleFontSize(
    __in HANDLE hConsoleOutput,
    __in DWORD nFont
    );

WINBASEAPI
BOOL
WINAPI
GetConsoleSelectionInfo(
    __out PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    );

#endif /* _WIN32_WINNT >= 0x0500 */

WINBASEAPI
BOOL
WINAPI
GetNumberOfConsoleMouseButtons(
    __out LPDWORD lpNumberOfMouseButtons
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleMode(
    __in HANDLE hConsoleHandle,
    __in DWORD dwMode
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleActiveScreenBuffer(
    __in HANDLE hConsoleOutput
    );

WINBASEAPI
BOOL
WINAPI
FlushConsoleInputBuffer(
    __in HANDLE hConsoleInput
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleScreenBufferSize(
    __in HANDLE hConsoleOutput,
    __in COORD dwSize
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleCursorPosition(
    __in HANDLE hConsoleOutput,
    __in COORD dwCursorPosition
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleCursorInfo(
    __in HANDLE hConsoleOutput,
    __in CONST CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    );

WINBASEAPI
BOOL
WINAPI
ScrollConsoleScreenBufferA(
    __in HANDLE hConsoleOutput,
    __in CONST SMALL_RECT *lpScrollRectangle,
    __in_opt CONST SMALL_RECT *lpClipRectangle,
    __in COORD dwDestinationOrigin,
    __in CONST CHAR_INFO *lpFill
    );
WINBASEAPI
BOOL
WINAPI
ScrollConsoleScreenBufferW(
    __in HANDLE hConsoleOutput,
    __in CONST SMALL_RECT *lpScrollRectangle,
    __in_opt CONST SMALL_RECT *lpClipRectangle,
    __in COORD dwDestinationOrigin,
    __in CONST CHAR_INFO *lpFill
    );
#ifdef UNICODE
#define ScrollConsoleScreenBuffer  ScrollConsoleScreenBufferW
#else
#define ScrollConsoleScreenBuffer  ScrollConsoleScreenBufferA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
SetConsoleWindowInfo(
    __in HANDLE hConsoleOutput,
    __in BOOL bAbsolute,
    __in CONST SMALL_RECT *lpConsoleWindow
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleTextAttribute(
    __in HANDLE hConsoleOutput,
    __in WORD wAttributes
    );

WINBASEAPI
BOOL
WINAPI
SetConsoleCtrlHandler(
    __in_opt PHANDLER_ROUTINE HandlerRoutine,
    __in BOOL Add);

WINBASEAPI
BOOL
WINAPI
GenerateConsoleCtrlEvent(
    __in DWORD dwCtrlEvent,
    __in DWORD dwProcessGroupId);

WINBASEAPI
BOOL
WINAPI
AllocConsole(
    VOID);

WINBASEAPI
BOOL
WINAPI
FreeConsole(
    VOID);

#if(_WIN32_WINNT >= 0x0500)
WINBASEAPI
BOOL
WINAPI
AttachConsole(
    __in DWORD dwProcessId);

#define ATTACH_PARENT_PROCESS ((DWORD)-1)

#endif /* _WIN32_WINNT >= 0x0500 */

WINBASEAPI
DWORD
WINAPI
GetConsoleTitleA(
    __out_ecount(nSize) LPSTR lpConsoleTitle,
    __in DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetConsoleTitleW(
    __out_ecount(nSize) LPWSTR lpConsoleTitle,
    __in DWORD nSize
    );
#ifdef UNICODE
#define GetConsoleTitle  GetConsoleTitleW
#else
#define GetConsoleTitle  GetConsoleTitleA
#endif // !UNICODE

#if(_WIN32_WINNT >= 0x0600)
WINBASEAPI
DWORD
WINAPI
GetConsoleOriginalTitleA(
    __out_ecount(nSize) LPSTR lpConsoleTitle,
    __in DWORD nSize);
WINBASEAPI
DWORD
WINAPI
GetConsoleOriginalTitleW(
    __out_ecount(nSize) LPWSTR lpConsoleTitle,
    __in DWORD nSize);
#ifdef UNICODE
#define GetConsoleOriginalTitle  GetConsoleOriginalTitleW
#else
#define GetConsoleOriginalTitle  GetConsoleOriginalTitleA
#endif // !UNICODE
#endif /* _WIN32_WINNT >= 0x0600 */

WINBASEAPI
BOOL
WINAPI
SetConsoleTitleA(
    __in LPCSTR lpConsoleTitle
    );
WINBASEAPI
BOOL
WINAPI
SetConsoleTitleW(
    __in LPCWSTR lpConsoleTitle
    );
#ifdef UNICODE
#define SetConsoleTitle  SetConsoleTitleW
#else
#define SetConsoleTitle  SetConsoleTitleA
#endif // !UNICODE

typedef struct _CONSOLE_READCONSOLE_CONTROL {
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;

WINBASEAPI
BOOL
WINAPI
ReadConsoleA(
    __in HANDLE hConsoleInput,
    __out_ecount_part(nNumberOfCharsToRead, *lpNumberOfCharsRead)
       LPVOID lpBuffer,
    __in DWORD nNumberOfCharsToRead,
    __out LPDWORD lpNumberOfCharsRead,
    __in_opt PCONSOLE_READCONSOLE_CONTROL pInputControl
    );
WINBASEAPI
BOOL
WINAPI
ReadConsoleW(
    __in HANDLE hConsoleInput,
    __out_ecount_part(nNumberOfCharsToRead, *lpNumberOfCharsRead)
       LPVOID lpBuffer,
    __in DWORD nNumberOfCharsToRead,
    __out LPDWORD lpNumberOfCharsRead,
    __in_opt PCONSOLE_READCONSOLE_CONTROL pInputControl
    );
#ifdef UNICODE
#define ReadConsole  ReadConsoleW
#else
#define ReadConsole  ReadConsoleA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteConsoleA(
    __in HANDLE hConsoleOutput,
    __in_ecount(nNumberOfCharsToWrite) CONST VOID *lpBuffer,
    __in DWORD nNumberOfCharsToWrite,
    __out_opt LPDWORD lpNumberOfCharsWritten,
    __reserved LPVOID lpReserved);
WINBASEAPI
BOOL
WINAPI
WriteConsoleW(
    __in HANDLE hConsoleOutput,
    __in_ecount(nNumberOfCharsToWrite) CONST VOID *lpBuffer,
    __in DWORD nNumberOfCharsToWrite,
    __out_opt LPDWORD lpNumberOfCharsWritten,
    __reserved LPVOID lpReserved);
#ifdef UNICODE
#define WriteConsole  WriteConsoleW
#else
#define WriteConsole  WriteConsoleA
#endif // !UNICODE

#define CONSOLE_TEXTMODE_BUFFER  1

__allocator
WINBASEAPI
HANDLE
WINAPI
CreateConsoleScreenBuffer(
    __in DWORD dwDesiredAccess,
    __in DWORD dwShareMode,
    __in_opt CONST SECURITY_ATTRIBUTES *lpSecurityAttributes,
    __in DWORD dwFlags,
    __reserved LPVOID lpScreenBufferData
    );

WINBASEAPI
UINT
WINAPI
GetConsoleCP(
    VOID);

WINBASEAPI
BOOL
WINAPI
SetConsoleCP(
    __in UINT wCodePageID
    );

WINBASEAPI
UINT
WINAPI
GetConsoleOutputCP(
    VOID);

WINBASEAPI
BOOL
WINAPI
SetConsoleOutputCP(
    __in UINT wCodePageID
    );

#if(_WIN32_WINNT >= 0x0500)

#define CONSOLE_FULLSCREEN 1            // fullscreen console
#define CONSOLE_FULLSCREEN_HARDWARE 2   // console owns the hardware

WINBASEAPI
BOOL
APIENTRY
GetConsoleDisplayMode(
    __out LPDWORD lpModeFlags);

#define CONSOLE_FULLSCREEN_MODE 1
#define CONSOLE_WINDOWED_MODE 2

BOOL
APIENTRY
SetConsoleDisplayMode(
    __in HANDLE hConsoleOutput,
    __in DWORD dwFlags,
    __out_opt PCOORD lpNewScreenBufferDimensions);

WINBASEAPI
HWND
APIENTRY
GetConsoleWindow(
    VOID
    );

#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0501)

WINBASEAPI
DWORD
APIENTRY
GetConsoleProcessList(
    __out_ecount(dwProcessCount) LPDWORD lpdwProcessList,
    __in DWORD dwProcessCount);

//
// Aliasing apis.
//

WINBASEAPI
BOOL
APIENTRY
AddConsoleAliasA(
    __in LPSTR Source,
    __in LPSTR Target,
    __in LPSTR ExeName);
WINBASEAPI
BOOL
APIENTRY
AddConsoleAliasW(
    __in LPWSTR Source,
    __in LPWSTR Target,
    __in LPWSTR ExeName);
#ifdef UNICODE
#define AddConsoleAlias  AddConsoleAliasW
#else
#define AddConsoleAlias  AddConsoleAliasA
#endif // !UNICODE

WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasA(
    __in LPSTR Source,
    __out_ecount(TargetBufferLength) LPSTR TargetBuffer,
    __in DWORD TargetBufferLength,
    __in LPSTR ExeName);
WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasW(
    __in LPWSTR Source,
    __out_ecount(TargetBufferLength) LPWSTR TargetBuffer,
    __in DWORD TargetBufferLength,
    __in LPWSTR ExeName);
#ifdef UNICODE
#define GetConsoleAlias  GetConsoleAliasW
#else
#define GetConsoleAlias  GetConsoleAliasA
#endif // !UNICODE

WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasesLengthA(
    __in LPSTR ExeName);
WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasesLengthW(
    __in LPWSTR ExeName);
#ifdef UNICODE
#define GetConsoleAliasesLength  GetConsoleAliasesLengthW
#else
#define GetConsoleAliasesLength  GetConsoleAliasesLengthA
#endif // !UNICODE

WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasExesLengthA(
    VOID);
WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasExesLengthW(
    VOID);
#ifdef UNICODE
#define GetConsoleAliasExesLength  GetConsoleAliasExesLengthW
#else
#define GetConsoleAliasExesLength  GetConsoleAliasExesLengthA
#endif // !UNICODE

WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasesA(
    __out_ecount(AliasBufferLength) LPSTR AliasBuffer,
    __in DWORD AliasBufferLength,
    __in LPSTR ExeName);
WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasesW(
    __out_ecount(AliasBufferLength) LPWSTR AliasBuffer,
    __in DWORD AliasBufferLength,
    __in LPWSTR ExeName);
#ifdef UNICODE
#define GetConsoleAliases  GetConsoleAliasesW
#else
#define GetConsoleAliases  GetConsoleAliasesA
#endif // !UNICODE

WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasExesA(
    __out_ecount(ExeNameBufferLength) LPSTR ExeNameBuffer,
    __in DWORD ExeNameBufferLength);
WINBASEAPI
DWORD
APIENTRY
GetConsoleAliasExesW(
    __out_ecount(ExeNameBufferLength) LPWSTR ExeNameBuffer,
    __in DWORD ExeNameBufferLength);
#ifdef UNICODE
#define GetConsoleAliasExes  GetConsoleAliasExesW
#else
#define GetConsoleAliasExes  GetConsoleAliasExesA
#endif // !UNICODE

#endif /* _WIN32_WINNT >= 0x0501 */

#ifdef __cplusplus
}
#endif

#endif // _WINCON_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinBio_Err.h ===
/*++

Copyright (c) 2007 Microsoft Corporation


Module Name:

    winbio_err.h

Abstract:

    Definitions of error codes used by
    Windows Biometric Framework components.


Environment:

    User or Kernel mode.

Revision History:

--*/

#ifndef _WINBIO_ERR_H_06269BBC_B52E_4d0d_9D35_D23BEA12DE5D_
#define _WINBIO_ERR_H_06269BBC_B52E_4d0d_9D35_D23BEA12DE5D_


#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// For now, WINBIO errors are piggy-backing on the Security
// facility code. That may change in a future revision.
//
//
// Error conditions -- values are in the range: 0x8001 - 0xFFFF
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINBIO                  0x9


//
// Define the severity codes
//


//
// MessageId: WINBIO_E_UNSUPPORTED_FACTOR
//
// MessageText:
//
// Windows Biometric Service doesn't support the specified biometric factor.
//
#define WINBIO_E_UNSUPPORTED_FACTOR      ((HRESULT)0x80098001L)

//
// MessageId: WINBIO_E_INVALID_UNIT
//
// MessageText:
//
// The unit ID number doesn't correspond to a valid biometric device.
//
#define WINBIO_E_INVALID_UNIT            ((HRESULT)0x80098002L)

//
// MessageId: WINBIO_E_UNKNOWN_ID
//
// MessageText:
//
// The biometric sample doesn't match any known identity.
//
#define WINBIO_E_UNKNOWN_ID              ((HRESULT)0x80098003L)

//
// MessageId: WINBIO_E_CANCELED
//
// MessageText:
//
// The biometric operation was canceled before it could complete.
//
#define WINBIO_E_CANCELED                ((HRESULT)0x80098004L)

//
// MessageId: WINBIO_E_NO_MATCH
//
// MessageText:
//
// The biometric sample doesn't match the specified identity or sub-factor.
//
#define WINBIO_E_NO_MATCH                ((HRESULT)0x80098005L)

//
// MessageId: WINBIO_E_CAPTURE_ABORTED
//
// MessageText:
//
// A biometric sample could not be captured because the operation was aborted.
//
#define WINBIO_E_CAPTURE_ABORTED         ((HRESULT)0x80098006L)

//
// MessageId: WINBIO_E_ENROLLMENT_IN_PROGRESS
//
// MessageText:
//
// An enrollment transaction could not be started because another enrollment is already in progress.
//
#define WINBIO_E_ENROLLMENT_IN_PROGRESS  ((HRESULT)0x80098007L)

//
// MessageId: WINBIO_E_BAD_CAPTURE
//
// MessageText:
//
// The captured sample cannot be used for any further biometric operations.
//
#define WINBIO_E_BAD_CAPTURE             ((HRESULT)0x80098008L)

//
// MessageId: WINBIO_E_INVALID_CONTROL_CODE
//
// MessageText:
//
// The biometric unit doesn't support the specified unit control code.
//
#define WINBIO_E_INVALID_CONTROL_CODE    ((HRESULT)0x80098009L)

//
// WINBIO_E_FACTOR_NOT_PRESENT - 0x8009800A
// [OBSOLETE] - DO NOT USE
//

//
// MessageId: WINBIO_E_DATA_COLLECTION_IN_PROGRESS
//
// MessageText:
//
// The driver already has a pending data collection operation in progress.
//
#define WINBIO_E_DATA_COLLECTION_IN_PROGRESS ((HRESULT)0x8009800BL)

//
// MessageId: WINBIO_E_UNSUPPORTED_DATA_FORMAT
//
// MessageText:
//
// The biometric sensor driver does not support the requested data format.
//
#define WINBIO_E_UNSUPPORTED_DATA_FORMAT ((HRESULT)0x8009800CL)

//
// MessageId: WINBIO_E_UNSUPPORTED_DATA_TYPE
//
// MessageText:
//
// The biometric sensor driver does not support the requested data type.
//
#define WINBIO_E_UNSUPPORTED_DATA_TYPE   ((HRESULT)0x8009800DL)

//
// MessageId: WINBIO_E_UNSUPPORTED_PURPOSE
//
// MessageText:
//
// The biometric sensor driver does not support the requested data purpose.
//
#define WINBIO_E_UNSUPPORTED_PURPOSE     ((HRESULT)0x8009800EL)

//
// MessageId: WINBIO_E_INVALID_DEVICE_STATE
//
// MessageText:
//
// The biometric unit is not in the proper state to perform the specified operation.
//
#define WINBIO_E_INVALID_DEVICE_STATE    ((HRESULT)0x8009800FL)

//
// MessageId: WINBIO_E_DEVICE_BUSY
//
// MessageText:
//
// The operation could not be performed because the sensor device was busy.
//
#define WINBIO_E_DEVICE_BUSY             ((HRESULT)0x80098010L)

//
// MessageId: WINBIO_E_DATABASE_CANT_CREATE
//
// MessageText:
//
// The biometric unit's storage adapter was unable to create a new database.
//
#define WINBIO_E_DATABASE_CANT_CREATE    ((HRESULT)0x80098011L)

//
// MessageId: WINBIO_E_DATABASE_CANT_OPEN
//
// MessageText:
//
// The biometric unit's storage adapter was unable to open an existing database.
//
#define WINBIO_E_DATABASE_CANT_OPEN      ((HRESULT)0x80098012L)

//
// MessageId: WINBIO_E_DATABASE_CANT_CLOSE
//
// MessageText:
//
// The biometric unit's storage adapter was unable to close a database.
//
#define WINBIO_E_DATABASE_CANT_CLOSE     ((HRESULT)0x80098013L)

//
// MessageId: WINBIO_E_DATABASE_CANT_ERASE
//
// MessageText:
//
// The biometric unit's storage adapter was unable to erase a database.
//
#define WINBIO_E_DATABASE_CANT_ERASE     ((HRESULT)0x80098014L)

//
// MessageId: WINBIO_E_DATABASE_CANT_FIND
//
// MessageText:
//
// The biometric unit's storage adapter was unable to find a database.
//
#define WINBIO_E_DATABASE_CANT_FIND      ((HRESULT)0x80098015L)

//
// MessageId: WINBIO_E_DATABASE_ALREADY_EXISTS
//
// MessageText:
//
// The biometric unit's storage adapter was unable to create a database because that database already exists.
//
#define WINBIO_E_DATABASE_ALREADY_EXISTS ((HRESULT)0x80098016L)

//
// WINBIO_E_DATABASE_INVALID_NAME - 0x80098017
// [OBSOLETE] - DO NOT USE
//

//
// MessageId: WINBIO_E_DATABASE_FULL
//
// MessageText:
//
// The biometric unit's storage adapter was unable to add a record to the database because the database is full.
//
#define WINBIO_E_DATABASE_FULL           ((HRESULT)0x80098018L)

//
// MessageId: WINBIO_E_DATABASE_LOCKED
//
// MessageText:
//
// The database is locked and its contents are inaccessible.
//
#define WINBIO_E_DATABASE_LOCKED         ((HRESULT)0x80098019L)

//
// MessageId: WINBIO_E_DATABASE_CORRUPTED
//
// MessageText:
//
// The contents of the database have become corrupted and are inaccessible.
//
#define WINBIO_E_DATABASE_CORRUPTED      ((HRESULT)0x8009801AL)

//
// MessageId: WINBIO_E_DATABASE_NO_SUCH_RECORD
//
// MessageText:
//
// No records were deleted because the specified identity and sub-factor are not present in the database.
//
#define WINBIO_E_DATABASE_NO_SUCH_RECORD ((HRESULT)0x8009801BL)

//
// MessageId: WINBIO_E_DUPLICATE_ENROLLMENT
//
// MessageText:
//
// The specified identity and sub-factor are already enrolled in the database.
//
#define WINBIO_E_DUPLICATE_ENROLLMENT    ((HRESULT)0x8009801CL)

//
// MessageId: WINBIO_E_DATABASE_READ_ERROR
//
// MessageText:
//
// An error occurred while trying to read from the database.
//
#define WINBIO_E_DATABASE_READ_ERROR     ((HRESULT)0x8009801DL)

//
// MessageId: WINBIO_E_DATABASE_WRITE_ERROR
//
// MessageText:
//
// An error occurred while trying to write to the database.
//
#define WINBIO_E_DATABASE_WRITE_ERROR    ((HRESULT)0x8009801EL)

//
// MessageId: WINBIO_E_DATABASE_NO_RESULTS
//
// MessageText:
//
// No records in the database matched the query.
//
#define WINBIO_E_DATABASE_NO_RESULTS     ((HRESULT)0x8009801FL)

//
// MessageId: WINBIO_E_DATABASE_NO_MORE_RECORDS
//
// MessageText:
//
// All records from the most recent database query have been viewed.
//
#define WINBIO_E_DATABASE_NO_MORE_RECORDS ((HRESULT)0x80098020L)

//
// MessageId: WINBIO_E_DATABASE_EOF
//
// MessageText:
//
// A database operation unexpectedly encountered the end of the file.
//
#define WINBIO_E_DATABASE_EOF            ((HRESULT)0x80098021L)

//
// MessageId: WINBIO_E_DATABASE_BAD_INDEX_VECTOR
//
// MessageText:
//
// A database operation failed due to a malformed index vector.
//
#define WINBIO_E_DATABASE_BAD_INDEX_VECTOR ((HRESULT)0x80098022L)

//
// WINBIO_E_INVALID_IDENTITY - 0x80098023
// [OBSOLETE] - DO NOT USE
//

//
// MessageId: WINBIO_E_INCORRECT_BSP
//
// MessageText:
//
// The biometric unit doesn't belong to the specified service provider.
//
#define WINBIO_E_INCORRECT_BSP           ((HRESULT)0x80098024L)

//
// MessageId: WINBIO_E_INCORRECT_SENSOR_POOL
//
// MessageText:
//
// The biometric unit doesn't belong to the specified sensor pool.
//
#define WINBIO_E_INCORRECT_SENSOR_POOL   ((HRESULT)0x80098025L)

//
// MessageId: WINBIO_E_NO_CAPTURE_DATA
//
// MessageText:
//
// The sensor adapter's capture buffer is empty.
//
#define WINBIO_E_NO_CAPTURE_DATA         ((HRESULT)0x80098026L)

//
// MessageId: WINBIO_E_INVALID_SENSOR_MODE
//
// MessageText:
//
// The sensor adapter doesn't support the sensor mode specified in the configuration.
//
#define WINBIO_E_INVALID_SENSOR_MODE     ((HRESULT)0x80098027L)

//
// MessageId: WINBIO_E_LOCK_VIOLATION
//
// MessageText:
//
// The requested operation cannot be performed due to a locking conflict.
//
#define WINBIO_E_LOCK_VIOLATION          ((HRESULT)0x8009802AL)

//
// MessageId: WINBIO_E_DUPLICATE_TEMPLATE
//
// MessageText:
//
// The data in a biometric template matches another template already in the database.
//
#define WINBIO_E_DUPLICATE_TEMPLATE      ((HRESULT)0x8009802BL)

//
// MessageId: WINBIO_E_INVALID_OPERATION
//
// MessageText:
//
// The requested operation is not valid for the current state of the session or biometric unit.
//
#define WINBIO_E_INVALID_OPERATION       ((HRESULT)0x8009802CL)

//
// MessageId: WINBIO_E_SESSION_BUSY
//
// MessageText:
//
// The session cannot begin a new operation because another operation is already in progress.
//
#define WINBIO_E_SESSION_BUSY            ((HRESULT)0x8009802DL)

//
// WINBIO_E_ASYNC_OPERATION_IN_PROGRESS - 0x8009802E
// [OBSOLETE] - DO NOT USE
//

//
// WINBIO_E_INVALID_ASYNC_OPERATION - 0x8009802F
// [OBSOLETE] - DO NOT USE
//

//
// MessageId: WINBIO_E_CRED_PROV_DISABLED
//
// MessageText:
//
// System policy settings have disabled the Windows biometric credential provider.
//
#define WINBIO_E_CRED_PROV_DISABLED      ((HRESULT)0x80098030L)

//
// MessageId: WINBIO_E_CRED_PROV_NO_CREDENTIAL
//
// MessageText:
//
// The requested credential was not found.
//
#define WINBIO_E_CRED_PROV_NO_CREDENTIAL ((HRESULT)0x80098031L)

//
// MessageId: WINBIO_E_DISABLED
//
// MessageText:
//
// System policy settings have disabled the Windows biometric service.
//
#define WINBIO_E_DISABLED                ((HRESULT)0x80098032L)

//
// MessageId: WINBIO_E_CONFIGURATION_FAILURE
//
// MessageText:
//
// The biometric unit could not be configured.
//
#define WINBIO_E_CONFIGURATION_FAILURE   ((HRESULT)0x80098033L)

//
// MessageId: WINBIO_E_SENSOR_UNAVAILABLE
//
// MessageText:
//
// A private pool cannot be created because one or more biometric units are not available.
//
#define WINBIO_E_SENSOR_UNAVAILABLE      ((HRESULT)0x80098034L)

//
// MessageId: WINBIO_E_SAS_ENABLED
//
// MessageText:
//
// A secure attention sequence (CTRL-ALT-DEL) is required for logon.
//
#define WINBIO_E_SAS_ENABLED             ((HRESULT)0x80098035L)

//
// MessageId: WINBIO_E_DEVICE_FAILURE
//
// MessageText:
//
// A biometric sensor has failed.
//
#define WINBIO_E_DEVICE_FAILURE          ((HRESULT)0x80098036L)

//
// MessageId: WINBIO_E_FAST_USER_SWITCH_DISABLED
//
// MessageText:
//
// Fast user switching is disabled.
//
#define WINBIO_E_FAST_USER_SWITCH_DISABLED ((HRESULT)0x80098037L)

//
// MessageId: WINBIO_E_NOT_ACTIVE_CONSOLE
//
// MessageText:
//
// The System sensor pool cannot be opened from Terminal Server client sessions.
//
#define WINBIO_E_NOT_ACTIVE_CONSOLE      ((HRESULT)0x80098038L)

//
// MessageId: WINBIO_E_EVENT_MONITOR_ACTIVE
//
// MessageText:
//
// There is already an active event monitor associated with the specified session.
//
#define WINBIO_E_EVENT_MONITOR_ACTIVE    ((HRESULT)0x80098039L)

//
// MessageId: WINBIO_E_INVALID_PROPERTY_TYPE
//
// MessageText:
//
// The value specified is not a valid property type.
//
#define WINBIO_E_INVALID_PROPERTY_TYPE   ((HRESULT)0x8009803AL)

//
// MessageId: WINBIO_E_INVALID_PROPERTY_ID
//
// MessageText:
//
// The value specified is not a valid property ID.
//
#define WINBIO_E_INVALID_PROPERTY_ID     ((HRESULT)0x8009803BL)

//
// MessageId: WINBIO_E_UNSUPPORTED_PROPERTY
//
// MessageText:
//
// The biometric unit doesn't support the specified property.
//
#define WINBIO_E_UNSUPPORTED_PROPERTY    ((HRESULT)0x8009803CL)

//
// MessageId: WINBIO_E_ADAPTER_INTEGRITY_FAILURE
//
// MessageText:
//
// The adapter binary did not pass its integrity check.
//
#define WINBIO_E_ADAPTER_INTEGRITY_FAILURE ((HRESULT)0x8009803DL)

//
// Informational messages -- values are in the range: 0x0001 - 0x7FFF
//
//
// MessageId: WINBIO_I_MORE_DATA
//
// MessageText:
//
// Another sample is needed for the current enrollment template.
//
#define WINBIO_I_MORE_DATA               ((HRESULT)0x00090001L)


#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#endif // _WINBIO_ERR_H_06269BBC_B52E_4d0d_9D35_D23BEA12DE5D_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wincodec.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wincodec.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wincodec_h__
#define __wincodec_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWICPalette_FWD_DEFINED__
#define __IWICPalette_FWD_DEFINED__
typedef interface IWICPalette IWICPalette;
#endif 	/* __IWICPalette_FWD_DEFINED__ */


#ifndef __IWICBitmapSource_FWD_DEFINED__
#define __IWICBitmapSource_FWD_DEFINED__
typedef interface IWICBitmapSource IWICBitmapSource;
#endif 	/* __IWICBitmapSource_FWD_DEFINED__ */


#ifndef __IWICFormatConverter_FWD_DEFINED__
#define __IWICFormatConverter_FWD_DEFINED__
typedef interface IWICFormatConverter IWICFormatConverter;
#endif 	/* __IWICFormatConverter_FWD_DEFINED__ */


#ifndef __IWICBitmapScaler_FWD_DEFINED__
#define __IWICBitmapScaler_FWD_DEFINED__
typedef interface IWICBitmapScaler IWICBitmapScaler;
#endif 	/* __IWICBitmapScaler_FWD_DEFINED__ */


#ifndef __IWICBitmapClipper_FWD_DEFINED__
#define __IWICBitmapClipper_FWD_DEFINED__
typedef interface IWICBitmapClipper IWICBitmapClipper;
#endif 	/* __IWICBitmapClipper_FWD_DEFINED__ */


#ifndef __IWICBitmapFlipRotator_FWD_DEFINED__
#define __IWICBitmapFlipRotator_FWD_DEFINED__
typedef interface IWICBitmapFlipRotator IWICBitmapFlipRotator;
#endif 	/* __IWICBitmapFlipRotator_FWD_DEFINED__ */


#ifndef __IWICBitmapLock_FWD_DEFINED__
#define __IWICBitmapLock_FWD_DEFINED__
typedef interface IWICBitmapLock IWICBitmapLock;
#endif 	/* __IWICBitmapLock_FWD_DEFINED__ */


#ifndef __IWICBitmap_FWD_DEFINED__
#define __IWICBitmap_FWD_DEFINED__
typedef interface IWICBitmap IWICBitmap;
#endif 	/* __IWICBitmap_FWD_DEFINED__ */


#ifndef __IWICColorContext_FWD_DEFINED__
#define __IWICColorContext_FWD_DEFINED__
typedef interface IWICColorContext IWICColorContext;
#endif 	/* __IWICColorContext_FWD_DEFINED__ */


#ifndef __IWICColorTransform_FWD_DEFINED__
#define __IWICColorTransform_FWD_DEFINED__
typedef interface IWICColorTransform IWICColorTransform;
#endif 	/* __IWICColorTransform_FWD_DEFINED__ */


#ifndef __IWICFastMetadataEncoder_FWD_DEFINED__
#define __IWICFastMetadataEncoder_FWD_DEFINED__
typedef interface IWICFastMetadataEncoder IWICFastMetadataEncoder;
#endif 	/* __IWICFastMetadataEncoder_FWD_DEFINED__ */


#ifndef __IWICStream_FWD_DEFINED__
#define __IWICStream_FWD_DEFINED__
typedef interface IWICStream IWICStream;
#endif 	/* __IWICStream_FWD_DEFINED__ */


#ifndef __IWICEnumMetadataItem_FWD_DEFINED__
#define __IWICEnumMetadataItem_FWD_DEFINED__
typedef interface IWICEnumMetadataItem IWICEnumMetadataItem;
#endif 	/* __IWICEnumMetadataItem_FWD_DEFINED__ */


#ifndef __IWICMetadataQueryReader_FWD_DEFINED__
#define __IWICMetadataQueryReader_FWD_DEFINED__
typedef interface IWICMetadataQueryReader IWICMetadataQueryReader;
#endif 	/* __IWICMetadataQueryReader_FWD_DEFINED__ */


#ifndef __IWICMetadataQueryWriter_FWD_DEFINED__
#define __IWICMetadataQueryWriter_FWD_DEFINED__
typedef interface IWICMetadataQueryWriter IWICMetadataQueryWriter;
#endif 	/* __IWICMetadataQueryWriter_FWD_DEFINED__ */


#ifndef __IWICBitmapEncoder_FWD_DEFINED__
#define __IWICBitmapEncoder_FWD_DEFINED__
typedef interface IWICBitmapEncoder IWICBitmapEncoder;
#endif 	/* __IWICBitmapEncoder_FWD_DEFINED__ */


#ifndef __IWICBitmapFrameEncode_FWD_DEFINED__
#define __IWICBitmapFrameEncode_FWD_DEFINED__
typedef interface IWICBitmapFrameEncode IWICBitmapFrameEncode;
#endif 	/* __IWICBitmapFrameEncode_FWD_DEFINED__ */


#ifndef __IWICBitmapDecoder_FWD_DEFINED__
#define __IWICBitmapDecoder_FWD_DEFINED__
typedef interface IWICBitmapDecoder IWICBitmapDecoder;
#endif 	/* __IWICBitmapDecoder_FWD_DEFINED__ */


#ifndef __IWICBitmapSourceTransform_FWD_DEFINED__
#define __IWICBitmapSourceTransform_FWD_DEFINED__
typedef interface IWICBitmapSourceTransform IWICBitmapSourceTransform;
#endif 	/* __IWICBitmapSourceTransform_FWD_DEFINED__ */


#ifndef __IWICBitmapFrameDecode_FWD_DEFINED__
#define __IWICBitmapFrameDecode_FWD_DEFINED__
typedef interface IWICBitmapFrameDecode IWICBitmapFrameDecode;
#endif 	/* __IWICBitmapFrameDecode_FWD_DEFINED__ */


#ifndef __IWICProgressiveLevelControl_FWD_DEFINED__
#define __IWICProgressiveLevelControl_FWD_DEFINED__
typedef interface IWICProgressiveLevelControl IWICProgressiveLevelControl;
#endif 	/* __IWICProgressiveLevelControl_FWD_DEFINED__ */


#ifndef __IWICProgressCallback_FWD_DEFINED__
#define __IWICProgressCallback_FWD_DEFINED__
typedef interface IWICProgressCallback IWICProgressCallback;
#endif 	/* __IWICProgressCallback_FWD_DEFINED__ */


#ifndef __IWICBitmapCodecProgressNotification_FWD_DEFINED__
#define __IWICBitmapCodecProgressNotification_FWD_DEFINED__
typedef interface IWICBitmapCodecProgressNotification IWICBitmapCodecProgressNotification;
#endif 	/* __IWICBitmapCodecProgressNotification_FWD_DEFINED__ */


#ifndef __IWICComponentInfo_FWD_DEFINED__
#define __IWICComponentInfo_FWD_DEFINED__
typedef interface IWICComponentInfo IWICComponentInfo;
#endif 	/* __IWICComponentInfo_FWD_DEFINED__ */


#ifndef __IWICFormatConverterInfo_FWD_DEFINED__
#define __IWICFormatConverterInfo_FWD_DEFINED__
typedef interface IWICFormatConverterInfo IWICFormatConverterInfo;
#endif 	/* __IWICFormatConverterInfo_FWD_DEFINED__ */


#ifndef __IWICBitmapCodecInfo_FWD_DEFINED__
#define __IWICBitmapCodecInfo_FWD_DEFINED__
typedef interface IWICBitmapCodecInfo IWICBitmapCodecInfo;
#endif 	/* __IWICBitmapCodecInfo_FWD_DEFINED__ */


#ifndef __IWICBitmapEncoderInfo_FWD_DEFINED__
#define __IWICBitmapEncoderInfo_FWD_DEFINED__
typedef interface IWICBitmapEncoderInfo IWICBitmapEncoderInfo;
#endif 	/* __IWICBitmapEncoderInfo_FWD_DEFINED__ */


#ifndef __IWICBitmapDecoderInfo_FWD_DEFINED__
#define __IWICBitmapDecoderInfo_FWD_DEFINED__
typedef interface IWICBitmapDecoderInfo IWICBitmapDecoderInfo;
#endif 	/* __IWICBitmapDecoderInfo_FWD_DEFINED__ */


#ifndef __IWICPixelFormatInfo_FWD_DEFINED__
#define __IWICPixelFormatInfo_FWD_DEFINED__
typedef interface IWICPixelFormatInfo IWICPixelFormatInfo;
#endif 	/* __IWICPixelFormatInfo_FWD_DEFINED__ */


#ifndef __IWICPixelFormatInfo2_FWD_DEFINED__
#define __IWICPixelFormatInfo2_FWD_DEFINED__
typedef interface IWICPixelFormatInfo2 IWICPixelFormatInfo2;
#endif 	/* __IWICPixelFormatInfo2_FWD_DEFINED__ */


#ifndef __IWICImagingFactory_FWD_DEFINED__
#define __IWICImagingFactory_FWD_DEFINED__
typedef interface IWICImagingFactory IWICImagingFactory;
#endif 	/* __IWICImagingFactory_FWD_DEFINED__ */


#ifndef __IWICDevelopRawNotificationCallback_FWD_DEFINED__
#define __IWICDevelopRawNotificationCallback_FWD_DEFINED__
typedef interface IWICDevelopRawNotificationCallback IWICDevelopRawNotificationCallback;
#endif 	/* __IWICDevelopRawNotificationCallback_FWD_DEFINED__ */


#ifndef __IWICDevelopRaw_FWD_DEFINED__
#define __IWICDevelopRaw_FWD_DEFINED__
typedef interface IWICDevelopRaw IWICDevelopRaw;
#endif 	/* __IWICDevelopRaw_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "propidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wincodec_0000_0000 */
/* [local] */ 

#include <intsafe.h>
#define WINCODEC_SDK_VERSION 0x0236
DEFINE_GUID(CLSID_WICImagingFactory, 0xcacaf262, 0x9370, 0x4615, 0xa1, 0x3b, 0x9f, 0x55, 0x39, 0xda, 0x4c, 0xa);
DEFINE_GUID(GUID_VendorMicrosoft, 0xf0e749ca, 0xedef, 0x4589, 0xa7, 0x3a, 0xee, 0xe, 0x62, 0x6a, 0x2a, 0x2b);
DEFINE_GUID(GUID_VendorMicrosoftBuiltIn, 0x257a30fd, 0x6b6, 0x462b, 0xae, 0xa4, 0x63, 0xf7, 0xb, 0x86, 0xe5, 0x33);
DEFINE_GUID(CLSID_WICBmpDecoder,  0x6b462062, 0x7cbf, 0x400d, 0x9f, 0xdb, 0x81, 0x3d, 0xd1, 0x0f, 0x27, 0x78);
DEFINE_GUID(CLSID_WICPngDecoder,  0x389ea17b, 0x5078, 0x4cde, 0xb6, 0xef, 0x25, 0xc1, 0x51, 0x75, 0xc7, 0x51);
DEFINE_GUID(CLSID_WICIcoDecoder,  0xc61bfcdf, 0x2e0f, 0x4aad, 0xa8, 0xd7, 0xe0, 0x6b, 0xaf, 0xeb, 0xcd, 0xfe);
DEFINE_GUID(CLSID_WICJpegDecoder, 0x9456a480, 0xe88b, 0x43ea, 0x9e, 0x73, 0x0b, 0x2d, 0x9b, 0x71, 0xb1, 0xca);
DEFINE_GUID(CLSID_WICGifDecoder,  0x381dda3c, 0x9ce9, 0x4834, 0xa2, 0x3e, 0x1f, 0x98, 0xf8, 0xfc, 0x52, 0xbe);
DEFINE_GUID(CLSID_WICTiffDecoder, 0xb54e85d9, 0xfe23, 0x499f, 0x8b, 0x88, 0x6a, 0xce, 0xa7, 0x13, 0x75, 0x2b);
DEFINE_GUID(CLSID_WICWmpDecoder,  0xa26cec36, 0x234c, 0x4950, 0xae, 0x16, 0xe3, 0x4a, 0xac, 0xe7, 0x1d, 0x0d);
DEFINE_GUID(CLSID_WICBmpEncoder,  0x69be8bb4, 0xd66d, 0x47c8, 0x86, 0x5a, 0xed, 0x15, 0x89, 0x43, 0x37, 0x82);
DEFINE_GUID(CLSID_WICPngEncoder,  0x27949969, 0x876a, 0x41d7, 0x94, 0x47, 0x56, 0x8f, 0x6a, 0x35, 0xa4, 0xdc);
DEFINE_GUID(CLSID_WICJpegEncoder, 0x1a34f5c1, 0x4a5a, 0x46dc, 0xb6, 0x44, 0x1f, 0x45, 0x67, 0xe7, 0xa6, 0x76);
DEFINE_GUID(CLSID_WICGifEncoder,  0x114f5598, 0x0b22, 0x40a0, 0x86, 0xa1, 0xc8, 0x3e, 0xa4, 0x95, 0xad, 0xbd);
DEFINE_GUID(CLSID_WICTiffEncoder, 0x0131be10, 0x2001, 0x4c5f, 0xa9, 0xb0, 0xcc, 0x88, 0xfa, 0xb6, 0x4c, 0xe8);
DEFINE_GUID(CLSID_WICWmpEncoder,  0xac4ce3cb, 0xe1c1, 0x44cd, 0x82, 0x15, 0x5a, 0x16, 0x65, 0x50, 0x9e, 0xc2);
DEFINE_GUID(GUID_ContainerFormatBmp,  0x0af1d87e, 0xfcfe, 0x4188, 0xbd, 0xeb, 0xa7, 0x90, 0x64, 0x71, 0xcb, 0xe3);
DEFINE_GUID(GUID_ContainerFormatPng,  0x1b7cfaf4, 0x713f, 0x473c, 0xbb, 0xcd, 0x61, 0x37, 0x42, 0x5f, 0xae, 0xaf);
DEFINE_GUID(GUID_ContainerFormatIco,  0xa3a860c4, 0x338f, 0x4c17, 0x91, 0x9a, 0xfb, 0xa4, 0xb5, 0x62, 0x8f, 0x21);
DEFINE_GUID(GUID_ContainerFormatJpeg, 0x19e4a5aa, 0x5662, 0x4fc5, 0xa0, 0xc0, 0x17, 0x58, 0x02, 0x8e, 0x10, 0x57);
DEFINE_GUID(GUID_ContainerFormatTiff, 0x163bcc30, 0xe2e9, 0x4f0b, 0x96, 0x1d, 0xa3, 0xe9, 0xfd, 0xb7, 0x88, 0xa3);
DEFINE_GUID(GUID_ContainerFormatGif,  0x1f8a5601, 0x7d4d, 0x4cbd, 0x9c, 0x82, 0x1b, 0xc8, 0xd4, 0xee, 0xb9, 0xa5);
DEFINE_GUID(GUID_ContainerFormatWmp,  0x57a37caa, 0x367a, 0x4540, 0x91, 0x6b, 0xf1, 0x83, 0xc5, 0x09, 0x3a, 0x4b);
DEFINE_GUID(CLSID_WICImagingCategories, 0xfae3d380, 0xfea4, 0x4623, 0x8c, 0x75, 0xc6, 0xb6, 0x11, 0x10, 0xb6, 0x81);
DEFINE_GUID(CATID_WICBitmapDecoders,    0x7ed96837, 0x96f0, 0x4812, 0xb2, 0x11, 0xf1, 0x3c, 0x24, 0x11, 0x7e, 0xd3);
DEFINE_GUID(CATID_WICBitmapEncoders,    0xac757296, 0x3522, 0x4e11, 0x98, 0x62, 0xc1, 0x7b, 0xe5, 0xa1, 0x76, 0x7e);
DEFINE_GUID(CATID_WICPixelFormats,      0x2b46e70f, 0xcda7, 0x473e, 0x89, 0xf6, 0xdc, 0x96, 0x30, 0xa2, 0x39, 0x0b);
DEFINE_GUID(CATID_WICFormatConverters,  0x7835eae8, 0xbf14, 0x49d1, 0x93, 0xce, 0x53, 0x3a, 0x40, 0x7b, 0x22, 0x48);
DEFINE_GUID(CATID_WICMetadataReader,    0x05af94d8, 0x7174, 0x4cd2, 0xbe, 0x4a, 0x41, 0x24, 0xb8, 0x0e, 0xe4, 0xb8);
DEFINE_GUID(CATID_WICMetadataWriter,    0xabe3b9a4, 0x257d, 0x4b97, 0xbd, 0x1a, 0x29, 0x4a, 0xf4, 0x96, 0x22, 0x2e);
DEFINE_GUID(CLSID_WICDefaultFormatConverter, 0x1a3f11dc, 0xb514, 0x4b17, 0x8c, 0x5f, 0x21, 0x54, 0x51, 0x38, 0x52, 0xf1);
DEFINE_GUID(CLSID_WICFormatConverterHighColor, 0xac75d454, 0x9f37, 0x48f8, 0xb9, 0x72, 0x4e, 0x19, 0xbc, 0x85, 0x60, 0x11);
DEFINE_GUID(CLSID_WICFormatConverterNChannel, 0xc17cabb2, 0xd4a3, 0x47d7, 0xa5, 0x57, 0x33, 0x9b, 0x2e, 0xfb, 0xd4, 0xf1);
DEFINE_GUID(CLSID_WICFormatConverterWMPhoto, 0x9cb5172b, 0xd600, 0x46ba, 0xab, 0x77, 0x77, 0xbb, 0x7e, 0x3a, 0x00, 0xd9);























typedef UINT32 WICColor;

typedef /* [public] */ struct WICRect
    {
    INT X;
    INT Y;
    INT Width;
    INT Height;
    } 	WICRect;

typedef BYTE* WICInProcPointer;
#if 0
typedef /* [wire_marshal] */ void *WICInProcPointer;

#endif
typedef /* [public] */ 
enum WICColorContextType
    {	WICColorContextUninitialized	= 0,
	WICColorContextProfile	= 0x1,
	WICColorContextExifColorSpace	= 0x2
    } 	WICColorContextType;

typedef /* [public] */ REFGUID REFWICPixelFormatGUID;

typedef /* [public] */ GUID WICPixelFormatGUID;

#define GUID_WICPixelFormatUndefined GUID_WICPixelFormatDontCare
DEFINE_GUID(GUID_WICPixelFormatDontCare, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x00);
DEFINE_GUID(GUID_WICPixelFormat1bppIndexed, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x01);
DEFINE_GUID(GUID_WICPixelFormat2bppIndexed, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x02);
DEFINE_GUID(GUID_WICPixelFormat4bppIndexed, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x03);
DEFINE_GUID(GUID_WICPixelFormat8bppIndexed, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x04);
DEFINE_GUID(GUID_WICPixelFormatBlackWhite, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x05);
DEFINE_GUID(GUID_WICPixelFormat2bppGray,   0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x06);
DEFINE_GUID(GUID_WICPixelFormat4bppGray,   0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x07);
DEFINE_GUID(GUID_WICPixelFormat8bppGray,   0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x08);
DEFINE_GUID(GUID_WICPixelFormat8bppAlpha, 0xe6cd0116, 0xeeba, 0x4161, 0xaa, 0x85, 0x27, 0xdd, 0x9f, 0xb3, 0xa8, 0x95);
DEFINE_GUID(GUID_WICPixelFormat16bppBGR555, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x09);
DEFINE_GUID(GUID_WICPixelFormat16bppBGR565, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0a);
DEFINE_GUID(GUID_WICPixelFormat16bppBGRA5551, 0x05ec7c2b, 0xf1e6, 0x4961, 0xad, 0x46, 0xe1, 0xcc, 0x81, 0x0a, 0x87, 0xd2);
DEFINE_GUID(GUID_WICPixelFormat16bppGray,   0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0b);
DEFINE_GUID(GUID_WICPixelFormat24bppBGR, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0c);
DEFINE_GUID(GUID_WICPixelFormat24bppRGB, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0d);
DEFINE_GUID(GUID_WICPixelFormat32bppBGR,   0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0e);
DEFINE_GUID(GUID_WICPixelFormat32bppBGRA,  0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x0f);
DEFINE_GUID(GUID_WICPixelFormat32bppPBGRA, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x10);
DEFINE_GUID(GUID_WICPixelFormat32bppGrayFloat,  0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x11);
DEFINE_GUID(GUID_WICPixelFormat32bppRGBA, 0xf5c7ad2d, 0x6a8d, 0x43dd, 0xa7, 0xa8, 0xa2, 0x99, 0x35, 0x26, 0x1a, 0xe9);
DEFINE_GUID(GUID_WICPixelFormat32bppPRGBA, 0x3cc4a650, 0xa527, 0x4d37, 0xa9, 0x16, 0x31, 0x42, 0xc7, 0xeb, 0xed, 0xba);
DEFINE_GUID(GUID_WICPixelFormat48bppRGB, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x15);
DEFINE_GUID(GUID_WICPixelFormat48bppBGR, 0xe605a384, 0xb468, 0x46ce, 0xbb, 0x2e, 0x36, 0xf1, 0x80, 0xe6, 0x43, 0x13);
DEFINE_GUID(GUID_WICPixelFormat64bppRGBA,  0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x16);
DEFINE_GUID(GUID_WICPixelFormat64bppBGRA,  0x1562ff7c, 0xd352, 0x46f9, 0x97, 0x9e, 0x42, 0x97, 0x6b, 0x79, 0x22, 0x46);
DEFINE_GUID(GUID_WICPixelFormat64bppPRGBA, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x17);
DEFINE_GUID(GUID_WICPixelFormat64bppPBGRA, 0x8c518e8e, 0xa4ec, 0x468b, 0xae, 0x70, 0xc9, 0xa3, 0x5a, 0x9c, 0x55, 0x30);
DEFINE_GUID(GUID_WICPixelFormat16bppGrayFixedPoint, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x13);
DEFINE_GUID(GUID_WICPixelFormat32bppBGR101010, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x14);
DEFINE_GUID(GUID_WICPixelFormat48bppRGBFixedPoint, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x12);
DEFINE_GUID(GUID_WICPixelFormat48bppBGRFixedPoint, 0x49ca140e, 0xcab6, 0x493b, 0x9d, 0xdf, 0x60, 0x18, 0x7c, 0x37, 0x53, 0x2a);
DEFINE_GUID(GUID_WICPixelFormat96bppRGBFixedPoint, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x18);
DEFINE_GUID(GUID_WICPixelFormat128bppRGBAFloat,  0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x19);
DEFINE_GUID(GUID_WICPixelFormat128bppPRGBAFloat, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x1a);
DEFINE_GUID(GUID_WICPixelFormat128bppRGBFloat,   0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x1b);
DEFINE_GUID(GUID_WICPixelFormat32bppCMYK, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x1c);
DEFINE_GUID(GUID_WICPixelFormat64bppRGBAFixedPoint, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x1d);
DEFINE_GUID(GUID_WICPixelFormat64bppBGRAFixedPoint, 0x356de33c, 0x54d2, 0x4a23, 0xbb, 0x4, 0x9b, 0x7b, 0xf9, 0xb1, 0xd4, 0x2d);
DEFINE_GUID(GUID_WICPixelFormat64bppRGBFixedPoint, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x40);
DEFINE_GUID(GUID_WICPixelFormat128bppRGBAFixedPoint, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x1e);
DEFINE_GUID(GUID_WICPixelFormat128bppRGBFixedPoint, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x41);
DEFINE_GUID(GUID_WICPixelFormat64bppRGBAHalf, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x3a);
DEFINE_GUID(GUID_WICPixelFormat64bppRGBHalf, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x42);
DEFINE_GUID(GUID_WICPixelFormat48bppRGBHalf, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x3b);
DEFINE_GUID(GUID_WICPixelFormat32bppRGBE, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x3d);
DEFINE_GUID(GUID_WICPixelFormat16bppGrayHalf, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x3e);
DEFINE_GUID(GUID_WICPixelFormat32bppGrayFixedPoint, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x3f);
DEFINE_GUID(GUID_WICPixelFormat32bppRGBA1010102, 0x25238D72, 0xFCF9, 0x4522, 0xb5, 0x14, 0x55, 0x78, 0xe5, 0xad, 0x55, 0xe0);
DEFINE_GUID(GUID_WICPixelFormat32bppRGBA1010102XR, 0x00DE6B9A, 0xC101, 0x434b, 0xb5, 0x02, 0xd0, 0x16, 0x5e, 0xe1, 0x12, 0x2c);
DEFINE_GUID(GUID_WICPixelFormat64bppCMYK, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x1f);
DEFINE_GUID(GUID_WICPixelFormat24bpp3Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x20);
DEFINE_GUID(GUID_WICPixelFormat32bpp4Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x21);
DEFINE_GUID(GUID_WICPixelFormat40bpp5Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x22);
DEFINE_GUID(GUID_WICPixelFormat48bpp6Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x23);
DEFINE_GUID(GUID_WICPixelFormat56bpp7Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x24);
DEFINE_GUID(GUID_WICPixelFormat64bpp8Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x25);
DEFINE_GUID(GUID_WICPixelFormat48bpp3Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x26);
DEFINE_GUID(GUID_WICPixelFormat64bpp4Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x27);
DEFINE_GUID(GUID_WICPixelFormat80bpp5Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x28);
DEFINE_GUID(GUID_WICPixelFormat96bpp6Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x29);
DEFINE_GUID(GUID_WICPixelFormat112bpp7Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x2a);
DEFINE_GUID(GUID_WICPixelFormat128bpp8Channels, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x2b);
DEFINE_GUID(GUID_WICPixelFormat40bppCMYKAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x2c);
DEFINE_GUID(GUID_WICPixelFormat80bppCMYKAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x2d);
DEFINE_GUID(GUID_WICPixelFormat32bpp3ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x2e);
DEFINE_GUID(GUID_WICPixelFormat40bpp4ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x2f);
DEFINE_GUID(GUID_WICPixelFormat48bpp5ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x30);
DEFINE_GUID(GUID_WICPixelFormat56bpp6ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x31);
DEFINE_GUID(GUID_WICPixelFormat64bpp7ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x32);
DEFINE_GUID(GUID_WICPixelFormat72bpp8ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x33);
DEFINE_GUID(GUID_WICPixelFormat64bpp3ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x34);
DEFINE_GUID(GUID_WICPixelFormat80bpp4ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x35);
DEFINE_GUID(GUID_WICPixelFormat96bpp5ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x36);
DEFINE_GUID(GUID_WICPixelFormat112bpp6ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x37);
DEFINE_GUID(GUID_WICPixelFormat128bpp7ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x38);
DEFINE_GUID(GUID_WICPixelFormat144bpp8ChannelsAlpha, 0x6fddc324, 0x4e03, 0x4bfe, 0xb1, 0x85, 0x3d, 0x77, 0x76, 0x8d, 0xc9, 0x39);
typedef /* [public] */ 
enum WICBitmapCreateCacheOption
    {	WICBitmapNoCache	= 0,
	WICBitmapCacheOnDemand	= 0x1,
	WICBitmapCacheOnLoad	= 0x2,
	WICBITMAPCREATECACHEOPTION_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapCreateCacheOption;

typedef /* [public] */ 
enum WICDecodeOptions
    {	WICDecodeMetadataCacheOnDemand	= 0,
	WICDecodeMetadataCacheOnLoad	= 0x1,
	WICMETADATACACHEOPTION_FORCE_DWORD	= 0x7fffffff
    } 	WICDecodeOptions;

typedef /* [public] */ 
enum WICBitmapEncoderCacheOption
    {	WICBitmapEncoderCacheInMemory	= 0,
	WICBitmapEncoderCacheTempFile	= 0x1,
	WICBitmapEncoderNoCache	= 0x2,
	WICBITMAPENCODERCACHEOPTION_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapEncoderCacheOption;

typedef /* [public] */ 
enum WICComponentType
    {	WICDecoder	= 0x1,
	WICEncoder	= 0x2,
	WICPixelFormatConverter	= 0x4,
	WICMetadataReader	= 0x8,
	WICMetadataWriter	= 0x10,
	WICPixelFormat	= 0x20,
	WICAllComponents	= 0x3f,
	WICCOMPONENTTYPE_FORCE_DWORD	= 0x7fffffff
    } 	WICComponentType;

typedef /* [public] */ 
enum WICComponentEnumerateOptions
    {	WICComponentEnumerateDefault	= 0,
	WICComponentEnumerateRefresh	= 0x1,
	WICComponentEnumerateDisabled	= 0x80000000,
	WICComponentEnumerateUnsigned	= 0x40000000,
	WICComponentEnumerateBuiltInOnly	= 0x20000000,
	WICCOMPONENTENUMERATEOPTIONS_FORCE_DWORD	= 0x7fffffff
    } 	WICComponentEnumerateOptions;

typedef /* [public] */ struct WICBitmapPattern
    {
    ULARGE_INTEGER Position;
    ULONG Length;
    BYTE *Pattern;
    BYTE *Mask;
    BOOL EndOfStream;
    } 	WICBitmapPattern;

typedef /* [public] */ 
enum WICBitmapInterpolationMode
    {	WICBitmapInterpolationModeNearestNeighbor	= 0,
	WICBitmapInterpolationModeLinear	= 0x1,
	WICBitmapInterpolationModeCubic	= 0x2,
	WICBitmapInterpolationModeFant	= 0x3,
	WICBITMAPINTERPOLATIONMODE_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapInterpolationMode;

typedef /* [public] */ 
enum WICBitmapPaletteType
    {	WICBitmapPaletteTypeCustom	= 0,
	WICBitmapPaletteTypeMedianCut	= 0x1,
	WICBitmapPaletteTypeFixedBW	= 0x2,
	WICBitmapPaletteTypeFixedHalftone8	= 0x3,
	WICBitmapPaletteTypeFixedHalftone27	= 0x4,
	WICBitmapPaletteTypeFixedHalftone64	= 0x5,
	WICBitmapPaletteTypeFixedHalftone125	= 0x6,
	WICBitmapPaletteTypeFixedHalftone216	= 0x7,
	WICBitmapPaletteTypeFixedWebPalette	= WICBitmapPaletteTypeFixedHalftone216,
	WICBitmapPaletteTypeFixedHalftone252	= 0x8,
	WICBitmapPaletteTypeFixedHalftone256	= 0x9,
	WICBitmapPaletteTypeFixedGray4	= 0xa,
	WICBitmapPaletteTypeFixedGray16	= 0xb,
	WICBitmapPaletteTypeFixedGray256	= 0xc,
	WICBITMAPPALETTETYPE_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapPaletteType;

typedef /* [public] */ 
enum WICBitmapDitherType
    {	WICBitmapDitherTypeNone	= 0,
	WICBitmapDitherTypeSolid	= 0,
	WICBitmapDitherTypeOrdered4x4	= 0x1,
	WICBitmapDitherTypeOrdered8x8	= 0x2,
	WICBitmapDitherTypeOrdered16x16	= 0x3,
	WICBitmapDitherTypeSpiral4x4	= 0x4,
	WICBitmapDitherTypeSpiral8x8	= 0x5,
	WICBitmapDitherTypeDualSpiral4x4	= 0x6,
	WICBitmapDitherTypeDualSpiral8x8	= 0x7,
	WICBitmapDitherTypeErrorDiffusion	= 0x8,
	WICBITMAPDITHERTYPE_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapDitherType;

typedef /* [public] */ 
enum WICBitmapAlphaChannelOption
    {	WICBitmapUseAlpha	= 0,
	WICBitmapUsePremultipliedAlpha	= 0x1,
	WICBitmapIgnoreAlpha	= 0x2,
	WICBITMAPALPHACHANNELOPTIONS_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapAlphaChannelOption;

typedef /* [public] */ 
enum WICBitmapTransformOptions
    {	WICBitmapTransformRotate0	= 0,
	WICBitmapTransformRotate90	= 0x1,
	WICBitmapTransformRotate180	= 0x2,
	WICBitmapTransformRotate270	= 0x3,
	WICBitmapTransformFlipHorizontal	= 0x8,
	WICBitmapTransformFlipVertical	= 0x10,
	WICBITMAPTRANSFORMOPTIONS_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapTransformOptions;

typedef /* [public] */ 
enum WICBitmapLockFlags
    {	WICBitmapLockRead	= 0x1,
	WICBitmapLockWrite	= 0x2,
	WICBITMAPLOCKFLAGS_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapLockFlags;

typedef /* [public] */ 
enum WICBitmapDecoderCapabilities
    {	WICBitmapDecoderCapabilitySameEncoder	= 0x1,
	WICBitmapDecoderCapabilityCanDecodeAllImages	= 0x2,
	WICBitmapDecoderCapabilityCanDecodeSomeImages	= 0x4,
	WICBitmapDecoderCapabilityCanEnumerateMetadata	= 0x8,
	WICBitmapDecoderCapabilityCanDecodeThumbnail	= 0x10,
	WICBITMAPDECODERCAPABILITIES_FORCE_DWORD	= 0x7fffffff
    } 	WICBitmapDecoderCapabilities;

typedef /* [public] */ 
enum WICProgressOperation
    {	WICProgressOperationCopyPixels	= 0x1,
	WICProgressOperationWritePixels	= 0x2,
	WICProgressOperationAll	= 0xffff,
	WICPROGRESSOPERATION_FORCE_DWORD	= 0x7fffffff
    } 	WICProgressOperation;

typedef /* [public] */ 
enum WICProgressNotification
    {	WICProgressNotificationBegin	= 0x10000,
	WICProgressNotificationEnd	= 0x20000,
	WICProgressNotificationFrequent	= 0x40000,
	WICProgressNotificationAll	= 0xffff0000,
	WICPROGRESSNOTIFICATION_FORCE_DWORD	= 0x7fffffff
    } 	WICProgressNotification;

typedef /* [public] */ 
enum WICComponentSigning
    {	WICComponentSigned	= 0x1,
	WICComponentUnsigned	= 0x2,
	WICComponentSafe	= 0x4,
	WICComponentDisabled	= 0x80000000,
	WICCOMPONENTSIGNING_FORCE_DWORD	= 0x7fffffff
    } 	WICComponentSigning;

typedef /* [public] */ 
enum WICGifLogicalScreenDescriptorProperties
    {	WICGifLogicalScreenSignature	= 0x1,
	WICGifLogicalScreenDescriptorWidth	= 0x2,
	WICGifLogicalScreenDescriptorHeight	= 0x3,
	WICGifLogicalScreenDescriptorGlobalColorTableFlag	= 0x4,
	WICGifLogicalScreenDescriptorColorResolution	= 0x5,
	WICGifLogicalScreenDescriptorSortFlag	= 0x6,
	WICGifLogicalScreenDescriptorGlobalColorTableSize	= 0x7,
	WICGifLogicalScreenDescriptorBackgroundColorIndex	= 0x8,
	WICGifLogicalScreenDescriptorPixelAspectRatio	= 0x9,
	WICGifLogicalScreenDescriptorProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICGifLogicalScreenDescriptorProperties;

typedef /* [public] */ 
enum WICGifImageDescriptorProperties
    {	WICGifImageDescriptorLeft	= 0x1,
	WICGifImageDescriptorTop	= 0x2,
	WICGifImageDescriptorWidth	= 0x3,
	WICGifImageDescriptorHeight	= 0x4,
	WICGifImageDescriptorLocalColorTableFlag	= 0x5,
	WICGifImageDescriptorInterlaceFlag	= 0x6,
	WICGifImageDescriptorSortFlag	= 0x7,
	WICGifImageDescriptorLocalColorTableSize	= 0x8,
	WICGifImageDescriptorProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICGifImageDescriptorProperties;

typedef /* [public] */ 
enum WICGifGraphicControlExtensionProperties
    {	WICGifGraphicControlExtensionDisposal	= 0x1,
	WICGifGraphicControlExtensionUserInputFlag	= 0x2,
	WICGifGraphicControlExtensionTransparencyFlag	= 0x3,
	WICGifGraphicControlExtensionDelay	= 0x4,
	WICGifGraphicControlExtensionTransparentColorIndex	= 0x5,
	WICGifGraphicControlExtensionProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICGifGraphicControlExtensionProperties;

typedef /* [public] */ 
enum WICGifApplicationExtensionProperties
    {	WICGifApplicationExtensionApplication	= 0x1,
	WICGifApplicationExtensionData	= 0x2,
	WICGifApplicationExtensionProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICGifApplicationExtensionProperties;

typedef /* [public] */ 
enum WICGifCommentExtensionProperties
    {	WICGifCommentExtensionText	= 0x1,
	WICGifCommentExtensionProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICGifCommentExtensionProperties;

typedef /* [public] */ 
enum WICJpegCommentProperties
    {	WICJpegCommentText	= 0x1,
	WICJpegCommentProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICJpegCommentProperties;

typedef /* [public] */ 
enum WICJpegLuminanceProperties
    {	WICJpegLuminanceTable	= 0x1,
	WICJpegLuminanceProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICJpegLuminanceProperties;

typedef /* [public] */ 
enum WICJpegChrominanceProperties
    {	WICJpegChrominanceTable	= 0x1,
	WICJpegChrominanceProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICJpegChrominanceProperties;

typedef /* [public] */ 
enum WIC8BIMIptcProperties
    {	WIC8BIMIptcPString	= 0,
	WIC8BIMIptcEmbeddedIPTC	= 0x1,
	WIC8BIMIptcProperties_FORCE_DWORD	= 0x7fffffff
    } 	WIC8BIMIptcProperties;

typedef /* [public] */ 
enum WIC8BIMResolutionInfoProperties
    {	WIC8BIMResolutionInfoPString	= 0x1,
	WIC8BIMResolutionInfoHResolution	= 0x2,
	WIC8BIMResolutionInfoHResolutionUnit	= 0x3,
	WIC8BIMResolutionInfoWidthUnit	= 0x4,
	WIC8BIMResolutionInfoVResolution	= 0x5,
	WIC8BIMResolutionInfoVResolutionUnit	= 0x6,
	WIC8BIMResolutionInfoHeightUnit	= 0x7,
	WIC8BIMResolutionInfoProperties_FORCE_DWORD	= 0x7fffffff
    } 	WIC8BIMResolutionInfoProperties;

typedef /* [public] */ 
enum WIC8BIMIptcDigestProperties
    {	WIC8BIMIptcDigestPString	= 0x1,
	WIC8BIMIptcDigestIptcDigest	= 0x2,
	WIC8BIMIptcDigestProperties_FORCE_DWORD	= 0x7fffffff
    } 	WIC8BIMIptcDigestProperties;

typedef /* [public] */ 
enum WICPngGamaProperties
    {	WICPngGamaGamma	= 0x1,
	WICPngGamaProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICPngGamaProperties;

typedef /* [public] */ 
enum WICPngBkgdProperties
    {	WICPngBkgdBackgroundColor	= 0x1,
	WICPngBkgdProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICPngBkgdProperties;

typedef /* [public] */ 
enum WICPngItxtProperties
    {	WICPngItxtKeyword	= 0x1,
	WICPngItxtCompressionFlag	= 0x2,
	WICPngItxtLanguageTag	= 0x3,
	WICPngItxtTranslatedKeyword	= 0x4,
	WICPngItxtText	= 0x5,
	WICPngItxtProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICPngItxtProperties;

typedef /* [public] */ 
enum WICPngChrmProperties
    {	WICPngChrmWhitePointX	= 0x1,
	WICPngChrmWhitePointY	= 0x2,
	WICPngChrmRedX	= 0x3,
	WICPngChrmRedY	= 0x4,
	WICPngChrmGreenX	= 0x5,
	WICPngChrmGreenY	= 0x6,
	WICPngChrmBlueX	= 0x7,
	WICPngChrmBlueY	= 0x8,
	WICPngChrmProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICPngChrmProperties;

typedef /* [public] */ 
enum WICPngHistProperties
    {	WICPngHistFrequencies	= 0x1,
	WICPngHistProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICPngHistProperties;

typedef /* [public] */ 
enum WICPngIccpProperties
    {	WICPngIccpProfileName	= 0x1,
	WICPngIccpProfileData	= 0x2,
	WICPngIccpProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICPngIccpProperties;

typedef /* [public] */ 
enum WICPngSrgbProperties
    {	WICPngSrgbRenderingIntent	= 0x1,
	WICPngSrgbProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICPngSrgbProperties;

typedef /* [public] */ 
enum WICPngTimeProperties
    {	WICPngTimeYear	= 0x1,
	WICPngTimeMonth	= 0x2,
	WICPngTimeDay	= 0x3,
	WICPngTimeHour	= 0x4,
	WICPngTimeMinute	= 0x5,
	WICPngTimeSecond	= 0x6,
	WICPngTimeProperties_FORCE_DWORD	= 0x7fffffff
    } 	WICPngTimeProperties;

typedef /* [public] */ 
enum WICSectionAccessLevel
    {	WICSectionAccessLevelRead	= 0x1,
	WICSectionAccessLevelReadWrite	= 0x3,
	WICSectionAccessLevel_FORCE_DWORD	= 0x7fffffff
    } 	WICSectionAccessLevel;

typedef /* [public] */ 
enum WICPixelFormatNumericRepresentation
    {	WICPixelFormatNumericRepresentationUnspecified	= 0,
	WICPixelFormatNumericRepresentationIndexed	= 0x1,
	WICPixelFormatNumericRepresentationUnsignedInteger	= 0x2,
	WICPixelFormatNumericRepresentationSignedInteger	= 0x3,
	WICPixelFormatNumericRepresentationFixed	= 0x4,
	WICPixelFormatNumericRepresentationFloat	= 0x5,
	WICPixelFormatNumericRepresentation_FORCE_DWORD	= 0x7fffffff
    } 	WICPixelFormatNumericRepresentation;



extern RPC_IF_HANDLE __MIDL_itf_wincodec_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wincodec_0000_0000_v0_0_s_ifspec;

#ifndef __IWICPalette_INTERFACE_DEFINED__
#define __IWICPalette_INTERFACE_DEFINED__

/* interface IWICPalette */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICPalette;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000040-a8f2-4877-ba0a-fd2b6645fb94")
    IWICPalette : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializePredefined( 
            /* [in] */ WICBitmapPaletteType ePaletteType,
            /* [in] */ BOOL fAddTransparentColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeCustom( 
            /* [size_is][in] */ __RPC__in_ecount_full(cCount) WICColor *pColors,
            /* [in] */ UINT cCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromBitmap( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISurface,
            /* [in] */ UINT cCount,
            /* [in] */ BOOL fAddTransparentColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromPalette( 
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ __RPC__out WICBitmapPaletteType *pePaletteType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorCount( 
            /* [out] */ __RPC__out UINT *pcCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColors( 
            /* [in] */ UINT cCount,
            /* [size_is][out] */ __RPC__out_ecount_full(cCount) WICColor *pColors,
            /* [out] */ __RPC__out UINT *pcActualColors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsBlackWhite( 
            /* [out] */ __RPC__out BOOL *pfIsBlackWhite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsGrayscale( 
            /* [out] */ __RPC__out BOOL *pfIsGrayscale) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasAlpha( 
            /* [out] */ __RPC__out BOOL *pfHasAlpha) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICPaletteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICPalette * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICPalette * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICPalette * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializePredefined )( 
            __RPC__in IWICPalette * This,
            /* [in] */ WICBitmapPaletteType ePaletteType,
            /* [in] */ BOOL fAddTransparentColor);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeCustom )( 
            __RPC__in IWICPalette * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cCount) WICColor *pColors,
            /* [in] */ UINT cCount);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromBitmap )( 
            __RPC__in IWICPalette * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISurface,
            /* [in] */ UINT cCount,
            /* [in] */ BOOL fAddTransparentColor);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromPalette )( 
            __RPC__in IWICPalette * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IWICPalette * This,
            /* [out] */ __RPC__out WICBitmapPaletteType *pePaletteType);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorCount )( 
            __RPC__in IWICPalette * This,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetColors )( 
            __RPC__in IWICPalette * This,
            /* [in] */ UINT cCount,
            /* [size_is][out] */ __RPC__out_ecount_full(cCount) WICColor *pColors,
            /* [out] */ __RPC__out UINT *pcActualColors);
        
        HRESULT ( STDMETHODCALLTYPE *IsBlackWhite )( 
            __RPC__in IWICPalette * This,
            /* [out] */ __RPC__out BOOL *pfIsBlackWhite);
        
        HRESULT ( STDMETHODCALLTYPE *IsGrayscale )( 
            __RPC__in IWICPalette * This,
            /* [out] */ __RPC__out BOOL *pfIsGrayscale);
        
        HRESULT ( STDMETHODCALLTYPE *HasAlpha )( 
            __RPC__in IWICPalette * This,
            /* [out] */ __RPC__out BOOL *pfHasAlpha);
        
        END_INTERFACE
    } IWICPaletteVtbl;

    interface IWICPalette
    {
        CONST_VTBL struct IWICPaletteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICPalette_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICPalette_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICPalette_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICPalette_InitializePredefined(This,ePaletteType,fAddTransparentColor)	\
    ( (This)->lpVtbl -> InitializePredefined(This,ePaletteType,fAddTransparentColor) ) 

#define IWICPalette_InitializeCustom(This,pColors,cCount)	\
    ( (This)->lpVtbl -> InitializeCustom(This,pColors,cCount) ) 

#define IWICPalette_InitializeFromBitmap(This,pISurface,cCount,fAddTransparentColor)	\
    ( (This)->lpVtbl -> InitializeFromBitmap(This,pISurface,cCount,fAddTransparentColor) ) 

#define IWICPalette_InitializeFromPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> InitializeFromPalette(This,pIPalette) ) 

#define IWICPalette_GetType(This,pePaletteType)	\
    ( (This)->lpVtbl -> GetType(This,pePaletteType) ) 

#define IWICPalette_GetColorCount(This,pcCount)	\
    ( (This)->lpVtbl -> GetColorCount(This,pcCount) ) 

#define IWICPalette_GetColors(This,cCount,pColors,pcActualColors)	\
    ( (This)->lpVtbl -> GetColors(This,cCount,pColors,pcActualColors) ) 

#define IWICPalette_IsBlackWhite(This,pfIsBlackWhite)	\
    ( (This)->lpVtbl -> IsBlackWhite(This,pfIsBlackWhite) ) 

#define IWICPalette_IsGrayscale(This,pfIsGrayscale)	\
    ( (This)->lpVtbl -> IsGrayscale(This,pfIsGrayscale) ) 

#define IWICPalette_HasAlpha(This,pfHasAlpha)	\
    ( (This)->lpVtbl -> HasAlpha(This,pfHasAlpha) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICPalette_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapSource_INTERFACE_DEFINED__
#define __IWICBitmapSource_INTERFACE_DEFINED__

/* interface IWICBitmapSource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000120-a8f2-4877-ba0a-fd2b6645fb94")
    IWICBitmapSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormat( 
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolution( 
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyPalette( 
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyPixels( 
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapSource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICBitmapSource * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICBitmapSource * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICBitmapSource * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICBitmapSource * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICBitmapSource * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        END_INTERFACE
    } IWICBitmapSourceVtbl;

    interface IWICBitmapSource
    {
        CONST_VTBL struct IWICBitmapSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapSource_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICBitmapSource_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICBitmapSource_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICBitmapSource_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICBitmapSource_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapSource_INTERFACE_DEFINED__ */


#ifndef __IWICFormatConverter_INTERFACE_DEFINED__
#define __IWICFormatConverter_INTERFACE_DEFINED__

/* interface IWICFormatConverter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICFormatConverter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000301-a8f2-4877-ba0a-fd2b6645fb94")
    IWICFormatConverter : public IWICBitmapSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISource,
            /* [in] */ __RPC__in REFWICPixelFormatGUID dstFormat,
            /* [in] */ WICBitmapDitherType dither,
            /* [unique][in] */ __RPC__in_opt IWICPalette *pIPalette,
            /* [in] */ double alphaThresholdPercent,
            /* [in] */ WICBitmapPaletteType paletteTranslate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanConvert( 
            /* [in] */ __RPC__in REFWICPixelFormatGUID srcPixelFormat,
            /* [in] */ __RPC__in REFWICPixelFormatGUID dstPixelFormat,
            /* [out] */ __RPC__out BOOL *pfCanConvert) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICFormatConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICFormatConverter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICFormatConverter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICFormatConverter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICFormatConverter * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICFormatConverter * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICFormatConverter * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICFormatConverter * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICFormatConverter * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IWICFormatConverter * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISource,
            /* [in] */ __RPC__in REFWICPixelFormatGUID dstFormat,
            /* [in] */ WICBitmapDitherType dither,
            /* [unique][in] */ __RPC__in_opt IWICPalette *pIPalette,
            /* [in] */ double alphaThresholdPercent,
            /* [in] */ WICBitmapPaletteType paletteTranslate);
        
        HRESULT ( STDMETHODCALLTYPE *CanConvert )( 
            __RPC__in IWICFormatConverter * This,
            /* [in] */ __RPC__in REFWICPixelFormatGUID srcPixelFormat,
            /* [in] */ __RPC__in REFWICPixelFormatGUID dstPixelFormat,
            /* [out] */ __RPC__out BOOL *pfCanConvert);
        
        END_INTERFACE
    } IWICFormatConverterVtbl;

    interface IWICFormatConverter
    {
        CONST_VTBL struct IWICFormatConverterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICFormatConverter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICFormatConverter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICFormatConverter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICFormatConverter_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICFormatConverter_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICFormatConverter_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICFormatConverter_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICFormatConverter_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 


#define IWICFormatConverter_Initialize(This,pISource,dstFormat,dither,pIPalette,alphaThresholdPercent,paletteTranslate)	\
    ( (This)->lpVtbl -> Initialize(This,pISource,dstFormat,dither,pIPalette,alphaThresholdPercent,paletteTranslate) ) 

#define IWICFormatConverter_CanConvert(This,srcPixelFormat,dstPixelFormat,pfCanConvert)	\
    ( (This)->lpVtbl -> CanConvert(This,srcPixelFormat,dstPixelFormat,pfCanConvert) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICFormatConverter_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapScaler_INTERFACE_DEFINED__
#define __IWICBitmapScaler_INTERFACE_DEFINED__

/* interface IWICBitmapScaler */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapScaler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000302-a8f2-4877-ba0a-fd2b6645fb94")
    IWICBitmapScaler : public IWICBitmapSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISource,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [in] */ WICBitmapInterpolationMode mode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapScalerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapScaler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapScaler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapScaler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICBitmapScaler * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICBitmapScaler * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICBitmapScaler * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICBitmapScaler * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICBitmapScaler * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IWICBitmapScaler * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISource,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [in] */ WICBitmapInterpolationMode mode);
        
        END_INTERFACE
    } IWICBitmapScalerVtbl;

    interface IWICBitmapScaler
    {
        CONST_VTBL struct IWICBitmapScalerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapScaler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapScaler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapScaler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapScaler_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICBitmapScaler_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICBitmapScaler_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICBitmapScaler_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICBitmapScaler_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 


#define IWICBitmapScaler_Initialize(This,pISource,uiWidth,uiHeight,mode)	\
    ( (This)->lpVtbl -> Initialize(This,pISource,uiWidth,uiHeight,mode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapScaler_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapClipper_INTERFACE_DEFINED__
#define __IWICBitmapClipper_INTERFACE_DEFINED__

/* interface IWICBitmapClipper */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapClipper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4FBCF03-223D-4e81-9333-D635556DD1B5")
    IWICBitmapClipper : public IWICBitmapSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISource,
            /* [in] */ __RPC__in const WICRect *prc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapClipperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapClipper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapClipper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapClipper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICBitmapClipper * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICBitmapClipper * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICBitmapClipper * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICBitmapClipper * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICBitmapClipper * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IWICBitmapClipper * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISource,
            /* [in] */ __RPC__in const WICRect *prc);
        
        END_INTERFACE
    } IWICBitmapClipperVtbl;

    interface IWICBitmapClipper
    {
        CONST_VTBL struct IWICBitmapClipperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapClipper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapClipper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapClipper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapClipper_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICBitmapClipper_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICBitmapClipper_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICBitmapClipper_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICBitmapClipper_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 


#define IWICBitmapClipper_Initialize(This,pISource,prc)	\
    ( (This)->lpVtbl -> Initialize(This,pISource,prc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapClipper_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapFlipRotator_INTERFACE_DEFINED__
#define __IWICBitmapFlipRotator_INTERFACE_DEFINED__

/* interface IWICBitmapFlipRotator */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapFlipRotator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5009834F-2D6A-41ce-9E1B-17C5AFF7A782")
    IWICBitmapFlipRotator : public IWICBitmapSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISource,
            /* [in] */ WICBitmapTransformOptions options) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapFlipRotatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapFlipRotator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapFlipRotator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapFlipRotator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICBitmapFlipRotator * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICBitmapFlipRotator * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICBitmapFlipRotator * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICBitmapFlipRotator * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICBitmapFlipRotator * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IWICBitmapFlipRotator * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pISource,
            /* [in] */ WICBitmapTransformOptions options);
        
        END_INTERFACE
    } IWICBitmapFlipRotatorVtbl;

    interface IWICBitmapFlipRotator
    {
        CONST_VTBL struct IWICBitmapFlipRotatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapFlipRotator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapFlipRotator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapFlipRotator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapFlipRotator_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICBitmapFlipRotator_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICBitmapFlipRotator_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICBitmapFlipRotator_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICBitmapFlipRotator_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 


#define IWICBitmapFlipRotator_Initialize(This,pISource,options)	\
    ( (This)->lpVtbl -> Initialize(This,pISource,options) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapFlipRotator_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapLock_INTERFACE_DEFINED__
#define __IWICBitmapLock_INTERFACE_DEFINED__

/* interface IWICBitmapLock */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000123-a8f2-4877-ba0a-fd2b6645fb94")
    IWICBitmapLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStride( 
            /* [out] */ __RPC__out UINT *pcbStride) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataPointer( 
            /* [out] */ __RPC__out UINT *pcbBufferSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbBufferSize) WICInProcPointer *ppbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormat( 
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapLock * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICBitmapLock * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetStride )( 
            __RPC__in IWICBitmapLock * This,
            /* [out] */ __RPC__out UINT *pcbStride);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataPointer )( 
            __RPC__in IWICBitmapLock * This,
            /* [out] */ __RPC__out UINT *pcbBufferSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbBufferSize) WICInProcPointer *ppbData);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICBitmapLock * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        END_INTERFACE
    } IWICBitmapLockVtbl;

    interface IWICBitmapLock
    {
        CONST_VTBL struct IWICBitmapLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapLock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapLock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapLock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapLock_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICBitmapLock_GetStride(This,pcbStride)	\
    ( (This)->lpVtbl -> GetStride(This,pcbStride) ) 

#define IWICBitmapLock_GetDataPointer(This,pcbBufferSize,ppbData)	\
    ( (This)->lpVtbl -> GetDataPointer(This,pcbBufferSize,ppbData) ) 

#define IWICBitmapLock_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapLock_INTERFACE_DEFINED__ */


#ifndef __IWICBitmap_INTERFACE_DEFINED__
#define __IWICBitmap_INTERFACE_DEFINED__

/* interface IWICBitmap */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000121-a8f2-4877-ba0a-fd2b6645fb94")
    IWICBitmap : public IWICBitmapSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [unique][in] */ __RPC__in_opt const WICRect *prcLock,
            /* [in] */ DWORD flags,
            /* [out] */ __RPC__deref_out_opt IWICBitmapLock **ppILock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPalette( 
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResolution( 
            /* [in] */ double dpiX,
            /* [in] */ double dpiY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmap * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICBitmap * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICBitmap * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICBitmap * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICBitmap * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICBitmap * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            __RPC__in IWICBitmap * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prcLock,
            /* [in] */ DWORD flags,
            /* [out] */ __RPC__deref_out_opt IWICBitmapLock **ppILock);
        
        HRESULT ( STDMETHODCALLTYPE *SetPalette )( 
            __RPC__in IWICBitmap * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *SetResolution )( 
            __RPC__in IWICBitmap * This,
            /* [in] */ double dpiX,
            /* [in] */ double dpiY);
        
        END_INTERFACE
    } IWICBitmapVtbl;

    interface IWICBitmap
    {
        CONST_VTBL struct IWICBitmapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmap_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICBitmap_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICBitmap_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICBitmap_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICBitmap_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 


#define IWICBitmap_Lock(This,prcLock,flags,ppILock)	\
    ( (This)->lpVtbl -> Lock(This,prcLock,flags,ppILock) ) 

#define IWICBitmap_SetPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> SetPalette(This,pIPalette) ) 

#define IWICBitmap_SetResolution(This,dpiX,dpiY)	\
    ( (This)->lpVtbl -> SetResolution(This,dpiX,dpiY) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmap_INTERFACE_DEFINED__ */


#ifndef __IWICColorContext_INTERFACE_DEFINED__
#define __IWICColorContext_INTERFACE_DEFINED__

/* interface IWICColorContext */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICColorContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C613A02-34B2-44ea-9A7C-45AEA9C6FD6D")
    IWICColorContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromFilename( 
            /* [in] */ __RPC__in LPCWSTR wzFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromMemory( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) const BYTE *pbBuffer,
            /* [in] */ UINT cbBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromExifColorSpace( 
            /* [in] */ UINT value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ __RPC__out WICColorContextType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProfileBytes( 
            /* [in] */ UINT cbBuffer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cbBuffer) BYTE *pbBuffer,
            /* [out] */ __RPC__out UINT *pcbActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExifColorSpace( 
            /* [out] */ __RPC__out UINT *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICColorContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICColorContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICColorContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICColorContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromFilename )( 
            __RPC__in IWICColorContext * This,
            /* [in] */ __RPC__in LPCWSTR wzFilename);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromMemory )( 
            __RPC__in IWICColorContext * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) const BYTE *pbBuffer,
            /* [in] */ UINT cbBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromExifColorSpace )( 
            __RPC__in IWICColorContext * This,
            /* [in] */ UINT value);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            __RPC__in IWICColorContext * This,
            /* [out] */ __RPC__out WICColorContextType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetProfileBytes )( 
            __RPC__in IWICColorContext * This,
            /* [in] */ UINT cbBuffer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cbBuffer) BYTE *pbBuffer,
            /* [out] */ __RPC__out UINT *pcbActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetExifColorSpace )( 
            __RPC__in IWICColorContext * This,
            /* [out] */ __RPC__out UINT *pValue);
        
        END_INTERFACE
    } IWICColorContextVtbl;

    interface IWICColorContext
    {
        CONST_VTBL struct IWICColorContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICColorContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICColorContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICColorContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICColorContext_InitializeFromFilename(This,wzFilename)	\
    ( (This)->lpVtbl -> InitializeFromFilename(This,wzFilename) ) 

#define IWICColorContext_InitializeFromMemory(This,pbBuffer,cbBufferSize)	\
    ( (This)->lpVtbl -> InitializeFromMemory(This,pbBuffer,cbBufferSize) ) 

#define IWICColorContext_InitializeFromExifColorSpace(This,value)	\
    ( (This)->lpVtbl -> InitializeFromExifColorSpace(This,value) ) 

#define IWICColorContext_GetType(This,pType)	\
    ( (This)->lpVtbl -> GetType(This,pType) ) 

#define IWICColorContext_GetProfileBytes(This,cbBuffer,pbBuffer,pcbActual)	\
    ( (This)->lpVtbl -> GetProfileBytes(This,cbBuffer,pbBuffer,pcbActual) ) 

#define IWICColorContext_GetExifColorSpace(This,pValue)	\
    ( (This)->lpVtbl -> GetExifColorSpace(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICColorContext_INTERFACE_DEFINED__ */


#ifndef __IWICColorTransform_INTERFACE_DEFINED__
#define __IWICColorTransform_INTERFACE_DEFINED__

/* interface IWICColorTransform */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICColorTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B66F034F-D0E2-40ab-B436-6DE39E321A94")
    IWICColorTransform : public IWICBitmapSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [in] */ __RPC__in_opt IWICColorContext *pIContextSource,
            /* [in] */ __RPC__in_opt IWICColorContext *pIContextDest,
            /* [in] */ __RPC__in REFWICPixelFormatGUID pixelFmtDest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICColorTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICColorTransform * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICColorTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICColorTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICColorTransform * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICColorTransform * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICColorTransform * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICColorTransform * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICColorTransform * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IWICColorTransform * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [in] */ __RPC__in_opt IWICColorContext *pIContextSource,
            /* [in] */ __RPC__in_opt IWICColorContext *pIContextDest,
            /* [in] */ __RPC__in REFWICPixelFormatGUID pixelFmtDest);
        
        END_INTERFACE
    } IWICColorTransformVtbl;

    interface IWICColorTransform
    {
        CONST_VTBL struct IWICColorTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICColorTransform_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICColorTransform_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICColorTransform_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICColorTransform_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICColorTransform_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICColorTransform_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICColorTransform_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICColorTransform_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 


#define IWICColorTransform_Initialize(This,pIBitmapSource,pIContextSource,pIContextDest,pixelFmtDest)	\
    ( (This)->lpVtbl -> Initialize(This,pIBitmapSource,pIContextSource,pIContextDest,pixelFmtDest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICColorTransform_INTERFACE_DEFINED__ */


#ifndef __IWICFastMetadataEncoder_INTERFACE_DEFINED__
#define __IWICFastMetadataEncoder_INTERFACE_DEFINED__

/* interface IWICFastMetadataEncoder */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICFastMetadataEncoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B84E2C09-78C9-4AC4-8BD3-524AE1663A2F")
    IWICFastMetadataEncoder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetadataQueryWriter( 
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIMetadataQueryWriter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICFastMetadataEncoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICFastMetadataEncoder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICFastMetadataEncoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICFastMetadataEncoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWICFastMetadataEncoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataQueryWriter )( 
            __RPC__in IWICFastMetadataEncoder * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIMetadataQueryWriter);
        
        END_INTERFACE
    } IWICFastMetadataEncoderVtbl;

    interface IWICFastMetadataEncoder
    {
        CONST_VTBL struct IWICFastMetadataEncoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICFastMetadataEncoder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICFastMetadataEncoder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICFastMetadataEncoder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICFastMetadataEncoder_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IWICFastMetadataEncoder_GetMetadataQueryWriter(This,ppIMetadataQueryWriter)	\
    ( (This)->lpVtbl -> GetMetadataQueryWriter(This,ppIMetadataQueryWriter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICFastMetadataEncoder_INTERFACE_DEFINED__ */


#ifndef __IWICStream_INTERFACE_DEFINED__
#define __IWICStream_INTERFACE_DEFINED__

/* interface IWICStream */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("135FF860-22B7-4ddf-B0F6-218F4F299A43")
    IWICStream : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeFromIStream( 
            /* [in] */ __RPC__in_opt IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromFilename( 
            /* [in] */ __RPC__in LPCWSTR wzFileName,
            /* [in] */ DWORD dwDesiredAccess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromMemory( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) WICInProcPointer pbBuffer,
            /* [in] */ DWORD cbBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeFromIStreamRegion( 
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [in] */ ULARGE_INTEGER ulMaxSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICStream * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IWICStream * This,
            /* [annotation] */ 
            __out_bcount_part(cb, *pcbRead)  void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IWICStream * This,
            /* [annotation] */ 
            __in_bcount(cb)  const void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IWICStream * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            __RPC__in IWICStream * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IWICStream * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbRead,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWICStream * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            __RPC__in IWICStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            __RPC__in IWICStream * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            __RPC__in IWICStream * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            __RPC__in IWICStream * This,
            /* [out] */ __RPC__out STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IWICStream * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromIStream )( 
            __RPC__in IWICStream * This,
            /* [in] */ __RPC__in_opt IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromFilename )( 
            __RPC__in IWICStream * This,
            /* [in] */ __RPC__in LPCWSTR wzFileName,
            /* [in] */ DWORD dwDesiredAccess);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromMemory )( 
            __RPC__in IWICStream * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) WICInProcPointer pbBuffer,
            /* [in] */ DWORD cbBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeFromIStreamRegion )( 
            __RPC__in IWICStream * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [in] */ ULARGE_INTEGER ulOffset,
            /* [in] */ ULARGE_INTEGER ulMaxSize);
        
        END_INTERFACE
    } IWICStreamVtbl;

    interface IWICStream
    {
        CONST_VTBL struct IWICStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICStream_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IWICStream_Write(This,pv,cb,pcbWritten)	\
    ( (This)->lpVtbl -> Write(This,pv,cb,pcbWritten) ) 


#define IWICStream_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IWICStream_SetSize(This,libNewSize)	\
    ( (This)->lpVtbl -> SetSize(This,libNewSize) ) 

#define IWICStream_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    ( (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten) ) 

#define IWICStream_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IWICStream_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IWICStream_LockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType) ) 

#define IWICStream_UnlockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType) ) 

#define IWICStream_Stat(This,pstatstg,grfStatFlag)	\
    ( (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag) ) 

#define IWICStream_Clone(This,ppstm)	\
    ( (This)->lpVtbl -> Clone(This,ppstm) ) 


#define IWICStream_InitializeFromIStream(This,pIStream)	\
    ( (This)->lpVtbl -> InitializeFromIStream(This,pIStream) ) 

#define IWICStream_InitializeFromFilename(This,wzFileName,dwDesiredAccess)	\
    ( (This)->lpVtbl -> InitializeFromFilename(This,wzFileName,dwDesiredAccess) ) 

#define IWICStream_InitializeFromMemory(This,pbBuffer,cbBufferSize)	\
    ( (This)->lpVtbl -> InitializeFromMemory(This,pbBuffer,cbBufferSize) ) 

#define IWICStream_InitializeFromIStreamRegion(This,pIStream,ulOffset,ulMaxSize)	\
    ( (This)->lpVtbl -> InitializeFromIStreamRegion(This,pIStream,ulOffset,ulMaxSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICStream_INTERFACE_DEFINED__ */


#ifndef __IWICEnumMetadataItem_INTERFACE_DEFINED__
#define __IWICEnumMetadataItem_INTERFACE_DEFINED__

/* interface IWICEnumMetadataItem */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICEnumMetadataItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DC2BB46D-3F07-481E-8625-220C4AEDBB33")
    IWICEnumMetadataItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(celt) PROPVARIANT *rgeltSchema,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(celt) PROPVARIANT *rgeltId,
            /* [size_is][optional][out][in] */ __RPC__inout_ecount_full(celt) PROPVARIANT *rgeltValue,
            /* [optional][out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IWICEnumMetadataItem **ppIEnumMetadataItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICEnumMetadataItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICEnumMetadataItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICEnumMetadataItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICEnumMetadataItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IWICEnumMetadataItem * This,
            /* [in] */ ULONG celt,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(celt) PROPVARIANT *rgeltSchema,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(celt) PROPVARIANT *rgeltId,
            /* [size_is][optional][out][in] */ __RPC__inout_ecount_full(celt) PROPVARIANT *rgeltValue,
            /* [optional][out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IWICEnumMetadataItem * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IWICEnumMetadataItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IWICEnumMetadataItem * This,
            /* [out] */ __RPC__deref_out_opt IWICEnumMetadataItem **ppIEnumMetadataItem);
        
        END_INTERFACE
    } IWICEnumMetadataItemVtbl;

    interface IWICEnumMetadataItem
    {
        CONST_VTBL struct IWICEnumMetadataItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICEnumMetadataItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICEnumMetadataItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICEnumMetadataItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICEnumMetadataItem_Next(This,celt,rgeltSchema,rgeltId,rgeltValue,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgeltSchema,rgeltId,rgeltValue,pceltFetched) ) 

#define IWICEnumMetadataItem_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IWICEnumMetadataItem_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IWICEnumMetadataItem_Clone(This,ppIEnumMetadataItem)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnumMetadataItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICEnumMetadataItem_INTERFACE_DEFINED__ */


#ifndef __IWICMetadataQueryReader_INTERFACE_DEFINED__
#define __IWICMetadataQueryReader_INTERFACE_DEFINED__

/* interface IWICMetadataQueryReader */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataQueryReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30989668-E1C9-4597-B395-458EEDB808DF")
    IWICMetadataQueryReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContainerFormat( 
            /* [out] */ __RPC__out GUID *pguidContainerFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocation( 
            /* [in] */ UINT cchMaxLength,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchMaxLength) WCHAR *wzNamespace,
            /* [out] */ __RPC__out UINT *pcchActualLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetadataByName( 
            /* [in] */ __RPC__in LPCWSTR wzName,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumerator( 
            /* [out] */ __RPC__deref_out_opt IEnumString **ppIEnumString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataQueryReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataQueryReader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataQueryReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataQueryReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICMetadataQueryReader * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocation )( 
            __RPC__in IWICMetadataQueryReader * This,
            /* [in] */ UINT cchMaxLength,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchMaxLength) WCHAR *wzNamespace,
            /* [out] */ __RPC__out UINT *pcchActualLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataByName )( 
            __RPC__in IWICMetadataQueryReader * This,
            /* [in] */ __RPC__in LPCWSTR wzName,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumerator )( 
            __RPC__in IWICMetadataQueryReader * This,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppIEnumString);
        
        END_INTERFACE
    } IWICMetadataQueryReaderVtbl;

    interface IWICMetadataQueryReader
    {
        CONST_VTBL struct IWICMetadataQueryReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataQueryReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataQueryReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataQueryReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataQueryReader_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICMetadataQueryReader_GetLocation(This,cchMaxLength,wzNamespace,pcchActualLength)	\
    ( (This)->lpVtbl -> GetLocation(This,cchMaxLength,wzNamespace,pcchActualLength) ) 

#define IWICMetadataQueryReader_GetMetadataByName(This,wzName,pvarValue)	\
    ( (This)->lpVtbl -> GetMetadataByName(This,wzName,pvarValue) ) 

#define IWICMetadataQueryReader_GetEnumerator(This,ppIEnumString)	\
    ( (This)->lpVtbl -> GetEnumerator(This,ppIEnumString) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICMetadataQueryReader_INTERFACE_DEFINED__ */


#ifndef __IWICMetadataQueryWriter_INTERFACE_DEFINED__
#define __IWICMetadataQueryWriter_INTERFACE_DEFINED__

/* interface IWICMetadataQueryWriter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICMetadataQueryWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A721791A-0DEF-4d06-BD91-2118BF1DB10B")
    IWICMetadataQueryWriter : public IWICMetadataQueryReader
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMetadataByName( 
            /* [in] */ __RPC__in LPCWSTR wzName,
            /* [in] */ __RPC__in const PROPVARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMetadataByName( 
            /* [in] */ __RPC__in LPCWSTR wzName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICMetadataQueryWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICMetadataQueryWriter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICMetadataQueryWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICMetadataQueryWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICMetadataQueryWriter * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocation )( 
            __RPC__in IWICMetadataQueryWriter * This,
            /* [in] */ UINT cchMaxLength,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchMaxLength) WCHAR *wzNamespace,
            /* [out] */ __RPC__out UINT *pcchActualLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataByName )( 
            __RPC__in IWICMetadataQueryWriter * This,
            /* [in] */ __RPC__in LPCWSTR wzName,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumerator )( 
            __RPC__in IWICMetadataQueryWriter * This,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppIEnumString);
        
        HRESULT ( STDMETHODCALLTYPE *SetMetadataByName )( 
            __RPC__in IWICMetadataQueryWriter * This,
            /* [in] */ __RPC__in LPCWSTR wzName,
            /* [in] */ __RPC__in const PROPVARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMetadataByName )( 
            __RPC__in IWICMetadataQueryWriter * This,
            /* [in] */ __RPC__in LPCWSTR wzName);
        
        END_INTERFACE
    } IWICMetadataQueryWriterVtbl;

    interface IWICMetadataQueryWriter
    {
        CONST_VTBL struct IWICMetadataQueryWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICMetadataQueryWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICMetadataQueryWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICMetadataQueryWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICMetadataQueryWriter_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICMetadataQueryWriter_GetLocation(This,cchMaxLength,wzNamespace,pcchActualLength)	\
    ( (This)->lpVtbl -> GetLocation(This,cchMaxLength,wzNamespace,pcchActualLength) ) 

#define IWICMetadataQueryWriter_GetMetadataByName(This,wzName,pvarValue)	\
    ( (This)->lpVtbl -> GetMetadataByName(This,wzName,pvarValue) ) 

#define IWICMetadataQueryWriter_GetEnumerator(This,ppIEnumString)	\
    ( (This)->lpVtbl -> GetEnumerator(This,ppIEnumString) ) 


#define IWICMetadataQueryWriter_SetMetadataByName(This,wzName,pvarValue)	\
    ( (This)->lpVtbl -> SetMetadataByName(This,wzName,pvarValue) ) 

#define IWICMetadataQueryWriter_RemoveMetadataByName(This,wzName)	\
    ( (This)->lpVtbl -> RemoveMetadataByName(This,wzName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICMetadataQueryWriter_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapEncoder_INTERFACE_DEFINED__
#define __IWICBitmapEncoder_INTERFACE_DEFINED__

/* interface IWICBitmapEncoder */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapEncoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000103-a8f2-4877-ba0a-fd2b6645fb94")
    IWICBitmapEncoder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [in] */ WICBitmapEncoderCacheOption cacheOption) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerFormat( 
            /* [out] */ __RPC__out GUID *pguidContainerFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEncoderInfo( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapEncoderInfo **ppIEncoderInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorContexts( 
            /* [in] */ UINT cCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cCount) IWICColorContext **ppIColorContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPalette( 
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnail( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIThumbnail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreview( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIPreview) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewFrame( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapFrameEncode **ppIFrameEncode,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IPropertyBag2 **ppIEncoderOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetadataQueryWriter( 
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIMetadataQueryWriter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapEncoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapEncoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapEncoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [in] */ WICBitmapEncoderCacheOption cacheOption);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetEncoderInfo )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapEncoderInfo **ppIEncoderInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorContexts )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [in] */ UINT cCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cCount) IWICColorContext **ppIColorContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetPalette )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnail )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreview )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIPreview);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewFrame )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapFrameEncode **ppIFrameEncode,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IPropertyBag2 **ppIEncoderOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWICBitmapEncoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataQueryWriter )( 
            __RPC__in IWICBitmapEncoder * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIMetadataQueryWriter);
        
        END_INTERFACE
    } IWICBitmapEncoderVtbl;

    interface IWICBitmapEncoder
    {
        CONST_VTBL struct IWICBitmapEncoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapEncoder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapEncoder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapEncoder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapEncoder_Initialize(This,pIStream,cacheOption)	\
    ( (This)->lpVtbl -> Initialize(This,pIStream,cacheOption) ) 

#define IWICBitmapEncoder_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICBitmapEncoder_GetEncoderInfo(This,ppIEncoderInfo)	\
    ( (This)->lpVtbl -> GetEncoderInfo(This,ppIEncoderInfo) ) 

#define IWICBitmapEncoder_SetColorContexts(This,cCount,ppIColorContext)	\
    ( (This)->lpVtbl -> SetColorContexts(This,cCount,ppIColorContext) ) 

#define IWICBitmapEncoder_SetPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> SetPalette(This,pIPalette) ) 

#define IWICBitmapEncoder_SetThumbnail(This,pIThumbnail)	\
    ( (This)->lpVtbl -> SetThumbnail(This,pIThumbnail) ) 

#define IWICBitmapEncoder_SetPreview(This,pIPreview)	\
    ( (This)->lpVtbl -> SetPreview(This,pIPreview) ) 

#define IWICBitmapEncoder_CreateNewFrame(This,ppIFrameEncode,ppIEncoderOptions)	\
    ( (This)->lpVtbl -> CreateNewFrame(This,ppIFrameEncode,ppIEncoderOptions) ) 

#define IWICBitmapEncoder_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IWICBitmapEncoder_GetMetadataQueryWriter(This,ppIMetadataQueryWriter)	\
    ( (This)->lpVtbl -> GetMetadataQueryWriter(This,ppIMetadataQueryWriter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapEncoder_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapFrameEncode_INTERFACE_DEFINED__
#define __IWICBitmapFrameEncode_INTERFACE_DEFINED__

/* interface IWICBitmapFrameEncode */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapFrameEncode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000105-a8f2-4877-ba0a-fd2b6645fb94")
    IWICBitmapFrameEncode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ __RPC__in_opt IPropertyBag2 *pIEncoderOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSize( 
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResolution( 
            /* [in] */ double dpiX,
            /* [in] */ double dpiY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPixelFormat( 
            /* [out][in] */ __RPC__inout WICPixelFormatGUID *pPixelFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorContexts( 
            /* [in] */ UINT cCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cCount) IWICColorContext **ppIColorContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPalette( 
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThumbnail( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIThumbnail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePixels( 
            /* [in] */ UINT lineCount,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) BYTE *pbPixels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSource( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [unique][in] */ __RPC__in_opt WICRect *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetadataQueryWriter( 
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIMetadataQueryWriter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapFrameEncodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapFrameEncode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapFrameEncode * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [unique][in] */ __RPC__in_opt IPropertyBag2 *pIEncoderOptions);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetResolution )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [in] */ double dpiX,
            /* [in] */ double dpiY);
        
        HRESULT ( STDMETHODCALLTYPE *SetPixelFormat )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [out][in] */ __RPC__inout WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorContexts )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [in] */ UINT cCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cCount) IWICColorContext **ppIColorContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetPalette )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *SetThumbnail )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *WritePixels )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [in] */ UINT lineCount,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) BYTE *pbPixels);
        
        HRESULT ( STDMETHODCALLTYPE *WriteSource )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [unique][in] */ __RPC__in_opt WICRect *prc);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IWICBitmapFrameEncode * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataQueryWriter )( 
            __RPC__in IWICBitmapFrameEncode * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIMetadataQueryWriter);
        
        END_INTERFACE
    } IWICBitmapFrameEncodeVtbl;

    interface IWICBitmapFrameEncode
    {
        CONST_VTBL struct IWICBitmapFrameEncodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapFrameEncode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapFrameEncode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapFrameEncode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapFrameEncode_Initialize(This,pIEncoderOptions)	\
    ( (This)->lpVtbl -> Initialize(This,pIEncoderOptions) ) 

#define IWICBitmapFrameEncode_SetSize(This,uiWidth,uiHeight)	\
    ( (This)->lpVtbl -> SetSize(This,uiWidth,uiHeight) ) 

#define IWICBitmapFrameEncode_SetResolution(This,dpiX,dpiY)	\
    ( (This)->lpVtbl -> SetResolution(This,dpiX,dpiY) ) 

#define IWICBitmapFrameEncode_SetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> SetPixelFormat(This,pPixelFormat) ) 

#define IWICBitmapFrameEncode_SetColorContexts(This,cCount,ppIColorContext)	\
    ( (This)->lpVtbl -> SetColorContexts(This,cCount,ppIColorContext) ) 

#define IWICBitmapFrameEncode_SetPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> SetPalette(This,pIPalette) ) 

#define IWICBitmapFrameEncode_SetThumbnail(This,pIThumbnail)	\
    ( (This)->lpVtbl -> SetThumbnail(This,pIThumbnail) ) 

#define IWICBitmapFrameEncode_WritePixels(This,lineCount,cbStride,cbBufferSize,pbPixels)	\
    ( (This)->lpVtbl -> WritePixels(This,lineCount,cbStride,cbBufferSize,pbPixels) ) 

#define IWICBitmapFrameEncode_WriteSource(This,pIBitmapSource,prc)	\
    ( (This)->lpVtbl -> WriteSource(This,pIBitmapSource,prc) ) 

#define IWICBitmapFrameEncode_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 

#define IWICBitmapFrameEncode_GetMetadataQueryWriter(This,ppIMetadataQueryWriter)	\
    ( (This)->lpVtbl -> GetMetadataQueryWriter(This,ppIMetadataQueryWriter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapFrameEncode_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapDecoder_INTERFACE_DEFINED__
#define __IWICBitmapDecoder_INTERFACE_DEFINED__

/* interface IWICBitmapDecoder */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapDecoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EDDE9E7-8DEE-47ea-99DF-E6FAF2ED44BF")
    IWICBitmapDecoder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryCapability( 
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__out DWORD *pdwCapability) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [in] */ WICDecodeOptions cacheOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerFormat( 
            /* [out] */ __RPC__out GUID *pguidContainerFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDecoderInfo( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapDecoderInfo **ppIDecoderInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyPalette( 
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetadataQueryReader( 
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryReader **ppIMetadataQueryReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreview( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapSource **ppIBitmapSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorContexts( 
            /* [in] */ UINT cCount,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cCount) IWICColorContext **ppIColorContexts,
            /* [out] */ __RPC__out UINT *pcActualCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThumbnail( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapSource **ppIThumbnail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameCount( 
            /* [out] */ __RPC__out UINT *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrame( 
            /* [in] */ UINT index,
            /* [out] */ __RPC__deref_out_opt IWICBitmapFrameDecode **ppIBitmapFrame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapDecoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapDecoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapDecoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCapability )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__out DWORD *pdwCapability);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [in] */ WICDecodeOptions cacheOptions);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderInfo )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapDecoderInfo **ppIDecoderInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataQueryReader )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryReader **ppIMetadataQueryReader);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreview )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapSource **ppIBitmapSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorContexts )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [in] */ UINT cCount,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cCount) IWICColorContext **ppIColorContexts,
            /* [out] */ __RPC__out UINT *pcActualCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnail )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapSource **ppIThumbnail);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameCount )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [out] */ __RPC__out UINT *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrame )( 
            __RPC__in IWICBitmapDecoder * This,
            /* [in] */ UINT index,
            /* [out] */ __RPC__deref_out_opt IWICBitmapFrameDecode **ppIBitmapFrame);
        
        END_INTERFACE
    } IWICBitmapDecoderVtbl;

    interface IWICBitmapDecoder
    {
        CONST_VTBL struct IWICBitmapDecoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapDecoder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapDecoder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapDecoder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapDecoder_QueryCapability(This,pIStream,pdwCapability)	\
    ( (This)->lpVtbl -> QueryCapability(This,pIStream,pdwCapability) ) 

#define IWICBitmapDecoder_Initialize(This,pIStream,cacheOptions)	\
    ( (This)->lpVtbl -> Initialize(This,pIStream,cacheOptions) ) 

#define IWICBitmapDecoder_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICBitmapDecoder_GetDecoderInfo(This,ppIDecoderInfo)	\
    ( (This)->lpVtbl -> GetDecoderInfo(This,ppIDecoderInfo) ) 

#define IWICBitmapDecoder_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICBitmapDecoder_GetMetadataQueryReader(This,ppIMetadataQueryReader)	\
    ( (This)->lpVtbl -> GetMetadataQueryReader(This,ppIMetadataQueryReader) ) 

#define IWICBitmapDecoder_GetPreview(This,ppIBitmapSource)	\
    ( (This)->lpVtbl -> GetPreview(This,ppIBitmapSource) ) 

#define IWICBitmapDecoder_GetColorContexts(This,cCount,ppIColorContexts,pcActualCount)	\
    ( (This)->lpVtbl -> GetColorContexts(This,cCount,ppIColorContexts,pcActualCount) ) 

#define IWICBitmapDecoder_GetThumbnail(This,ppIThumbnail)	\
    ( (This)->lpVtbl -> GetThumbnail(This,ppIThumbnail) ) 

#define IWICBitmapDecoder_GetFrameCount(This,pCount)	\
    ( (This)->lpVtbl -> GetFrameCount(This,pCount) ) 

#define IWICBitmapDecoder_GetFrame(This,index,ppIBitmapFrame)	\
    ( (This)->lpVtbl -> GetFrame(This,index,ppIBitmapFrame) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapDecoder_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapSourceTransform_INTERFACE_DEFINED__
#define __IWICBitmapSourceTransform_INTERFACE_DEFINED__

/* interface IWICBitmapSourceTransform */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapSourceTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B16811B-6A43-4ec9-B713-3D5A0C13B940")
    IWICBitmapSourceTransform : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CopyPixels( 
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [unique][in] */ __RPC__in_opt WICPixelFormatGUID *pguidDstFormat,
            /* [in] */ WICBitmapTransformOptions dstTransform,
            /* [in] */ UINT nStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClosestSize( 
            /* [out][in] */ __RPC__inout UINT *puiWidth,
            /* [out][in] */ __RPC__inout UINT *puiHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClosestPixelFormat( 
            /* [out][in] */ __RPC__inout WICPixelFormatGUID *pguidDstFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesSupportTransform( 
            /* [in] */ WICBitmapTransformOptions dstTransform,
            /* [out] */ __RPC__out BOOL *pfIsSupported) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapSourceTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapSourceTransform * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapSourceTransform * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapSourceTransform * This);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICBitmapSourceTransform * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [unique][in] */ __RPC__in_opt WICPixelFormatGUID *pguidDstFormat,
            /* [in] */ WICBitmapTransformOptions dstTransform,
            /* [in] */ UINT nStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetClosestSize )( 
            __RPC__in IWICBitmapSourceTransform * This,
            /* [out][in] */ __RPC__inout UINT *puiWidth,
            /* [out][in] */ __RPC__inout UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetClosestPixelFormat )( 
            __RPC__in IWICBitmapSourceTransform * This,
            /* [out][in] */ __RPC__inout WICPixelFormatGUID *pguidDstFormat);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportTransform )( 
            __RPC__in IWICBitmapSourceTransform * This,
            /* [in] */ WICBitmapTransformOptions dstTransform,
            /* [out] */ __RPC__out BOOL *pfIsSupported);
        
        END_INTERFACE
    } IWICBitmapSourceTransformVtbl;

    interface IWICBitmapSourceTransform
    {
        CONST_VTBL struct IWICBitmapSourceTransformVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapSourceTransform_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapSourceTransform_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapSourceTransform_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapSourceTransform_CopyPixels(This,prc,uiWidth,uiHeight,pguidDstFormat,dstTransform,nStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,uiWidth,uiHeight,pguidDstFormat,dstTransform,nStride,cbBufferSize,pbBuffer) ) 

#define IWICBitmapSourceTransform_GetClosestSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetClosestSize(This,puiWidth,puiHeight) ) 

#define IWICBitmapSourceTransform_GetClosestPixelFormat(This,pguidDstFormat)	\
    ( (This)->lpVtbl -> GetClosestPixelFormat(This,pguidDstFormat) ) 

#define IWICBitmapSourceTransform_DoesSupportTransform(This,dstTransform,pfIsSupported)	\
    ( (This)->lpVtbl -> DoesSupportTransform(This,dstTransform,pfIsSupported) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapSourceTransform_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapFrameDecode_INTERFACE_DEFINED__
#define __IWICBitmapFrameDecode_INTERFACE_DEFINED__

/* interface IWICBitmapFrameDecode */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapFrameDecode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B16811B-6A43-4ec9-A813-3D930C13B940")
    IWICBitmapFrameDecode : public IWICBitmapSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMetadataQueryReader( 
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryReader **ppIMetadataQueryReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorContexts( 
            /* [in] */ UINT cCount,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cCount) IWICColorContext **ppIColorContexts,
            /* [out] */ __RPC__out UINT *pcActualCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThumbnail( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapSource **ppIThumbnail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapFrameDecodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapFrameDecode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapFrameDecode * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataQueryReader )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryReader **ppIMetadataQueryReader);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorContexts )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [in] */ UINT cCount,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cCount) IWICColorContext **ppIColorContexts,
            /* [out] */ __RPC__out UINT *pcActualCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnail )( 
            __RPC__in IWICBitmapFrameDecode * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapSource **ppIThumbnail);
        
        END_INTERFACE
    } IWICBitmapFrameDecodeVtbl;

    interface IWICBitmapFrameDecode
    {
        CONST_VTBL struct IWICBitmapFrameDecodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapFrameDecode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapFrameDecode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapFrameDecode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapFrameDecode_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICBitmapFrameDecode_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICBitmapFrameDecode_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICBitmapFrameDecode_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICBitmapFrameDecode_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 


#define IWICBitmapFrameDecode_GetMetadataQueryReader(This,ppIMetadataQueryReader)	\
    ( (This)->lpVtbl -> GetMetadataQueryReader(This,ppIMetadataQueryReader) ) 

#define IWICBitmapFrameDecode_GetColorContexts(This,cCount,ppIColorContexts,pcActualCount)	\
    ( (This)->lpVtbl -> GetColorContexts(This,cCount,ppIColorContexts,pcActualCount) ) 

#define IWICBitmapFrameDecode_GetThumbnail(This,ppIThumbnail)	\
    ( (This)->lpVtbl -> GetThumbnail(This,ppIThumbnail) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapFrameDecode_INTERFACE_DEFINED__ */


#ifndef __IWICProgressiveLevelControl_INTERFACE_DEFINED__
#define __IWICProgressiveLevelControl_INTERFACE_DEFINED__

/* interface IWICProgressiveLevelControl */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICProgressiveLevelControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DAAC296F-7AA5-4dbf-8D15-225C5976F891")
    IWICProgressiveLevelControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLevelCount( 
            /* [retval][out] */ __RPC__out UINT *pcLevels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLevel( 
            /* [retval][out] */ __RPC__out UINT *pnLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentLevel( 
            /* [in] */ UINT nLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICProgressiveLevelControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICProgressiveLevelControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICProgressiveLevelControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICProgressiveLevelControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLevelCount )( 
            __RPC__in IWICProgressiveLevelControl * This,
            /* [retval][out] */ __RPC__out UINT *pcLevels);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLevel )( 
            __RPC__in IWICProgressiveLevelControl * This,
            /* [retval][out] */ __RPC__out UINT *pnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentLevel )( 
            __RPC__in IWICProgressiveLevelControl * This,
            /* [in] */ UINT nLevel);
        
        END_INTERFACE
    } IWICProgressiveLevelControlVtbl;

    interface IWICProgressiveLevelControl
    {
        CONST_VTBL struct IWICProgressiveLevelControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICProgressiveLevelControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICProgressiveLevelControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICProgressiveLevelControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICProgressiveLevelControl_GetLevelCount(This,pcLevels)	\
    ( (This)->lpVtbl -> GetLevelCount(This,pcLevels) ) 

#define IWICProgressiveLevelControl_GetCurrentLevel(This,pnLevel)	\
    ( (This)->lpVtbl -> GetCurrentLevel(This,pnLevel) ) 

#define IWICProgressiveLevelControl_SetCurrentLevel(This,nLevel)	\
    ( (This)->lpVtbl -> SetCurrentLevel(This,nLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICProgressiveLevelControl_INTERFACE_DEFINED__ */


#ifndef __IWICProgressCallback_INTERFACE_DEFINED__
#define __IWICProgressCallback_INTERFACE_DEFINED__

/* interface IWICProgressCallback */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICProgressCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4776F9CD-9517-45FA-BF24-E89C5EC5C60C")
    IWICProgressCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ ULONG uFrameNum,
            /* [in] */ WICProgressOperation operation,
            /* [in] */ double dblProgress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICProgressCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICProgressCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICProgressCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICProgressCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            __RPC__in IWICProgressCallback * This,
            /* [in] */ ULONG uFrameNum,
            /* [in] */ WICProgressOperation operation,
            /* [in] */ double dblProgress);
        
        END_INTERFACE
    } IWICProgressCallbackVtbl;

    interface IWICProgressCallback
    {
        CONST_VTBL struct IWICProgressCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICProgressCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICProgressCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICProgressCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICProgressCallback_Notify(This,uFrameNum,operation,dblProgress)	\
    ( (This)->lpVtbl -> Notify(This,uFrameNum,operation,dblProgress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICProgressCallback_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapCodecProgressNotification_INTERFACE_DEFINED__
#define __IWICBitmapCodecProgressNotification_INTERFACE_DEFINED__

/* interface IWICBitmapCodecProgressNotification */
/* [uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer HRESULT ( __stdcall *PFNProgressNotification )( 
    __RPC__in LPVOID pvData,
    ULONG uFrameNum,
    WICProgressOperation operation,
    double dblProgress);


EXTERN_C const IID IID_IWICBitmapCodecProgressNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64C1024E-C3CF-4462-8078-88C2B11C46D9")
    IWICBitmapCodecProgressNotification : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RegisterProgressNotification( 
            /* [annotation][unique][in] */ 
            __in_opt  PFNProgressNotification pfnProgressNotification,
            /* [annotation][unique][in] */ 
            __in_opt  LPVOID pvData,
            /* [in] */ DWORD dwProgressFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapCodecProgressNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapCodecProgressNotification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapCodecProgressNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapCodecProgressNotification * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RegisterProgressNotification )( 
            IWICBitmapCodecProgressNotification * This,
            /* [annotation][unique][in] */ 
            __in_opt  PFNProgressNotification pfnProgressNotification,
            /* [annotation][unique][in] */ 
            __in_opt  LPVOID pvData,
            /* [in] */ DWORD dwProgressFlags);
        
        END_INTERFACE
    } IWICBitmapCodecProgressNotificationVtbl;

    interface IWICBitmapCodecProgressNotification
    {
        CONST_VTBL struct IWICBitmapCodecProgressNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapCodecProgressNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapCodecProgressNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapCodecProgressNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapCodecProgressNotification_RegisterProgressNotification(This,pfnProgressNotification,pvData,dwProgressFlags)	\
    ( (This)->lpVtbl -> RegisterProgressNotification(This,pfnProgressNotification,pvData,dwProgressFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICBitmapCodecProgressNotification_Remote_RegisterProgressNotification_Proxy( 
    __RPC__in IWICBitmapCodecProgressNotification * This,
    /* [unique][in] */ __RPC__in_opt IWICProgressCallback *pICallback,
    /* [in] */ DWORD dwProgressFlags);


void __RPC_STUB IWICBitmapCodecProgressNotification_Remote_RegisterProgressNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWICBitmapCodecProgressNotification_INTERFACE_DEFINED__ */


#ifndef __IWICComponentInfo_INTERFACE_DEFINED__
#define __IWICComponentInfo_INTERFACE_DEFINED__

/* interface IWICComponentInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICComponentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23BC3F0A-698B-4357-886B-F24D50671334")
    IWICComponentInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetComponentType( 
            /* [out] */ __RPC__out WICComponentType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSID( 
            /* [out] */ __RPC__out CLSID *pclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSigningStatus( 
            /* [out] */ __RPC__out DWORD *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuthor( 
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVendorGUID( 
            /* [out] */ __RPC__out GUID *pguidVendor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpecVersion( 
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFriendlyName( 
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICComponentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICComponentInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICComponentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICComponentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICComponentInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICComponentInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICComponentInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICComponentInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICComponentInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICComponentInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICComponentInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICComponentInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        END_INTERFACE
    } IWICComponentInfoVtbl;

    interface IWICComponentInfo
    {
        CONST_VTBL struct IWICComponentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICComponentInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICComponentInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICComponentInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICComponentInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICComponentInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICComponentInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICComponentInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICComponentInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICComponentInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICComponentInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICComponentInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICComponentInfo_INTERFACE_DEFINED__ */


#ifndef __IWICFormatConverterInfo_INTERFACE_DEFINED__
#define __IWICFormatConverterInfo_INTERFACE_DEFINED__

/* interface IWICFormatConverterInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICFormatConverterInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F34FB65-13F4-4f15-BC57-3726B5E53D9F")
    IWICFormatConverterInfo : public IWICComponentInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormats( 
            /* [in] */ UINT cFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cFormats) WICPixelFormatGUID *pPixelFormatGUIDs,
            /* [out] */ __RPC__out UINT *pcActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [out] */ __RPC__deref_out_opt IWICFormatConverter **ppIConverter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICFormatConverterInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICFormatConverterInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICFormatConverterInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormats )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [in] */ UINT cFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cFormats) WICPixelFormatGUID *pPixelFormatGUIDs,
            /* [out] */ __RPC__out UINT *pcActual);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            __RPC__in IWICFormatConverterInfo * This,
            /* [out] */ __RPC__deref_out_opt IWICFormatConverter **ppIConverter);
        
        END_INTERFACE
    } IWICFormatConverterInfoVtbl;

    interface IWICFormatConverterInfo
    {
        CONST_VTBL struct IWICFormatConverterInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICFormatConverterInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICFormatConverterInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICFormatConverterInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICFormatConverterInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICFormatConverterInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICFormatConverterInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICFormatConverterInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICFormatConverterInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICFormatConverterInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICFormatConverterInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICFormatConverterInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICFormatConverterInfo_GetPixelFormats(This,cFormats,pPixelFormatGUIDs,pcActual)	\
    ( (This)->lpVtbl -> GetPixelFormats(This,cFormats,pPixelFormatGUIDs,pcActual) ) 

#define IWICFormatConverterInfo_CreateInstance(This,ppIConverter)	\
    ( (This)->lpVtbl -> CreateInstance(This,ppIConverter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICFormatConverterInfo_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapCodecInfo_INTERFACE_DEFINED__
#define __IWICBitmapCodecInfo_INTERFACE_DEFINED__

/* interface IWICBitmapCodecInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapCodecInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E87A44C4-B76E-4c47-8B09-298EB12A2714")
    IWICBitmapCodecInfo : public IWICComponentInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContainerFormat( 
            /* [out] */ __RPC__out GUID *pguidContainerFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormats( 
            /* [in] */ UINT cFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cFormats) GUID *pguidPixelFormats,
            /* [out] */ __RPC__out UINT *pcActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorManagementVersion( 
            /* [in] */ UINT cchColorManagementVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchColorManagementVersion) WCHAR *wzColorManagementVersion,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceManufacturer( 
            /* [in] */ UINT cchDeviceManufacturer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceManufacturer) WCHAR *wzDeviceManufacturer,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceModels( 
            /* [in] */ UINT cchDeviceModels,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceModels) WCHAR *wzDeviceModels,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMimeTypes( 
            /* [in] */ UINT cchMimeTypes,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchMimeTypes) WCHAR *wzMimeTypes,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileExtensions( 
            /* [in] */ UINT cchFileExtensions,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFileExtensions) WCHAR *wzFileExtensions,
            /* [out] */ __RPC__out UINT *pcchActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesSupportAnimation( 
            /* [out] */ __RPC__out BOOL *pfSupportAnimation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesSupportChromakey( 
            /* [out] */ __RPC__out BOOL *pfSupportChromakey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesSupportLossless( 
            /* [out] */ __RPC__out BOOL *pfSupportLossless) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesSupportMultiframe( 
            /* [out] */ __RPC__out BOOL *pfSupportMultiframe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchesMimeType( 
            /* [in] */ __RPC__in LPCWSTR wzMimeType,
            /* [out] */ __RPC__out BOOL *pfMatches) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapCodecInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapCodecInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapCodecInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormats )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cFormats) GUID *pguidPixelFormats,
            /* [out] */ __RPC__out UINT *pcActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorManagementVersion )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchColorManagementVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchColorManagementVersion) WCHAR *wzColorManagementVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceManufacturer )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchDeviceManufacturer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceManufacturer) WCHAR *wzDeviceManufacturer,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceModels )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchDeviceModels,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceModels) WCHAR *wzDeviceModels,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetMimeTypes )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchMimeTypes,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchMimeTypes) WCHAR *wzMimeTypes,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileExtensions )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ UINT cchFileExtensions,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFileExtensions) WCHAR *wzFileExtensions,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportAnimation )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportAnimation);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportChromakey )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportChromakey);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportLossless )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportLossless);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportMultiframe )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportMultiframe);
        
        HRESULT ( STDMETHODCALLTYPE *MatchesMimeType )( 
            __RPC__in IWICBitmapCodecInfo * This,
            /* [in] */ __RPC__in LPCWSTR wzMimeType,
            /* [out] */ __RPC__out BOOL *pfMatches);
        
        END_INTERFACE
    } IWICBitmapCodecInfoVtbl;

    interface IWICBitmapCodecInfo
    {
        CONST_VTBL struct IWICBitmapCodecInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapCodecInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapCodecInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapCodecInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapCodecInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICBitmapCodecInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICBitmapCodecInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICBitmapCodecInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICBitmapCodecInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICBitmapCodecInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICBitmapCodecInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICBitmapCodecInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICBitmapCodecInfo_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICBitmapCodecInfo_GetPixelFormats(This,cFormats,pguidPixelFormats,pcActual)	\
    ( (This)->lpVtbl -> GetPixelFormats(This,cFormats,pguidPixelFormats,pcActual) ) 

#define IWICBitmapCodecInfo_GetColorManagementVersion(This,cchColorManagementVersion,wzColorManagementVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetColorManagementVersion(This,cchColorManagementVersion,wzColorManagementVersion,pcchActual) ) 

#define IWICBitmapCodecInfo_GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual) ) 

#define IWICBitmapCodecInfo_GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual) ) 

#define IWICBitmapCodecInfo_GetMimeTypes(This,cchMimeTypes,wzMimeTypes,pcchActual)	\
    ( (This)->lpVtbl -> GetMimeTypes(This,cchMimeTypes,wzMimeTypes,pcchActual) ) 

#define IWICBitmapCodecInfo_GetFileExtensions(This,cchFileExtensions,wzFileExtensions,pcchActual)	\
    ( (This)->lpVtbl -> GetFileExtensions(This,cchFileExtensions,wzFileExtensions,pcchActual) ) 

#define IWICBitmapCodecInfo_DoesSupportAnimation(This,pfSupportAnimation)	\
    ( (This)->lpVtbl -> DoesSupportAnimation(This,pfSupportAnimation) ) 

#define IWICBitmapCodecInfo_DoesSupportChromakey(This,pfSupportChromakey)	\
    ( (This)->lpVtbl -> DoesSupportChromakey(This,pfSupportChromakey) ) 

#define IWICBitmapCodecInfo_DoesSupportLossless(This,pfSupportLossless)	\
    ( (This)->lpVtbl -> DoesSupportLossless(This,pfSupportLossless) ) 

#define IWICBitmapCodecInfo_DoesSupportMultiframe(This,pfSupportMultiframe)	\
    ( (This)->lpVtbl -> DoesSupportMultiframe(This,pfSupportMultiframe) ) 

#define IWICBitmapCodecInfo_MatchesMimeType(This,wzMimeType,pfMatches)	\
    ( (This)->lpVtbl -> MatchesMimeType(This,wzMimeType,pfMatches) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapCodecInfo_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapEncoderInfo_INTERFACE_DEFINED__
#define __IWICBitmapEncoderInfo_INTERFACE_DEFINED__

/* interface IWICBitmapEncoderInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapEncoderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94C9B4EE-A09F-4f92-8A1E-4A9BCE7E76FB")
    IWICBitmapEncoderInfo : public IWICBitmapCodecInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapEncoder **ppIBitmapEncoder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapEncoderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapEncoderInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapEncoderInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormats )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cFormats) GUID *pguidPixelFormats,
            /* [out] */ __RPC__out UINT *pcActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorManagementVersion )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchColorManagementVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchColorManagementVersion) WCHAR *wzColorManagementVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceManufacturer )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchDeviceManufacturer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceManufacturer) WCHAR *wzDeviceManufacturer,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceModels )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchDeviceModels,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceModels) WCHAR *wzDeviceModels,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetMimeTypes )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchMimeTypes,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchMimeTypes) WCHAR *wzMimeTypes,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileExtensions )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ UINT cchFileExtensions,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFileExtensions) WCHAR *wzFileExtensions,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportAnimation )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportAnimation);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportChromakey )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportChromakey);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportLossless )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportLossless);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportMultiframe )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportMultiframe);
        
        HRESULT ( STDMETHODCALLTYPE *MatchesMimeType )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [in] */ __RPC__in LPCWSTR wzMimeType,
            /* [out] */ __RPC__out BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            __RPC__in IWICBitmapEncoderInfo * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapEncoder **ppIBitmapEncoder);
        
        END_INTERFACE
    } IWICBitmapEncoderInfoVtbl;

    interface IWICBitmapEncoderInfo
    {
        CONST_VTBL struct IWICBitmapEncoderInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapEncoderInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapEncoderInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapEncoderInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapEncoderInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICBitmapEncoderInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICBitmapEncoderInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICBitmapEncoderInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICBitmapEncoderInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICBitmapEncoderInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICBitmapEncoderInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICBitmapEncoderInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICBitmapEncoderInfo_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICBitmapEncoderInfo_GetPixelFormats(This,cFormats,pguidPixelFormats,pcActual)	\
    ( (This)->lpVtbl -> GetPixelFormats(This,cFormats,pguidPixelFormats,pcActual) ) 

#define IWICBitmapEncoderInfo_GetColorManagementVersion(This,cchColorManagementVersion,wzColorManagementVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetColorManagementVersion(This,cchColorManagementVersion,wzColorManagementVersion,pcchActual) ) 

#define IWICBitmapEncoderInfo_GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual) ) 

#define IWICBitmapEncoderInfo_GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual) ) 

#define IWICBitmapEncoderInfo_GetMimeTypes(This,cchMimeTypes,wzMimeTypes,pcchActual)	\
    ( (This)->lpVtbl -> GetMimeTypes(This,cchMimeTypes,wzMimeTypes,pcchActual) ) 

#define IWICBitmapEncoderInfo_GetFileExtensions(This,cchFileExtensions,wzFileExtensions,pcchActual)	\
    ( (This)->lpVtbl -> GetFileExtensions(This,cchFileExtensions,wzFileExtensions,pcchActual) ) 

#define IWICBitmapEncoderInfo_DoesSupportAnimation(This,pfSupportAnimation)	\
    ( (This)->lpVtbl -> DoesSupportAnimation(This,pfSupportAnimation) ) 

#define IWICBitmapEncoderInfo_DoesSupportChromakey(This,pfSupportChromakey)	\
    ( (This)->lpVtbl -> DoesSupportChromakey(This,pfSupportChromakey) ) 

#define IWICBitmapEncoderInfo_DoesSupportLossless(This,pfSupportLossless)	\
    ( (This)->lpVtbl -> DoesSupportLossless(This,pfSupportLossless) ) 

#define IWICBitmapEncoderInfo_DoesSupportMultiframe(This,pfSupportMultiframe)	\
    ( (This)->lpVtbl -> DoesSupportMultiframe(This,pfSupportMultiframe) ) 

#define IWICBitmapEncoderInfo_MatchesMimeType(This,wzMimeType,pfMatches)	\
    ( (This)->lpVtbl -> MatchesMimeType(This,wzMimeType,pfMatches) ) 


#define IWICBitmapEncoderInfo_CreateInstance(This,ppIBitmapEncoder)	\
    ( (This)->lpVtbl -> CreateInstance(This,ppIBitmapEncoder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICBitmapEncoderInfo_INTERFACE_DEFINED__ */


#ifndef __IWICBitmapDecoderInfo_INTERFACE_DEFINED__
#define __IWICBitmapDecoderInfo_INTERFACE_DEFINED__

/* interface IWICBitmapDecoderInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICBitmapDecoderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8CD007F-D08F-4191-9BFC-236EA7F0E4B5")
    IWICBitmapDecoderInfo : public IWICBitmapCodecInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPatterns( 
            /* [in] */ UINT cbSizePatterns,
            /* [annotation][unique][size_is][out] */ 
            __out_bcount_part_opt(cbSizePatterns, *pcbPatternsActual)  WICBitmapPattern *pPatterns,
            /* [annotation][unique][out] */ 
            __inout_opt  UINT *pcPatterns,
            /* [annotation][out] */ 
            __inout_opt  UINT *pcbPatternsActual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MatchesPattern( 
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__out BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIBitmapDecoder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICBitmapDecoderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICBitmapDecoderInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICBitmapDecoderInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerFormat )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out GUID *pguidContainerFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormats )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cFormats,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cFormats) GUID *pguidPixelFormats,
            /* [out] */ __RPC__out UINT *pcActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorManagementVersion )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchColorManagementVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchColorManagementVersion) WCHAR *wzColorManagementVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceManufacturer )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchDeviceManufacturer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceManufacturer) WCHAR *wzDeviceManufacturer,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceModels )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchDeviceModels,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchDeviceModels) WCHAR *wzDeviceModels,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetMimeTypes )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchMimeTypes,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchMimeTypes) WCHAR *wzMimeTypes,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileExtensions )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cchFileExtensions,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFileExtensions) WCHAR *wzFileExtensions,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportAnimation )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportAnimation);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportChromakey )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportChromakey);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportLossless )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportLossless);
        
        HRESULT ( STDMETHODCALLTYPE *DoesSupportMultiframe )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__out BOOL *pfSupportMultiframe);
        
        HRESULT ( STDMETHODCALLTYPE *MatchesMimeType )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ __RPC__in LPCWSTR wzMimeType,
            /* [out] */ __RPC__out BOOL *pfMatches);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetPatterns )( 
            IWICBitmapDecoderInfo * This,
            /* [in] */ UINT cbSizePatterns,
            /* [annotation][unique][size_is][out] */ 
            __out_bcount_part_opt(cbSizePatterns, *pcbPatternsActual)  WICBitmapPattern *pPatterns,
            /* [annotation][unique][out] */ 
            __inout_opt  UINT *pcPatterns,
            /* [annotation][out] */ 
            __inout_opt  UINT *pcbPatternsActual);
        
        HRESULT ( STDMETHODCALLTYPE *MatchesPattern )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [out] */ __RPC__out BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            __RPC__in IWICBitmapDecoderInfo * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIBitmapDecoder);
        
        END_INTERFACE
    } IWICBitmapDecoderInfoVtbl;

    interface IWICBitmapDecoderInfo
    {
        CONST_VTBL struct IWICBitmapDecoderInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICBitmapDecoderInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICBitmapDecoderInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICBitmapDecoderInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICBitmapDecoderInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICBitmapDecoderInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICBitmapDecoderInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICBitmapDecoderInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICBitmapDecoderInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICBitmapDecoderInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICBitmapDecoderInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICBitmapDecoderInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICBitmapDecoderInfo_GetContainerFormat(This,pguidContainerFormat)	\
    ( (This)->lpVtbl -> GetContainerFormat(This,pguidContainerFormat) ) 

#define IWICBitmapDecoderInfo_GetPixelFormats(This,cFormats,pguidPixelFormats,pcActual)	\
    ( (This)->lpVtbl -> GetPixelFormats(This,cFormats,pguidPixelFormats,pcActual) ) 

#define IWICBitmapDecoderInfo_GetColorManagementVersion(This,cchColorManagementVersion,wzColorManagementVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetColorManagementVersion(This,cchColorManagementVersion,wzColorManagementVersion,pcchActual) ) 

#define IWICBitmapDecoderInfo_GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceManufacturer(This,cchDeviceManufacturer,wzDeviceManufacturer,pcchActual) ) 

#define IWICBitmapDecoderInfo_GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual)	\
    ( (This)->lpVtbl -> GetDeviceModels(This,cchDeviceModels,wzDeviceModels,pcchActual) ) 

#define IWICBitmapDecoderInfo_GetMimeTypes(This,cchMimeTypes,wzMimeTypes,pcchActual)	\
    ( (This)->lpVtbl -> GetMimeTypes(This,cchMimeTypes,wzMimeTypes,pcchActual) ) 

#define IWICBitmapDecoderInfo_GetFileExtensions(This,cchFileExtensions,wzFileExtensions,pcchActual)	\
    ( (This)->lpVtbl -> GetFileExtensions(This,cchFileExtensions,wzFileExtensions,pcchActual) ) 

#define IWICBitmapDecoderInfo_DoesSupportAnimation(This,pfSupportAnimation)	\
    ( (This)->lpVtbl -> DoesSupportAnimation(This,pfSupportAnimation) ) 

#define IWICBitmapDecoderInfo_DoesSupportChromakey(This,pfSupportChromakey)	\
    ( (This)->lpVtbl -> DoesSupportChromakey(This,pfSupportChromakey) ) 

#define IWICBitmapDecoderInfo_DoesSupportLossless(This,pfSupportLossless)	\
    ( (This)->lpVtbl -> DoesSupportLossless(This,pfSupportLossless) ) 

#define IWICBitmapDecoderInfo_DoesSupportMultiframe(This,pfSupportMultiframe)	\
    ( (This)->lpVtbl -> DoesSupportMultiframe(This,pfSupportMultiframe) ) 

#define IWICBitmapDecoderInfo_MatchesMimeType(This,wzMimeType,pfMatches)	\
    ( (This)->lpVtbl -> MatchesMimeType(This,wzMimeType,pfMatches) ) 


#define IWICBitmapDecoderInfo_GetPatterns(This,cbSizePatterns,pPatterns,pcPatterns,pcbPatternsActual)	\
    ( (This)->lpVtbl -> GetPatterns(This,cbSizePatterns,pPatterns,pcPatterns,pcbPatternsActual) ) 

#define IWICBitmapDecoderInfo_MatchesPattern(This,pIStream,pfMatches)	\
    ( (This)->lpVtbl -> MatchesPattern(This,pIStream,pfMatches) ) 

#define IWICBitmapDecoderInfo_CreateInstance(This,ppIBitmapDecoder)	\
    ( (This)->lpVtbl -> CreateInstance(This,ppIBitmapDecoder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICBitmapDecoderInfo_Remote_GetPatterns_Proxy( 
    __RPC__in IWICBitmapDecoderInfo * This,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcPatterns) WICBitmapPattern **ppPatterns,
    /* [out] */ __RPC__out UINT *pcPatterns);


void __RPC_STUB IWICBitmapDecoderInfo_Remote_GetPatterns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWICBitmapDecoderInfo_INTERFACE_DEFINED__ */


#ifndef __IWICPixelFormatInfo_INTERFACE_DEFINED__
#define __IWICPixelFormatInfo_INTERFACE_DEFINED__

/* interface IWICPixelFormatInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICPixelFormatInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8EDA601-3D48-431a-AB44-69059BE88BBE")
    IWICPixelFormatInfo : public IWICComponentInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormatGUID( 
            /* [out] */ __RPC__out GUID *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorContext( 
            /* [out] */ __RPC__deref_out_opt IWICColorContext **ppIColorContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitsPerPixel( 
            /* [out] */ __RPC__out UINT *puiBitsPerPixel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChannelCount( 
            /* [out] */ __RPC__out UINT *puiChannelCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChannelMask( 
            /* [in] */ UINT uiChannelIndex,
            /* [in] */ UINT cbMaskBuffer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cbMaskBuffer) BYTE *pbMaskBuffer,
            /* [out] */ __RPC__out UINT *pcbActual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICPixelFormatInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICPixelFormatInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICPixelFormatInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormatGUID )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [out] */ __RPC__out GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorContext )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [out] */ __RPC__deref_out_opt IWICColorContext **ppIColorContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitsPerPixel )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [out] */ __RPC__out UINT *puiBitsPerPixel);
        
        HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [out] */ __RPC__out UINT *puiChannelCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetChannelMask )( 
            __RPC__in IWICPixelFormatInfo * This,
            /* [in] */ UINT uiChannelIndex,
            /* [in] */ UINT cbMaskBuffer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cbMaskBuffer) BYTE *pbMaskBuffer,
            /* [out] */ __RPC__out UINT *pcbActual);
        
        END_INTERFACE
    } IWICPixelFormatInfoVtbl;

    interface IWICPixelFormatInfo
    {
        CONST_VTBL struct IWICPixelFormatInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICPixelFormatInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICPixelFormatInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICPixelFormatInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICPixelFormatInfo_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICPixelFormatInfo_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICPixelFormatInfo_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICPixelFormatInfo_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICPixelFormatInfo_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICPixelFormatInfo_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICPixelFormatInfo_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICPixelFormatInfo_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICPixelFormatInfo_GetFormatGUID(This,pFormat)	\
    ( (This)->lpVtbl -> GetFormatGUID(This,pFormat) ) 

#define IWICPixelFormatInfo_GetColorContext(This,ppIColorContext)	\
    ( (This)->lpVtbl -> GetColorContext(This,ppIColorContext) ) 

#define IWICPixelFormatInfo_GetBitsPerPixel(This,puiBitsPerPixel)	\
    ( (This)->lpVtbl -> GetBitsPerPixel(This,puiBitsPerPixel) ) 

#define IWICPixelFormatInfo_GetChannelCount(This,puiChannelCount)	\
    ( (This)->lpVtbl -> GetChannelCount(This,puiChannelCount) ) 

#define IWICPixelFormatInfo_GetChannelMask(This,uiChannelIndex,cbMaskBuffer,pbMaskBuffer,pcbActual)	\
    ( (This)->lpVtbl -> GetChannelMask(This,uiChannelIndex,cbMaskBuffer,pbMaskBuffer,pcbActual) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICPixelFormatInfo_INTERFACE_DEFINED__ */


#ifndef __IWICPixelFormatInfo2_INTERFACE_DEFINED__
#define __IWICPixelFormatInfo2_INTERFACE_DEFINED__

/* interface IWICPixelFormatInfo2 */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICPixelFormatInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9DB33A2-AF5F-43C7-B679-74F5984B5AA4")
    IWICPixelFormatInfo2 : public IWICPixelFormatInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SupportsTransparency( 
            /* [out] */ __RPC__out BOOL *pfSupportsTransparency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumericRepresentation( 
            /* [out] */ __RPC__out WICPixelFormatNumericRepresentation *pNumericRepresentation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICPixelFormatInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICPixelFormatInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICPixelFormatInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out WICComponentType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSID )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *GetSigningStatus )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out DWORD *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuthor )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [in] */ UINT cchAuthor,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchAuthor) WCHAR *wzAuthor,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetVendorGUID )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out GUID *pguidVendor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [in] */ UINT cchVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchVersion) WCHAR *wzVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [in] */ UINT cchSpecVersion,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchSpecVersion) WCHAR *wzSpecVersion,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFriendlyName )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [in] */ UINT cchFriendlyName,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cchFriendlyName) WCHAR *wzFriendlyName,
            /* [out] */ __RPC__out UINT *pcchActual);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormatGUID )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorContext )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__deref_out_opt IWICColorContext **ppIColorContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitsPerPixel )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out UINT *puiBitsPerPixel);
        
        HRESULT ( STDMETHODCALLTYPE *GetChannelCount )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out UINT *puiChannelCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetChannelMask )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [in] */ UINT uiChannelIndex,
            /* [in] */ UINT cbMaskBuffer,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cbMaskBuffer) BYTE *pbMaskBuffer,
            /* [out] */ __RPC__out UINT *pcbActual);
        
        HRESULT ( STDMETHODCALLTYPE *SupportsTransparency )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out BOOL *pfSupportsTransparency);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumericRepresentation )( 
            __RPC__in IWICPixelFormatInfo2 * This,
            /* [out] */ __RPC__out WICPixelFormatNumericRepresentation *pNumericRepresentation);
        
        END_INTERFACE
    } IWICPixelFormatInfo2Vtbl;

    interface IWICPixelFormatInfo2
    {
        CONST_VTBL struct IWICPixelFormatInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICPixelFormatInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICPixelFormatInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICPixelFormatInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICPixelFormatInfo2_GetComponentType(This,pType)	\
    ( (This)->lpVtbl -> GetComponentType(This,pType) ) 

#define IWICPixelFormatInfo2_GetCLSID(This,pclsid)	\
    ( (This)->lpVtbl -> GetCLSID(This,pclsid) ) 

#define IWICPixelFormatInfo2_GetSigningStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetSigningStatus(This,pStatus) ) 

#define IWICPixelFormatInfo2_GetAuthor(This,cchAuthor,wzAuthor,pcchActual)	\
    ( (This)->lpVtbl -> GetAuthor(This,cchAuthor,wzAuthor,pcchActual) ) 

#define IWICPixelFormatInfo2_GetVendorGUID(This,pguidVendor)	\
    ( (This)->lpVtbl -> GetVendorGUID(This,pguidVendor) ) 

#define IWICPixelFormatInfo2_GetVersion(This,cchVersion,wzVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetVersion(This,cchVersion,wzVersion,pcchActual) ) 

#define IWICPixelFormatInfo2_GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,cchSpecVersion,wzSpecVersion,pcchActual) ) 

#define IWICPixelFormatInfo2_GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual)	\
    ( (This)->lpVtbl -> GetFriendlyName(This,cchFriendlyName,wzFriendlyName,pcchActual) ) 


#define IWICPixelFormatInfo2_GetFormatGUID(This,pFormat)	\
    ( (This)->lpVtbl -> GetFormatGUID(This,pFormat) ) 

#define IWICPixelFormatInfo2_GetColorContext(This,ppIColorContext)	\
    ( (This)->lpVtbl -> GetColorContext(This,ppIColorContext) ) 

#define IWICPixelFormatInfo2_GetBitsPerPixel(This,puiBitsPerPixel)	\
    ( (This)->lpVtbl -> GetBitsPerPixel(This,puiBitsPerPixel) ) 

#define IWICPixelFormatInfo2_GetChannelCount(This,puiChannelCount)	\
    ( (This)->lpVtbl -> GetChannelCount(This,puiChannelCount) ) 

#define IWICPixelFormatInfo2_GetChannelMask(This,uiChannelIndex,cbMaskBuffer,pbMaskBuffer,pcbActual)	\
    ( (This)->lpVtbl -> GetChannelMask(This,uiChannelIndex,cbMaskBuffer,pbMaskBuffer,pcbActual) ) 


#define IWICPixelFormatInfo2_SupportsTransparency(This,pfSupportsTransparency)	\
    ( (This)->lpVtbl -> SupportsTransparency(This,pfSupportsTransparency) ) 

#define IWICPixelFormatInfo2_GetNumericRepresentation(This,pNumericRepresentation)	\
    ( (This)->lpVtbl -> GetNumericRepresentation(This,pNumericRepresentation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICPixelFormatInfo2_INTERFACE_DEFINED__ */


#ifndef __IWICImagingFactory_INTERFACE_DEFINED__
#define __IWICImagingFactory_INTERFACE_DEFINED__

/* interface IWICImagingFactory */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICImagingFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec5ec8a9-c395-4314-9c77-54d7a935ff70")
    IWICImagingFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateDecoderFromFilename( 
            /* [in] */ __RPC__in LPCWSTR wzFilename,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDecoderFromStream( 
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDecoderFromFileHandle( 
            /* [in] */ ULONG_PTR hFile,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateComponentInfo( 
            /* [in] */ __RPC__in REFCLSID clsidComponent,
            /* [out] */ __RPC__deref_out_opt IWICComponentInfo **ppIInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDecoder( 
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEncoder( 
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapEncoder **ppIEncoder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePalette( 
            /* [out] */ __RPC__deref_out_opt IWICPalette **ppIPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFormatConverter( 
            /* [out] */ __RPC__deref_out_opt IWICFormatConverter **ppIFormatConverter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmapScaler( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapScaler **ppIBitmapScaler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmapClipper( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapClipper **ppIBitmapClipper) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmapFlipRotator( 
            /* [out] */ __RPC__deref_out_opt IWICBitmapFlipRotator **ppIBitmapFlipRotator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [out] */ __RPC__deref_out_opt IWICStream **ppIWICStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateColorContext( 
            /* [out] */ __RPC__deref_out_opt IWICColorContext **ppIWICColorContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateColorTransformer( 
            /* [out] */ __RPC__deref_out_opt IWICColorTransform **ppIWICColorTransform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmap( 
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [in] */ __RPC__in REFWICPixelFormatGUID pixelFormat,
            /* [in] */ WICBitmapCreateCacheOption option,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmapFromSource( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [in] */ WICBitmapCreateCacheOption option,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmapFromSourceRect( 
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [in] */ UINT x,
            /* [in] */ UINT y,
            /* [in] */ UINT width,
            /* [in] */ UINT height,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmapFromMemory( 
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [in] */ __RPC__in REFWICPixelFormatGUID pixelFormat,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) BYTE *pbBuffer,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmapFromHBITMAP( 
            /* [in] */ __RPC__in HBITMAP hBitmap,
            /* [unique][in] */ __RPC__in_opt HPALETTE hPalette,
            /* [in] */ WICBitmapAlphaChannelOption options,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBitmapFromHICON( 
            /* [in] */ __RPC__in HICON hIcon,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateComponentEnumerator( 
            /* [in] */ DWORD componentTypes,
            /* [in] */ DWORD options,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppIEnumUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFastMetadataEncoderFromDecoder( 
            /* [in] */ __RPC__in_opt IWICBitmapDecoder *pIDecoder,
            /* [out] */ __RPC__deref_out_opt IWICFastMetadataEncoder **ppIFastEncoder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFastMetadataEncoderFromFrameDecode( 
            /* [in] */ __RPC__in_opt IWICBitmapFrameDecode *pIFrameDecoder,
            /* [out] */ __RPC__deref_out_opt IWICFastMetadataEncoder **ppIFastEncoder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateQueryWriter( 
            /* [in] */ __RPC__in REFGUID guidMetadataFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIQueryWriter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateQueryWriterFromReader( 
            /* [in] */ __RPC__in_opt IWICMetadataQueryReader *pIQueryReader,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIQueryWriter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICImagingFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICImagingFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICImagingFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDecoderFromFilename )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in LPCWSTR wzFilename,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDecoderFromStream )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in_opt IStream *pIStream,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDecoderFromFileHandle )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ ULONG_PTR hFile,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [in] */ WICDecodeOptions metadataOptions,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateComponentInfo )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in REFCLSID clsidComponent,
            /* [out] */ __RPC__deref_out_opt IWICComponentInfo **ppIInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDecoder )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapDecoder **ppIDecoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEncoder )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in REFGUID guidContainerFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [retval][out] */ __RPC__deref_out_opt IWICBitmapEncoder **ppIEncoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePalette )( 
            __RPC__in IWICImagingFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICPalette **ppIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFormatConverter )( 
            __RPC__in IWICImagingFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICFormatConverter **ppIFormatConverter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapScaler )( 
            __RPC__in IWICImagingFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapScaler **ppIBitmapScaler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapClipper )( 
            __RPC__in IWICImagingFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapClipper **ppIBitmapClipper);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFlipRotator )( 
            __RPC__in IWICImagingFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapFlipRotator **ppIBitmapFlipRotator);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            __RPC__in IWICImagingFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICStream **ppIWICStream);
        
        HRESULT ( STDMETHODCALLTYPE *CreateColorContext )( 
            __RPC__in IWICImagingFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICColorContext **ppIWICColorContext);
        
        HRESULT ( STDMETHODCALLTYPE *CreateColorTransformer )( 
            __RPC__in IWICImagingFactory * This,
            /* [out] */ __RPC__deref_out_opt IWICColorTransform **ppIWICColorTransform);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmap )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [in] */ __RPC__in REFWICPixelFormatGUID pixelFormat,
            /* [in] */ WICBitmapCreateCacheOption option,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromSource )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [in] */ WICBitmapCreateCacheOption option,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromSourceRect )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in_opt IWICBitmapSource *pIBitmapSource,
            /* [in] */ UINT x,
            /* [in] */ UINT y,
            /* [in] */ UINT width,
            /* [in] */ UINT height,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromMemory )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ UINT uiWidth,
            /* [in] */ UINT uiHeight,
            /* [in] */ __RPC__in REFWICPixelFormatGUID pixelFormat,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(cbBufferSize) BYTE *pbBuffer,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromHBITMAP )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in HBITMAP hBitmap,
            /* [unique][in] */ __RPC__in_opt HPALETTE hPalette,
            /* [in] */ WICBitmapAlphaChannelOption options,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBitmapFromHICON )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in HICON hIcon,
            /* [out] */ __RPC__deref_out_opt IWICBitmap **ppIBitmap);
        
        HRESULT ( STDMETHODCALLTYPE *CreateComponentEnumerator )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ DWORD componentTypes,
            /* [in] */ DWORD options,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppIEnumUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFastMetadataEncoderFromDecoder )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in_opt IWICBitmapDecoder *pIDecoder,
            /* [out] */ __RPC__deref_out_opt IWICFastMetadataEncoder **ppIFastEncoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFastMetadataEncoderFromFrameDecode )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in_opt IWICBitmapFrameDecode *pIFrameDecoder,
            /* [out] */ __RPC__deref_out_opt IWICFastMetadataEncoder **ppIFastEncoder);
        
        HRESULT ( STDMETHODCALLTYPE *CreateQueryWriter )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in REFGUID guidMetadataFormat,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIQueryWriter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateQueryWriterFromReader )( 
            __RPC__in IWICImagingFactory * This,
            /* [in] */ __RPC__in_opt IWICMetadataQueryReader *pIQueryReader,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidVendor,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryWriter **ppIQueryWriter);
        
        END_INTERFACE
    } IWICImagingFactoryVtbl;

    interface IWICImagingFactory
    {
        CONST_VTBL struct IWICImagingFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICImagingFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICImagingFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICImagingFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICImagingFactory_CreateDecoderFromFilename(This,wzFilename,pguidVendor,dwDesiredAccess,metadataOptions,ppIDecoder)	\
    ( (This)->lpVtbl -> CreateDecoderFromFilename(This,wzFilename,pguidVendor,dwDesiredAccess,metadataOptions,ppIDecoder) ) 

#define IWICImagingFactory_CreateDecoderFromStream(This,pIStream,pguidVendor,metadataOptions,ppIDecoder)	\
    ( (This)->lpVtbl -> CreateDecoderFromStream(This,pIStream,pguidVendor,metadataOptions,ppIDecoder) ) 

#define IWICImagingFactory_CreateDecoderFromFileHandle(This,hFile,pguidVendor,metadataOptions,ppIDecoder)	\
    ( (This)->lpVtbl -> CreateDecoderFromFileHandle(This,hFile,pguidVendor,metadataOptions,ppIDecoder) ) 

#define IWICImagingFactory_CreateComponentInfo(This,clsidComponent,ppIInfo)	\
    ( (This)->lpVtbl -> CreateComponentInfo(This,clsidComponent,ppIInfo) ) 

#define IWICImagingFactory_CreateDecoder(This,guidContainerFormat,pguidVendor,ppIDecoder)	\
    ( (This)->lpVtbl -> CreateDecoder(This,guidContainerFormat,pguidVendor,ppIDecoder) ) 

#define IWICImagingFactory_CreateEncoder(This,guidContainerFormat,pguidVendor,ppIEncoder)	\
    ( (This)->lpVtbl -> CreateEncoder(This,guidContainerFormat,pguidVendor,ppIEncoder) ) 

#define IWICImagingFactory_CreatePalette(This,ppIPalette)	\
    ( (This)->lpVtbl -> CreatePalette(This,ppIPalette) ) 

#define IWICImagingFactory_CreateFormatConverter(This,ppIFormatConverter)	\
    ( (This)->lpVtbl -> CreateFormatConverter(This,ppIFormatConverter) ) 

#define IWICImagingFactory_CreateBitmapScaler(This,ppIBitmapScaler)	\
    ( (This)->lpVtbl -> CreateBitmapScaler(This,ppIBitmapScaler) ) 

#define IWICImagingFactory_CreateBitmapClipper(This,ppIBitmapClipper)	\
    ( (This)->lpVtbl -> CreateBitmapClipper(This,ppIBitmapClipper) ) 

#define IWICImagingFactory_CreateBitmapFlipRotator(This,ppIBitmapFlipRotator)	\
    ( (This)->lpVtbl -> CreateBitmapFlipRotator(This,ppIBitmapFlipRotator) ) 

#define IWICImagingFactory_CreateStream(This,ppIWICStream)	\
    ( (This)->lpVtbl -> CreateStream(This,ppIWICStream) ) 

#define IWICImagingFactory_CreateColorContext(This,ppIWICColorContext)	\
    ( (This)->lpVtbl -> CreateColorContext(This,ppIWICColorContext) ) 

#define IWICImagingFactory_CreateColorTransformer(This,ppIWICColorTransform)	\
    ( (This)->lpVtbl -> CreateColorTransformer(This,ppIWICColorTransform) ) 

#define IWICImagingFactory_CreateBitmap(This,uiWidth,uiHeight,pixelFormat,option,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmap(This,uiWidth,uiHeight,pixelFormat,option,ppIBitmap) ) 

#define IWICImagingFactory_CreateBitmapFromSource(This,pIBitmapSource,option,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromSource(This,pIBitmapSource,option,ppIBitmap) ) 

#define IWICImagingFactory_CreateBitmapFromSourceRect(This,pIBitmapSource,x,y,width,height,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromSourceRect(This,pIBitmapSource,x,y,width,height,ppIBitmap) ) 

#define IWICImagingFactory_CreateBitmapFromMemory(This,uiWidth,uiHeight,pixelFormat,cbStride,cbBufferSize,pbBuffer,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromMemory(This,uiWidth,uiHeight,pixelFormat,cbStride,cbBufferSize,pbBuffer,ppIBitmap) ) 

#define IWICImagingFactory_CreateBitmapFromHBITMAP(This,hBitmap,hPalette,options,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromHBITMAP(This,hBitmap,hPalette,options,ppIBitmap) ) 

#define IWICImagingFactory_CreateBitmapFromHICON(This,hIcon,ppIBitmap)	\
    ( (This)->lpVtbl -> CreateBitmapFromHICON(This,hIcon,ppIBitmap) ) 

#define IWICImagingFactory_CreateComponentEnumerator(This,componentTypes,options,ppIEnumUnknown)	\
    ( (This)->lpVtbl -> CreateComponentEnumerator(This,componentTypes,options,ppIEnumUnknown) ) 

#define IWICImagingFactory_CreateFastMetadataEncoderFromDecoder(This,pIDecoder,ppIFastEncoder)	\
    ( (This)->lpVtbl -> CreateFastMetadataEncoderFromDecoder(This,pIDecoder,ppIFastEncoder) ) 

#define IWICImagingFactory_CreateFastMetadataEncoderFromFrameDecode(This,pIFrameDecoder,ppIFastEncoder)	\
    ( (This)->lpVtbl -> CreateFastMetadataEncoderFromFrameDecode(This,pIFrameDecoder,ppIFastEncoder) ) 

#define IWICImagingFactory_CreateQueryWriter(This,guidMetadataFormat,pguidVendor,ppIQueryWriter)	\
    ( (This)->lpVtbl -> CreateQueryWriter(This,guidMetadataFormat,pguidVendor,ppIQueryWriter) ) 

#define IWICImagingFactory_CreateQueryWriterFromReader(This,pIQueryReader,pguidVendor,ppIQueryWriter)	\
    ( (This)->lpVtbl -> CreateQueryWriterFromReader(This,pIQueryReader,pguidVendor,ppIQueryWriter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICImagingFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wincodec_0000_0031 */
/* [local] */ 

HRESULT WINAPI WICConvertBitmapSource(
     __in REFWICPixelFormatGUID dstFormat, // Destination pixel format
     __in_ecount(1) IWICBitmapSource  *pISrc,    // Source bitmap
     __deref_out_ecount(1) IWICBitmapSource **ppIDst   // Destination bitmap, a copy or addrefed source
     );
HRESULT WINAPI WICCreateBitmapFromSection(
     __in UINT width,
     __in UINT height,
     __in REFWICPixelFormatGUID pixelFormat,
     __in HANDLE hSection,
     __in UINT stride,
     __in UINT offset,
     __deref_out_ecount(1) IWICBitmap **ppIBitmap
     );
HRESULT WINAPI WICCreateBitmapFromSectionEx(
     __in UINT width,
     __in UINT height,
     __in REFWICPixelFormatGUID pixelFormat,
     __in HANDLE hSection,
     __in UINT stride,
     __in UINT offset,
     __in WICSectionAccessLevel desiredAccessLevel,
     __deref_out_ecount(1) IWICBitmap **ppIBitmap
     );
HRESULT WINAPI WICMapGuidToShortName(
    __in_ecount(1) REFGUID guid,
    __in UINT cchName,
    __inout_ecount_opt(cchName) WCHAR *wzName,
    __out_ecount(1) UINT *pcchActual
   );
HRESULT WINAPI WICMapShortNameToGuid(
    __in_ecount(1) const WCHAR *wzName,
    __out_ecount(1) GUID *pguid
   );
HRESULT WINAPI WICMapSchemaToName(
    __in_ecount(1) REFGUID guidMetadataFormat,
    __in_ecount(1) LPWSTR pwzSchema,
    __in UINT cchName,
    __inout_ecount_opt(cchName) WCHAR *wzName,
    __out_ecount(1) UINT *pcchActual
    );
#define FACILITY_WINCODEC_ERR 0x898
#define WINCODEC_ERR_BASE 0x2000
#define MAKE_WINCODECHR(sev, code) MAKE_HRESULT(sev, FACILITY_WINCODEC_ERR, (WINCODEC_ERR_BASE + code))
#define MAKE_WINCODECHR_ERR(code) MAKE_WINCODECHR(1, code)
#define WINCODEC_ERR_GENERIC_ERROR                    E_FAIL
#define WINCODEC_ERR_INVALIDPARAMETER                 E_INVALIDARG
#define WINCODEC_ERR_OUTOFMEMORY                      E_OUTOFMEMORY
#define WINCODEC_ERR_NOTIMPLEMENTED                   E_NOTIMPL
#define WINCODEC_ERR_ABORTED                          E_ABORT
#define WINCODEC_ERR_ACCESSDENIED                     E_ACCESSDENIED
#define WINCODEC_ERR_VALUEOVERFLOW                    INTSAFE_E_ARITHMETIC_OVERFLOW
#define WINCODEC_ERR_WRONGSTATE                       MAKE_WINCODECHR_ERR(0xf04)
#define WINCODEC_ERR_VALUEOUTOFRANGE                  MAKE_WINCODECHR_ERR(0xf05)
#define WINCODEC_ERR_UNKNOWNIMAGEFORMAT               MAKE_WINCODECHR_ERR(0xf07)
#define WINCODEC_ERR_UNSUPPORTEDVERSION               MAKE_WINCODECHR_ERR(0xf0B)
#define WINCODEC_ERR_NOTINITIALIZED                   MAKE_WINCODECHR_ERR(0xf0C)
#define WINCODEC_ERR_ALREADYLOCKED                    MAKE_WINCODECHR_ERR(0xf0D)
#define WINCODEC_ERR_PROPERTYNOTFOUND                 MAKE_WINCODECHR_ERR(0xf40)
#define WINCODEC_ERR_PROPERTYNOTSUPPORTED             MAKE_WINCODECHR_ERR(0xf41)
#define WINCODEC_ERR_PROPERTYSIZE                     MAKE_WINCODECHR_ERR(0xf42)
#define WINCODEC_ERR_CODECPRESENT                     MAKE_WINCODECHR_ERR(0xf43)
#define WINCODEC_ERR_CODECNOTHUMBNAIL                 MAKE_WINCODECHR_ERR(0xf44)
#define WINCODEC_ERR_PALETTEUNAVAILABLE               MAKE_WINCODECHR_ERR(0xf45)
#define WINCODEC_ERR_CODECTOOMANYSCANLINES            MAKE_WINCODECHR_ERR(0xf46)
#define WINCODEC_ERR_INTERNALERROR                    MAKE_WINCODECHR_ERR(0xf48)
#define WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS MAKE_WINCODECHR_ERR(0xf49)
#define WINCODEC_ERR_COMPONENTNOTFOUND                MAKE_WINCODECHR_ERR(0xf50)
#define WINCODEC_ERR_IMAGESIZEOUTOFRANGE              MAKE_WINCODECHR_ERR(0xf51)
#define WINCODEC_ERR_TOOMUCHMETADATA                  MAKE_WINCODECHR_ERR(0xf52)
#define WINCODEC_ERR_BADIMAGE                         MAKE_WINCODECHR_ERR(0xf60)
#define WINCODEC_ERR_BADHEADER                        MAKE_WINCODECHR_ERR(0xf61)
#define WINCODEC_ERR_FRAMEMISSING                     MAKE_WINCODECHR_ERR(0xf62)
#define WINCODEC_ERR_BADMETADATAHEADER                MAKE_WINCODECHR_ERR(0xf63)
#define WINCODEC_ERR_BADSTREAMDATA                    MAKE_WINCODECHR_ERR(0xf70)
#define WINCODEC_ERR_STREAMWRITE                      MAKE_WINCODECHR_ERR(0xf71)
#define WINCODEC_ERR_STREAMREAD                       MAKE_WINCODECHR_ERR(0xf72)
#define WINCODEC_ERR_STREAMNOTAVAILABLE               MAKE_WINCODECHR_ERR(0xf73)
#define WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT           MAKE_WINCODECHR_ERR(0xf80)
#define WINCODEC_ERR_UNSUPPORTEDOPERATION             MAKE_WINCODECHR_ERR(0xf81)
#define WINCODEC_ERR_INVALIDREGISTRATION              MAKE_WINCODECHR_ERR(0xf8A)
#define WINCODEC_ERR_COMPONENTINITIALIZEFAILURE       MAKE_WINCODECHR_ERR(0xf8B)
#define WINCODEC_ERR_INSUFFICIENTBUFFER               MAKE_WINCODECHR_ERR(0xf8C)
#define WINCODEC_ERR_DUPLICATEMETADATAPRESENT         MAKE_WINCODECHR_ERR(0xf8D)
#define WINCODEC_ERR_PROPERTYUNEXPECTEDTYPE           MAKE_WINCODECHR_ERR(0xf8E)
#define WINCODEC_ERR_UNEXPECTEDSIZE                   MAKE_WINCODECHR_ERR(0xf8F)
#define WINCODEC_ERR_INVALIDQUERYREQUEST              MAKE_WINCODECHR_ERR(0xf90)
#define WINCODEC_ERR_UNEXPECTEDMETADATATYPE           MAKE_WINCODECHR_ERR(0xf91)
#define WINCODEC_ERR_REQUESTONLYVALIDATMETADATAROOT   MAKE_WINCODECHR_ERR(0xf92)
#define WINCODEC_ERR_INVALIDQUERYCHARACTER            MAKE_WINCODECHR_ERR(0xf93)
#define WINCODEC_ERR_WIN32ERROR                       MAKE_WINCODECHR_ERR(0xf94)
#define WINCODEC_ERR_INVALIDPROGRESSIVELEVEL          MAKE_WINCODECHR_ERR(0xf95)
typedef /* [public] */ 
enum WICTiffCompressionOption
    {	WICTiffCompressionDontCare	= 0,
	WICTiffCompressionNone	= 0x1,
	WICTiffCompressionCCITT3	= 0x2,
	WICTiffCompressionCCITT4	= 0x3,
	WICTiffCompressionLZW	= 0x4,
	WICTiffCompressionRLE	= 0x5,
	WICTiffCompressionZIP	= 0x6,
	WICTiffCompressionLZWHDifferencing	= 0x7,
	WICTIFFCOMPRESSIONOPTION_FORCE_DWORD	= 0x7fffffff
    } 	WICTiffCompressionOption;

typedef /* [public] */ 
enum WICJpegYCrCbSubsamplingOption
    {	WICJpegYCrCbSubsamplingDefault	= 0,
	WICJpegYCrCbSubsampling420	= 0x1,
	WICJpegYCrCbSubsampling422	= 0x2,
	WICJpegYCrCbSubsampling444	= 0x3,
	WICJPEGYCRCBSUBSAMPLING_FORCE_DWORD	= 0x7fffffff
    } 	WICJpegYCrCbSubsamplingOption;

typedef /* [public] */ 
enum WICPngFilterOption
    {	WICPngFilterUnspecified	= 0,
	WICPngFilterNone	= 0x1,
	WICPngFilterSub	= 0x2,
	WICPngFilterUp	= 0x3,
	WICPngFilterAverage	= 0x4,
	WICPngFilterPaeth	= 0x5,
	WICPngFilterAdaptive	= 0x6,
	WICPNGFILTEROPTION_FORCE_DWORD	= 0x7fffffff
    } 	WICPngFilterOption;

typedef /* [public] */ 
enum WICNamedWhitePoint
    {	WICWhitePointDefault	= 0x1,
	WICWhitePointDaylight	= 0x2,
	WICWhitePointCloudy	= 0x4,
	WICWhitePointShade	= 0x8,
	WICWhitePointTungsten	= 0x10,
	WICWhitePointFluorescent	= 0x20,
	WICWhitePointFlash	= 0x40,
	WICWhitePointUnderwater	= 0x80,
	WICWhitePointCustom	= 0x100,
	WICWhitePointAutoWhiteBalance	= 0x200,
	WICWhitePointAsShot	= WICWhitePointDefault,
	WICNAMEDWHITEPOINT_FORCE_DWORD	= 0x7fffffff
    } 	WICNamedWhitePoint;

typedef /* [public] */ 
enum WICRawCapabilities
    {	WICRawCapabilityNotSupported	= 0,
	WICRawCapabilityGetSupported	= 0x1,
	WICRawCapabilityFullySupported	= 0x2,
	WICRAWCAPABILITIES_FORCE_DWORD	= 0x7fffffff
    } 	WICRawCapabilities;

typedef /* [public] */ 
enum WICRawRotationCapabilities
    {	WICRawRotationCapabilityNotSupported	= 0,
	WICRawRotationCapabilityGetSupported	= 0x1,
	WICRawRotationCapabilityNinetyDegreesSupported	= 0x2,
	WICRawRotationCapabilityFullySupported	= 0x3,
	WICRAWROTATIONCAPABILITIES_FORCE_DWORD	= 0x7fffffff
    } 	WICRawRotationCapabilities;

typedef /* [public] */ struct WICRawCapabilitiesInfo
    {
    UINT cbSize;
    UINT CodecMajorVersion;
    UINT CodecMinorVersion;
    WICRawCapabilities ExposureCompensationSupport;
    WICRawCapabilities ContrastSupport;
    WICRawCapabilities RGBWhitePointSupport;
    WICRawCapabilities NamedWhitePointSupport;
    UINT NamedWhitePointSupportMask;
    WICRawCapabilities KelvinWhitePointSupport;
    WICRawCapabilities GammaSupport;
    WICRawCapabilities TintSupport;
    WICRawCapabilities SaturationSupport;
    WICRawCapabilities SharpnessSupport;
    WICRawCapabilities NoiseReductionSupport;
    WICRawCapabilities DestinationColorProfileSupport;
    WICRawCapabilities ToneCurveSupport;
    WICRawRotationCapabilities RotationSupport;
    WICRawCapabilities RenderModeSupport;
    } 	WICRawCapabilitiesInfo;

typedef /* [public] */ 
enum WICRawParameterSet
    {	WICAsShotParameterSet	= 0x1,
	WICUserAdjustedParameterSet	= 0x2,
	WICAutoAdjustedParameterSet	= 0x3,
	WICRAWPARAMETERSET_FORCE_DWORD	= 0x7fffffff
    } 	WICRawParameterSet;

typedef /* [public] */ 
enum WICRawRenderMode
    {	WICRawRenderModeDraft	= 0x1,
	WICRawRenderModeNormal	= 0x2,
	WICRawRenderModeBestQuality	= 0x3,
	WICRAWRENDERMODE_FORCE_DWORD	= 0x7fffffff
    } 	WICRawRenderMode;

typedef /* [public] */ struct WICRawToneCurvePoint
    {
    double Input;
    double Output;
    } 	WICRawToneCurvePoint;

typedef /* [public] */ struct WICRawToneCurve
    {
    UINT cPoints;
    WICRawToneCurvePoint aPoints[ 1 ];
    } 	WICRawToneCurve;

#define WICRawChangeNotification_ExposureCompensation       0x00000001
#define WICRawChangeNotification_NamedWhitePoint            0x00000002
#define WICRawChangeNotification_KelvinWhitePoint           0x00000004
#define WICRawChangeNotification_RGBWhitePoint              0x00000008
#define WICRawChangeNotification_Contrast                   0x00000010
#define WICRawChangeNotification_Gamma                      0x00000020
#define WICRawChangeNotification_Sharpness                  0x00000040
#define WICRawChangeNotification_Saturation                 0x00000080
#define WICRawChangeNotification_Tint                       0x00000100
#define WICRawChangeNotification_NoiseReduction             0x00000200
#define WICRawChangeNotification_DestinationColorContext    0x00000400
#define WICRawChangeNotification_ToneCurve                  0x00000800
#define WICRawChangeNotification_Rotation                   0x00001000
#define WICRawChangeNotification_RenderMode                 0x00002000


extern RPC_IF_HANDLE __MIDL_itf_wincodec_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wincodec_0000_0031_v0_0_s_ifspec;

#ifndef __IWICDevelopRawNotificationCallback_INTERFACE_DEFINED__
#define __IWICDevelopRawNotificationCallback_INTERFACE_DEFINED__

/* interface IWICDevelopRawNotificationCallback */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICDevelopRawNotificationCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95c75a6e-3e8c-4ec2-85a8-aebcc551e59b")
    IWICDevelopRawNotificationCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ UINT NotificationMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICDevelopRawNotificationCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICDevelopRawNotificationCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICDevelopRawNotificationCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICDevelopRawNotificationCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            __RPC__in IWICDevelopRawNotificationCallback * This,
            /* [in] */ UINT NotificationMask);
        
        END_INTERFACE
    } IWICDevelopRawNotificationCallbackVtbl;

    interface IWICDevelopRawNotificationCallback
    {
        CONST_VTBL struct IWICDevelopRawNotificationCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICDevelopRawNotificationCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICDevelopRawNotificationCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICDevelopRawNotificationCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICDevelopRawNotificationCallback_Notify(This,NotificationMask)	\
    ( (This)->lpVtbl -> Notify(This,NotificationMask) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWICDevelopRawNotificationCallback_INTERFACE_DEFINED__ */


#ifndef __IWICDevelopRaw_INTERFACE_DEFINED__
#define __IWICDevelopRaw_INTERFACE_DEFINED__

/* interface IWICDevelopRaw */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWICDevelopRaw;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fbec5e44-f7be-4b65-b7f8-c0c81fef026d")
    IWICDevelopRaw : public IWICBitmapFrameDecode
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryRawCapabilitiesInfo( 
            /* [out][in] */ WICRawCapabilitiesInfo *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadParameterSet( 
            /* [in] */ WICRawParameterSet ParameterSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentParameterSet( 
            /* [out] */ __RPC__deref_out_opt IPropertyBag2 **ppCurrentParameterSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExposureCompensation( 
            /* [in] */ double ev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExposureCompensation( 
            /* [out] */ __RPC__out double *pEV) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWhitePointRGB( 
            /* [in] */ UINT Red,
            /* [in] */ UINT Green,
            /* [in] */ UINT Blue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWhitePointRGB( 
            /* [out] */ __RPC__out UINT *pRed,
            /* [out] */ __RPC__out UINT *pGreen,
            /* [out] */ __RPC__out UINT *pBlue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamedWhitePoint( 
            /* [in] */ WICNamedWhitePoint WhitePoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamedWhitePoint( 
            /* [out] */ __RPC__out WICNamedWhitePoint *pWhitePoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWhitePointKelvin( 
            /* [in] */ UINT WhitePointKelvin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWhitePointKelvin( 
            /* [out] */ __RPC__out UINT *pWhitePointKelvin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKelvinRangeInfo( 
            /* [out] */ __RPC__out UINT *pMinKelvinTemp,
            /* [out] */ __RPC__out UINT *pMaxKelvinTemp,
            /* [out] */ __RPC__out UINT *pKelvinTempStepValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContrast( 
            /* [in] */ double Contrast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContrast( 
            /* [out] */ __RPC__out double *pContrast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGamma( 
            /* [in] */ double Gamma) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGamma( 
            /* [out] */ __RPC__out double *pGamma) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSharpness( 
            /* [in] */ double Sharpness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSharpness( 
            /* [out] */ __RPC__out double *pSharpness) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSaturation( 
            /* [in] */ double Saturation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaturation( 
            /* [out] */ __RPC__out double *pSaturation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTint( 
            /* [in] */ double Tint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTint( 
            /* [out] */ __RPC__out double *pTint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoiseReduction( 
            /* [in] */ double NoiseReduction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNoiseReduction( 
            /* [out] */ __RPC__out double *pNoiseReduction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDestinationColorContext( 
            /* [unique][in] */ __RPC__in_opt IWICColorContext *pColorContext) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetToneCurve( 
            /* [in] */ UINT cbToneCurveSize,
            /* [annotation][in] */ 
            __in_bcount(cbToneCurveSize)  const WICRawToneCurve *pToneCurve) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetToneCurve( 
            /* [in] */ UINT cbToneCurveBufferSize,
            /* [annotation][unique][out] */ 
            __out_bcount_part_opt(cbToneCurveBufferSize, *pcbActualToneCurveBufferSize)  WICRawToneCurve *pToneCurve,
            /* [annotation][unique][out] */ 
            __inout_opt  UINT *pcbActualToneCurveBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRotation( 
            /* [in] */ double Rotation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRotation( 
            /* [out] */ __RPC__out double *pRotation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderMode( 
            /* [in] */ WICRawRenderMode RenderMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderMode( 
            /* [out] */ __RPC__out WICRawRenderMode *pRenderMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotificationCallback( 
            /* [unique][in] */ __RPC__in_opt IWICDevelopRawNotificationCallback *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWICDevelopRawVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWICDevelopRaw * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWICDevelopRaw * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out WICPixelFormatGUID *pPixelFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pDpiX,
            /* [out] */ __RPC__out double *pDpiY);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPalette )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ __RPC__in_opt IWICPalette *pIPalette);
        
        HRESULT ( STDMETHODCALLTYPE *CopyPixels )( 
            __RPC__in IWICDevelopRaw * This,
            /* [unique][in] */ __RPC__in_opt const WICRect *prc,
            /* [in] */ UINT cbStride,
            /* [in] */ UINT cbBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(cbBufferSize) BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadataQueryReader )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__deref_out_opt IWICMetadataQueryReader **ppIMetadataQueryReader);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorContexts )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ UINT cCount,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(cCount) IWICColorContext **ppIColorContexts,
            /* [out] */ __RPC__out UINT *pcActualCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetThumbnail )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__deref_out_opt IWICBitmapSource **ppIThumbnail);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryRawCapabilitiesInfo )( 
            IWICDevelopRaw * This,
            /* [out][in] */ WICRawCapabilitiesInfo *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *LoadParameterSet )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ WICRawParameterSet ParameterSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentParameterSet )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__deref_out_opt IPropertyBag2 **ppCurrentParameterSet);
        
        HRESULT ( STDMETHODCALLTYPE *SetExposureCompensation )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ double ev);
        
        HRESULT ( STDMETHODCALLTYPE *GetExposureCompensation )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pEV);
        
        HRESULT ( STDMETHODCALLTYPE *SetWhitePointRGB )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ UINT Red,
            /* [in] */ UINT Green,
            /* [in] */ UINT Blue);
        
        HRESULT ( STDMETHODCALLTYPE *GetWhitePointRGB )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out UINT *pRed,
            /* [out] */ __RPC__out UINT *pGreen,
            /* [out] */ __RPC__out UINT *pBlue);
        
        HRESULT ( STDMETHODCALLTYPE *SetNamedWhitePoint )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ WICNamedWhitePoint WhitePoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamedWhitePoint )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out WICNamedWhitePoint *pWhitePoint);
        
        HRESULT ( STDMETHODCALLTYPE *SetWhitePointKelvin )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ UINT WhitePointKelvin);
        
        HRESULT ( STDMETHODCALLTYPE *GetWhitePointKelvin )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out UINT *pWhitePointKelvin);
        
        HRESULT ( STDMETHODCALLTYPE *GetKelvinRangeInfo )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out UINT *pMinKelvinTemp,
            /* [out] */ __RPC__out UINT *pMaxKelvinTemp,
            /* [out] */ __RPC__out UINT *pKelvinTempStepValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetContrast )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ double Contrast);
        
        HRESULT ( STDMETHODCALLTYPE *GetContrast )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pContrast);
        
        HRESULT ( STDMETHODCALLTYPE *SetGamma )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ double Gamma);
        
        HRESULT ( STDMETHODCALLTYPE *GetGamma )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pGamma);
        
        HRESULT ( STDMETHODCALLTYPE *SetSharpness )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ double Sharpness);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharpness )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pSharpness);
        
        HRESULT ( STDMETHODCALLTYPE *SetSaturation )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ double Saturation);
        
        HRESULT ( STDMETHODCALLTYPE *GetSaturation )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pSaturation);
        
        HRESULT ( STDMETHODCALLTYPE *SetTint )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ double Tint);
        
        HRESULT ( STDMETHODCALLTYPE *GetTint )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pTint);
        
        HRESULT ( STDMETHODCALLTYPE *SetNoiseReduction )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ double NoiseReduction);
        
        HRESULT ( STDMETHODCALLTYPE *GetNoiseReduction )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pNoiseReduction);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestinationColorContext )( 
            __RPC__in IWICDevelopRaw * This,
            /* [unique][in] */ __RPC__in_opt IWICColorContext *pColorContext);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetToneCurve )( 
            IWICDevelopRaw * This,
            /* [in] */ UINT cbToneCurveSize,
            /* [annotation][in] */ 
            __in_bcount(cbToneCurveSize)  const WICRawToneCurve *pToneCurve);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetToneCurve )( 
            IWICDevelopRaw * This,
            /* [in] */ UINT cbToneCurveBufferSize,
            /* [annotation][unique][out] */ 
            __out_bcount_part_opt(cbToneCurveBufferSize, *pcbActualToneCurveBufferSize)  WICRawToneCurve *pToneCurve,
            /* [annotation][unique][out] */ 
            __inout_opt  UINT *pcbActualToneCurveBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetRotation )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ double Rotation);
        
        HRESULT ( STDMETHODCALLTYPE *GetRotation )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out double *pRotation);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderMode )( 
            __RPC__in IWICDevelopRaw * This,
            /* [in] */ WICRawRenderMode RenderMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderMode )( 
            __RPC__in IWICDevelopRaw * This,
            /* [out] */ __RPC__out WICRawRenderMode *pRenderMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotificationCallback )( 
            __RPC__in IWICDevelopRaw * This,
            /* [unique][in] */ __RPC__in_opt IWICDevelopRawNotificationCallback *pCallback);
        
        END_INTERFACE
    } IWICDevelopRawVtbl;

    interface IWICDevelopRaw
    {
        CONST_VTBL struct IWICDevelopRawVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWICDevelopRaw_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWICDevelopRaw_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWICDevelopRaw_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWICDevelopRaw_GetSize(This,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> GetSize(This,puiWidth,puiHeight) ) 

#define IWICDevelopRaw_GetPixelFormat(This,pPixelFormat)	\
    ( (This)->lpVtbl -> GetPixelFormat(This,pPixelFormat) ) 

#define IWICDevelopRaw_GetResolution(This,pDpiX,pDpiY)	\
    ( (This)->lpVtbl -> GetResolution(This,pDpiX,pDpiY) ) 

#define IWICDevelopRaw_CopyPalette(This,pIPalette)	\
    ( (This)->lpVtbl -> CopyPalette(This,pIPalette) ) 

#define IWICDevelopRaw_CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer)	\
    ( (This)->lpVtbl -> CopyPixels(This,prc,cbStride,cbBufferSize,pbBuffer) ) 


#define IWICDevelopRaw_GetMetadataQueryReader(This,ppIMetadataQueryReader)	\
    ( (This)->lpVtbl -> GetMetadataQueryReader(This,ppIMetadataQueryReader) ) 

#define IWICDevelopRaw_GetColorContexts(This,cCount,ppIColorContexts,pcActualCount)	\
    ( (This)->lpVtbl -> GetColorContexts(This,cCount,ppIColorContexts,pcActualCount) ) 

#define IWICDevelopRaw_GetThumbnail(This,ppIThumbnail)	\
    ( (This)->lpVtbl -> GetThumbnail(This,ppIThumbnail) ) 


#define IWICDevelopRaw_QueryRawCapabilitiesInfo(This,pInfo)	\
    ( (This)->lpVtbl -> QueryRawCapabilitiesInfo(This,pInfo) ) 

#define IWICDevelopRaw_LoadParameterSet(This,ParameterSet)	\
    ( (This)->lpVtbl -> LoadParameterSet(This,ParameterSet) ) 

#define IWICDevelopRaw_GetCurrentParameterSet(This,ppCurrentParameterSet)	\
    ( (This)->lpVtbl -> GetCurrentParameterSet(This,ppCurrentParameterSet) ) 

#define IWICDevelopRaw_SetExposureCompensation(This,ev)	\
    ( (This)->lpVtbl -> SetExposureCompensation(This,ev) ) 

#define IWICDevelopRaw_GetExposureCompensation(This,pEV)	\
    ( (This)->lpVtbl -> GetExposureCompensation(This,pEV) ) 

#define IWICDevelopRaw_SetWhitePointRGB(This,Red,Green,Blue)	\
    ( (This)->lpVtbl -> SetWhitePointRGB(This,Red,Green,Blue) ) 

#define IWICDevelopRaw_GetWhitePointRGB(This,pRed,pGreen,pBlue)	\
    ( (This)->lpVtbl -> GetWhitePointRGB(This,pRed,pGreen,pBlue) ) 

#define IWICDevelopRaw_SetNamedWhitePoint(This,WhitePoint)	\
    ( (This)->lpVtbl -> SetNamedWhitePoint(This,WhitePoint) ) 

#define IWICDevelopRaw_GetNamedWhitePoint(This,pWhitePoint)	\
    ( (This)->lpVtbl -> GetNamedWhitePoint(This,pWhitePoint) ) 

#define IWICDevelopRaw_SetWhitePointKelvin(This,WhitePointKelvin)	\
    ( (This)->lpVtbl -> SetWhitePointKelvin(This,WhitePointKelvin) ) 

#define IWICDevelopRaw_GetWhitePointKelvin(This,pWhitePointKelvin)	\
    ( (This)->lpVtbl -> GetWhitePointKelvin(This,pWhitePointKelvin) ) 

#define IWICDevelopRaw_GetKelvinRangeInfo(This,pMinKelvinTemp,pMaxKelvinTemp,pKelvinTempStepValue)	\
    ( (This)->lpVtbl -> GetKelvinRangeInfo(This,pMinKelvinTemp,pMaxKelvinTemp,pKelvinTempStepValue) ) 

#define IWICDevelopRaw_SetContrast(This,Contrast)	\
    ( (This)->lpVtbl -> SetContrast(This,Contrast) ) 

#define IWICDevelopRaw_GetContrast(This,pContrast)	\
    ( (This)->lpVtbl -> GetContrast(This,pContrast) ) 

#define IWICDevelopRaw_SetGamma(This,Gamma)	\
    ( (This)->lpVtbl -> SetGamma(This,Gamma) ) 

#define IWICDevelopRaw_GetGamma(This,pGamma)	\
    ( (This)->lpVtbl -> GetGamma(This,pGamma) ) 

#define IWICDevelopRaw_SetSharpness(This,Sharpness)	\
    ( (This)->lpVtbl -> SetSharpness(This,Sharpness) ) 

#define IWICDevelopRaw_GetSharpness(This,pSharpness)	\
    ( (This)->lpVtbl -> GetSharpness(This,pSharpness) ) 

#define IWICDevelopRaw_SetSaturation(This,Saturation)	\
    ( (This)->lpVtbl -> SetSaturation(This,Saturation) ) 

#define IWICDevelopRaw_GetSaturation(This,pSaturation)	\
    ( (This)->lpVtbl -> GetSaturation(This,pSaturation) ) 

#define IWICDevelopRaw_SetTint(This,Tint)	\
    ( (This)->lpVtbl -> SetTint(This,Tint) ) 

#define IWICDevelopRaw_GetTint(This,pTint)	\
    ( (This)->lpVtbl -> GetTint(This,pTint) ) 

#define IWICDevelopRaw_SetNoiseReduction(This,NoiseReduction)	\
    ( (This)->lpVtbl -> SetNoiseReduction(This,NoiseReduction) ) 

#define IWICDevelopRaw_GetNoiseReduction(This,pNoiseReduction)	\
    ( (This)->lpVtbl -> GetNoiseReduction(This,pNoiseReduction) ) 

#define IWICDevelopRaw_SetDestinationColorContext(This,pColorContext)	\
    ( (This)->lpVtbl -> SetDestinationColorContext(This,pColorContext) ) 

#define IWICDevelopRaw_SetToneCurve(This,cbToneCurveSize,pToneCurve)	\
    ( (This)->lpVtbl -> SetToneCurve(This,cbToneCurveSize,pToneCurve) ) 

#define IWICDevelopRaw_GetToneCurve(This,cbToneCurveBufferSize,pToneCurve,pcbActualToneCurveBufferSize)	\
    ( (This)->lpVtbl -> GetToneCurve(This,cbToneCurveBufferSize,pToneCurve,pcbActualToneCurveBufferSize) ) 

#define IWICDevelopRaw_SetRotation(This,Rotation)	\
    ( (This)->lpVtbl -> SetRotation(This,Rotation) ) 

#define IWICDevelopRaw_GetRotation(This,pRotation)	\
    ( (This)->lpVtbl -> GetRotation(This,pRotation) ) 

#define IWICDevelopRaw_SetRenderMode(This,RenderMode)	\
    ( (This)->lpVtbl -> SetRenderMode(This,RenderMode) ) 

#define IWICDevelopRaw_GetRenderMode(This,pRenderMode)	\
    ( (This)->lpVtbl -> GetRenderMode(This,pRenderMode) ) 

#define IWICDevelopRaw_SetNotificationCallback(This,pCallback)	\
    ( (This)->lpVtbl -> SetNotificationCallback(This,pCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_Remote_QueryRawCapabilitiesInfo_Proxy( 
    __RPC__in IWICDevelopRaw * This,
    /* [out][in] */ __RPC__inout WICRawCapabilitiesInfo *pInfo);


void __RPC_STUB IWICDevelopRaw_Remote_QueryRawCapabilitiesInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_Remote_SetToneCurve_Proxy( 
    __RPC__in IWICDevelopRaw * This,
    /* [in] */ UINT cPoints,
    /* [size_is][in] */ __RPC__in_ecount_full(cPoints) const WICRawToneCurvePoint *aPoints);


void __RPC_STUB IWICDevelopRaw_Remote_SetToneCurve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_Remote_GetToneCurve_Proxy( 
    __RPC__in IWICDevelopRaw * This,
    /* [out] */ __RPC__out UINT *pcPoints,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcPoints) WICRawToneCurvePoint **paPoints);


void __RPC_STUB IWICDevelopRaw_Remote_GetToneCurve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWICDevelopRaw_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     __RPC__in unsigned long *, __RPC__in HBITMAP * ); 

unsigned long             __RPC_USER  HICON_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HICON * ); 
void                      __RPC_USER  HICON_UserFree(     __RPC__in unsigned long *, __RPC__in HICON * ); 

unsigned long             __RPC_USER  HPALETTE_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HPALETTE * ); 
unsigned char * __RPC_USER  HPALETTE_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HPALETTE * ); 
unsigned char * __RPC_USER  HPALETTE_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HPALETTE * ); 
void                      __RPC_USER  HPALETTE_UserFree(     __RPC__in unsigned long *, __RPC__in HPALETTE * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  WICInProcPointer_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in WICInProcPointer * ); 
unsigned char * __RPC_USER  WICInProcPointer_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in WICInProcPointer * ); 
unsigned char * __RPC_USER  WICInProcPointer_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out WICInProcPointer * ); 
void                      __RPC_USER  WICInProcPointer_UserFree(     __RPC__in unsigned long *, __RPC__in WICInProcPointer * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IWICBitmapCodecProgressNotification_RegisterProgressNotification_Proxy( 
    IWICBitmapCodecProgressNotification * This,
    /* [annotation][unique][in] */ 
    __in_opt  PFNProgressNotification pfnProgressNotification,
    /* [annotation][unique][in] */ 
    __in_opt  LPVOID pvData,
    /* [in] */ DWORD dwProgressFlags);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICBitmapCodecProgressNotification_RegisterProgressNotification_Stub( 
    __RPC__in IWICBitmapCodecProgressNotification * This,
    /* [unique][in] */ __RPC__in_opt IWICProgressCallback *pICallback,
    /* [in] */ DWORD dwProgressFlags);

/* [local] */ HRESULT STDMETHODCALLTYPE IWICBitmapDecoderInfo_GetPatterns_Proxy( 
    IWICBitmapDecoderInfo * This,
    /* [in] */ UINT cbSizePatterns,
    /* [annotation][unique][size_is][out] */ 
    __out_bcount_part_opt(cbSizePatterns, *pcbPatternsActual)  WICBitmapPattern *pPatterns,
    /* [annotation][unique][out] */ 
    __inout_opt  UINT *pcPatterns,
    /* [annotation][out] */ 
    __inout_opt  UINT *pcbPatternsActual);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICBitmapDecoderInfo_GetPatterns_Stub( 
    __RPC__in IWICBitmapDecoderInfo * This,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcPatterns) WICBitmapPattern **ppPatterns,
    /* [out] */ __RPC__out UINT *pcPatterns);

/* [local] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_QueryRawCapabilitiesInfo_Proxy( 
    IWICDevelopRaw * This,
    /* [out][in] */ WICRawCapabilitiesInfo *pInfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_QueryRawCapabilitiesInfo_Stub( 
    __RPC__in IWICDevelopRaw * This,
    /* [out][in] */ __RPC__inout WICRawCapabilitiesInfo *pInfo);

/* [local] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_SetToneCurve_Proxy( 
    IWICDevelopRaw * This,
    /* [in] */ UINT cbToneCurveSize,
    /* [annotation][in] */ 
    __in_bcount(cbToneCurveSize)  const WICRawToneCurve *pToneCurve);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_SetToneCurve_Stub( 
    __RPC__in IWICDevelopRaw * This,
    /* [in] */ UINT cPoints,
    /* [size_is][in] */ __RPC__in_ecount_full(cPoints) const WICRawToneCurvePoint *aPoints);

/* [local] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_GetToneCurve_Proxy( 
    IWICDevelopRaw * This,
    /* [in] */ UINT cbToneCurveBufferSize,
    /* [annotation][unique][out] */ 
    __out_bcount_part_opt(cbToneCurveBufferSize, *pcbActualToneCurveBufferSize)  WICRawToneCurve *pToneCurve,
    /* [annotation][unique][out] */ 
    __inout_opt  UINT *pcbActualToneCurveBufferSize);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWICDevelopRaw_GetToneCurve_Stub( 
    __RPC__in IWICDevelopRaw * This,
    /* [out] */ __RPC__out UINT *pcPoints,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcPoints) WICRawToneCurvePoint **paPoints);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\wincred.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wincred.h

Abstract:

    This module contains the public data structures and API definitions
    needed for the Credential Manager.


Author:


Revision History:

--*/

#ifndef _WINCRED_H_
#define _WINCRED_H_

#if !defined(_ADVAPI32_)
#define WINADVAPI    DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif

#if !defined(CREDUIAPI)
#if !defined(_CREDUI_)
#define CREDUIAPI    EXTERN_C DECLSPEC_IMPORT
#else
#define CREDUIAPI    EXTERN_C
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// Ensure PCtxtHandle is defined
//

#ifndef __SECHANDLE_DEFINED__
typedef struct _SecHandle
{
    ULONG_PTR dwLower ;
    ULONG_PTR dwUpper ;
} SecHandle, * PSecHandle ;

#define __SECHANDLE_DEFINED__
#endif // __SECHANDLE_DEFINED__

typedef PSecHandle PCtxtHandle;



//
// Ensure FILETIME is defined
//

#ifndef _WINBASE_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct _FILETIME
    {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
    }   FILETIME;

typedef struct _FILETIME *PFILETIME;

typedef struct _FILETIME *LPFILETIME;

#endif // !_FILETIME
#endif // _WINBASE_

//
// Ensure NTSTATUS is defined
//
#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif


//-----------------------------------------------------------------------------
// Macros
//-----------------------------------------------------------------------------

//
// Macro to determine whether CredUIPromptForCredentials should be called upon a failed
//      authentication attempt.
//
// Implemented as a macro so that the caller can delay load credui.dll only if this
//      macro returns TRUE.
//
// Include only status codes that imply the username/password are wrong or that the
//      password is expired.  In the former case, asking for a another username or password
//      is appropriate.  In the later case, we put up a different dialog asking the
//      user to change the password on the server.
//
// Don't include status codes such as ERROR_ACCOUNT_DISABLED, ERROR_ACCOUNT_RESTRICTION,
//      ERROR_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_EXPIRED, ERROR_LOGON_TYPE_NOT_GRANTED.
//      For those, the user isn't going to have another account so prompting him
//      won't help.
//
// STATUS_DOWNGRADE_DETECTED is included to handle the case where a corporate laptop
//      is brought to another LAN.  A downgrade attack will indeed be detected,
//      but we want to popup UI to allow the user to connect to resources in the
//      other LAN.
//
// Don't use the CREDUIP_* macros directly.  Their definition is private to credui.dll.
//

// Don't require ntstatus.h
#define STATUS_LOGON_FAILURE             ((NTSTATUS)0xC000006DL)     // ntsubauth
#define STATUS_WRONG_PASSWORD            ((NTSTATUS)0xC000006AL)     // ntsubauth
#define STATUS_PASSWORD_EXPIRED          ((NTSTATUS)0xC0000071L)     // ntsubauth
#define STATUS_PASSWORD_MUST_CHANGE      ((NTSTATUS)0xC0000224L)    // ntsubauth
#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)
#define STATUS_DOWNGRADE_DETECTED        ((NTSTATUS)0xC0000388L)
#define STATUS_AUTHENTICATION_FIREWALL_FAILED ((NTSTATUS)0xC0000413L)
#define STATUS_ACCOUNT_DISABLED          ((NTSTATUS)0xC0000072L)     // ntsubauth
#define STATUS_ACCOUNT_RESTRICTION       ((NTSTATUS)0xC000006EL)     // ntsubauth
#define STATUS_ACCOUNT_LOCKED_OUT        ((NTSTATUS)0xC0000234L)    // ntsubauth
#define STATUS_ACCOUNT_EXPIRED           ((NTSTATUS)0xC0000193L)    // ntsubauth
#define STATUS_LOGON_TYPE_NOT_GRANTED    ((NTSTATUS)0xC000015BL)

// Don't require lmerr.h
#define NERR_BASE       2100
#define NERR_PasswordExpired    (NERR_BASE+142) /* The password of this user has expired. */

#define CREDUIP_IS_USER_PASSWORD_ERROR( _Status ) ( \
        (_Status) == ERROR_LOGON_FAILURE || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE ) || \
        (_Status) == STATUS_LOGON_FAILURE || \
        (_Status) == HRESULT_FROM_NT( STATUS_LOGON_FAILURE ) || \
        (_Status) == ERROR_ACCESS_DENIED || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) || \
        (_Status) == STATUS_ACCESS_DENIED || \
        (_Status) == HRESULT_FROM_NT( STATUS_ACCESS_DENIED ) || \
        (_Status) == ERROR_INVALID_PASSWORD || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_INVALID_PASSWORD ) || \
        (_Status) == STATUS_WRONG_PASSWORD || \
        (_Status) == HRESULT_FROM_NT( STATUS_WRONG_PASSWORD ) || \
        (_Status) == SEC_E_NO_CREDENTIALS || \
        (_Status) == SEC_E_LOGON_DENIED || \
        (_Status) == SEC_E_NO_CONTEXT || \
        (_Status) == STATUS_NO_SECURITY_CONTEXT )

#define CREDUIP_IS_DOWNGRADE_ERROR( _Status ) ( \
        (_Status) == ERROR_DOWNGRADE_DETECTED || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_DOWNGRADE_DETECTED ) || \
        (_Status) == STATUS_DOWNGRADE_DETECTED || \
        (_Status) == HRESULT_FROM_NT( STATUS_DOWNGRADE_DETECTED ) \
)

#define CREDUIP_IS_EXPIRED_ERROR( _Status ) ( \
        (_Status) == ERROR_PASSWORD_EXPIRED || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_PASSWORD_EXPIRED ) || \
        (_Status) == STATUS_PASSWORD_EXPIRED || \
        (_Status) == HRESULT_FROM_NT( STATUS_PASSWORD_EXPIRED ) || \
        (_Status) == ERROR_PASSWORD_MUST_CHANGE || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_PASSWORD_MUST_CHANGE ) || \
        (_Status) == STATUS_PASSWORD_MUST_CHANGE || \
        (_Status) == HRESULT_FROM_NT( STATUS_PASSWORD_MUST_CHANGE ) || \
        (_Status) == NERR_PasswordExpired || \
        (_Status) == __HRESULT_FROM_WIN32( NERR_PasswordExpired ) \
)

#define CREDUI_IS_AUTHENTICATION_ERROR( _Status ) ( \
        CREDUIP_IS_USER_PASSWORD_ERROR( _Status ) || \
        CREDUIP_IS_DOWNGRADE_ERROR( _Status ) || \
        CREDUIP_IS_EXPIRED_ERROR( _Status ) \
)

#define CREDUI_NO_PROMPT_AUTHENTICATION_ERROR( _Status ) ( \
        (_Status) == ERROR_AUTHENTICATION_FIREWALL_FAILED || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_AUTHENTICATION_FIREWALL_FAILED ) || \
        (_Status) == STATUS_AUTHENTICATION_FIREWALL_FAILED || \
        (_Status) == HRESULT_FROM_NT( STATUS_AUTHENTICATION_FIREWALL_FAILED ) || \
        (_Status) == ERROR_ACCOUNT_DISABLED || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_ACCOUNT_DISABLED ) || \
        (_Status) == STATUS_ACCOUNT_DISABLED || \
        (_Status) == HRESULT_FROM_NT( STATUS_ACCOUNT_DISABLED ) || \
        (_Status) == ERROR_ACCOUNT_RESTRICTION || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_ACCOUNT_RESTRICTION ) || \
        (_Status) == STATUS_ACCOUNT_RESTRICTION || \
        (_Status) == HRESULT_FROM_NT( STATUS_ACCOUNT_RESTRICTION ) || \
        (_Status) == ERROR_ACCOUNT_LOCKED_OUT || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_ACCOUNT_LOCKED_OUT ) || \
        (_Status) == STATUS_ACCOUNT_LOCKED_OUT || \
        (_Status) == HRESULT_FROM_NT( STATUS_ACCOUNT_LOCKED_OUT ) || \
        (_Status) == ERROR_ACCOUNT_EXPIRED || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_ACCOUNT_EXPIRED ) || \
        (_Status) == STATUS_ACCOUNT_EXPIRED || \
        (_Status) == HRESULT_FROM_NT( STATUS_ACCOUNT_EXPIRED ) || \
        (_Status) == ERROR_LOGON_TYPE_NOT_GRANTED || \
        (_Status) == __HRESULT_FROM_WIN32( ERROR_LOGON_TYPE_NOT_GRANTED ) || \
        (_Status) == STATUS_LOGON_TYPE_NOT_GRANTED || \
        (_Status) == HRESULT_FROM_NT( STATUS_LOGON_TYPE_NOT_GRANTED ) \
)

//-----------------------------------------------------------------------------
// Structures
//-----------------------------------------------------------------------------

//
// Credential Attribute
//

// Maximum length of the various credential string fields (in characters)
#define CRED_MAX_STRING_LENGTH 256

// Maximum length of the UserName field.  The worst case is <User>@<DnsDomain>
#define CRED_MAX_USERNAME_LENGTH (256+1+256)

// Maximum length of the TargetName field for CRED_TYPE_GENERIC (in characters)
#define CRED_MAX_GENERIC_TARGET_NAME_LENGTH 32767

// Maximum length of the TargetName field for CRED_TYPE_DOMAIN_* (in characters)
//      Largest one is <DfsRoot>\<DfsShare>
#define CRED_MAX_DOMAIN_TARGET_NAME_LENGTH (256+1+80)

// Maximum length of a target namespace
#define CRED_MAX_TARGETNAME_NAMESPACE_LENGTH (256)

// Maximum length of a target attribute
#define CRED_MAX_TARGETNAME_ATTRIBUTE_LENGTH (256)

// Maximum size of the Credential Attribute Value field (in bytes)
#define CRED_MAX_VALUE_SIZE (256)

// Maximum number of attributes per credential
#define CRED_MAX_ATTRIBUTES 64

typedef struct _CREDENTIAL_ATTRIBUTEA {
    LPSTR Keyword;
    DWORD Flags;
    DWORD ValueSize;
    LPBYTE Value;
} CREDENTIAL_ATTRIBUTEA, *PCREDENTIAL_ATTRIBUTEA;

typedef struct _CREDENTIAL_ATTRIBUTEW {
#ifdef MIDL_PASS
    [string] wchar_t * Keyword;
#else // MIDL_PASS
    LPWSTR  Keyword;
#endif // MIDL_PASS
    DWORD Flags;
#ifdef MIDL_PASS
    [range(0,CRED_MAX_VALUE_SIZE)]
#endif // MIDL_PASS
    DWORD ValueSize;
#ifdef MIDL_PASS
    [size_is(ValueSize)]
#endif // MIDL_PASS
    LPBYTE Value;
} CREDENTIAL_ATTRIBUTEW, *PCREDENTIAL_ATTRIBUTEW;

#ifdef UNICODE
typedef CREDENTIAL_ATTRIBUTEW CREDENTIAL_ATTRIBUTE;
typedef PCREDENTIAL_ATTRIBUTEW PCREDENTIAL_ATTRIBUTE;
#else
typedef CREDENTIAL_ATTRIBUTEA CREDENTIAL_ATTRIBUTE;
typedef PCREDENTIAL_ATTRIBUTEA PCREDENTIAL_ATTRIBUTE;
#endif // UNICODE

//
// Special values of the TargetName field
//
#define CRED_SESSION_WILDCARD_NAME_W L"*Session"
#define CRED_SESSION_WILDCARD_NAME_A "*Session"
#define CRED_UNIVERSAL_WILDCARD_W L'*'
#define CRED_UNIVERSAL_WILDCARD_A '*'
#define CRED_SESSION_WILDCARD_NAME_LENGTH (sizeof(CRED_SESSION_WILDCARD_NAME_A)-1)
#define CRED_TARGETNAME_DOMAIN_NAMESPACE_W L"Domain"
#define CRED_TARGETNAME_DOMAIN_NAMESPACE_A "Domain"
#define CRED_TARGETNAME_DOMAIN_NAMESPACE_LENGTH (sizeof(CRED_TARGETNAME_DOMAIN_NAMESPACE_A)-1)
#define CRED_UNIVERSAL_WILDCARD_W L'*'
#define CRED_UNIVERSAL_WILDCARD_A '*'
#define CRED_TARGETNAME_LEGACYGENERIC_NAMESPACE_W L"LegacyGeneric"
#define CRED_TARGETNAME_LEGACYGENERIC_NAMESPACE_A "LegacyGeneric"
#define CRED_TARGETNAME_LEGACYGENERIC_NAMESPACE_LENGTH (sizeof(CRED_TARGETNAME_LEGACYGENERIC_NAMESPACE_A)-1)
#define CRED_TARGETNAME_NAMESPACE_SEPERATOR_W L':'
#define CRED_TARGETNAME_NAMESPACE_SEPERATOR_A ':'
#define CRED_TARGETNAME_ATTRIBUTE_SEPERATOR_W L'='
#define CRED_TARGETNAME_ATTRIBUTE_SEPERATOR_A '='
#define CRED_TARGETNAME_DOMAIN_EXTENDED_USERNAME_SEPARATOR_W L'|'
#define CRED_TARGETNAME_DOMAIN_EXTENDED_USERNAME_SEPARATOR_A '|'
#define CRED_TARGETNAME_ATTRIBUTE_TARGET_W L"target"
#define CRED_TARGETNAME_ATTRIBUTE_TARGET_A "target"
#define CRED_TARGETNAME_ATTRIBUTE_TARGET_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_TARGET_A)-1)
#define CRED_TARGETNAME_ATTRIBUTE_NAME_W L"name"
#define CRED_TARGETNAME_ATTRIBUTE_NAME_A "name"
#define CRED_TARGETNAME_ATTRIBUTE_NAME_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_NAME_A)-1)
#define CRED_TARGETNAME_ATTRIBUTE_BATCH_W L"batch"
#define CRED_TARGETNAME_ATTRIBUTE_BATCH_A "batch"
#define CRED_TARGETNAME_ATTRIBUTE_BATCH_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_BATCH_A)-1)
#define CRED_TARGETNAME_ATTRIBUTE_INTERACTIVE_W L"interactive"
#define CRED_TARGETNAME_ATTRIBUTE_INTERACTIVE_A "interactive"
#define CRED_TARGETNAME_ATTRIBUTE_INTERACTIVE_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_INTERACTIVE_A)-1)
#define CRED_TARGETNAME_ATTRIBUTE_SERVICE_W L"service"
#define CRED_TARGETNAME_ATTRIBUTE_SERVICE_A "service"
#define CRED_TARGETNAME_ATTRIBUTE_SERVICE_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_SERVICE_A)-1)
#define CRED_TARGETNAME_ATTRIBUTE_NETWORK_W L"network"
#define CRED_TARGETNAME_ATTRIBUTE_NETWORK_A "network"
#define CRED_TARGETNAME_ATTRIBUTE_NETWORK_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_NETWORK_A)-1)
#define CRED_TARGETNAME_ATTRIBUTE_NETWORKCLEARTEXT_W L"networkcleartext"
#define CRED_TARGETNAME_ATTRIBUTE_NETWORKCLEARTEXT_A "networkcleartext"
#define CRED_TARGETNAME_ATTRIBUTE_NETWORKCLEARTEXT_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_NETWORKCLEARTEXT_A)-1)
#define CRED_TARGETNAME_ATTRIBUTE_REMOTEINTERACTIVE_W L"remoteinteractive"
#define CRED_TARGETNAME_ATTRIBUTE_REMOTEINTERACTIVE_A "remoteinteractive"
#define CRED_TARGETNAME_ATTRIBUTE_REMOTEINTERACTIVE_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_REMOTEINTERACTIVE_A)-1)
#define CRED_TARGETNAME_ATTRIBUTE_CACHEDINTERACTIVE_W L"cachedinteractive"
#define CRED_TARGETNAME_ATTRIBUTE_CACHEDINTERACTIVE_A "cachedinteractive"
#define CRED_TARGETNAME_ATTRIBUTE_CACHEDINTERACTIVE_LENGTH (sizeof(CRED_TARGETNAME_ATTRIBUTE_CACHEDINTERACTIVE_A)-1)

#ifdef UNICODE
#define CRED_SESSION_WILDCARD_NAME CRED_SESSION_WILDCARD_NAME_W
#define CRED_TARGETNAME_DOMAIN_NAMESPACE CRED_TARGETNAME_DOMAIN_NAMESPACE_W
#define CRED_UNIVERSAL_WILDCARD = CRED_UNIVERSAL_WILDCARD_W
#define CRED_TARGETNAME_NAMESPACE_SEPERATOR = CRED_TARGETNAME_NAMESPACE_SEPERATOR_W
#define CRED_TARGETNAME_ATTRIBUTE_SEPERATOR = CRED_TARGETNAME_ATTRIBUTE_SEPERATOR_W
#define CRED_TARGETNAME_ATTRIBUTE_NAME CRED_TARGETNAME_ATTRIBUTE_NAME_W
#define CRED_TARGETNAME_ATTRIBUTE_TARGET CRED_TARGETNAME_ATTRIBUTE_TARGET_W
#define CRED_TARGETNAME_ATTRIBUTE_BATCH CRED_TARGETNAME_ATTRIBUTE_BATCH_W
#define CRED_TARGETNAME_ATTRIBUTE_INTERACTIVE CRED_TARGETNAME_ATTRIBUTE_INTERACTIVE_W
#define CRED_TARGETNAME_ATTRIBUTE_SERVICE CRED_TARGETNAME_ATTRIBUTE_SERVICE_W
#define CRED_TARGETNAME_ATTRIBUTE_NETWORK CRED_TARGETNAME_ATTRIBUTE_NETWORK_W
#define CRED_TARGETNAME_ATTRIBUTE_NETWORKCLEARTEXT CRED_TARGETNAME_ATTRIBUTE_NETWORKCLEARTEXT_W
#define CRED_TARGETNAME_ATTRIBUTE_REMOTEINTERACTIVE CRED_TARGETNAME_ATTRIBUTE_REMOTEINTERACTIVE_W
#define CRED_TARGETNAME_ATTRIBUTE_CACHEDINTERACTIVE CRED_TARGETNAME_ATTRIBUTE_CACHEDINTERACTIVE_W

#else
#define CRED_SESSION_WILDCARD_NAME CRED_SESSION_WILDCARD_NAME_A
#define CRED_TARGETNAME_DOMAIN_NAMESPACE CRED_TARGETNAME_DOMAIN_NAMESPACE_A
#define CRED_UNIVERSAL_WILDCARD = CRED_UNIVERSAL_WILDCARD_A
#define CRED_TARGETNAME_NAMESPACE_SEPERATOR = CRED_TARGETNAME_NAMESPACE_SEPERATOR_A
#define CRED_TARGETNAME_ATTRIBUTE_SEPERATOR = CRED_TARGETNAME_ATTRIBUTE_SEPERATOR_A
#define CRED_TARGETNAME_ATTRIBUTE_NAME CRED_TARGETNAME_ATTRIBUTE_NAME_A
#define CRED_TARGETNAME_ATTRIBUTE_TARGET CRED_TARGETNAME_ATTRIBUTE_TARGET_A
#define CRED_TARGETNAME_ATTRIBUTE_BATCH CRED_TARGETNAME_ATTRIBUTE_BATCH_A
#define CRED_TARGETNAME_ATTRIBUTE_INTERACTIVE CRED_TARGETNAME_ATTRIBUTE_INTERACTIVE_A
#define CRED_TARGETNAME_ATTRIBUTE_SERVICE CRED_TARGETNAME_ATTRIBUTE_SERVICE_A
#define CRED_TARGETNAME_ATTRIBUTE_NETWORK CRED_TARGETNAME_ATTRIBUTE_NETWORK_A
#define CRED_TARGETNAME_ATTRIBUTE_NETWORKCLEARTEXT CRED_TARGETNAME_ATTRIBUTE_NETWORKCLEARTEXT_A
#define CRED_TARGETNAME_ATTRIBUTE_REMOTEINTERACTIVE CRED_TARGETNAME_ATTRIBUTE_REMOTEINTERACTIVE_A
#define CRED_TARGETNAME_ATTRIBUTE_CACHEDINTERACTIVE CRED_TARGETNAME_ATTRIBUTE_CACHEDINTERACTIVE_A
#endif // UNICODE


//
// Add\Extract Logon type from flags
//
#define CRED_LOGON_TYPES_MASK             0xF000  // Mask to get logon types

#define CredAppendLogonTypeToFlags(Flags, LogonType)      (Flags) |= ((LogonType) << 12)
#define CredGetLogonTypeFromFlags(Flags)                  ((SECURITY_LOGON_TYPE)(((Flags) & CRED_LOGON_TYPES_MASK) >> 12))
#define CredRemoveLogonTypeFromFlags(Flags)               (Flags) &= ~CRED_LOGON_TYPES_MASK

//
// Values of the Credential Flags field.
//
#define CRED_FLAGS_PASSWORD_FOR_CERT    0x0001
#define CRED_FLAGS_PROMPT_NOW           0x0002
#define CRED_FLAGS_USERNAME_TARGET      0x0004
#define CRED_FLAGS_OWF_CRED_BLOB        0x0008
#define CRED_FLAGS_REQUIRE_CONFIRMATION 0x0010

//
//  Valid only for return and only with CredReadDomainCredentials().
//  Indicates credential was returned due to wildcard match
//  of targetname with credential.
//

#define CRED_FLAGS_WILDCARD_MATCH       0x0020
#define CRED_FLAGS_VALID_FLAGS          0xF03F  // Mask of all valid flags

//
//  Bit mask for only those flags which can be passed to the credman
//  APIs.
//

#define CRED_FLAGS_VALID_INPUT_FLAGS    0xF01F

//
// Values of the Credential Type field.
//
#define CRED_TYPE_GENERIC               1
#define CRED_TYPE_DOMAIN_PASSWORD       2
#define CRED_TYPE_DOMAIN_CERTIFICATE    3
#define CRED_TYPE_DOMAIN_VISIBLE_PASSWORD 4
#define CRED_TYPE_GENERIC_CERTIFICATE   5
#define CRED_TYPE_DOMAIN_EXTENDED       6
#define CRED_TYPE_MAXIMUM               7       // Maximum supported cred type
#define CRED_TYPE_MAXIMUM_EX  (CRED_TYPE_MAXIMUM+1000)  // Allow new applications to run on old OSes

//
// Maximum size of the CredBlob field (in bytes)
//

#define CRED_MAX_CREDENTIAL_BLOB_SIZE   (5*512)

//
// Values of the Credential Persist field
//
#define CRED_PERSIST_NONE               0
#define CRED_PERSIST_SESSION            1
#define CRED_PERSIST_LOCAL_MACHINE      2
#define CRED_PERSIST_ENTERPRISE         3



//
// A credential
//
typedef struct _CREDENTIALA {
    DWORD Flags;
    DWORD Type;
    LPSTR TargetName;
    LPSTR Comment;
    FILETIME LastWritten;
    DWORD CredentialBlobSize;
    __field_bcount(CredentialBlobSize) LPBYTE CredentialBlob;
    DWORD Persist;
    DWORD AttributeCount;
    PCREDENTIAL_ATTRIBUTEA Attributes;
    LPSTR TargetAlias;
    LPSTR UserName;
} CREDENTIALA, *PCREDENTIALA;

typedef struct _CREDENTIALW {
    DWORD Flags;
    DWORD Type;
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_GENERIC_TARGET_NAME_LENGTH-1)] wchar_t *TargetName;
#else // MIDL_PASS
    LPWSTR TargetName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_STRING_LENGTH-1)] wchar_t *Comment;
#else // MIDL_PASS
    LPWSTR Comment;
#endif // MIDL_PASS
    FILETIME LastWritten;
#ifdef MIDL_PASS
    [range(0,CRED_MAX_CREDENTIAL_BLOB_SIZE)]
#endif // MIDL_PASS
    DWORD CredentialBlobSize;
#ifdef MIDL_PASS
    [size_is(CredentialBlobSize)]
#endif // MIDL_PASS
    LPBYTE CredentialBlob;
    DWORD Persist;
#ifdef MIDL_PASS
    [range(0,CRED_MAX_ATTRIBUTES)]
#endif // MIDL_PASS
    DWORD AttributeCount;
#ifdef MIDL_PASS
    [size_is(AttributeCount)]
#endif // MIDL_PASS
    PCREDENTIAL_ATTRIBUTEW Attributes;
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_STRING_LENGTH-1)] wchar_t *TargetAlias;
#else // MIDL_PASS
    LPWSTR TargetAlias;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_USERNAME_LENGTH-1)] wchar_t *UserName;
#else // MIDL_PASS
    LPWSTR UserName;
#endif // MIDL_PASS
} CREDENTIALW, *PCREDENTIALW;

#ifdef UNICODE
typedef CREDENTIALW CREDENTIAL;
typedef PCREDENTIALW PCREDENTIAL;
#else
typedef CREDENTIALA CREDENTIAL;
typedef PCREDENTIALA PCREDENTIAL;
#endif // UNICODE

//
// Value of the Flags field in CREDENTIAL_TARGET_INFORMATION
//

#define CRED_TI_SERVER_FORMAT_UNKNOWN   0x0001  // Don't know if server name is DNS or netbios format
#define CRED_TI_DOMAIN_FORMAT_UNKNOWN   0x0002  // Don't know if domain name is DNS or netbios format
#define CRED_TI_ONLY_PASSWORD_REQUIRED  0x0004  // Server only requires a password and not a username
#define CRED_TI_USERNAME_TARGET         0x0008  // TargetName is username
#define CRED_TI_CREATE_EXPLICIT_CRED    0x0010  // When creating a cred, create one named TargetInfo->TargetName
#define CRED_TI_WORKGROUP_MEMBER        0x0020  // Indicates the machine is a member of a workgroup
#define CRED_TI_VALID_FLAGS             0xF07F


//
// A credential target
//

typedef struct _CREDENTIAL_TARGET_INFORMATIONA {
    LPSTR TargetName;
    LPSTR NetbiosServerName;
    LPSTR DnsServerName;
    LPSTR NetbiosDomainName;
    LPSTR DnsDomainName;
    LPSTR DnsTreeName;
    LPSTR PackageName;
    ULONG Flags;
    DWORD CredTypeCount;
    LPDWORD CredTypes;
} CREDENTIAL_TARGET_INFORMATIONA, *PCREDENTIAL_TARGET_INFORMATIONA;

typedef struct _CREDENTIAL_TARGET_INFORMATIONW {
#ifdef MIDL_PASS
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *TargetName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *NetbiosServerName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *DnsServerName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *NetbiosDomainName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *DnsDomainName;
    [string,max_is(CRED_MAX_DOMAIN_TARGET_NAME_LENGTH-1)] wchar_t *DnsTreeName;
    [string,max_is(CRED_MAX_STRING_LENGTH-1)] wchar_t *PackageName;
#else // MIDL_PASS
    LPWSTR TargetName;
    LPWSTR NetbiosServerName;
    LPWSTR DnsServerName;
    LPWSTR NetbiosDomainName;
    LPWSTR DnsDomainName;
    LPWSTR DnsTreeName;
    LPWSTR PackageName;
#endif // MIDL_PASS
    ULONG Flags;
#ifdef MIDL_PASS
    [range(0,CRED_TYPE_MAXIMUM_EX)]
#endif // MIDL_PASS
    DWORD CredTypeCount;
#ifdef MIDL_PASS
    [size_is(CredTypeCount)]
#endif // MIDL_PASS
    LPDWORD CredTypes;
} CREDENTIAL_TARGET_INFORMATIONW, *PCREDENTIAL_TARGET_INFORMATIONW;

#ifdef UNICODE
typedef CREDENTIAL_TARGET_INFORMATIONW CREDENTIAL_TARGET_INFORMATION;
typedef PCREDENTIAL_TARGET_INFORMATIONW PCREDENTIAL_TARGET_INFORMATION;
#else
typedef CREDENTIAL_TARGET_INFORMATIONA CREDENTIAL_TARGET_INFORMATION;
typedef PCREDENTIAL_TARGET_INFORMATIONA PCREDENTIAL_TARGET_INFORMATION;
#endif // UNICODE

//
// Certificate credential information
//
// The cbSize should be the size of the structure, sizeof(CERT_CREDENTIAL_INFO),
// rgbHashofCert is the hash of the cert which is to be used as the credential.
//

#define CERT_HASH_LENGTH        20  // SHA1 hashes are used for cert hashes

typedef struct _CERT_CREDENTIAL_INFO {
    ULONG cbSize;
    UCHAR rgbHashOfCert[CERT_HASH_LENGTH];
} CERT_CREDENTIAL_INFO, *PCERT_CREDENTIAL_INFO;

//
// Username Target credential information
//
// This credential can be pass to LsaLogonUser to ask it to find a credential with a
// TargetName of UserName.
//

typedef struct _USERNAME_TARGET_CREDENTIAL_INFO {
    LPWSTR UserName;
} USERNAME_TARGET_CREDENTIAL_INFO, *PUSERNAME_TARGET_CREDENTIAL_INFO;

//
// Marshaled credential blob information.
//

typedef struct _BINARY_BLOB_CREDENTIAL_INFO {
    ULONG cbBlob;
    LPBYTE pbBlob;
} BINARY_BLOB_CREDENTIAL_INFO, *PBINARY_BLOB_CREDENTIAL_INFO;

//
// Credential type for credential marshaling routines
//

typedef enum _CRED_MARSHAL_TYPE {
    CertCredential = 1,
    UsernameTargetCredential,
    BinaryBlobCredential,
    UsernameForPackedCredentials,  // internal only, reserved
} CRED_MARSHAL_TYPE, *PCRED_MARSHAL_TYPE;

//
// Protection type for credential providers secret protection routines
//

typedef enum _CRED_PROTECTION_TYPE {
    CredUnprotected,
    CredUserProtection,
    CredTrustedProtection
} CRED_PROTECTION_TYPE, *PCRED_PROTECTION_TYPE;

//
// Values for authentication buffers packing
//
#define CRED_PACK_PROTECTED_CREDENTIALS      0x1
#define CRED_PACK_WOW_BUFFER                 0x2
#define CRED_PACK_GENERIC_CREDENTIALS        0x4

//
// Credential UI info
//

#define _CREDUI_INFO_DEFINED

typedef struct _CREDUI_INFOA
{
    DWORD cbSize;
    HWND hwndParent;
    PCSTR pszMessageText;
    PCSTR pszCaptionText;
    HBITMAP hbmBanner;
} CREDUI_INFOA, *PCREDUI_INFOA;

typedef struct _CREDUI_INFOW
{
    DWORD cbSize;
    HWND hwndParent;
    PCWSTR pszMessageText;
    PCWSTR pszCaptionText;
    HBITMAP hbmBanner;
} CREDUI_INFOW, *PCREDUI_INFOW;

#ifdef UNICODE
typedef CREDUI_INFOW CREDUI_INFO;
typedef PCREDUI_INFOW PCREDUI_INFO;
#else
typedef CREDUI_INFOA CREDUI_INFO;
typedef PCREDUI_INFOA PCREDUI_INFO;
#endif

//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------

// String length limits:

#define CREDUI_MAX_MESSAGE_LENGTH           32767
#define CREDUI_MAX_CAPTION_LENGTH           128
#define CREDUI_MAX_GENERIC_TARGET_LENGTH    CRED_MAX_GENERIC_TARGET_NAME_LENGTH
#define CREDUI_MAX_DOMAIN_TARGET_LENGTH     CRED_MAX_DOMAIN_TARGET_NAME_LENGTH

//
//  Username can be in <domain>\<user> or <user>@<domain>
//  Length in characters, not including NULL termination.
//

#define CREDUI_MAX_USERNAME_LENGTH          CRED_MAX_USERNAME_LENGTH
#define CREDUI_MAX_PASSWORD_LENGTH          (512 / 2)

//
//  Packed credential returned by SspiEncodeAuthIdentityAsStrings().
//  Length in characters, not including NULL termination.
//

#define CREDUI_MAX_PACKED_CREDENTIALS_LENGTH    ((MAXUSHORT / 2) - 2)

// maximum length in bytes for binary credential blobs

#define CREDUI_MAX_CREDENTIALS_BLOB_SIZE        (MAXUSHORT)

//
// Flags for CredUIPromptForCredentials and/or CredUICmdLinePromptForCredentials
//

#define CREDUI_FLAGS_INCORRECT_PASSWORD     0x00001     // indicates the username is valid, but password is not
#define CREDUI_FLAGS_DO_NOT_PERSIST         0x00002     // Do not show "Save" checkbox, and do not persist credentials
#define CREDUI_FLAGS_REQUEST_ADMINISTRATOR  0x00004     // Populate list box with admin accounts
#define CREDUI_FLAGS_EXCLUDE_CERTIFICATES   0x00008     // do not include certificates in the drop list
#define CREDUI_FLAGS_REQUIRE_CERTIFICATE    0x00010
#define CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX    0x00040
#define CREDUI_FLAGS_ALWAYS_SHOW_UI         0x00080
#define CREDUI_FLAGS_REQUIRE_SMARTCARD      0x00100
#define CREDUI_FLAGS_PASSWORD_ONLY_OK       0x00200
#define CREDUI_FLAGS_VALIDATE_USERNAME      0x00400
#define CREDUI_FLAGS_COMPLETE_USERNAME      0x00800     //
#define CREDUI_FLAGS_PERSIST                0x01000     // Do not show "Save" checkbox, but persist credentials anyway
#define CREDUI_FLAGS_SERVER_CREDENTIAL      0x04000
#define CREDUI_FLAGS_EXPECT_CONFIRMATION    0x20000     // do not persist unless caller later confirms credential via CredUIConfirmCredential() api
#define CREDUI_FLAGS_GENERIC_CREDENTIALS    0x40000     // Credential is a generic credential
#define CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS 0x80000 // Credential has a username as the target
#define CREDUI_FLAGS_KEEP_USERNAME         0x100000             // don't allow the user to change the supplied username


//
// Mask of flags valid for CredUIPromptForCredentials
//
#define CREDUI_FLAGS_PROMPT_VALID ( \
        CREDUI_FLAGS_INCORRECT_PASSWORD | \
        CREDUI_FLAGS_DO_NOT_PERSIST | \
        CREDUI_FLAGS_REQUEST_ADMINISTRATOR | \
        CREDUI_FLAGS_EXCLUDE_CERTIFICATES | \
        CREDUI_FLAGS_REQUIRE_CERTIFICATE | \
        CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX | \
        CREDUI_FLAGS_ALWAYS_SHOW_UI | \
        CREDUI_FLAGS_REQUIRE_SMARTCARD | \
        CREDUI_FLAGS_PASSWORD_ONLY_OK | \
        CREDUI_FLAGS_VALIDATE_USERNAME | \
        CREDUI_FLAGS_COMPLETE_USERNAME | \
        CREDUI_FLAGS_PERSIST | \
        CREDUI_FLAGS_SERVER_CREDENTIAL | \
        CREDUI_FLAGS_EXPECT_CONFIRMATION | \
        CREDUI_FLAGS_GENERIC_CREDENTIALS | \
        CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS | \
        CREDUI_FLAGS_KEEP_USERNAME )


//
// Flags for CredUIPromptForWindowsCredentials and CPUS_CREDUI Usage Scenarios
//

#define CREDUIWIN_GENERIC                   0x00000001  // Plain text username/password is being requested
#define CREDUIWIN_CHECKBOX                  0x00000002  // Show the Save Credential checkbox
#define CREDUIWIN_AUTHPACKAGE_ONLY          0x00000010  // Only Cred Providers that support the input auth package should enumerate
#define CREDUIWIN_IN_CRED_ONLY              0x00000020  // Only the incoming cred for the specific auth package should be enumerated
#define CREDUIWIN_ENUMERATE_ADMINS          0x00000100  // Cred Providers should enumerate administrators only
#define CREDUIWIN_ENUMERATE_CURRENT_USER    0x00000200  // Only the incoming cred for the specific auth package should be enumerated
#define CREDUIWIN_SECURE_PROMPT             0x00001000  // The Credui prompt should be displayed on the secure desktop
#define CREDUIWIN_PACK_32_WOW               0x10000000  // Tell the credential provider it should be packing its Auth Blob 32 bit even though it is running 64 native

#define CREDUIWIN_VALID_FLAGS            ( \
        CREDUIWIN_GENERIC                | \
        CREDUIWIN_CHECKBOX               | \
        CREDUIWIN_AUTHPACKAGE_ONLY       | \
        CREDUIWIN_IN_CRED_ONLY           | \
        CREDUIWIN_ENUMERATE_ADMINS       | \
        CREDUIWIN_ENUMERATE_CURRENT_USER | \
        CREDUIWIN_SECURE_PROMPT          | \
        CREDUIWIN_PACK_32_WOW            )

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------


//
// Values of flags to CredWrite and CredWriteDomainCredentials
//

#define CRED_PRESERVE_CREDENTIAL_BLOB 0x1

WINADVAPI
BOOL
WINAPI
CredWriteW (
    __in PCREDENTIALW Credential,
    __in DWORD Flags
    );

WINADVAPI
BOOL
WINAPI
CredWriteA (
    __in PCREDENTIALA Credential,
    __in DWORD Flags
    );

#ifdef UNICODE
#define CredWrite CredWriteW
#else
#define CredWrite CredWriteA
#endif // UNICODE


WINADVAPI
BOOL
WINAPI
CredReadW (
    __in LPCWSTR TargetName,
    __in DWORD Type,
    __reserved DWORD Flags,
    __out PCREDENTIALW *Credential
    );

WINADVAPI
BOOL
WINAPI
CredReadA (
    __in LPCSTR TargetName,
    __in DWORD Type,
    __reserved DWORD Flags,
    __out PCREDENTIALA *Credential
    );

#ifdef UNICODE
#define CredRead CredReadW
#else
#define CredRead CredReadA
#endif // UNICODE


//
// Values of flags to CredEnumerate
//

#define CRED_ENUMERATE_ALL_CREDENTIALS 0x1

WINADVAPI
BOOL
WINAPI
CredEnumerateW (
    __in_opt LPCWSTR Filter,
    __reserved DWORD Flags,
    __out DWORD *Count,
    __deref_out_ecount(*Count) PCREDENTIALW **Credential
    );

WINADVAPI
BOOL
WINAPI
CredEnumerateA (
    __in_opt LPCSTR Filter,
    __reserved DWORD Flags,
    __out DWORD *Count,
    __deref_out_ecount(*Count) PCREDENTIALA **Credential
    );

#ifdef UNICODE
#define CredEnumerate CredEnumerateW
#else
#define CredEnumerate CredEnumerateA
#endif // UNICODE


WINADVAPI
BOOL
WINAPI
CredWriteDomainCredentialsW (
    __in PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    __in PCREDENTIALW Credential,
    __in DWORD Flags
    );

WINADVAPI
BOOL
WINAPI
CredWriteDomainCredentialsA (
    __in PCREDENTIAL_TARGET_INFORMATIONA TargetInfo,
    __in PCREDENTIALA Credential,
    __in DWORD Flags
    );

#ifdef UNICODE
#define CredWriteDomainCredentials CredWriteDomainCredentialsW
#else
#define CredWriteDomainCredentials CredWriteDomainCredentialsA
#endif // UNICODE



//
// Values of flags to CredReadDomainCredentials
//

#define CRED_CACHE_TARGET_INFORMATION 0x1


WINADVAPI
BOOL
WINAPI
CredReadDomainCredentialsW (
    __in PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    __in DWORD Flags,
    __out DWORD *Count,
    __deref_out_ecount(*Count) PCREDENTIALW **Credential
    );

WINADVAPI
BOOL
WINAPI
CredReadDomainCredentialsA (
    __in PCREDENTIAL_TARGET_INFORMATIONA TargetInfo,
    __in DWORD Flags,
    __out DWORD *Count,
    __deref_out_ecount(*Count) PCREDENTIALA **Credential
    );

#ifdef UNICODE
#define CredReadDomainCredentials CredReadDomainCredentialsW
#else
#define CredReadDomainCredentials CredReadDomainCredentialsA
#endif // UNICODE


WINADVAPI
BOOL
WINAPI
CredDeleteW (
    __in LPCWSTR TargetName,
    __in DWORD Type,
    __reserved DWORD Flags
    );

WINADVAPI
BOOL
WINAPI
CredDeleteA (
    __in LPCSTR TargetName,
    __in DWORD Type,
    __reserved DWORD Flags
    );

#ifdef UNICODE
#define CredDelete CredDeleteW
#else
#define CredDelete CredDeleteA
#endif // UNICODE


WINADVAPI
BOOL
WINAPI
CredRenameW (
    __in LPCWSTR OldTargetName,
    __in LPCWSTR NewTargetName,
    __in DWORD Type,
    __reserved DWORD Flags
    );

WINADVAPI
BOOL
WINAPI
CredRenameA (
    __in LPCSTR OldTargetName,
    __in LPCSTR NewTargetName,
    __in DWORD Type,
    __reserved DWORD Flags
    );

#ifdef UNICODE
#define CredRename CredRenameW
#else
#define CredRename CredRenameA
#endif // UNICODE

//
// Values of flags to CredGetTargetInfo
//

#define CRED_ALLOW_NAME_RESOLUTION 0x1


WINADVAPI
BOOL
WINAPI
CredGetTargetInfoW (
    __in LPCWSTR TargetName,
    __in DWORD Flags,
    __out PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    );

WINADVAPI
BOOL
WINAPI
CredGetTargetInfoA (
    __in LPCSTR TargetName,
    __in DWORD Flags,
    __out PCREDENTIAL_TARGET_INFORMATIONA *TargetInfo
    );

#ifdef UNICODE
#define CredGetTargetInfo CredGetTargetInfoW
#else
#define CredGetTargetInfo CredGetTargetInfoA
#endif // UNICODE

WINADVAPI
BOOL
WINAPI
CredMarshalCredentialW(
    __in CRED_MARSHAL_TYPE CredType,
    __in PVOID Credential,
    __out LPWSTR *MarshaledCredential
    );

WINADVAPI
BOOL
WINAPI
CredMarshalCredentialA(
    __in CRED_MARSHAL_TYPE CredType,
    __in PVOID Credential,
    __out LPSTR *MarshaledCredential
    );

#ifdef UNICODE
#define CredMarshalCredential CredMarshalCredentialW
#else
#define CredMarshalCredential CredMarshalCredentialA
#endif // UNICODE

WINADVAPI
BOOL
WINAPI
CredUnmarshalCredentialW(
    __in LPCWSTR MarshaledCredential,
    __out PCRED_MARSHAL_TYPE CredType,
    __out PVOID *Credential
    );

WINADVAPI
BOOL
WINAPI
CredUnmarshalCredentialA(
    __in LPCSTR MarshaledCredential,
    __out PCRED_MARSHAL_TYPE CredType,
    __out PVOID *Credential
    );

#ifdef UNICODE
#define CredUnmarshalCredential CredUnmarshalCredentialW
#else
#define CredUnmarshalCredential CredUnmarshalCredentialA
#endif // UNICODE

WINADVAPI
BOOL
WINAPI
CredIsMarshaledCredentialW(
    __in LPCWSTR MarshaledCredential
    );

WINADVAPI
BOOL
WINAPI
CredIsMarshaledCredentialA(
    __in LPCSTR MarshaledCredential
    );

#ifdef UNICODE
#define CredIsMarshaledCredential CredIsMarshaledCredentialW
#else
#define CredIsMarshaledCredential CredIsMarshaledCredentialA
#endif // UNICODE

CREDUIAPI
BOOL
WINAPI
CredUnPackAuthenticationBufferW(
    __in DWORD                                      dwFlags,
    __in_bcount(cbAuthBuffer) PVOID                 pAuthBuffer,
    __in DWORD                                      cbAuthBuffer,
    __out_ecount_opt(*pcchMaxUserName) LPWSTR       pszUserName,
    __inout DWORD*                                  pcchMaxUserName,
    __out_ecount_opt(*pcchMaxDomainName) LPWSTR     pszDomainName,
    __inout_opt DWORD*                              pcchMaxDomainName,
    __out_ecount_opt(*pcchMaxPassword) LPWSTR       pszPassword,
    __inout DWORD*                                  pcchMaxPassword
    );

CREDUIAPI
BOOL
WINAPI
CredUnPackAuthenticationBufferA(
    __in DWORD                                      dwFlags,
    __in_bcount(cbAuthBuffer) PVOID                 pAuthBuffer,
    __in DWORD                                      cbAuthBuffer,
    __out_ecount_opt(*pcchMaxUserName) LPSTR        pszUserName,
    __inout DWORD*                                  pcchlMaxUserName,
    __out_ecount_opt(*pcchMaxDomainName) LPSTR      pszDomainName,
    __inout_opt DWORD*                              pcchMaxDomainName,
    __out_ecount_opt(*pcchMaxPassword) LPSTR        pszPassword,
    __inout DWORD*                                  pcchMaxPassword
    );

#ifdef UNICODE
#define CredUnPackAuthenticationBuffer CredUnPackAuthenticationBufferW
#else
#define CredUnPackAuthenticationBuffer CredUnPackAuthenticationBufferA
#endif //UNICODE

CREDUIAPI
BOOL
WINAPI
CredPackAuthenticationBufferW(
    __in DWORD                                      dwFlags,
    __in LPWSTR                                     pszUserName,
    __in LPWSTR                                     pszPassword,
    __out_bcount_opt(*pcbPackedCredentials) PBYTE   pPackedCredentials,
    __inout DWORD*                                  pcbPackedCredentials
    );

CREDUIAPI
BOOL
WINAPI
CredPackAuthenticationBufferA(
    __in DWORD                                      dwFlags,
    __in LPSTR                                      pszUserName,
    __in LPSTR                                      pszPassword,
    __out_bcount_opt(*pcbPackedCredentials) PBYTE   pPackedCredentials,
    __inout DWORD*                                  pcbPackedCredentials
    );

#ifdef UNICODE
#define CredPackAuthenticationBuffer CredPackAuthenticationBufferW
#else
#define CredPackAuthenticationBuffer CredPackAuthenticationBufferA
#endif //UNICODE

WINADVAPI
BOOL
WINAPI
CredProtectW(
    __in BOOL                               fAsSelf,
    __in_ecount(cchCredentials) LPWSTR      pszCredentials,
    __in DWORD                              cchCredentials,
    __out_ecount(*pcchMaxChars) LPWSTR      pszProtectedCredentials,
    __inout DWORD*                          pcchMaxChars,
    __out_opt CRED_PROTECTION_TYPE*         ProtectionType
    );

WINADVAPI
BOOL
WINAPI
CredProtectA(
    __in BOOL                            fAsSelf,
    __in_ecount(cchCredentials) LPSTR    pszCredentials,
    __in DWORD                           cchCredentials,
    __out_ecount(*pcchMaxChars) LPSTR    pszProtectedCredentials,
    __inout DWORD*                       pcchMaxChars,
    __out_opt CRED_PROTECTION_TYPE*      ProtectionType
    );

#ifdef UNICODE
#define CredProtect CredProtectW
#else
#define CredProtect CredProtectA
#endif //UNICODE

WINADVAPI
BOOL
WINAPI
CredUnprotectW(
    __in BOOL                                   fAsSelf,
    __in_ecount(cchProtectedCredentials) LPWSTR pszProtectedCredentials,
    __in DWORD                                  cchProtectedCredentials,
    __out_ecount_opt(*pcchMaxChars) LPWSTR      pszCredentials,
    __inout DWORD*                              pcchMaxChars
    );

WINADVAPI
BOOL
WINAPI
CredUnprotectA(
    __in BOOL                                   fAsSelf,
    __in_ecount(cchProtectedCredentials) LPSTR  pszProtectedCredentials,
    __in DWORD                                  cchProtectedCredentials,
    __out_ecount_opt(*pcchMaxChars) LPSTR       pszCredentials,
    __inout DWORD*                              pcchMaxChars
    );

#ifdef UNICODE
#define CredUnprotect CredUnprotectW
#else
#define CredUnprotect CredUnprotectA
#endif //UNICODE

WINADVAPI
BOOL
WINAPI
CredIsProtectedW(
    __in LPWSTR                 pszProtectedCredentials,
    __out CRED_PROTECTION_TYPE* pProtectionType
    );

WINADVAPI
BOOL
WINAPI
CredIsProtectedA(
    __in LPSTR                  pszProtectedCredentials,
    __out CRED_PROTECTION_TYPE* pProtectionType
    );

#ifdef UNICODE
#define CredIsProtected CredIsProtectedW
#else
#define CredIsProtected CredIsProtectedA
#endif //UNICODE



WINADVAPI
BOOL
WINAPI
CredFindBestCredentialW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    );

WINADVAPI
BOOL
WINAPI
CredFindBestCredentialA (
    IN LPCSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags,
    OUT PCREDENTIALA *Credential
    );

#ifdef UNICODE
#define CredFindBestCredential CredFindBestCredentialW
#else
#define CredFindBestCredential CredFindBestCredentialA
#endif // UNICODE




WINADVAPI
BOOL
WINAPI
CredGetSessionTypes (
    __in DWORD MaximumPersistCount,
    __out LPDWORD MaximumPersist
    );


WINADVAPI
VOID
WINAPI
CredFree (
    __in PVOID Buffer
    );


CREDUIAPI
DWORD
WINAPI
CredUIPromptForCredentialsW(
    __in_opt PCREDUI_INFOW pUiInfo,
    __in_opt PCWSTR pszTargetName,
    __reserved PCtxtHandle pContext,
    __in DWORD dwAuthError,
    __inout_ecount(ulUserNameBufferSize) PWSTR pszUserName,
    __in ULONG ulUserNameBufferSize,
    __inout_ecount(ulPasswordBufferSize) PWSTR pszPassword,
    __in ULONG ulPasswordBufferSize,
    __inout_opt BOOL *save,
    __in DWORD dwFlags
    );

CREDUIAPI
DWORD
WINAPI
CredUIPromptForCredentialsA(
    __in_opt PCREDUI_INFOA pUiInfo,
    __in_opt PCSTR pszTargetName,
    __reserved PCtxtHandle pContext,
    __in DWORD dwAuthError,
    __inout_ecount(ulUserNameBufferSize) PSTR  pszUserName,
    __in ULONG ulUserNameBufferSize,
    __inout_ecount(ulPasswordBufferSize) PSTR pszPassword,
    __in ULONG ulPasswordBufferSize,
    __inout_opt BOOL *save,
    __in DWORD dwFlags
    );

#ifdef UNICODE
#define CredUIPromptForCredentials CredUIPromptForCredentialsW
#else
#define CredUIPromptForCredentials CredUIPromptForCredentialsA
#endif

CREDUIAPI
DWORD
WINAPI
CredUIPromptForWindowsCredentialsW(
    __in_opt PCREDUI_INFOW pUiInfo,
    __in DWORD dwAuthError,
    __inout ULONG *pulAuthPackage,
    __in_bcount_opt(ulInAuthBufferSize) LPCVOID pvInAuthBuffer,
    __in ULONG ulInAuthBufferSize,
    __deref_out_bcount_full(*pulOutAuthBufferSize) LPVOID * ppvOutAuthBuffer,
    __out ULONG * pulOutAuthBufferSize,
    __inout_opt BOOL *pfSave,
    __in DWORD dwFlags
    );

CREDUIAPI
DWORD
WINAPI
CredUIPromptForWindowsCredentialsA(
    __in_opt PCREDUI_INFOA pUiInfo,
    __in DWORD dwAuthError,
    __inout ULONG *pulAuthPackage,
    __in_bcount_opt(ulInAuthBufferSize) LPCVOID pvInAuthBuffer,
    __in ULONG ulInAuthBufferSize,
    __deref_out_bcount_full(*pulOutAuthBufferSize) LPVOID * ppvOutAuthBuffer,
    __out ULONG * pulOutAuthBufferSize,
    __inout_opt BOOL *pfSave,
    __in DWORD dwFlags
    );

#ifdef UNICODE
#define CredUIPromptForWindowsCredentials CredUIPromptForWindowsCredentialsW
#else
#define CredUIPromptForWindowsCredentials CredUIPromptForWindowsCredentialsA
#endif


CREDUIAPI
DWORD
WINAPI
CredUIParseUserNameW(
    __in CONST WCHAR *UserName,
    __out_ecount(userBufferSize) WCHAR *user,
    __in ULONG userBufferSize,
    __out_ecount(domainBufferSize) WCHAR *domain,
    __in ULONG domainBufferSize
    );

CREDUIAPI
DWORD
WINAPI
CredUIParseUserNameA(
    __in CONST CHAR *userName,
    __out_ecount(userBufferSize) CHAR *user,
    __in ULONG userBufferSize,
    __out_ecount(domainBufferSize) CHAR *domain,
    __in ULONG domainBufferSize
    );

#ifdef UNICODE
#define CredUIParseUserName CredUIParseUserNameW
#else
#define CredUIParseUserName CredUIParseUserNameA
#endif



CREDUIAPI
DWORD
WINAPI
CredUICmdLinePromptForCredentialsW(
    __in_opt PCWSTR pszTargetName,
    __reserved PCtxtHandle pContext,
    __in DWORD dwAuthError,
    __inout_ecount(ulUserBufferSize) PWSTR UserName,
    __in ULONG ulUserBufferSize,
    __inout_ecount(ulPasswordBufferSize) PWSTR pszPassword,
    __in ULONG ulPasswordBufferSize,
    __inout_opt PBOOL pfSave,
    __in DWORD dwFlags
    );

CREDUIAPI
DWORD
WINAPI
CredUICmdLinePromptForCredentialsA(
    __in_opt PCSTR pszTargetName,
    __reserved PCtxtHandle pContext,
    __in DWORD dwAuthError,
    __inout_ecount(ulUserBufferSize) PSTR UserName,
    __in ULONG ulUserBufferSize,
    __inout_ecount(ulPasswordBufferSize) PSTR pszPassword,
    __in ULONG ulPasswordBufferSize,
    __inout_opt PBOOL pfSave,
    __in DWORD dwFlags
    );

#ifdef UNICODE
#define CredUICmdLinePromptForCredentials CredUICmdLinePromptForCredentialsW
#else
#define CredUICmdLinePromptForCredentials CredUICmdLinePromptForCredentialsA
#endif

//
// Call this API with bConfirm set to TRUE to confirm that the credential (previously created
// via CredUIGetCredentials or CredUIPromptForCredentials worked, or with bConfirm set to FALSE
// to indicate it didn't

CREDUIAPI
DWORD
WINAPI
CredUIConfirmCredentialsW(
    __in PCWSTR pszTargetName,
    __in BOOL  bConfirm
    );

CREDUIAPI
DWORD
WINAPI
CredUIConfirmCredentialsA(
    __in PCSTR pszTargetName,
    __in BOOL  bConfirm
    );

#ifdef UNICODE
#define CredUIConfirmCredentials CredUIConfirmCredentialsW
#else
#define CredUIConfirmCredentials CredUIConfirmCredentialsA
#endif


CREDUIAPI
DWORD
WINAPI
CredUIStoreSSOCredW (
    __in_opt PCWSTR pszRealm,
    __in PCWSTR pszUsername,
    __in PCWSTR pszPassword,
    __in BOOL   bPersist
    );

CREDUIAPI
DWORD
WINAPI
CredUIReadSSOCredW (
    __in_opt PCWSTR pszRealm,
    __deref_out PWSTR* ppszUsername
    );

#ifdef __cplusplus
}
#endif

#endif // _WINCRED_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinDNS.h ===
/*++

Copyright (c) 1996-2005  Microsoft Corporation

Module Name:

    windns.h

Abstract:

    Domain Name System (DNS)

    DNS definitions and DNS API.

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _WINDNS_INCLUDED_
#define _WINDNS_INCLUDED_


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Define QWORD -- not yet defined globally 
//

typedef unsigned __int64 QWORD, *PQWORD;

//
//  DNS public types
//

typedef __success(return == 0) LONG    DNS_STATUS;
typedef DNS_STATUS                    *PDNS_STATUS;

//
//  IP Address
//

typedef DWORD   IP4_ADDRESS, *PIP4_ADDRESS;

#define SIZEOF_IP4_ADDRESS                  (4)
#define IP4_ADDRESS_STRING_LENGTH           (16)

//  Backcompat only -- length def contains terminating NULL

#define IP4_ADDRESS_STRING_BUFFER_LENGTH    (16)


//
//  IP Address Array type
//

typedef struct  _IP4_ARRAY
{
    DWORD           AddrCount;
#ifdef MIDL_PASS
    [size_is( AddrCount )]  IP4_ADDRESS  AddrArray[];
#else
    IP4_ADDRESS     AddrArray[1];
#endif
}
IP4_ARRAY, *PIP4_ARRAY;


//
//  IPv6 Address
//

#ifdef MIDL_PASS

#ifdef _WIN64
#pragma pack(push, 8)
#else
#pragma pack(push, 4)
#endif

typedef struct
{
    QWORD       IP6Qword[2];
}
IP6_ADDRESS, *PIP6_ADDRESS;

#pragma pack(pop)

#else // MIDL_PASS

typedef union
{
#ifdef _WIN64
    QWORD       IP6Qword[2];
#endif
    DWORD       IP6Dword[4];
    WORD        IP6Word[8];
    BYTE        IP6Byte[16];
#ifdef  IN6_ADDR
    IN6_ADDR    In6;
#endif
}
IP6_ADDRESS, *PIP6_ADDRESS;

#endif // MIDL_PASS


//
//  IP6 string max is 45 bytes
//      - 6 WORDs in colon+hex (5 chars)
//      - last DWORD as IP4 (15 chars)
//  but include
//      - 11 bytes for scope ID
//      - 6 bytes for port (inc. colon)
//      - two bytes to bracket address with port
//      - terminating NULL
//
//  Note:  this is a change to previous def, but a single
//      definition continaing space for ALL possible IPv6
//      address strings, we elminate many possible errors

#undef  IP6_ADDRESS_STRING_LENGTH
#define IP6_ADDRESS_STRING_LENGTH           (65)
#define IP6_ADDRESS_STRING_BUFFER_LENGTH    (65)

//
//  IP4/IP6 combined maximum
//

#define DNS_ADDRESS_STRING_LENGTH           (IP6_ADDRESS_STRING_LENGTH)


//
//  Inline byte flipping -- can be done in registers
//

#define INLINE_WORD_FLIP(out, in)   \
        {                           \
            WORD _in = (in);        \
            (out) = (_in << 8) | (_in >> 8);  \
        }
#define INLINE_HTONS(out, in)   INLINE_WORD_FLIP(out, in)
#define INLINE_NTOHS(out, in)   INLINE_WORD_FLIP(out, in)

#define INLINE_DWORD_FLIP(out, in)  \
        {                           \
            DWORD _in = (in);       \
            (out) = ((_in << 8) & 0x00ff0000) | \
                    (_in << 24)               | \
                    ((_in >> 8) & 0x0000ff00) | \
                    (_in >> 24);                \
        }
#define INLINE_NTOHL(out, in) INLINE_DWORD_FLIP(out, in)
#define INLINE_HTONL(out, in) INLINE_DWORD_FLIP(out, in)


//
//  Inline byte flip and write to packet (unaligned)
//

#define INLINE_WRITE_FLIPPED_WORD( pout, in ) \
            INLINE_WORD_FLIP( *((UNALIGNED WORD *)(pout)), in )

#define INLINE_WRITE_FLIPPED_DWORD( pout, in ) \
            INLINE_DWORD_FLIP( *((UNALIGNED DWORD *)(pout)), in )




//
//  Basic DNS definitions
//

//
//  DNS port for both UDP and TCP is 53.
//

#define DNS_PORT_HOST_ORDER     (0x0035)    // port 53
#define DNS_PORT_NET_ORDER      (0x3500)

//
//  DNS UDP packets no more than 512 bytes
//

#define DNS_RFC_MAX_UDP_PACKET_LENGTH   (512)


//
//  DNS Names limited to 255, 63 in any one label
//

#define DNS_MAX_NAME_LENGTH             (255)
#define DNS_MAX_LABEL_LENGTH            (63)

#define DNS_MAX_NAME_BUFFER_LENGTH      (256)
#define DNS_MAX_LABEL_BUFFER_LENGTH     (64)

//
//  Reverse lookup domain names
//

#define DNS_IP4_REVERSE_DOMAIN_STRING_A     ("in-addr.arpa.")
#define DNS_IP4_REVERSE_DOMAIN_STRING_W     (L"in-addr.arpa.")

#define DNS_MAX_IP4_REVERSE_NAME_LENGTH     (IP4_ADDRESS_STRING_LENGTH+15)
            //(IP4_ADDRESS_STRING_LENGTH+1+sizeof(DNS_IP4_REVERSE_DOMAIN_STRING_A))

#define DNS_IP6_REVERSE_DOMAIN_STRING_A     ("ip6.arpa.")
#define DNS_IP6_REVERSE_DOMAIN_STRING_W     (L"ip6.arpa.")

#define DNS_MAX_IP6_REVERSE_NAME_LENGTH     (75)
            //(64+sizeof(DNS_IP6_REVERSE_DOMAIN_STRING_A))

//  Combined

#define DNS_MAX_REVERSE_NAME_LENGTH     DNS_MAX_IP6_REVERSE_NAME_LENGTH

#ifdef UNICODE
#define DNS_IP4_REVERSE_DOMAIN_STRING   DNS_IP4_REVERSE_DOMAIN_STRING_W
#define DNS_IP6_REVERSE_DOMAIN_STRING   DNS_IP6_REVERSE_DOMAIN_STRING_W
#else
#define DNS_IP4_REVERSE_DOMAIN_STRING   DNS_IP4_REVERSE_DOMAIN_STRING_A
#define DNS_IP6_REVERSE_DOMAIN_STRING   DNS_IP6_REVERSE_DOMAIN_STRING_A
#endif

//
//  Backcompat only -- name def contains terminating NULL
//

#define DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH  DNS_MAX_IP4_REVERSE_NAME_LENGTH
#define DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH  DNS_MAX_IP6_REVERSE_NAME_LENGTH
#define DNS_MAX_REVERSE_NAME_BUFFER_LENGTH      DNS_MAX_REVERSE_NAME_LENGTH


//
//  DNS Text string limited by size representable
//      in a single byte length field

#define DNS_MAX_TEXT_STRING_LENGTH  (255)




//
//  DNS On-The-Wire Structures
//

#pragma pack(push, 1)

//
//  DNS Message Header
//

typedef struct _DNS_HEADER
{
    WORD    Xid;

    BYTE    RecursionDesired : 1;
    BYTE    Truncation : 1;
    BYTE    Authoritative : 1;
    BYTE    Opcode : 4;
    BYTE    IsResponse : 1;

    BYTE    ResponseCode : 4;
    BYTE    CheckingDisabled : 1;
    BYTE    AuthenticatedData : 1;
    BYTE    Reserved : 1;
    BYTE    RecursionAvailable : 1;

    WORD    QuestionCount;
    WORD    AnswerCount;
    WORD    NameServerCount;
    WORD    AdditionalCount;
}
DNS_HEADER, *PDNS_HEADER;

typedef struct _DNS_HEADER_EXT
{
    WORD            Reserved : 15;
    WORD            DnssecOk : 1;
    BYTE            chRcode;
    BYTE            chVersion;
} 
DNS_HEADER_EXT, *PDNS_HEADER_EXT;

//
//  Flags as WORD
//

#define DNS_HEADER_FLAGS(pHead)     ( *((PWORD)(pHead)+1) )


//
//  Byte flip DNS header to\from host order.
//
//  Note that this does NOT flip flags, as definition above defines
//  flags as individual bytes for direct access to net byte order.
//

#define DNS_BYTE_FLIP_HEADER_COUNTS(pHeader)       \
        {                                   \
            PDNS_HEADER _head = (pHeader);  \
            INLINE_HTONS(_head->Xid,            _head->Xid             ); \
            INLINE_HTONS(_head->QuestionCount,  _head->QuestionCount   ); \
            INLINE_HTONS(_head->AnswerCount,    _head->AnswerCount     ); \
            INLINE_HTONS(_head->NameServerCount,_head->NameServerCount ); \
            INLINE_HTONS(_head->AdditionalCount,_head->AdditionalCount ); \
        }

//
//  Question name follows header
//

#define DNS_OFFSET_TO_QUESTION_NAME     sizeof(DNS_HEADER)

//
//  Question immediately follows header so compressed question name
//      0xC000 | sizeof(DNS_HEADER)

#define DNS_COMPRESSED_QUESTION_NAME  (0xC00C)


//
//  Packet extraction macros
//

#define DNS_QUESTION_NAME_FROM_HEADER( _pHeader_ ) \
            ( (PCHAR)( (PDNS_HEADER)(_pHeader_) + 1 ) )

#define DNS_ANSWER_FROM_QUESTION( _pQuestion_ ) \
            ( (PCHAR)( (PDNS_QUESTION)(_pQuestion_) + 1 ) )


//
//  DNS Question
//

typedef struct _DNS_WIRE_QUESTION
{
    //  Preceded by question name

    WORD    QuestionType;
    WORD    QuestionClass;
}
DNS_WIRE_QUESTION, *PDNS_WIRE_QUESTION;


//
//  DNS Resource Record
//

typedef struct _DNS_WIRE_RECORD
{
    //  Preceded by record owner name

    WORD    RecordType;
    WORD    RecordClass;
    DWORD   TimeToLive;
    WORD    DataLength;

    //  Followed by record data
}
DNS_WIRE_RECORD, *PDNS_WIRE_RECORD;

#pragma pack(pop)


//
//  DNS Query Types
//

#define DNS_OPCODE_QUERY            0   // Query
#define DNS_OPCODE_IQUERY           1   // Obsolete: IP to name
#define DNS_OPCODE_SERVER_STATUS    2   // Obsolete: DNS ping
#define DNS_OPCODE_UNKNOWN          3   // Unknown
#define DNS_OPCODE_NOTIFY           4   // Notify
#define DNS_OPCODE_UPDATE           5   // Dynamic Update

//
//  DNS response codes.
//
//  Sent in the "ResponseCode" field of a DNS_HEADER.
//

#define DNS_RCODE_NOERROR       0
#define DNS_RCODE_FORMERR       1       // Format error
#define DNS_RCODE_SERVFAIL      2       // Server failure
#define DNS_RCODE_NXDOMAIN      3       // Name error
#define DNS_RCODE_NOTIMPL       4       // Not implemented
#define DNS_RCODE_REFUSED       5       // Refused
#define DNS_RCODE_YXDOMAIN      6       // Domain name should not exist
#define DNS_RCODE_YXRRSET       7       // RR set should not exist
#define DNS_RCODE_NXRRSET       8       // RR set does not exist
#define DNS_RCODE_NOTAUTH       9       // Not authoritative for zone
#define DNS_RCODE_NOTZONE       10      // Name is not zone
#define DNS_RCODE_MAX           15

//
//  Extended RCODEs
//

#define DNS_RCODE_BADVERS       16      // Bad EDNS version
#define DNS_RCODE_BADSIG        16      // Bad signature
#define DNS_RCODE_BADKEY        17      // Bad key
#define DNS_RCODE_BADTIME       18      // Bad timestamp

//
//  Mappings to friendly names
//

#define DNS_RCODE_NO_ERROR          DNS_RCODE_NOERROR
#define DNS_RCODE_FORMAT_ERROR      DNS_RCODE_FORMERR
#define DNS_RCODE_SERVER_FAILURE    DNS_RCODE_SERVFAIL
#define DNS_RCODE_NAME_ERROR        DNS_RCODE_NXDOMAIN
#define DNS_RCODE_NOT_IMPLEMENTED   DNS_RCODE_NOTIMPL


//
//  DNS Classes
//
//  Classes are on the wire as WORDs.
//
//  _CLASS_ defines in host order.
//  _RCLASS_ defines in net byte order.
//
//  Generally we'll avoid byte flip and test class in net byte order.
//

#define DNS_CLASS_INTERNET  0x0001      //  1
#define DNS_CLASS_CSNET     0x0002      //  2
#define DNS_CLASS_CHAOS     0x0003      //  3
#define DNS_CLASS_HESIOD    0x0004      //  4
#define DNS_CLASS_NONE      0x00fe      //  254
#define DNS_CLASS_ALL       0x00ff      //  255
#define DNS_CLASS_ANY       0x00ff      //  255

#define DNS_RCLASS_INTERNET 0x0100      //  1
#define DNS_RCLASS_CSNET    0x0200      //  2
#define DNS_RCLASS_CHAOS    0x0300      //  3
#define DNS_RCLASS_HESIOD   0x0400      //  4
#define DNS_RCLASS_NONE     0xfe00      //  254
#define DNS_RCLASS_ALL      0xff00      //  255
#define DNS_RCLASS_ANY      0xff00      //  255



//
//  DNS Record Types
//
//  _TYPE_ defines are in host byte order.
//  _RTYPE_ defines are in net byte order.
//
//  Generally always deal with types in host byte order as we index
//  resource record functions by type.
//

#define DNS_TYPE_ZERO       0x0000

//  RFC 1034/1035
#define DNS_TYPE_A          0x0001      //  1
#define DNS_TYPE_NS         0x0002      //  2
#define DNS_TYPE_MD         0x0003      //  3
#define DNS_TYPE_MF         0x0004      //  4
#define DNS_TYPE_CNAME      0x0005      //  5
#define DNS_TYPE_SOA        0x0006      //  6
#define DNS_TYPE_MB         0x0007      //  7
#define DNS_TYPE_MG         0x0008      //  8
#define DNS_TYPE_MR         0x0009      //  9
#define DNS_TYPE_NULL       0x000a      //  10
#define DNS_TYPE_WKS        0x000b      //  11
#define DNS_TYPE_PTR        0x000c      //  12
#define DNS_TYPE_HINFO      0x000d      //  13
#define DNS_TYPE_MINFO      0x000e      //  14
#define DNS_TYPE_MX         0x000f      //  15
#define DNS_TYPE_TEXT       0x0010      //  16

//  RFC 1183
#define DNS_TYPE_RP         0x0011      //  17
#define DNS_TYPE_AFSDB      0x0012      //  18
#define DNS_TYPE_X25        0x0013      //  19
#define DNS_TYPE_ISDN       0x0014      //  20
#define DNS_TYPE_RT         0x0015      //  21

//  RFC 1348
#define DNS_TYPE_NSAP       0x0016      //  22
#define DNS_TYPE_NSAPPTR    0x0017      //  23

//  RFC 2065    (DNS security)
#define DNS_TYPE_SIG        0x0018      //  24
#define DNS_TYPE_KEY        0x0019      //  25

//  RFC 1664    (X.400 mail)
#define DNS_TYPE_PX         0x001a      //  26

//  RFC 1712    (Geographic position)
#define DNS_TYPE_GPOS       0x001b      //  27

//  RFC 1886    (IPv6 Address)
#define DNS_TYPE_AAAA       0x001c      //  28

//  RFC 1876    (Geographic location)
#define DNS_TYPE_LOC        0x001d      //  29

//  RFC 2065    (Secure negative response)
#define DNS_TYPE_NXT        0x001e      //  30

//  Patton      (Endpoint Identifier)
#define DNS_TYPE_EID        0x001f      //  31

//  Patton      (Nimrod Locator)
#define DNS_TYPE_NIMLOC     0x0020      //  32

//  RFC 2052    (Service location)
#define DNS_TYPE_SRV        0x0021      //  33

//  ATM Standard something-or-another (ATM Address)
#define DNS_TYPE_ATMA       0x0022      //  34

//  RFC 2168    (Naming Authority Pointer)
#define DNS_TYPE_NAPTR      0x0023      //  35

//  RFC 2230    (Key Exchanger)
#define DNS_TYPE_KX         0x0024      //  36

//  RFC 2538    (CERT)
#define DNS_TYPE_CERT       0x0025      //  37

//  A6 Draft    (A6)
#define DNS_TYPE_A6         0x0026      //  38

//  DNAME Draft (DNAME)
#define DNS_TYPE_DNAME      0x0027      //  39

//  Eastlake    (Kitchen Sink)
#define DNS_TYPE_SINK       0x0028      //  40

//  RFC 2671    (EDNS OPT)
#define DNS_TYPE_OPT        0x0029      //  41

//  RFC 4034    (DNSSEC DS)
#define DNS_TYPE_DS         0x002b      //  43

//  RFC 4034    (DNSSEC RRSIG)
#define DNS_TYPE_RRSIG      0x002e      //  46

//  RFC 4034    (DNSSEC NSEC)
#define DNS_TYPE_NSEC       0x002f      //  47

//  RFC 4034    (DNSSEC DNSKEY)
#define DNS_TYPE_DNSKEY     0x0030      //  48

//  RFC 4701    (DHCID)
#define DNS_TYPE_DHCID      0x0031      //  49

//
//  IANA Reserved
//

#define DNS_TYPE_UINFO      0x0064      //  100
#define DNS_TYPE_UID        0x0065      //  101
#define DNS_TYPE_GID        0x0066      //  102
#define DNS_TYPE_UNSPEC     0x0067      //  103

//
//  Query only types (1035, 1995)
//      - Crawford      (ADDRS)
//      - TKEY draft    (TKEY)
//      - TSIG draft    (TSIG)
//      - RFC 1995      (IXFR)
//      - RFC 1035      (AXFR up)
//

#define DNS_TYPE_ADDRS      0x00f8      //  248
#define DNS_TYPE_TKEY       0x00f9      //  249
#define DNS_TYPE_TSIG       0x00fa      //  250
#define DNS_TYPE_IXFR       0x00fb      //  251
#define DNS_TYPE_AXFR       0x00fc      //  252
#define DNS_TYPE_MAILB      0x00fd      //  253
#define DNS_TYPE_MAILA      0x00fe      //  254
#define DNS_TYPE_ALL        0x00ff      //  255
#define DNS_TYPE_ANY        0x00ff      //  255

//
//  Temp Microsoft types -- use until get IANA approval for real type
//

#define DNS_TYPE_WINS       0xff01      //  64K - 255
#define DNS_TYPE_WINSR      0xff02      //  64K - 254
#define DNS_TYPE_NBSTAT     (DNS_TYPE_WINSR)


//
//  DNS Record Types -- Net Byte Order
//

#define DNS_RTYPE_A         0x0100      //  1
#define DNS_RTYPE_NS        0x0200      //  2
#define DNS_RTYPE_MD        0x0300      //  3
#define DNS_RTYPE_MF        0x0400      //  4
#define DNS_RTYPE_CNAME     0x0500      //  5
#define DNS_RTYPE_SOA       0x0600      //  6
#define DNS_RTYPE_MB        0x0700      //  7
#define DNS_RTYPE_MG        0x0800      //  8
#define DNS_RTYPE_MR        0x0900      //  9
#define DNS_RTYPE_NULL      0x0a00      //  10
#define DNS_RTYPE_WKS       0x0b00      //  11
#define DNS_RTYPE_PTR       0x0c00      //  12
#define DNS_RTYPE_HINFO     0x0d00      //  13
#define DNS_RTYPE_MINFO     0x0e00      //  14
#define DNS_RTYPE_MX        0x0f00      //  15
#define DNS_RTYPE_TEXT      0x1000      //  16
#define DNS_RTYPE_RP        0x1100      //  17
#define DNS_RTYPE_AFSDB     0x1200      //  18
#define DNS_RTYPE_X25       0x1300      //  19
#define DNS_RTYPE_ISDN      0x1400      //  20
#define DNS_RTYPE_RT        0x1500      //  21
#define DNS_RTYPE_NSAP      0x1600      //  22
#define DNS_RTYPE_NSAPPTR   0x1700      //  23
#define DNS_RTYPE_SIG       0x1800      //  24
#define DNS_RTYPE_KEY       0x1900      //  25
#define DNS_RTYPE_PX        0x1a00      //  26
#define DNS_RTYPE_GPOS      0x1b00      //  27
#define DNS_RTYPE_AAAA      0x1c00      //  28
#define DNS_RTYPE_LOC       0x1d00      //  29
#define DNS_RTYPE_NXT       0x1e00      //  30
#define DNS_RTYPE_EID       0x1f00      //  31
#define DNS_RTYPE_NIMLOC    0x2000      //  32
#define DNS_RTYPE_SRV       0x2100      //  33
#define DNS_RTYPE_ATMA      0x2200      //  34
#define DNS_RTYPE_NAPTR     0x2300      //  35
#define DNS_RTYPE_KX        0x2400      //  36
#define DNS_RTYPE_CERT      0x2500      //  37
#define DNS_RTYPE_A6        0x2600      //  38
#define DNS_RTYPE_DNAME     0x2700      //  39
#define DNS_RTYPE_SINK      0x2800      //  40
#define DNS_RTYPE_OPT       0x2900      //  41

#define DNS_RTYPE_DS        0x2b00      //  43
#define DNS_RTYPE_RRSIG     0x2e00      //  46
#define DNS_RTYPE_NSEC      0x2f00      //  47
#define DNS_RTYPE_DNSKEY    0x3000      //  48
#define DNS_RTYPE_DHCID     0x3100      //  49

//
//  IANA Reserved
//

#define DNS_RTYPE_UINFO     0x6400      //  100
#define DNS_RTYPE_UID       0x6500      //  101
#define DNS_RTYPE_GID       0x6600      //  102
#define DNS_RTYPE_UNSPEC    0x6700      //  103

//
//  Query only types
//

#define DNS_RTYPE_TKEY      0xf900      //  249
#define DNS_RTYPE_TSIG      0xfa00      //  250
#define DNS_RTYPE_IXFR      0xfb00      //  251
#define DNS_RTYPE_AXFR      0xfc00      //  252
#define DNS_RTYPE_MAILB     0xfd00      //  253
#define DNS_RTYPE_MAILA     0xfe00      //  254
#define DNS_RTYPE_ALL       0xff00      //  255
#define DNS_RTYPE_ANY       0xff00      //  255

//
//  Temp Microsoft types -- use until get IANA approval for real type
//

#define DNS_RTYPE_WINS      0x01ff      //  64K - 255
#define DNS_RTYPE_WINSR     0x02ff      //  64K - 254




//
//  Record type specific definitions
//

//
//  ATMA (ATM address type) formats
//
//  Define these directly for any environment (ex NT4)
//  without winsock2 ATM support (ws2atm.h)
//

#ifndef  ATMA_E164
#define DNS_ATMA_FORMAT_E164            1
#define DNS_ATMA_FORMAT_AESA            2
#define DNS_ATMA_MAX_ADDR_LENGTH        (20)
#else
#define DNS_ATMA_FORMAT_E164            ATM_E164
#define DNS_ATMA_FORMAT_AESA            ATM_AESA
#define DNS_ATMA_MAX_ADDR_LENGTH        ATM_ADDR_SIZE
#endif

#define DNS_ATMA_AESA_ADDR_LENGTH       (20)
#define DNS_ATMA_MAX_RECORD_LENGTH      (DNS_ATMA_MAX_ADDR_LENGTH+1)


//
//  DNSSEC defs
//

//  DNSSEC algorithms

#define DNSSEC_ALGORITHM_RSAMD5     1
#define DNSSEC_ALGORITHM_RSASHA1    5
#define DNSSEC_ALGORITHM_NULL       253
#define DNSSEC_ALGORITHM_PRIVATE    254

//  DNSSEC KEY protocol table

#define DNSSEC_PROTOCOL_NONE        0
#define DNSSEC_PROTOCOL_TLS         1
#define DNSSEC_PROTOCOL_EMAIL       2
#define DNSSEC_PROTOCOL_DNSSEC      3
#define DNSSEC_PROTOCOL_IPSEC       4

//  DNSSEC KEY flag field

#define DNSSEC_KEY_FLAG_NOAUTH          0x0001
#define DNSSEC_KEY_FLAG_NOCONF          0x0002
#define DNSSEC_KEY_FLAG_FLAG2           0x0004
#define DNSSEC_KEY_FLAG_EXTEND          0x0008
#define DNSSEC_KEY_FLAG_
#define DNSSEC_KEY_FLAG_FLAG4           0x0010
#define DNSSEC_KEY_FLAG_FLAG5           0x0020

// bits 6,7 are name type

#define DNSSEC_KEY_FLAG_USER            0x0000
#define DNSSEC_KEY_FLAG_ZONE            0x0040
#define DNSSEC_KEY_FLAG_HOST            0x0080
#define DNSSEC_KEY_FLAG_NTPE3           0x00c0

// bits 8-11 are reserved for future use

#define DNSSEC_KEY_FLAG_FLAG8           0x0100
#define DNSSEC_KEY_FLAG_FLAG9           0x0200
#define DNSSEC_KEY_FLAG_FLAG10          0x0400
#define DNSSEC_KEY_FLAG_FLAG11          0x0800

// bits 12-15 are sig field

#define DNSSEC_KEY_FLAG_SIG0            0x0000
#define DNSSEC_KEY_FLAG_SIG1            0x1000
#define DNSSEC_KEY_FLAG_SIG2            0x2000
#define DNSSEC_KEY_FLAG_SIG3            0x3000
#define DNSSEC_KEY_FLAG_SIG4            0x4000
#define DNSSEC_KEY_FLAG_SIG5            0x5000
#define DNSSEC_KEY_FLAG_SIG6            0x6000
#define DNSSEC_KEY_FLAG_SIG7            0x7000
#define DNSSEC_KEY_FLAG_SIG8            0x8000
#define DNSSEC_KEY_FLAG_SIG9            0x9000
#define DNSSEC_KEY_FLAG_SIG10           0xa000
#define DNSSEC_KEY_FLAG_SIG11           0xb000
#define DNSSEC_KEY_FLAG_SIG12           0xc000
#define DNSSEC_KEY_FLAG_SIG13           0xd000
#define DNSSEC_KEY_FLAG_SIG14           0xe000
#define DNSSEC_KEY_FLAG_SIG15           0xf000


//
//  TKEY modes
//

#define DNS_TKEY_MODE_SERVER_ASSIGN         1
#define DNS_TKEY_MODE_DIFFIE_HELLMAN        2
#define DNS_TKEY_MODE_GSS                   3
#define DNS_TKEY_MODE_RESOLVER_ASSIGN       4

//
//  WINS + NBSTAT flag field
//

#define DNS_WINS_FLAG_SCOPE     (0x80000000)
#define DNS_WINS_FLAG_LOCAL     (0x00010000)


//
//  Helpful checks
//

#define IS_WORD_ALIGNED(p)      ( !((UINT_PTR)(p) & (UINT_PTR)1) )
#define IS_DWORD_ALIGNED(p)     ( !((UINT_PTR)(p) & (UINT_PTR)3) )
#define IS_QWORD_ALIGNED(p)     ( !((UINT_PTR)(p) & (UINT_PTR)7) )




//
//  DNS config API
//

//
//  Types of DNS configuration info
//

typedef enum
{
    //  In Win2K
    DnsConfigPrimaryDomainName_W,
    DnsConfigPrimaryDomainName_A,
    DnsConfigPrimaryDomainName_UTF8,

    //  Not available yet
    DnsConfigAdapterDomainName_W,
    DnsConfigAdapterDomainName_A,
    DnsConfigAdapterDomainName_UTF8,

    //  In Win2K
    DnsConfigDnsServerList,

    //  Not available yet
    DnsConfigSearchList,
    DnsConfigAdapterInfo,

    //  In Win2K
    DnsConfigPrimaryHostNameRegistrationEnabled,
    DnsConfigAdapterHostNameRegistrationEnabled,
    DnsConfigAddressRegistrationMaxCount,

    //  In WindowsXP
    DnsConfigHostName_W,
    DnsConfigHostName_A,
    DnsConfigHostName_UTF8,
    DnsConfigFullHostName_W,
    DnsConfigFullHostName_A,
    DnsConfigFullHostName_UTF8

    //  In XP-SP1 (Server.net)
}
DNS_CONFIG_TYPE;

//
//  Config API flags
//

//
//  DNS_CONFIG_FLAG_ALLOC -- Causes config info to be allocated.
//      Free with LocalFree().
//
#define DNS_CONFIG_FLAG_ALLOC   (0x00000001)

DNS_STATUS
WINAPI
DnsQueryConfig(
    __in                                    DNS_CONFIG_TYPE     Config,
    __in                                    DWORD               Flag,
    __in_opt                                PCWSTR              pwsAdapterName,
    __in_opt                                PVOID               pReserved,
    __out_bcount_part(*pBufLen, *pBufLen)   PVOID               pBuffer,
    __inout                                 PDWORD              pBufLen
    );



//
//  DNS resource record structure
//

//
//  Record data for specific types
//

typedef struct
{
    IP4_ADDRESS     IpAddress;
}
DNS_A_DATA, *PDNS_A_DATA;

typedef struct
{
    PWSTR           pNameHost;
}
DNS_PTR_DATAW, *PDNS_PTR_DATAW;

typedef struct
{
    PSTR            pNameHost;
}
DNS_PTR_DATAA, *PDNS_PTR_DATAA;

typedef struct
{
    PWSTR           pNamePrimaryServer;
    PWSTR           pNameAdministrator;
    DWORD           dwSerialNo;
    DWORD           dwRefresh;
    DWORD           dwRetry;
    DWORD           dwExpire;
    DWORD           dwDefaultTtl;
}
DNS_SOA_DATAW, *PDNS_SOA_DATAW;

typedef struct
{
    PSTR            pNamePrimaryServer;
    PSTR            pNameAdministrator;
    DWORD           dwSerialNo;
    DWORD           dwRefresh;
    DWORD           dwRetry;
    DWORD           dwExpire;
    DWORD           dwDefaultTtl;
}
DNS_SOA_DATAA, *PDNS_SOA_DATAA;

typedef struct
{
    PWSTR           pNameMailbox;
    PWSTR           pNameErrorsMailbox;
}
DNS_MINFO_DATAW, *PDNS_MINFO_DATAW;

typedef struct
{
    PSTR            pNameMailbox;
    PSTR            pNameErrorsMailbox;
}
DNS_MINFO_DATAA, *PDNS_MINFO_DATAA;

typedef struct
{
    PWSTR           pNameExchange;
    WORD            wPreference;
    WORD            Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATAW, *PDNS_MX_DATAW;

typedef struct
{
    PSTR            pNameExchange;
    WORD            wPreference;
    WORD            Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATAA, *PDNS_MX_DATAA;

typedef struct
{
    DWORD           dwStringCount;
#ifdef MIDL_PASS
    [size_is(dwStringCount)] PWSTR pStringArray[];
#else
    PWSTR           pStringArray[1];
#endif
}
DNS_TXT_DATAW, *PDNS_TXT_DATAW;

typedef struct
{
    DWORD           dwStringCount;
#ifdef MIDL_PASS
    [size_is(dwStringCount)] PSTR  pStringArray[];
#else
    PSTR            pStringArray[1];
#endif
}
DNS_TXT_DATAA, *PDNS_TXT_DATAA;

typedef struct
{
    DWORD           dwByteCount;
#ifdef MIDL_PASS
    [size_is(dwByteCount)] BYTE Data[];
#else
    BYTE            Data[1];
#endif
}
DNS_NULL_DATA, *PDNS_NULL_DATA;

typedef struct
{
    IP4_ADDRESS     IpAddress;
    UCHAR           chProtocol;
    BYTE            BitMask[1];
}
DNS_WKS_DATA, *PDNS_WKS_DATA;

typedef struct
{
    IP6_ADDRESS     Ip6Address;
}
DNS_AAAA_DATA, *PDNS_AAAA_DATA;

typedef struct
{
    WORD            wTypeCovered;
    BYTE            chAlgorithm;
    BYTE            chLabelCount;
    DWORD           dwOriginalTtl;
    DWORD           dwExpiration;
    DWORD           dwTimeSigned;
    WORD            wKeyTag;
    WORD            wSignatureLength;
    PWSTR           pNameSigner;
    BYTE            Signature[1];
}
DNS_SIG_DATAW, *PDNS_SIG_DATAW, DNS_RRSIG_DATAW, *PDNS_RRSIG_DATAW;

typedef struct
{
    WORD            wTypeCovered;
    BYTE            chAlgorithm;
    BYTE            chLabelCount;
    DWORD           dwOriginalTtl;
    DWORD           dwExpiration;
    DWORD           dwTimeSigned;
    WORD            wKeyTag;
    WORD            wSignatureLength;    
    PSTR            pNameSigner;
    BYTE            Signature[1];
}
DNS_SIG_DATAA, *PDNS_SIG_DATAA, DNS_RRSIG_DATAA, *PDNS_RRSIG_DATAA;

typedef struct
{
    WORD            wFlags;
    BYTE            chProtocol;
    BYTE            chAlgorithm;
    WORD            wKeyLength;
    WORD            wPad;            // keep byte field aligned
    BYTE            Key[1];
}
DNS_KEY_DATA, *PDNS_KEY_DATA, DNS_DNSKEY_DATA, *PDNS_DNSKEY_DATA;

typedef struct
{
    DWORD           dwByteCount;
#ifdef MIDL_PASS
    [size_is(dwByteCount)] BYTE DHCID[];
#else
    BYTE            DHCID[1];
#endif
}
DNS_DHCID_DATA, *PDNS_DHCID_DATA;

typedef struct
{
    PWSTR           pNextDomainName;
    WORD            wTypeBitMapsLength;
    WORD            wPad;            // keep byte field aligned
    BYTE            TypeBitMaps[1];
}
DNS_NSEC_DATAW, *PDNS_NSEC_DATAW;

typedef struct
{
    PSTR            pNextDomainName;
    WORD            wTypeBitMapsLength;
    WORD            wPad;            // keep byte field aligned
    BYTE            TypeBitMaps[1];
}
DNS_NSEC_DATAA, *PDNS_NSEC_DATAA;

typedef struct
{
    WORD            wKeyTag;
    BYTE            chAlgorithm;
    BYTE            chDigestType;
    WORD            wDigestLength;
    WORD            wPad;            // keep byte field aligned
    BYTE            Digest[1];
}
DNS_DS_DATA, *PDNS_DS_DATA;

typedef struct
{
    WORD            wDataLength;
    WORD            wPad;            // keep byte field aligned
    BYTE            Data[1];
}
DNS_OPT_DATA, *PDNS_OPT_DATA;

typedef struct
{
    WORD            wVersion;
    WORD            wSize;
    WORD            wHorPrec;
    WORD            wVerPrec;
    DWORD           dwLatitude;
    DWORD           dwLongitude;
    DWORD           dwAltitude;
}
DNS_LOC_DATA, *PDNS_LOC_DATA;

typedef struct
{
    PWSTR           pNameNext;
    WORD            wNumTypes;
    WORD            wTypes[1];
}
DNS_NXT_DATAW, *PDNS_NXT_DATAW;

typedef struct
{
    PSTR            pNameNext;
    WORD            wNumTypes;
    WORD            wTypes[1];
}
DNS_NXT_DATAA, *PDNS_NXT_DATAA;

typedef struct
{
    PWSTR           pNameTarget;
    WORD            wPriority;
    WORD            wWeight;
    WORD            wPort;
    WORD            Pad;            // keep ptrs DWORD aligned
}
DNS_SRV_DATAW, *PDNS_SRV_DATAW;

typedef struct
{
    PSTR            pNameTarget;
    WORD            wPriority;
    WORD            wWeight;
    WORD            wPort;
    WORD            Pad;            // keep ptrs DWORD aligned
}
DNS_SRV_DATAA, *PDNS_SRV_DATAA;

typedef struct
{
    WORD            wOrder;
    WORD            wPreference;
    PWSTR           pFlags;
    PWSTR           pService;
    PWSTR           pRegularExpression;
    PWSTR           pReplacement;
}
DNS_NAPTR_DATAW, *PDNS_NAPTR_DATAW;

typedef struct
{
    WORD            wOrder;
    WORD            wPreference;
    PSTR            pFlags;
    PSTR            pService;
    PSTR            pRegularExpression;
    PSTR            pReplacement;
}
DNS_NAPTR_DATAA, *PDNS_NAPTR_DATAA;



typedef struct
{
    BYTE            AddressType;
    BYTE            Address[ DNS_ATMA_MAX_ADDR_LENGTH ];

    //  E164 -- Null terminated string of less than
    //      DNS_ATMA_MAX_ADDR_LENGTH
    //
    //  For NSAP (AESA) BCD encoding of exactly
    //      DNS_ATMA_AESA_ADDR_LENGTH
}
DNS_ATMA_DATA, *PDNS_ATMA_DATA;


typedef struct
{
    PWSTR           pNameAlgorithm;
    PBYTE           pAlgorithmPacket;
    PBYTE           pKey;
    PBYTE           pOtherData;
    DWORD           dwCreateTime;
    DWORD           dwExpireTime;
    WORD            wMode;
    WORD            wError;
    WORD            wKeyLength;
    WORD            wOtherLength;
    UCHAR           cAlgNameLength;
    BOOL            bPacketPointers;
}
DNS_TKEY_DATAW, *PDNS_TKEY_DATAW;

typedef struct
{
    PSTR            pNameAlgorithm;
    PBYTE           pAlgorithmPacket;
    PBYTE           pKey;
    PBYTE           pOtherData;
    DWORD           dwCreateTime;
    DWORD           dwExpireTime;
    WORD            wMode;
    WORD            wError;
    WORD            wKeyLength;
    WORD            wOtherLength;
    UCHAR           cAlgNameLength;
    BOOL            bPacketPointers;
}
DNS_TKEY_DATAA, *PDNS_TKEY_DATAA;

typedef struct
{
    PWSTR           pNameAlgorithm;
    PBYTE           pAlgorithmPacket;
    PBYTE           pSignature;
    PBYTE           pOtherData;
    LONGLONG        i64CreateTime;
    WORD            wFudgeTime;
    WORD            wOriginalXid;
    WORD            wError;
    WORD            wSigLength;
    WORD            wOtherLength;
    UCHAR           cAlgNameLength;
    BOOL            bPacketPointers;
}
DNS_TSIG_DATAW, *PDNS_TSIG_DATAW;

typedef struct
{
    PSTR            pNameAlgorithm;
    PBYTE           pAlgorithmPacket;
    PBYTE           pSignature;
    PBYTE           pOtherData;
    LONGLONG        i64CreateTime;
    WORD            wFudgeTime;
    WORD            wOriginalXid;
    WORD            wError;
    WORD            wSigLength;
    WORD            wOtherLength;
    UCHAR           cAlgNameLength;
    BOOL            bPacketPointers;
}
DNS_TSIG_DATAA, *PDNS_TSIG_DATAA;

//
//  MS only types -- only hit the wire in MS-MS zone transfer
//

typedef struct
{
    DWORD           dwMappingFlag;
    DWORD           dwLookupTimeout;
    DWORD           dwCacheTimeout;
    DWORD           cWinsServerCount;
    IP4_ADDRESS     WinsServers[1];
}
DNS_WINS_DATA, *PDNS_WINS_DATA;

typedef struct
{
    DWORD           dwMappingFlag;
    DWORD           dwLookupTimeout;
    DWORD           dwCacheTimeout;
    PWSTR           pNameResultDomain;
}
DNS_WINSR_DATAW, *PDNS_WINSR_DATAW;

typedef struct
{
    DWORD           dwMappingFlag;
    DWORD           dwLookupTimeout;
    DWORD           dwCacheTimeout;
    PSTR            pNameResultDomain;
}
DNS_WINSR_DATAA, *PDNS_WINSR_DATAA;

//
//  Unicode/ANSI record types
//

#ifdef UNICODE
typedef DNS_PTR_DATAW   DNS_PTR_DATA,   *PDNS_PTR_DATA;
typedef DNS_SOA_DATAW   DNS_SOA_DATA,   *PDNS_SOA_DATA;
typedef DNS_MINFO_DATAW DNS_MINFO_DATA, *PDNS_MINFO_DATA;
typedef DNS_MX_DATAW    DNS_MX_DATA,    *PDNS_MX_DATA;
typedef DNS_TXT_DATAW   DNS_TXT_DATA,   *PDNS_TXT_DATA;
typedef DNS_SIG_DATAW   DNS_SIG_DATA,   *PDNS_SIG_DATA;
typedef DNS_NXT_DATAW   DNS_NXT_DATA,   *PDNS_NXT_DATA;
typedef DNS_SRV_DATAW   DNS_SRV_DATA,   *PDNS_SRV_DATA;
typedef DNS_NAPTR_DATAW DNS_NAPTR_DATA, *PDNS_NAPTR_DATA;
typedef DNS_RRSIG_DATAW DNS_RRSIG_DATA, *PDNS_RRSIG_DATA;
typedef DNS_NSEC_DATAW  DNS_NSEC_DATA,  *PDNS_NSEC_DATA;
typedef DNS_TKEY_DATAW  DNS_TKEY_DATA,  *PDNS_TKEY_DATA;
typedef DNS_TSIG_DATAW  DNS_TSIG_DATA,  *PDNS_TSIG_DATA;
typedef DNS_WINSR_DATAW DNS_WINSR_DATA, *PDNS_WINSR_DATA;
#else
typedef DNS_PTR_DATAA   DNS_PTR_DATA,   *PDNS_PTR_DATA;
typedef DNS_SOA_DATAA   DNS_SOA_DATA,   *PDNS_SOA_DATA;
typedef DNS_MINFO_DATAA DNS_MINFO_DATA, *PDNS_MINFO_DATA;
typedef DNS_MX_DATAA    DNS_MX_DATA,    *PDNS_MX_DATA;
typedef DNS_TXT_DATAA   DNS_TXT_DATA,   *PDNS_TXT_DATA;
typedef DNS_SIG_DATAA   DNS_SIG_DATA,   *PDNS_SIG_DATA;
typedef DNS_NXT_DATAA   DNS_NXT_DATA,   *PDNS_NXT_DATA;
typedef DNS_SRV_DATAA   DNS_SRV_DATA,   *PDNS_SRV_DATA;
typedef DNS_NAPTR_DATAA DNS_NAPTR_DATA, *PDNS_NAPTR_DATA;
typedef DNS_RRSIG_DATAA DNS_RRSIG_DATA, *PDNS_RRSIG_DATA;
typedef DNS_NSEC_DATAA  DNS_NSEC_DATA,  *PDNS_NSEC_DATA;
typedef DNS_TKEY_DATAA  DNS_TKEY_DATA,  *PDNS_TKEY_DATA;
typedef DNS_TSIG_DATAA  DNS_TSIG_DATA,  *PDNS_TSIG_DATA;
typedef DNS_WINSR_DATAA DNS_WINSR_DATA, *PDNS_WINSR_DATA;
#endif

//
//  Length of non-fixed-length data types
//

#define DNS_TEXT_RECORD_LENGTH(StringCount) \
            (FIELD_OFFSET(DNS_TXT_DATA, pStringArray) + ((StringCount) * sizeof(PCHAR)))

#define DNS_NULL_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_NULL_DATA, Data) + (ByteCount))

#define DNS_WKS_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_WKS_DATA, BitMask) + (ByteCount))

#define DNS_WINS_RECORD_LENGTH(IpCount) \
            (FIELD_OFFSET(DNS_WINS_DATA, WinsServers) + ((IpCount) * sizeof(IP4_ADDRESS)))

#define DNS_KEY_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_KEY_DATA, Key) + (ByteCount))

#define DNS_SIG_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_SIG_DATA, Signature) + (ByteCount))

#define DNS_NSEC_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_NSEC_DATA, TypeBitMaps) + (ByteCount))

#define DNS_DS_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_DS_DATA, Digest) + (ByteCount))

#define DNS_OPT_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_OPT_DATA, Data) + (ByteCount))

#define DNS_DHCID_RECORD_LENGTH(ByteCount) \
            (FIELD_OFFSET(DNS_DHCID_DATA, DHCID) + (ByteCount))         
            
//
//  Record flags
//

typedef struct _DnsRecordFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;
    DWORD   Unused      : 3;

    DWORD   Reserved    : 24;
}
DNS_RECORD_FLAGS;


//
//  Wire Record Sections
//
//  Useable both in record flags "Section" and as index into
//  wire message header section counts.
//

typedef enum _DnsSection
{
    DnsSectionQuestion,
    DnsSectionAnswer,
    DnsSectionAuthority,
    DnsSectionAddtional,
}
DNS_SECTION;

//  Update message section names

#define DnsSectionZone      DnsSectionQuestion
#define DnsSectionPrereq    DnsSectionAnswer
#define DnsSectionUpdate    DnsSectionAuthority


//
//  Record flags as bit flags
//  These may be or'd together to set the fields
//

//  RR Section in packet

#define     DNSREC_SECTION      (0x00000003)

#define     DNSREC_QUESTION     (0x00000000)
#define     DNSREC_ANSWER       (0x00000001)
#define     DNSREC_AUTHORITY    (0x00000002)
#define     DNSREC_ADDITIONAL   (0x00000003)

//  RR Section in packet (update)

#define     DNSREC_ZONE         (0x00000000)
#define     DNSREC_PREREQ       (0x00000001)
#define     DNSREC_UPDATE       (0x00000002)

//  Delete RR (update) or No-exist (prerequisite)

#define     DNSREC_DELETE       (0x00000004)
#define     DNSREC_NOEXIST      (0x00000004)


//
//  Record \ RR set structure
//
//  Note:  The dwReserved flag serves to insure that the substructures
//  start on 64-bit boundaries.  Do NOT pack this structure, as the
//  substructures may contain pointers or int64 values which are
//  properly aligned unpacked.
//

#ifdef MIDL_PASS

#define PDNS_RECORD     PVOID
#define PDNS_RECORDA    PVOID
#define PDNS_RECORDW    PVOID

#else

typedef struct _DnsRecordW
{
    struct _DnsRecordW *    pNext;
    PWSTR                   pName;
    WORD                    wType;
    WORD                    wDataLength;    // Not referenced for DNS record types
                                            // defined above.
    union
    {
        DWORD               DW;     // flags as DWORD
        DNS_RECORD_FLAGS    S;      // flags as structure

    } Flags;

    DWORD                   dwTtl;
    DWORD                   dwReserved;
    
    //  Record Data

    union
    {
        DNS_A_DATA          A;
        DNS_SOA_DATAW       SOA, Soa;
        DNS_PTR_DATAW       PTR, Ptr,
                            NS, Ns,
                            CNAME, Cname,
                            DNAME, Dname,
                            MB, Mb,
                            MD, Md,
                            MF, Mf,
                            MG, Mg,
                            MR, Mr;
        DNS_MINFO_DATAW     MINFO, Minfo,
                            RP, Rp;
        DNS_MX_DATAW        MX, Mx,
                            AFSDB, Afsdb,
                            RT, Rt;
        DNS_TXT_DATAW       HINFO, Hinfo,
                            ISDN, Isdn,
                            TXT, Txt,
                            X25;
        DNS_NULL_DATA       Null;
        DNS_WKS_DATA        WKS, Wks;
        DNS_AAAA_DATA       AAAA;
        DNS_KEY_DATA        KEY, Key;
        DNS_SIG_DATAW       SIG, Sig;
        DNS_ATMA_DATA       ATMA, Atma;
        DNS_NXT_DATAW       NXT, Nxt;
        DNS_SRV_DATAW       SRV, Srv;
        DNS_NAPTR_DATAW     NAPTR, Naptr;
        DNS_OPT_DATA        OPT, Opt;
        DNS_DS_DATA         DS, Ds;
        DNS_RRSIG_DATAW     RRSIG, Rrsig;
        DNS_NSEC_DATAW      NSEC, Nsec;
        DNS_DNSKEY_DATA     DNSKEY, Dnskey;
        DNS_TKEY_DATAW      TKEY, Tkey;
        DNS_TSIG_DATAW      TSIG, Tsig;
        DNS_WINS_DATA       WINS, Wins;
        DNS_WINSR_DATAW     WINSR, WinsR, NBSTAT, Nbstat;
        DNS_DHCID_DATA      DHCID;

    } Data;    
}
DNS_RECORDW, *PDNS_RECORDW;

typedef struct _DnsRecordOptW
{
    struct _DnsRecordW *    pNext;
    PWSTR                   pName;
    WORD                    wType;
    WORD                    wDataLength;    // Not referenced for DNS record types
                                            // defined above.
    union
    {
        DWORD               DW;     // flags as DWORD
        DNS_RECORD_FLAGS    S;      // flags as structure

    } Flags;

    DNS_HEADER_EXT          ExtHeader;      // TTL        
    WORD                    wPayloadSize;   // dwReserved;
    WORD                    wReserved;
    
    //  Record Data
    union
    {
        DNS_OPT_DATA        OPT, Opt;
        
    } Data;    
}
DNS_RECORD_OPTW, *PDNS_RECORD_OPTW;


typedef struct _DnsRecordA
{
    struct _DnsRecordA *    pNext;
    PSTR                    pName;
    WORD                    wType;
    WORD                    wDataLength; // Not referenced for DNS record types
                                     // defined above.
    union
    {
        DWORD               DW;     // flags as DWORD
        DNS_RECORD_FLAGS    S;      // flags as structure

    } Flags;
    
    DWORD               dwTtl;    
    DWORD               dwReserved;

    //  Record Data

    union
    {
        DNS_A_DATA          A;
        DNS_SOA_DATAA       SOA, Soa;
        DNS_PTR_DATAA       PTR, Ptr,
                            NS, Ns,
                            CNAME, Cname,
                            DNAME, Dname,
                            MB, Mb,
                            MD, Md,
                            MF, Mf,
                            MG, Mg,
                            MR, Mr;
        DNS_MINFO_DATAA     MINFO, Minfo,
                            RP, Rp;
        DNS_MX_DATAA        MX, Mx,
                            AFSDB, Afsdb,
                            RT, Rt;
        DNS_TXT_DATAA       HINFO, Hinfo,
                            ISDN, Isdn,
                            TXT, Txt,
                            X25;
        DNS_NULL_DATA       Null;
        DNS_WKS_DATA        WKS, Wks;
        DNS_AAAA_DATA       AAAA;
        DNS_KEY_DATA        KEY, Key;
        DNS_SIG_DATAA       SIG, Sig;
        DNS_ATMA_DATA       ATMA, Atma;
        DNS_NXT_DATAA       NXT, Nxt;
        DNS_SRV_DATAA       SRV, Srv;
        DNS_NAPTR_DATAA     NAPTR, Naptr;
        DNS_OPT_DATA        OPT, Opt;
        DNS_DS_DATA         DS, Ds;
        DNS_RRSIG_DATAA     RRSIG, Rrsig;
        DNS_NSEC_DATAA      NSEC, Nsec;
        DNS_DNSKEY_DATA     DNSKEY, Dnskey;
        DNS_TKEY_DATAA      TKEY, Tkey;
        DNS_TSIG_DATAA      TSIG, Tsig;
        DNS_WINS_DATA       WINS, Wins;
        DNS_WINSR_DATAA     WINSR, WinsR, NBSTAT, Nbstat;
        DNS_DHCID_DATA      DHCID;

    } Data;
}
DNS_RECORDA, *PDNS_RECORDA;


typedef struct _DnsRecordOptA
{
    struct _DnsRecordA *    pNext;
    PSTR                    pName;
    WORD                    wType;
    WORD                    wDataLength; // Not referenced for DNS record types
                                     // defined above.
    union
    {
        DWORD               DW;     // flags as DWORD
        DNS_RECORD_FLAGS    S;      // flags as structure

    } Flags;

    DNS_HEADER_EXT          ExtHeader;      // TTL        
    WORD                    wPayloadSize;   // dwReserved;
    WORD                    wReserved;

    //  Record Data

    union
    {
        DNS_OPT_DATA        OPT, Opt;

    } Data;
}
DNS_RECORD_OPTA, *PDNS_RECORD_OPTA;


#ifdef UNICODE
typedef DNS_RECORDW         DNS_RECORD, *PDNS_RECORD;
typedef DNS_RECORD_OPTW     DNS_RECORD_OPT, *PDNS_RECORD_OPT;
#else
typedef DNS_RECORDA         DNS_RECORD, *PDNS_RECORD;
typedef DNS_RECORD_OPTA     DNS_RECORD_OPT, *PDNS_RECORD_OPT;
#endif

//
//  Header or fixed size of DNS_RECORD
//

#define DNS_RECORD_FIXED_SIZE       FIELD_OFFSET( DNS_RECORD, Data )
#define SIZEOF_DNS_RECORD_HEADER    DNS_RECORD_FIXED_SIZE

#endif  // PRIVATE_DNS_RECORD



//
//  Resource record set building
//
//  pFirst points to first record in list.
//  pLast points to last record in list.
//

typedef struct _DnsRRSet
{
    PDNS_RECORD     pFirstRR;
    PDNS_RECORD     pLastRR;
}
DNS_RRSET, *PDNS_RRSET;


//
//  To init pFirst is NULL.
//  But pLast points at the location of the pFirst pointer -- essentially
//  treating the pFirst ptr as a DNS_RECORD.  (It is a DNS_RECORD with
//  only a pNext field, but that's the only part we use.)
//
//  Then when the first record is added to the list, the pNext field of
//  this dummy record (which corresponds to pFirst's value) is set to
//  point at the first record.  So pFirst then properly points at the
//  first record.
//
//  (This works only because pNext is the first field in a
//  DNS_RECORD structure and hence casting a PDNS_RECORD ptr to
//  PDNS_RECORD* and dereferencing yields its pNext field)
//
//  Use TERMINATE when have built RR set by grabbing records out of
//  existing set.   This makes sure that at the end, the last RR is
//  properly NULL terminated.
//

#define DNS_RRSET_INIT( rrset )                 \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            _prrset->pFirstRR = NULL;           \
            _prrset->pLastRR = (PDNS_RECORD) &_prrset->pFirstRR; \
        }

#define DNS_RRSET_ADD( rrset, pnewRR )          \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            PDNS_RECORD _prrnew = (pnewRR);     \
            _prrset->pLastRR->pNext = _prrnew;  \
            _prrset->pLastRR = _prrnew;         \
        }

#define DNS_RRSET_TERMINATE( rrset )            \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            _prrset->pLastRR->pNext = NULL;     \
        }



typedef
VOID
(WINAPI *DNS_PROXY_COMPLETION_ROUTINE) (
    __in_opt void *completionContext,
    __in DNS_STATUS status);


typedef enum DNS_PROXY_INFORMATION_TYPE {
                DNS_PROXY_INFORMATION_DIRECT,
                DNS_PROXY_INFORMATION_DEFAULT_SETTINGS,
                DNS_PROXY_INFORMATION_PROXY_NAME,
                DNS_PROXY_INFORMATION_DOES_NOT_EXIST
}   DNS_PROXY_INFORMATION_TYPE;

typedef struct DNS_PROXY_INFORMATION {
                __in ULONG version;  // Current version is 1
                __out DNS_PROXY_INFORMATION_TYPE proxyInformationType;
                __out_opt PWSTR proxyName;
} DNS_PROXY_INFORMATION;

//
//  Record set manipulation
//

//
//  Record Copy
//  Record copy functions also do conversion between character sets.
//
//  Note, it might be advisable to directly expose non-Ex copy
//  functions _W, _A for record and set, to avoid exposing the
//  conversion enum.
//

typedef enum _DNS_CHARSET
{
    DnsCharSetUnknown,
    DnsCharSetUnicode,
    DnsCharSetUtf8,
    DnsCharSetAnsi,
}
DNS_CHARSET;


PDNS_RECORD
WINAPI
DnsRecordCopyEx(
    __in    PDNS_RECORD     pRecord,
    __in    DNS_CHARSET     CharSetIn,
    __in    DNS_CHARSET     CharSetOut
    );

PDNS_RECORD
WINAPI
DnsRecordSetCopyEx(
    __in    PDNS_RECORD     pRecordSet,
    __in    DNS_CHARSET     CharSetIn,
    __in    DNS_CHARSET     CharSetOut
    );

#ifdef UNICODE
#define DnsRecordCopy(pRR)  \
        DnsRecordCopyEx( (pRR), DnsCharSetUnicode, DnsCharSetUnicode )
#define DnsRecordSetCopy(pRR)  \
        DnsRecordSetCopyEx( (pRR), DnsCharSetUnicode, DnsCharSetUnicode )
#else
#define DnsRecordCopy(pRR)  \
        DnsRecordCopyEx( (pRR), DnsCharSetAnsi, DnsCharSetAnsi )
#define DnsRecordSetCopy(pRR)  \
        DnsRecordSetCopyEx( (pRR), DnsCharSetAnsi, DnsCharSetAnsi )
#endif


//
//  Record Compare
//
//  Note:  these routines only compare records of the SAME character set.
//  (ANSI, unicode or UTF8).  Furthermore the routines assume the character
//  set is indicated within the record.  If compare of user created, rather
//  than DNS API created record lists is desired, then caller should use
//  DnsRecordCopy API and compare copies.
//

BOOL
WINAPI
DnsRecordCompare(
    __in            PDNS_RECORD     pRecord1,
    __in            PDNS_RECORD     pRecord2
    );

BOOL
WINAPI
DnsRecordSetCompare(
    __inout                 PDNS_RECORD     pRR1,
    __inout                 PDNS_RECORD     pRR2,
    __deref_opt_out_opt     PDNS_RECORD *   ppDiff1,
    __deref_opt_out_opt     PDNS_RECORD *   ppDiff2
    );

//
//  Detach next record set from record list
//

PDNS_RECORD
DnsRecordSetDetach(
    __inout         PDNS_RECORD     pRecordList
    );

//
//  Free structures returned from dnsapi.dll
//
//  Currently supported free structures:
//      Flat -- flat structure, including those allocated by DnsQueryConfig()
//      RecordList -- deep record list free, including sub-fields of DNS_RECORD;
//          includes those returned by DnsQuery() or DnsRecordSetCopy()
//

typedef enum
{
    DnsFreeFlat = 0,
    DnsFreeRecordList,
    DnsFreeParsedMessageFields
}
DNS_FREE_TYPE;

VOID
WINAPI
DnsFree(
    __inout     PVOID           pData,
    __in        DNS_FREE_TYPE   FreeType
    );

//
//  Backward compatibility with Win2K, do not use for XP+ applications
//
//  To free record lists, code
//      DnsFree( pRecordList, DnsFreeRecordList );
//

#define DnsFreeRecordListDeep   DnsFreeRecordList

#if(_WIN32_WINNT >= 0x0501)
#define DnsRecordListFree(p,t)  DnsFree(p,DnsFreeRecordList)
#else
VOID
WINAPI
DnsRecordListFree(
    __inout_opt PDNS_RECORD     pRecordList,
    __in        DNS_FREE_TYPE   FreeType
    );
#endif /* _WIN32_WINNT >= 0x0501 */



//
//  DNS Query API
//

//
//  Options for DnsQuery
//

#define DNS_QUERY_STANDARD                  0x00000000
#define DNS_QUERY_ACCEPT_TRUNCATED_RESPONSE 0x00000001
#define DNS_QUERY_USE_TCP_ONLY              0x00000002
#define DNS_QUERY_NO_RECURSION              0x00000004
#define DNS_QUERY_BYPASS_CACHE              0x00000008

#define DNS_QUERY_NO_WIRE_QUERY             0x00000010
#define DNS_QUERY_NO_LOCAL_NAME             0x00000020
#define DNS_QUERY_NO_HOSTS_FILE             0x00000040
#define DNS_QUERY_NO_NETBT                  0x00000080

#define DNS_QUERY_WIRE_ONLY                 0x00000100
#define DNS_QUERY_RETURN_MESSAGE            0x00000200

#define DNS_QUERY_MULTICAST_ONLY            0x00000400
#define DNS_QUERY_NO_MULTICAST              0x00000800

#define DNS_QUERY_TREAT_AS_FQDN             0x00001000
#define DNS_QUERY_APPEND_MULTILABEL         0x00800000

#define DNS_QUERY_DONT_RESET_TTL_VALUES     0x00100000
#define DNS_QUERY_RESERVED                  0xf0000000



//  Backward compatibility with Win2K
//  Do not use

#define DNS_QUERY_CACHE_ONLY                DNS_QUERY_NO_WIRE_QUERY



DNS_STATUS
WINAPI
DnsQuery_A(
    __in                PCSTR           pszName,
    __in                WORD            wType,
    __in                DWORD           Options,
    __inout_opt         PVOID           pExtra,
    __deref_out_opt     PDNS_RECORD *   ppQueryResults,
    __deref_opt_out_opt PVOID *         pReserved
    );

DNS_STATUS
WINAPI
DnsQuery_UTF8(
    __in                PCSTR           pszName,
    __in                WORD            wType,
    __in                DWORD           Options,
    __inout_opt         PVOID           pExtra,
    __deref_out_opt     PDNS_RECORD *   ppQueryResults,
    __deref_opt_out_opt PVOID *         pReserved
    );

DNS_STATUS
WINAPI
DnsQuery_W(
    __in                PCWSTR          pszName,
    __in                WORD            wType,
    __in                DWORD           Options,
    __inout_opt         PVOID           pExtra,
    __deref_out_opt     PDNS_RECORD *   ppQueryResults,
    __deref_opt_out_opt PVOID *         pReserved
    );

#ifdef UNICODE
#define DnsQuery DnsQuery_W
#else
#define DnsQuery DnsQuery_A
#endif




//
//  DNS Update API
//
//      DnsAcquireContextHandle
//      DnsReleaseContextHandle
//      DnsModifyRecordsInSet
//      DnsReplaceRecordSet
//

//
//  Update flags
//

#define DNS_UPDATE_SECURITY_USE_DEFAULT     0x00000000
#define DNS_UPDATE_SECURITY_OFF             0x00000010
#define DNS_UPDATE_SECURITY_ON              0x00000020
#define DNS_UPDATE_SECURITY_ONLY            0x00000100
#define DNS_UPDATE_CACHE_SECURITY_CONTEXT   0x00000200
#define DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT  0x00000400
#define DNS_UPDATE_FORCE_SECURITY_NEGO      0x00000800
#define DNS_UPDATE_TRY_ALL_MASTER_SERVERS   0x00001000
#define DNS_UPDATE_SKIP_NO_UPDATE_ADAPTERS  0x00002000
#define DNS_UPDATE_REMOTE_SERVER            0x00004000
#define DNS_UPDATE_RESERVED                 0xffff0000


//
//  Note:  pCredentials paramater is currently respectively
//  PSEC_WINNT_AUTH_IDENTITY_W or PSEC_WINNT_AUTH_IDENTITY_A.
//  Using PVOID to obviate the need for including rpcdce.h
//  in order to include this file and to leave open the
//  possibility of alternative credential specifications in
//  the future.
//

DNS_STATUS
WINAPI
DnsAcquireContextHandle_W(
    __in            DWORD           CredentialFlags,
    __in_opt        PVOID           Credentials,
    __deref_out     PHANDLE         pContext
    );

DNS_STATUS
WINAPI
DnsAcquireContextHandle_A(
    __in            DWORD           CredentialFlags,
    __in_opt        PVOID           Credentials,
    __deref_out     PHANDLE         pContext
    );

#ifdef UNICODE
#define DnsAcquireContextHandle DnsAcquireContextHandle_W
#else
#define DnsAcquireContextHandle DnsAcquireContextHandle_A
#endif

VOID
WINAPI
DnsReleaseContextHandle(
    __in        HANDLE          hContext
    );

//
//  Dynamic Update API
//

DNS_STATUS
WINAPI
DnsModifyRecordsInSet_W(
    __in_opt        PDNS_RECORD     pAddRecords,
    __in_opt        PDNS_RECORD     pDeleteRecords,
    __in            DWORD           Options,
    __in_opt        HANDLE          hCredentials,
    __inout_opt     PVOID           pExtraList,
    __inout_opt     PVOID           pReserved
    );

DNS_STATUS
WINAPI
DnsModifyRecordsInSet_A(
    __in_opt        PDNS_RECORD     pAddRecords,
    __in_opt        PDNS_RECORD     pDeleteRecords,
    __in            DWORD           Options,
    __in_opt        HANDLE          hCredentials,
    __inout_opt     PVOID           pExtraList,
    __inout_opt     PVOID           pReserved
    );

DNS_STATUS
WINAPI
DnsModifyRecordsInSet_UTF8(
    __in_opt        PDNS_RECORD     pAddRecords,
    __in_opt        PDNS_RECORD     pDeleteRecords,
    __in            DWORD           Options,
    __in_opt        HANDLE          hCredentials,
    __inout_opt     PVOID           pExtraList,
    __inout_opt     PVOID           pReserved
    );

#ifdef UNICODE
#define DnsModifyRecordsInSet  DnsModifyRecordsInSet_W
#else
#define DnsModifyRecordsInSet  DnsModifyRecordsInSet_A
#endif


DNS_STATUS
WINAPI
DnsReplaceRecordSetW(
    __in            PDNS_RECORD     pReplaceSet,
    __in            DWORD           Options,
    __in_opt        HANDLE          hContext,
    __inout_opt     PVOID           pExtraInfo,
    __inout_opt     PVOID           pReserved
    );

DNS_STATUS
WINAPI
DnsReplaceRecordSetA(
    __in            PDNS_RECORD     pReplaceSet,
    __in            DWORD           Options,
    __in_opt        HANDLE          hContext,
    __inout_opt     PVOID           pExtraInfo,
    __inout_opt     PVOID           pReserved
    );

DNS_STATUS
WINAPI
DnsReplaceRecordSetUTF8(
    __in            PDNS_RECORD     pReplaceSet,
    __in            DWORD           Options,
    __in_opt        HANDLE          hContext,
    __inout_opt     PVOID           pExtraInfo,
    __inout_opt     PVOID           pReserved
    );

#ifdef UNICODE
#define DnsReplaceRecordSet  DnsReplaceRecordSetW
#else
#define DnsReplaceRecordSet  DnsReplaceRecordSetA
#endif



//
//  DNS name validation
//

typedef enum _DNS_NAME_FORMAT
{
    DnsNameDomain,
    DnsNameDomainLabel,
    DnsNameHostnameFull,
    DnsNameHostnameLabel,
    DnsNameWildcard,
    DnsNameSrvRecord,
    DnsNameValidateTld
}
DNS_NAME_FORMAT;


DNS_STATUS
DnsValidateName_W(
    __in    PCWSTR          pszName,
    __in    DNS_NAME_FORMAT Format
    );

DNS_STATUS
DnsValidateName_A(
    __in    PCSTR           pszName,
    __in    DNS_NAME_FORMAT Format
    );

DNS_STATUS
DnsValidateName_UTF8(
    __in    PCSTR           pszName,
    __in    DNS_NAME_FORMAT Format
    );

#ifdef UNICODE
#define DnsValidateName(p,f)    DnsValidateName_W( (p), (f) )
#else
#define DnsValidateName(p,f)    DnsValidateName_A( (p), (f) )
#endif

//
// DNS server validation
//

// DNS server validation error codes
#define DNS_VALSVR_ERROR_INVALID_ADDR               0x01
#define DNS_VALSVR_ERROR_INVALID_NAME               0x02
#define DNS_VALSVR_ERROR_UNREACHABLE                0x03
#define DNS_VALSVR_ERROR_NO_RESPONSE                0x04
#define DNS_VALSVR_ERROR_NO_AUTH                    0x05
#define DNS_VALSVR_ERROR_REFUSED                    0x06

#define DNS_VALSVR_ERROR_NO_TCP                     0x10
#define DNS_VALSVR_ERROR_UNKNOWN                    0xFF

// Winsock2.h must be included before windns.h to use the validate server function
#ifdef _WS2DEF_

DNS_STATUS
DnsValidateServerStatus(
    __in    PSOCKADDR   server,
    __in    PCWSTR      queryName,
    __out   PDWORD      serverStatus
    );

#endif

//
//  DNS name comparison
//

BOOL
WINAPI
DnsNameCompare_A(
    __in    PCSTR           pName1,
    __in    PCSTR           pName2
    );

BOOL
WINAPI
DnsNameCompare_W(
    __in    PCWSTR          pName1,
    __in    PCWSTR          pName2
    );

#ifdef UNICODE
#define DnsNameCompare(n1,n2)   DnsNameCompare_W( (n1),(n2) )
#else
#define DnsNameCompare(n1,n2)   DnsNameCompare_A( (n1),(n2) )
#endif



//
//  DNS message "roll-your-own" routines
//

typedef struct _DNS_MESSAGE_BUFFER
{
    DNS_HEADER  MessageHead;
    CHAR        MessageBody[1];
}
DNS_MESSAGE_BUFFER, *PDNS_MESSAGE_BUFFER;

BOOL
WINAPI
DnsWriteQuestionToBuffer_W(
    __inout     PDNS_MESSAGE_BUFFER pDnsBuffer,
    __inout     PDWORD              pdwBufferSize,
    __in        PCWSTR              pszName,
    __in        WORD                wType,
    __in        WORD                Xid,
    __in        BOOL                fRecursionDesired
    );

BOOL
WINAPI
DnsWriteQuestionToBuffer_UTF8(
    __inout     PDNS_MESSAGE_BUFFER pDnsBuffer,
    __inout     PDWORD              pdwBufferSize,
    __in        PCSTR               pszName,
    __in        WORD                wType,
    __in        WORD                Xid,
    __in        BOOL                fRecursionDesired
    );

DNS_STATUS
WINAPI
DnsExtractRecordsFromMessage_W(
    __in            PDNS_MESSAGE_BUFFER pDnsBuffer,
    __in            WORD                wMessageLength,
    __deref_out     PDNS_RECORD *       ppRecord
    );

DNS_STATUS
WINAPI
DnsExtractRecordsFromMessage_UTF8(
    __in            PDNS_MESSAGE_BUFFER pDnsBuffer,
    __in            WORD                wMessageLength,
    __deref_out     PDNS_RECORD *       ppRecord
    );




DWORD
WINAPI 
DnsGetProxyInformation(
                __in PCWSTR                                         hostName, 
                __inout DNS_PROXY_INFORMATION                       *proxyInformation,
                __inout_opt DNS_PROXY_INFORMATION                   *defaultProxyInformation,
                __in_opt DNS_PROXY_COMPLETION_ROUTINE               completionRoutine,
                __in_opt void                                       *completionContext);


VOID    DnsFreeProxyName(__inout PWSTR    proxyName);


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _WINDNS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Windows.h ===
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:


    windows.h

Abstract:

    Master include file for Windows applications.

--*/

#ifndef _WINDOWS_
#define _WINDOWS_


#include <sdkddkver.h>

#ifndef _INC_WINDOWS
#define _INC_WINDOWS

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/*  If defined, the following flags inhibit definition
 *     of the indicated items.
 *
 *  NOGDICAPMASKS     - CC_*, LC_*, PC_*, CP_*, TC_*, RC_
 *  NOVIRTUALKEYCODES - VK_*
 *  NOWINMESSAGES     - WM_*, EM_*, LB_*, CB_*
 *  NOWINSTYLES       - WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
 *  NOSYSMETRICS      - SM_*
 *  NOMENUS           - MF_*
 *  NOICONS           - IDI_*
 *  NOKEYSTATES       - MK_*
 *  NOSYSCOMMANDS     - SC_*
 *  NORASTEROPS       - Binary and Tertiary raster ops
 *  NOSHOWWINDOW      - SW_*
 *  OEMRESOURCE       - OEM Resource values
 *  NOATOM            - Atom Manager routines
 *  NOCLIPBOARD       - Clipboard routines
 *  NOCOLOR           - Screen colors
 *  NOCTLMGR          - Control and Dialog routines
 *  NODRAWTEXT        - DrawText() and DT_*
 *  NOGDI             - All GDI defines and routines
 *  NOKERNEL          - All KERNEL defines and routines
 *  NOUSER            - All USER defines and routines
 *  NONLS             - All NLS defines and routines
 *  NOMB              - MB_* and MessageBox()
 *  NOMEMMGR          - GMEM_*, LMEM_*, GHND, LHND, associated routines
 *  NOMETAFILE        - typedef METAFILEPICT
 *  NOMINMAX          - Macros min(a,b) and max(a,b)
 *  NOMSG             - typedef MSG and associated routines
 *  NOOPENFILE        - OpenFile(), OemToAnsi, AnsiToOem, and OF_*
 *  NOSCROLL          - SB_* and scrolling routines
 *  NOSERVICE         - All Service Controller routines, SERVICE_ equates, etc.
 *  NOSOUND           - Sound driver routines
 *  NOTEXTMETRIC      - typedef TEXTMETRIC and associated routines
 *  NOWH              - SetWindowsHook and WH_*
 *  NOWINOFFSETS      - GWL_*, GCL_*, associated routines
 *  NOCOMM            - COMM driver routines
 *  NOKANJI           - Kanji support stuff.
 *  NOHELP            - Help engine interface.
 *  NOPROFILER        - Profiler interface.
 *  NODEFERWINDOWPOS  - DeferWindowPos routines
 *  NOMCX             - Modem Configuration Extensions
 */

#if defined(RC_INVOKED) && !defined(NOWINRES)

#include <winresrc.h>

#else

#if defined(RC_INVOKED)
/* Turn off a bunch of stuff to ensure that RC files compile OK. */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI
#define NOCRYPT
#define NOMCX
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_M68K)
#define _68K_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_MPPC)
#define _MPPC_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_M_IX86) && !defined(_AMD64_) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif /* !_IA64_ */
#endif

#ifndef _MAC
#if defined(_68K_) || defined(_MPPC_)
#define _MAC
#endif
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#ifndef __cplusplus
#pragma warning(disable:4116)       /* TYPE_ALIGNMENT generates this - move it */
                                    /* outside the warning push/pop scope. */
#endif
#endif
#endif

#ifndef RC_INVOKED
#if     ( _MSC_VER >= 800 )
#pragma warning(disable:4514)
#ifndef __WINDOWS_DONT_DISABLE_PRAGMA_PACK_WARNING__
#pragma warning(disable:4103)
#endif
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#endif
#include <excpt.h>
#include <stdarg.h>
#endif /* RC_INVOKED */

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winuser.h>
#if !defined(_MAC) || defined(_WIN32NLS)
#include <winnls.h>
#endif
#ifndef _MAC
#include <wincon.h>
#include <winver.h>
#endif
#if !defined(_MAC) || defined(_WIN32REG)
#include <winreg.h>
#endif
#ifndef _MAC
#include <winnetwk.h>
#endif

#ifndef WIN32_LEAN_AND_MEAN
#include <cderr.h>
#include <dde.h>
#include <ddeml.h>
#include <dlgs.h>
#ifndef _MAC
#include <lzexpand.h>
#include <mmsystem.h>
#include <nb30.h>
#include <rpc.h>
#endif
#include <shellapi.h>
#ifndef _MAC
#include <winperf.h>
#include <winsock.h>
#endif
#ifndef NOCRYPT
#include <wincrypt.h>
#include <winefs.h>
#include <winscard.h>
#endif

#ifndef NOGDI
#ifndef _MAC
#include <winspool.h>
#ifdef INC_OLE1
#include <ole.h>
#else
#include <ole2.h>
#endif /* !INC_OLE1 */
#endif /* !MAC */
#include <commdlg.h>
#endif /* !NOGDI */
#endif /* WIN32_LEAN_AND_MEAN */

#include <stralign.h>

#ifdef _MAC
#include <winwlm.h>
#endif


#ifdef INC_OLE2
#include <ole2.h>
#endif /* INC_OLE2 */

#ifndef _MAC
#ifndef NOSERVICE
#include <winsvc.h>
#endif

#if(WINVER >= 0x0400)
#ifndef NOMCX
#include <mcx.h>
#endif /* NOMCX */

#ifndef NOIME
#include <imm.h>
#endif
#endif /* WINVER >= 0x0400 */
#endif

#ifndef RC_INVOKED
#if     ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4001)
#pragma warning(default:4201)
#pragma warning(default:4214)
/* Leave 4514 disabled.  It's an unneeded warning anyway. */
#endif
#endif
#endif /* RC_INVOKED */

#endif /* RC_INVOKED */

#endif /* _INC_WINDOWS */
#endif /* _WINDOWS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\WinCrypt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       wincrypt.h
//
//  Contents:   Cryptographic API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __WINCRYPT_H__
#define __WINCRYPT_H__

#include <specstrings.h>        /* for SAL annotations */

#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef __success(return >= 0) long HRESULT;
#endif

#ifndef WINADVAPI
#define WINADVAPI
#endif

#ifndef WINAPI
#define WINAPI __stdcall
#endif

#ifndef CALLBACK
#define CALLBACK __stdcall
#endif

#ifndef DECLSPEC_IMPORT
#define DECLSPEC_IMPORT
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#if (NTDDI_VERSION >= NTDDI_WINLH)

#if !defined(WINCRYPT32API)
#if !defined(_CRYPT32_)
#define WINCRYPT32API DECLSPEC_IMPORT
#else
#define WINCRYPT32API
#endif
#endif

#else

#if !defined(_CRYPT32_)
#define WINCRYPT32API DECLSPEC_IMPORT
#else
#define WINCRYPT32API
#endif

#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if !defined(WINCRYPT32STRINGAPI)
#if !defined(_CRYPT32STRING_)
#define WINCRYPT32STRINGAPI WINCRYPT32API
#else
#define WINCRYPT32STRINGAPI
#endif
#endif

//
// Algorithm IDs and Flags
//

// ALG_ID crackers
#define GET_ALG_CLASS(x)                (x & (7 << 13))
#define GET_ALG_TYPE(x)                 (x & (15 << 9))
#define GET_ALG_SID(x)                  (x & (511))

// Algorithm classes
// certenrolld_begin -- ALG_CLASS_*
#define ALG_CLASS_ANY                   (0)
#define ALG_CLASS_SIGNATURE             (1 << 13)
#define ALG_CLASS_MSG_ENCRYPT           (2 << 13)
#define ALG_CLASS_DATA_ENCRYPT          (3 << 13)
#define ALG_CLASS_HASH                  (4 << 13)
#define ALG_CLASS_KEY_EXCHANGE          (5 << 13)
#define ALG_CLASS_ALL                   (7 << 13)
// certenrolld_end

// Algorithm types
#define ALG_TYPE_ANY                    (0)
#define ALG_TYPE_DSS                    (1 << 9)
#define ALG_TYPE_RSA                    (2 << 9)
#define ALG_TYPE_BLOCK                  (3 << 9)
#define ALG_TYPE_STREAM                 (4 << 9)
#define ALG_TYPE_DH                     (5 << 9)
#define ALG_TYPE_SECURECHANNEL          (6 << 9)

// Generic sub-ids
#define ALG_SID_ANY                     (0)

// Some RSA sub-ids
#define ALG_SID_RSA_ANY                 0
#define ALG_SID_RSA_PKCS                1
#define ALG_SID_RSA_MSATWORK            2
#define ALG_SID_RSA_ENTRUST             3
#define ALG_SID_RSA_PGP                 4

// Some DSS sub-ids
//
#define ALG_SID_DSS_ANY                 0
#define ALG_SID_DSS_PKCS                1
#define ALG_SID_DSS_DMS                 2
#if (NTDDI_VERSION >= NTDDI_WINLH)
#define ALG_SID_ECDSA                   3
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

// Block cipher sub ids
// DES sub_ids
#define ALG_SID_DES                     1
#define ALG_SID_3DES                    3
#define ALG_SID_DESX                    4
#define ALG_SID_IDEA                    5
#define ALG_SID_CAST                    6
#define ALG_SID_SAFERSK64               7
#define ALG_SID_SAFERSK128              8
#define ALG_SID_3DES_112                9
#define ALG_SID_CYLINK_MEK              12
#define ALG_SID_RC5                     13
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define ALG_SID_AES_128                 14
#define ALG_SID_AES_192                 15
#define ALG_SID_AES_256                 16
#define ALG_SID_AES                     17
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

// Fortezza sub-ids
#define ALG_SID_SKIPJACK                10
#define ALG_SID_TEK                     11

// KP_MODE
#define CRYPT_MODE_CBCI                 6       // ANSI CBC Interleaved
#define CRYPT_MODE_CFBP                 7       // ANSI CFB Pipelined
#define CRYPT_MODE_OFBP                 8       // ANSI OFB Pipelined
#define CRYPT_MODE_CBCOFM               9       // ANSI CBC + OF Masking
#define CRYPT_MODE_CBCOFMI              10      // ANSI CBC + OFM Interleaved

// RC2 sub-ids
#define ALG_SID_RC2                     2

// Stream cipher sub-ids
#define ALG_SID_RC4                     1
#define ALG_SID_SEAL                    2

// Diffie-Hellman sub-ids
#define ALG_SID_DH_SANDF                1
#define ALG_SID_DH_EPHEM                2
#define ALG_SID_AGREED_KEY_ANY          3
#define ALG_SID_KEA                     4
#if (NTDDI_VERSION >= NTDDI_WINLH)
#define ALG_SID_ECDH                    5
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

// Hash sub ids
#define ALG_SID_MD2                     1
#define ALG_SID_MD4                     2
#define ALG_SID_MD5                     3
#define ALG_SID_SHA                     4
#define ALG_SID_SHA1                    4
#define ALG_SID_MAC                     5
#define ALG_SID_RIPEMD                  6
#define ALG_SID_RIPEMD160               7
#define ALG_SID_SSL3SHAMD5              8
#define ALG_SID_HMAC                    9
#define ALG_SID_TLS1PRF                 10
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define ALG_SID_HASH_REPLACE_OWF        11
#endif //(NTDDI_VERSION >= NTDDI_WINXP)
#if (NTDDI_VERSION > NTDDI_WINXPSP2)
#define ALG_SID_SHA_256                 12
#define ALG_SID_SHA_384                 13
#define ALG_SID_SHA_512                 14
#endif //(NTDDI_VERSION > NTDDI_WINXPSP2)

// secure channel sub ids
#define ALG_SID_SSL3_MASTER             1
#define ALG_SID_SCHANNEL_MASTER_HASH    2
#define ALG_SID_SCHANNEL_MAC_KEY        3
#define ALG_SID_PCT1_MASTER             4
#define ALG_SID_SSL2_MASTER             5
#define ALG_SID_TLS1_MASTER             6
#define ALG_SID_SCHANNEL_ENC_KEY        7

#if (NTDDI_VERSION >= NTDDI_WINLH)
// misc ECC sub ids
#define ALG_SID_ECMQV                   1
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

// Our silly example sub-id
#define ALG_SID_EXAMPLE                 80

// certenrolls_begin -- PROV_ENUMALGS_EX
#ifndef ALGIDDEF
#define ALGIDDEF
typedef unsigned int ALG_ID;
#endif
// certenrolls_end

// algorithm identifier definitions
#define CALG_MD2                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD2)
#define CALG_MD4                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4)
#define CALG_MD5                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5)
#define CALG_SHA                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA)
#define CALG_SHA1               (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA1)
#define CALG_MAC                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MAC)
#define CALG_RSA_SIGN           (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY)
#define CALG_DSS_SIGN           (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | ALG_SID_DSS_ANY)
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define CALG_NO_SIGN            (ALG_CLASS_SIGNATURE | ALG_TYPE_ANY | ALG_SID_ANY)
#endif //(NTDDI_VERSION >= NTDDI_WINXP)
#define CALG_RSA_KEYX           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY)
#define CALG_DES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DES)
#define CALG_3DES_112           (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES_112)
#define CALG_3DES               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES)
#define CALG_DESX               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DESX)
#define CALG_RC2                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC2)
#define CALG_RC4                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_RC4)
#define CALG_SEAL               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_SEAL)
#define CALG_DH_SF              (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_SANDF)
#define CALG_DH_EPHEM           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_EPHEM)
#define CALG_AGREEDKEY_ANY      (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_AGREED_KEY_ANY)
#define CALG_KEA_KEYX           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_KEA)
#define CALG_HUGHES_MD5         (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_ANY|ALG_SID_MD5)
#define CALG_SKIPJACK           (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_SKIPJACK)
#define CALG_TEK                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_TEK)
#define CALG_CYLINK_MEK         (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_CYLINK_MEK)
#define CALG_SSL3_SHAMD5        (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5)
#define CALG_SSL3_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL3_MASTER)
#define CALG_SCHANNEL_MASTER_HASH   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MASTER_HASH)
#define CALG_SCHANNEL_MAC_KEY   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MAC_KEY)
#define CALG_SCHANNEL_ENC_KEY   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_ENC_KEY)
#define CALG_PCT1_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_PCT1_MASTER)
#define CALG_SSL2_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL2_MASTER)
#define CALG_TLS1_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_TLS1_MASTER)
#define CALG_RC5                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC5)
#define CALG_HMAC               (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_HMAC)
#define CALG_TLS1PRF            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_TLS1PRF)
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define CALG_HASH_REPLACE_OWF   (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_HASH_REPLACE_OWF)
#define CALG_AES_128            (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_128)
#define CALG_AES_192            (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_192)
#define CALG_AES_256            (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_256)
#define CALG_AES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES)
#endif //(NTDDI_VERSION >= NTDDI_WINXP)
#if (NTDDI_VERSION > NTDDI_WINXPSP2)
#define CALG_SHA_256            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_256)
#define CALG_SHA_384            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_384)
#define CALG_SHA_512            (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_512)
#endif //(NTDDI_VERSION > NTDDI_WINXPSP2)
#if (NTDDI_VERSION >= NTDDI_WINLH)
#define CALG_ECDH               (ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_DH | ALG_SID_ECDH)
#define CALG_ECMQV              (ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_ANY | ALG_SID_ECMQV)
#define CALG_ECDSA              (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | ALG_SID_ECDSA)
#endif //(NTDDI_VERSION >= NTDDI_WINLH)


#if (NTDDI_VERSION < NTDDI_WINXP)
// resource number for signatures in the CSP
#define SIGNATURE_RESOURCE_NUMBER       0x29A

typedef struct _VTableProvStruc {
    DWORD   Version;
    FARPROC FuncVerifyImage;
    FARPROC FuncReturnhWnd;
    DWORD   dwProvType;
    BYTE        *pbContextInfo;
    DWORD       cbContextInfo;
    LPSTR   pszProvName;
} VTableProvStruc, *PVTableProvStruc;
#endif //(NTDDI_VERSION < NTDDI_WINXP)

// Used for certenroll.idl:
// certenrolls_begin -- HCRYPT*
typedef ULONG_PTR HCRYPTPROV;
typedef ULONG_PTR HCRYPTKEY;
typedef ULONG_PTR HCRYPTHASH;
// certenrolls_end



// dwFlags definitions for CryptAcquireContext
#define CRYPT_VERIFYCONTEXT     0xF0000000
#define CRYPT_NEWKEYSET         0x00000008
#define CRYPT_DELETEKEYSET      0x00000010
#define CRYPT_MACHINE_KEYSET    0x00000020
#define CRYPT_SILENT            0x00000040
#if (NTDDI_VERSION >= NTDDI_WINLH)
#define CRYPT_DEFAULT_CONTAINER_OPTIONAL 0x00000080
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

// dwFlag definitions for CryptGenKey
#define CRYPT_EXPORTABLE        0x00000001
#define CRYPT_USER_PROTECTED    0x00000002
#define CRYPT_CREATE_SALT       0x00000004
#define CRYPT_UPDATE_KEY        0x00000008
#define CRYPT_NO_SALT           0x00000010
#define CRYPT_PREGEN            0x00000040
#define CRYPT_RECIPIENT         0x00000010
#define CRYPT_INITIATOR         0x00000040
#define CRYPT_ONLINE            0x00000080
#define CRYPT_SF                0x00000100
#define CRYPT_CREATE_IV         0x00000200
#define CRYPT_KEK               0x00000400
#define CRYPT_DATA_KEY          0x00000800
#define CRYPT_VOLATILE          0x00001000
#define CRYPT_SGCKEY            0x00002000
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define CRYPT_ARCHIVABLE        0x00004000
#endif //(NTDDI_VERSION >= NTDDI_WINXP)
#if (NTDDI_VERSION >= NTDDI_WINLH)
#define CRYPT_FORCE_KEY_PROTECTION_HIGH 0x00008000
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#define RSA1024BIT_KEY          0x04000000

// dwFlags definitions for CryptDeriveKey
#define CRYPT_SERVER            0x00000400

#define KEY_LENGTH_MASK         0xFFFF0000

// dwFlag definitions for CryptExportKey
#define CRYPT_Y_ONLY            0x00000001
#define CRYPT_SSL2_FALLBACK     0x00000002
#define CRYPT_DESTROYKEY        0x00000004
#define CRYPT_OAEP              0x00000040  // used with RSA encryptions/decryptions
                                            // CryptExportKey, CryptImportKey,
                                            // CryptEncrypt and CryptDecrypt

#define CRYPT_BLOB_VER3         0x00000080  // export version 3 of a blob type
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define CRYPT_IPSEC_HMAC_KEY    0x00000100  // CryptImportKey only
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION >= NTDDI_WS03)
// dwFlags definitions for CryptDecrypt
//  See also CRYPT_OAEP, above.
//  Note, the following flag is not supported for CryptEncrypt
#define CRYPT_DECRYPT_RSA_NO_PADDING_CHECK      0x00000020
#endif //(NTDDI_VERSION >= NTDDI_WS03)

// dwFlags definitions for CryptCreateHash
#define CRYPT_SECRETDIGEST      0x00000001

#if (NTDDI_VERSION >= NTDDI_WINXP)
// dwFlags definitions for CryptHashData
#define CRYPT_OWF_REPL_LM_HASH  0x00000001  // this is only for the OWF replacement CSP
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

// dwFlags definitions for CryptHashSessionKey
#define CRYPT_LITTLE_ENDIAN     0x00000001

// dwFlags definitions for CryptSignHash and CryptVerifySignature
#define CRYPT_NOHASHOID         0x00000001
#define CRYPT_TYPE2_FORMAT      0x00000002
#define CRYPT_X931_FORMAT       0x00000004

// dwFlag definitions for CryptSetProviderEx and CryptGetDefaultProvider
#define CRYPT_MACHINE_DEFAULT   0x00000001
#define CRYPT_USER_DEFAULT      0x00000002
#define CRYPT_DELETE_DEFAULT    0x00000004

// exported key blob definitions
// certenrolld_begin -- *BLOB
#define SIMPLEBLOB              0x1
#define PUBLICKEYBLOB           0x6
#define PRIVATEKEYBLOB          0x7
#define PLAINTEXTKEYBLOB        0x8
#define OPAQUEKEYBLOB           0x9
#define PUBLICKEYBLOBEX         0xA
#define SYMMETRICWRAPKEYBLOB    0xB
#if (NTDDI_VERSION >= NTDDI_WS03)
#define KEYSTATEBLOB            0xC
#endif //(NTDDI_VERSION >= NTDDI_WS03)
// certenrolld_end

// certenrolld_begin -- AT_*
#define AT_KEYEXCHANGE          1
#define AT_SIGNATURE            2
// certenrolld_end

#define CRYPT_USERDATA          1

// dwParam
#define KP_IV                   1       // Initialization vector
#define KP_SALT                 2       // Salt value
#define KP_PADDING              3       // Padding values
#define KP_MODE                 4       // Mode of the cipher
#define KP_MODE_BITS            5       // Number of bits to feedback
#define KP_PERMISSIONS          6       // Key permissions DWORD
#define KP_ALGID                7       // Key algorithm
#define KP_BLOCKLEN             8       // Block size of the cipher
#define KP_KEYLEN               9       // Length of key in bits
#define KP_SALT_EX              10      // Length of salt in bytes
#define KP_P                    11      // DSS/Diffie-Hellman P value
#define KP_G                    12      // DSS/Diffie-Hellman G value
#define KP_Q                    13      // DSS Q value
#define KP_X                    14      // Diffie-Hellman X value
#define KP_Y                    15      // Y value
#define KP_RA                   16      // Fortezza RA value
#define KP_RB                   17      // Fortezza RB value
#define KP_INFO                 18      // for putting information into an RSA envelope
#define KP_EFFECTIVE_KEYLEN     19      // setting and getting RC2 effective key length
#define KP_SCHANNEL_ALG         20      // for setting the Secure Channel algorithms
#define KP_CLIENT_RANDOM        21      // for setting the Secure Channel client random data
#define KP_SERVER_RANDOM        22      // for setting the Secure Channel server random data
#define KP_RP                   23
#define KP_PRECOMP_MD5          24
#define KP_PRECOMP_SHA          25
#define KP_CERTIFICATE          26      // for setting Secure Channel certificate data (PCT1)
#define KP_CLEAR_KEY            27      // for setting Secure Channel clear key data (PCT1)
#define KP_PUB_EX_LEN           28
#define KP_PUB_EX_VAL           29
#define KP_KEYVAL               30
#define KP_ADMIN_PIN            31
#define KP_KEYEXCHANGE_PIN      32
#define KP_SIGNATURE_PIN        33
#define KP_PREHASH              34
#if (NTDDI_VERSION >= NTDDI_WS03)
#define KP_ROUNDS               35
#endif //(NTDDI_VERSION >= NTDDI_WS03)
#define KP_OAEP_PARAMS          36      // for setting OAEP params on RSA keys
#define KP_CMS_KEY_INFO         37
#define KP_CMS_DH_KEY_INFO      38
#define KP_PUB_PARAMS           39      // for setting public parameters
#define KP_VERIFY_PARAMS        40      // for verifying DSA and DH parameters
#define KP_HIGHEST_VERSION      41      // for TLS protocol version setting
#if (NTDDI_VERSION >= NTDDI_WS03)
#define KP_GET_USE_COUNT        42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
#endif //(NTDDI_VERSION >= NTDDI_WS03)
#define KP_PIN_ID               43
#define KP_PIN_INFO             44

// KP_PADDING
#define PKCS5_PADDING           1       // PKCS 5 (sec 6.2) padding method
#define RANDOM_PADDING          2
#define ZERO_PADDING            3

// KP_MODE
#define CRYPT_MODE_CBC          1       // Cipher block chaining
#define CRYPT_MODE_ECB          2       // Electronic code book
#define CRYPT_MODE_OFB          3       // Output feedback mode
#define CRYPT_MODE_CFB          4       // Cipher feedback mode
#define CRYPT_MODE_CTS          5       // Ciphertext stealing mode

// KP_PERMISSIONS
#define CRYPT_ENCRYPT           0x0001  // Allow encryption
#define CRYPT_DECRYPT           0x0002  // Allow decryption
#define CRYPT_EXPORT            0x0004  // Allow key to be exported
#define CRYPT_READ              0x0008  // Allow parameters to be read
#define CRYPT_WRITE             0x0010  // Allow parameters to be set
#define CRYPT_MAC               0x0020  // Allow MACs to be used with key
#define CRYPT_EXPORT_KEY        0x0040  // Allow key to be used for exporting keys
#define CRYPT_IMPORT_KEY        0x0080  // Allow key to be used for importing keys
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define CRYPT_ARCHIVE           0x0100  // Allow key to be exported at creation only
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

#define HP_ALGID                0x0001  // Hash algorithm
#define HP_HASHVAL              0x0002  // Hash value
#define HP_HASHSIZE             0x0004  // Hash value size
#define HP_HMAC_INFO            0x0005  // information for creating an HMAC
#define HP_TLS1PRF_LABEL        0x0006  // label for TLS1 PRF
#define HP_TLS1PRF_SEED         0x0007  // seed for TLS1 PRF

#define CRYPT_FAILED            FALSE
#define CRYPT_SUCCEED           TRUE

#define RCRYPT_SUCCEEDED(rt)     ((rt) == CRYPT_SUCCEED)
#define RCRYPT_FAILED(rt)        ((rt) == CRYPT_FAILED)

//
// CryptGetProvParam
//
#define PP_ENUMALGS             1
#define PP_ENUMCONTAINERS       2
#define PP_IMPTYPE              3
#define PP_NAME                 4
#define PP_VERSION              5
#define PP_CONTAINER            6
#define PP_CHANGE_PASSWORD      7
#define PP_KEYSET_SEC_DESCR     8       // get/set security descriptor of keyset
#define PP_CERTCHAIN            9       // for retrieving certificates from tokens
#define PP_KEY_TYPE_SUBTYPE     10
#define PP_PROVTYPE             16
#define PP_KEYSTORAGE           17
#define PP_APPLI_CERT           18
#define PP_SYM_KEYSIZE          19
#define PP_SESSION_KEYSIZE      20
#define PP_UI_PROMPT            21
#define PP_ENUMALGS_EX          22
#define PP_ENUMMANDROOTS        25
#define PP_ENUMELECTROOTS       26
#define PP_KEYSET_TYPE          27
#define PP_ADMIN_PIN            31
#define PP_KEYEXCHANGE_PIN      32
#define PP_SIGNATURE_PIN        33
#define PP_SIG_KEYSIZE_INC      34
#define PP_KEYX_KEYSIZE_INC     35
#define PP_UNIQUE_CONTAINER     36
#define PP_SGC_INFO             37
#define PP_USE_HARDWARE_RNG     38
#define PP_KEYSPEC              39
#define PP_ENUMEX_SIGNING_PROT  40
#if (NTDDI_VERSION >= NTDDI_WS03)
#define PP_CRYPT_COUNT_KEY_USE  41
#endif //(NTDDI_VERSION >= NTDDI_WS03)
#if (NTDDI_VERSION >= NTDDI_WINLH)
#define PP_USER_CERTSTORE       42
#define PP_SMARTCARD_READER     43
#define PP_SMARTCARD_GUID       45
#define PP_ROOT_CERTSTORE       46
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#define CRYPT_FIRST             1
#define CRYPT_NEXT              2
#define CRYPT_SGC_ENUM          4

#define CRYPT_IMPL_HARDWARE     1
#define CRYPT_IMPL_SOFTWARE     2
#define CRYPT_IMPL_MIXED        3
#define CRYPT_IMPL_UNKNOWN      4
#define CRYPT_IMPL_REMOVABLE    8

// key storage flags
#define CRYPT_SEC_DESCR         0x00000001
#define CRYPT_PSTORE            0x00000002
#define CRYPT_UI_PROMPT         0x00000004

// protocol flags
#define CRYPT_FLAG_PCT1         0x0001
#define CRYPT_FLAG_SSL2         0x0002
#define CRYPT_FLAG_SSL3         0x0004
#define CRYPT_FLAG_TLS1         0x0008
#define CRYPT_FLAG_IPSEC        0x0010
#define CRYPT_FLAG_SIGNING      0x0020

// SGC flags
#define CRYPT_SGC               0x0001
#define CRYPT_FASTSGC           0x0002

//
// CryptSetProvParam
//
#define PP_CLIENT_HWND          1
#define PP_CONTEXT_INFO         11
#define PP_KEYEXCHANGE_KEYSIZE  12
#define PP_SIGNATURE_KEYSIZE    13
#define PP_KEYEXCHANGE_ALG      14
#define PP_SIGNATURE_ALG        15
#define PP_DELETEKEY            24
#if (NTDDI_VERSION >= NTDDI_WINLH)
#define PP_PIN_PROMPT_STRING      44
#define PP_SECURE_KEYEXCHANGE_PIN 47
#define PP_SECURE_SIGNATURE_PIN   48
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

// certenrolld_begin -- PROV_RSA_*
#define PROV_RSA_FULL           1
#define PROV_RSA_SIG            2
#define PROV_DSS                3
#define PROV_FORTEZZA           4
#define PROV_MS_EXCHANGE        5
#define PROV_SSL                6
#define PROV_RSA_SCHANNEL       12
#define PROV_DSS_DH             13
#define PROV_EC_ECDSA_SIG       14
#define PROV_EC_ECNRA_SIG       15
#define PROV_EC_ECDSA_FULL      16
#define PROV_EC_ECNRA_FULL      17
#define PROV_DH_SCHANNEL        18
#define PROV_SPYRUS_LYNKS       20
#define PROV_RNG                21
#define PROV_INTEL_SEC          22
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define PROV_REPLACE_OWF        23
#define PROV_RSA_AES            24
#endif //(NTDDI_VERSION >= NTDDI_WINXP)
// certenrolld_end

#if (NTDDI_VERSION <= NTDDI_WINXP)
//
// STT defined Providers
//
#define PROV_STT_MER            7
#define PROV_STT_ACQ            8
#define PROV_STT_BRND           9
#define PROV_STT_ROOT           10
#define PROV_STT_ISS            11
#endif //(NTDDI_VERSION <= NTDDI_WINXP)

//
// Provider friendly names
//
#define MS_DEF_PROV_A           "Microsoft Base Cryptographic Provider v1.0"
#define MS_DEF_PROV_W           L"Microsoft Base Cryptographic Provider v1.0"
#ifdef UNICODE
#define MS_DEF_PROV             MS_DEF_PROV_W
#else
#define MS_DEF_PROV             MS_DEF_PROV_A
#endif

#define MS_ENHANCED_PROV_A      "Microsoft Enhanced Cryptographic Provider v1.0"
#define MS_ENHANCED_PROV_W      L"Microsoft Enhanced Cryptographic Provider v1.0"
#ifdef UNICODE
#define MS_ENHANCED_PROV        MS_ENHANCED_PROV_W
#else
#define MS_ENHANCED_PROV        MS_ENHANCED_PROV_A
#endif

#define MS_STRONG_PROV_A        "Microsoft Strong Cryptographic Provider"
#define MS_STRONG_PROV_W        L"Microsoft Strong Cryptographic Provider"
#ifdef UNICODE
#define MS_STRONG_PROV          MS_STRONG_PROV_W
#else
#define MS_STRONG_PROV          MS_STRONG_PROV_A
#endif

#define MS_DEF_RSA_SIG_PROV_A   "Microsoft RSA Signature Cryptographic Provider"
#define MS_DEF_RSA_SIG_PROV_W   L"Microsoft RSA Signature Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_RSA_SIG_PROV     MS_DEF_RSA_SIG_PROV_W
#else
#define MS_DEF_RSA_SIG_PROV     MS_DEF_RSA_SIG_PROV_A
#endif

#define MS_DEF_RSA_SCHANNEL_PROV_A  "Microsoft RSA SChannel Cryptographic Provider"
#define MS_DEF_RSA_SCHANNEL_PROV_W  L"Microsoft RSA SChannel Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_RSA_SCHANNEL_PROV    MS_DEF_RSA_SCHANNEL_PROV_W
#else
#define MS_DEF_RSA_SCHANNEL_PROV    MS_DEF_RSA_SCHANNEL_PROV_A
#endif

#define MS_DEF_DSS_PROV_A       "Microsoft Base DSS Cryptographic Provider"
#define MS_DEF_DSS_PROV_W       L"Microsoft Base DSS Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_DSS_PROV         MS_DEF_DSS_PROV_W
#else
#define MS_DEF_DSS_PROV         MS_DEF_DSS_PROV_A
#endif

#define MS_DEF_DSS_DH_PROV_A    "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
#define MS_DEF_DSS_DH_PROV_W    L"Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_DSS_DH_PROV      MS_DEF_DSS_DH_PROV_W
#else
#define MS_DEF_DSS_DH_PROV      MS_DEF_DSS_DH_PROV_A
#endif

#define MS_ENH_DSS_DH_PROV_A    "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
#define MS_ENH_DSS_DH_PROV_W    L"Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
#ifdef UNICODE
#define MS_ENH_DSS_DH_PROV      MS_ENH_DSS_DH_PROV_W
#else
#define MS_ENH_DSS_DH_PROV      MS_ENH_DSS_DH_PROV_A
#endif

#define MS_DEF_DH_SCHANNEL_PROV_A  "Microsoft DH SChannel Cryptographic Provider"
#define MS_DEF_DH_SCHANNEL_PROV_W  L"Microsoft DH SChannel Cryptographic Provider"
#ifdef UNICODE
#define MS_DEF_DH_SCHANNEL_PROV MS_DEF_DH_SCHANNEL_PROV_W
#else
#define MS_DEF_DH_SCHANNEL_PROV MS_DEF_DH_SCHANNEL_PROV_A
#endif

#define MS_SCARD_PROV_A         "Microsoft Base Smart Card Crypto Provider"
#define MS_SCARD_PROV_W         L"Microsoft Base Smart Card Crypto Provider"
#ifdef UNICODE
#define MS_SCARD_PROV           MS_SCARD_PROV_W
#else
#define MS_SCARD_PROV           MS_SCARD_PROV_A
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define MS_ENH_RSA_AES_PROV_A   "Microsoft Enhanced RSA and AES Cryptographic Provider"
#define MS_ENH_RSA_AES_PROV_W   L"Microsoft Enhanced RSA and AES Cryptographic Provider"
#define MS_ENH_RSA_AES_PROV_XP_A "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"
#define MS_ENH_RSA_AES_PROV_XP_W L"Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"
#ifdef UNICODE
#define MS_ENH_RSA_AES_PROV_XP  MS_ENH_RSA_AES_PROV_XP_W
#define MS_ENH_RSA_AES_PROV     MS_ENH_RSA_AES_PROV_W
#else
#define MS_ENH_RSA_AES_PROV_XP  MS_ENH_RSA_AES_PROV_XP_A
#define MS_ENH_RSA_AES_PROV     MS_ENH_RSA_AES_PROV_A
#endif
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

#define MAXUIDLEN               64

// Exponentiation Offload Reg Location
#define EXPO_OFFLOAD_REG_VALUE "ExpoOffload"
#define EXPO_OFFLOAD_FUNC_NAME "OffloadModExpo"

//
// Registry key in which the following private key-related
// values are created.
//
#define szKEY_CRYPTOAPI_PRIVATE_KEY_OPTIONS \
    "Software\\Policies\\Microsoft\\Cryptography"

//
// Registry value for controlling Data Protection API (DPAPI) UI settings.
//
#define szFORCE_KEY_PROTECTION             "ForceKeyProtection"

#define dwFORCE_KEY_PROTECTION_DISABLED     0x0
#define dwFORCE_KEY_PROTECTION_USER_SELECT  0x1
#define dwFORCE_KEY_PROTECTION_HIGH         0x2

//
// Registry values for enabling and controlling the caching (and timeout)
// of private keys.  This feature is intended for UI-protected private
// keys.
//
// Note that in Windows 2000 and later, private keys, once read from storage,
// are cached in the associated HCRYPTPROV structure for subsequent use.
//
// In Server 2003 and XP SP1, new key caching behavior is available.  Keys
// that have been read from storage and cached may now be considered "stale"
// if a period of time has elapsed since the key was last used.  This forces
// the key to be re-read from storage (which will make the DPAPI UI appear
// again).
//
// Optional Key Timeouts:
//
// In Windows Server 2003, XP SP1, and later, new key caching behavior is
// available.  Keys that have been read from storage and cached per-context
// may now be considered "stale" if a period of time has elapsed since the
// key was last used.  This forces the key to be re-read from storage (which
// will make the Data Protection API dialog appear again if the key is
// UI-protected).
//
// To enable the new behavior, create the registry DWORD value
// szKEY_CACHE_ENABLED and set it to 1.  The registry DWORD value
// szKEY_CACHE_SECONDS must also be created and set to the number of seconds
// that a cached private key may still be considered usable.
//
#define szKEY_CACHE_ENABLED                     "CachePrivateKeys"
#define szKEY_CACHE_SECONDS                     "PrivateKeyLifetimeSeconds"

#if (NTDDI_VERSION >= NTDDI_WINXP)
//
// In platforms later than (and not including) Windows Server 2003, private
// keys are always cached for a period of time per-process, even when
// not being used in any context.
//
// The differences between the process-wide caching settings described below
// and the Optional Key Timeouts described above are subtle.
//
//  - The Optional Key Timeout policy is applied only when an attempt is made
//    to use a specific private key with an open context handle (HCRYPTPROV).
//    If szKEY_CACHE_SECONDS have elapsed since the key was last used, the
//    private key will be re-read from storage.
//
//  - The Cache Purge Interval policy, below, is applied whenever any
//    non-ephemeral private key is used or read from storage.  If
//    szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS have elapsed since the last
//    purge occurred, all cached keys that have not been referenced since the
//    last purge will be removed from the cache.
//
//    If a private key that is purged from the cache is currently
//    referenced in an open context, then the key will be re-read from storage
//    the next time an attempt is made to use it (via any context).
//
// The following two registry DWORD values control this behavior.
//

//
// Registry value for controlling the maximum number of persisted
// (non-ephemeral) private keys that can be cached per-process.  If the cache
// fills up, keys will be replaced on a least-recently-used basis.  If the
// maximum number of cached keys is set to zero, no keys will be globally
// cached.
//
#define szPRIV_KEY_CACHE_MAX_ITEMS              "PrivKeyCacheMaxItems"
#define cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT       20

//
// Registry value for controlling the interval at which the private key
// cache is proactively purged of outdated keys.
//
#define szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS "PrivKeyCachePurgeIntervalSeconds"
#define cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT 86400 // 1 day
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

#define CUR_BLOB_VERSION        2

// structure for use with CryptSetKeyParam for CMS keys
// DO NOT USE THIS STRUCTURE!!!!!
typedef struct _CMS_KEY_INFO {
    DWORD       dwVersion;                      // sizeof(CMS_KEY_INFO)
    ALG_ID  Algid;                              // algorithmm id for the key to be converted
    BYTE    *pbOID;                             // pointer to OID to hash in with Z
    DWORD   cbOID;                              // length of OID to hash in with Z
} CMS_KEY_INFO, *PCMS_KEY_INFO;

// structure for use with CryptSetHashParam with CALG_HMAC
typedef struct _HMAC_Info {
    ALG_ID  HashAlgid;
    BYTE    *pbInnerString;
    DWORD   cbInnerString;
    BYTE    *pbOuterString;
    DWORD   cbOuterString;
} HMAC_INFO, *PHMAC_INFO;

// structure for use with CryptSetKeyParam with KP_SCHANNEL_ALG
typedef struct _SCHANNEL_ALG {
    DWORD   dwUse;
    ALG_ID  Algid;
    DWORD   cBits;
    DWORD   dwFlags;
    DWORD   dwReserved;
} SCHANNEL_ALG, *PSCHANNEL_ALG;

// uses of algortihms for SCHANNEL_ALG structure
#define     SCHANNEL_MAC_KEY    0x00000000
#define     SCHANNEL_ENC_KEY    0x00000001

// uses of dwFlags SCHANNEL_ALG structure
#define     INTERNATIONAL_USAGE 0x00000001

typedef struct _PROV_ENUMALGS {
    ALG_ID    aiAlgid;
    DWORD     dwBitLen;
    DWORD     dwNameLen;
    CHAR      szName[20];
} PROV_ENUMALGS;

// certenrolls_begin -- PROV_ENUMALGS_EX
typedef struct _PROV_ENUMALGS_EX {
    ALG_ID    aiAlgid;
    DWORD     dwDefaultLen;
    DWORD     dwMinLen;
    DWORD     dwMaxLen;
    DWORD     dwProtocols;
    DWORD     dwNameLen;
    CHAR      szName[20];
    DWORD     dwLongNameLen;
    CHAR      szLongName[40];
} PROV_ENUMALGS_EX;
// certenrolls_end

typedef struct _PUBLICKEYSTRUC {
        BYTE    bType;
        BYTE    bVersion;
        WORD    reserved;
        ALG_ID  aiKeyAlg;
} BLOBHEADER, PUBLICKEYSTRUC;

typedef struct _RSAPUBKEY {
        DWORD   magic;                  // Has to be RSA1
        DWORD   bitlen;                 // # of bits in modulus
        DWORD   pubexp;                 // public exponent
                                        // Modulus data follows
} RSAPUBKEY;

typedef struct _PUBKEY {
        DWORD   magic;
        DWORD   bitlen;                 // # of bits in modulus
} DHPUBKEY, DSSPUBKEY, KEAPUBKEY, TEKPUBKEY;

typedef struct _DSSSEED {
        DWORD   counter;
        BYTE    seed[20];
} DSSSEED;

typedef struct _PUBKEYVER3 {
        DWORD   magic;
        DWORD   bitlenP;                // # of bits in prime modulus
        DWORD   bitlenQ;                // # of bits in prime q, 0 if not available
        DWORD   bitlenJ;                // # of bits in (p-1)/q, 0 if not available
        DSSSEED DSSSeed;
} DHPUBKEY_VER3, DSSPUBKEY_VER3;

typedef struct _PRIVKEYVER3 {
        DWORD   magic;
        DWORD   bitlenP;                // # of bits in prime modulus
        DWORD   bitlenQ;                // # of bits in prime q, 0 if not available
        DWORD   bitlenJ;                // # of bits in (p-1)/q, 0 if not available
        DWORD   bitlenX;                // # of bits in X
        DSSSEED DSSSeed;
} DHPRIVKEY_VER3, DSSPRIVKEY_VER3;

typedef struct _KEY_TYPE_SUBTYPE {
        DWORD   dwKeySpec;
        GUID    Type;
        GUID    Subtype;
} KEY_TYPE_SUBTYPE, *PKEY_TYPE_SUBTYPE;

typedef struct _CERT_FORTEZZA_DATA_PROP {
    unsigned char   SerialNumber[8];
    int             CertIndex;
    unsigned char   CertLabel[36];
} CERT_FORTEZZA_DATA_PROP;

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef struct _CRYPT_RC4_KEY_STATE {
    unsigned char Key[16];
    unsigned char SBox[256];
    unsigned char i;
    unsigned char j;
} CRYPT_RC4_KEY_STATE, *PCRYPT_RC4_KEY_STATE;

typedef struct _CRYPT_DES_KEY_STATE {
    unsigned char Key[8];
    unsigned char IV[8];
    unsigned char Feedback[8];
} CRYPT_DES_KEY_STATE, *PCRYPT_DES_KEY_STATE;

typedef struct _CRYPT_3DES_KEY_STATE {
    unsigned char Key[24];
    unsigned char IV[8];
    unsigned char Feedback[8];
} CRYPT_3DES_KEY_STATE, *PCRYPT_3DES_KEY_STATE;
#endif //(NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_WINLH)
typedef struct _CRYPT_AES_128_KEY_STATE {
    unsigned char Key[16];
    unsigned char IV[16];
    unsigned char EncryptionState[11][16];      // 10 rounds + 1
    unsigned char DecryptionState[11][16];
    unsigned char Feedback[16];
} CRYPT_AES_128_KEY_STATE, *PCRYPT_AES_128_KEY_STATE;

typedef struct _CRYPT_AES_256_KEY_STATE {
    unsigned char Key[32];
    unsigned char IV[16];
    unsigned char EncryptionState[15][16];      // 14 rounds + 1
    unsigned char DecryptionState[15][16];
    unsigned char Feedback[16];
} CRYPT_AES_256_KEY_STATE, *PCRYPT_AES_256_KEY_STATE;
#endif //(NTDDI_VERSION >= NTDDI_WINLH)


//+-------------------------------------------------------------------------
//  CRYPTOAPI BLOB definitions
//--------------------------------------------------------------------------
// certenrolls_begin -- *_BLOB
#ifndef CRYPTO_BLOBS_DEFINED
#define CRYPTO_BLOBS_DEFINED
typedef struct _CRYPTOAPI_BLOB {
                            DWORD   cbData;
    __field_bcount(cbData)  BYTE    *pbData;
} CRYPT_INTEGER_BLOB, *PCRYPT_INTEGER_BLOB,
CRYPT_UINT_BLOB, *PCRYPT_UINT_BLOB,
CRYPT_OBJID_BLOB, *PCRYPT_OBJID_BLOB,
CERT_NAME_BLOB, *PCERT_NAME_BLOB,
CERT_RDN_VALUE_BLOB, *PCERT_RDN_VALUE_BLOB,
CERT_BLOB, *PCERT_BLOB,
CRL_BLOB, *PCRL_BLOB,
DATA_BLOB, *PDATA_BLOB,
CRYPT_DATA_BLOB, *PCRYPT_DATA_BLOB,
CRYPT_HASH_BLOB, *PCRYPT_HASH_BLOB,
CRYPT_DIGEST_BLOB, *PCRYPT_DIGEST_BLOB,
CRYPT_DER_BLOB, *PCRYPT_DER_BLOB,
CRYPT_ATTR_BLOB, *PCRYPT_ATTR_BLOB;
#endif
// certenrolls_end

// structure for use with CryptSetKeyParam for CMS keys
typedef struct _CMS_DH_KEY_INFO {
    DWORD               dwVersion;                      // sizeof(CMS_DH_KEY_INFO)
    ALG_ID          Algid;                              // algorithmm id for the key to be converted
    LPSTR           pszContentEncObjId; // pointer to OID to hash in with Z
    CRYPT_DATA_BLOB PubInfo;            // OPTIONAL - public information
    void            *pReserved;         // reserved - should be NULL
} CMS_DH_KEY_INFO, *PCMS_DH_KEY_INFO;

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptAcquireContextA(
    __out       HCRYPTPROV  *phProv,
    __in_opt    LPCSTR    szContainer,
    __in_opt    LPCSTR    szProvider,
    __in        DWORD       dwProvType,
    __in        DWORD       dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptAcquireContextW(
    __out       HCRYPTPROV  *phProv,
    __in_opt    LPCWSTR    szContainer,
    __in_opt    LPCWSTR    szProvider,
    __in        DWORD       dwProvType,
    __in        DWORD       dwFlags
    );
#ifdef UNICODE
#define CryptAcquireContext  CryptAcquireContextW
#else
#define CryptAcquireContext  CryptAcquireContextA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR szContainer,
    LPCSTR szProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR szContainer,
    LPCWSTR szProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINLH)
#ifdef UNICODE
#define CryptAcquireContext  CryptAcquireContextW
#else
#define CryptAcquireContext  CryptAcquireContextA
#endif // !UNICODE
#endif //(NTDDI_VERSION < NTDDI_WINLH)


#if (NTDDI_VERSION >= NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptReleaseContext(
    __in    HCRYPTPROV  hProv,
    __in    DWORD       dwFlags
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptReleaseContext(
    HCRYPTPROV hProv,
    ULONG_PTR dwFlags
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

WINADVAPI
BOOL
WINAPI
CryptGenKey(
    __in    HCRYPTPROV  hProv,
    __in    ALG_ID      Algid,
    __in    DWORD       dwFlags,
    __out   HCRYPTKEY   *phKey
    );

WINADVAPI
BOOL
WINAPI
CryptDeriveKey(
    __in    HCRYPTPROV  hProv,
    __in    ALG_ID      Algid,
    __in    HCRYPTHASH  hBaseData,
    __in    DWORD       dwFlags,
    __out   HCRYPTKEY   *phKey
    );

WINADVAPI
BOOL
WINAPI
CryptDestroyKey(
    __in    HCRYPTKEY   hKey
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptSetKeyParam(
    __in    HCRYPTKEY   hKey,
    __in    DWORD       dwParam,
    __in    CONST BYTE  *pbData,
    __in    DWORD       dwFlags
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

WINADVAPI
BOOL
WINAPI
CryptGetKeyParam(
    __in                                            HCRYPTKEY   hKey,
    __in                                            DWORD   dwParam,
    __out_bcount_part_opt(*pdwDataLen, *pdwDataLen) BYTE    *pbData,
    __inout                                         DWORD   *pdwDataLen,
    __in                                            DWORD   dwFlags
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptSetHashParam(
    __in    HCRYPTHASH  hHash,
    __in    DWORD       dwParam,
    __in    CONST BYTE  *pbData,
    __in    DWORD       dwFlags
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE*pbData,
    DWORD dwFlags
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

WINADVAPI
BOOL
WINAPI
CryptGetHashParam(
    __in                                        HCRYPTHASH  hHash,
    __in                                        DWORD   dwParam,
    __out_bcount_part_opt(*pdwDataLen, *pdwDataLen) BYTE    *pbData,
    __inout                                     DWORD   *pdwDataLen,
    __in                                        DWORD   dwFlags
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptSetProvParam(
    __in    HCRYPTPROV  hProv,
    __in    DWORD       dwParam,
    __in    CONST BYTE  *pbData,
    __in    DWORD       dwFlags
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE*pbData,
    DWORD dwFlags
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

WINADVAPI
BOOL
WINAPI
CryptGetProvParam(
    __in                                            HCRYPTPROV  hProv,
    __in                                            DWORD   dwParam,
    __out_bcount_part_opt(*pdwDataLen, *pdwDataLen) BYTE    *pbData,
    __inout                                         DWORD   *pdwDataLen,
    __in                                            DWORD   dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptGenRandom(
    __in                    HCRYPTPROV  hProv,
    __in                    DWORD   dwLen,
    __inout_bcount(dwLen)   BYTE    *pbBuffer
    );

WINADVAPI
BOOL
WINAPI
CryptGetUserKey(
    __in    HCRYPTPROV  hProv,
    __in    DWORD       dwKeySpec,
    __out   HCRYPTKEY   *phUserKey
    );

WINADVAPI
BOOL
WINAPI
CryptExportKey(
    __in                                            HCRYPTKEY   hKey,
    __in                                            HCRYPTKEY   hExpKey,
    __in                                            DWORD   dwBlobType,
    __in                                            DWORD   dwFlags,
    __out_bcount_part_opt(*pdwDataLen, *pdwDataLen) BYTE    *pbData,
    __inout                                         DWORD   *pdwDataLen
    );

WINADVAPI
BOOL
WINAPI
CryptImportKey(
    __in                    HCRYPTPROV  hProv,
    __in_bcount(dwDataLen)  CONST BYTE  *pbData,
    __in                    DWORD       dwDataLen,
    __in                    HCRYPTKEY   hPubKey,
    __in                    DWORD       dwFlags,
    __out                   HCRYPTKEY   *phKey
    );

WINADVAPI
__success(0 != return) BOOL
WINAPI
CryptEncrypt(
    __in                                            HCRYPTKEY   hKey,
    __in                                            HCRYPTHASH  hHash,
    __in                                            BOOL    Final,
    __in                                            DWORD   dwFlags,
    __inout_bcount_part_opt(dwBufLen, *pdwDataLen)  BYTE    *pbData,
    __inout                                         DWORD   *pdwDataLen,
    __in                                            DWORD   dwBufLen
    );

WINADVAPI
__success(0 != return) BOOL
WINAPI
CryptDecrypt(
    __in                                            HCRYPTKEY   hKey,
    __in                                            HCRYPTHASH  hHash,
    __in                                            BOOL        Final,
    __in                                            DWORD       dwFlags,
    __inout_bcount_part(*pdwDataLen, *pdwDataLen)   BYTE        *pbData,
    __inout                                         DWORD       *pdwDataLen
    );

WINADVAPI
BOOL
WINAPI
CryptCreateHash(
    __in    HCRYPTPROV  hProv,
    __in    ALG_ID      Algid,
    __in    HCRYPTKEY   hKey,
    __in    DWORD       dwFlags,
    __out   HCRYPTHASH  *phHash
    );

WINADVAPI
BOOL
WINAPI
CryptHashData(
    __in                    HCRYPTHASH  hHash,
    __in_bcount(dwDataLen)  CONST BYTE  *pbData,
    __in                    DWORD   dwDataLen,
    __in                    DWORD   dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptHashSessionKey(
    __in    HCRYPTHASH  hHash,
    __in    HCRYPTKEY   hKey,
    __in    DWORD   dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptDestroyHash(
    __in    HCRYPTHASH  hHash
    );

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptSignHashA(
    __in                                          HCRYPTHASH  hHash,
    __in                                          DWORD       dwKeySpec,
    __in_opt                                      LPCSTR    szDescription,
    __in                                          DWORD       dwFlags,
    __out_bcount_part_opt(*pdwSigLen, *pdwSigLen) BYTE        *pbSignature,
    __inout                                       DWORD       *pdwSigLen
    );
WINADVAPI
BOOL
WINAPI
CryptSignHashW(
    __in                                          HCRYPTHASH  hHash,
    __in                                          DWORD       dwKeySpec,
    __in_opt                                      LPCWSTR    szDescription,
    __in                                          DWORD       dwFlags,
    __out_bcount_part_opt(*pdwSigLen, *pdwSigLen) BYTE        *pbSignature,
    __inout                                       DWORD       *pdwSigLen
    );
#ifdef UNICODE
#define CryptSignHash  CryptSignHashW
#else
#define CryptSignHash  CryptSignHashA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR szDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );
WINADVAPI
BOOL
WINAPI
CryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR szDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );
WINADVAPI
BOOL
WINAPI
CryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINLH)
#ifdef UNICODE
#define CryptSignHash  CryptSignHashW
#else
#define CryptSignHash  CryptSignHashA
#endif // !UNICODE
#endif //(NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptVerifySignatureA(
    __in                    HCRYPTHASH  hHash,
    __in_bcount(dwSigLen)   CONST BYTE  *pbSignature,
    __in                    DWORD       dwSigLen,
    __in                    HCRYPTKEY   hPubKey,
    __in_opt                LPCSTR    szDescription,
    __in                    DWORD       dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptVerifySignatureW(
    __in                    HCRYPTHASH  hHash,
    __in_bcount(dwSigLen)   CONST BYTE  *pbSignature,
    __in                    DWORD       dwSigLen,
    __in                    HCRYPTKEY   hPubKey,
    __in_opt                LPCWSTR    szDescription,
    __in                    DWORD       dwFlags
    );
#ifdef UNICODE
#define CryptVerifySignature  CryptVerifySignatureW
#else
#define CryptVerifySignature  CryptVerifySignatureA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR szDescription,
    DWORD dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR szDescription,
    DWORD dwFlags
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINLH)
#ifdef UNICODE
#define CryptVerifySignature  CryptVerifySignatureW
#else
#define CryptVerifySignature  CryptVerifySignatureA
#endif // !UNICODE
#endif //(NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptSetProviderA(
    __in    LPCSTR    pszProvName,
    __in    DWORD       dwProvType
    );
WINADVAPI
BOOL
WINAPI
CryptSetProviderW(
    __in    LPCWSTR    pszProvName,
    __in    DWORD       dwProvType
    );
#ifdef UNICODE
#define CryptSetProvider  CryptSetProviderW
#else
#define CryptSetProvider  CryptSetProviderA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptSetProviderA(
    LPCSTR pszProvName,
    DWORD dwProvType
    );
WINADVAPI
BOOL
WINAPI
CryptSetProviderW(
    LPCWSTR pszProvName,
    DWORD dwProvType
    );
#ifdef UNICODE
#define CryptSetProvider  CryptSetProviderW
#else
#define CryptSetProvider  CryptSetProviderA
#endif // !UNICODE
#endif //(NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptSetProviderExA(
    __in        LPCSTR pszProvName,
    __in        DWORD dwProvType,
    __reserved  DWORD *pdwReserved,
    __in        DWORD dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptSetProviderExW(
    __in        LPCWSTR pszProvName,
    __in        DWORD dwProvType,
    __reserved  DWORD *pdwReserved,
    __in        DWORD dwFlags
    );
#ifdef UNICODE
#define CryptSetProviderEx  CryptSetProviderExW
#else
#define CryptSetProviderEx  CryptSetProviderExA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptSetProviderExA(
    LPCSTR pszProvName,
    DWORD dwProvType,
    DWORD *pdwReserved,
    DWORD dwFlags
    );
WINADVAPI
BOOL
WINAPI
CryptSetProviderExW(
    LPCWSTR pszProvName,
    DWORD dwProvType,
    DWORD *pdwReserved,
    DWORD dwFlags
    );
#ifdef UNICODE
#define CryptSetProviderEx  CryptSetProviderExW
#else
#define CryptSetProviderEx  CryptSetProviderExA
#endif // !UNICODE
#endif //(NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
__success(0 != return) BOOL
WINAPI
CryptGetDefaultProviderA(
    __in                                            DWORD   dwProvType,
    __reserved                                      DWORD   *pdwReserved,
    __in                                            DWORD   dwFlags,
    __out_bcount_part_opt(*pcbProvName, *pcbProvName)   LPSTR pszProvName,
    __inout                                         DWORD   *pcbProvName
    );
WINADVAPI
__success(0 != return) BOOL
WINAPI
CryptGetDefaultProviderW(
    __in                                            DWORD   dwProvType,
    __reserved                                      DWORD   *pdwReserved,
    __in                                            DWORD   dwFlags,
    __out_bcount_part_opt(*pcbProvName, *pcbProvName)   LPWSTR pszProvName,
    __inout                                         DWORD   *pcbProvName
    );
#ifdef UNICODE
#define CryptGetDefaultProvider  CryptGetDefaultProviderW
#else
#define CryptGetDefaultProvider  CryptGetDefaultProviderA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptGetDefaultProviderA(
    DWORD dwProvType,
    DWORD *pdwReserved,
    DWORD dwFlags,
    LPSTR pszProvName,
    DWORD *pcbProvName
    );
WINADVAPI
BOOL
WINAPI
CryptGetDefaultProviderW(
    DWORD dwProvType,
    DWORD *pdwReserved,
    DWORD dwFlags,
    LPWSTR pszProvName,
    DWORD *pcbProvName
    );
#ifdef UNICODE
#define CryptGetDefaultProvider  CryptGetDefaultProviderW
#else
#define CryptGetDefaultProvider  CryptGetDefaultProviderA
#endif // !UNICODE
#endif //(NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
__success(0 != return) BOOL
WINAPI
CryptEnumProviderTypesA(
    __in                                            DWORD   dwIndex,
    __reserved                                      DWORD   *pdwReserved,
    __in                                            DWORD   dwFlags,
    __out                                           DWORD   *pdwProvType,
    __out_bcount_part_opt(*pcbTypeName, *pcbTypeName)   LPSTR szTypeName,
    __inout                                         DWORD   *pcbTypeName
    );
WINADVAPI
__success(0 != return) BOOL
WINAPI
CryptEnumProviderTypesW(
    __in                                            DWORD   dwIndex,
    __reserved                                      DWORD   *pdwReserved,
    __in                                            DWORD   dwFlags,
    __out                                           DWORD   *pdwProvType,
    __out_bcount_part_opt(*pcbTypeName, *pcbTypeName)   LPWSTR szTypeName,
    __inout                                         DWORD   *pcbTypeName
    );
#ifdef UNICODE
#define CryptEnumProviderTypes  CryptEnumProviderTypesW
#else
#define CryptEnumProviderTypes  CryptEnumProviderTypesA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptEnumProviderTypesA(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPSTR szTypeName,
    DWORD *pcbTypeName
    );
WINADVAPI
BOOL
WINAPI
CryptEnumProviderTypesW(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR szTypeName,
    DWORD *pcbTypeName
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptEnumProviderTypesA(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    LPSTR pszTypeName,
    DWORD * pcbTypeName
    );
WINADVAPI
BOOL
WINAPI
CryptEnumProviderTypesW(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    LPWSTR pszTypeName,
    DWORD * pcbTypeName
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINLH)
#ifdef UNICODE
#define CryptEnumProviderTypes  CryptEnumProviderTypesW
#else
#define CryptEnumProviderTypes  CryptEnumProviderTypesA
#endif // !UNICODE
#endif //(NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINLH)
WINADVAPI
__success(0 != return) BOOL
WINAPI
CryptEnumProvidersA(
    __in                                                DWORD   dwIndex,
    __reserved                                          DWORD   *pdwReserved,
    __in                                                DWORD   dwFlags,
    __out                                               DWORD   *pdwProvType,
    __out_bcount_part_opt(*pcbProvName, *pcbProvName)   LPSTR szProvName,
    __inout                                             DWORD   *pcbProvName
    );
WINADVAPI
__success(0 != return) BOOL
WINAPI
CryptEnumProvidersW(
    __in                                                DWORD   dwIndex,
    __reserved                                          DWORD   *pdwReserved,
    __in                                                DWORD   dwFlags,
    __out                                               DWORD   *pdwProvType,
    __out_bcount_part_opt(*pcbProvName, *pcbProvName)   LPWSTR szProvName,
    __inout                                             DWORD   *pcbProvName
    );
#ifdef UNICODE
#define CryptEnumProviders  CryptEnumProvidersW
#else
#define CryptEnumProviders  CryptEnumProvidersA
#endif // !UNICODE
#endif //(NTDDI_VERSION >= NTDDI_WINLH)

#if (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)
WINADVAPI
BOOL
WINAPI
CryptEnumProvidersA(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPSTR szProvName,
    DWORD *pcbProvName
    );
WINADVAPI
BOOL
WINAPI
CryptEnumProvidersW(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR szProvName,
    DWORD *pcbProvName
    );
#endif //(NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_WINLH)

#if (NTDDI_VERSION < NTDDI_WINXP)
WINADVAPI
BOOL
WINAPI
CryptEnumProvidersA(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    LPSTR pszProvName,
    DWORD * pcbProvName
    );
WINADVAPI
BOOL
WINAPI
CryptEnumProvidersW(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    LPWSTR pszProvName,
    DWORD * pcbProvName
    );
#endif //(NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINLH)
#ifdef UNICODE
#define CryptEnumProviders  CryptEnumProvidersW
#else
#define CryptEnumProviders  CryptEnumProvidersA
#endif // !UNICODE
#endif //(NTDDI_VERSION < NTDDI_WINLH)

WINADVAPI
BOOL
WINAPI
CryptContextAddRef(
    __in        HCRYPTPROV  hProv,
    __reserved  DWORD       *pdwReserved,
    __in        DWORD       dwFlags
    );

WINADVAPI
BOOL
WINAPI
CryptDuplicateKey(
    __in        HCRYPTKEY   hKey,
    __reserved  DWORD   *pdwReserved,
    __in        DWORD   dwFlags,
    __out       HCRYPTKEY   *phKey
    );

WINADVAPI
BOOL
WINAPI
CryptDuplicateHash(
    __in        HCRYPTHASH  hHash,
    __reserved  DWORD       *pdwReserved,
    __in        DWORD       dwFlags,
    __out       HCRYPTHASH  *phHash
    );

#if (NTDDI_VERSION >= NTDDI_WS03)
//
// This function is provided in Microsoft Windows 2000 as a means of
// installing the 128-bit encryption provider. This function is unavailable
// in Microsoft Windows XP, because Windows XP ships with the 128-bit
// encryption provider.
//
BOOL
__cdecl
GetEncSChannel(
    BYTE **pData,
    DWORD *dwDecSize
    );
#endif //(NTDDI_VERSION >= NTDDI_WS03)


#if !defined(_DDK_DRIVER_)

// In Vista, the following APIs were updated to support the new
// CNG (Cryptography Next Generation) BCrypt* and NCrypt* APIs in addition
// to the above CAPI1 APIs.

// Include the definitions for the CNG APIs
#include <bcrypt.h>
#include <ncrypt.h>

// This type is used when the API can take either the CAPI1 HCRYPTPROV or
// the CNG NCRYPT_KEY_HANDLE. Where appropriate, the HCRYPTPROV will be
// converted to a NCRYPT_KEY_HANDLE via the CNG NCryptTranslateHandle().
typedef ULONG_PTR HCRYPTPROV_OR_NCRYPT_KEY_HANDLE;

// This type is used where the HCRYPTPROV parameter is no longer used.
// The caller should always pass in NULL.
typedef ULONG_PTR HCRYPTPROV_LEGACY;

//+-------------------------------------------------------------------------
//  In a CRYPT_BIT_BLOB the last byte may contain 0-7 unused bits. Therefore, the
//  overall bit length is cbData * 8 - cUnusedBits.
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CRYPT_BIT_BLOB {
    DWORD   cbData;
    BYTE    *pbData;
    DWORD   cUnusedBits;
} CRYPT_BIT_BLOB, *PCRYPT_BIT_BLOB;

//+-------------------------------------------------------------------------
//  Type used for any algorithm
//
//  Where the Parameters CRYPT_OBJID_BLOB is in its encoded representation. For most
//  algorithm types, the Parameters CRYPT_OBJID_BLOB is NULL (Parameters.cbData = 0).
//--------------------------------------------------------------------------
typedef struct _CRYPT_ALGORITHM_IDENTIFIER {
    LPSTR               pszObjId;
    CRYPT_OBJID_BLOB    Parameters;
} CRYPT_ALGORITHM_IDENTIFIER, *PCRYPT_ALGORITHM_IDENTIFIER;
// certenrolls_end


// Following are the definitions of various algorithm object identifiers
// RSA
#define szOID_RSA               "1.2.840.113549"
#define szOID_PKCS              "1.2.840.113549.1"
#define szOID_RSA_HASH          "1.2.840.113549.2"
#define szOID_RSA_ENCRYPT       "1.2.840.113549.3"

#define szOID_PKCS_1            "1.2.840.113549.1.1"
#define szOID_PKCS_2            "1.2.840.113549.1.2"
#define szOID_PKCS_3            "1.2.840.113549.1.3"
#define szOID_PKCS_4            "1.2.840.113549.1.4"
#define szOID_PKCS_5            "1.2.840.113549.1.5"
#define szOID_PKCS_6            "1.2.840.113549.1.6"
#define szOID_PKCS_7            "1.2.840.113549.1.7"
#define szOID_PKCS_8            "1.2.840.113549.1.8"
#define szOID_PKCS_9            "1.2.840.113549.1.9"
#define szOID_PKCS_10           "1.2.840.113549.1.10"
#define szOID_PKCS_12           "1.2.840.113549.1.12"

#define szOID_RSA_RSA           "1.2.840.113549.1.1.1"
#define szOID_RSA_MD2RSA        "1.2.840.113549.1.1.2"
#define szOID_RSA_MD4RSA        "1.2.840.113549.1.1.3"
#define szOID_RSA_MD5RSA        "1.2.840.113549.1.1.4"
#define szOID_RSA_SHA1RSA       "1.2.840.113549.1.1.5"
#define szOID_RSA_SETOAEP_RSA   "1.2.840.113549.1.1.6"

#define szOID_RSAES_OAEP        "1.2.840.113549.1.1.7"
#define szOID_RSA_MGF1          "1.2.840.113549.1.1.8"
#define szOID_RSA_PSPECIFIED    "1.2.840.113549.1.1.9"
#define szOID_RSA_SSA_PSS       "1.2.840.113549.1.1.10"
#define szOID_RSA_SHA256RSA     "1.2.840.113549.1.1.11"
#define szOID_RSA_SHA384RSA     "1.2.840.113549.1.1.12"
#define szOID_RSA_SHA512RSA     "1.2.840.113549.1.1.13"

#define szOID_RSA_DH            "1.2.840.113549.1.3.1"

#define szOID_RSA_data          "1.2.840.113549.1.7.1"
#define szOID_RSA_signedData    "1.2.840.113549.1.7.2"
#define szOID_RSA_envelopedData "1.2.840.113549.1.7.3"
#define szOID_RSA_signEnvData   "1.2.840.113549.1.7.4"
#define szOID_RSA_digestedData  "1.2.840.113549.1.7.5"
#define szOID_RSA_hashedData    "1.2.840.113549.1.7.5"
#define szOID_RSA_encryptedData "1.2.840.113549.1.7.6"

#define szOID_RSA_emailAddr     "1.2.840.113549.1.9.1"
#define szOID_RSA_unstructName  "1.2.840.113549.1.9.2"
#define szOID_RSA_contentType   "1.2.840.113549.1.9.3"
#define szOID_RSA_messageDigest "1.2.840.113549.1.9.4"
#define szOID_RSA_signingTime   "1.2.840.113549.1.9.5"
#define szOID_RSA_counterSign   "1.2.840.113549.1.9.6"
#define szOID_RSA_challengePwd  "1.2.840.113549.1.9.7"
#define szOID_RSA_unstructAddr  "1.2.840.113549.1.9.8"
#define szOID_RSA_extCertAttrs  "1.2.840.113549.1.9.9"
#define szOID_RSA_certExtensions "1.2.840.113549.1.9.14"
#define szOID_RSA_SMIMECapabilities "1.2.840.113549.1.9.15"
#define szOID_RSA_preferSignedData "1.2.840.113549.1.9.15.1"

#define szOID_TIMESTAMP_TOKEN           "1.2.840.113549.1.9.16.1.4"
#define szOID_RFC3161_counterSign "1.3.6.1.4.1.311.3.3.1"

#define szOID_RSA_SMIMEalg              "1.2.840.113549.1.9.16.3"
#define szOID_RSA_SMIMEalgESDH          "1.2.840.113549.1.9.16.3.5"
#define szOID_RSA_SMIMEalgCMS3DESwrap   "1.2.840.113549.1.9.16.3.6"
#define szOID_RSA_SMIMEalgCMSRC2wrap    "1.2.840.113549.1.9.16.3.7"

#define szOID_RSA_MD2           "1.2.840.113549.2.2"
#define szOID_RSA_MD4           "1.2.840.113549.2.4"
#define szOID_RSA_MD5           "1.2.840.113549.2.5"

#define szOID_RSA_RC2CBC        "1.2.840.113549.3.2"
#define szOID_RSA_RC4           "1.2.840.113549.3.4"
#define szOID_RSA_DES_EDE3_CBC  "1.2.840.113549.3.7"
#define szOID_RSA_RC5_CBCPad    "1.2.840.113549.3.9"


#define szOID_ANSI_X942         "1.2.840.10046"
#define szOID_ANSI_X942_DH      "1.2.840.10046.2.1"

#define szOID_X957              "1.2.840.10040"
#define szOID_X957_DSA          "1.2.840.10040.4.1"
#define szOID_X957_SHA1DSA      "1.2.840.10040.4.3"


// iso(1) member-body(2) us(840) 10045 keyType(2) unrestricted(1)
#define szOID_ECC_PUBLIC_KEY    "1.2.840.10045.2.1"

// iso(1) member-body(2) us(840) 10045 curves(3) prime(1) 7
#define szOID_ECC_CURVE_P256    "1.2.840.10045.3.1.7"

// iso(1) identified-organization(3) certicom(132) curve(0) 34
#define szOID_ECC_CURVE_P384    "1.3.132.0.34"

// iso(1) identified-organization(3) certicom(132) curve(0) 35
#define szOID_ECC_CURVE_P521    "1.3.132.0.35"


// iso(1) member-body(2) us(840) 10045 signatures(4) sha1(1)
#define szOID_ECDSA_SHA1        "1.2.840.10045.4.1"

// iso(1) member-body(2) us(840) 10045 signatures(4) specified(3)
#define szOID_ECDSA_SPECIFIED   "1.2.840.10045.4.3"

// iso(1) member-body(2) us(840) 10045 signatures(4) specified(3) 2
#define szOID_ECDSA_SHA256      "1.2.840.10045.4.3.2"

// iso(1) member-body(2) us(840) 10045 signatures(4) specified(3) 3
#define szOID_ECDSA_SHA384      "1.2.840.10045.4.3.3"

// iso(1) member-body(2) us(840) 10045 signatures(4) specified(3) 4
#define szOID_ECDSA_SHA512      "1.2.840.10045.4.3.4"


// NIST AES CBC Algorithms
// joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistAlgorithms(4)  aesAlgs(1) }

#define szOID_NIST_AES128_CBC        "2.16.840.1.101.3.4.1.2"
#define szOID_NIST_AES192_CBC        "2.16.840.1.101.3.4.1.22"
#define szOID_NIST_AES256_CBC        "2.16.840.1.101.3.4.1.42"

// For the above Algorithms, the AlgorithmIdentifier parameters must be
// present and the parameters field MUST contain an AES-IV:
//
//  AES-IV ::= OCTET STRING (SIZE(16))

// NIST AES WRAP Algorithms
#define szOID_NIST_AES128_WRAP       "2.16.840.1.101.3.4.1.5"
#define szOID_NIST_AES192_WRAP       "2.16.840.1.101.3.4.1.25"
#define szOID_NIST_AES256_WRAP       "2.16.840.1.101.3.4.1.45"


//      x9-63-scheme OBJECT IDENTIFIER ::= { iso(1)
//         identified-organization(3) tc68(133) country(16) x9(840)
//         x9-63(63) schemes(0) }


// ECDH single pass ephemeral-static KeyAgreement KeyEncryptionAlgorithm
#define szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF   "1.3.133.16.840.63.0.2"
#define szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF "1.3.132.1.11.1"
#define szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF "1.3.132.1.11.2"

// For the above KeyEncryptionAlgorithm the following wrap algorithms are
// supported:
//  szOID_RSA_SMIMEalgCMS3DESwrap
//  szOID_RSA_SMIMEalgCMSRC2wrap
//  szOID_NIST_AES128_WRAP
//  szOID_NIST_AES192_WRAP
//  szOID_NIST_AES256_WRAP



// ITU-T UsefulDefinitions
#define szOID_DS                "2.5"
#define szOID_DSALG             "2.5.8"
#define szOID_DSALG_CRPT        "2.5.8.1"
#define szOID_DSALG_HASH        "2.5.8.2"
#define szOID_DSALG_SIGN        "2.5.8.3"
#define szOID_DSALG_RSA         "2.5.8.1.1"
// NIST OSE Implementors' Workshop (OIW)
// http://nemo.ncsl.nist.gov/oiw/agreements/stable/OSI/12s_9506.w51
// http://nemo.ncsl.nist.gov/oiw/agreements/working/OSI/12w_9503.w51
#define szOID_OIW               "1.3.14"
// NIST OSE Implementors' Workshop (OIW) Security SIG algorithm identifiers
#define szOID_OIWSEC            "1.3.14.3.2"
#define szOID_OIWSEC_md4RSA     "1.3.14.3.2.2"
#define szOID_OIWSEC_md5RSA     "1.3.14.3.2.3"
#define szOID_OIWSEC_md4RSA2    "1.3.14.3.2.4"
#define szOID_OIWSEC_desECB     "1.3.14.3.2.6"
#define szOID_OIWSEC_desCBC     "1.3.14.3.2.7"
#define szOID_OIWSEC_desOFB     "1.3.14.3.2.8"
#define szOID_OIWSEC_desCFB     "1.3.14.3.2.9"
#define szOID_OIWSEC_desMAC     "1.3.14.3.2.10"
#define szOID_OIWSEC_rsaSign    "1.3.14.3.2.11"
#define szOID_OIWSEC_dsa        "1.3.14.3.2.12"
#define szOID_OIWSEC_shaDSA     "1.3.14.3.2.13"
#define szOID_OIWSEC_mdc2RSA    "1.3.14.3.2.14"
#define szOID_OIWSEC_shaRSA     "1.3.14.3.2.15"
#define szOID_OIWSEC_dhCommMod  "1.3.14.3.2.16"
#define szOID_OIWSEC_desEDE     "1.3.14.3.2.17"
#define szOID_OIWSEC_sha        "1.3.14.3.2.18"
#define szOID_OIWSEC_mdc2       "1.3.14.3.2.19"
#define szOID_OIWSEC_dsaComm    "1.3.14.3.2.20"
#define szOID_OIWSEC_dsaCommSHA "1.3.14.3.2.21"
#define szOID_OIWSEC_rsaXchg    "1.3.14.3.2.22"
#define szOID_OIWSEC_keyHashSeal "1.3.14.3.2.23"
#define szOID_OIWSEC_md2RSASign "1.3.14.3.2.24"
#define szOID_OIWSEC_md5RSASign "1.3.14.3.2.25"
#define szOID_OIWSEC_sha1       "1.3.14.3.2.26"
#define szOID_OIWSEC_dsaSHA1    "1.3.14.3.2.27"
#define szOID_OIWSEC_dsaCommSHA1 "1.3.14.3.2.28"
#define szOID_OIWSEC_sha1RSASign "1.3.14.3.2.29"
// NIST OSE Implementors' Workshop (OIW) Directory SIG algorithm identifiers
#define szOID_OIWDIR            "1.3.14.7.2"
#define szOID_OIWDIR_CRPT       "1.3.14.7.2.1"
#define szOID_OIWDIR_HASH       "1.3.14.7.2.2"
#define szOID_OIWDIR_SIGN       "1.3.14.7.2.3"
#define szOID_OIWDIR_md2        "1.3.14.7.2.2.1"
#define szOID_OIWDIR_md2RSA     "1.3.14.7.2.3.1"


// INFOSEC Algorithms
// joint-iso-ccitt(2) country(16) us(840) organization(1) us-government(101) dod(2) id-infosec(1)
#define szOID_INFOSEC                       "2.16.840.1.101.2.1"
#define szOID_INFOSEC_sdnsSignature         "2.16.840.1.101.2.1.1.1"
#define szOID_INFOSEC_mosaicSignature       "2.16.840.1.101.2.1.1.2"
#define szOID_INFOSEC_sdnsConfidentiality   "2.16.840.1.101.2.1.1.3"
#define szOID_INFOSEC_mosaicConfidentiality "2.16.840.1.101.2.1.1.4"
#define szOID_INFOSEC_sdnsIntegrity         "2.16.840.1.101.2.1.1.5"
#define szOID_INFOSEC_mosaicIntegrity       "2.16.840.1.101.2.1.1.6"
#define szOID_INFOSEC_sdnsTokenProtection   "2.16.840.1.101.2.1.1.7"
#define szOID_INFOSEC_mosaicTokenProtection "2.16.840.1.101.2.1.1.8"
#define szOID_INFOSEC_sdnsKeyManagement     "2.16.840.1.101.2.1.1.9"
#define szOID_INFOSEC_mosaicKeyManagement   "2.16.840.1.101.2.1.1.10"
#define szOID_INFOSEC_sdnsKMandSig          "2.16.840.1.101.2.1.1.11"
#define szOID_INFOSEC_mosaicKMandSig        "2.16.840.1.101.2.1.1.12"
#define szOID_INFOSEC_SuiteASignature       "2.16.840.1.101.2.1.1.13"
#define szOID_INFOSEC_SuiteAConfidentiality "2.16.840.1.101.2.1.1.14"
#define szOID_INFOSEC_SuiteAIntegrity       "2.16.840.1.101.2.1.1.15"
#define szOID_INFOSEC_SuiteATokenProtection "2.16.840.1.101.2.1.1.16"
#define szOID_INFOSEC_SuiteAKeyManagement   "2.16.840.1.101.2.1.1.17"
#define szOID_INFOSEC_SuiteAKMandSig        "2.16.840.1.101.2.1.1.18"
#define szOID_INFOSEC_mosaicUpdatedSig      "2.16.840.1.101.2.1.1.19"
#define szOID_INFOSEC_mosaicKMandUpdSig     "2.16.840.1.101.2.1.1.20"
#define szOID_INFOSEC_mosaicUpdatedInteg    "2.16.840.1.101.2.1.1.21"

// NIST Hash Algorithms
// joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2)

#define szOID_NIST_sha256                   "2.16.840.1.101.3.4.2.1"
#define szOID_NIST_sha384                   "2.16.840.1.101.3.4.2.2"
#define szOID_NIST_sha512                   "2.16.840.1.101.3.4.2.3"

typedef struct _CRYPT_OBJID_TABLE {
    DWORD   dwAlgId;
    LPCSTR  pszObjId;
} CRYPT_OBJID_TABLE, *PCRYPT_OBJID_TABLE;


//+-------------------------------------------------------------------------
//  PKCS #1 HashInfo (DigestInfo)
//--------------------------------------------------------------------------
typedef struct _CRYPT_HASH_INFO {
    CRYPT_ALGORITHM_IDENTIFIER  HashAlgorithm;
    CRYPT_HASH_BLOB             Hash;
} CRYPT_HASH_INFO, *PCRYPT_HASH_INFO;

//+-------------------------------------------------------------------------
//  Type used for an extension to an encoded content
//
//  Where the Value's CRYPT_OBJID_BLOB is in its encoded representation.
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CERT_EXTENSION {
    LPSTR               pszObjId;
    BOOL                fCritical;
    CRYPT_OBJID_BLOB    Value;
} CERT_EXTENSION, *PCERT_EXTENSION;
typedef const CERT_EXTENSION* PCCERT_EXTENSION;
// certenrolls_end

//+-------------------------------------------------------------------------
//  AttributeTypeValue
//
//  Where the Value's CRYPT_OBJID_BLOB is in its encoded representation.
//--------------------------------------------------------------------------
// certenrolls_begin -- CRYPT_ATTRIBUTE_TYPE_VALUE
typedef struct _CRYPT_ATTRIBUTE_TYPE_VALUE {
    LPSTR               pszObjId;
    CRYPT_OBJID_BLOB    Value;
} CRYPT_ATTRIBUTE_TYPE_VALUE, *PCRYPT_ATTRIBUTE_TYPE_VALUE;
// certenrolls_end

//+-------------------------------------------------------------------------
//  Attributes
//
//  Where the Value's PATTR_BLOBs are in their encoded representation.
//--------------------------------------------------------------------------
// certenrolls_begin -- CRYPT_ATTRIBUTE
typedef struct _CRYPT_ATTRIBUTE {
    LPSTR               pszObjId;
    DWORD               cValue;
    PCRYPT_ATTR_BLOB    rgValue;
} CRYPT_ATTRIBUTE, *PCRYPT_ATTRIBUTE;

typedef struct _CRYPT_ATTRIBUTES {
    DWORD                cAttr;
    PCRYPT_ATTRIBUTE     rgAttr;
} CRYPT_ATTRIBUTES, *PCRYPT_ATTRIBUTES;
// certenrolls_end

//+-------------------------------------------------------------------------
//  Attributes making up a Relative Distinguished Name (CERT_RDN)
//
//  The interpretation of the Value depends on the dwValueType.
//  See below for a list of the types.
//--------------------------------------------------------------------------
typedef struct _CERT_RDN_ATTR {
    LPSTR                   pszObjId;
    DWORD                   dwValueType;
    CERT_RDN_VALUE_BLOB     Value;
} CERT_RDN_ATTR, *PCERT_RDN_ATTR;

//+-------------------------------------------------------------------------
//  CERT_RDN attribute Object Identifiers
//--------------------------------------------------------------------------
// Labeling attribute types:
#define szOID_COMMON_NAME                   "2.5.4.3"  // case-ignore string
#define szOID_SUR_NAME                      "2.5.4.4"  // case-ignore string
#define szOID_DEVICE_SERIAL_NUMBER          "2.5.4.5"  // printable string

// Geographic attribute types:
#define szOID_COUNTRY_NAME                  "2.5.4.6"  // printable 2char string
#define szOID_LOCALITY_NAME                 "2.5.4.7"  // case-ignore string
#define szOID_STATE_OR_PROVINCE_NAME        "2.5.4.8"  // case-ignore string
#define szOID_STREET_ADDRESS                "2.5.4.9"  // case-ignore string

// Organizational attribute types:
#define szOID_ORGANIZATION_NAME             "2.5.4.10" // case-ignore string
#define szOID_ORGANIZATIONAL_UNIT_NAME      "2.5.4.11" // case-ignore string
#define szOID_TITLE                         "2.5.4.12" // case-ignore string

// Explanatory attribute types:
#define szOID_DESCRIPTION                   "2.5.4.13" // case-ignore string
#define szOID_SEARCH_GUIDE                  "2.5.4.14"
#define szOID_BUSINESS_CATEGORY             "2.5.4.15" // case-ignore string

// Postal addressing attribute types:
#define szOID_POSTAL_ADDRESS                "2.5.4.16"
#define szOID_POSTAL_CODE                   "2.5.4.17" // case-ignore string
#define szOID_POST_OFFICE_BOX               "2.5.4.18" // case-ignore string
#define szOID_PHYSICAL_DELIVERY_OFFICE_NAME "2.5.4.19" // case-ignore string

// Telecommunications addressing attribute types:
#define szOID_TELEPHONE_NUMBER              "2.5.4.20" // telephone number
#define szOID_TELEX_NUMBER                  "2.5.4.21"
#define szOID_TELETEXT_TERMINAL_IDENTIFIER  "2.5.4.22"
#define szOID_FACSIMILE_TELEPHONE_NUMBER    "2.5.4.23"
#define szOID_X21_ADDRESS                   "2.5.4.24" // numeric string
#define szOID_INTERNATIONAL_ISDN_NUMBER     "2.5.4.25" // numeric string
#define szOID_REGISTERED_ADDRESS            "2.5.4.26"
#define szOID_DESTINATION_INDICATOR         "2.5.4.27" // printable string

// Preference attribute types:
#define szOID_PREFERRED_DELIVERY_METHOD     "2.5.4.28"

// OSI application attribute types:
#define szOID_PRESENTATION_ADDRESS          "2.5.4.29"
#define szOID_SUPPORTED_APPLICATION_CONTEXT "2.5.4.30"

// Relational application attribute types:
#define szOID_MEMBER                        "2.5.4.31"
#define szOID_OWNER                         "2.5.4.32"
#define szOID_ROLE_OCCUPANT                 "2.5.4.33"
#define szOID_SEE_ALSO                      "2.5.4.34"

// Security attribute types:
#define szOID_USER_PASSWORD                 "2.5.4.35"
#define szOID_USER_CERTIFICATE              "2.5.4.36"
#define szOID_CA_CERTIFICATE                "2.5.4.37"
#define szOID_AUTHORITY_REVOCATION_LIST     "2.5.4.38"
#define szOID_CERTIFICATE_REVOCATION_LIST   "2.5.4.39"
#define szOID_CROSS_CERTIFICATE_PAIR        "2.5.4.40"

// Undocumented attribute types???
//#define szOID_???                         "2.5.4.41"
#define szOID_GIVEN_NAME                    "2.5.4.42" // case-ignore string
#define szOID_INITIALS                      "2.5.4.43" // case-ignore string

// The DN Qualifier attribute type specifies disambiguating information to add
// to the relative distinguished name of an entry. It is intended to be used
// for entries held in multiple DSAs which would otherwise have the same name,
// and that its value be the same in a given DSA for all entries to which
// the information has been added.
#define szOID_DN_QUALIFIER                  "2.5.4.46"

// Pilot user attribute types:
#define szOID_DOMAIN_COMPONENT  "0.9.2342.19200300.100.1.25" // IA5, UTF8 string

// used for PKCS 12 attributes
#define szOID_PKCS_12_FRIENDLY_NAME_ATTR     "1.2.840.113549.1.9.20"
#define szOID_PKCS_12_LOCAL_KEY_ID           "1.2.840.113549.1.9.21"
#define szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR "1.3.6.1.4.1.311.17.1"
#define szOID_LOCAL_MACHINE_KEYSET           "1.3.6.1.4.1.311.17.2"
#define szOID_PKCS_12_EXTENDED_ATTRIBUTES    "1.3.6.1.4.1.311.17.3"

//+-------------------------------------------------------------------------
//  Microsoft CERT_RDN attribute Object Identifiers
//--------------------------------------------------------------------------
// Special RDN containing the KEY_ID. Its value type is CERT_RDN_OCTET_STRING.
#define szOID_KEYID_RDN                     "1.3.6.1.4.1.311.10.7.1"

//+-------------------------------------------------------------------------
//  EV RDN OIDs
//--------------------------------------------------------------------------
#define szOID_EV_RDN_LOCALE                         "1.3.6.1.4.1.311.60.2.1.1"
#define szOID_EV_RDN_STATE_OR_PROVINCE              "1.3.6.1.4.1.311.60.2.1.2"
#define szOID_EV_RDN_COUNTRY                        "1.3.6.1.4.1.311.60.2.1.3"

//+-------------------------------------------------------------------------
//  CERT_RDN Attribute Value Types
//
//  For RDN_ENCODED_BLOB, the Value's CERT_RDN_VALUE_BLOB is in its encoded
//  representation. Otherwise, its an array of bytes.
//
//  For all CERT_RDN types, Value.cbData is always the number of bytes, not
//  necessarily the number of elements in the string. For instance,
//  RDN_UNIVERSAL_STRING is an array of ints (cbData == intCnt * 4) and
//  RDN_BMP_STRING is an array of unsigned shorts (cbData == ushortCnt * 2).
//
//  A RDN_UTF8_STRING is an array of UNICODE characters (cbData == charCnt *2).
//  These UNICODE characters are encoded as UTF8 8 bit characters.
//
//  For CertDecodeName, two 0 bytes are always appended to the end of the
//  string (ensures a CHAR or WCHAR string is null terminated).
//  These added 0 bytes are't included in the BLOB.cbData.
//--------------------------------------------------------------------------
#define CERT_RDN_ANY_TYPE                0
#define CERT_RDN_ENCODED_BLOB            1
#define CERT_RDN_OCTET_STRING            2
#define CERT_RDN_NUMERIC_STRING          3
#define CERT_RDN_PRINTABLE_STRING        4
#define CERT_RDN_TELETEX_STRING          5
#define CERT_RDN_T61_STRING              5
#define CERT_RDN_VIDEOTEX_STRING         6
#define CERT_RDN_IA5_STRING              7
#define CERT_RDN_GRAPHIC_STRING          8
#define CERT_RDN_VISIBLE_STRING          9
#define CERT_RDN_ISO646_STRING           9
#define CERT_RDN_GENERAL_STRING          10
#define CERT_RDN_UNIVERSAL_STRING        11
#define CERT_RDN_INT4_STRING             11
#define CERT_RDN_BMP_STRING              12
#define CERT_RDN_UNICODE_STRING          12
#define CERT_RDN_UTF8_STRING             13

#define CERT_RDN_TYPE_MASK                  0x000000FF
#define CERT_RDN_FLAGS_MASK                 0xFF000000

//+-------------------------------------------------------------------------
//  Flags that can be or'ed with the above Value Type when encoding/decoding
//--------------------------------------------------------------------------
// For encoding: when set, CERT_RDN_T61_STRING is selected instead of
// CERT_RDN_UNICODE_STRING if all the unicode characters are <= 0xFF
#define CERT_RDN_ENABLE_T61_UNICODE_FLAG    0x80000000

// For encoding: when set, CERT_RDN_UTF8_STRING is selected instead of
// CERT_RDN_UNICODE_STRING.
#define CERT_RDN_ENABLE_UTF8_UNICODE_FLAG   0x20000000

// For encoding: when set, CERT_RDN_UTF8_STRING is selected instead of
// CERT_RDN_PRINTABLE_STRING for DirectoryString types. Also,
// enables CERT_RDN_ENABLE_UTF8_UNICODE_FLAG.
#define CERT_RDN_FORCE_UTF8_UNICODE_FLAG    0x10000000

// For encoding: when set, the characters aren't checked to see if they
// are valid for the Value Type.
#define CERT_RDN_DISABLE_CHECK_TYPE_FLAG    0x40000000

// For decoding: by default, CERT_RDN_T61_STRING values are initially decoded
// as UTF8. If the UTF8 decoding fails, then, decoded as 8 bit characters.
// Setting this flag skips the initial attempt to decode as UTF8.
#define CERT_RDN_DISABLE_IE4_UTF8_FLAG      0x01000000

// For encoding: If the string contains E/Email RDN, and the email-address
// (in RDN value) contains unicode characters outside of ASCII character set,
// the localpart and the hostname portion of the email-address would be first
// encoded in punycode and then the resultant Email-Address would be attempted
// to be encoded as IA5String. Punycode encoding of hostname is done on
// label-by-label basis.
// For decoding: If the name contains E/Email RDN, and local part or hostname
// portion of the email-address contains punycode encoded IA5String,
// The RDN string value is converted to its unicode equivalent.
#define CERT_RDN_ENABLE_PUNYCODE_FLAG       0x02000000

// Macro to check that the dwValueType is a character string and not an
// encoded blob or octet string
#define IS_CERT_RDN_CHAR_STRING(X)      \
                (((X) & CERT_RDN_TYPE_MASK) >= CERT_RDN_NUMERIC_STRING)


//+-------------------------------------------------------------------------
//  A CERT_RDN consists of an array of the above attributes
//--------------------------------------------------------------------------
typedef struct _CERT_RDN {
    DWORD           cRDNAttr;
    PCERT_RDN_ATTR  rgRDNAttr;
} CERT_RDN, *PCERT_RDN;

//+-------------------------------------------------------------------------
//  Information stored in a subject's or issuer's name. The information
//  is represented as an array of the above RDNs.
//--------------------------------------------------------------------------
typedef struct _CERT_NAME_INFO {
    DWORD       cRDN;
    PCERT_RDN   rgRDN;
} CERT_NAME_INFO, *PCERT_NAME_INFO;

//+-------------------------------------------------------------------------
//  Name attribute value without the Object Identifier
//
//  The interpretation of the Value depends on the dwValueType.
//  See above for a list of the types.
//--------------------------------------------------------------------------
typedef struct _CERT_NAME_VALUE {
    DWORD               dwValueType;
    CERT_RDN_VALUE_BLOB Value;
} CERT_NAME_VALUE, *PCERT_NAME_VALUE;

//+-------------------------------------------------------------------------
//  Public Key Info
//
//  The PublicKey is the encoded representation of the information as it is
//  stored in the bit string
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CERT_PUBLIC_KEY_INFO {
    CRYPT_ALGORITHM_IDENTIFIER    Algorithm;
    CRYPT_BIT_BLOB                PublicKey;
} CERT_PUBLIC_KEY_INFO, *PCERT_PUBLIC_KEY_INFO;
// certenrolls_end

#define CERT_RSA_PUBLIC_KEY_OBJID            szOID_RSA_RSA
#define CERT_DEFAULT_OID_PUBLIC_KEY_SIGN     szOID_RSA_RSA
#define CERT_DEFAULT_OID_PUBLIC_KEY_XCHG     szOID_RSA_RSA


//+-------------------------------------------------------------------------
//  structure that contains all the information in a PKCS#8 PrivateKeyInfo
//--------------------------------------------------------------------------
typedef struct _CRYPT_PRIVATE_KEY_INFO{
    DWORD                       Version;
    CRYPT_ALGORITHM_IDENTIFIER  Algorithm;
    CRYPT_DER_BLOB              PrivateKey;
    PCRYPT_ATTRIBUTES           pAttributes;
}  CRYPT_PRIVATE_KEY_INFO, *PCRYPT_PRIVATE_KEY_INFO;

//+-------------------------------------------------------------------------
//  structure that contains all the information in a PKCS#8
//  EncryptedPrivateKeyInfo
//--------------------------------------------------------------------------
typedef struct _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO{
    CRYPT_ALGORITHM_IDENTIFIER  EncryptionAlgorithm;
    CRYPT_DATA_BLOB             EncryptedPrivateKey;
} CRYPT_ENCRYPTED_PRIVATE_KEY_INFO, *PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO;

//+-------------------------------------------------------------------------
// this callback is given when an EncryptedProvateKeyInfo structure is
// encountered during ImportPKCS8.  the caller is then expected to decrypt
// the private key and hand back the decrypted contents.
//
// the parameters are:
// Algorithm - the algorithm used to encrypt the PrivateKeyInfo
// EncryptedPrivateKey - the encrypted private key blob
// pClearTextKey - a buffer to receive the clear text
// cbClearTextKey - the number of bytes of the pClearTextKey buffer
//                  note the if this is zero then this should be
//                  filled in with the size required to decrypt the
//                  key into, and pClearTextKey should be ignored
// pVoidDecryptFunc - this is the pVoid that was passed into the call
//                    and is preserved and passed back as context
//+-------------------------------------------------------------------------
typedef BOOL (CALLBACK *PCRYPT_DECRYPT_PRIVATE_KEY_FUNC)(
    __in CRYPT_ALGORITHM_IDENTIFIER Algorithm,
    __in CRYPT_DATA_BLOB EncryptedPrivateKey,
    __out_bcount_opt (*pcbClearTextKey) BYTE* pbClearTextKey,
    __inout DWORD* pcbClearTextKey,
    __in LPVOID pVoidDecryptFunc);

//+-------------------------------------------------------------------------
// this callback is given when creating a PKCS8 EncryptedPrivateKeyInfo.
// The caller is then expected to encrypt the private key and hand back
// the encrypted contents.
//
// the parameters are:
// Algorithm - the algorithm used to encrypt the PrivateKeyInfo
// pClearTextPrivateKey - the cleartext private key to be encrypted
// pbEncryptedKey - the output encrypted private key blob
// cbEncryptedKey - the number of bytes of the pbEncryptedKey buffer
//                  note the if this is zero then this should be
//                  filled in with the size required to encrypt the
//                  key into, and pbEncryptedKey should be ignored
// pVoidEncryptFunc - this is the pVoid that was passed into the call
//                    and is preserved and passed back as context
//+-------------------------------------------------------------------------
typedef BOOL (CALLBACK *PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC)(
    __out CRYPT_ALGORITHM_IDENTIFIER* pAlgorithm,
    __in CRYPT_DATA_BLOB* pClearTextPrivateKey,
    __out_bcount_opt (*pcbEncryptedKey) BYTE* pbEncryptedKey,
    __inout DWORD* pcbEncryptedKey,
    __in LPVOID pVoidEncryptFunc);

//+-------------------------------------------------------------------------
// this callback is given from the context of a ImportPKCS8 calls.  the caller
// is then expected to hand back an HCRYPTPROV to receive the key being imported
//
// the parameters are:
// pPrivateKeyInfo - pointer to a CRYPT_PRIVATE_KEY_INFO structure which
//                   describes the key being imported
// EncryptedPrivateKey - the encrypted private key blob
// phCryptProv - a pointer to a HCRRYPTPROV to be filled in
// pVoidResolveFunc - this is the pVoidResolveFunc passed in by the caller in the
//                    CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS struct
//+-------------------------------------------------------------------------
typedef BOOL (CALLBACK *PCRYPT_RESOLVE_HCRYPTPROV_FUNC)(
                                                       CRYPT_PRIVATE_KEY_INFO      *pPrivateKeyInfo,
                                                       HCRYPTPROV                  *phCryptProv,
                                                       LPVOID                      pVoidResolveFunc);

//+-------------------------------------------------------------------------
// this struct contains a PKCS8 private key and two pointers to callback
// functions, with a corresponding pVoids.  the first callback is used to give
// the caller the opportunity to specify where the key is imported to.  the callback
// passes the caller the algoroithm OID and key size to use in making the decision.
// the other callback is used to decrypt the private key if the PKCS8 contains an
// EncryptedPrivateKeyInfo.  both pVoids are preserved and passed back to the caller
// in the respective callback
//+-------------------------------------------------------------------------
typedef struct _CRYPT_PKCS8_IMPORT_PARAMS{
    CRYPT_DIGEST_BLOB               PrivateKey;             // PKCS8 blob
    PCRYPT_RESOLVE_HCRYPTPROV_FUNC  pResolvehCryptProvFunc; // optional
    LPVOID                          pVoidResolveFunc;       // optional
    PCRYPT_DECRYPT_PRIVATE_KEY_FUNC pDecryptPrivateKeyFunc;
    LPVOID                          pVoidDecryptFunc;
} CRYPT_PKCS8_IMPORT_PARAMS, *PCRYPT_PKCS8_IMPORT_PARAMS, CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS, *PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS;


//+-------------------------------------------------------------------------
// this struct contains information identifying a private key and a pointer
// to a callback function, with a corresponding pVoid. The callback is used
// to encrypt the private key. If the pEncryptPrivateKeyFunc is NULL, the
// key will not be encrypted and an EncryptedPrivateKeyInfo will not be generated.
// The pVoid is preserved and passed back to the caller in the respective callback
//+-------------------------------------------------------------------------
typedef struct _CRYPT_PKCS8_EXPORT_PARAMS{
    HCRYPTPROV                      hCryptProv;
    DWORD                           dwKeySpec;
    LPSTR                           pszPrivateKeyObjId;

    PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC pEncryptPrivateKeyFunc;
    LPVOID                          pVoidEncryptFunc;
} CRYPT_PKCS8_EXPORT_PARAMS, *PCRYPT_PKCS8_EXPORT_PARAMS;

//+-------------------------------------------------------------------------
//  Information stored in a certificate
//
//  The Issuer, Subject, Algorithm, PublicKey and Extension BLOBs are the
//  encoded representation of the information.
//--------------------------------------------------------------------------
// certenrolls_begin -- CERT_CONTEXT
typedef struct _CERT_INFO {
    DWORD                       dwVersion;
    CRYPT_INTEGER_BLOB          SerialNumber;
    CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
    CERT_NAME_BLOB              Issuer;
    FILETIME                    NotBefore;
    FILETIME                    NotAfter;
    CERT_NAME_BLOB              Subject;
    CERT_PUBLIC_KEY_INFO        SubjectPublicKeyInfo;
    CRYPT_BIT_BLOB              IssuerUniqueId;
    CRYPT_BIT_BLOB              SubjectUniqueId;
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} CERT_INFO, *PCERT_INFO;
// certenrolls_end

//+-------------------------------------------------------------------------
//  Certificate versions
//--------------------------------------------------------------------------
#define CERT_V1     0
#define CERT_V2     1
#define CERT_V3     2

//+-------------------------------------------------------------------------
//  Certificate Information Flags
//--------------------------------------------------------------------------
#define CERT_INFO_VERSION_FLAG                      1
#define CERT_INFO_SERIAL_NUMBER_FLAG                2
#define CERT_INFO_SIGNATURE_ALGORITHM_FLAG          3
#define CERT_INFO_ISSUER_FLAG                       4
#define CERT_INFO_NOT_BEFORE_FLAG                   5
#define CERT_INFO_NOT_AFTER_FLAG                    6
#define CERT_INFO_SUBJECT_FLAG                      7
#define CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG      8
#define CERT_INFO_ISSUER_UNIQUE_ID_FLAG             9
#define CERT_INFO_SUBJECT_UNIQUE_ID_FLAG            10
#define CERT_INFO_EXTENSION_FLAG                    11

//+-------------------------------------------------------------------------
//  An entry in a CRL
//
//  The Extension BLOBs are the encoded representation of the information.
//--------------------------------------------------------------------------
typedef struct _CRL_ENTRY {
    CRYPT_INTEGER_BLOB  SerialNumber;
    FILETIME            RevocationDate;
    DWORD               cExtension;
    PCERT_EXTENSION     rgExtension;
} CRL_ENTRY, *PCRL_ENTRY;

//+-------------------------------------------------------------------------
//  Information stored in a CRL
//
//  The Issuer, Algorithm and Extension BLOBs are the encoded
//  representation of the information.
//--------------------------------------------------------------------------
typedef struct _CRL_INFO {
    DWORD                       dwVersion;
    CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
    CERT_NAME_BLOB              Issuer;
    FILETIME                    ThisUpdate;
    FILETIME                    NextUpdate;
    DWORD                       cCRLEntry;
    PCRL_ENTRY                  rgCRLEntry;
    DWORD                       cExtension;
    PCERT_EXTENSION             rgExtension;
} CRL_INFO, *PCRL_INFO;

//+-------------------------------------------------------------------------
//  CRL versions
//--------------------------------------------------------------------------
#define CRL_V1     0
#define CRL_V2     1

//+-------------------------------------------------------------------------
// Certificate Bundle
//--------------------------------------------------------------------------
#define CERT_BUNDLE_CERTIFICATE 0
#define CERT_BUNDLE_CRL         1

typedef struct _CERT_OR_CRL_BLOB {
    DWORD                   dwChoice;
    DWORD                   cbEncoded;
    __field_bcount(cbEncoded)
    BYTE                    *pbEncoded;
} CERT_OR_CRL_BLOB, * PCERT_OR_CRL_BLOB;

typedef struct _CERT_OR_CRL_BUNDLE {
    DWORD                   cItem;
    __field_ecount(cItem)
    PCERT_OR_CRL_BLOB       rgItem;
} CERT_OR_CRL_BUNDLE, *PCERT_OR_CRL_BUNDLE;

//+-------------------------------------------------------------------------
//  Information stored in a certificate request
//
//  The Subject, Algorithm, PublicKey and Attribute BLOBs are the encoded
//  representation of the information.
//--------------------------------------------------------------------------
typedef struct _CERT_REQUEST_INFO {
    DWORD                   dwVersion;
    CERT_NAME_BLOB          Subject;
    CERT_PUBLIC_KEY_INFO    SubjectPublicKeyInfo;
    DWORD                   cAttribute;
    PCRYPT_ATTRIBUTE        rgAttribute;
} CERT_REQUEST_INFO, *PCERT_REQUEST_INFO;

//+-------------------------------------------------------------------------
//  Certificate Request versions
//--------------------------------------------------------------------------
#define CERT_REQUEST_V1     0

//+-------------------------------------------------------------------------
//  Information stored in Netscape's Keygen request
//--------------------------------------------------------------------------
typedef struct _CERT_KEYGEN_REQUEST_INFO {
    DWORD                   dwVersion;
    CERT_PUBLIC_KEY_INFO    SubjectPublicKeyInfo;
    LPWSTR                  pwszChallengeString;        // encoded as IA5
} CERT_KEYGEN_REQUEST_INFO, *PCERT_KEYGEN_REQUEST_INFO;

#define CERT_KEYGEN_REQUEST_V1     0


//+-------------------------------------------------------------------------
//  Certificate, CRL, Certificate Request or Keygen Request Signed Content
//
//  The "to be signed" encoded content plus its signature. The ToBeSigned
//  is the encoded CERT_INFO, CRL_INFO, CERT_REQUEST_INFO or
//  CERT_KEYGEN_REQUEST_INFO.
//--------------------------------------------------------------------------
typedef struct _CERT_SIGNED_CONTENT_INFO {
    CRYPT_DER_BLOB              ToBeSigned;
    CRYPT_ALGORITHM_IDENTIFIER  SignatureAlgorithm;
    CRYPT_BIT_BLOB              Signature;
} CERT_SIGNED_CONTENT_INFO, *PCERT_SIGNED_CONTENT_INFO;


//+-------------------------------------------------------------------------
//  Certificate Trust List (CTL)
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CTL Usage. Also used for EnhancedKeyUsage extension.
//--------------------------------------------------------------------------
typedef struct _CTL_USAGE {
    DWORD               cUsageIdentifier;
    LPSTR               *rgpszUsageIdentifier;      // array of pszObjId
} CTL_USAGE, *PCTL_USAGE,
CERT_ENHKEY_USAGE, *PCERT_ENHKEY_USAGE;
typedef const CTL_USAGE* PCCTL_USAGE;
typedef const CERT_ENHKEY_USAGE* PCCERT_ENHKEY_USAGE;


//+-------------------------------------------------------------------------
//  An entry in a CTL
//--------------------------------------------------------------------------
typedef struct _CTL_ENTRY {
    CRYPT_DATA_BLOB  