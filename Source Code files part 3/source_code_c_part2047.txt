ireMinutes; }
        }

        public string Description
        {
            get { return this.m_summary.szDescription; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\SystemMessage.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using xonline.common.protocol;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public class SystemMessage : IReadOnlySystemMessage
    {
        private IReadOnlySystemMessageHeader m_header;
        private MessageDetails m_details;
        private uint textStringId = 0;

        public SystemMessage(SystemMessageSummary summary, MessageDetails details)
        {
            this.m_header = new SystemMessageHeader(summary);
            this.m_details = details;
            int offset = 0;

            byte[] data = this.m_details.rgbData;

            // find the text value
            for (int i = 0; i < this.m_details.wPropCount; i++)
            {
                if (this.m_details.rgProperties[i].wPropTag == MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT)
                {
                    offset = this.m_details.rgProperties[i].wPropOffset;

                    System.IO.Stream stream = new System.IO.MemoryStream();

                    // find out the length of this property
                    stream.Write(data, 0, data.Length);
                    stream.Position = offset;
                    System.IO.BinaryReader reader = new BinaryReader(stream);

                    this.textStringId = reader.ReadUInt32();
                }
            }
        }

        public IReadOnlySystemMessageHeader Header
        {
            get { return this.m_header; }
        }

        public uint StringId
        {
            get { return this.textStringId; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\AccountEnums.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Profile
{
    public enum Privilege
    {
        None,
        Communication,
        ExplicitContent,
        MemberContent,
        OnlineGamePlay,
        OnlineFriends,
        OnlineStatus,
        OriginalXboxLiveGames,
        PlayedMusicSharing,
        PremiumContent,
        ProfileSharing,
        ProfileViewing,
        ProfileCustomization,
        VideoCommunication,
        GamesForWindowsMultiplayer,
        FriendsListSharing,
    }

    public enum PrivilegeValue
    {
        Allow,
        FriendsOnly,
        Deny
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Messaging\MessageHeader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using xonline.common.service;
using Leet.Live.Livecache.Logic.Profile;

namespace Leet.Live.Livecache.Logic.Messaging
{
    public class MessageHeader : IReadOnlyMessageHeader
    {
        private MessageSummary2 m_summary;
        private IGamerProfile m_userProfileSettings;

        public MessageHeader(MessageSummary2 summary)
            : this(summary, new GamerProfile())
        {
        }

        public MessageHeader(MessageSummary2 summary, IGamerProfile userProfileSettings)
        {
            this.m_summary = summary;
            this.m_userProfileSettings = userProfileSettings;
        }

        public MessageTypeEnum MessageType
        {
            get { return (MessageTypeEnum)(this.m_summary.bMessageType); }
        }

        public IGamerProfile UserProfileSettings
        {
            get { return this.m_userProfileSettings; }
        }

        public bool IsRequired
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_REQUIRED) > 0; }
        }

        public bool IsRecommended
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_RECOMMENDED) > 0; }
        }

        public bool HasVoice
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_HAS_VOICE) > 0; }
        }

        public bool HasImage
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_HAS_PHOTO) > 0; }
        }

        public bool HasText
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_HAS_TEXT) > 0; }
        }

        public bool HasBeenRead
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_READ) > 0; }
        }

        public bool AllowDisplayOnWeb
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_NON_EXPORTABLE) == 0; }
        }

        public bool IsTeamContext
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_TEAM_CONTEXT) > 0; }
        }

        public bool IsCompetitionContext
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_COMP_CONTEXT) > 0; }
        }

        public bool IsFromAlternateTitle
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_ALTERNATE_TITLE) > 0; }
        }

        public bool IsFromMarketing
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_MARKETING) > 0; }
        }

        public bool IsFromMicrosoftMarketing
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_MS_MARKETING) > 0; }
        }

        public bool IsFromFriend
        {
            get { return (this.m_summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_SENDER_IS_FRIEND) > 0; }
        }

        public bool IsFromZune
        {
            get { return this.m_summary.dwSenderTitleID == XOn.ZUNE_TITLE_ID; }
        }

        public ulong SenderId
        {
            get { return this.m_summary.qwSenderID; }
        }

        public string SenderGamertag
        {
            get { return this.m_summary.szSenderName; }
        }

        public uint MessageId
        {
            get { return this.m_summary.dwMessageID; }
        }

        public uint SenderTitleId
        {
            get { return this.m_summary.dwSenderTitleID; }
        }

        public DateTime SentTime
        {
            get
            {
                return MsgDefs.MsgTimeToDateTime(this.m_summary.mtSentTime);
            }
        }

        private void calculateExpiresTimeSpan()
        {
            // need to calculate this
            DateTime sentTime = this.SentTime;
            DateTime expiresTime = sentTime.AddMinutes(this.m_summary.wExpireMinutes);

            DateTime currentTime = DateTime.Now.ToUniversalTime();

            if (expiresTime < currentTime)
            {
                expiresTimeSpan = new TimeSpan(0);
            }
            else
            {
                expiresTimeSpan = expiresTime.Subtract(currentTime);
            }
        }

        private object expiresTimeSpan = null;
        public int Expires
        {
            get
            {
                if (expiresTimeSpan == null)
                {
                    calculateExpiresTimeSpan();
                }

                return (int)Math.Round(((TimeSpan)expiresTimeSpan).TotalMinutes);
            }
        }

        public int ExpiresInDays
        {
            get
            {
                if (expiresTimeSpan == null)
                {
                    calculateExpiresTimeSpan();
                }

                TimeSpan span = (TimeSpan)expiresTimeSpan;

                return (int)Math.Round(((TimeSpan)expiresTimeSpan).TotalDays, 0);
            }
        }

        public string Subject
        {
            get { return this.m_summary.szSubject; }
        }

        public bool CanDelete
        {
            get
            {
                return (this.MessageType == MessageTypeEnum.PersonalMessage ||
                    this.MessageType == MessageTypeEnum.TitleCustom ||
                    this.MessageType == MessageTypeEnum.VideoMessage);
            }
        }

        public bool CanSetReadFlag
        {
            get
            {
                return !(this.MessageType == MessageTypeEnum.TitleCustom ||
                    this.MessageType == MessageTypeEnum.GameInvite ||
                    this.MessageType == MessageTypeEnum.VideoMessage ||
                    this.MessageType == MessageTypeEnum.QuickChatInvite ||
                    this.MessageType == MessageTypeEnum.VideoChatInvite ||
                    this.HasImage ||
                    this.HasVoice);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\IReadOnlyFriendInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Profile
{
    public interface IReadOnlyFriendInfo : IReadOnlyPresenceInfo
    {
        new string Gamertag { get; }
        new ulong LivePuid { get; }
        FriendState FriendState { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\IReadOnlyGamerProfile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Leet.Live.Livecache.Logic.Avatars;

namespace Leet.Live.Livecache.Logic.Profile
{
    public interface IGamerProfile
    {
        ulong LivePuid { get; set; }

        string GamerTag { get; set; }
        string Bio { get; set; }
        string Name { get; set; }
        string Location { get; set; }
        string Motto { get; set; }
        int Gamerscore { get; set; }

        bool HasAcceptedTOU { get; set; }
        int Country { get; set; }
        float Reputation { get; set; }
        int ReputationBucket { get; }

        string GamerTileUrl { get; set; }
        string SecureGamerTileUrl { get; set; }
        string SmallGamerTileUrl { get; set; }
        string SecureSmallGamerTileUrl { get; set; }
        string GamerTileId { get; set; }

        GamercardZone Zone { get; set; }
        GamerTier Tier { get; set; }
        byte[] AvatarManifest { get; set; }
        AvatarBodyType AvatarBodyType { get;}

        bool IsLaunchTeamMember { get; }
        bool IsCheater { get; }
        bool IsNXELaunchTeamMember { get; }

        int ProfilePermissions { get; set; }
        PrivilegeValue ProfileActivityPrivilege { get; set; }
        PrivilegeValue ProfileUserCreatedContentPrivilege { get; set; }
        PrivilegeValue PlayedMusicSharingPrivilege { get; set; }

        string GamerTile { get; set; }

        string BlogUrl { get; set; }

        GamerTypeFlags GamerType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\IReadOnlyPresenceInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Profile
{
    public interface IReadOnlyPresenceInfo
    {
        string Gamertag { get; }
        OnlineState State { get; }
        ulong LivePuid { get; }
        bool IsOnline { get; }
        bool IsJoinable { get; }
        bool IsPlaying { get; }
        DateTime LastSeen { get; }
        uint TitleId { get; }
        string PresenceString { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\GamerProfile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.service;

using Leet.Live.Livecache.Logic.Avatars;

namespace Leet.Live.Livecache.Logic.Profile
{
    public class GamerProfile : IGamerProfile
    {
        private static Guid AvatarBodyAssetMaleId = new Guid(0x00000002, 0x0000, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);
        private static Guid AvatarBodyAssetFemaleId = new Guid(0x00000002, 0x0001, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0);

        public GamerProfile()
        {
        }

        public GamerProfile(ulong livepuid, string gamertag)
        {
            this.LivePuid = livepuid;
            this.GamerTag = gamertag;
        }

        #region IGamerProfile Members

        public ulong LivePuid { get; set; }
        public string GamerTag { get; set; }
        public string Bio { get; set; }

        public string Name { get; set; }

        public string Location { get; set; }

        public int Gamerscore { get; set; }

        public string Motto { get; set; }

        public bool HasAcceptedTOU { get; set; }

        public int Country { get; set; }

        public float Reputation { get; set; }

        public int ReputationBucket 
        {
            get
            {
                if ((float.IsNaN(Reputation)) || (Reputation <= 0))
                {
                    return 0;
                }
                else if (Reputation >= 100)
                {
                    return 20;
                }
                else
                {
                    int roundedRepuation = Convert.ToInt32(Reputation);
                    return Convert.ToInt32(Math.Ceiling(roundedRepuation / 5.0f));
                }

            }
        }

        public string GamerTileUrl { get; set; }

        public string SecureGamerTileUrl { get; set; }

        public string SmallGamerTileUrl { get; set; }

        public string SecureSmallGamerTileUrl { get; set; }

        // TODO: Is this the equivalent of the GamerTile property from xboxcom?
        /// <summary>
        /// Gets or sets the gamer tile location information.
        /// </summary>
        /// <remarks>
        /// This property is null if it has not been loaded or the information is unavailable.
        /// (e.g. Permission denied when fetching from stats profile service).
        /// This value is a 24 character string in the form of "XXXXXXXXYYYYYYYYZZZZZZZZ",
        /// where:
        /// X is the title id for the image
        /// Y is the normal 64x64 image id
        /// Z is the 32x32 image id
        /// The storage path for a tile is //global/t:[titleid]/tile/0/[image id].
        /// </remarks>
        public string GamerTileId { get; set; }

        public GamercardZone Zone { get; set; }

        public GamerTier Tier { get; set; }

        public bool IsLaunchTeamMember
        {
            get
            {
                return ((GamerType & GamerTypeFlags.LaunchTeam) != 0);
            }
        }
        public bool IsCheater
        {
            get
            {
                return ((GamerType & GamerTypeFlags.Cheater) != 0);
            }
        }
        public bool IsNXELaunchTeamMember 
        {
            get
            {
                return ((GamerType & GamerTypeFlags.NXELaunchTeam) != 0);
            }
        }        

        public byte[] AvatarManifest { get; set; }

        public GamerTypeFlags GamerType { get; set; }

        public int ProfilePermissions { get; set; }

        public PrivilegeValue ProfileActivityPrivilege
        {
            get
            {
                return GetPrivilegeValue(XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS, XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE);
            }
            set
            {
                SetPrivilegeValue(value, XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS, XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE);
            }
        }

        public PrivilegeValue ProfileUserCreatedContentPrivilege
        {
            get
            {
                return GetPrivilegeValue(XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS, XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE);
            }
            set
            {
                SetPrivilegeValue(value, XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS, XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE);
            }
        }

        public PrivilegeValue PlayedMusicSharingPrivilege
        {
            get
            {
                return GetPrivilegeValue(XOn.XPROFILE_PERMISSION_SHARE_MUSIC_FRIENDS, XOn.XPROFILE_PERMISSION_SHARE_MUSIC_NOONE);
            }
            set
            {
                SetPrivilegeValue(value, XOn.XPROFILE_PERMISSION_SHARE_MUSIC_FRIENDS, XOn.XPROFILE_PERMISSION_SHARE_MUSIC_NOONE);
            }
        }

        public AvatarBodyType AvatarBodyType
        {
            get
            {
                if (AvatarManifest != null)
                {
                    xonline.common.service.AvatarManifest avatarManifest = xonline.common.service.AvatarManifest.Read(AvatarManifest);
                    if (avatarManifest.BodyComponentInfo.ModelAssetId.Id == AvatarBodyAssetMaleId)
                    {
                        return AvatarBodyType.Male;
                    }
                    else if (avatarManifest.BodyComponentInfo.ModelAssetId.Id == AvatarBodyAssetFemaleId)
                    {
                        return AvatarBodyType.Female;
                    }
                    else
                    {
                        return AvatarBodyType.Unknown;
                    }
                }
                else
                {
                    return AvatarBodyType.Unknown;
                }
            }
        }

        public string GamerTile { get; set; }

        public string BlogUrl { get; set; }

        #endregion



        private PrivilegeValue GetPrivilegeValue(byte friendsOnlyFlag, byte nooneFlag)
        {
            if (ProfilePermissions == int.MinValue)
            {
                throw new Exception("ProfilePermissions is invalid");
            }

            PrivilegeValue privilegeValue = PrivilegeValue.Allow;
            if ((ProfilePermissions & nooneFlag) == nooneFlag)
            {
                privilegeValue = PrivilegeValue.Deny;
            }
            else if ((ProfilePermissions & friendsOnlyFlag) == friendsOnlyFlag)
            {
                privilegeValue = PrivilegeValue.FriendsOnly;
            }
            return privilegeValue;
        }

        private void SetPrivilegeValue(PrivilegeValue value, byte friendsOnlyFlag, byte nooneFlag)
        {
            if (ProfilePermissions == int.MinValue)
            {
                // If profile permissions haven't been set yet then we have to initialize 
                // it to 0 before mask in any privileges
                ProfilePermissions = 0;
            }

            // Clear the friends only flag and the noone flag
            ProfilePermissions &= ~(friendsOnlyFlag | nooneFlag);
            if (value == PrivilegeValue.FriendsOnly)
            {
                ProfilePermissions |= friendsOnlyFlag;
            }
            else if (value == PrivilegeValue.Deny)
            {
                ProfilePermissions |= nooneFlag;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\WebPreferences.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Profile
{
    public interface IWebPreferences
    {
        ulong LivePuid { get; set; }
        bool AcceptedTou { get; set; }
        bool AcceptedTouValid { get; set; }
        Consoles OwnedConsoles { get; set; }
        FavoriteGenreFlag FavoriteGenres { get; set; }
        EmailFormats EmailFormat { get; set; }
        ConnectionSpeeds InternetConnection { get; set; }
        ImageTypePreferences ImageType { get; set; }
        VideoBandwidthPreferences VideoBandwidth { get; set; }
        int FavoriteGame1 { get; set; }
        int FavoriteGame2 { get; set; }
        int FavoriteGame3 { get; set; }
        int FavoriteGame4 { get; set; }
        int FavoriteGame5 { get; set; }
        int FavoriteGame6 { get; set; }
    }

    internal class WebPreferences : IWebPreferences
    {
        public ulong LivePuid { get; set; }
        public bool AcceptedTou { get; set; }
        public bool AcceptedTouValid { get; set; }
        public Consoles OwnedConsoles { get; set; }
        public FavoriteGenreFlag FavoriteGenres { get; set; }
        public EmailFormats EmailFormat { get; set; }
        public ConnectionSpeeds InternetConnection { get; set; }
        public ImageTypePreferences ImageType { get; set; }
        public VideoBandwidthPreferences VideoBandwidth { get; set; }
        public int FavoriteGame1 { get; set; }
        public int FavoriteGame2 { get; set; }
        public int FavoriteGame3 { get; set; }
        public int FavoriteGame4 { get; set; }
        public int FavoriteGame5 { get; set; }
        public int FavoriteGame6 { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\FriendInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Profile
{
    [Flags]
    public enum LaunchTypes
    {
        None = 0x0000,
        Launch = 0x0001,
        NXE = 0x0002,
        All = 0xFFFF
    }

    [Flags]
    public enum FriendStateFilter
    {
        None = 0x0000,
        Requesting = 0x0001,
        Pending = 0x0002,
        Busy = 0x0004,
        Away = 0x0010,
        Online = 0x0020,
        Offline = 0x0040,
        All = 0xFFFF
    }

    public enum FriendState
    {
        Friend,
        Pending,
        Requesting,
        NotAFriend,
    }

    class FriendInfo : IReadOnlyFriendInfo
    {
        // FriendInfo members
        public FriendState FriendState { get; set; }
        public string Gamertag { get; set; }
        public ulong LivePuid { get; set; }

        // PresenceInfo members
        string IReadOnlyPresenceInfo.Gamertag 
        { 
            get { return this.Gamertag; }
        }
        ulong IReadOnlyPresenceInfo.LivePuid 
        {
            get { return this.LivePuid; }
        }
        public OnlineState State { get; set; }
        public bool IsOnline { get; set; }
        public bool IsJoinable { get; set; }
        public bool IsPlaying { get; set; }
        public DateTime LastSeen { get; set; }
        public uint TitleId { get; set; }
        public string PresenceString { get; set; }


        public FriendInfo()
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\PresenceInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Profile
{
    public enum OnlineState
    {
        Online,
        Offline,
        Away,
        Busy,
        Unknown
    }

    class PresenceInfo : IReadOnlyPresenceInfo
    {
        public string Gamertag { get; set; }
        public OnlineState State { get; set; }
        public ulong LivePuid { get; set; }
        public bool IsOnline { get; set; }
        public bool IsJoinable { get; set; }
        public bool IsPlaying { get; set; }
        public DateTime LastSeen { get; set; }
        public uint TitleId { get; set; }
        public string PresenceString { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\ProfileSetting.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;

namespace Leet.Live.Livecache.Logic.Profile
{
    public class ProfileSetting
    {
        public uint SettingId { get; set; }
        public uint Source { get; set; }
        public ulong UserId { get; set; }
        public byte[] Value { get; set; }
        public ushort ValueLen { get; set; }

        public ProfileSetting()
            : this(0, 0, 0, null)
        {
        }

        public ProfileSetting(ulong userId, uint settingId)
            : this(userId, 0, settingId, null)
        {
        }

        public ProfileSetting(ulong userId, uint source, uint settingId, byte[] value)
        {
            this.UserId = userId;
            this.Source = source;
            this.SettingId = settingId;
            this.Value = value;
        }

        public ProfileSetting(UserSetting setting)
        {
            this.UserId = setting.UserId;
            this.Source = setting.Source;
            this.SettingId = setting.SettingId;
            this.Value = setting.Value;
        }

        internal UserSetting ToUserSetting()
        {
            return new UserSetting(
                this.UserId,
                this.Source,
                this.SettingId,
                this.Value);
        }

        internal static UserSetting[] ToArray(ProfileSetting[] settings)
        {
            UserSetting[] userSettings = new UserSetting[settings.Length];

            for (int i = 0; i < settings.Length; i++)
            {
                userSettings[i] = settings[i].ToUserSetting();
            }

            return userSettings;
        }

        internal static ProfileSetting[] FromArray(UserSetting[] settings)
        {
            ProfileSetting[] profileSettings = new ProfileSetting[settings.Length];

            for (int i = 0; i < settings.Length; i++)
            {
                profileSettings[i] = new ProfileSetting(settings[i]);
            }

            return profileSettings;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\WebPreferencesEnums.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.Profile
{
    public enum Consoles : int
    {
        None = 0x00000000,
        Xbox = 0x00000001,
        Xbox360 = 0x00000002,
        PS1 = 0x00000004,
        PS2 = 0x00000008,
        PSP = 0x00000010,
        N64 = 0x00000020,
        Gamecube = 0x00000040,
        NDS = 0x00000080,
        PS3 = 0x00000100,
        PC = 0x00000200,
        Dreamcast = 0x00000400,
        Genesis = 0x00000800,
        Wii = 0x00001000,
        Unknown = 0x40000000
    }

    public enum FavoriteGenreFlag : int
    {
        None = 0x00000000,
        Action = 0x00000001,
        Compilations = 0x00000002,
        Fighting = 0x00000004,
        Racing = 0x00000008,
        Shooter = 0x00000010,
        Sports = 0x00000020,
        Adventure = 0x00000040,
        Family = 0x00000080,
        Platform = 0x00000100,
        RolePlaying = 0x00000200,
        Simulation = 0x00000400,
        Strategy = 0x00000800,
        Unknown = 0x40000000
    }

    public enum ConnectionSpeeds : byte
    {
        Unknown = 0,
        Cable,
        Dsl,
        T1,
        Modem,
        FTTH
    }

    public enum VideoBandwidthPreferences : byte
    {
        Unknown = 0,
        Low,
        High
    }

    public enum EmailFormats
    {
        Unknown = 0,
        Text = 1,
        HTML
    }

    public enum ImageTypePreferences : byte
    {
        Unknown = 0,
        Static,
        Flash
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\RecentPlayers\IRecentPlayerCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.RecentPlayers
{
    public interface IRecentPlayerCollection
    {
        IReadOnlyRecentPlayer this[int index] { get; set; }

        IList<IReadOnlyRecentPlayer> AsReadOnlyList();

        List<IReadOnlyRecentPlayer>.Enumerator GetEnumerator();

        void Add(IReadOnlyRecentPlayer player);

        bool Contains(IReadOnlyRecentPlayer player);

        int Count { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\Profile\ProfilePrivileges.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.service;

namespace Leet.Live.Livecache.Logic.Profile
{
    public class ProfilePrivileges
    {
        /// <summary>
        /// Utility method used to parse the privilege array received from Livecache
        /// </summary>
        /// <param name="privileges">Raw privilege field returned from Livecache</param>
        /// <returns></returns>
        public static Dictionary<Privilege, PrivilegeValue> Parse(uint[] privileges)
        {
            Dictionary<Privilege, PrivilegeValue> privs = new Dictionary<Privilege, PrivilegeValue>();

            privs.Add(Privilege.Communication, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_COMMUNICATIONS, XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY));
            privs.Add(Privilege.VideoCommunication, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS, XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY));
            privs.Add(Privilege.ExplicitContent, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_MUSIC_EXPLICIT_CONTENT));
            privs.Add(Privilege.MemberContent, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_USER_CREATED_CONTENT, XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY));
            privs.Add(Privilege.OnlineFriends, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_ADD_FRIEND));
            privs.Add(Privilege.OnlineGamePlay, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS));
            privs.Add(Privilege.OnlineStatus, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_PRESENCE, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY));
            privs.Add(Privilege.OriginalXboxLiveGames, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_XBOX1_LIVE_ACCESS));
            privs.Add(Privilege.PremiumContent, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_PURCHASE_CONTENT));
            privs.Add(Privilege.ProfileViewing, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_PROFILE_VIEWING, XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY));
            privs.Add(Privilege.GamesForWindowsMultiplayer, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER));
            privs.Add(Privilege.FriendsListSharing, GetPrivilegeValue(privileges, XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY));

            return privs;
        }

        /// <summary>
        /// Privilege test method to be used for privileges with tri-part values (yes, no, friends only)
        /// </summary>
        /// <param name="privileges"></param>
        /// <param name="privilegeId"></param>
        /// <param name="friendsOnlyId"></param>
        /// <returns></returns>
        private static PrivilegeValue GetPrivilegeValue(uint[] privileges, byte privilegeId, byte friendsOnlyId)
        {
            PrivilegeValue privilegeValue = PrivilegeValue.Deny;

            if(LivePrivilegeSet.Test(privileges, privilegeId))
            {
                privilegeValue = PrivilegeValue.Allow;
            }
            else if (LivePrivilegeSet.Test(privileges, friendsOnlyId))
            {
                privilegeValue = PrivilegeValue.FriendsOnly;
            }

            return privilegeValue;
        }


        /// <summary>
        /// Privilege test method to be used for privileges with binary values (yes, no)
        /// </summary>
        /// <param name="privileges"></param>
        /// <param name="privilegeId"></param>
        /// <returns></returns>
        private static PrivilegeValue GetPrivilegeValue(uint[] privileges, byte privilegeId)
        {
            PrivilegeValue privilegeValue = PrivilegeValue.Deny;

            if (LivePrivilegeSet.Test(privileges, privilegeId))
            {
                privilegeValue = PrivilegeValue.Allow;
            }

            return privilegeValue;
        }

        /// <summary>
        /// Return the priviledge value for given profilePermissions (property in Profile object)
        /// </summary>
        /// <param name="profilePermissions"></param>
        /// <returns></returns>
        public static PrivilegeValue GetProfileCustomizationPermission(int profilePermissions)
        {
            return GetPrivilegeValue(profilePermissions, XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS, XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE);
        }

        private static PrivilegeValue GetPrivilegeValue(int profilePermissions, byte friendsOnlyFlag, byte nooneFlag)
        {
            PrivilegeValue privilegeValue = PrivilegeValue.Allow;
            if ((profilePermissions & nooneFlag) == nooneFlag)
            {
                privilegeValue = PrivilegeValue.Deny;
            }
            else if ((profilePermissions & friendsOnlyFlag) == friendsOnlyFlag)
            {
                privilegeValue = PrivilegeValue.FriendsOnly;
            }
            return privilegeValue;
        }

        /// <summary>
        /// Utility method used to save back updated privilege fields for a user
        /// </summary>
        /// <param name="livePuid"></param>
        /// <param name="privileges"></param>
        public static void Save(ulong livePuid, uint[] privileges)
        {
            throw new NotImplementedException();

            // TODO:  Implement this method to save back updated privileges

            //// Set a default of nobody in the off case that it wasn't set correctly
            //if (WebTicket.Current.ParentalControlGroup == XOn.PARENTAL_CONTROL_GROUP_RESTRICTED)
            //{
            //    privileges[Privileges.PlayedMusicSharing] = PrivilegeValue.Deny;
            //}
            //string zuneUsageBitValue = ZUNEUSAGEBIT_NOBODY;
            //bool zuneUsageBitChanged = false;


            //// the dictionary will only contain values we set (or left the same) on the page viewed
            //// so this method called from the vela page will only contain vela values, etc.
            //System.Collections.ArrayList addPrivileges = new System.Collections.ArrayList();
            //System.Collections.ArrayList revokePrivileges = new System.Collections.ArrayList();

            ////get profile permission setting
            //GamerProfile profile = _statsAccess.GetGamerProfile(livePuid, livePuid);
            //int profilePermission = profile.ProfilePermissions;

            //// translate from our enums to the xonline enums
            //foreach (KeyValuePair<Privileges, PrivilegeValue> kvp in privileges)
            //{
            //    switch (kvp.Key)
            //    // handle each of the privileges...
            //    {
            //        case Privileges.Communication:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS);
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS);
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
            //                    break;
            //            }
            //            break;
            //        case Privileges.VideoCommunication:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS);
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS);
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY);
            //                    break;
            //            }
            //            break;
            //        case Privileges.ExplicitContent:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_MUSIC_EXPLICIT_CONTENT);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    throw new ArgumentException();
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_MUSIC_EXPLICIT_CONTENT);
            //                    break;
            //            }
            //            break;
            //        case Privileges.MemberContent:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
            //                    break;
            //            }
            //            break;
            //        case Privileges.OnlineFriends:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_ADD_FRIEND);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    throw new ArgumentException();
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_ADD_FRIEND);
            //                    break;
            //            }
            //            break;
            //        case Privileges.OnlineGamePlay:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    throw new ArgumentException();
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS);
            //                    break;
            //            }
            //            break;
            //        case Privileges.OnlineStatus:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE);
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE);
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
            //                    break;
            //            }
            //            break;
            //        case Privileges.OriginalXboxLiveGames:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_XBOX1_LIVE_ACCESS);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    throw new ArgumentException();
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_XBOX1_LIVE_ACCESS);
            //                    break;
            //            }
            //            break;
            //        case Privileges.PremiumContent:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_PURCHASE_CONTENT);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    throw new ArgumentException();
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_PURCHASE_CONTENT);
            //                    break;
            //            }
            //            break;
            //        case Privileges.ProfileViewing:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING);
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING);
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
            //                    break;
            //            }
            //            break;
            //        case Privileges.GamesForWindowsMultiplayer:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    throw new ArgumentException();
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_MULTIPLAYER_DEDICATED_SERVER);
            //                    break;
            //            }
            //            break;
            //        case Privileges.ProfileSharing:
            //            int profileSharingMask = 0xffff ^ (XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE | XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS);
            //            int uccSharingMask = 0xffff ^ (XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE | XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    profilePermission = profilePermission & profileSharingMask & uccSharingMask;
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    profilePermission = (profilePermission & profileSharingMask) | XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE;
            //                    profilePermission = (profilePermission & uccSharingMask) | XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE;
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    profilePermission = (profilePermission & profileSharingMask) | XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS;
            //                    profilePermission = (profilePermission & uccSharingMask) | XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS;
            //                    break;
            //            }
            //            break;
            //        case Privileges.ProfileCustomization:
            //            int profileCustomizeMask = 0xffff ^ (XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE | XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS);
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    profilePermission = profilePermission & profileCustomizeMask;
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    profilePermission = (profilePermission & profileCustomizeMask) | XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE;
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    profilePermission = (profilePermission & profileCustomizeMask) | XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS;
            //                    break;
            //            }
            //            break;
            //        case Privileges.FriendsListSharing:
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST);
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    addPrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST);
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST);
            //                    revokePrivileges.Add((uint)XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);
            //                    break;
            //            }
            //            break;
            //        case Privileges.PlayedMusicSharing:
            //            int playedMusicSharingMask = 0xffff ^ (XOn.XPROFILE_PERMISSION_SHARE_MUSIC_NOONE | XOn.XPROFILE_PERMISSION_SHARE_MUSIC_FRIENDS);
            //            zuneUsageBitChanged = true;
            //            switch (kvp.Value)
            //            {
            //                case PrivilegeValue.Allow:
            //                    profilePermission = profilePermission & playedMusicSharingMask;
            //                    zuneUsageBitValue = ZUNEUSAGEBIT_EVERYBODY;
            //                    break;
            //                case PrivilegeValue.Deny:
            //                    profilePermission = (profilePermission & playedMusicSharingMask) | XOn.XPROFILE_PERMISSION_SHARE_MUSIC_NOONE;
            //                    zuneUsageBitValue = ZUNEUSAGEBIT_NOBODY;
            //                    break;
            //                case PrivilegeValue.FriendsOnly:
            //                    profilePermission = (profilePermission & playedMusicSharingMask) | XOn.XPROFILE_PERMISSION_SHARE_MUSIC_FRIENDS;
            //                    zuneUsageBitValue = ZUNEUSAGEBIT_FRIENDS;
            //                    break;
            //            }
            //            break;
            //    }

            //}

            //if (addPrivileges.Count > 0 || revokePrivileges.Count > 0)
            //{
            //    // convert the arraylists to arrays of uints
            //    uint[] add = new uint[8];
            //    uint[] revoke = new uint[8];
            //    for (int i = 0; i < 8; i++)
            //    {
            //        add[i] = 0;
            //        revoke[i] = 0;
            //    }


            //    foreach (uint ui in addPrivileges)
            //    {
            //        LivePrivilegeSet.Set(add, (int)ui);
            //    }
            //    foreach (uint ui in revokePrivileges)
            //    {
            //        LivePrivilegeSet.Set(revoke, (int)ui);
            //    }

            //    // now call the DAL method
            //    _dataAccess.UpdateParentalControls(livePuid, add, revoke, "Web-" + XboxcomLib.LibProperty.SubProperty().ToString());
            //}
            ////update profile permission settings
            //SaveGamerProfilePermission(livePuid, profilePermission);
            //if ((XboxcomLib.LibProperty.Property() == WebProperty.Zune) && (zuneUsageBitChanged))
            //    SaveZuneUsageBit(livePuid, zuneUsageBitValue);

            ////expire existing web ticket which stored old privacy settings
            //WebTicketManager.CreateWebTicket(true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\RecentPlayers\IReadOnlyRecentPlayer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;

namespace Leet.Live.Livecache.Logic.RecentPlayers
{
    public interface IReadOnlyRecentPlayer
    {
        ulong UserLivepuid { get; }
        string Gamertag { get; }
        string GamerTileUrl { get; }
        int ReputationBucket { get; }
        int GamerScore { get; }
        GamercardZone GamerZone { get; }
        RecentPlayerStatus Status { get; }
        string GameTitleName { get; }
        DateTime LastMetDate { get; }
        string GameTitleTileUrl { get; }
        GamerTier Tier { get; }
        LaunchTypes LaunchType { get; }
    }

    public enum RecentPlayerStatus 
    { 
        Neutral, 
        Preferred, 
        Avoided 
    }

    public enum AffiliateFlag
    {
        Encountered,
        Completed,
        Positive,
        Negative,
        Avoiding,
        Friend,
        Block,
        Mute
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\RecentPlayers\RecentPlayer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;

namespace Leet.Live.Livecache.Logic.RecentPlayers
{
    internal class RecentPlayer : IReadOnlyRecentPlayer
    {
        private ulong userLivepuid = 0;
        public ulong UserLivepuid
        {
            get { return userLivepuid; }
            set { userLivepuid = value; }
        }

        private string gamertag = String.Empty;
        public string Gamertag
        {
            get { return gamertag; }
            set { gamertag = value; }
        }

        private string gamerTileUrl = String.Empty;
        public string GamerTileUrl
        {
            get { return gamerTileUrl; }
            set { gamerTileUrl = value; }
        }

        private int reputationBucket = 0;
        public int ReputationBucket
        {
            get { return reputationBucket; }
            set { reputationBucket = value; }
        }

        private int gamerScore = 0;
        public int GamerScore
        {
            get { return gamerScore; }
            set { gamerScore = value; }
        }

        private GamercardZone gamerZone = GamercardZone.Unknown;
        public GamercardZone GamerZone
        {
            get { return gamerZone; }
            set { gamerZone = value; }
        }

        private RecentPlayerStatus status = RecentPlayerStatus.Preferred;
        public RecentPlayerStatus Status
        {
            get { return status; }
            set { status = value; }
        }

        private string gameTitleName = String.Empty;
        public string GameTitleName
        {
            get { return gameTitleName; }
            set { gameTitleName = value; }
        }

        private DateTime lastMetDate = DateTime.MinValue;
        public DateTime LastMetDate
        {
            get { return lastMetDate; }
            set { lastMetDate = value; }
        }

        private string gameTitleTileUrl = String.Empty;
        public string GameTitleTileUrl
        {
            get { return gameTitleTileUrl; }
            set { gameTitleTileUrl = value; }
        }

        public GamerTier Tier { get; set; }
        public LaunchTypes LaunchType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\RecentPlayers\RecentPlayerCollectionBuilder.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.protocol;
using Leet.Live.Livecache.Logic.Profile;
using System.Collections;

namespace Leet.Live.Livecache.Logic.RecentPlayers
{
    internal class RecentPlayerCollectionBuilder
    {
        public static uint GetAffiliateListFlag(AffiliateFlag flag)
        {
            int index = 0;
            switch (flag)
            {
                case AffiliateFlag.Encountered:
                    index = (int)PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX;
                    break;
                case AffiliateFlag.Completed:
                    index = (int)PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX;
                    break;
                case AffiliateFlag.Positive:
                    index = (int)PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX;
                    break;
                case AffiliateFlag.Negative:
                    index = (int)PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX;
                    break;
                case AffiliateFlag.Avoiding:
                    index = (int)PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX;
                    break;
                case AffiliateFlag.Friend:
                    index = (int)PresDefs.X_AFFILIATE_FRIEND_INDEX;
                    break;
                case AffiliateFlag.Block:
                    index = (int)PresDefs.X_AFFILIATE_BLOCK_INDEX;
                    break;
                case AffiliateFlag.Mute:
                    index = (int)PresDefs.X_AFFILIATE_MUTE_INDEX;
                    break;
            }
            return (uint)(1 << index);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Logic\RecentPlayers\RecentPlayerCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Logic.RecentPlayers
{
    internal class RecentPlayerCollection : IRecentPlayerCollection
    {
        private List<IReadOnlyRecentPlayer> _list;

        public RecentPlayerCollection()
        {
            _list = new List<IReadOnlyRecentPlayer>();
        }

        public IReadOnlyRecentPlayer this[int index]
        {
            get
            {
                return (_list[index]);
            }
            set
            {
                _list[index] = value;
            }
        }

        public IList<IReadOnlyRecentPlayer> AsReadOnlyList()
        {
            return _list.AsReadOnly();
        }

        public List<IReadOnlyRecentPlayer>.Enumerator GetEnumerator()
        {
            return _list.GetEnumerator();
        }

        public void Add(IReadOnlyRecentPlayer player)
        {
            _list.Add(player);
        }

        public bool Contains(IReadOnlyRecentPlayer player)
        {
            return _list.Contains(player);
        }

        public int Count
        {
            get { return _list.Count; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\AnonymousAuthDataProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using xonline.common.webplatform.livecache;
using xonline.common.service;

namespace Leet.Live.Livecache.Providers
{
    public class AnonymousAuthDataProvider : IAccountAuthDataProvider
    {
        private const ulong NoFriendsFakeLivePuid = 1;
        private const byte NoTier = 0;

        private static uint[] PublicProfilePrivileges;


        #region IAccountAuthDataProvider Members

        public IPEndPoint ClientIPEndPoint
        {
            get { return null; }
        }

        public ulong LivePuid
        {
            get { return NoFriendsFakeLivePuid; }
        }

        public uint[] Privileges
        {
            get 
            {
                if (PublicProfilePrivileges == null)
                {
                    uint[] newPrivs = new uint[XOn.PRIVILEGE_DWORD_LENGTH];

                    // find the DWORD containing this bit
                    int dwordIndex = XOn.XPRIVILEGE_PROFILE_VIEWING / 32;

                    // find the bit offset within the DWORD
                    int bitIndex = XOn.XPRIVILEGE_PROFILE_VIEWING - dwordIndex * 32;

                    // create the mask
                    newPrivs[dwordIndex] |= ((uint)1) << bitIndex;

                    PublicProfilePrivileges = newPrivs;
                }

                return PublicProfilePrivileges;
            }
        }

        public byte Tier
        {
            get { return NoTier; }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\DebugLivecacheLoggerProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.config;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    public class DebugLivecacheLoggerProvider : ILivecacheLoggerProvider
    {
        #region ILivecacheLoggerProvider Members

        /// <summary>
        /// This method registers a delegate that will handle log events from the Livecache data access
        /// providers.  It is also responsible for setting the correct component name that will be
        /// used for any logged events.
        /// </summary>
        public void RegisterLogger(string componentName)
        {
            // Set the correct component name
            Config.ComponentName = componentName;

            // Register delegate
            LivecacheClient.CreateLoggerHandler d = delegate(string area, string component)
            {
                return new DebugLivecacheLogger(area, component);
            };

            LivecacheClient.RegisterCreateLoggerHandler(d);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Live.Livecache")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("2afdf6b7-385a-4790-908a-71b4760f6a0c")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\DefaultLivecacheLocaleProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    /// <summary>
    /// Forces Livecache culture to default en-US culture.
    /// 
    /// Livecache cultures require the console language and country IDs.  EN is language ID 1
    /// and US is country ID 103.
    /// </summary>
    public class DefaultLivecacheLocaleProvider : ILivecacheLocaleProvider
    {
        private const uint EN_LANG_ID = 1;
        private const uint US_COUNTRY_ID = 103;

        [System.ThreadStatic] public static uint langId;
        [System.ThreadStatic] public static uint countryId;

        public void RegisterLocaleHandler()
        {
            LivecacheRequest.CurrentLocaleHandler = new LivecacheLocaleHandler(delegate(out uint language, out uint country)
                {
                    if (langId == 0)
                    {
                        langId = EN_LANG_ID;
                    }

                    if (countryId == 0)
                    {
                        countryId = US_COUNTRY_ID;
                    }

                    language = langId;
                    country = countryId;
                });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\ILivecacheClientIdentifierProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    public interface ILivecacheClientIdentifierProvider
    {
        LivecacheClientType GetClientType();
        uint GetClientTitleId();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\ILivecacheLocaleProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Providers
{
    public interface ILivecacheLocaleProvider
    {
        void RegisterLocaleHandler();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\ILivecacheLoggerProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Livecache.Providers
{
    public interface ILivecacheLoggerProvider
    {
        void RegisterLogger(string component);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\ILocalLivecacheContextProvider.cs ===
﻿
namespace Leet.Live.Livecache.Providers
{
    public interface ILocalLivecacheContextProvider
    {
        void RegisterLocalContext();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\IWebRequestClientIdentifierProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    public interface IWebRequestClientIdentifierProvider
    {
        LivecacheClientType GetClientType();
        uint GetClientTitleId();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\LIVEnLivecacheClientIdenitfierProvider.cs ===
﻿using Leet.Live.Livecache.Providers;
using xonline.common.webplatform.livecache;
using xonline.common.service;

namespace Leet.Live.Livecache.Providers
{
    /// <summary>
    /// Client identifier provider to the LIVEn
    /// </summary>
    public class LIVEnLivecacheClientIdentifierProvider : ILivecacheClientIdentifierProvider
    {
        #region ILivecacheClientIdentifierProvider Members

        public LivecacheClientType GetClientType()
        {
            return LivecacheClientType.LIVEn;
        }

        public uint GetClientTitleId()
        {
            return XOn.WEB_TITLE_ID;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\LIVEnServiceMobileExtendedAuthDataProvider.cs ===
﻿
namespace Leet.Live.Livecache.Providers
{
    using System.Net;
    using Leet.Live.Livecache.Account;
    using xonline.common.service;
    using xonline.common.webplatform.livecache;

    public class LIVEnServiceMobileExtendedAuthDataProvider : IExtendedAuthDataProvider
    {
        private byte _tier = 0;
        private uint[] _privileges = null;
        private ILcAuthTicket _authTicket;
        private ILcAuthManager _authManager;

        [System.ThreadStatic] public static ulong Puid;
        [System.ThreadStatic] public static string PlatformType;

        public LIVEnServiceMobileExtendedAuthDataProvider(ILcAuthManager lcAuthManager)
        {
            _authManager = lcAuthManager;
        }

        #region IAccountAuthDataProvider Members

        public ulong LivePuid
        {
            get
            {
                return Puid;
            }
        }

        public byte Tier
        {
            get
            {
                _authTicket = _authManager.GetAuthTicket();
                return (_authTicket == null ? _tier : (byte)_authTicket.Tier);
            }
        }

        public uint[] Privileges
        {
            get
            {
                _authTicket = _authManager.GetAuthTicket();
                return _authTicket == null ? _privileges : _authTicket.Privileges;
            }
        }

        public IPEndPoint ClientIPEndPoint
        {
            get
            {
                return new IPEndPoint(0, 0);
            }
        }

        public byte ClientPlatform
        {
            get
            {
                if (!string.IsNullOrEmpty(PlatformType))
                {
                    return GetClientPlatformType(PlatformType);
                }
                else
                {
                    // default to mobile for this provider
                    return XOn.XPLT_MOBILE;
                }
            }
        }

        public ulong XboxPuid
        {
            get; set;
        }

        public byte GetClientPlatformType(string platformType)
        {
            uint platformTypeNum = uint.Parse(platformType);

            if (platformTypeNum == (uint)Core.Platforms.PlatformType.Mobile)
            {
                return XOn.XPLT_MOBILE;
            }
            else if (platformTypeNum == (uint)Core.Platforms.PlatformType.WebGames)
            {
                return XOn.XPLT_WEB_GAMES;
            }

            // default to mobile for this provider
            return XOn.XPLT_MOBILE;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\LivecacheLoggerProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.common.config;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    public class LivecacheLoggerProvider : ILivecacheLoggerProvider
    {
        #region ILivecacheLoggerProvider Members

        /// <summary>
        /// This method registers a delegate that will handle log events from the Livecache data access
        /// providers.  It is also responsible for setting the correct component name that will be
        /// used for any logged events.
        /// </summary>
        public void RegisterLogger(string componentName)
        {
            // Set the correct component name
            Config.ComponentName = componentName;

            // Register delegate
            LivecacheClient.CreateLoggerHandler d = delegate(string area, string component)
            {
                return new LivecacheLogger(area, component);
            };

            LivecacheClient.RegisterCreateLoggerHandler(d);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\LocalLivecacheContextProvider.cs ===
﻿using xonline.common.webplatform.livecache;
using Leet.Core.IoCCo;

namespace Leet.Live.Livecache.Providers
{
    public class LocalLivecacheContextProvider : ILocalLivecacheContextProvider
    {
        public void RegisterLocalContext()
        {
            LivecacheClient.LocalLivecacheContext = Container.Instance.GetComponent<ILocalLivecacheContext>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\NonWebContextItemProvider.cs ===
﻿using System.Collections.Generic;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    /// <summary>
    /// A context item provider with a simple cache that lasts only for the lifetime of the object.
    /// Consumers of this context item provider should expect to maintain an instance of this object
    /// for the lifetime of the request context in order to get the most benefit from the cache.
    /// </summary>
    public class NonWebContextItemProvider : IContextItemProvider
    {
        private Dictionary<string, object> storage = new Dictionary<string, object>();

        #region IContextItemProvider Members

        public object this[string name]
        {
            get
            {
                object contextItem = null;
                this.storage.TryGetValue(name, out contextItem);

                return contextItem;
            }
            set
            {
                this.storage[name] = value;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\LIVEnWebMobileExtendedAuthDataProvider.cs ===
﻿
namespace Leet.Live.Livecache.Providers
{
    using System;
    using System.Net;
    using System.Net.Sockets;
    using System.ServiceModel;
    using System.ServiceModel.Web;
    using System.Web;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Live.Livecache.Account;
    using xonline.common.service;
    using xonline.common.webplatform.livecache;

    [PerWebRequestInstance]
    public class LIVEnWebMobileExtendedAuthDataProvider : IExtendedAuthDataProvider
    {
        private ulong _livePuid = 0;
        private byte _tier = 0;
        private uint[] _privileges = null;
        private IPEndPoint _clientIPEndPoint = null;
        private ILcAuthTicket _authTicket;
        private ILcAuthManager _authManager;

        public LIVEnWebMobileExtendedAuthDataProvider(ILcAuthManager lcAuthManager)
        {
            _authManager = lcAuthManager;
        }

        public ulong LivePuid
        {
            get
            {
                _authTicket = _authManager.GetAuthTicket();
                return (_authTicket == null ? _livePuid : _authTicket.LivePuid); 
            }
        }

        public byte Tier
        {
            get 
            {
                _authTicket = _authManager.GetAuthTicket();
                return (_authTicket == null ? _tier : (byte)_authTicket.Tier); 
            }
        }

        public uint[] Privileges
        {
            get 
            {
                _authTicket = _authManager.GetAuthTicket();
                return (_authTicket == null ? _privileges : _authTicket.Privileges); 
            }
        }

        public IPEndPoint ClientIPEndPoint
        {
            get
            {
                IPEndPoint endpoint = _clientIPEndPoint;

                if (endpoint == null)
                {
                    endpoint = GetIPEndPointFromHttpContext();
                }

                if (endpoint == null)
                {
                    return new IPEndPoint(0, 0);
                }

                return endpoint;
            }
        }

        // this method may throw various exceptions
        // we want to handle only the cases when platformType is null or empty and return a bad request
        public byte ClientPlatform
        {
            get
            {
                string platformType = WebOperationContext.Current.IncomingRequest.Headers[CustomWebHeaderNames.XPlatformType];

                if (String.IsNullOrEmpty(platformType))
                {
                    // Default to Web
                    platformType = ((uint)Core.Platforms.PlatformType.WebGames).ToString();
                 }

                return GetClientPlatformType(platformType);
            }
        }

        public ulong XboxPuid
        {
            get
            {
                _authTicket = _authManager.GetAuthTicket();
                return (_authTicket == null ? _livePuid : _authTicket.LivePuid);
            }
        }

        private IPEndPoint GetIPEndPointFromHttpContext()
        {
            HttpContext context = HttpContext.Current;

            if (context == null)
            {
                return null;
            }

            HttpRequest request = context.Request;

            if (request == null)
            {
                return null;
            }
            
            string addressString = request.UserHostAddress;

            if (String.IsNullOrEmpty(addressString))
            {
                return null;
            }

            IPAddress address = null;

            // Get the IPv4 address since it'll return IPv6 if enabled on machine
            foreach (IPAddress ipa in Dns.GetHostAddresses(addressString))
            {
                if (ipa.AddressFamily == AddressFamily.InterNetwork)
                {
                    address = ipa;
                    break;
                }
            }

            if (address == null)
            {
                return null;
            }

            // Currently not sure that we really need the client port.
            // Since the HttpRequest doesn't expose this directly and requires the slower
            // query of ServerVariables[] to get the client port, just going
            // to set port to 0 here. However, leaving open the option to centrally set 
            // the port if needed later.
            return new IPEndPoint(address, 0);
        }

        public byte GetClientPlatformType(string platformType)
        {
            uint platformTypeNum = uint.Parse(platformType);

            if (platformTypeNum == (uint)Core.Platforms.PlatformType.Mobile)
            {
                return XOn.XPLT_MOBILE;
            }
            else if (platformTypeNum == (uint)Core.Platforms.PlatformType.WebGames)
            {
                return XOn.XPLT_WEB_GAMES;
            }

            return XOn.XPLT_WEB_GAMES;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\NullContextItemProvider.cs ===
﻿using System.Web;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    /// <summary>
    /// An empty implementation of IContextItemProvider that provides no local caching of
    /// Livecache data.
    /// </summary>
    public class NullContextItemProvider : IContextItemProvider
    {
        #region IContextItemProvider Members

        public object this[string name]
        {
            get
            {
                return null;
            }
            set
            {
                
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\WGXLivecacheClientIdentifierProvider.cs ===
﻿using xonline.common.service;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    public class WGXLivecacheClientIdentifierProvider : ILivecacheClientIdentifierProvider
    {
        #region ILivecacheClientIdentifierProvider Members

        public LivecacheClientType GetClientType()
        {
            return LivecacheClientType.WGX;
        }

        public uint GetClientTitleId()
        {
            return (uint)4293722112;  // TODO:  Need to verify WGX title ID
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\XboxcomLivecacheClientIdentifierProvider.cs ===
﻿using Leet.Live.Livecache.Providers;
using xonline.common.webplatform.livecache;
using xonline.common.service;

namespace Leet.Live.Livecache.Providers
{
    public class XboxcomLivecacheClientIdentifierProvider : ILivecacheClientIdentifierProvider
    {
        #region ILivecacheClientIdentifierProvider Members

        public LivecacheClientType GetClientType()
        {
            return LivecacheClientType.Xboxcom;
        }

        public uint GetClientTitleId()
        {
            return XOn.WEB_TITLE_ID;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\WebContextItemProvider.cs ===
﻿using System.Web;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Providers
{
    /// <summary>
    /// This ContextItemProvider should be used by web applications as it internally implements
    /// an HttpContext cache.
    /// </summary>
    public class WebContextItemProvider : IContextItemProvider
    {
        public object this[string name]
        {
            get
            {
                object contextItem = null;
                if (HttpContext.Current != null)
                {
                    contextItem = HttpContext.Current.Items[name];
                }
                return contextItem;
            }
            set
            {
                if (HttpContext.Current != null)
                {
                    HttpContext.Current.Items[name] = value;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\CoreLivecacheTests.cs ===
﻿using Leet.Core.IoCCo;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.common.webplatform.livecache;
using Leet.Core.Configuration;

namespace Leet.Live.Livecache.Test
{
    [TestClass]
    public class CoreLivecacheTests
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_Init_And_Local_Context_Access()
        {
            // Arrange
            var stubs = RegisterStubs();

            // Act
            stubs.LocalContextProvider.RegisterLocalContext();
            stubs.LocaleProvider.RegisterLocaleHandler();
            stubs.LoggerProvider.RegisterLogger("testcomponent");

            var localContext = Container.Instance.GetComponent<ILocalLivecacheContext>();
            localContext["Key"] = "Value";

            // Assert
            Assert.AreEqual("Value", localContext["Key"].ToString());
        }

        private static Stubs RegisterStubs()
        {         
            var stubs = new Stubs { Stubber = new Stubber() };
         
            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.LocalContextProvider = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContextProvider>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();
            stubs.LocaleProvider = stubs.Stubber.RegisterWithContainer<ILivecacheLocaleProvider>();
            stubs.LoggerProvider = stubs.Stubber.RegisterWithContainer<ILivecacheLoggerProvider>();
            stubs.ConfigProvider = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;
            public ILocalLivecacheContextProvider LocalContextProvider;
            public ILivecacheLocaleProvider LocaleProvider;
            public ILivecacheLoggerProvider LoggerProvider;
            public IConfigurationProvider ConfigProvider;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache\Providers\WebAuthDataProvider.cs ===
﻿using System;
using System.Net;
using System.Net.Sockets;
using System.Web;
using Leet.Core.IoCCo;
using xonline.common.webplatform.livecache;
using Leet.Live.Livecache.Account;

namespace Leet.Live.Livecache.Providers
{
    [PerWebRequestInstance]
    public class WebAuthDataProvider : IAccountAuthDataProvider
    {
        private ulong _livePuid = 0;
        private byte _tier = 0;
        private uint[] _privileges = null;
        private IPEndPoint _clientIPEndPoint = null;
        private ILcAuthTicket _authTicket;
        private ILcAuthManager _authManager;

        public WebAuthDataProvider(ILcAuthManager lcAuthManager)
        {
            _authManager = lcAuthManager;
        }

        public ulong LivePuid
        {
            get 
            {
                _authTicket = _authManager.GetAuthTicket();
                return (_authTicket == null ? _livePuid : _authTicket.LivePuid); 
            }
        }

        public byte Tier
        {
            get 
            {
                _authTicket = _authManager.GetAuthTicket();
                return (_authTicket == null ? _tier : (byte)_authTicket.Tier); 
            }
        }

        public uint[] Privileges
        {
            get 
            {
                _authTicket = _authManager.GetAuthTicket();
                return (_authTicket == null ? _privileges : _authTicket.Privileges); 
            }
        }

        public IPEndPoint ClientIPEndPoint
        {
            get
            {
                IPEndPoint endpoint = _clientIPEndPoint;

                if (endpoint == null)
                {
                    endpoint = GetIPEndPointFromHttpContext();
                }

                if (endpoint == null)
                {
                    return new IPEndPoint(0, 0);
                }

                return endpoint;

            }
        }

        private IPEndPoint GetIPEndPointFromHttpContext()
        {
            HttpContext context = HttpContext.Current;

            if (context == null)
            {
                return null;
            }

            HttpRequest request = context.Request;

            if (request == null)
            {
                return null;
            }
            
            string addressString = request.UserHostAddress;

            if (String.IsNullOrEmpty(addressString))
            {
                return null;
            }

            IPAddress address = null;

            // Get the IPv4 address since it'll return IPv6 if enabled on machine
            foreach (IPAddress ipa in Dns.GetHostAddresses(addressString))
            {
                if(ipa.AddressFamily == AddressFamily.InterNetwork)
                {
                    address = ipa;
                    break;
                }
            }

            if (address == null)
            {
                return null;
            }

            // Currently not sure that we really need the client port.
            // Since the HttpRequest doesn't expose this directly and requires the slower
            // query of ServerVariables[] to get the client port, just going
            // to set port to 0 here. However, leaving open the option to centrally set 
            // the port if needed later.
            return new IPEndPoint(address, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\DataAccess\AchievementDataAccessTest.cs ===
﻿using System;
using System.Collections.Generic;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Achievements;
using Leet.Live.Livecache.Logic.Games;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.Account.DataAccess
{
    [TestClass]
    public class AchievementDataAccessTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_GetUserTitles()
        {
            const int expectedNumTitles = 5;

            Stubs stubs = RegisterStubs();

            EnumTitlesResponse etrResponse = GetEnumTitlesResponse();
            stubs.LcAchievement.Stub(lca => lca.GetUserTitles(Arg<EnumTitlesRequest>.Is.Anything)).Return(etrResponse);
            stubs.LcStringSvr.Stub(
                    lss => lss.StringLookup(
                        Arg<uint>.Is.Anything,
                        Arg<uint>.Is.Anything,
                        Arg<ushort>.Is.Anything,
                        out Arg<DateTime>.Out(new DateTime()).Dummy
                        )
                ).Return("LocalizedTitle");

            IAchievementDataAccess ada = new AchievementDataAccess(stubs.LcAchievement, stubs.LcStringSvr, stubs.ContextItemProvider);

            List<IReadOnlyUserTitle> titles = ada.GetUserTitles(0, 0, 0, 0, 5);

            Assert.IsNotNull(titles);
            Assert.AreEqual(expectedNumTitles, titles.Count);
        }

        [TestMethod]
        public void Test_GetPublicUserTitles()
        {
            const int expectedNumTitles = 5;
            DateTime dummyDT;

            Stubs stubs = RegisterStubs();

            EnumTitlesResponse etrResponse = GetEnumTitlesResponse();

            stubs.LcAchievement.Stub(lca => lca.GetPublicUserTitles(
                    Arg<EnumTitlesRequest>.Is.Anything,
                    Arg<IAccountAuthDataProvider>.Is.Anything,
                    out Arg<DateTime>.Out(new DateTime()).Dummy
                    )
                ).Return(etrResponse);
            
            stubs.LcStringSvr.Stub(lss => lss.StringLookup(
                    Arg<uint>.Is.Anything,
                    Arg<uint>.Is.Anything,
                    Arg<ushort>.Is.Anything,
                    out Arg<DateTime>.Out(new DateTime()).Dummy
                    )
                ).Return("LocalizedTitle");

            IAchievementDataAccess ada = new AchievementDataAccess(stubs.LcAchievement, stubs.LcStringSvr, stubs.ContextItemProvider);

            List<IReadOnlyUserTitle> titles = ada.GetPublicUserTitles(0, 0, 0, 0, out dummyDT);

            Assert.IsNotNull(titles);
            Assert.AreEqual(expectedNumTitles, titles.Count);
        }

        [TestMethod]
        public void Test_Single_Page_of_Achievements()
        {
            // Arrange
            int expectedAchievementCount = 1;

            var stubs = RegisterStubs();
            AchievementEnumResponse response = GetPartialPageResponse();
            stubs.LcAchievement.Stub(lca => lca.GetUserAchievements(Arg<AchievementEnumRequest>.Is.Anything)).Return(response);

            IAchievementDataAccess ada = new AchievementDataAccess(stubs.LcAchievement, stubs.LcStringSvr, stubs.ContextItemProvider);

            // Act
            List<IReadOnlyAchievementInfo> achievements = ada.GetUserAchievements(0, 0, 0, 0);

            // Assert
            Assert.IsNotNull(achievements);
            Assert.AreEqual(expectedAchievementCount, achievements.Count);
        }

        [TestMethod]
        public void Test_Multiple_Pages_of_Achievements()
        {
            // Arrange
            int expectedAchievementCount = XOn.XONLINE_MAX_ACHIEVEMENTS + 1;

            var stubs = RegisterStubs();
            AchievementEnumResponse fullResponse = GetFullPageResponse();
            AchievementEnumResponse partialResponse = GetPartialPageResponse();

            // Page 1 response (32 records)
            stubs.LcAchievement
                .Stub(lca => lca.GetUserAchievements(Arg<AchievementEnumRequest>
                    .Matches(aer => aer.StartingIndex == 0)))
                .Return(fullResponse);

            // Page 2 response (1 record)
            stubs.LcAchievement
                .Stub(lca => lca.GetUserAchievements(Arg<AchievementEnumRequest>
                    .Matches(aer => aer.StartingIndex == XOn.XONLINE_MAX_ACHIEVEMENTS)))
                .Return(partialResponse);

            IAchievementDataAccess ada = new AchievementDataAccess(stubs.LcAchievement, stubs.LcStringSvr, stubs.ContextItemProvider);

            // Act
            List<IReadOnlyAchievementInfo> achievements = ada.GetUserAchievements(0, 0, 0, 0);

            // Assert
            Assert.IsNotNull(achievements);
            Assert.AreEqual(expectedAchievementCount, achievements.Count);
        }

        [TestMethod]
        [ExpectedException(typeof(System.ArgumentException))]
        public void Test_SyncAchievements()
        {
            // Arrange
            var stubs = RegisterStubs();
            IAchievementDataAccess ada = new AchievementDataAccess(stubs.LcAchievement, stubs.LcStringSvr, stubs.ContextItemProvider);

            // Act
            ada.SyncAchievements(0, 0, 0, null);

            // Assert
        }

        [TestMethod]
        public void Test_SyncTitles()
        {
            // Arrange
            var stubs = RegisterStubs();
            IAchievementDataAccess ada = new AchievementDataAccess(stubs.LcAchievement, stubs.LcStringSvr, stubs.ContextItemProvider);

            // Act
            ada.SyncTitles(0, 0, 0, DateTime.UtcNow);

            // Assert
            
        }

        private static AchievementEnumResponse GetFullPageResponse()
        {
            AchievementEnumResponse response = new AchievementEnumResponse();
            response.AchievementsCount = XOn.XONLINE_MAX_ACHIEVEMENTS;
            response.Achievements = new Achievement[XOn.XONLINE_MAX_ACHIEVEMENTS];
            for (int i = 0; i < XOn.XONLINE_MAX_ACHIEVEMENTS; ++i)
            {
                response.Achievements[i] = new Achievement((uint)i, DateTime.Now, 0);
            }

            return response;
        }

        private static AchievementEnumResponse GetPartialPageResponse()
        {
            AchievementEnumResponse response = new AchievementEnumResponse();
            response.AchievementsCount = 1;
            response.Achievements = new Achievement[1];
            response.Achievements[0] = new Achievement((uint)1, DateTime.Now, 0);

            return response;
        }

        private static EnumTitlesResponse GetEnumTitlesResponse()
        {
            EnumTitlesResponse response = new EnumTitlesResponse();

            xonline.common.protocol.UserTitle[] titles = new xonline.common.protocol.UserTitle[5];
            response.TitlesLen = (ushort)titles.Length;
            for (int i = 0; i < titles.Length; i++)
            {
                titles[i] = new xonline.common.protocol.UserTitle(0, DateTime.Now, 0, 0, 0);
            }
            response.Titles = titles;
            return response;
        }

        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();

            stubs.LcAchievement = stubs.Stubber.RegisterWithContainer<ILcAchievement>();
            stubs.LcStringSvr = stubs.Stubber.RegisterWithContainer<ILcStringSvr>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;
            public ILcStringSvr LcStringSvr;
            public ILcAchievement LcAchievement;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\DataAccess\PresenceDataAccessTest.cs ===
﻿using System;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Providers;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using Leet.Core.IoCCo;
using Leet.TestUtilities;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.DataAccess
{
    [TestClass]
    public class PresenceDataAccessTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        [ExpectedException(typeof(System.ArgumentOutOfRangeException))]
        public void No_Presence_Results_Throws_Exception()
        {
            // Arrange
            var stubs = RegisterStubs();
            PresenceInfoResponse pir = GetBrokenPresenceInfoResponse();
            stubs.LcPresence.Stub(lcp => lcp.GetPresenceInfo(Arg<GetPresenceInfoRequest>.Is.Anything)).Return(pir);
            IPresenceDataAccess pda = new PresenceDataAccess(stubs.LcPresence, stubs.IdentProvider);

            // Act
            IReadOnlyPresenceInfo presence = pda.GetPresenceInfo(0, 0);

            // Assert
        }

        [TestMethod]
        [ExpectedException(typeof(System.ArgumentOutOfRangeException))]
        public void No_Public_Presence_Results_Throws_Exception()
        {
            // Arrange
            DateTime ttl = DateTime.Now;

            var stubs = RegisterStubs();
            PresenceInfoResponse pir = GetBrokenPresenceInfoResponse();
            stubs.LcPresence.Stub(lcp => lcp.GetPublicPresenceInfo(Arg<GetPresenceInfoRequest>.Is.Anything, out Arg<DateTime>.Out(ttl).Dummy)).Return(pir);
            IPresenceDataAccess pda = new PresenceDataAccess(stubs.LcPresence, stubs.IdentProvider);

            // Act
            IReadOnlyPresenceInfo presence = pda.GetPublicPresenceInfo(0, out ttl);

            // Assert
        }


        private static PresenceInfoResponse GetBrokenPresenceInfoResponse()
        {
            PresenceInfoResponse pir = new PresenceInfoResponse();
            pir.header.dwMsgType = 1057;
            pir.header.dwMsgLen = 66;
            pir.header.dwSeqNum = 0x0;
            pir.qwSenderID = 2600292642020749;
            pir.cdwUsers = 0;
            pir.rgUsers = new PresenceInfoData[0];

            return pir;
        }

        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();

            stubs.LcPresence = stubs.Stubber.RegisterWithContainer<ILcPresence>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;

            public ILcPresence LcPresence;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\DataAccess\BillingOfferingDataAccessTest.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Text;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Live.Livecache;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.DataAccess
{
    [TestClass]
    public class BillingOfferingDataAccessTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void GetPurchaseHistoryTest()
        {
            Stubs stubs = RegisterStubs();

            Int32 entryCount = 5;
            LiveCacheWebSvcResponse response = new LiveCacheWebSvcResponse();
            response.response = CreatePurchaseHistoryResponse(entryCount);

            stubs.BillingOffering.Stub(lcBillingOffering => lcBillingOffering.PurchaseHistory(Arg<ulong>.Is.Anything, Arg<LivecacheWebSvcRequest>.Is.Anything)).Return(response);

            IBillingOfferingDataAccess bo = new BillingOfferingDataAccess(stubs.BillingOffering);

            ReadOnlyCollection<PurchaseHistoryEntry>  purchaseHistoryEntries = bo.GetPurchaseHistory(2456891090);

            Assert.IsTrue(purchaseHistoryEntries != null, "purchaseHistoryEntries cannot be null");
            Assert.IsTrue(purchaseHistoryEntries.Count == entryCount, "Purchase History Entry count should be " + entryCount);
            //TODO: Other asserts
        }

        [TestMethod]
        public void GetPurchaseHistoryResponseNullTest()
        {
            Stubs stubs = RegisterStubs();

            stubs.BillingOffering.Stub(lcBillingOffering => lcBillingOffering.PurchaseHistory(Arg<ulong>.Is.Anything, Arg<LivecacheWebSvcRequest>.Is.Anything)).Return(null);

            IBillingOfferingDataAccess bo = new BillingOfferingDataAccess(stubs.BillingOffering);

            ReadOnlyCollection<PurchaseHistoryEntry> purchaseHistoryEntries = bo.GetPurchaseHistory(2456891090);

            Assert.IsTrue(purchaseHistoryEntries == null, "purchaseHistoryEntries should be null");

        }

        [TestMethod]
        public void GetPurchaseHistoryResponseStringNullTest()
        {
            Stubs stubs = RegisterStubs();

            LiveCacheWebSvcResponse response = new LiveCacheWebSvcResponse();
            response.response = String.Empty;

            stubs.BillingOffering.Stub(lcBillingOffering => lcBillingOffering.PurchaseHistory(Arg<ulong>.Is.Anything, Arg<LivecacheWebSvcRequest>.Is.Anything)).Return(response);

            IBillingOfferingDataAccess bo = new BillingOfferingDataAccess(stubs.BillingOffering);

            ReadOnlyCollection<PurchaseHistoryEntry> purchaseHistoryEntries = bo.GetPurchaseHistory(2456891090);

            Assert.IsTrue(purchaseHistoryEntries == null, "purchaseHistoryEntries should be null");

        }

        private String CreatePurchaseHistoryResponse(Int32 entryCount)
        {
            String response = String.Empty;

            return response;
        }

        private static Stubs RegisterStubs()
        {
            Stubs stubs = new Stubs { Stubber = new Stubber() };

            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();
            stubs.Config = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();
            stubs.BillingOffering = stubs.Stubber.RegisterWithContainer<ILcBillingOffering>();
            stubs.ClientIdentifierProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            return stubs;
        }

        private class Stubs
        {
            public Stubber Stubber;
            public IAccountAuthDataProvider AuthDataProvider;
            public IConfigurationProvider Config;
            public ILcBillingOffering BillingOffering;
            public ILivecacheClientIdentifierProvider ClientIdentifierProvider;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\DataAccess\SettingsDataAccessTest.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Text;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Live.Livecache;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.DataAccess
{
    /// <summary>
    /// Summary description for SettingsDataAccessTest
    /// </summary>
    [TestClass]
    public class SettingsDataAccessTest
    {

        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_GetGamerProfile()
        {
            //Arange
            Stubs stubs = RegisterStubs();
            ReadSettingsResponse response = GetReadSettingsResponse();
            string testGamerTag = "TestGamerTag";

            stubs.XCache.Stub(xc => xc.GetGamertagByPuid(Arg<ulong>.Is.Anything, out Arg<string>.Out(testGamerTag).Dummy)).Return(true);
            stubs.LcStats.Stub(lcs => lcs.ReadSettings(
                Arg<ulong>.Is.Anything,
                Arg<ulong>.Is.Anything,
                Arg<uint[]>.Is.Anything,
                Arg<IAccountAuthDataProvider>.Is.Anything)).Return(response);

            //Act
            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache);
            IGamerProfile profile = sda.GetGamerProfile(0, 0);

            //Assert
            Assert.IsNotNull(profile);
            Assert.IsFalse(String.IsNullOrEmpty(profile.GamerTag));

            Assert.IsFalse(String.IsNullOrEmpty(profile.GamerTileUrl));
            Assert.IsFalse(String.IsNullOrEmpty(profile.SecureGamerTileUrl));
            Assert.IsFalse(String.IsNullOrEmpty(profile.SmallGamerTileUrl));
            Assert.IsFalse(String.IsNullOrEmpty(profile.SecureSmallGamerTileUrl));
        }

        #region Awardable Assets
        [TestMethod]
        public void TestAwardableAssets()
        {
            Stubs stubs = RegisterStubs();
            AvatarAssetEnumResponse liveCacheResponse = CreateAvatarAssetEnumResponse();

            //TODO: stubs.LcStats.Stub(lcStats => lcStats.GetUserAvatarAwards(Arg<AvatarAssetEnumRequest>.Is.Anything, Arg<IAccountAuthDataProvider>.Is.Anything)).Return(liveCacheResponse);

            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache);

             ReadOnlyCollection<AwardedAvatarAsset> awardedAssets = sda.GetUserAvatarAwards(98656568987, 1033);

             CompareExcpectedAndActualAssets(awardedAssets, liveCacheResponse);
        }

        [TestMethod]
        public void TestAwardableAssetsLiveCacheReturnsNoAssets()
        {
            Stubs stubs = RegisterStubs();

           //TODO: stubs.LcStats.Stub(lcStats => lcStats.GetUserAvatarAwards(Arg<AvatarAssetEnumRequest>.Is.Anything, Arg<IAccountAuthDataProvider>.Is.Anything)).Return(null);

            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache);

            ReadOnlyCollection<AwardedAvatarAsset> awardedAssets = sda.GetUserAvatarAwards(98656568987, 1033);

            Assert.AreEqual<Int32>(awardedAssets.Count,  0, "awarded assets count should be 0");
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException), "livePUID")]
        public void TestAwardableAssetsExceptionWhenPUIDisZero()
        {
            Stubs stubs = RegisterStubs();
            
            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache);
            
            ReadOnlyCollection<AwardedAvatarAsset> awardedAssets = sda.GetUserAvatarAwards(0, 1033);
        }

        [TestMethod]
        [ExpectedException(typeof(InvalidOperationException), " InvalidOperation")]
        public void TestAwardableAssetsLiveCacheException()
        {
            Stubs stubs = RegisterStubs();
         
            //TODO:stubs.LcStats.Stub(lcStats => lcStats.GetUserAvatarAwards(Arg<AvatarAssetEnumRequest>.Is.Anything, Arg<IAccountAuthDataProvider>.Is.Anything)).Throw(new InvalidOperationException("InvalidOperation"));

            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache);

            ReadOnlyCollection<AwardedAvatarAsset> awardedAssets = sda.GetUserAvatarAwards(98656568987, 1033);
        }
        
  

        #endregion

        [TestMethod]
        public void Test_GetPublicGamerProfile()
        {
            //Arange
            Stubs stubs = RegisterStubs();
            ReadSettingsResponse response = GetReadSettingsResponse();
            string testGamerTag = "TestGamerTag";

            stubs.XCache.Stub(xc => xc.GetGamertagByPuid(Arg<ulong>.Is.Anything, out Arg<string>.Out(testGamerTag).Dummy)).Return(true);
            stubs.LcStats.Stub(lcs => lcs.PublicReadSettings(
                Arg<ulong>.Is.Anything,
                Arg<uint[]>.Is.Anything,
                out Arg<DateTime>.Out(new DateTime()).Dummy)).Return(response);

            //Act
            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache);
            IGamerProfile profile = sda.GetPublicGamerProfile(0);

            //Assert
            Assert.IsNotNull(profile);
            Assert.IsFalse(String.IsNullOrEmpty(profile.GamerTag));

            Assert.IsFalse(String.IsNullOrEmpty(profile.GamerTileUrl));
            Assert.IsFalse(String.IsNullOrEmpty(profile.SecureGamerTileUrl));
            Assert.IsFalse(String.IsNullOrEmpty(profile.SmallGamerTileUrl));
            Assert.IsFalse(String.IsNullOrEmpty(profile.SecureSmallGamerTileUrl));
        }
        
        private ReadSettingsResponse GetReadSettingsResponse()
        {
            UnicodeEncoding encoder = new UnicodeEncoding();
            ReadSettingsResponse response = new ReadSettingsResponse();
            response.Settings = new UserSetting[1];
            response.Settings[0] = new UserSetting(0, 0, 0x4064000F, encoder.GetBytes(""));

            return response;
        }
        
        private static Stubs RegisterStubs()
        {
            Stubs stubs = new Stubs { Stubber = new Stubber() };

            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();
            stubs.Config = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();
            stubs.LcAchievement = stubs.Stubber.RegisterWithContainer<ILcAchievement>();
            stubs.LcStats = stubs.Stubber.RegisterWithContainer<ILcStats>();
            stubs.XCache = stubs.Stubber.RegisterWithContainer<IXCacheDataAccess>();
            return stubs;
        }

        private class Stubs
        {
            public Stubber Stubber;
            public IAccountAuthDataProvider AuthDataProvider;
            public IConfigurationProvider Config;
            public ILcAchievement LcAchievement;
            public ILcStats LcStats;
            public IXCacheDataAccess XCache;
        }

        private void CompareExcpectedAndActualAssets(ReadOnlyCollection<AwardedAvatarAsset> awardedAssets, AvatarAssetEnumResponse liveCacheResponse)
        {
            Int32 assetCountExcpected = liveCacheResponse.AvatarAssetsCount;
            Assert.AreEqual<ushort>(liveCacheResponse.AvatarAssetsCount, (ushort)awardedAssets.Count, "Asset Count");
            for (Int32 count = 0; count < assetCountExcpected; count++)
            {
                Assert.AreEqual<Guid>(new Guid(liveCacheResponse.AvatarAssets[count].AvatarAssetId), new Guid(awardedAssets[count].AvatarAssetId), "AssetIDs");
            }
        }

        private AvatarAssetEnumResponse CreateAvatarAssetEnumResponse()
        {
            Int32 assetCount = 5;
            AvatarAssetEnumResponse response = new AvatarAssetEnumResponse();
            response.AvatarAssetsCount = (ushort)assetCount;
            response.AvatarAssets = new AvatarAsset[assetCount];
            for (Int32 count = 0; count < assetCount; count++)
            {
                AvatarAsset asset = new AvatarAsset();
                asset.AvatarAssetId = Guid.NewGuid().ToByteArray();
                asset.AvatarAssetOrdinal = (uint)count;
                asset.Description = "Asset " + count.ToString();
                response.AvatarAssets[count] = asset;
            }

            return response;
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\DataAccess\AccountCreationDataAccessTest.cs ===
﻿using System;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Providers;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using Leet.Core.IoCCo;
using Leet.TestUtilities;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.DataAccess
{
    [TestClass]
    public class AccountCreationDataAccessTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Validate_Out_Params_Set_Correctly()
        {
            // Arrange
            ulong livePuid = 1;
            uint expectedTier = 0;
            uint expectedParentalControlGroup = 0;
            int expectedPrivilegesLength = 1;

            uint tier;
            uint[] privileges;
            DateTime lastWebActivity;
            byte parentalControlGroup;
            bool isLightAccount;
            bool isProvisioned;
            byte accountType;

            var stubs = RegisterStubs();
            XeGetUserWebInfoResponse resp = GetStandardWebInfoResponse();
            stubs.LcAccountCreation.Stub(lcac => lcac.GetUserWebInfo(Arg<XeGetUserWebInfoRequest>.Is.Anything)).Return(resp);
            IAccountCreationDataAccess acda = new AccountCreationDataAccess(stubs.LcAccountCreation);

            // Act
            acda.GetUserWebInfo(livePuid, ServiceTypeEnum.XboxLive, out tier, out privileges, out lastWebActivity, out parentalControlGroup, out isLightAccount, out isProvisioned, out accountType);

            // Assert
            Assert.AreEqual(expectedTier, tier);
            Assert.AreEqual(expectedParentalControlGroup, parentalControlGroup);
            Assert.IsTrue(isLightAccount);
            Assert.IsTrue(isProvisioned);
            Assert.IsNotNull(privileges);
            Assert.AreEqual(expectedPrivilegesLength, privileges.Length);
        }

        private static XeGetUserWebInfoResponse GetStandardWebInfoResponse()
        {
            XeGetUserWebInfoResponse resp = new XeGetUserWebInfoResponse();
            resp.tier = 0;
            resp.lastWebActivity = DateTime.Now;
            resp.parentalControlGroupId = 0;
            resp.isLightweight = true;
            resp.userPrivileges = new uint[1] { 1 };

            return resp;
        }

        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();

            stubs.LcAccountCreation = stubs.Stubber.RegisterWithContainer<ILcAccountCreation>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;

            public ILcAccountCreation LcAccountCreation;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\Account\AuthManagerTest.cs ===
﻿using Leet.Authentication;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Account;
using Leet.Live.Livecache.DataAccess;
using Leet.TestUtilities;
using Rhino.Mocks;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.Account
{
    [TestClass]
    public class AuthManagerTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_WebTicket_Values()
        {
            ulong expectedPuid = 2600292642020750;
            string expectedGamertag = "Test Tag";

            // Arrange
            var stubs = RegisterStubs();

            stubs.IdentityManager.Stub(im => im.IsAuthenticated).Return(true);
            stubs.IdentityManager.Stub(im => im.WindowsLiveIdentity).Return(new FakeWindowsLiveIdentity());
            stubs.XCacheDA.Stub(xda => xda.LookupWebID(Arg<ulong>.Is.Anything, out Arg<ulong>.Out(expectedPuid).Dummy, out Arg<string>.Out(expectedGamertag).Dummy)).Return(true);
            

            // Act
            WebLcAuthManager lcAuthMgr = new WebLcAuthManager();

            ILcAuthTicket ticket = lcAuthMgr.GetAuthTicket();

            // Assert
            Assert.IsNotNull(ticket);
            Assert.AreEqual(expectedPuid, ticket.Puid);

        }

        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentityManager = stubs.Stubber.RegisterWithContainer<IIdentityManager>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AcctCreationDA = stubs.Stubber.RegisterWithContainer<IAccountCreationDataAccess>();
            stubs.XCacheDA = stubs.Stubber.RegisterWithContainer<IXCacheDataAccess>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public IIdentityManager IdentityManager;
            public IXCacheDataAccess XCacheDA;
            public IAccountCreationDataAccess AcctCreationDA;
            public IContextItemProvider ContextItemProvider;
        }

        class FakeWindowsLiveIdentity : IWindowsLiveIdentity
        {

            #region IWindowsLiveIdentity Members

            public Puid Cid
            {
                get { throw new System.NotImplementedException(); }
            }

            public string FirstName
            {
                get { throw new System.NotImplementedException(); }
            }

            public bool HasProfile()
            {
                throw new System.NotImplementedException();
            }

            public string HexCid
            {
                get { throw new System.NotImplementedException(); }
            }

            public string HexPuid
            {
                get { throw new System.NotImplementedException(); }
            }

            public string LastName
            {
                get { throw new System.NotImplementedException(); }
            }

            public string MemberName
            {
                get { throw new System.NotImplementedException(); }
            }

            public Puid Puid
            {
                get { return new Puid(2600292642020750); }
            }

            public string GetTextLinkForLoggingOnOrOff()
            {
                throw new System.NotImplementedException();
            }

            public string GetLogOnLogOffUrl()
            {
                throw new System.NotImplementedException();
            }

            #endregion

            #region IIdentity Members

            public string AuthenticationType
            {
                get { throw new System.NotImplementedException(); }
            }

            public bool IsAuthenticated
            {
                get { return true; }
            }

            public string Name
            {
                get { throw new System.NotImplementedException(); }
            }

            #endregion


        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\DataAccess\StsDataAccessTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.IoCCo;
using Leet.TestUtilities;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;
using Rhino.Mocks;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.Live.Livecache.Providers;
using Leet.Live.Livecache.DataAccess;
using xonline.common.service;

namespace Leet.Live.Livecache.Test.DataAccess
{
    [TestClass]
    public class StsDataAccessTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void GetSecurityTicket_Throws_When_LivePuid_Equals_0()
        {
            var stubs = RegisterStubs();

            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            AssertException.Expect<ArgumentOutOfRangeException>(
                () => sda.GetSecurityTicket(0x0, 0x1, 0x1, 0x1, "1.1.1.1", 0x1, DateTime.Now, DateTime.Now), "livePuid must be non-zero\r\nParameter name: livePuid");
        }

        [TestMethod]
        public void GetSecurityTicket_Throws_When_PassportPuid_Equals_0()
        {
            var stubs = RegisterStubs();

            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            AssertException.Expect<ArgumentOutOfRangeException>(
                () => sda.GetSecurityTicket(0x1, 0x0, 0x1, 0x1, "1.1.1.1", 0x1, DateTime.Now, DateTime.Now), "passportPuid must be non-zero\r\nParameter name: passportPuid");
        }

        [TestMethod]
        public void GetSecurityTicket_Throws_When_TitleId_Equals_0()
        {
            var stubs = RegisterStubs();

            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            AssertException.Expect<ArgumentOutOfRangeException>(
                () => sda.GetSecurityTicket(0x1, 0x1, 0x0, 0x1, "1.1.1.1", 0x1, DateTime.Now, DateTime.Now), "titleId must be non-zero\r\nParameter name: titleId");
        }

        [TestMethod]
        public void GetSecurityTicket_Throws_When_IPAddressInternet_IS_NullOrEmpty()
        {
            var stubs = RegisterStubs();

            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            AssertException.Expect<ArgumentNullException>(
                () => sda.GetSecurityTicket(0x1, 0x1, 0x1, 0x1, "", 0x1, DateTime.Now, DateTime.Now), "ipAddressInternet cannot be null or empty\r\nParameter name: ipAddressInternet");

            AssertException.Expect<ArgumentNullException>(
                () => sda.GetSecurityTicket(0x1, 0x1, 0x1, 0x1, null, 0x1, DateTime.Now, DateTime.Now), "ipAddressInternet cannot be null or empty\r\nParameter name: ipAddressInternet");
        }

        [TestMethod]
        public void GetSecurityTicket_Throws_When_PassportCid_Equals_0()
        {
            var stubs = RegisterStubs();

            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            AssertException.Expect<ArgumentOutOfRangeException>(
                () => sda.GetSecurityTicket(0x1, 0x1, 0x1, 0x1, "1.1.1.1", 0x0, DateTime.Now, DateTime.Now), "passportCid must be non-zero\r\nParameter name: passportCid");
        }

        [TestMethod]
        public void GetSecurityTicket_Passes_Expected_Values_To_GetSecurityTicket()
        {
            var stubs = RegisterStubs();
            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            var response = new LiveCacheWebSvcResponse();
            response.response = "<root />";

            stubs.LcSts.Stub(lcsts => lcsts.GetSecurityTicket(
                Arg<ulong>.Is.Anything,
                Arg<uint>.Is.Anything,
                Arg<LivecacheWebSvcRequest>.Is.Anything,
                Arg<IAAInfoData>.Is.Anything)).Return(response);

            ulong expectedLivePuid = 0x1;
            ulong expectedPassportPuid = 0x2;
            uint expectedTitleId = 0x3;
            ushort expectedTitleVersion = 0x4;
            string expectedIpAddressInternet = "1.1.1.1";
            ulong expectedPassportCid = 0x5;
            DateTime expectedIssueInstant = DateTime.Parse("12/13/2009");
            DateTime expectedNotAfter = DateTime.Parse("12/14/2009 11:12:13");

            sda.GetSecurityTicket(expectedLivePuid,
                expectedPassportPuid,
                expectedTitleId,
                expectedTitleVersion,
                expectedIpAddressInternet,
                expectedPassportCid,
                expectedIssueInstant,
                expectedNotAfter);

            var arguments = stubs.LcSts.GetArgumentsForCallsMadeOn(lcsts => lcsts.GetSecurityTicket(
                Arg<ulong>.Is.Anything,
                Arg<uint>.Is.Anything,
                Arg<LivecacheWebSvcRequest>.Is.Anything,
                Arg<IAAInfoData>.Is.Anything));

            ulong actualLivePuid = (ulong)arguments[0][0];
            uint actualTitleId = (uint)arguments[0][1];
            var actualRequest = (LivecacheWebSvcRequest)arguments[0][2];
            var actualAAInfoData = (IAAInfoData)arguments[0][3];

            Assert.AreEqual(expectedLivePuid, actualLivePuid);
            Assert.AreEqual(expectedTitleId, actualTitleId);

            Assert.AreEqual(XOn.XPLT_WEB_GAMES.ToString(), actualRequest.NameValuePairs.Find(nvp => nvp.name == "platformType").value);
            Assert.AreEqual(expectedTitleId.ToString(), actualRequest.NameValuePairs.Find(nvp => nvp.name == "titleId").value);
            Assert.AreEqual(expectedTitleVersion.ToString(), actualRequest.NameValuePairs.Find(nvp => nvp.name == "titleVersion").value);
            Assert.AreEqual("", actualRequest.NameValuePairs.Find(nvp => nvp.name == "deviceId").value);

            Assert.AreEqual("", actualAAInfoData.CertThumbprint);
            Assert.AreEqual(expectedPassportPuid, actualAAInfoData.PassportPuid);
            Assert.AreEqual(expectedPassportCid, actualAAInfoData.PassportCId);
            Assert.AreEqual(expectedIpAddressInternet, actualAAInfoData.IpAddressInternet);
            Assert.AreEqual(expectedIssueInstant, actualAAInfoData.IssueInstant);
            Assert.AreEqual(expectedNotAfter, actualAAInfoData.NotAfter);

        }

        [TestMethod]
        public void GetSecurityTicket_Parses_Return_Value_From_Web_Service()
        {
            var stubs = RegisterStubs();
            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            var response = new LiveCacheWebSvcResponse();
            response.response = "<string>This is the response.</string>";

            stubs.LcSts.Stub(lcsts => lcsts.GetSecurityTicket(
                Arg<ulong>.Is.Anything,
                Arg<uint>.Is.Anything,
                Arg<LivecacheWebSvcRequest>.Is.Anything,
                Arg<IAAInfoData>.Is.Anything)).Return(response);

            string actualTicket = sda.GetSecurityTicket(0x1, 0x1, 0x1, 0x1, "1.1.1.1", 0x1, DateTime.Now, DateTime.Now);

            Assert.AreEqual("This is the response.", actualTicket);
        }

        [TestMethod]
        public void GetSecurityTicket_Parses_Returns_EmptyString_If_Xml_Doesnt_Contain_Expected_Result()
        {
            var stubs = RegisterStubs();
            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            var response = new LiveCacheWebSvcResponse();
            response.response = "<notastring>This is the response.</notastring>";

            stubs.LcSts.Stub(lcsts => lcsts.GetSecurityTicket(
                Arg<ulong>.Is.Anything,
                Arg<uint>.Is.Anything,
                Arg<LivecacheWebSvcRequest>.Is.Anything,
                Arg<IAAInfoData>.Is.Anything)).Return(response);

            string actualTicket = sda.GetSecurityTicket(0x1, 0x1, 0x1, 0x1, "1.1.1.1", 0x1, DateTime.Now, DateTime.Now);

            Assert.AreEqual(String.Empty, actualTicket);
        }


        [TestMethod]
        public void GetPartnerSecurityTicket_Throws_When_LivePuid_Equals_0()
        {
            var stubs = RegisterStubs();

            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            AssertException.Expect<ArgumentOutOfRangeException>(
                () => sda.GetPartnerSecurityTicket(0x0, 0x1, 0x1, "1.1.1.1", "<aSamlToken>real stuff should go here</aSamlToken>"), "livePuid must be non-zero\r\nParameter name: livePuid");
        }

        [TestMethod]
        public void GetPartnerSecurityTicket_Throws_When_TitleId_Equals_0()
        {
            var stubs = RegisterStubs();

            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            AssertException.Expect<ArgumentOutOfRangeException>(
                () => sda.GetPartnerSecurityTicket(0x1, 0x0, 0x1, "1.1.1.1", "<aSamlToken>real stuff should go here</aSamlToken>"), "titleId must be non-zero\r\nParameter name: titleId");
        }

        [TestMethod]
        public void GetPartnerSecurityTicket_Throws_When_IPAddressInternet_IS_NullOrEmpty()
        {
            var stubs = RegisterStubs();

            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            AssertException.Expect<ArgumentNullException>(
                () => sda.GetPartnerSecurityTicket(0x1, 0x1, 0x1, "", "<aSamlToken>real stuff should go here</aSamlToken>"), "ipAddressInternet cannot be null or empty\r\nParameter name: ipAddressInternet");

            AssertException.Expect<ArgumentNullException>(
                () => sda.GetPartnerSecurityTicket(0x1, 0x1, 0x1, null, "<aSamlToken>real stuff should go here</aSamlToken>"), "ipAddressInternet cannot be null or empty\r\nParameter name: ipAddressInternet");
        }

        [TestMethod]
        public void GetPartnerSecurityTicket_Passes_Expected_Values_To_GetSecurityTicket()
        {
            var stubs = RegisterStubs();
            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            var response = new LiveCacheWebSvcResponse();
            response.response = "<root />";

            stubs.LcSts.Stub(lcsts => lcsts.GetPartnerSecurityTicket(
                Arg<ulong>.Is.Anything,
                Arg<uint>.Is.Anything,
                Arg<LivecacheWebSvcRequest>.Is.Anything,
                Arg<IAAInfoData>.Is.Anything)).Return(response);

            ulong expectedLivePuid = 0x1;
            uint expectedTitleId = 0x3;
            ushort expectedTitleVersion = 0x4;
            string expectedIpAddressInternet = "1.1.1.1";
            string expectedSaml = "<aSamlToken>stuff</aSamlToken>";

            sda.GetPartnerSecurityTicket(expectedLivePuid,
                expectedTitleId,
                expectedTitleVersion,
                expectedIpAddressInternet,
                expectedSaml);

            var arguments = stubs.LcSts.GetArgumentsForCallsMadeOn(lcsts => lcsts.GetPartnerSecurityTicket(
                Arg<ulong>.Is.Anything,
                Arg<uint>.Is.Anything,
                Arg<LivecacheWebSvcRequest>.Is.Anything,
                Arg<IAAInfoData>.Is.Anything));

            ulong actualLivePuid = (ulong)arguments[0][0];
            uint actualTitleId = (uint)arguments[0][1];
            var actualRequest = (LivecacheWebSvcRequest)arguments[0][2];
            var actualAAInfoData = (IAAInfoData)arguments[0][3];

            Assert.AreEqual(expectedLivePuid, actualLivePuid);
            Assert.AreEqual(expectedTitleId, actualTitleId);

            Assert.AreEqual(expectedLivePuid.ToString(), actualRequest.NameValuePairs.Find(nvp => nvp.name == "xuid").value);
            Assert.AreEqual(expectedTitleId.ToString(), actualRequest.NameValuePairs.Find(nvp => nvp.name == "titleId").value);
            Assert.AreEqual(expectedTitleVersion.ToString(), actualRequest.NameValuePairs.Find(nvp => nvp.name == "titleVersion").value);

            Assert.AreEqual("", actualAAInfoData.CertThumbprint);
            Assert.AreEqual(expectedIpAddressInternet, actualAAInfoData.IpAddressInternet);
            Assert.AreEqual(expectedSaml, actualAAInfoData.SamlToken);
        }

        [TestMethod]
        public void GetPartnerSecurityTicket_Parses_Return_Value_From_Web_Service()
        {
            var stubs = RegisterStubs();
            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            var response = new LiveCacheWebSvcResponse();
            response.response = "<string>This is the response.</string>";

            stubs.LcSts.Stub(lcsts => lcsts.GetPartnerSecurityTicket(
                Arg<ulong>.Is.Anything,
                Arg<uint>.Is.Anything,
                Arg<LivecacheWebSvcRequest>.Is.Anything,
                Arg<IAAInfoData>.Is.Anything)).Return(response);

            string actualTicket = sda.GetPartnerSecurityTicket(0x1, 0x1, 0x1, "1.1.1.1", "<aSamlToken>real stuff should go here</aSamlToken>");

            Assert.AreEqual("This is the response.", actualTicket);
        }

        [TestMethod]
        public void GetPartnerSecurityTicket_Parses_Returns_EmptyString_If_Xml_Doesnt_Contain_Expected_Result()
        {
            var stubs = RegisterStubs();
            StsDataAccess sda = new StsDataAccess(stubs.LcSts);

            var response = new LiveCacheWebSvcResponse();
            response.response = "<notastring>This is the response.</notastring>";

            stubs.LcSts.Stub(lcsts => lcsts.GetPartnerSecurityTicket(
                Arg<ulong>.Is.Anything,
                Arg<uint>.Is.Anything,
                Arg<LivecacheWebSvcRequest>.Is.Anything,
                Arg<IAAInfoData>.Is.Anything)).Return(response);

            string actualTicket = sda.GetPartnerSecurityTicket(0x1, 0x1, 0x1, "1.1.1.1", "<aSamlToken>real stuff should go here</aSamlToken>");

            Assert.AreEqual(String.Empty, actualTicket);
        }

        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();

            stubs.LcSts = stubs.Stubber.RegisterWithContainer<ILcSts>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;

            public ILcSts LcSts;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\Logic\FriendInfoTest.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.Logic
{
    [TestClass]
    public class FriendInfoTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_FriendInfo_Creation()
        {
            // Expected data
            ulong expectedPuid = 2600292642020750;
            string expectedGamertag = "MJHDev01";
            uint expectedTitleId = 4293722112;
            DateTime expectedLastActive = new DateTime(2009, 8, 10, 21, 43, 2);
            FriendState expectedFriendStatus = FriendState.Friend;

            // Arrange
            var stubs = RegisterStubs();
            WebFriendsResponse wfr = GetWebFriendsResponse();

            stubs.LcPresence.Stub(lcp => lcp.GetFriends(Arg<WebFriendsRequest>.Is.Anything)).Return(wfr);
            IPresenceDataAccess pda = new PresenceDataAccess(stubs.LcPresence, stubs.IdentProvider);

            // Act
            IReadOnlyFriendInfo[] friends = pda.GetFriendsInfo(0, false, false);

            // Assert
            stubs.LcPresence.AssertWasCalled(p => p.GetFriends(Arg<WebFriendsRequest>.Is.Anything));
            Assert.AreEqual(1, friends.Length);
            Assert.AreEqual(expectedGamertag, friends[0].Gamertag);
            Assert.AreEqual(expectedPuid, friends[0].LivePuid);
            Assert.AreEqual(expectedFriendStatus, friends[0].FriendState);

            Assert.AreEqual(expectedTitleId, friends[0].TitleId);
            Assert.AreEqual(expectedLastActive, friends[0].LastSeen);

            IReadOnlyPresenceInfo presence = (IReadOnlyPresenceInfo)friends[0];
            Assert.AreEqual(expectedGamertag, presence.Gamertag);
            Assert.AreEqual(expectedPuid, presence.LivePuid);
        }

        private static WebFriendsResponse GetWebFriendsResponse()
        {
            WebFriendsResponse wfr = new WebFriendsResponse();
            wfr.header.dwMsgLen = 66;
            wfr.header.dwMsgType = 1103;
            wfr.puid = 2600292642020750;
            wfr.hr = 0;
            wfr.version = 429;
            wfr.cdwFriends = 1;
            wfr.rgFriends = new WebFriendsData[1] { new WebFriendsData() };
            wfr.rgFriends[0].Puid = 2600292642020750;
            wfr.rgFriends[0].FriendStatus = 0;
            wfr.rgFriends[0].OnlineState = 0;
            wfr.rgFriends[0].TitleId = 4293722112;
            wfr.rgFriends[0].mtLastActive = 208561382;
            wfr.rgFriends[0].szGamerTag = "MJHDev01";
            wfr.rgFriends[0].StateData = new byte[0];
            wfr.rgFriends[0].RPData = new byte[0];

            return wfr;
        }


        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();

            stubs.LcPresence = stubs.Stubber.RegisterWithContainer<ILcPresence>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;

            public ILcPresence LcPresence;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Live.Livecache.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("267c23d9-77f6-4a8e-a5a9-c85b03c79b86")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\Logic\ProfilePrivilegesTest.cs ===
﻿using System;
using System.Collections.Generic;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;


namespace Leet.Live.Livecache.Test.Logic
{
    [TestClass]
    public class ProfilePrivilegesTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_Privilege_Read()
        {
            ulong livePuid = 1;
            uint tier;
            uint[] privileges;
            DateTime lastWebActivity;
            byte parentalControlGroup;
            bool isLightAccount;
            bool isProvisioned;
            byte accountType;

            // Expected data
            PrivilegeValue expectedAllowOnlinePlay = PrivilegeValue.Deny;
            PrivilegeValue expectedOnlineStatus = PrivilegeValue.Allow;

            // Arrange
            XeGetUserWebInfoResponse response = GetStandardWebInfoResponse();
            var stubs = RegisterStubs();
            stubs.LcAccountCreation.Stub(lcap => lcap.GetUserWebInfo(Arg<XeGetUserWebInfoRequest>.Is.Anything)).Return(response);

            // Act
            IAccountCreationDataAccess acda = new AccountCreationDataAccess(stubs.LcAccountCreation);
            acda.GetUserWebInfo(livePuid, ServiceTypeEnum.XboxLive, out tier, out privileges, out lastWebActivity, out parentalControlGroup, out isLightAccount, out isProvisioned, out accountType);
            Dictionary<Privilege, PrivilegeValue> privilegeSet = ProfilePrivileges.Parse(privileges);

            // Assert
            Assert.AreEqual(expectedAllowOnlinePlay, privilegeSet[Privilege.OnlineGamePlay]);
            Assert.AreEqual(expectedOnlineStatus, privilegeSet[Privilege.OnlineStatus]);

        }

        private static XeGetUserWebInfoResponse GetStandardWebInfoResponse()
        {
            XeGetUserWebInfoResponse resp = new XeGetUserWebInfoResponse();
            resp.tier = 0;
            resp.lastWebActivity = DateTime.Now;
            resp.parentalControlGroupId = 0;
            resp.isLightweight = true;
            resp.userPrivileges = new uint[8] { 0, 0, 0, 0, 0, 0, 268435456, 2616796412 };

            return resp;
        }

        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();

            stubs.LcAccountCreation = stubs.Stubber.RegisterWithContainer<ILcAccountCreation>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;

            public ILcAccountCreation LcAccountCreation;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\Logic\PresenceInfoTest.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.Logic
{
    [TestClass]
    public class PresenceInfoTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_PresenceInfo_Creation()
        {
            // Expected data
            ulong expectedPuid = 2600292642020750;
            string expectedGamertag = "MJHDev01";
            uint expectedTitleId = 4293722112;
            DateTime expectedLastActive = new DateTime(2009, 8, 10, 21, 43, 2);
            OnlineState expectedState = OnlineState.Offline;
            bool expectedIsPlaying = false;
            bool expectedIsJoinable = false;

            // Arrange
            var stubs = RegisterStubs();
            PresenceInfoResponse pir = GetPresenceInfoResponse();

            stubs.LcPresence.Stub(lcp => lcp.GetPresenceInfo(Arg<GetPresenceInfoRequest>.Is.Anything)).Return(pir);
            IPresenceDataAccess pda = new PresenceDataAccess(stubs.LcPresence, stubs.IdentProvider);

            // Act
            IReadOnlyPresenceInfo presence = pda.GetPresenceInfo(0, 0);

            // Assert
            stubs.LcPresence.AssertWasCalled(p => p.GetPresenceInfo(Arg<GetPresenceInfoRequest>.Is.Anything));
            Assert.AreEqual(expectedGamertag, presence.Gamertag);
            Assert.AreEqual(expectedPuid, presence.LivePuid);
            Assert.AreEqual(expectedTitleId, presence.TitleId);
            Assert.AreEqual(expectedLastActive, presence.LastSeen);
            Assert.AreEqual(expectedState, presence.State);
            Assert.IsFalse(expectedIsJoinable);
            Assert.IsFalse(expectedIsPlaying);

        }

        private static PresenceInfoResponse GetPresenceInfoResponse()
        {
            PresenceInfoResponse pir = new PresenceInfoResponse();
            pir.header.dwMsgType = 1057;
            pir.header.dwMsgLen = 66;
            pir.header.dwSeqNum = 0x0;
            pir.qwSenderID = 2600292642020749;
            pir.cdwUsers = 1;
            pir.rgUsers = new PresenceInfoData[1] { new PresenceInfoData() };
            pir.rgUsers[0].Puid = 2600292642020750;
            pir.rgUsers[0].OnlineState = 0;
            pir.rgUsers[0].TitleId = 4293722112;
            pir.rgUsers[0].mtLastActive = 208561382;
            pir.rgUsers[0].szGamerTag = "MJHDev01";
            pir.rgUsers[0].StateData = new byte[0];
            pir.rgUsers[0].StateDataLen = 0;
            pir.rgUsers[0].RPData = new byte[0];
            pir.rgUsers[0].RPDataLen = 0;

            return pir;
        }


        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();

            stubs.LcPresence = stubs.Stubber.RegisterWithContainer<ILcPresence>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;
            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;

            public ILcPresence LcPresence;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.TestApp\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Text;
using Leet.Authentication;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Account;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Providers;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;
using Leet.Core.Configuration;
using Leet.Live.Livecache.Logic.Achievements;

using Test.Common.LiveCacheEmulator;
namespace Leet.Live.Livecache.TestApp
{
    class Program
    {
        /// <summary>
        /// A test PUID for use in tests.  Should be modified when appropriate.
        /// </summary>
        /// 
        private static ulong _friendPuid = 12345678901234;
        private static ulong _testPuid = 985160349927778;//985160349915290;
        private static ulong _livePuid;   //2600292641993860
        private static bool _userLivecacheEmulator = false;
        /// <summary>
        /// Purpose of this application is to test basic connectivity against an XBLOB in a development
        /// environment.  It will make a live request against the XCache interface defined in the NPDB set
        /// in the HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\XboxLive\CommonConfig registry key (or the 
        /// Wow6432Node if appropriate).
        /// </summary>
        /// <param name="args"></param>
        static void Main(string[] args)
        {
            Console.WriteLine("Leet.Live.Livecache test application starting up");

            ConfigureIoCContainer();

            //Container.Instance.GetComponent<ILivecacheLoggerProvider>().RegisterLogger("Leet.Live.Livecache.TestApp");

            //TestXCacheDataAccess();
            TestGetPublicProfile();
            //TestAchievementDataAccess();
            //TestPresenceDataAccess();
            //TestPrivilegeBits();

            //TestClosetService();

            //TestLocaleFromPuid();

            Console.WriteLine("Press any key to continue...");
            Console.ReadKey(false);
        }

        private static void TestPresenceDataAccess()
        {
            Console.WriteLine("Begin executing GetFriends from PresenceDataAccess");

            Console.WriteLine("Get auth ticket");
            ILcAuthManager authManager = Container.Instance.GetComponent<ILcAuthManager>();
            ILcAuthTicket authTicket = authManager.GetAuthTicket();

            Console.WriteLine("Make request against PresenceDataAccess...");
            IPresenceDataAccess pda = Container.Instance.GetComponent<IPresenceDataAccess>();

            IReadOnlyFriendInfo[] friends = pda.GetFriendsInfo(authTicket.LivePuid, false, false);

            Console.WriteLine("\nPuid={0}\nFriend Count={1}", _testPuid, friends.Length);
        }

        private static void TestXCacheDataAccess()
        {
            Console.WriteLine("Executing livePuid lookup from XCache...");

            IXCacheDataAccess xda = Container.Instance.GetComponent<IXCacheDataAccess>();

            string gamertag;
            xda.LookupWebID(_testPuid, out _livePuid, out gamertag);

            Console.WriteLine("\nPuid={0}\nlivePuid={1}\ngamertag={2}", _testPuid, _livePuid, gamertag);
        }

        private static void TestGetPublicProfile()
        {
            Console.Write("Executing Public Profile Lookup from Livecache...");

            ISettingsDataAccess sda = Container.Instance.GetComponent<ISettingsDataAccess>();
            IGamerProfile profile = sda.GetPublicGamerProfile(2600292641993860);

            Console.WriteLine("\nPuid={0}\nGamerScore={1}\nGamerTileUrl={2}\n",
                _testPuid, profile.Gamerscore, profile.GamerTileUrl);
        }

        private static void TestAchievementDataAccess()
        {
            Console.WriteLine("Executing achievement lookup...");

            IAchievementDataAccess ada = Container.Instance.GetComponent<IAchievementDataAccess>();
            List<IReadOnlyAchievementInfo> achievements = ada.GetUserAchievements(0, _friendPuid, _livePuid, 0);

            Console.WriteLine("Achievement Count={0}", achievements.Count);
        }

        private static void TestPrivilegeBits()
        {
            Console.WriteLine();
            Console.WriteLine("Executing privilege settings test...");
            Console.WriteLine();

            ulong livePuid = 2600292642020750;
            uint tier;
            uint[] privileges;
            DateTime lastWebActivity = DateTime.Now;
            byte parentalControlGroup = 0;
            bool isLightAccount = false;
            bool isProvisioned = false;
            byte accountType;


            Console.WriteLine("Invoking GetUserWebInfo");
            IAccountCreationDataAccess acda = Container.Instance.GetComponent<IAccountCreationDataAccess>();
            acda.GetUserWebInfo(livePuid, ServiceTypeEnum.XboxLive, 
                out tier,
                out privileges,
                out lastWebActivity,
                out parentalControlGroup,
                out isLightAccount,
                out isProvisioned, 
                out accountType);

            if (privileges.Length != 0)
            {
                Console.WriteLine("Parsing privileges");
                Dictionary<Privilege, PrivilegeValue> privilegeSet = ProfilePrivileges.Parse(privileges);

                PrivilegeValue value = privilegeSet[Privilege.OnlineStatus];
                Console.WriteLine("Show Online Status:  " + value.ToString());
                value = privilegeSet[Privilege.OnlineGamePlay];
                Console.WriteLine("Allow Online Play:  " + value.ToString());
            }
            else
            {
                Console.WriteLine("ERROR:  GetUserWebInfo failed");
            }
        }

        private static void TestClosetService()
        {
            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();
            ReadOnlyCollection<AwardedAvatarAsset> awardables = settingsDataAccess.GetUserAvatarAwards((ulong)2600292641993860, 0);
        }

        private static void TestLocaleFromPuid()
        {
            //ushort lcid = xonline.common.service.
            //Console.WriteLine("LCID: " + lcid);
        }

        private static void ConfigureIoCContainer()
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IIdentityManager, TestIdentityManager>();
            Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
            ((NpdbConfigurationProvider)Container.Instance.GetComponent<IConfigurationProvider>()).Initialize("LEET", "livecache_test");

            Container.Instance.AddService<ILivecacheClientIdentifierProvider, XboxcomLivecacheClientIdentifierProvider>();
            //Container.Instance.AddService<ILivecacheClientIdentifierProvider, LIVEnLivecacheClientIdentifierProvider>();
            Container.Instance.AddService<IContextItemProvider, TestContextItemProvider>();
            Container.Instance.AddService<ILocalLivecacheContext, DefaultLocalLivecacheContext>();
            Container.Instance.AddService<ILivecacheLoggerProvider, DebugLivecacheLoggerProvider>();
            Container.Instance.AddService<ILivecacheLogger, DebugLivecacheLogger>();
            Container.Instance.AddService<ILivecacheLocaleProvider, DefaultLivecacheLocaleProvider>();

            Container.Instance.AddService<IAccountAuthDataProvider, TestAcctAuthDataProvider>();
            Container.Instance.AddService<ILcAuthManager, WebLcAuthManager>();

            Container.Instance.AddService<IXCacheDataAccess, XCacheDataAccess>();
            Container.Instance.AddService<ILcXCache, LcXCache>();

            Container.Instance.AddService<IAccountCreationDataAccess, AccountCreationDataAccess>();
            Container.Instance.AddService<ILcAccountCreation, LcAccountCreationAdapter>();

            Container.Instance.AddService<ILcStats, LcStatsAdapter>();
            if (_userLivecacheEmulator)
            {
                Container.Instance.AddService<ISettingsDataAccess, SettingsDataAccessEmulator>();
                Container.Instance.AddService<IAchievementDataAccess, AchievementDataAccessEmulator>();
            }
            else
            {
                Container.Instance.AddService<IAchievementDataAccess, AchievementDataAccess>();
                Container.Instance.AddService<ISettingsDataAccess, SettingsDataAccess>();
            }

            Container.Instance.AddService<IPresenceDataAccess, PresenceDataAccess>();
            Container.Instance.AddService<ILcPresence, LcPresenceAdapter>();

            
            Container.Instance.AddService<ILcAchievement, LcAchievementAdapter>();
        }
    }

    /// <summary>
    /// Test class for use by the test application
    /// </summary>
    public class TestAcctAuthDataProvider : IAccountAuthDataProvider
    {
        ILcAuthManager _authManager;

        public TestAcctAuthDataProvider(ILcAuthManager authManager)
        {
            _authManager = authManager;
        }

        #region IAccountAuthDataProvider Members

        public IPEndPoint ClientIPEndPoint
        {
            get { return new IPEndPoint(IPAddress.Parse("127.0.0.1"), 0); }
        }

        public ulong LivePuid
        {
            get
            {
                //ILcAuthTicket ticket = _authManager.GetAuthTicket();
                //return (ticket == null ? 0 : ticket.LivePuid);

                return 2600292641993860;
            }
        }

        public uint[] Privileges
        {
            get
            {
                //ILcAuthTicket ticket = _authManager.GetAuthTicket();
                //return (ticket == null ? null : ticket.Privileges);
                uint[] pvs = new uint[8] { 0, 0, 0, 0, 0, 0, 2415919104, 4294796541 };
                return pvs;
            }
        }

        public byte Tier
        {
            get
            {
                ILcAuthTicket ticket = _authManager.GetAuthTicket();
                return (ticket == null ? (byte)0 : (byte)ticket.Tier);
            }
        }

        #endregion
    }

    public class TestIdentityManager : IIdentityManager
    {

        #region IIdentityManager Members

        public SocialIdentity PrimaryIdentity
        {
            get { throw new NotImplementedException(); }
        }

        public IWindowsLiveIdentity WindowsLiveIdentity
        {
            get
            {
                IWindowsLiveIdentity id = new TestWindowsLiveIdentity();
                return id;
            }
        }

        public IXboxLiveIdentity XboxLiveIdentity
        {
            get { throw new NotImplementedException(); }
        }

        public SocialIdentity GetIdentity(int networkId)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region IIdentity Members

        public string AuthenticationType
        {
            get { throw new NotImplementedException(); }
        }

        public bool IsAuthenticated
        {
            get { return true; }
        }

        public string Name
        {
            get { throw new NotImplementedException(); }
        }

        #endregion
    }

    public class TestWindowsLiveIdentity : IWindowsLiveIdentity
    {

        #region IWindowsLiveIdentity Members

        public Puid Cid
        {
            get { throw new NotImplementedException(); }
        }

        public string FirstName
        {
            get { throw new NotImplementedException(); }
        }

        public bool HasProfile()
        {
            throw new NotImplementedException();
        }

        public string HexCid
        {
            get { throw new NotImplementedException(); }
        }

        public string HexPuid
        {
            get { throw new NotImplementedException(); }
        }

        public string LastName
        {
            get { throw new NotImplementedException(); }
        }

        public string MemberName
        {
            get { throw new NotImplementedException(); }
        }

        public Puid Puid
        {
            get { return new Puid(985160349915290); }
        }

        public string GetTextLinkForLoggingOnOrOff()
        {
            throw new NotImplementedException();
        }

        public string GetLogOnLogOffUrl()
        {
            throw new NotImplementedException();
        }

        #endregion

        #region IIdentity Members

        public string AuthenticationType
        {
            get { throw new NotImplementedException(); }
        }

        public bool IsAuthenticated
        {
            get { throw new NotImplementedException(); }
        }

        public string Name
        {
            get { throw new NotImplementedException(); }
        }

        #endregion
    }

    [SingletonInstance]
    public class TestContextItemProvider : IContextItemProvider
    {
        private Dictionary<string, object> _storage = new Dictionary<string, object>();

        public object this[string name]
        {
            get
            {
                object contextItem = null;
                _storage.TryGetValue(name, out contextItem);

                return contextItem;
            }
            set
            {
                _storage[name] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.TestApp\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Live.Livecache.TestApp")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("Leet.Live.Livecache.TestApp")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3f366b0e-3025-458f-ad3c-579072e4621c")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Livecache.Test\DataAccess\XCacheDataAccessTest.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.webplatform.livecache;

namespace Leet.Live.Livecache.Test.DataAccess
{
    [TestClass]
    public class XCacheDataAccessTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Simple_XCache_Function_Call_Returns_Values()
        {
            // Arrange
            string inputGamertag = "My Tag";
            string expectedOfficialTag = "MyTag";
            ulong expectedLivePuid = 1234;
            
            var stubs = RegisterStubs();
            stubs.XCache.Stub(xc => xc.GetOfficialGamerTag(Arg.Is(inputGamertag), out Arg<ulong>.Out(expectedLivePuid).Dummy, out Arg<String>.Out(expectedOfficialTag).Dummy)).Return(true);
            IXCacheDataAccess xda = new XCacheDataAccess(stubs.XCache);

            // Act
            ulong actualLivePuid = 0;
            string actualGamertag = "";
            bool result = xda.GetOfficialGamerTag(inputGamertag, out actualLivePuid, out actualGamertag);

            // Assert
            stubs.XCache.AssertWasCalled(xc => xc.GetOfficialGamerTag(Arg.Is(inputGamertag), out Arg<ulong>.Out(expectedLivePuid).Dummy, out Arg<String>.Out(expectedOfficialTag).Dummy));
            Assert.AreEqual(expectedOfficialTag, actualGamertag);
            Assert.AreEqual(expectedLivePuid, actualLivePuid);
        }

        private static Stubs RegisterStubs()
        {
            var stubs = new Stubs { Stubber = new Stubber() };

            stubs.IdentProvider = stubs.Stubber.RegisterWithContainer<ILivecacheClientIdentifierProvider>();
            stubs.LocalContext = stubs.Stubber.RegisterWithContainer<ILocalLivecacheContext>();
            stubs.ContextItemProvider = stubs.Stubber.RegisterWithContainer<IContextItemProvider>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();

            stubs.XCache = stubs.Stubber.RegisterWithContainer<ILcXCache>();

            return stubs;
        }

        class Stubs
        {
            public Stubber Stubber;

            public ILivecacheClientIdentifierProvider IdentProvider;
            public IAccountAuthDataProvider AuthDataProvider;
            public IContextItemProvider ContextItemProvider;
            public ILocalLivecacheContext LocalContext;

            public ILcXCache XCache;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Tiles\FallbackTiles.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Tiles
{
    public enum FallbackTileType : byte
    {
        // FallbackTiles expects the members of this enum to start at 0 and be incremented sequentually.
        // The name of the enums should corespond to a .jpg with the same name that is in /xweb/lib/images.
        QuestionMark64x64 = 0,
        QuestionMark32x32
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Tiles\Exception\SignedDataInvalidException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Tiles.Exception
{
    public class SignedDataInvalidException : System.Exception
    {
        public SignedDataInvalidException(string message)
            : base(message)
        {
        }

        public SignedDataInvalidException(string message, System.Exception e)
            : base(message, e)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Tiles\TileSpecifier.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leet.Live.Tiles
{
    internal class TileSpecifier
    {
        private TileSpecifierData _tileData = new TileSpecifierData();

        public TileSpecifier()
        {
        }

        public TileSpecifier(string urlPath)
        {
            UrlPath = urlPath;
        }

        public TileSpecifier(string storagePath, ushort dimensions)
        {
            StoragePath = storagePath;
            Dimensions = dimensions;
        }

        public bool Dimmed
        {
            get
            {
                return (_tileData.Flags & 0x01) != 0;
            }
            set
            {
                if (value)
                {
                    _tileData.Flags |= 0x01;
                }
                else
                {
                    _tileData.Flags &= 0xFE;
                }
            }
        }

        public bool UseFallbackTile
        {
            get
            {
                return (_tileData.Flags & 0x02) != 0;
            }
            set
            {
                if (value)
                {
                    _tileData.Flags |= 0x02;
                }
                else
                {
                    _tileData.Flags &= 0xFD;
                }
            }
        }

        public string UrlPath
        {
            get
            {
                byte[] blob = _tileData.ToBytes();

                // twidle with the first half of the data to give it a bit more random of a distribution.
                // we're using the first few bytes to create some directories in the path. If we dont do
                // anything, these tend to be very uniform, so it defeats the plan to spread the generated
                // files across multiple physical directories.
                int half = blob.Length / 2 - 1;
                int endOffset = blob.Length - 1;

                for (int i = 0; i < half; i++)
                {
                    blob[i] ^= blob[endOffset - i];
                }

                string rawPath = Convert.ToBase64String(blob);
                // forward slashes look like part of the URL, so swap them out with -
                rawPath = rawPath.Replace("/", "-");

                if (rawPath.Length < 5)
                {
                    throw new InvalidOperationException("Path with signed data should always be > 5, but was not");
                }

                StringBuilder fullPath = new StringBuilder(rawPath.Length + 3);

                fullPath.Append("/");
                fullPath.Append(rawPath.Substring(0, 2));
                fullPath.Append("/");
                fullPath.Append(rawPath.Substring(2, 2));
                fullPath.Append("/");
                fullPath.Append(rawPath.Substring(4));
                fullPath.Append(".jpg");

                return fullPath.ToString();
            }
            set
            {
                if (!DoesUrlMatchTilePattern(value))
                {
                    if (value == null)
                    {
                        throw new ArgumentNullException("value");
                    }
                    else
                    {
                        throw new ArgumentException("UrlPath must be at least 12 characters long, and follow the pattern /XX/XX/XX...X.jpg Passed value was " + value, "value");
                    }
                }

                StringBuilder rawPath = new StringBuilder(value.Length);

                int trimSize = value.Length - (4 + 7); //extension length plus initial offset
                rawPath.Append(value.Substring(1, 2));
                rawPath.Append(value.Substring(4, 2));
                rawPath.Append(value.Substring(7, trimSize));

                // convert back the / we removed in the get
                rawPath = rawPath.Replace('-', '/');
                // occasionally we'll get a bad base64encoded string - often from the string being
                // transformed to quoted printable - so we need to wrap the conversion back in a try
                // catch block.  If it fails we'll default to the fallback tile ([?])
                try
                {
                    byte[] blob = Convert.FromBase64String(rawPath.ToString());

                    // undo the twidling we do in the get
                    int half = blob.Length / 2 - 1;
                    int endOffset = blob.Length - 1;

                    for (int i = 0; i < half; i++)
                    {
                        blob[i] ^= blob[endOffset - i];
                    }

                    _tileData.FromBytes(blob);
                }
                catch (System.Exception)
                {
                    // will default to fallback title
                    _tileData = new TileSpecifierData();
                    UseFallbackTile = true;
                }
            }
        }

        public static bool DoesUrlMatchTilePattern(string urlPath)
        {
            if (urlPath == null)
            {
                return false;
            }

            if ((urlPath.Length < 13) || (urlPath[0] != '/') || (urlPath[3] != '/') || (urlPath[6] != '/') || !urlPath.EndsWith(".jpg"))
            {
                return false;
            }

            return true;
        }

        public string StoragePath
        {
            get
            {
                return _tileData.StoragePath;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }

                _tileData.StoragePathSize = (ushort)value.Length;
                _tileData.StoragePath = value;
            }
        }

        public ushort Dimensions
        {
            get { return _tileData.Dimensions; }
            set { _tileData.Dimensions = value; }
        }

        // Removing this until game tiles are added.  Not required for achievements
        //public FallbackTileType FallbackTile
        //{
        //    get
        //    {
        //        if (Enum.IsDefined(typeof(FallbackTileType), _tileData.bFallbackTile))
        //        {
        //            return ((FallbackTileType)_tileData.bFallbackTile);
        //        }
        //        else
        //        {
        //            return FallbackTileType.QuestionMark32x32;
        //        }
        //    }
        //    set { _tileData.bFallbackTile = (byte)value; }
        //}

        public System.Drawing.Color BackgroundColor
        {
            get
            {
                return System.Drawing.Color.FromArgb(
                    _tileData.BackgroundColorRed,
                    _tileData.BackgroundColorGreen,
                    _tileData.BackgroundColorBlue
                    );
            }

            set
            {
                _tileData.BackgroundColorRed = value.R;
                _tileData.BackgroundColorGreen = value.G;
                _tileData.BackgroundColorBlue = value.B;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Tiles\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Live.Tiles")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("041fc8d8-9fc7-45c2-9173-6bdced8d3f4a")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Tiles\TileSpecifierData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Tiles.Utility;
using xonline.common.service;

namespace Leet.Live.Tiles
{
    public class TileSpecifierData : CRC32WireData
    {
        public TileSpecifierData()
        {
            StoragePathSize = 0;
            StoragePath = "";
            Dimensions = 0;
            FallbackTile = (byte)FallbackTileType.QuestionMark64x64;
            BackgroundColorRed = 0;
            BackgroundColorGreen = 0;
            BackgroundColorBlue = 0;
        }

        public ushort StoragePathSize;

        [WireInfo(SizeParam = "StoragePathSize")]
        public string StoragePath;

        public ushort Dimensions;

        public byte FallbackTile;

        public byte Flags;

        public byte BackgroundColorRed;
        public byte BackgroundColorGreen;
        public byte BackgroundColorBlue;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Tiles\Utility\CRC32.cs ===
﻿using System.Collections;
using System.IO;
using System.Security.Cryptography;

namespace Leet.Live.Tiles.Utility
{
    /// <summary>
    /// 
    /// </summary>
    public class CRC32 : HashAlgorithm
    {
        protected static uint AllOnes = 0xffffffff;
        protected static Hashtable cachedCRC32Tables;
        protected static bool autoCache;

        protected uint[] crc32Table;
        private uint m_crc;

        /// <summary>
        /// Returns the default polynomial (used in WinZip, Ethernet, etc)
        /// </summary>
        public static uint DefaultPolynomial
        {
            get { return 0x04C11DB7; }
        }

        /// <summary>
        /// Gets or sets the auto-cache setting of this class.
        /// </summary>
        public static bool AutoCache
        {
            get { return autoCache; }
            set { autoCache = value; }
        }

        /// <summary>
        /// Initialize the cache
        /// </summary>
        static CRC32()
        {
            cachedCRC32Tables = Hashtable.Synchronized(new Hashtable());
            autoCache = true;
        }

        public static void ClearCache()
        {
            cachedCRC32Tables.Clear();
        }


        /// <summary>
        /// Builds a crc32 table given a polynomial
        /// </summary>
        /// <param name="ulPolynomial"></param>
        /// <returns></returns>
        protected static uint[] BuildCRC32Table(uint ulPolynomial)
        {
            uint dwCrc;
            uint[] table = new uint[256];

            // 256 values representing ASCII character codes. 
            for (int i = 0; i < 256; i++)
            {
                dwCrc = (uint)i;
                for (int j = 8; j > 0; j--)
                {
                    if ((dwCrc & 1) == 1)
                        dwCrc = (dwCrc >> 1) ^ ulPolynomial;
                    else
                        dwCrc >>= 1;
                }
                table[i] = dwCrc;
            }

            return table;
        }


        /// <summary>
        /// Creates a CRC32 object using the DefaultPolynomial
        /// </summary>
        public CRC32()
            : this(DefaultPolynomial)
        {
        }

        /// <summary>
        /// Creates a CRC32 object using the specified Creates a CRC32 object 
        /// </summary>
        public CRC32(uint aPolynomial)
            : this(aPolynomial, CRC32.AutoCache)
        {
        }

        /// <summary>
        /// Construct the 
        /// </summary>
        public CRC32(uint aPolynomial, bool cacheTable)
        {
            this.HashSizeValue = 32;

            crc32Table = (uint[])cachedCRC32Tables[aPolynomial];
            if (crc32Table == null)
            {
                crc32Table = CRC32.BuildCRC32Table(aPolynomial);
                if (cacheTable)
                {
                    lock (cachedCRC32Tables)
                    {
                        if (!cachedCRC32Tables.Contains(aPolynomial))
                        {
                            cachedCRC32Tables.Add(aPolynomial, crc32Table);
                        }
                    }
                }
            }
            Initialize();
        }

        /// <summary>
        /// Initializes an implementation of HashAlgorithm.
        /// </summary>
        public override void Initialize()
        {
            m_crc = AllOnes;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        protected override void HashCore(byte[] buffer, int offset, int count)
        {
            // Save the text in the buffer. 
            for (int i = offset; i < count; i++)
            {
                ulong tabPtr = (m_crc & 0xFF) ^ buffer[i];
                m_crc >>= 8;
                m_crc ^= crc32Table[tabPtr];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override byte[] HashFinal()
        {
            byte[] finalHash = new byte[4];
            ulong finalCRC = m_crc ^ AllOnes;

            finalHash[0] = (byte)((finalCRC >> 24) & 0xFF);
            finalHash[1] = (byte)((finalCRC >> 16) & 0xFF);
            finalHash[2] = (byte)((finalCRC >> 8) & 0xFF);
            finalHash[3] = (byte)((finalCRC >> 0) & 0xFF);

            return finalHash;
        }

        /// <summary>
        /// Computes the hash value for the specified Stream.
        /// </summary>
        new public byte[] ComputeHash(Stream inputStream)
        {
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = inputStream.Read(buffer, 0, 4096)) > 0)
            {
                HashCore(buffer, 0, bytesRead);
            }
            return HashFinal();
        }


        /// <summary>
        /// Overloaded. Computes the hash value for the input data.
        /// </summary>
        new public byte[] ComputeHash(byte[] buffer)
        {
            return ComputeHash(buffer, 0, buffer.Length);
        }

        /// <summary>
        /// Overloaded. Computes the hash value for the input data.
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        /// <returns></returns>
        new public byte[] ComputeHash(byte[] buffer, int offset, int count)
        {
            HashCore(buffer, offset, count);
            return HashFinal();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Tiles\TileLocator.cs ===
﻿
namespace Leet.Live.Tiles
{
    using System;
    using System.Drawing;
    using System.Text;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;

    public class TileLocator
    {
        private static TileLocator singletonInstance = new TileLocator(Container.Instance.GetComponent<IConfigurationProvider>());

        private Color DEFAULT_BACKGROUND_COLOR = Color.FromArgb(231, 231, 231);
        private Color UNACHIEVED_PREDIMMED_BACKGROUND_COLOR = Color.FromArgb(80, 80, 80);

        private IConfigurationProvider _config;

        private TileLocator(IConfigurationProvider config)
        {
            _config = config;
        }

        public static TileLocator Instance
        {
            get
            {
                return singletonInstance;
            }
        }

        // if achieved = false, we would send unachieved AchievementTileUrl (dimmed image)
        public Uri AchievementTileUrl(bool achieved, uint titleId, uint imageId, string tilesAuthority)
        {
            if (achieved == true)
            {
                return AchievementTileUrl(achieved, titleId, imageId, DEFAULT_BACKGROUND_COLOR, tilesAuthority);
            }
            else
            {
                return AchievementTileUrl(achieved, titleId, imageId, UNACHIEVED_PREDIMMED_BACKGROUND_COLOR, tilesAuthority);
            }
        }

        public Uri AchievementTileUrl(bool achieved, uint titleId, uint imageId, Color backgroundColor, string tilesAuthority)
        {
            Uri tileHref = null;
            StringBuilder storagePath = new StringBuilder(40);

            storagePath.Append("//global/t:");
            storagePath.Append(titleId.ToString("X"));
            storagePath.Append("/ach/0/");
            storagePath.Append(imageId.ToString("X"));

            TileSpecifier specifier = new TileSpecifier(storagePath.ToString(), 0);
            specifier.BackgroundColor = backgroundColor;

            // dim the color if not achieved
            if (achieved == false)
            {
                specifier.Dimmed = true;
            }

            string tileLocation = String.Empty;
            try
            {
                tileLocation = String.Concat(tilesAuthority, "/tiles", specifier.UrlPath);
            }
            catch (InvalidOperationException)
            {
                tileLocation = String.Empty;
            }

            if(!(String.IsNullOrEmpty(tileLocation)))
            {
                tileHref = new Uri(tileLocation);
            }

            return tileHref;
        }

        public Uri UnachievedHiddenAchievementTileUrl(string tilesAuthority)
        {
            return UnachievedHiddenAchievementTileUrl(UNACHIEVED_PREDIMMED_BACKGROUND_COLOR, tilesAuthority);
        }

        // unachieved (locked) hidden achievement Url
        public Uri UnachievedHiddenAchievementTileUrl(Color backgroundColor, string tilesAuthority)
        {
            Uri tileHref = null;

            TileSpecifier specifier = new TileSpecifier();
            specifier.BackgroundColor = backgroundColor;
            specifier.UseFallbackTile = true;
            specifier.Dimmed = true;

            string tileLocation = String.Empty;
            try
            {
                tileLocation = String.Concat(tilesAuthority, "/tiles", specifier.UrlPath);
            }
            catch (InvalidOperationException)
            {
                tileLocation = String.Empty;
            }

            if (!(String.IsNullOrEmpty(tileLocation)))
            {
                tileHref = new Uri(tileLocation);
            }

            return tileHref;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="gamerTag">
        /// Gamer Tag of the user
        /// </param>
        /// <param name="profileTileId">
        /// This value is a 24 character string in one of two forms.
        /// If the gamerpic is an avatar picture it will be 0001XXXXYYYYYYYY0001XXXXYYYYYYYY with 
        /// X being random characters (ignored) and Y being the user's gamertag, padded with null characters ('\0')
        /// If the gamerpic is a standard tile, the form will be "XXXXXXXXYYYYYYYYZZZZZZZZ", 
        /// with X as the title id for the image, Y as the normal 64x64 image id, and Z as the 32x32 image id.
        /// </param>
        /// <param name="bigTile">
        /// True to get the 64x64 tile, false to get the 32x32 tile.
        /// </param>
        /// <param name="secure">True to get the secure (https) url, false to get the standard (http) tile.</param>
        /// <returns></returns>
        //
        // Warning - profileTileId doesn't come as a 24 characters always as it claims here
        //
        public string GamerTileUrl(string gamerTag, string profileTileId, bool bigTile, bool secure)
        {
            string tileUrl = String.Empty;
            if ((profileTileId == null) || (profileTileId.Length < 24))
            {
                // set the default gamer pic URL
                tileUrl = GetAvatarTileUrl(gamerTag, profileTileId, bigTile, secure);
                return tileUrl;
            }
            
            try
            {
                string titleId = profileTileId.Substring(0, 4);
                if (titleId == "0001")
                {
                    // Avatar photobooth tile
                    tileUrl = GetAvatarTileUrl(gamerTag, profileTileId, bigTile, secure);
                }
                else
                {
                    // Standard gamer tile
                    tileUrl = GetStandardTileUrl(profileTileId, bigTile, secure);
                }
            }
            catch (FormatException)
            {
                tileUrl = GetAvatarTileUrl(gamerTag, profileTileId, bigTile, secure);
                return tileUrl;
            }

            return tileUrl;
        }

        // this function will be called only if profileTileId.Length > 23
        // investigate format of profileTileId, if URL appears to be created incorrectly
        private string GetStandardTileUrl(string profileTileId, bool bigTile, bool secure)
        {
            string uriRoot;

            if (secure)
            {
                uriRoot = _config.GetSetting(Settings.GamerPictureSecureUriRoot);
            }
            else
            {
                uriRoot = _config.GetSetting(Settings.GamerPictureUriRoot);
            }

            string titleId;
            string tileId;

            titleId = profileTileId.Substring(0, 8);

            // The tile ID is padded with leading zeros, which must be removed to create a valid URL
            if (bigTile)
            {
                tileId = profileTileId.Substring(8, 8).TrimStart('0');
            }
            else
            {
                tileId = profileTileId.Substring(16, 8).TrimStart('0');
            }

            return String.Format("{0}/global/t.{1}/tile/0/{2}", uriRoot, titleId, tileId);
        }

        public string TitleTileUrl(uint uiTitleId)
        {
            string tilesDomain = _config.GetSetting(Settings.TilesDomainName);
            
            StringBuilder storagePath = new StringBuilder(40);

            storagePath.Append("//global/t:");
            storagePath.Append(uiTitleId.ToString("X"));
            storagePath.Append("/icon/0/8000");

            TileSpecifier specifier = new TileSpecifier(storagePath.ToString(), 0);

            string tileLocation = String.Concat("http://", tilesDomain, "/tiles", specifier.UrlPath);

            Uri titleTile = new Uri(tileLocation);
            return titleTile.AbsoluteUri;
        }

        private string GetAvatarTileUrl(string gamerTag, string profileTileId, bool bigTile, bool secure)
        {
            string tileUrl = String.Empty;
            string uriRoot;

            if (secure)
            {
                uriRoot = _config.GetSetting(Settings.AvatarPictureSecureUriRoot);
            }
            else
            {
                uriRoot = _config.GetSetting(Settings.AvatarPictureUriRoot);
            }

            // for some reason gamerTag is not passed, then set it using profileTileId
            // this function will be called only when profileTileId.Length > 23
            if (String.IsNullOrEmpty(gamerTag) && !string.IsNullOrEmpty(profileTileId) && profileTileId.Length > 23)
            {
                // The gamertag will be padded with null characters, strip them off
                gamerTag = System.Web.HttpUtility.UrlPathEncode(profileTileId.Substring(8, 16).Trim('\0'));
            }


            if (String.IsNullOrEmpty(gamerTag))
            {
                // Set to default just to construct the avatar URL
                gamerTag = "0";
            }


            if (bigTile)
            {
                tileUrl = String.Format("{0}/avatar/{1}/avatarpic-l.png", uriRoot, gamerTag);
            }
            else
            {
                tileUrl = String.Format("{0}/avatar/{1}/avatarpic-s.png", uriRoot, gamerTag);
            }

            return tileUrl;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live.Xblm\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Leet.Live.Xblm")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live.Xblm\IXblmFastAccess.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;

namespace Leet.Live.Xblm
{
   
    /// <summary>
    /// Interface that wraps methods to access FAST APIs
    /// </summary>
    public interface IXblmFastAccess
    {
        /// <summary>
        /// Query all assets for a title id fileterd by locale and store
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="locale"></param>
        /// <param name="productTypes"></param>
        /// <param name="store"></param>
        /// <returns></returns>
        XblmAssetsResponse QueryAssets(UInt32 titleId, String locale, String productTypes, String store);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live.Xblm\XblmAssetsResponse.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml;
using System.Net;

namespace Leet.Live.Xblm
{
    /// <summary>
    /// FASTAssetsAccessResponse
    /// </summary>
    public class XblmAssetsResponse : XblmResponse
    {
        public XblmAssetsResponse(HttpStatusCode statusCode, XmlReader response)
        {
            base.StatusCode = statusCode;
            base.Response = response;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live.Xblm\XblmResponse.cs ===
﻿using System;
using System.Net;
using System.Xml;

namespace Leet.Live.Xblm
{
    public abstract class XblmResponse
    {
        public HttpStatusCode StatusCode
        {
            get;
            protected set;
        }

        public XmlReader Response
        {
            get;
            protected set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live.Xblm\XblmFastAccess.cs ===
﻿using System;
using System.Xml;
using System.Net;
using System.IO;
namespace Leet.Live.Xblm
{
    public class XblmFastAccess : IXblmFastAccess
    {
        #region IFASTAssetsAccess Members

        public XblmAssetsResponse QueryAssets(uint titleId, string locale, string productTypes, string stores)
        {
            XblmAssetsResponse fastResponse = null;

            //query marketplace FAST API to all Game Consumable assets for this title
            String query = 
                String.Format(System.Globalization.CultureInfo.CurrentUICulture, "{0}/{1}/{2}?producttypes={3}&tiers=2&hextitles=0x{4:X}&stores={5}", XblmSettings.XblmUrl.ToString(), XblmSettings.XblmVersionProductPath, locale, productTypes, titleId, stores);
            
            var consumablesRequest = (HttpWebRequest)HttpWebRequest.Create(new Uri(query));
            consumablesRequest.Method = "GET";
            using (var webResponse = consumablesRequest.GetResponse() as HttpWebResponse)
            {
                if (webResponse != null) //can be null
                {
                    var ws = webResponse.GetResponseStream();
                    if (ws != null) //stream can be null here
                    {
                        //create a copy of the response in another memory stream so that we can close the webResponse stream object
                        fastResponse = new XblmAssetsResponse(webResponse.StatusCode,
                                                              new XmlTextReader(new StringReader(new StreamReader(ws).ReadToEnd())));
                    }
                }
            }  //finally should release the webResponse object and the underlying stream

            return fastResponse;

        }

        #endregion
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live.Xblm\XblmSettings.cs ===
﻿using System;
using System.Text;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Leet.Live.Xblm
{
    public static class XblmSettings
    {
        private static IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

        public static Uri XblmUrl
        {
            get 
            {
                return new Uri(configProvider.GetSetting(Settings.Pdlc_InternalXblMarketplaceCatalogUrl));
            }
        }

        public static String XblmNameSpace
        {
            get { return configProvider.GetSetting(Settings.Pdlc_XblmNameSpace); }  
        }

        public static String XblmVersionProductPath
        {
            get { return configProvider.GetSetting(Settings.Pdlc_XblmVersionProductPath); } 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live\Leet.Live.Tiles\Utility\CRC32WireData.cs ===
﻿using System;
using System.IO;
using System.Text;
using Leet.Live.Tiles.Exception;
using xonline.common.service;

namespace Leet.Live.Tiles.Utility
{
    public class CRC32WireData : WireData
    {
        public virtual bool FromBytes(byte[] buf)
        {
            MemoryStream stream = new MemoryStream(buf);
            BinaryReader reader = new BinaryReader(stream);
            CRC32 crc = new CRC32();

            try
            {
                base.ReadStream(reader);
            }
            catch (xonline.common.service.XRLException ex)
            {
                throw new SignedDataInvalidException("Error reading signed data.", ex);
            }

            int posHashStart = (int)stream.Position;
            byte[] hash = crc.ComputeHash(buf, 0, posHashStart);

            if (hash.Length != buf.Length - posHashStart)
            {
                throw new SignedDataInvalidException(
                    String.Format("CRC32 not verified: req is {0}, expected {1}.",
                    BytesToHexString(buf, posHashStart),
                    BytesToHexString(hash)));
            }

            for (int i = 0; i < hash.Length; i++)
            {
                if (hash[i] != buf[posHashStart + i])
                {
                    throw new SignedDataInvalidException(
                        String.Format("CRC32 not verified: req is {0}, expected {1}.",
                        BytesToHexString(buf, posHashStart),
                        BytesToHexString(hash)));
                }
            }

            return true;
        }

        public virtual byte[] ToBytes()
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);

            base.WriteStream(writer);
            writer.Flush();

            stream.Position = 0;

            CRC32 crc = new CRC32();
            byte[] hash = crc.ComputeHash(stream);

            writer.Write(hash);
            writer.Flush();

            return stream.ToArray();

        }


        //
        // helper functions
        //

        private static string BytesToHexString(byte[] bytes, int start, int len)
        {
            string hexDigit = "0123456789ABCDEF";

            StringBuilder sb = new StringBuilder(3 * len);
            for (int i = 0; i < len; i++)
            {
                int b = (bytes[start + i]);
                sb.Append(hexDigit[b / 16]);
                sb.Append(hexDigit[b % 16]);
                sb.Append(' ');
            }
            return sb.ToString();
        }

        private static string BytesToHexString(byte[] bytes, int start)
        {
            return BytesToHexString(bytes, start, bytes.Length - start);
        }

        private static string BytesToHexString(byte[] bytes)
        {
            return BytesToHexString(bytes, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\AbchContactsProvider.cs ===
﻿using System;
using System.Net;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Profile.Proxies;

namespace Leet.Profile
{
    // TODO: Add error handling, perf counters, eventing
    [SingletonInstance]
    public class AbchContactsProvider : IAbchContactsProvider
    {
        private readonly ABService abService;
        private readonly FindPageContext findPageContext;
        private readonly FindPageContext findPageContextSmall;
        private readonly FindFilterOptions findFilterOptions;

        public AbchContactsProvider()
        {
            var configProvider = 
                Container.Instance.GetComponent<IConfigurationProvider>();
            
            var appHeader =
                new ABApplicationHeader
                    {
                        ApplicationId = 
                            new Guid(configProvider.GetSetting(Settings.ABCHApplicationId))
                    };

            this.abService =
                new ABService
                    {
                        ABApplicationHeaderValue = appHeader,
                        Url = configProvider.GetSetting(Settings.ABCHServiceUrl)
                    };

            if (!string.IsNullOrEmpty(configProvider.GetSetting(Settings.ProxyAddress)))
            {
                this.abService.Proxy = 
                    new WebProxy(
                        configProvider.GetSetting(Settings.ProxyAddress), 
                        true);
            }

            findPageContext = new FindPageContext
            {
                PageSize = 100,
                StartContact = null,
                Direction = FindPageDirection.Forward
            };

            findPageContextSmall = new FindPageContext
            {
                PageSize = 20,
                StartContact = null,
                Direction = FindPageDirection.Forward
            };

            findFilterOptions = new FindFilterOptions { DeltasOnly = false };
        }

        public FindContactsPagedResult FindContacts(long puid)
        {
            var handle =
                new ABHandle
                    {
                        ABId = new Guid(string.Format("{0:x32}", puid))
                    };

            // TODO: Add code to iterate over contacts if there are more than 100 (page size)
            var contacts = abService.ABFindContactsPaged(
                            handle, ABView.ContactControl, findPageContext, null, findFilterOptions,
                            (ExtendedContentTypes.AB | ExtendedContentTypes.AllGroups));

            return contacts;
        }

        public long FindPuid(long cid)
        {
            var handle = new ABHandle { Cid = cid };

            var abInfo = this.GetABInfo(handle);

            return abInfo.ownerPuid;
        }

        public long FindCid(long puid)
        {
            var handle = new ABHandle { Puid = puid };

            var abInfo = this.GetABInfo(handle);

            return abInfo.OwnerCID;
        }

        private ABInfo GetABInfo(ABHandle handle)
        {
            var contacts = abService.ABFindContactsPaged(
                handle, ABView.ContactControl, findPageContextSmall, null, findFilterOptions,
                ExtendedContentTypes.AB);

            return contacts.Ab.abInfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Live.Xblm\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Live.FAST")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

[assembly:System.CLSCompliant(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6edc9542-b90f-4ff2-b8aa-5969ca93f130")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\CloudDirectoryProfileData.cs ===
﻿using System;

namespace Leet.Profile
{
    /// <summary>
    /// CloudDirectoryProfileData Class
    /// </summary>
    public class CloudDirectoryProfileData
    {
        /// <summary>
        /// Initializes a new instance of the CloudDirectoryProfileData class.
        /// </summary>
        /// <param name="displayName">Display name of the user</param>
        /// <param name="displayPictureUri">Uri of the display picture</param>
        public CloudDirectoryProfileData(string displayName, Uri displayPictureUri)
        {
            this.DisplayName = displayName;
            this.DisplayPictureUri = displayPictureUri;
        }

        /// <summary>
        /// Gets the Display Name of the user
        /// </summary>
        public string DisplayName { get; private set; }
        
        /// <summary>
        /// Gets the DisplayPictureUri of the user
        /// </summary>
        public Uri DisplayPictureUri { get; private set; }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet", Scope = "namespace", Target = "Leet.Profile")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Leet")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists", Scope = "member", Target = "Leet.Profile.ICloudDirectoryProfileProvider.#GetMany(System.Int64,System.Int64,System.Collections.Generic.List`1<System.Int64>)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid", Scope = "member", Target = "Leet.Profile.ICloudDirectoryProfileProvider.#GetMany(System.Int64,System.Int64,System.Collections.Generic.List`1<System.Int64>)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Scope = "type", Target = "Leet.Profile.CloudDirectoryProfileProvider")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "Leet.Profile.CloudDirectoryProfileProvider.#CloudDirectoryProfileService")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists", Scope = "member", Target = "Leet.Profile.CloudDirectoryProfileProvider.#GetMany(System.Int64,System.Int64,System.Collections.Generic.List`1<System.Int64>)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Abch", Scope = "type", Target = "Leet.Profile.AbchContactsProvider")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)", Scope = "member", Target = "Leet.Profile.AbchContactsProvider.#FindContacts(System.Int64)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Abch", Scope = "type", Target = "Leet.Profile.IAbchContactsProvider")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "puid", Scope = "member", Target = "Leet.Profile.IAbchContactsProvider.#FindContacts(System.Int64)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetFriends(Leet.Authentication.IIdentityManager,System.Collections.Generic.ICollection`1<System.Int32>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfiles(Leet.Authentication.IIdentityManager,System.Collections.Generic.ICollection`1<Leet.Authentication.SocialIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfiles(Leet.Authentication.IIdentityManager,System.Collections.Generic.ICollection`1<Leet.Authentication.SocialIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,Leet.Authentication.SocialIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,Leet.Authentication.SocialIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfiles(Leet.Authentication.IIdentityManager,System.Collections.Generic.ICollection`1<Leet.Authentication.SocialIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetFriends(Leet.Authentication.IIdentityManager,System.Collections.Generic.ICollection`1<System.Int32>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfiles(Leet.Authentication.IIdentityManager,System.Collections.Generic.IList`1<Leet.Authentication.SocialIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfiles(Leet.Authentication.IIdentityManager,System.Collections.Generic.IList`1<Leet.Authentication.SocialIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid", Scope = "member", Target = "Leet.Profile.ICloudDirectoryProfileProvider.#GetMany(System.Int64,System.Int64,System.Collections.Generic.List`1<System.Int64>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.CloudDirectoryAdapter.#GetMany(System.Int64,System.Int64,System.Collections.Generic.List`1<System.Int64>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists", Scope = "member", Target = "Leet.Profile.CloudDirectoryAdapter.#GetMany(System.Int64,System.Int64,System.Collections.Generic.List`1<System.Int64>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid", Scope = "member", Target = "Leet.Profile.CloudDirectoryAdapter.#GetMany(System.Int64,System.Int64,System.Collections.Generic.List`1<System.Int64>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Leet.Profile")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid", Scope = "member", Target = "Leet.Profile.IWindowsLiveProfileProvider.#GetProfiles(System.Int64,System.Int64,System.Collections.Generic.List`1<System.Int64>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", MessageId = "3#", Scope = "member", Target = "Leet.Profile.IWindowsLiveProfileProvider.#GetProfiles(System.Int64,System.Int64,System.Collections.Generic.ICollection`1<System.Int64>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid", Scope = "member", Target = "Leet.Profile.IWindowsLiveProfileProvider.#GetProfiles(System.Int64,System.Int64,System.Collections.Generic.ICollection`1<System.Int64>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "partialResult", Scope = "member", Target = "Leet.Profile.ProfileProvider.#PopulateProfile(Leet.UserGameData.DataContracts.Profile,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Get", Scope = "member", Target = "Leet.Profile.ICloudDirectoryProfileProvider.#Get(Leet.Profile.Proxies.SOAPApplicationHeader,Leet.Profile.Proxies.SOAPUserHeader,Leet.Profile.Proxies.GetProfileRequest)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid", Scope = "member", Target = "Leet.Profile.IWindowsLiveProfileProvider.#GetProfile(System.Int64,System.Int64,System.Int64)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Leet.Profile.ProfileProvider.#PopulateProfile(Leet.UserGameData.DataContracts.Profile,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.Int64.Parse(System.String)", Scope = "member", Target = "Leet.Profile.ProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,Leet.Authentication.SocialIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", MessageId = "3#", Scope = "member", Target = "Leet.Profile.IWindowsLiveProfileProvider.#GetProfile(System.Int64,System.Int64,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid", Scope = "member", Target = "Leet.Profile.IWindowsLiveProfileProvider.#GetProfile(System.Int64,System.Int64,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1063:ImplementIDisposableCorrectly", Scope = "type", Target = "Leet.Profile.CloudDirectoryProfileProvider")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1063:ImplementIDisposableCorrectly", Scope = "member", Target = "Leet.Profile.CloudDirectoryProfileProvider.#Dispose()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1816:CallGCSuppressFinalizeCorrectly", Scope = "member", Target = "Leet.Profile.CloudDirectoryProfileProvider.#Dispose()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetFriends(Leet.Authentication.IIdentityManager,System.Collections.Generic.ICollection`1<System.Int32>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,Leet.Authentication.SocialIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,Leet.Authentication.SocialIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfiles(Leet.Authentication.IIdentityManager,System.Collections.Generic.IList`1<Leet.Authentication.SocialIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfiles(Leet.Authentication.IIdentityManager,System.Collections.Generic.IList`1<Leet.Authentication.SocialIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Authentication.IIdentityManager,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Scope = "member", Target = "Leet.Profile.ProfileProvider.#RegisterLivecacheInterfaces()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetFriends(Leet.Authentication.IUserIdentity,System.Collections.Generic.ICollection`1<System.Int32>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Authentication.IUserIdentity,Leet.Authentication.IUserIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Authentication.IUserIdentity,Leet.Authentication.IUserIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Authentication.IUserIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Authentication.IUserIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfiles(Leet.Authentication.IUserIdentity,System.Collections.Generic.IList`1<Leet.Authentication.IUserIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfiles(Leet.Authentication.IUserIdentity,System.Collections.Generic.IList`1<Leet.Authentication.IUserIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "1#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetFriends(Leet.Authentication.IUserIdentity,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "1#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetFriends(Leet.Identity.IUserIdentity,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Identity.IUserIdentity,Leet.Identity.IUserIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Identity.IUserIdentity,Leet.Identity.IUserIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Identity.IUserIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfile(Leet.Identity.IUserIdentity,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "3#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfiles(Leet.Identity.IUserIdentity,System.Collections.Generic.IList`1<Leet.Identity.IUserIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1726:UsePreferredTerms", MessageId = "Flags", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetProfiles(Leet.Identity.IUserIdentity,System.Collections.Generic.IList`1<Leet.Identity.IUserIdentity>,System.Int64,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Leet.Profile.ProfileProvider.#AddContactProfileToList(Leet.Profile.Proxies.Contact,Leet.Identity.IUserIdentity,System.Collections.Generic.IList`1<Leet.UserGameData.DataContracts.Profile>,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Scope = "member", Target = "Leet.Profile.ProfileProvider.#RegisterLivecacheInterfaces(Leet.Core.IoCCo.IContainer)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Leet.Profile.IProfileProvider.#GetFriends(Leet.Identity.IUserIdentity,Leet.UserGameData.DataContracts.Network,System.Boolean&)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\IAbchContactsProvider.cs ===
﻿using Leet.Profile.Proxies;

namespace Leet.Profile
{
    public interface IAbchContactsProvider
    {
        FindContactsPagedResult FindContacts(long puid);
        long FindPuid(long cid);
        long FindCid(long puid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\CloudDirectoryAdapter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Profile.Proxies;
using Leet.Core.Utils;
using Leet.Core.Diagnostics;

namespace Leet.Profile
{
    public class CloudDirectoryAdapter : IWindowsLiveProfileProvider
    {
        /// <summary>
        /// Component name used for logging
        /// </summary>
        private const string ComponentName = "CloudDirectoryAdapter";

        /// <summary>
        /// CDP Application Id
        /// </summary>
        private readonly string applicationId;
        
        /// <summary>
        /// Default profile picture link
        /// </summary>
        private readonly string defaultProfilePicUrl;

        /// <summary>
        /// CloudDirectoryProfileProvider
        /// </summary>
        private readonly ICloudDirectoryProfileProvider provider;

        /// <summary>
        /// Initializes a new instance of the CloudDirectoryAdapter class.
        /// </summary>
        public CloudDirectoryAdapter()
        {
            this.provider = 
                Container.Instance.GetComponent<ICloudDirectoryProfileProvider>();

            var configProvider =
                Container.Instance.GetComponent<IConfigurationProvider>();
            this.applicationId =
                configProvider.GetSetting(Settings.CloudDirectoryProfileApplicationId);
            this.defaultProfilePicUrl = 
                configProvider.GetSetting(Settings.DefaultProfilePicUrl);
        }

        /// <summary>
        /// Takes a CID and returns the DisplayName and DisplayPictureUri
        /// of the profile picture
        /// </summary>
        /// <param name="callerPuid">Puid of the caller</param>
        /// <param name="callerCid">CID of the caller</param>
        /// <param name="targetCid">CID to return data for</param>
        /// <param name="partialResult">Indicates whether partially complete results 
        /// are being returned</param>
        /// <returns>Data for the requested profile</returns>
        public CloudDirectoryProfileData GetProfile(
            long callerPuid, long callerCid, long targetCid, 
            ref bool partialResult)
        {
            SOAPApplicationHeader applicationHeader;
            SOAPUserHeader userHeader;

            GetSoapHeaders(callerCid, callerPuid,
                out applicationHeader, out userHeader);

            var profileId = new ProfileId
                                {
                                    Ns1 = IdNamespace.Cid,
                                    V1 = targetCid
                                };

            // create the request
            GetProfileRequest getRequest = new GetProfileRequest
                                               {
                                                   Id = profileId,
                                                   ViewName = "All"
                                               };

            // make call to ICloudDirectoryProfileProvider
            GetProfileResponse getResponse = 
                this.provider.Get(applicationHeader, userHeader, getRequest);

            // check for errors or no views returned in the response
            if (getResponse.Errors != null || getResponse.View == null)
            {
                partialResult = true;

                return null;
            }

            // crack open the response and get relevant fields to return
            CloudDirectoryProfileData profileData = 
                ExtractProfileData(getResponse.View, ref partialResult);

            return profileData;
        }

        /// <summary>
        /// Takes a list of CIDs and returns a dictionary with the cid and DisplayPictureUri/DisplayName 
        /// of the profile picture
        /// </summary>
        /// <param name="callerPuid">Puid of the caller</param>
        /// <param name="callerCid">CID of the caller</param>
        /// <param name="cids">List of CIDs to return data for</param>
        /// <param name="partialResult">true if not all of the data availible from CDP</param>
        /// <returns>Data for each cid in cids if it exists in CDP</returns>
        public Dictionary<long, CloudDirectoryProfileData> GetProfiles(long callerPuid, long callerCid, 
            ICollection<long> cids, ref bool partialResult)
        {
            Dictionary<long, CloudDirectoryProfileData> profileData = 
                new Dictionary<long, CloudDirectoryProfileData>();

            // create the SOAP headers
            SOAPApplicationHeader applicationHeader;
            SOAPUserHeader userHeader;
            GetSoapHeaders(callerCid, callerPuid, 
                out applicationHeader, out userHeader);

            // create list of ProfileId objects
            var profiles = cids.Select(cid => new ProfileId
                                                  {
                                                      Ns1 = IdNamespace.Cid,
                                                      V1 = cid
                                                  });

            // create the request
            GetProfilesRequest getRequest = new GetProfilesRequest
                                                {
                                                    Ids = profiles.ToArray(),
                                                    ViewName = "All"
                                                };

            // make call to ICloudDirectoryProfileProvider
            GetProfilesResponse getResponse = 
                this.provider.GetMany(applicationHeader, userHeader, getRequest);

            // check for errors or no views returned in the response
            if (getResponse.Errors != null || getResponse.Views == null)
            {
                partialResult = true;

                return null;
            }

            int viewsCount = getResponse.Views.Length;

            // crack open the response and get relevant fields to return
            for (int i = 0; i < viewsCount; i++)
            {
                long cid = (long)getResponse.Ids[i].V1;

                profileData.Add(
                    cid, ExtractProfileData(getResponse.Views[i], ref partialResult));
            }

            return profileData;
        }

        /// <summary>
        /// Gets the specified attribute from the view
        /// </summary>
        /// <typeparam name="T">Type of the Attribute</typeparam>
        /// <param name="view">View</param>
        /// <param name="attributeName">Attribute name</param>
        /// <param name="partialResult">set to true if attribute not found</param>
        /// <returns>Attribute Value</returns>
        private static T GetAttribute<T>(View view, string attributeName, ref bool partialResult)
        {
            T value;

            try
            {
                value = (T) view.Attributes.Single(x => x.N == attributeName).V;
            }
            catch (InvalidOperationException ex)
            {
               Logging.TraceException(ex, "{0}:{1}", ComponentName,
                    "InvalidOperationException caught in method: GetAttribute<T>");

                partialResult = true;
                value = default(T);
            }

            return value;
        }

        private void GetSoapHeaders(long callerCid, long callerPuid, 
            out SOAPApplicationHeader applicationHeader, out SOAPUserHeader userHeader)
        {
            applicationHeader =
                new SOAPApplicationHeader
                    {
                        ApplicationId = new Guid(this.applicationId),
                        Scenario = "0",
                        TransactionId = "0"
                    };

            userHeader =
                new SOAPUserHeader
                    {
                        TicketToken = null,
                        Caller = new ProfileId
                                     {
                                         Ns1 = IdNamespace.Cid,
                                         V1 = callerCid,
                                         Ns2 = IdNamespace.Puid,
                                         V2 = callerPuid
                                     }
                    };
        }

        private CloudDirectoryProfileData ExtractProfileData(View view, ref bool partialResult)
        {
            // Only track whether display name was returned for the purposes of the 
            // partial result - last name and pic URL are optional anyway
            bool dummy = false;
            string displayName =
                GetAttribute<string>(view, "PublicProfile.DisplayName", ref partialResult) + " " +
                GetAttribute<string>(view, "PublicProfile.DisplayLastName", ref dummy);
            string profilePic = GetAttribute<string>(view, "UserTileStaticUrl", ref dummy);

            if (string.IsNullOrEmpty(profilePic))
            {
                profilePic = this.defaultProfilePicUrl;
            }

            var profileData =
                new CloudDirectoryProfileData(displayName.Trim(), new Uri(profilePic));

            return profileData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\CloudDirectoryProfileProvider.cs ===
﻿using System.Net;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Profile.Proxies;

namespace Leet.Profile
{
    [SingletonInstance]
    public class CloudDirectoryProfileProvider : ICloudDirectoryProfileProvider
    {
        public CloudDirectoryProfileProvider()
        {
            var config = Container.Instance.GetComponent<IConfigurationProvider>();

            this.cloudDirectoryProfileService =
                new CloudDirectoryProfileService
                    {
                        Url = config.GetSetting(Settings.CloudDirectoryProfileServiceUrl)                      
                    };

            var proxyAddress = config.GetSetting(Settings.ProxyAddress);
            if (!string.IsNullOrEmpty(proxyAddress))
            {
                this.CloudDirectoryProfileService.Proxy = new WebProxy(proxyAddress, true);
            }
        }

        /// <summary>
        /// Cloud Directory Profile service
        /// </summary>
        private readonly CloudDirectoryProfileService cloudDirectoryProfileService;

        /// <summary>
        /// Gets the CloudDirectoryProfileService.
        /// </summary>
        private CloudDirectoryProfileService CloudDirectoryProfileService
        {
            get
            {
                return this.cloudDirectoryProfileService;
            }
        }

        /// <summary>
        /// Takes a profile request and returns the response from CDP
        /// </summary>
        /// <param name="applicationHeader">Application Header for the request</param>
        /// <param name="userHeader">User Header for the request</param>
        /// <param name="request">Request object to send to CDP containing the target CID</param>
        /// <returns>the profiles in the GetProfileResponse if they exist in CDP</returns>   
        public GetProfileResponse Get(SOAPApplicationHeader applicationHeader, SOAPUserHeader userHeader,
            GetProfileRequest request)
        {
            this.CloudDirectoryProfileService.SOAPApplicationHeaderValue = applicationHeader;
            this.CloudDirectoryProfileService.SOAPUserHeaderValue = userHeader;
            
            return CloudDirectoryProfileService.Get(request);
        }

        /// <summary>
        /// Takes a profiles request and returns the response from CDP
        /// </summary>
        /// <param name="applicationHeader">Application Header for the request</param>
        /// <param name="userHeader">User Header for the request</param>
        /// <param name="request">Request object to send to CDP containing the list of target CIDs</param>
        /// <returns>the profiles in the GetProfilesResponse if they exist in CDP</returns>   
        public GetProfilesResponse GetMany(SOAPApplicationHeader applicationHeader, SOAPUserHeader userHeader, 
            GetProfilesRequest request)
        {
            this.CloudDirectoryProfileService.SOAPApplicationHeaderValue = applicationHeader;
            this.CloudDirectoryProfileService.SOAPUserHeaderValue = userHeader;
            
            return CloudDirectoryProfileService.GetMany(request);
        }

        /// <summary>
        /// Dispose the components of this class
        /// </summary>
        public void Dispose()
        {
            this.cloudDirectoryProfileService.Dispose();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\ICloudDirectoryProfileProvider.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Profile.Proxies;

namespace Leet.Profile
{
    /// <summary>
    /// Interface for the Cloud Directory Platform (CDP) Profile service provider
    /// </summary>
    public interface ICloudDirectoryProfileProvider : IDisposable
    {
        /// <summary>
        /// Takes a profile request and returns the response from CDP
        /// </summary>
        /// <param name="applicationHeader">Application Header for the request</param>
        /// <param name="userHeader">User Header for the request</param>
        /// <param name="request">Request object to send to CDP containing the target CID</param>
        /// <returns>the profiles in the GetProfileResponse if they exist in CDP</returns>   
        GetProfileResponse Get(SOAPApplicationHeader applicationHeader, SOAPUserHeader userHeader,
            GetProfileRequest request);
        
        /// <summary>
        /// Takes a profiles request and returns the response from CDP
        /// </summary>
        /// <param name="applicationHeader">Application Header for the request</param>
        /// <param name="userHeader">User Header for the request</param>
        /// <param name="request">Request object to send to CDP containing the list of target CIDs</param>
        /// <returns>the profiles in the GetProfilesResponse if they exist in CDP</returns>       
        GetProfilesResponse GetMany(SOAPApplicationHeader applicationHeader, SOAPUserHeader userHeader, 
            GetProfilesRequest request);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\IWindowsLiveProfileProvider.cs ===
using System.Collections.Generic;

namespace Leet.Profile
{
    public interface IWindowsLiveProfileProvider
    {
        /// <summary>
        /// Takes a CID and returns the DisplayName and DisplayPictureUri
        /// of the profile picture
        /// </summary>
        /// <param name="callerPuid">Puid of the caller</param>
        /// <param name="callerCid">CID of the caller</param>
        /// <param name="targetCid">CID to return DisplayData for</param>
        /// <param name="partialResult">Indicates whether partially complete results 
        /// are being returned</param>
        /// <returns>DisplayData for each cid in cids if it exists in CDP</returns>
        CloudDirectoryProfileData GetProfile(
            long callerPuid, long callerCid, long targetCid,
            ref bool partialResult);

        /// <summary>
        /// Takes a list of CIDs and returns a dictionary with the cid and DisplayPictureUri/DisplayName 
        /// of the profile picture
        /// </summary>
        /// <param name="callerPuid">Puid of the caller</param>
        /// <param name="callerCid">CID of the caller</param>
        /// <param name="cids">List of CIDs to return DisplayData for</param>
        /// <param name="partialResult">true if not all of the data availible from CDP</param>
        /// <returns>DisplayData for each cid in cids if it exists in CDP</returns>
        Dictionary<long, CloudDirectoryProfileData> GetProfiles(
            long callerPuid, long callerCid, ICollection<long> cids, 
            ref bool partialResult);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\ProfileCounters.cs ===
﻿
namespace Leet.Profile
{
    using System;
    using Leet.Core.Utils;
    using Leet.Utils;
    using Wgx.Services.Monitoring;
    using Leet.Core.Diagnostics;

    public enum ProfileMethod
    {
        GetProfileCaller,
        GetProfileTarget,
        GetFriends
    }

    /// <summary>
    /// Performance counter class for ProfileCounters
    /// </summary>
    public class ProfileCounters : PerfCounterBase<ProfileCounters>
    {
        private PerformanceCounterCollection counters;

        private static object lockObject = new Object();

        private bool perfCountersInitialized;

        private string instanceName = string.Empty;

        /// <summary>
        /// Initializes a new instance of the ProfileCounters class
        /// </summary>
        public ProfileCounters(string instanceName)
        {
            this.instanceName = instanceName;
            Initialize(instanceName);
        }

        private bool Initialize(string instanceName)
        {
            if (this.counters == null)
            {
                lock (lockObject)
                {
                    if (this.counters == null)
                    {
                        perfCountersInitialized = true;

                        try
                        {
                            this.counters = PerformanceCounters.GetPerformanceCounters(typeof(ProfilePerfCounters), instanceName);
                        }
                        catch (Exception ex)
                        {
                            this.perfCountersInitialized = false;
                            Logging.TraceException(ex, "ProfileCounters: ProfilePerfCounters has not been installed.");
                        }
                    }
                }
            }

            return perfCountersInitialized;
        }

        public override void StartRequest(Object profileMethod)
        {
            if (this.Initialize(this.instanceName))
            {
                base.StartRequest(profileMethod);
                
                ProfileMethod pm = (ProfileMethod)profileMethod;
                
                switch (pm)
                {
                    case ProfileMethod.GetProfileCaller:
                        this.counters.SafeIncrement(ProfilePerfCounters.GetProfileCallerRequestsPerSecond);
                        this.counters.SafeIncrement(ProfilePerfCounters.GetProfileCallerTotalRequests);
                        break;
                    case ProfileMethod.GetProfileTarget:
                        this.counters.SafeIncrement(ProfilePerfCounters.GetProfileTargetRequestsPerSecond);
                        this.counters.SafeIncrement(ProfilePerfCounters.GetProfileTargetTotalRequests);
                        break;
                    case ProfileMethod.GetFriends:
                        this.counters.SafeIncrement(ProfilePerfCounters.GetFriendsRequestsPerSecond);
                        this.counters.SafeIncrement(ProfilePerfCounters.GetFriendsTotalRequests);
                        break;
                    default:
                        Logging.TraceError("ProfileCounters: ProfileMethod not found.");
                        break;
                }
            }
        }

        public override long EndRequest(bool failed)
        {
            long duration = 0;
            if (this.perfCountersInitialized)
            {
                // it is imperative that Context object be retrieved once and before the base.EndRequest() call
                ProfileMethod pm = (ProfileMethod)ProfileCounters.Context;

                // Note: thread-static members are simply set by the StartRequest Call.
                duration = base.EndRequest(failed);

                switch (pm)
                {
                    case ProfileMethod.GetProfileCaller:
                        this.counters.SafeIncrementBy(ProfilePerfCounters.GetProfileCallerAverageExecutionTime, duration);
                        this.counters.SafeIncrement(ProfilePerfCounters.GetProfileCallerAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(ProfilePerfCounters.GetProfileCallerFailuresPerSecond);
                            this.counters.SafeIncrement(ProfilePerfCounters.GetProfileCallerTotalFailures);
                        }

                        break;
                    case ProfileMethod.GetProfileTarget:
                        this.counters.SafeIncrementBy(ProfilePerfCounters.GetProfileTargetAverageExecutionTime, duration);
                        this.counters.SafeIncrement(ProfilePerfCounters.GetProfileTargetAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(ProfilePerfCounters.GetProfileTargetFailuresPerSecond);
                            this.counters.SafeIncrement(ProfilePerfCounters.GetProfileTargetTotalFailures);
                        }

                        break;
                    case ProfileMethod.GetFriends:
                        this.counters.SafeIncrementBy(ProfilePerfCounters.GetFriendsAverageExecutionTime, duration);
                        this.counters.SafeIncrement(ProfilePerfCounters.GetFriendsAverageExecutionTimeBase);
                        if (failed)
                        {
                            this.counters.SafeIncrement(ProfilePerfCounters.GetFriendsFailuresPerSecond);
                            this.counters.SafeIncrement(ProfilePerfCounters.GetFriendsTotalFailures);
                        }

                        break;
                    default:
                        Logging.TraceError("ProfileCounters: ProfileMethod not found.");
                        break;
                }
            }

            return duration;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\ProfileServiceException.cs ===
﻿using System;
using System.Runtime.Serialization;

namespace Leet.Profile
{
    [Serializable]
    public class ProfileServiceException : Exception
    {
        public ProfileServiceException()
        {
        }

        public ProfileServiceException(string message)
            : base(message)
        {
        }

        public ProfileServiceException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        protected ProfileServiceException(SerializationInfo serializationInfo, 
            StreamingContext streamingContext)
            : base(serializationInfo, streamingContext)
        {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\ProfilePerfCounters.cs ===
﻿
namespace Leet.Profile
{
    using System.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class implements the Rewards PerfCounter Category
    /// </summary>
    [PerformanceCategory(CategoryName = "Leet.Profile", CategoryType = PerformanceCounterCategoryType.MultiInstance)]
    public sealed class ProfilePerfCounters
    {
        private ProfilePerfCounters()
        {
        }

        public static string Name
        {
            get
            {
                return "Leet.Profile";
            }
        }

        public static PerformanceCounterCollection Counters
        {
            get;
            set;
        }

        /// <summary>
        /// Performance counters for GetProfile (Caller)
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "GetProfileCallerTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for GetProfile (Caller)")]
        public static int GetProfileCallerTotalRequests;

        [PerformanceCounterAttribute(CounterName = "GetProfileCallerTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for GetProfile (Caller)")]
        public static int GetProfileCallerTotalFailures;

        [PerformanceCounterAttribute(CounterName = "GetProfileCallerRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "GetProfile (Caller) requests per second")]
        public static int GetProfileCallerRequestsPerSecond;

        [PerformanceCounterAttribute(CounterName = "GetProfileCallerFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "GetProfile (Caller) failures per second")]
        public static int GetProfileCallerFailuresPerSecond;

        [PerformanceCounterAttribute(CounterName = "GetProfileCallerAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for GetProfile (Caller)")]
        public static int GetProfileCallerAverageExecutionTimeBase;

        [PerformanceCounterAttribute(CounterName = "GetProfileCallerAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for GetProfile (Caller)", BasePropertyName = "GetProfileCallerAverageExecutionTimeBase")]
        public static int GetProfileCallerAverageExecutionTime;

        /// <summary>
        /// Performance counters for GetProfile (Target)
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "GetProfileTargetTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for GetProfile (Target)")]
        public static int GetProfileTargetTotalRequests;

        [PerformanceCounterAttribute(CounterName = "GetProfileTargetTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for GetProfile (Target)")]
        public static int GetProfileTargetTotalFailures;

        [PerformanceCounterAttribute(CounterName = "GetProfileTargetRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "GetProfile (Target) requests per second")]
        public static int GetProfileTargetRequestsPerSecond;

        [PerformanceCounterAttribute(CounterName = "GetProfileTargetFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "GetProfile (Target) failures per second")]
        public static int GetProfileTargetFailuresPerSecond;

        [PerformanceCounterAttribute(CounterName = "GetProfileTargetAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for GetProfile (Target)")]
        public static int GetProfileTargetAverageExecutionTimeBase;

        [PerformanceCounterAttribute(CounterName = "GetProfileTargetAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for GetProfile (Target)", BasePropertyName = "GetProfileTargetAverageExecutionTimeBase")]
        public static int GetProfileTargetAverageExecutionTime;

        /// <summary>
        /// Performance counters for GetFriends
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "GetFriendsTotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
    CounterDescription = "Total requests for GetFriends")]
        public static int GetFriendsTotalRequests;

        [PerformanceCounterAttribute(CounterName = "GetFriendsTotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for GetFriends")]
        public static int GetFriendsTotalFailures;

        [PerformanceCounterAttribute(CounterName = "GetFriendsRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
            CounterDescription = "GetFriends requests per second")]
        public static int GetFriendsRequestsPerSecond;

        [PerformanceCounterAttribute(CounterName = "GetFriendsFailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
    CounterDescription = "GetFriends failures per second")]
        public static int GetFriendsFailuresPerSecond;

        [PerformanceCounterAttribute(CounterName = "GetFriendsAverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
CounterDescription = "Average waiting base for GetFriends")]
        public static int GetFriendsAverageExecutionTimeBase;

        [PerformanceCounterAttribute(CounterName = "GetFriendsAverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "Average execution time for GetFriends", BasePropertyName = "GetFriendsAverageExecutionTimeBase")]
        public static int GetFriendsAverageExecutionTime;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\IProfileProvider.cs ===
﻿

namespace Leet.Profile
{
    using Leet.Identity;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.UserGameData.DataContracts;

    public interface IProfileProvider
    {
        /// <summary>
        /// Gets the profile for the calling user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the calling user</returns>
        UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult);

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="targetGamertag">
        /// Gamertag of the user whose profile is requested
        /// </param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <param name="targetIdentity">Target's identity</param>
        /// <returns>Profile of the target user</returns>
        UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            string targetGamertag,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult,
            out Identity targetIdentity);

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="targetXuid">Target's Xuid</param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="friendsInfoList">Friend list information.</param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the target user</returns>
        UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            ulong targetXuid,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult);

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="cid">
        /// CID of the user whose profile is requested
        /// </param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the target user</returns>
        UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            long cid,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult);

        /// <summary>
        /// Gets a list of the calling user's friends
        /// </summary>
        /// <param name="callerIdentity">Calling user's identity</param>
        /// <param name="friendNetwork">Network friends are requested from</param>
        /// <param name="partialResult">
        /// Indicates whether partial results are being returned
        /// </param>
        /// <returns></returns>
        XmlSerializableList<UserGameData.DataContracts.Profile> GetFriends(
            IUserIdentity callerIdentity, Network friendNetwork, out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult);

        /// <summary>
        /// Gets a list of the calling user's friends for leaderboard
        /// </summary>
        /// <param name="callerIdentity">Calling user's identity</param>
        /// <param name="friendNetwork">Network friends are requested from</param>
        /// <param name="partialResult">
        /// Indicates whether partial results are being returned
        /// </param>
        /// <returns>array of IReadOnlyFriendInfo </returns>
        Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] GetFriendsForLeaderboard(
            IUserIdentity callerIdentity, Network friendNetwork,
            out bool partialResult);


        /// <summary>
        /// Return the profile for a given array of xuids
        /// </summary>
        /// <param name="callingXuid">caller</param>
        /// <param name="friendsInfo">array of xuids</param>
        /// <returns></returns>
        Leet.Live.Livecache.Logic.Profile.IGamerProfile[] GetProfile(
            ulong callingXuid,
            ulong[] xuids);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\ProfileProvider.cs ===
﻿namespace Leet.Profile
{
    using System;
    using System.Collections; 
    using System.Collections.Generic;
    using System.Security.Authentication;
    using System.Diagnostics;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Platforms;
    using Leet.Core.Diagnostics;
    using Leet.Identity;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Live.Tiles;
    using Leet.Profile.Proxies;
    using Leet.UserGameData.DataContracts;
    using Leet.Utils;
    using Leet.Live.Livecache.Logic.Games;
    using xonline.common.webplatform.livecache;
    using xonline.common.service;

    /// <summary>
    /// Profile Module APIs are exposed via this class
    /// </summary>
    public class ProfileProvider : IProfileProvider
    {
        /// <summary>
        /// Name of the component
        /// </summary>
        private const string ComponentName = "ProfileProvider";
        private const int MaxUserTitlesToFetch = 6; // maximum number of recent games to fetch for titles and recent achievement

        #region Public Members

        // This is set with the call RegisterWithIocContainer
        public static string InstanceName
        {
            get;
            private set;
        }

        internal ProfileCounters ProfileCounters { get; set; }

        public ProfileProvider()
        {
            this.ProfileCounters = new ProfileCounters(InstanceName);
        }

        /// <summary>
        /// Registers all required interfaces and implementations with the 
        /// IoCCo container.  
        /// </summary>
        /// <remarks>
        /// For all interfaces that can use test implementations,
        /// the test implementations can be enabled using configuration.
        /// </remarks>
        /// <param name="container">Container that the interfaces are registered in</param>
        public static void RegisterWithIocContainer(IContainer container, string instanceName)
        {
            container.AddEmulatableService<IProfileProvider, ProfileProvider>();
            container.AddEmulatableService<IWindowsLiveProfileProvider, CloudDirectoryAdapter>();
            InstanceName = instanceName;
        }

        /// <summary>
        /// Gets the profile for the calling user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the calling user</returns>
        public UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult)
        {
            bool requestFailed = false;

            try
            {
                this.ProfileCounters.StartRequest(ProfileMethod.GetProfileCaller);

                var targetIdentity = new Identity(callerIdentity.Xuid, callerIdentity.Puid, callerIdentity.Cid);

                friendsInfoList = null;

                var profile = GetProfile(callerIdentity, targetIdentity, locale, sectionFlags, out friendsInfoList, out partialResult);

                return profile;

            }
            catch (Exception)
            {
                requestFailed = true;
                throw;
            }
            finally
            {
                this.ProfileCounters.EndRequest(requestFailed);
            }
        }

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="targetGamertag">
        /// Gamertag of the user whose profile is requested
        /// </param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <param name="targetIdentity">Target identity</param>
        /// <returns>Profile of the target user</returns>
        public UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            string targetGamertag,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult,
            out Identity targetIdentity)
        {
            bool requestFailed = false;

            try
            {
                this.ProfileCounters.StartRequest(ProfileMethod.GetProfileTarget);
                targetIdentity = new Identity(targetGamertag);

                friendsInfoList = null;

                var profile = GetProfile(callerIdentity, targetIdentity, locale, sectionFlags, out friendsInfoList, out partialResult);

                return profile;
            }
            catch (Exception)
            {
                requestFailed = true;
                throw;
            }
            finally
            {
                this.ProfileCounters.EndRequest(requestFailed);
            }

        }

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="targetXuid">Target's Xuid</param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="friendsInfoList">Friend list information.</param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the target user</returns>
        public UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            ulong targetXuid,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult)
        {
            bool requestFailed = false;

            try
            {
                this.ProfileCounters.StartRequest(ProfileMethod.GetProfileTarget);
                Identity targetUserIdentity = new Identity(targetXuid, 0, 0);

                friendsInfoList = null;
                var profile = this.GetProfile(callerIdentity, targetUserIdentity, locale, sectionFlags, out friendsInfoList, out partialResult);

                return profile;
            }
            catch (Exception)
            {
                requestFailed = true;
                throw;
            }
            finally
            {
                this.ProfileCounters.EndRequest(requestFailed);
            }
        }

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="cid">
        /// CID of the user whose profile is requested
        /// </param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the target user</returns>
        public UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            long cid,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult)
        {
            var targetIdentity = new Identity(cid);

            friendsInfoList = null;

            var profile = GetProfile(callerIdentity, targetIdentity, locale, sectionFlags, out friendsInfoList, out partialResult);

            return profile;
        }

        /// <summary>
        /// Gets a list of the calling user's friends
        /// </summary>
        /// <param name="callerIdentity">Calling user's identity</param>
        /// <param name="friendNetwork">Network friends are requested from</param>
        /// <param name="partialResult">
        /// Indicates whether partial results are being returned
        /// </param>
        /// <returns>A list of xml serializable profiles of friends</returns>
        public XmlSerializableList<UserGameData.DataContracts.Profile> GetFriends(
            IUserIdentity callerIdentity, 
            Network friendNetwork,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult)
        {
            bool requestFailed = false;

            try
            {
                this.ProfileCounters.StartRequest(ProfileMethod.GetFriends);
                partialResult = false;

                XmlSerializableList<UserGameData.DataContracts.Profile> friendsList = null;
                friendsInfoList = null;
                if (friendNetwork == Network.XboxLive)
                {
                    friendsList =
                        GetXboxFriendsList(callerIdentity, callerIdentity.Xuid, true, out friendsInfoList, ref partialResult); 
                }
                
                return friendsList;
            }
            catch (Exception)
            {
                requestFailed = true;
                throw;
            }
            finally
            {
                this.ProfileCounters.EndRequest(requestFailed);
            }
        }

        /// <summary>
        /// Gets a list of the calling user's friends with data required for leaderboard
        /// </summary>
        /// <param name="callerIdentity">Calling user's identity</param>
        /// <param name="friendNetwork">Network friends are requested from</param>
        /// <param name="partialResult">
        /// Indicates whether partial results are being returned
        /// </param>
        /// <returns>array of IReadOnlyFriendInfo</returns>
        public Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] GetFriendsForLeaderboard(
            IUserIdentity callerIdentity,
            Network friendNetwork,
            out bool partialResult)
        {
            bool requestFailed = false;

            try
            {
                this.ProfileCounters.StartRequest(ProfileMethod.GetFriends);
                partialResult = false;

                Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] friendsList = new Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[0];

                if (friendNetwork == Network.XboxLive)
                {
                    friendsList = GetFriendsListForLeaderboard(callerIdentity, ref partialResult);
                }

                return friendsList;
            }
            catch (Exception)
            {
                requestFailed = true;
                throw;
            }
            finally
            {
                this.ProfileCounters.EndRequest(requestFailed);
            }
        }

        #endregion Public Members

        #region Private Members

        /// <summary>
        /// Retrieves Profile
        /// </summary>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="targetIdentity">Target's idenity</param>
        /// <param name="locale">Locale of data to be returned</param>
        /// <param name="sectionFlags">Specifies which profile section to be returned</param>
        /// <param name="partialResult">Whether there are partial results</param>
        /// <returns>Get target's profile</returns>
        private UserGameData.DataContracts.Profile GetProfile(
            IUserIdentity callerIdentity,
            Identity targetIdentity,
            string locale,
            long sectionFlags,
            out IReadOnlyFriendInfo[] friendsInfoList,
            out bool partialResult)
        {
            ushort lcid = 0;
            var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
            lcid = localeHelper.GetLCID(locale);

            CheckIIdentityManagerValidity(callerIdentity);

            partialResult = false;

            var profile = GetProfileAuthenticated(callerIdentity, targetIdentity, lcid, sectionFlags, out friendsInfoList, ref partialResult);

            return profile;
        }

        /// <summary>
        /// Get profile for already authenticated caller
        /// </summary>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="targetIdentity">Target's identity</param>
        /// <param name="lcid">Locale of the strings</param>
        /// <param name="sectionFlags">Specifies which profile sections to return</param>
        /// <param name="partialResult">Whether partial results are returned</param>
        /// <returns>Target's profile</returns>
        private UserGameData.DataContracts.Profile GetProfileAuthenticated(
            IUserIdentity callerIdentity, 
            Identity targetIdentity, 
            ushort lcid,
            long sectionFlags, 
            out IReadOnlyFriendInfo[] friendsInfoList,
            ref bool partialResult)
        {
            var profile = new UserGameData.DataContracts.Profile();
            
            PopulateProfile(profile, callerIdentity, targetIdentity, lcid, sectionFlags, false, out friendsInfoList, ref partialResult);

            return profile;
        }

        /// <summary>
        /// Populates profile
        /// </summary>
        /// <param name="profile">Profile to be poulated</param>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="targetIdentity">Target's identity</param>
        /// <param name="lcid">Locale of the strings</param>
        /// <param name="sectionFlags">Specifies which profile sections to return</param>
        /// <param name="includePrivateFields">Specifies whether to include private fields</param>
        /// <param name="partialResult">Whether partial results are returned</param>
        private void PopulateProfile(
            UserGameData.DataContracts.Profile profile,
            IUserIdentity callerIdentity, 
            Identity targetIdentity, 
            ushort lcid,
            long sectionFlags, 
            bool includePrivateFields,
            out IReadOnlyFriendInfo[] friendsInfoList,
            ref bool partialResult)
        {
           Logging.TraceVerbose("{0}: PopulateProfile {1}|{2}|{3}|{4}|{5}",
                ComponentName,
                callerIdentity.Xuid,
                targetIdentity.Puid,
                lcid,
                sectionFlags, 
                includePrivateFields);

            profile.SectionFlags = sectionFlags;
            friendsInfoList = null;

            if (FlagIsSet(sectionFlags, ProfileSections.XboxLiveProperties))
            {   
                AddProfilePropertiesToProfile(profile, callerIdentity.Xuid, targetIdentity.Xuid, ref partialResult);
            }

            if (FlagIsSet(sectionFlags, ProfileSections.WindowsLiveProperties))
            {
                throw new NotSupportedException("ProfileSections.WindowsLiveProperties section flag is not supported.");
            }

            if (FlagIsSet(sectionFlags, ProfileSections.Friends))
            {
                if (targetIdentity != null)
                {
                    profile.Friends =
                        GetXboxFriendsList(callerIdentity, targetIdentity.Xuid, includePrivateFields, out friendsInfoList, ref partialResult);
                }
            }

            // List of user's titles, we are fetching MaxUserTitlesToFetch here to avoid two live cache calls in this function
            List<IReadOnlyUserTitle> userTitles = null;

            if (FlagIsSet(sectionFlags, ProfileSections.RecentGames))
            {
                if ((callerIdentity != null) && (targetIdentity != null))
                {
                    var provider = Container.Instance.GetComponent<IAchievementDataAccess>();
                    userTitles = provider.GetUserTitles(callerIdentity.Xuid, targetIdentity.Xuid, lcid, 0, MaxUserTitlesToFetch);

                    // userTitles = null is handled inside the function
                    profile.RecentGames = GetRecentGames(userTitles, lcid, ref partialResult);
                }
            }

            if (FlagIsSet(sectionFlags, ProfileSections.RecentAchievements))
            {
                if ((callerIdentity != null) && (targetIdentity != null))
                {
                    if (userTitles == null && FlagIsSet(sectionFlags, ProfileSections.RecentGames) == false)
                    {
                        // the case where provider.GetUserTitles was not invoked because this flag was not set
                        var provider = Container.Instance.GetComponent<IAchievementDataAccess>();
                        userTitles = provider.GetUserTitles(callerIdentity.Xuid, targetIdentity.Xuid, lcid, 0, MaxUserTitlesToFetch);
                    }

                    // userTitles = null case is handled inside GetRecentAchievements method
                    profile.RecentAchievements =
                            GetRecentAchievements(userTitles, callerIdentity.Xuid, targetIdentity.Xuid, lcid, ref partialResult);
                }
            }
        }

        /// <summary>
        /// Returns a serializable list of Xbox friend's list 
        /// </summary>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="targetXuid">Target user's xuid</param>
        /// <param name="includePrivateFields">Whether to include private fields</param>
        /// <param name="partialResult">Whether partial results are added</param>
        /// <returns>A serializable list of Xbox friends profile list</returns>
        private XmlSerializableList<UserGameData.DataContracts.Profile> GetXboxFriendsList(
            IUserIdentity callerIdentity,
            ulong targetXuid, 
            bool includePrivateFields,
            out IReadOnlyFriendInfo[] xboxFriendsInfo,
            ref bool partialResult)
        {
            xboxFriendsInfo = null;

            var friendsList = new XmlSerializableList<UserGameData.DataContracts.Profile>();

            var presenceDataAccess =
                Container.Instance.GetComponent<IPresenceDataAccess>();

            try
            {
                if (targetXuid == callerIdentity.Xuid)
                {   // if target is the caller get his/her friends
                    xboxFriendsInfo = presenceDataAccess.GetFriendsInfo(targetXuid, false, true);
                }
                else if (targetXuid != 0)
                {   // if target is not the caller, get the targets friends (can return empty array based on targets privileges to expose friends)
                    xboxFriendsInfo = presenceDataAccess.GetFriendsOfFriend(callerIdentity.Xuid, targetXuid);
                }

                if (xboxFriendsInfo == null || xboxFriendsInfo.Length == 0)
                {
                    return friendsList; // No friends
                }
                else
                {
                    // find the friends in the state FriendState.Friend
                    int numFriends = 0;
                    for (int index = 0; index < xboxFriendsInfo.Length; index++)
                    {
                        // filter on friend's state - LSR3 restriction
                        if (xboxFriendsInfo[index].FriendState == Leet.Live.Livecache.Logic.Profile.FriendState.Friend)
                        {
                            numFriends++;
                        }
                    }

                    if (numFriends == 0)
                    {
                        return friendsList; // No friends
                    }

                    // create an array of frind's xuids (Live Cache call requires it)
                    ulong[] friends = new ulong[numFriends];
                    int friendIndex = 0;
                    for (int index = 0; index < xboxFriendsInfo.Length; index++)
                    {
                        // filter on friend's state - LSR3 restriction
                        if (xboxFriendsInfo[index].FriendState == Leet.Live.Livecache.Logic.Profile.FriendState.Friend)
                        {
                            friends[friendIndex] = xboxFriendsInfo[index].LivePuid;
                            friendIndex++;
                        }
                    }

                    IGamerProfile[] gamerProfile = GetProfilePartner(callerIdentity.Xuid, friends);
                    // this shouldn't happen but log it
                    if (gamerProfile == null || gamerProfile.Length == 0)
                    {
                        Logging.TraceError("{0}: Unexpected internal error in ProfileProvider.GetXboxFriendsList()gamerProfile is either null or empty",
                            ComponentName);

                        return friendsList; // return empty friends list
                    }

                    // this shouldn't happen but log it
                    if (gamerProfile.Length != friends.Length)
                    {
                        Logging.TraceError("{0}:Unexpected internal error in ProfileProvider.GetXboxFriendsList() gamerProfile.Length != xboxFriendsInfo.Length",
                            ComponentName);

                        return friendsList; // return empty friends list
                    }

                    // populate the profile of each of the friends
                    // need to traverse both arrays they are not 1-1
                    for (int index1 = 0; index1< xboxFriendsInfo.Length; index1++)
                    {
                        // filter on friend's state - LSR3 restriction
                        if (xboxFriendsInfo[index1].FriendState == Leet.Live.Livecache.Logic.Profile.FriendState.Friend)
                        {
                            for (int index2 = 0; index2 < gamerProfile.Length; index2++)
                            {
                                if (xboxFriendsInfo[index1].LivePuid == gamerProfile[index2].LivePuid)
                                {
                                    // got the match, populate the profile for this friend
                                    AddXboxFriendProfileToList(xboxFriendsInfo[index1], gamerProfile[index2], friendsList, includePrivateFields, ref partialResult);
                                    break; // from the ineer loop
                                }
                            }
                        }
                    }
                }
            }
            catch (LivecacheUserThrottledException ex)
            {
               partialResult = true;
               Logging.TraceException(ex, "{0} LivecacheUserThrottledException caught in method: GetXboxFriendsList", ComponentName);
            }
            catch (LivecacheResponseException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} LivecacheResponseException caught in method: GetXboxFriendsList",
                     ComponentName);
            }
            catch (ServiceUnavailableException ex)
            {
                partialResult = true;
                Logging.TraceException(ex, "{0} ServiceUnavailableException caught in method: GetXboxFriendsList",
                    ComponentName);
            }

            return friendsList;
        }

        /// <summary>
        /// Returns a serializable list of Xbox friend's list that does not filter out pending friends
        /// </summary>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="targetXuid">Target user's xuid</param>
        /// <param name="includePrivateFields">Whether to include private fields</param>
        /// <param name="xboxFriendsInfo">A list of xbox live friends</param>
        /// <param name="partialResult">Whether partial results are added</param>
        /// <returns>A serializable list of Xbox friends profile list</returns>
        public static XmlSerializableList<UserGameData.DataContracts.Profile> GetXboxEntireFriendsList(
            IUserIdentity callerIdentity,
            ulong targetXuid,
            bool includePrivateFields,
            out IReadOnlyFriendInfo[] xboxFriendsInfo,
            ref bool partialResult)
        {
            xboxFriendsInfo = null;

            var friendsList = new XmlSerializableList<UserGameData.DataContracts.Profile>();

            var presenceDataAccess =
                Container.Instance.GetComponent<IPresenceDataAccess>();

            try
            {
                if (targetXuid == callerIdentity.Xuid)
                {   // if target is the caller get his/her friends
                    xboxFriendsInfo = presenceDataAccess.GetFriendsInfo(targetXuid, false, true);
                }
                else
                {   // if target is not the caller, get the targets friends (can return empty array based on targets privileges to expose friends)
                    xboxFriendsInfo = presenceDataAccess.GetFriendsOfFriend(callerIdentity.Xuid, targetXuid);
                }

                if (xboxFriendsInfo == null || xboxFriendsInfo.Length == 0)
                {
                    return friendsList; // No friends
                }
                else
                {
                    // create an array of friend's xuids (Live Cache call requires it)
                    ulong[] friends = new ulong[xboxFriendsInfo.Length];
                    for (int index = 0; index < xboxFriendsInfo.Length; index++)
                    {
                        friends[index] = xboxFriendsInfo[index].LivePuid;
                    }

                    IGamerProfile[] gamerProfile = GetProfilePartner(callerIdentity.Xuid, friends);
                    // this shouldn't happen but log it
                    if (gamerProfile == null || gamerProfile.Length == 0)
                    {
                        Logging.TraceError("{0} > Unexpected internal error in ProfileProvider.GetXboxFriendsList() gamerProfile is either null or empty",
                            ComponentName);

                        return friendsList; // return empty friends list
                    }

                    // this shouldn't happen but log it
                    if (gamerProfile.Length != friends.Length)
                    {
                        Logging.TraceError("{0} > Unexpected internal error in ProfileProvider.GetXboxFriendsList() gamerProfile.Length != xboxFriendsInfo.Length",
                           ComponentName);

                        return friendsList; // return empty friends list
                    }

                    // populate the profile of each of the friends
                    // need to traverse both arrays they are not 1-1
                    for (int index1 = 0; index1 < xboxFriendsInfo.Length; index1++)
                    {
                        for (int index2 = 0; index2 < gamerProfile.Length; index2++)
                        {
                            if (xboxFriendsInfo[index1].LivePuid == gamerProfile[index2].LivePuid)
                            {
                                // got the match, populate the profile for this friend
                                AddXboxFriendProfileToList(xboxFriendsInfo[index1], gamerProfile[index2], friendsList, includePrivateFields, ref partialResult);
                                break; // from the inner loop
                            }
                        }
                     }
                }
            }
            catch (LivecacheUserThrottledException ex)
            {
                partialResult = true;

                 Logging.TraceException(ex, "{0} > LivecacheUserThrottledException caught in method: GetXboxEntireFriendsList",
                    ComponentName);
            }
            catch (LivecacheResponseException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} > LivecacheResponseException caught in method: GetXboxEntireFriendsList",
                    ComponentName);
            }
            catch (ServiceUnavailableException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} > ServiceUnavailableException caught in method: GetXboxEntireFriendsList",
                   ComponentName);
            }

            return friendsList;
        }

        /// <summary>
        /// Returns a list of Xbox friend's list with data required for leaderboard
        /// </summary>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="partialResult">Whether partial results are added</param>
        /// <returns>array of IReadOnlyFriendInfo</returns>
        private static Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] GetFriendsListForLeaderboard(
            IUserIdentity callerIdentity,
            ref bool partialResult)
        {
            var presenceDataAccess =
                Container.Instance.GetComponent<IPresenceDataAccess>();

            Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] xboxFriendsInfo = null;

            try
            {
                // get all the friends
                // sortAlphabetically is set to false to improve perf and not required for leaderboard
                xboxFriendsInfo = presenceDataAccess.GetFriendsInfo(callerIdentity.Xuid, false, true);
            }
            catch (LivecacheUserThrottledException ex)
            {
                partialResult = true;
                
                 Logging.TraceException(ex, "{0} LivecacheUserThrottledException caught in method: GetXboxFriendsList",
                    ComponentName);
            }
            catch (LivecacheResponseException ex)
            {
                partialResult = true;

               Logging.TraceException(ex, "{0} LivecacheResponseException caught in method: GetXboxFriendsList",
                    ComponentName);
            }
            catch (ServiceUnavailableException ex)
            {
                partialResult = true;

               Logging.TraceException(ex, "{0} ServiceUnavailableException caught in method: GetXboxFriendsList",
                    ComponentName);
            }

            if (xboxFriendsInfo == null)
            {
                return xboxFriendsInfo; // no friends fetched, return the empty list
            }

            // Filter out the friends that don't have any Xuid or GamerTag.
            return FilterFriendsWithoutXuidAndGamerTag(xboxFriendsInfo);
        }

        /// <summary>
        /// Return the profile for a given array of xuids
        /// </summary>
        /// <param name="callingXuid">caller</param>
        /// <param name="friendsInfo">array of xuids</param>
        /// <returns></returns>
        public Leet.Live.Livecache.Logic.Profile.IGamerProfile[] GetProfile(
            ulong callingXuid,
             ulong[] targetXuids)
        {
            // call GetGamerProfilesBySetting to retrieve profile settings        
            uint[] settings = new uint[2];
            settings[1] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_USER_NAME;
            settings[0] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY;
            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();

            // we don't need the gamerTag (false) in this call because it is already in friendsInfo
            Leet.Live.Livecache.Logic.Profile.IGamerProfile[] gamerProfile =
                settingsDataAccess.GetGamerProfilesBySetting(callingXuid, targetXuids, settings, false);

            if (gamerProfile.Length != targetXuids.Length)
            {
                // this really shouldn't happen, I would expect an exception here, let's write to the trace to be safe
                Logging.TraceError("{0} gamerProfile.Length and targetXuids.Length are not equal in GetFriendsListForLeaderboard",
                    ComponentName);
            }

            return gamerProfile;
        }

        /// <summary>
        /// Return the profile for a given array of xuids
        /// </summary>
        /// <param name="callingXuid">caller</param>
        /// <param name="friendsInfo">array of xuids</param>
        /// <returns></returns>
        public static Leet.Live.Livecache.Logic.Profile.IGamerProfile[] GetProfilePartner(
            ulong callingXuid,
             ulong[] targetXuids)
        {
            // call GetGamerProfilesBySetting to retrieve profile settings        
            uint[] settings = new uint[11];
            settings[0] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_USER_NAME; // name
            settings[1] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY; //gamerTileURL, SmallGamerTileURL
            settings[2] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_MOTTO; // motto
            settings[3] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1; // avatar manifest
            settings[4] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_CRED; // gamer score
            settings[5] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_USER_BIO; // bio
            settings[6] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_USER_LOCATION; // location
            settings[7] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMER_TIER; // tier
            settings[8] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_ZONE; // zone
            settings[9] = xonline.common.protocol.ProfileDefs.XPROFILE_GAMERCARD_REP; // reputation
            settings[10] = xonline.common.protocol.ProfileDefs.XPROFILE_PERMISSIONS; // profile permissions

            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();

            // we don't need the gamerTag (false) in this call because it is already in friendsInfo
            Leet.Live.Livecache.Logic.Profile.IGamerProfile[] gamerProfile =
                settingsDataAccess.GetGamerProfilesBySetting(callingXuid, targetXuids, settings, false);

            if (gamerProfile.Length != targetXuids.Length)
            {
                // this really shouldn't happen, I would expect an exception here, let's write to the trace to be safe
                Logging.TraceError("{0} gamerProfile.Length and targetXuids.Length are not equal in GetProfilePartner",
                     ComponentName);
            }

            return gamerProfile;
        }

        /// <summary>
        /// Add profile properites to Profile
        /// </summary>
        /// <param name="profile">Profile to add properties to</param>
        /// <param name="callerXuid">friend's friendInfo</param>
        /// <param name="targetXuid">friend's gamerProfile</param>
        /// <param name="partialResult">Whether to include partial result</param>
        private static void AddProfilePropertiesToProfile(
            UserGameData.DataContracts.Profile profile,
            IReadOnlyFriendInfo friendInfo, // contains the gamertag
            IGamerProfile gamerProfile,
            ref bool partialResult)
        {
            if (profile.ProfileProperties == null)
            {
                profile.ProfileProperties =
                    new XmlSerializableDictionary<ProfileProperty, object>();
            }

            var profileProperties = profile.ProfileProperties;

            if (gamerProfile != null)
            {
                bool hasAvatar = gamerProfile.AvatarManifest != null;

                string avatarUrl =
                    Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.XboxAvatarBodyURL);
                if (!string.IsNullOrEmpty(avatarUrl))
                {
                    avatarUrl = avatarUrl.Replace("{gamertag}", friendInfo.Gamertag);
                }

                profileProperties.Add(ProfileProperty.HasAvatar, hasAvatar);
                profileProperties.Add(ProfileProperty.AvatarImageUrl, avatarUrl);
                profileProperties.Add(ProfileProperty.GamerTag, friendInfo.Gamertag);
                profileProperties.Add(ProfileProperty.GamerScore, gamerProfile.Gamerscore);
                profileProperties.Add(ProfileProperty.Bio, gamerProfile.Bio);
                profileProperties.Add(ProfileProperty.GamerPicUrl, gamerProfile.GamerTileUrl);
                profileProperties.Add(ProfileProperty.SmallGamerPicUrl, gamerProfile.SmallGamerTileUrl);
                profileProperties.Add(ProfileProperty.Location, gamerProfile.Location);
                profileProperties.Add(ProfileProperty.Motto, gamerProfile.Motto);
                profileProperties.Add(ProfileProperty.Name, gamerProfile.Name);
                profileProperties.Add(ProfileProperty.MembershipLevel, gamerProfile.Tier.ToString());
                profileProperties.Add(ProfileProperty.GamerZone, gamerProfile.Zone.ToString());
                profileProperties.Add(ProfileProperty.Reputation, ConvertReputationToFivePointValue(gamerProfile.Reputation));
                profileProperties.Add(ProfileProperty.ShowGamerProfile, gamerProfile.ProfileUserCreatedContentPrivilege);
            }
        }

        /// <summary>
        /// Add profile properites to Profile
        /// </summary>
        /// <param name="profile">Profile to add properties to</param>
        /// <param name="callerXuid">Caller's xuid</param>
        /// <param name="targetXuid">Target's xuid</param>
        /// <param name="partialResult">Whether to include partial result</param>
        private static void AddProfilePropertiesToProfile(
            UserGameData.DataContracts.Profile profile, 
            ulong callerXuid, 
            ulong targetXuid,
            ref bool partialResult)
        {
            if (profile.ProfileProperties == null)
            {
                profile.ProfileProperties =
                    new XmlSerializableDictionary<ProfileProperty, object>();
            }

            var profileProperties = profile.ProfileProperties;

            var settingsDataAccess =
                Container.Instance.GetComponent<ISettingsDataAccess>();

            Live.Livecache.Logic.Profile.IGamerProfile xboxProfile = null;

            try
            {
                if (targetXuid != 0)
                {
                    xboxProfile =
                        settingsDataAccess.GetGamerProfile(
                            callerXuid, targetXuid);
                }
            }
            catch (LivecacheUserThrottledException ex)
            {
                partialResult = true;
                Logging.TraceException(ex, "{0} LivecacheUserThrottledException caught in method: AddProfilePropertiesToProfile",
                     ComponentName);
            }
            catch (LivecacheResponseException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} LivecacheResponseException caught in method: AddProfilePropertiesToProfile",
                    ComponentName);
            }
            catch (ServiceUnavailableException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} ServiceUnavailableException caught in method: AddProfilePropertiesToProfile",
                    ComponentName);
            }
            catch (Exception ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} Exception caught in method: AddProfilePropertiesToProfile",
                    ComponentName);
            }

            if (xboxProfile != null)
            {
                bool hasAvatar = xboxProfile.AvatarManifest != null;

                string avatarUrl = 
                    Container.Instance.GetComponent<IConfigurationProvider>()
                    .GetSetting(Settings.XboxAvatarBodyURL);
                if (!string.IsNullOrEmpty(avatarUrl))
                {
                    avatarUrl = avatarUrl.Replace("{gamertag}", xboxProfile.GamerTag);
                }

                profileProperties.Add(ProfileProperty.GamerTag, xboxProfile.GamerTag);
                profileProperties.Add(ProfileProperty.GamerScore, xboxProfile.Gamerscore);
                profileProperties.Add(ProfileProperty.HasAvatar, hasAvatar);
                profileProperties.Add(ProfileProperty.AvatarImageUrl, avatarUrl);
                profileProperties.Add(ProfileProperty.Bio, xboxProfile.Bio);
                profileProperties.Add(ProfileProperty.GamerPicUrl, xboxProfile.GamerTileUrl);
                profileProperties.Add(ProfileProperty.SmallGamerPicUrl, xboxProfile.SmallGamerTileUrl);
                profileProperties.Add(ProfileProperty.Location, xboxProfile.Location);
                profileProperties.Add(ProfileProperty.Motto, xboxProfile.Motto);
                profileProperties.Add(ProfileProperty.Name, xboxProfile.Name);
                profileProperties.Add(ProfileProperty.MembershipLevel, xboxProfile.Tier.ToString());
                profileProperties.Add(ProfileProperty.GamerZone, xboxProfile.Zone.ToString());
                profileProperties.Add(ProfileProperty.Reputation, ConvertReputationToFivePointValue(xboxProfile.Reputation));
                profileProperties.Add(ProfileProperty.ShowGamerProfile, xboxProfile.ProfileUserCreatedContentPrivilege);
            }
        }

        /// <summary>
        /// Retrieves a list of recently played games
        /// </summary>
        /// <param name="userTitles">Caller's list of userTitles up to MaxRecentGamaes</param>
        /// <param name="callerXuid">Caller's xuid</param>
        /// <param name="targetXuid">Target's xuid</param>
        /// <param name="lcid">Locale of the strings to be returned</param>
        /// <param name="partialResult">Whether to include partial result</param>
        /// <returns>Serializable list of caller's recent games</returns>
        public static XmlSerializableList<GameInfo> GetRecentGames(List<IReadOnlyUserTitle> userTitles, ushort lcid, ref bool partialResult)
        {
            var gmsClient = Container.Instance.GetComponent<IGameMetadataClient>();
            var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
            IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

            var games = new List<GameInfo>();

            if (userTitles == null)
            {
                partialResult = true;
            }
            else
            {
                foreach (Leet.Live.Livecache.Logic.Games.IReadOnlyUserTitle userTitle in userTitles)
                {
                    try
                    {
                        string locale = localeHelper.GetLocale(lcid);
                        GameMetadataComposite gameData = gmsClient.GetGameMetadata(userTitle.TitleId, locale);

                        string imageUrl = TileLocator.Instance.TitleTileUrl(userTitle.TitleId);

                        // set the default gameUrl
                        string gameUrl = String.Format(configProvider.GetSetting(Settings.DefaultGameUrl), locale, userTitle.TitleId);

                        uint gameType = (uint) PlatformBitMask.None;
                        
                        // if game data is available, populate URL, image URL, and type
                        // else use the image URL which we got using userTitle.TitleId
                        if (gameData != null)
                        {
                            gameUrl = gameData.GameRedirectionUrl;
                            if (gameData.Images.ContainsKey(ImageType.GameTile_WebLarge)
                                && String.IsNullOrEmpty(gameData.Images[ImageType.GameTile_WebLarge].ImageUrl) == false)
                            {
                                imageUrl = gameData.Images[ImageType.GameTile_WebLarge].ImageUrl;
                            }
                            gameType = gameData.SupportedPlatformsBitMask;
                        }
                        else
                        {
                           Logging.TraceInformation("{0} GameData returned from GMS is null {1} | {2}",
                                 ComponentName,
                                 userTitle.TitleId, locale);
                        }

                        GameInfo gameInfo = new GameInfo
                        {
                            Id = (int)userTitle.TitleId,
                            Name = userTitle.TitleName,
                            GameUrl = gameUrl,
                            ImageUrl = imageUrl,
                            LastPlayed = userTitle.LastPlayed,
                            AchievementsEarned = userTitle.EarnedAchievements,
                            TotalAchievements = userTitle.TotalAchievements,
                            Type = gameType,
                        };

                        // Add the GameInfo to the RecentGames collection
                        games.Add(gameInfo);
                    }
                    catch (System.Exception ex)
                    {
                        // Write log then contine to the next userTile
                       Logging.TraceException(ex, "{0} Exception caught in method GetRecentGames for title {1}",
                            ComponentName, userTitle.TitleName);

                        continue;
                    }
                }
            }
            
            return new XmlSerializableList<GameInfo>(games);
        }

        /// <summary>
        /// Retrieves a list of recent achievements unlocked; only one achievement is returned currently
        /// </summary>
        /// <param name="userTitles">Caller's list of userTitles up to MaxUserTitlesToFetch</param>
        /// <param name="callerXuid">Caller's xuid</param>
        /// <param name="callerXuid">Caller's xuid</param>
        /// <param name="targetXuid">Target's xuid</param>
        /// <param name="lcid">Locale of strings to be returned</param>
        /// <param name="partialResult">Whether partial results are to be included</param>
        /// <returns>A serializable list of most recent achievement</returns>
        public static XmlSerializableList<Achievement> GetRecentAchievements(List<IReadOnlyUserTitle> userTitles, ulong callerXuid, ulong targetXuid, ushort lcid, ref bool partialResult)
        {
            var provider = Container.Instance.GetComponent<IAchievementDataAccess>();

            var achievements = new XmlSerializableList<Achievement>();

            Achievement recentAchievement = null;
            
            if (null == userTitles)
            {
                partialResult = true;

                Logging.TraceError("{0} Error in method AddProfilePropertiesToProfile.  userTitles is Null", // Code review question: Error or warning?
                    ComponentName);
            }
            else
            {
                foreach (var title in userTitles)
                {
                    if (title.EarnedAchievements <= 0)
                    {
                        continue;
                    }

                    var achievementInfo =
                        provider.GetUserAchievements(title.TitleId, (ulong) callerXuid, (ulong) targetXuid, lcid);

                    if (achievementInfo != null && achievementInfo.Count > 0 && achievementInfo[0].IsUnlocked)
                    {
                        if (recentAchievement == null ||
                            (achievementInfo[0].DateUnlocked > recentAchievement.EarnedDateTime))
                        {
                            recentAchievement = new Achievement
                                                    {
                                                        GameId = title.TitleId,
                                                        Name = achievementInfo[0].Title,
                                                        GameName = title.TitleName,
                                                        EarnedDateTime = achievementInfo[0].DateUnlocked,
                                                        Description = achievementInfo[0].Description,
                                                        Gamerscore = achievementInfo[0].GamerscoreValue,
                                                        DisplayBeforeEarned = !achievementInfo[0].IsHidden,
                                                        EarnedOnline = achievementInfo[0].WasEarnedOnline,
                                                        HowToEarn = achievementInfo[0].HowTo,
                                                        IsEarned = achievementInfo[0].IsUnlocked,
                                                        Key = achievementInfo[0].AchievementId.ToString()
                                                    };
                            if (achievementInfo[0].ImageHref != null)
                            {
                                recentAchievement.PictureUrl = achievementInfo[0].ImageHref.ToString();
                            }
                        }
                    }
                }
            }

            if (recentAchievement != null)
            {
                achievements.Add(recentAchievement);
            }

            return achievements;
        }

        /// <summary>
        /// Converts the 100 pt reputation to a 5 pt value with .25 increments
        /// </summary>
        /// <param name="reputation">Reputation value</param>
        /// <returns>5 point value</returns>
        private static double ConvertReputationToFivePointValue(float reputation)
        {
            return Math.Ceiling(reputation / 5) * 0.25;
        }

        /// <summary>
        /// Adding profile properties to friends list 
        /// </summary>
        /// <param name="friendInfo">Friend's info</param>
        /// <param name="callerIdentity">Friend's gamer profile</param>
        /// <param name="friendsList">Friend's list</param>
        /// <param name="includePrivateFields">Whether to include private fields</param>
        /// <param name="partialResult">Whether to include partial results</param>
        private static void AddXboxFriendProfileToList(
            IReadOnlyFriendInfo friendInfo,
            IGamerProfile gamerProfile,
            ICollection<UserGameData.DataContracts.Profile> friendsList,
            bool includePrivateFields,
            ref bool partialResult)
        {
            if (friendInfo == null || gamerProfile == null)
            {
                Logging.TraceError("{0} Unexpected internal error in ProfileProvider.AddXboxFriendProfileToListPartner() friendInfo == null or gamerProfile == null",
                         ComponentName);

                return; // cannot populate this user's profile
            }

            var friendProfile = new UserGameData.DataContracts.Profile();

            friendProfile.ProfileProperties = new XmlSerializableDictionary<ProfileProperty, object>();

            if (includePrivateFields)
            {
                friendProfile.ProfileProperties.Add(ProfileProperty.Xuid, friendInfo.LivePuid);
            }

            // Populate the properties for the friend
            AddProfilePropertiesToProfile(friendProfile, friendInfo, gamerProfile, ref partialResult);

            friendsList.Add(friendProfile);
        }

        /// <summary>
        /// Adding profile properties to friends list
        /// </summary>
        /// <param name="friendInfo">Friend's info</param>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="friendsList">Friend's list</param>
        /// <param name="includePrivateFields">Whether to include private fields</param>
        /// <param name="partialResult">Whether to include partial results</param>
        private static void AddXboxFriendProfileToList(
            Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo friendInfo,
            IUserIdentity callerIdentity,
            ICollection<UserGameData.DataContracts.Profile> friendsList, 
            bool includePrivateFields,
            ref bool partialResult)
        {
            if (null == friendInfo)
            {
                return;
            }

            // for LSR3 we will return only friends in the state FriendState.Friend
            // friends in other states wouldn't show up on the leaderboard either
            if (friendInfo.FriendState != Leet.Live.Livecache.Logic.Profile.FriendState.Friend)
            {
                return;
            }

            var friendProfile = new UserGameData.DataContracts.Profile();

            friendProfile.ProfileProperties =
                    new XmlSerializableDictionary<ProfileProperty, object>();
            
            try
            {
                if (includePrivateFields)
                {
                    friendProfile.ProfileProperties.Add(ProfileProperty.Xuid, friendInfo.LivePuid);
                }

                // Get the Properties for the friend
                AddProfilePropertiesToProfile(friendProfile, callerIdentity.Xuid, friendInfo.LivePuid, ref partialResult);
            }
            catch (LivecacheUserThrottledException ex)
            {
                partialResult = true;

               Logging.TraceException(ex, "{0} LivecacheUserThrottledException caught in method: AddXboxFriendProfileToList",
                    ComponentName);
            }
            catch (LivecacheResponseException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} LivecacheResponseException caught in method: AddXboxFriendProfileToList",
                  ComponentName);
            }
            catch (ServiceUnavailableException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} ServiceUnavailableException caught in method: AddXboxFriendProfileToList",
                  ComponentName);
            }

            friendsList.Add(friendProfile);
        }

        /// <summary>
        /// Adding contact profile to friends list
        /// </summary>
        /// <param name="contact">Contains contact infor</param>
        /// <param name="callerIdentity">Caller's identity</param>
        /// <param name="friendsList">Friend's list</param>
        /// <param name="includePrivateFields">Whether to include private fields to the profile</param>
        /// <param name="partialResult">Whether partial results are included</param>
        private static void AddContactProfileToList(
            Contact contact, 
            IUserIdentity callerIdentity,
            ICollection<UserGameData.DataContracts.Profile> friendsList, 
            bool includePrivateFields,
            ref bool partialResult)
        {
            if (null == contact)
            {
                return;
            }

            if (null == contact.contactInfo)
            {
                partialResult = true;

               Logging.TraceError("{0} Error in method AddProfilePropertiesToProfile.  contact.contactInfo is Null", ComponentName);

                return;
            }

            if (!contact.contactInfo.isMessengerUser)
            {
                return;
            }

            var profile = new UserGameData.DataContracts.Profile();
            friendsList.Add(profile);

            AddProfilePropertiesToFriendProfile(contact, profile, includePrivateFields, ref partialResult);
        }

        /// <summary>
        /// Adding profile properties to friend profile
        /// </summary>
        /// <param name="contact">Contact info used to get the puid</param>
        /// <param name="profile">Profile to be added properties to</param>
        /// <param name="includePrivateFields">Whether to include private fields to the profile</param>
        /// <param name="partialResult">Whether partial results are included</param>
        private static void AddProfilePropertiesToFriendProfile(
            Contact contact, 
            UserGameData.DataContracts.Profile profile, 
            bool includePrivateFields, 
            ref bool partialResult)
        {
            if (null == contact)
            {
                return;
            }

            if (null == contact.contactInfo)
            {
                partialResult = true;

                Logging.TraceError("{0} Error in method AddProfilePropertiesToProfile.  contact.contactInfo is Null", ComponentName);
                return;
            }

            var xCache = Container.Instance.GetComponent<IXCacheDataAccess>();

            try
            {
                ulong xuid;
                string gamerTag;
                xCache.LookupWebID(
                    (ulong)contact.contactInfo.puid,
                    out xuid,
                    out gamerTag);
                profile.ProfileProperties =
                    new XmlSerializableDictionary<ProfileProperty, object>
                        {
                            {
                                ProfileProperty.GamerTag, 
                                gamerTag
                            }
                        };
                if (includePrivateFields)
                {
                    profile.ProfileProperties.Add(ProfileProperty.Xuid, xuid);
                }
            }
            catch (LivecacheUserThrottledException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} LivecacheUserThrottledException caught in method: AddProfilePropertiesToFriendProfile", ComponentName);
            }
            catch (LivecacheResponseException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} LivecacheResponseException caught in method: AddProfilePropertiesToFriendProfile", ComponentName);

            }
            catch (ServiceUnavailableException ex)
            {
                partialResult = true;

                Logging.TraceException(ex, "{0} ServiceUnavailableException caught in method: AddProfilePropertiesToFriendProfile", ComponentName);
            }
        }

        /// <summary>
        /// Determines if the specified bit is set in the provided bitmap
        /// </summary>
        /// <param name="bitMap">Selects which section to be included</param>
        /// <param name="section">Profile section</param>
        /// <returns>Whether to flag is set</returns>
        private static bool FlagIsSet(long bitMap, ProfileSections section)
        {
            bool flagIsSet =
                (bitMap & ((long)section)) != 0;

            return flagIsSet;
        }

        /// <summary>
        /// Checks if the caller's identity is authenticated
        /// </summary>
        /// <param name="callerIdentity">Caller's identity</param>
        private static void CheckIIdentityManagerValidity(IUserIdentity callerIdentity)
        {
            if ((null == callerIdentity) || (!callerIdentity.IsAuthenticated))
            {
                throw new AuthenticationException("Unable to authenticate calling user");
            }
        }

        /// <summary>
        /// Returns the friends with non-empty gamerTag and a valid xuid
        /// </summary>
        /// <param name="friendInfo">array of friends</param>
        /// <returns>Returns an array of IReadOnlyFriendInfo, could be null if we cannot find an item with the match</returns>
        private static Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] FilterFriendsWithoutXuidAndGamerTag(Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] friendInfo)
        {
            int estimatedSize = friendInfo.Length / 2; // assume half of the friends played the game (wild guess, but better than starting with empty capacity)
            ArrayList arrayList = new ArrayList(estimatedSize);

            // for LSR3 we care about friends in the state FriendState.Friend
            // they wouldn't show up on the leaderboard either
            for (int index = 0; index < friendInfo.Length; index++)
            {
                if (String.IsNullOrEmpty(friendInfo[index].Gamertag) == false && friendInfo[index].LivePuid > 0
                    && friendInfo[index].FriendState == Leet.Live.Livecache.Logic.Profile.FriendState.Friend)
                {
                    arrayList.Add(friendInfo[index]);
                }
            }

            if (arrayList.Count > 0)
            {
                Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] returnedFriendInfo =
                    new Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[arrayList.Count];
                arrayList.CopyTo(returnedFriendInfo);
                return returnedFriendInfo;
            }
            else
            {
                return null;
            }
        }

        #endregion Private Members
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\Identity.cs ===
﻿
namespace Leet.Profile
{
    using Leet.Core.IoCCo;
    using Leet.Live.Livecache.DataAccess;

    /// <summary>
    /// This class encapsulates a user's identity (XUID, PUID, and CID). It loads up the 
    /// various elements of this identity in a lazy fashion (as this requires service calls 
    /// in most cases). 
    /// </summary>
    /// <remarks>
    /// One could make the case that this should live in Leet.Identity, but that would make 
    /// Leet.Identity dependent upon ABCH and LiveCache. Therefore it was decided that this 
    /// class be placed in Leet.Profile (which already has these dependencies and is the
    /// assembly using this functionality in the first place) and be marked internal so that
    /// it didn't get used elsewhere by mistake.
    /// </remarks>
    public class Identity
    {
        private bool xuidInitialized = false;
        private bool puidInitialized = false;
        private bool cidInitialized = false;

        private ulong xuid;
        public ulong Xuid
        {
            get
            {
                if (!this.xuidInitialized) // Use PUID to find XUID
                {
                    this.xuidInitialized = true;

                    var provider = 
                        Container.Instance.GetComponent<IXCacheDataAccess>();

                    string dummy;

                    // Use the property this.Puid and not the underlying field this.puid, 
                    // because this.puid may not be initialized itself. The property
                    // will initialize it if necessary
                    provider.LookupWebID((ulong)this.Puid, out this.xuid, out dummy);
                }

                return this.xuid;
            }
        }

        private long puid;
        public long Puid
        {
            get
            {
                if (!this.puidInitialized) // Use CID or XUID (in that order) to find PUID
                {
                    // If CID is available, use ABCH to map the CID to a PUID. We
                    // have to do this as there is no algorithmic mechanism to do
                    // this, and as far as we know, there is no service that will
                    // do this mapping for us. So we have to use ABCH, as non-ideal
                    // as that is.
                    if (this.cidInitialized) 
                    {
                        var provider = 
                            Container.Instance.GetComponent<IAbchContactsProvider>();

                        this.puid = provider.FindPuid(this.cid);
                    }

                    this.puidInitialized = (this.puid != 0);
                }

                return this.puid;
            }
        }

        private long cid;
        public long Cid
        {
            get
            {
                if (!this.cidInitialized) // Use PUID to find CID
                {
                    // We have to use ABCH to go from PUID to CID as there is no 
                    // algorithmic mechanism to do this that uses data we have access 
                    // to, and as far as we know, there is no service that will
                    // do this mapping for us. So we have to use ABCH, as non-ideal
                    // as that is.
                    var provider =
                            Container.Instance.GetComponent<IAbchContactsProvider>();

                    // Use the property this.Puid and not the underlying field this.puid, 
                    // because this.puid may not be initialized itself. The property
                    // will initialize it if necessary
                    this.cid = provider.FindCid(this.Puid);

                    this.cidInitialized = (this.cid != 0);
                }

                return this.cid;
            }
        }

        public Identity(ulong xuid, long puid, long cid)
        {
            this.xuid = xuid;
            this.xuidInitialized = (this.xuid != 0);

            this.puid = puid;
            this.puidInitialized = (this.puid != 0);
            
            this.cid = cid;
            this.cidInitialized = (this.cid != 0);
        }

        public Identity(string gamertag)
        {
            var xCache = Container.Instance.GetComponent<IXCacheDataAccess>();

            xCache.GetPuidByGamerTag(gamertag, out this.xuid);
            this.xuidInitialized = true;

            // Use default values for PUID and CID
            this.puid = 0;
            this.cid = 0;
        }

        public Identity(long cid)
        {
            this.cid = cid;
            this.cidInitialized = (this.cid != 0);

            // Use default values for XUID and PUID
            this.xuid = 0;
            this.puid = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Profile")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3038ef85-d06d-4c15-88f2-d1b0cf09590e")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile.Test\CloudDirectoryAdapterTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using Leet.Core.Configuration;
using Leet.Profile.Proxies;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;

namespace Leet.Profile.Test
{
    /// <summary>
    /// Summary description for CloudDirectoryProfileProviderTest
    /// </summary>
    [TestClass]
    public class CloudDirectoryAdapterTest
    {
        private IConfigurationProvider configProvider;
        private ICloudDirectoryProfileProvider profileProvider;
        private bool dummy = false;

        [TestInitialize]
        public void Initialize()
        {
            var stubber = new Stubber();
            this.configProvider =
                stubber.RegisterWithContainer<IConfigurationProvider>();
            this.profileProvider =
                stubber.RegisterWithContainer<ICloudDirectoryProfileProvider>();
        }

        #region GetProfile Tests

        [TestMethod]
        public void GetProfileReturnsValidResultWithValidInput()
        {
            // Arrange
            this.configProvider.Stub(cp => cp.GetSetting(Settings.CloudDirectoryProfileApplicationId))
                .Return(Guid.Empty.ToString());
            this.profileProvider.Stub(pp => pp.Get(null, null, null))
                .IgnoreArguments()
                .Return(CreateGetProfileResponse());

            // Act
            var adapter = new CloudDirectoryAdapter();
            var profile = adapter.GetProfile(100, 100, 200, ref dummy);

            // Assert
            Assert.IsNotNull(profile);
        }

        [TestMethod]
        public void GetProfileReturnsExpectedResultWithValidInput()
        {
            // Arrange
            var partialResult = false;
            this.configProvider.Stub(cp => cp.GetSetting(Settings.CloudDirectoryProfileApplicationId))
                .Return(Guid.Empty.ToString());
            this.profileProvider.Stub(pp => pp.Get(null, null, null))
                .IgnoreArguments()
                .Return(CreateGetProfileResponse());

            // Act
            var adapter = new CloudDirectoryAdapter();
            var profile = adapter.GetProfile(100, 100, 200, ref partialResult);
            
            // Assert
            Assert.IsNotNull(profile);
            Assert.AreEqual("TestDisplayName TestDisplayLastName", profile.DisplayName);
            Assert.AreEqual(new Uri("http://testtileurl.com"), profile.DisplayPictureUri);
            Assert.IsFalse(partialResult);
        }

        [TestMethod]
        public void GetProfilePropagatesProfileProviderException()
        {
            // Arrange
            this.configProvider.Stub(cp => cp.GetSetting(Settings.CloudDirectoryProfileApplicationId))
                .Return(Guid.Empty.ToString());
            this.profileProvider.Stub(pp => pp.Get(null, null, null))
                .IgnoreArguments()
                .Throw(new WebException(""));

            // Act / Assert
            var adapter = new CloudDirectoryAdapter();
            AssertException.Expect<WebException>(
                () => adapter.GetProfile(100, 100, 200, ref this.dummy));
        }
        
        [TestMethod]
        public void GetProfileThrowsWhenProfileProviderReturnsErrors()
        {
            // Arrange
            this.configProvider.Stub(cp => cp.GetSetting(Settings.CloudDirectoryProfileApplicationId))
                .Return(Guid.Empty.ToString());
            this.profileProvider.Stub(pp => pp.Get(null, null, null))
                .IgnoreArguments()
                .Return(CreateGetProfileErrorResponse());

            // Act / Assert
            var adapter = new CloudDirectoryAdapter();
            var profile =
                adapter.GetProfile(100, 100, 200, ref this.dummy);
            
            // Assert
            Assert.IsNull(profile);
        }

        [TestMethod]
        public void GetProfileReturnsPartialResultWhenSuppliedWithIncompleteResults()
        {
            // Arrange
            var partialResult = false;
            this.configProvider.Stub(cp => cp.GetSetting(Settings.CloudDirectoryProfileApplicationId))
                .Return(Guid.Empty.ToString());
            this.profileProvider.Stub(pp => pp.Get(null, null, null))
                .IgnoreArguments()
                .Return(CreateGetProfilePartialResponse());

            // Act
            var adapter = new CloudDirectoryAdapter();
            var profile = adapter.GetProfile(100, 100, 200, ref partialResult);

            // Assert
            Assert.IsNotNull(profile);
            Assert.AreEqual("", profile.DisplayName);
            Assert.IsTrue(partialResult);
        }

        [TestMethod]
        public void GetProfileUsesDefaultPicUrlWhenNotSuppliedWithIt()
        {
            // Arrange
            this.configProvider.Stub(cp => cp.GetSetting(Settings.CloudDirectoryProfileApplicationId))
                .Return(Guid.Empty.ToString());
            this.configProvider.Stub(cp => cp.GetSetting(Settings.DefaultProfilePicUrl))
                .Return("http://DefaultPicUrl");
            this.profileProvider.Stub(pp => pp.Get(null, null, null))
                .IgnoreArguments()
                .Return(CreateGetProfilePartialResponse_NoPicUrl());

            // Act
            var adapter = new CloudDirectoryAdapter();
            var profile = adapter.GetProfile(100, 100, 200, ref dummy);

            // Assert
            Assert.IsNotNull(profile);
            Assert.AreEqual(new Uri("http://DefaultPicUrl"), profile.DisplayPictureUri);
        }

        #endregion GetProfile Tests

        #region GetProfiles Tests

        [TestMethod]
        public void GetProfilesReturnsExpectedResultWithValidInput()
        {
            // Arrange
            IList<long> cids = new List<long> { 123456789, 987654321, 19283746 };
            this.configProvider.Stub(cp => cp.GetSetting(Settings.CloudDirectoryProfileApplicationId))
                .Return(Guid.Empty.ToString());
            this.profileProvider.Stub(pp => pp.GetMany(null, null, null))
                .IgnoreArguments()
                .Return(CreateGetProfilesResponse(cids));

            // Act
            var adapter = new CloudDirectoryAdapter();
            var profiles = adapter.GetProfiles(100, 100, cids, ref dummy);

            // Assert
            Assert.IsNotNull(profiles);
            Assert.AreEqual(3, profiles.Count);
        }

        
        [TestMethod]
        public void GetProfilesReturnsNullWhenProfileProviderReturnsErrors()
        {
            // Arrange
            IList<long> cids = new List<long> { 123456789, 987654321, 19283746 };
            this.configProvider.Stub(cp => cp.GetSetting(Settings.CloudDirectoryProfileApplicationId))
                .Return(Guid.Empty.ToString());
            this.profileProvider.Stub(pp => pp.GetMany(null, null, null))
                .IgnoreArguments()
                .Return(CreateGetProfilesErrorResponse(cids));

            // Act
            var adapter = new CloudDirectoryAdapter();
            var profiles =
                adapter.GetProfiles(100, 100, cids, ref this.dummy);

            // Assert
            Assert.IsNull(profiles);
        }
        
        #endregion GetProfile Tests

        #region Private Methods

        private static GetProfileResponse CreateGetProfileResponse()
        {
            return new GetProfileResponse
            {
                Id = CreateProfileId("123456789"),
                View = CreateView("")
            };
        }

        private static GetProfileResponse CreateGetProfileErrorResponse()
        {
            var response = CreateGetProfileResponse();
            response.Errors = new[] { new ErrorInfo() };

            return response;
        }

        private static GetProfileResponse CreateGetProfilePartialResponse()
        {
            var attributes =
                new[]
                        {
                            new A {N = "UserTileStaticUrl", V = "http://testtileurl.com"}
                        };
            var response = CreateGetProfileResponse();
            response.View.Attributes = attributes;

            return response;
        }

        private static GetProfileResponse CreateGetProfilePartialResponse_NoPicUrl()
        {
            var attributes =
                new[]
                        {
                            new A {N = "PublicProfile.DisplayName", V = "TestDisplayName"}
                        };
            var response = CreateGetProfileResponse();
            response.View.Attributes = attributes;

            return response;
        }

        private static GetProfilesResponse CreateGetProfilesResponse(IEnumerable<long> ids)
        {
            var profileIds = ids.Select(
                id => CreateProfileId(id.ToString())).ToArray();
            var views = ids.Select(
                id => CreateView(id.ToString())).ToArray();

            return new GetProfilesResponse
            {
                Ids = profileIds,
                Views = views
            };
        }

        private static GetProfilesResponse CreateGetProfilesErrorResponse(IEnumerable<long> ids)
        {
            var response = CreateGetProfilesResponse(ids);
            response.Errors = new[] { new ErrorInfo() };

            return response;
        }

        private static ProfileId CreateProfileId(string id)
        {
            return new ProfileId
            {
                Ns1 = IdNamespace.Cid,
                V1 = Int64.Parse(id)
            };
        }

        private static View CreateView(string id)
        {
            var attributes =
                new[]
                        {
                            new A {N = "PublicProfile.DisplayName", V = id + "TestDisplayName"},
                            new A {N = "PublicProfile.DisplayLastName", V = "TestDisplayLastName"},
                            new A {N = "UserTileStaticUrl", V = "http://testtileurl.com"}
                        };

            return new View
            {
                Attributes = attributes
            };
        }
        
        #endregion Private Methods
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile.Test\SerializableTests.cs ===
﻿using System.Collections.Generic;
using System.IO;
using System.Xml.Serialization;
using Leet.UserGameData.DataContracts;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Profile.Test
{
    /// <summary>
    /// Summary description for SerializableTests
    /// </summary>
    [TestClass]
    public class SerializableTests
    {

        [TestMethod]
        public void GetSchemaXmlDictionary()
        {
            IXmlSerializable serializable = new XmlSerializableDictionary<object, object>();

            Assert.IsNull(serializable.GetSchema());
        }

        [TestMethod]
        public void GetSchemaXmlList()
        {
            IXmlSerializable serializable = new XmlSerializableList<object>();

            Assert.IsNull(serializable.GetSchema());
        }

        [TestMethod]
        public void XmlSerializableListConstructor()
        {
            List<string> list = new List<string>();

            list.Add("one");
            list.Add("two");
            list.Add("three");

            XmlSerializableList<string> xmlList = new XmlSerializableList<string>(list);

            // Assert
            Assert.AreEqual(list.Count, xmlList.Count, "list and xmlList have the same count");

            foreach(string element in list)
            {
                Assert.IsTrue(xmlList.Contains(element), string.Format("xmlList contians element {0}", element));
            }
        }



        [TestMethod]
        public void XmlDictionarySerialization()
        {
            XmlSerializableDictionary<ProfileProperty, object> dictionary1 = new XmlSerializableDictionary<ProfileProperty, object>();
            XmlSerializableDictionary<ProfileProperty, object> dictionary2 = new XmlSerializableDictionary<ProfileProperty, object>();

            dictionary1.Add(ProfileProperty.GamerPicUrl, "http://someurl.com");
            dictionary1.Add(ProfileProperty.GamerScore, 1234567);

            System.Text.StringBuilder stringBuilder = new System.Text.StringBuilder();

            // Serialize dictionary1
            using (TextWriter stringWriter = new StringWriter(stringBuilder))
            {
                System.Xml.XmlTextWriter writer = new System.Xml.XmlTextWriter(stringWriter);
                ((IXmlSerializable)dictionary1).WriteXml(writer);
            }

            // Deserialize to dictionary2
            using (TextReader stringReader = new StringReader(stringBuilder.ToString()))
            {
                System.Xml.XmlTextReader reader = new System.Xml.XmlTextReader(stringReader);
                ((IXmlSerializable)dictionary2).ReadXml(reader);
            }

            // Verify dictionary1 and dictionary2 have the same values
            Assert.AreEqual(dictionary1[ProfileProperty.GamerPicUrl], dictionary2[ProfileProperty.GamerPicUrl], "Key/Value match after serialization");
            Assert.AreEqual(dictionary1[ProfileProperty.GamerScore], dictionary2[ProfileProperty.GamerScore], "Key/Value match after serialization");
        }

        [TestMethod]
        public void XmlListSerialization()
        {
            // Create two lists
            XmlSerializableList<string> list1 = new XmlSerializableList<string>();
            XmlSerializableList<string> list2 = new XmlSerializableList<string>();

            list1.Add("one");
            list1.Add("two");
            list1.Add("three");

            System.Text.StringBuilder stringBuilder = new System.Text.StringBuilder();

            // Serialize list1
            using (TextWriter stringWriter = new StringWriter(stringBuilder))
            {
                System.Xml.XmlTextWriter writer = new System.Xml.XmlTextWriter(stringWriter);
                ((IXmlSerializable)list1).WriteXml(writer);
            }

            // Deserialize to list2
            using (TextReader stringReader = new StringReader(stringBuilder.ToString()))
            {
                System.Xml.XmlTextReader reader = new System.Xml.XmlTextReader(stringReader);
                ((IXmlSerializable)list2).ReadXml(reader);
            }

            // Assert
            Assert.AreEqual(list1.Count, list2.Count, "list1 and list2 have the same count");

            foreach (string element in list1)
            {
                Assert.IsTrue(list2.Contains(element), string.Format("Element {0} found", element));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile.Test\ProfileProviderTest.cs ===
﻿namespace Leet.Profile.Test
{
    using System;
    using System.Collections.Generic;
    using System.Security.Authentication;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Identity;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Achievements;
    using Leet.Live.Livecache.Logic.Games;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Profile.Proxies;
    using Leet.TestUtilities;
    using Leet.UserGameData.DataContracts;
    using Leet.Utils;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Rhino.Mocks;

    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class ProfileProviderTest
    {
        public class FakeXCache : IXCacheDataAccess
        {
            public bool GetGamertagByPuid(ulong livePuid, out string gamertag)
            {
                gamertag = "TestGamertag";

                return true;
            }

            public bool GetOfficialGamerTag(string gamertag, out ulong livePuid, out string officialGamertag)
            {
                livePuid = 10;
                officialGamertag = "TestOfficialGamertag";

                return true;
            }

            public bool GetPuidByGamerTag(string gamertag, out ulong livePuid)
            {
                livePuid = 10;

                return true;
            }

            public bool LookupWebID(ulong passportPuid, out ulong livePuid, out string gamertag)
            {
                livePuid = 10;
                gamertag = "TestGamertag";

                return true;
            }
        }

        private IUserIdentity callerIdentity;
        private IWindowsLiveProfileProvider wlProvider;
        private IAbchContactsProvider abchProvider;
        private ISettingsDataAccess settingsDataAccess;
        private IPresenceDataAccess presenceDataAccess;
        private IAchievementDataAccess achievementProvider;
        private IGamerProfile gamerProfile;
        private TestFriendInfo[] friendsInfo;
        private IConfigurationProvider configProvider;
        private List<IReadOnlyUserTitle> userTitles;
        private IReadOnlyUserTitle userTitle1;
        private IReadOnlyUserTitle userTitle2;
        private List<IReadOnlyAchievementInfo> achievements;
        private IReadOnlyAchievementInfo achievement;
        private ProfileProvider provider;
        private GameMetadataComposite gameMetadataComposite; 
        private bool partialResult;
        private Identity targetIdentity;
        private long callerCid;
        private long callerPuid;
        private Random rand;
        private bool dummyBool;
        private CloudDirectoryProfileData cdpData;
        private long sectionFlags;
        private string locale;
        private IReadOnlyFriendInfo[] friendsInfoList;

        [TestInitialize()]
        public void Initialize()
        {
            // Initialize values
            rand = new Random();
            this.partialResult = false;
            this.dummyBool = false;

            // Create generated objects
            this.callerCid = this.rand.Next();
            this.callerPuid = this.rand.Next();
            this.sectionFlags = 29;
            this.locale = "en-US";
            this.cdpData = new CloudDirectoryProfileData(
                "TestDisplayName", new Uri("http://testdisplayimageurl.com"));

            this.gameMetadataComposite =
                new GameMetadataComposite
                    {
                        GameRedirectionUrl = "http://redirection.com",
                        GameAndVariantName = "GameName",
                        GameId = 0,
                        GameName = "GameName",
                    };
           
            // Create stubs
            var stubber = new Stubber();
            this.wlProvider =
                stubber.RegisterWithContainer<IWindowsLiveProfileProvider>();
            this.abchProvider =
                stubber.RegisterWithContainer<IAbchContactsProvider>();
            this.settingsDataAccess =
                stubber.RegisterWithContainer<ISettingsDataAccess>();
            this.presenceDataAccess =
                stubber.RegisterWithContainer<IPresenceDataAccess>();
            this.achievementProvider =
                stubber.RegisterWithContainer<IAchievementDataAccess>();
            this.configProvider =
                stubber.RegisterWithContainer<IConfigurationProvider>();
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IXCacheDataAccess, FakeXCache>();

            this.callerIdentity =
                MockRepository.GenerateStub<IUserIdentity>();
            this.gamerProfile =
                MockRepository.GenerateStub<IGamerProfile>();
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            this.friendsInfo =
                new TestFriendInfo[] { new TestFriendInfo((ulong)this.rand.Next()) };


            this.userTitle1 =
                MockRepository.GenerateStub<IReadOnlyUserTitle>();
            this.userTitle2 =
                MockRepository.GenerateStub<IReadOnlyUserTitle>();
            this.userTitles = new List<IReadOnlyUserTitle>
                                  {
                                      this.userTitle1,
                                      this.userTitle2
                                  };

            this.achievement =
                MockRepository.GenerateStub<IReadOnlyAchievementInfo>();
            this.achievements = new List<IReadOnlyAchievementInfo>
                                    {
                                        this.achievement
                                    };

            this.provider = new ProfileProvider();
        }

        #region GetProfile Tests

        [TestMethod()]
        public void GetProfileReturnsValidProfile()
        {
            // Arrange
            StubSuccessfulAuthCalls();
            this.wlProvider.Stub(wlp => wlp.GetProfile(0, 0, 0, ref this.dummyBool))
                .IgnoreArguments()
                .Return(this.cdpData);

            // Act
            var profile =
                this.provider.GetProfile(this.callerIdentity, this.locale, this.sectionFlags, out friendsInfoList,
                out partialResult);

            // Assert
            Assert.IsNotNull(profile);
        }

        [TestMethod()]
        public void GetProfileReturnsValidProfile_GamertagOverload()
        {
            // Arrange
            StubSuccessfulAuthCalls();
            this.wlProvider.Stub(wlp => wlp.GetProfile(0, 0, 0, ref this.dummyBool))
                .IgnoreArguments()
                .Return(this.cdpData);

            // Act
            var profile =
                this.provider.GetProfile(this.callerIdentity, string.Empty, this.locale, this.sectionFlags,
                out friendsInfoList, out partialResult, out targetIdentity);

            // Assert
            Assert.IsNotNull(profile);
        }


        [TestMethod()]
        public void GetProfileReturnsValidProfile_CidOverload()
        {
            // Arrange
            StubSuccessfulAuthCalls();
            this.wlProvider.Stub(wlp => wlp.GetProfile(0, 0, 0, ref this.dummyBool))
                .IgnoreArguments()
                .Return(this.cdpData);

            // Act
            var profile =
                this.provider.GetProfile(this.callerIdentity, 123, this.locale, this.sectionFlags, out friendsInfoList,
                out partialResult);

            // Assert
            Assert.IsNotNull(profile);
        }

        [TestMethod()]
        public void GetProfileThrowsIfCallerNotAuthenticated()
        {
            // Arrange
            this.callerIdentity.IsAuthenticated = false;

            // Act / Assert
            AssertException.Expect<AuthenticationException>(
                () => this.provider.GetProfile(this.callerIdentity, this.locale, this.sectionFlags, out friendsInfoList,
                    out partialResult));
        }

        [TestMethod()]
        public void GetProfileThrowsIfCallerNotAuthenticated_GamertagOverload()
        {
            // Arrange
            this.callerIdentity.IsAuthenticated = false;

            // Act / Assert
            AssertException.Expect<AuthenticationException>(
                () => this.provider.GetProfile(this.callerIdentity, string.Empty, this.locale, this.sectionFlags, out friendsInfoList,
                    out partialResult, out targetIdentity));
        }

        [TestMethod()]
        public void GetProfileThrowsIfCallerNotAuthenticated_CidOverload()
        {
            // Arrange
            this.callerIdentity.IsAuthenticated = false;

            // Act / Assert
            AssertException.Expect<AuthenticationException>(
                () => this.provider.GetProfile(this.callerIdentity, 123, this.locale, this.sectionFlags, out friendsInfoList,
                    out partialResult));
        }

        [TestMethod()]
        public void GetProfileReturnsExpectedProfileValues()
        {
            // Arrange
            ArrangeForGetProfileReturnsExpectedProfileValues();

            // Act
            var profile =
                this.provider.GetProfile(this.callerIdentity, this.locale, this.sectionFlags, out friendsInfoList,
                out partialResult);

            // Assert
            AssertForGetProfileReturnsExpectedProfileValues(profile);
        }

        [TestMethod()]
        public void GetProfileReturnsExpectedProfileValues_GamertagOverload()
        {
            // Arrange
            ArrangeForGetProfileReturnsExpectedProfileValues();

            // Act
            var profile =
                this.provider.GetProfile(this.callerIdentity, "MyGamerTag", this.locale, this.sectionFlags, out friendsInfoList,
                out partialResult, out targetIdentity);

            // Assert
            AssertForGetProfileReturnsExpectedProfileValues(profile);
        }
        [TestMethod()]
        public void GetProfileReturnsExpectedProfileValues_CidOverload()
        {
            // Arrange
            ArrangeForGetProfileReturnsExpectedProfileValues();

            // Act
            var profile =
                this.provider.GetProfile(this.callerIdentity, 123, this.locale, this.sectionFlags, out friendsInfoList,
                out partialResult);

            // Assert
            AssertForGetProfileReturnsExpectedProfileValues(profile);
        }

        #endregion GetProfile Tests

        #region Other Tests

        [TestMethod()]
        public void GetFriendsReturnsValidXboxFriendsProfileList()
        {
            string gamerTag = "MyGamerTag";
            int gamerScore = 500;

            // Arrange
            this.settingsDataAccess.Stub(sda => sda.GetGamerProfile(0, 0))
                .IgnoreArguments()
                .Return(this.gamerProfile);
            this.gamerProfile.GamerTag = gamerTag;
            this.gamerProfile.Gamerscore = gamerScore;
            this.gamerProfile.GamerTileUrl = "http://www.blah.com";
            this.presenceDataAccess.Stub(pda => pda.GetFriendsInfo(0, true, true))
                .IgnoreArguments()
                .Return(this.friendsInfo);

            // Act
            var profiles =
                this.provider.GetFriends(this.callerIdentity, Network.XboxLive, out friendsInfoList, out partialResult);

            // Assert
            Assert.IsNotNull(profiles);
            Assert.IsTrue(profiles.Count == 1);

            foreach (UserGameData.DataContracts.Profile profile in profiles)
            {
                Assert.AreEqual(gamerTag, profile.ProfileProperties[ProfileProperty.GamerTag]);
                Assert.AreEqual(gamerScore, profile.ProfileProperties[ProfileProperty.GamerScore]);
            }
        }


        #endregion Other Tests

        private void AssertForGetProfileReturnsExpectedProfileValues(UserGameData.DataContracts.Profile profile)
        {
            Assert.IsNotNull(profile);

            Assert.AreEqual(this.sectionFlags, profile.SectionFlags);
            Assert.AreEqual(1, profile.Friends.Count);
            Assert.AreEqual("MyGamerTag", profile.ProfileProperties[ProfileProperty.GamerTag]);
            Assert.AreEqual(
                "http://avatar.xboxlive.com/avatar/MyGamerTag/avatar-body.png",
                profile.ProfileProperties[ProfileProperty.AvatarImageUrl]);
            Assert.AreEqual(500, profile.ProfileProperties[ProfileProperty.GamerScore]);
            Assert.AreEqual("http://www.blah.com", profile.ProfileProperties[ProfileProperty.GamerPicUrl]);
            Assert.AreEqual("http://www.smallblah.com", profile.ProfileProperties[ProfileProperty.SmallGamerPicUrl]);
            Assert.AreEqual(1234, profile.RecentGames[0].Id);
            Assert.AreEqual("http://tiles.xbox.com/tiles/-6/cE/0mdsb2JhbC9ECgR8HR9GY29uLzAvODAwMAAAAAAAAAD9K6fl.jpg", profile.RecentGames[0].ImageUrl);
            Assert.AreEqual("http://tiles.xbox.com/tiles/lg/zm/02dsb2JhbC9ECgEIagEAB2Nvbi8wLzgwMDAAAAAAAAAA-MkMjQ==.jpg", profile.RecentGames[1].ImageUrl);
            Assert.AreEqual(4321, profile.RecentGames[1].Id);
            Assert.AreEqual("Successful test!", profile.RecentAchievements[0].Name);
        }

        private void ArrangeForGetProfileReturnsExpectedProfileValues()
        {
            this.sectionFlags = 29;
            StubSuccessfulAuthCalls();
            this.wlProvider.Stub(wlp => wlp.GetProfile(0, 0, 0, ref this.dummyBool))
                .IgnoreArguments()
                .Return(this.cdpData);
            this.settingsDataAccess.Stub(sda => sda.GetGamerProfile(0, 0))
                .IgnoreArguments()
                .Return(this.gamerProfile);
            this.configProvider.Stub(cp => cp.GetSetting(Settings.XboxAvatarBodyURL))
                .Return("http://avatar.xboxlive.com/avatar/{gamertag}/avatar-body.png");
            this.configProvider.Stub(cp => cp.GetSetting(Settings.TilesDomainName)).Return("tiles.xbox.com");
            this.gamerProfile.GamerTag = "MyGamerTag";
            this.gamerProfile.Gamerscore = 500;
            this.gamerProfile.GamerTileUrl = "http://www.blah.com";
            this.gamerProfile.SmallGamerTileUrl = "http://www.smallblah.com";
            this.presenceDataAccess.Stub(pda => pda.GetFriendsOfFriend(0, 0))
                .IgnoreArguments()
                .Return(this.friendsInfo);
            this.achievementProvider.Stub(ap => ap.GetUserTitles(0, 0, 0, 0, 0))
                .IgnoreArguments()
                .Return(this.userTitles);
            this.userTitle1.Stub(ut => ut.TitleId)
                .Return(1234);
            this.userTitle2.Stub(ut => ut.TitleId)
                .Return(4321);
            this.userTitle2.Stub(ut => ut.EarnedAchievements)
                .Return(1);
            this.achievementProvider.Stub(ap => ap.GetUserAchievements(0, 0, 0, 0))
                .IgnoreArguments()
                .Return(this.achievements);
            this.achievement.Stub(a => a.IsUnlocked)
                .Return(true);
            this.achievement.Stub(a => a.Title)
                .Return("Successful test!");
        }

        private void StubSuccessfulAuthCalls()
        {
            this.callerIdentity.IsAuthenticated = true;
            this.callerIdentity.Cid = this.callerCid;
            this.callerIdentity.Puid = this.callerPuid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile.Test\TestFriendInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.Logic.Profile;

namespace Leet.Profile.Test
{
    public class TestFriendInfo : IReadOnlyFriendInfo
    {
        // FriendInfo members
        public FriendState FriendState { get; set; }
        public string Gamertag { get; set; }
        public ulong LivePuid { get; set; }

        // PresenceInfo members
        string IReadOnlyPresenceInfo.Gamertag 
        { 
            get { return this.Gamertag; }
        }
        ulong IReadOnlyPresenceInfo.LivePuid 
        {
            get { return this.LivePuid; }
        }
        public OnlineState State { get; set; }
        public bool IsOnline { get; set; }
        public bool IsJoinable { get; set; }
        public bool IsPlaying { get; set; }
        public DateTime LastSeen { get; set; }
        public uint TitleId { get; set; }
        public string PresenceString { get; set; }


        public TestFriendInfo(ulong LivePuid)
        {
            this.LivePuid = LivePuid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\Proxies\CloudDirectoryProfileService.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4918
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.3038.
// 
namespace Leet.Profile.Proxies
{

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "ProfileServiceSoap", Namespace = "http://profile.live.com/")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(AttributeEnumValue))]
    public partial class CloudDirectoryProfileService : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        private SOAPApplicationHeader sOAPApplicationHeaderValueField;

        private SOAPUserHeader sOAPUserHeaderValueField;

        private System.Threading.SendOrPostCallback GetOperationCompleted;

        private System.Threading.SendOrPostCallback GetManyOperationCompleted;

        private System.Threading.SendOrPostCallback SetOperationCompleted;

        private System.Threading.SendOrPostCallback BatchOperationCompleted;

        /// <remarks/>
        public CloudDirectoryProfileService()
        {
        }

        public SOAPApplicationHeader SOAPApplicationHeaderValue
        {
            get
            {
                return this.sOAPApplicationHeaderValueField;
            }
            set
            {
                this.sOAPApplicationHeaderValueField = value;
            }
        }

        public SOAPUserHeader SOAPUserHeaderValue
        {
            get
            {
                return this.sOAPUserHeaderValueField;
            }
            set
            {
                this.sOAPUserHeaderValueField = value;
            }
        }

        /// <remarks/>
        public event GetCompletedEventHandler GetCompleted;

        /// <remarks/>
        public event GetManyCompletedEventHandler GetManyCompleted;

        /// <remarks/>
        public event SetCompletedEventHandler SetCompleted;

        /// <remarks/>
        public event BatchCompletedEventHandler BatchCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("SOAPApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("SOAPUserHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://profile.live.com/Get", RequestNamespace = "http://profile.live.com/", ResponseNamespace = "http://profile.live.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetProfileResponse Get(GetProfileRequest request)
        {
            object[] results = this.Invoke("Get", new object[] {
                    request});
            return ((GetProfileResponse)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGet(GetProfileRequest request, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("Get", new object[] {
                    request}, callback, asyncState);
        }

        /// <remarks/>
        public GetProfileResponse EndGet(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetProfileResponse)(results[0]));
        }

        /// <remarks/>
        public void GetAsync(GetProfileRequest request)
        {
            this.GetAsync(request, null);
        }

        /// <remarks/>
        public void GetAsync(GetProfileRequest request, object userState)
        {
            if ((this.GetOperationCompleted == null))
            {
                this.GetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetOperationCompleted);
            }
            this.InvokeAsync("Get", new object[] {
                    request}, this.GetOperationCompleted, userState);
        }

        private void OnGetOperationCompleted(object arg)
        {
            if ((this.GetCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCompleted(this, new GetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("SOAPApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("SOAPUserHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://profile.live.com/GetMany", RequestNamespace = "http://profile.live.com/", ResponseNamespace = "http://profile.live.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetProfilesResponse GetMany(GetProfilesRequest request)
        {
            object[] results = this.Invoke("GetMany", new object[] {
                    request});
            return ((GetProfilesResponse)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetMany(GetProfilesRequest request, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetMany", new object[] {
                    request}, callback, asyncState);
        }

        /// <remarks/>
        public GetProfilesResponse EndGetMany(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetProfilesResponse)(results[0]));
        }

        /// <remarks/>
        public void GetManyAsync(GetProfilesRequest request)
        {
            this.GetManyAsync(request, null);
        }

        /// <remarks/>
        public void GetManyAsync(GetProfilesRequest request, object userState)
        {
            if ((this.GetManyOperationCompleted == null))
            {
                this.GetManyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetManyOperationCompleted);
            }
            this.InvokeAsync("GetMany", new object[] {
                    request}, this.GetManyOperationCompleted, userState);
        }

        private void OnGetManyOperationCompleted(object arg)
        {
            if ((this.GetManyCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetManyCompleted(this, new GetManyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("SOAPApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("SOAPUserHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://profile.live.com/Set", RequestNamespace = "http://profile.live.com/", ResponseNamespace = "http://profile.live.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SetProfileResponse Set(SetProfileRequest request)
        {
            object[] results = this.Invoke("Set", new object[] {
                    request});
            return ((SetProfileResponse)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSet(SetProfileRequest request, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("Set", new object[] {
                    request}, callback, asyncState);
        }

        /// <remarks/>
        public SetProfileResponse EndSet(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((SetProfileResponse)(results[0]));
        }

        /// <remarks/>
        public void SetAsync(SetProfileRequest request)
        {
            this.SetAsync(request, null);
        }

        /// <remarks/>
        public void SetAsync(SetProfileRequest request, object userState)
        {
            if ((this.SetOperationCompleted == null))
            {
                this.SetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetOperationCompleted);
            }
            this.InvokeAsync("Set", new object[] {
                    request}, this.SetOperationCompleted, userState);
        }

        private void OnSetOperationCompleted(object arg)
        {
            if ((this.SetCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetCompleted(this, new SetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("SOAPApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("SOAPUserHeaderValue")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://profile.live.com/Batch", RequestNamespace = "http://profile.live.com/", ResponseNamespace = "http://profile.live.com/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ProfileResponse[] Batch(ProfileRequest[] requests)
        {
            object[] results = this.Invoke("Batch", new object[] {
                    requests});
            return ((ProfileResponse[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginBatch(ProfileRequest[] requests, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("Batch", new object[] {
                    requests}, callback, asyncState);
        }

        /// <remarks/>
        public ProfileResponse[] EndBatch(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((ProfileResponse[])(results[0]));
        }

        /// <remarks/>
        public void BatchAsync(ProfileRequest[] requests)
        {
            this.BatchAsync(requests, null);
        }

        /// <remarks/>
        public void BatchAsync(ProfileRequest[] requests, object userState)
        {
            if ((this.BatchOperationCompleted == null))
            {
                this.BatchOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBatchOperationCompleted);
            }
            this.InvokeAsync("Batch", new object[] {
                    requests}, this.BatchOperationCompleted, userState);
        }

        private void OnBatchOperationCompleted(object arg)
        {
            if ((this.BatchCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BatchCompleted(this, new BatchCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://profile.live.com/", IsNullable = false)]
    public partial class SOAPApplicationHeader : System.Web.Services.Protocols.SoapHeader
    {

        private System.Guid applicationIdField;

        private string scenarioField;

        private string transactionIdField;

        private System.Xml.XmlAttribute[] anyAttrField;

        /// <remarks/>
        public System.Guid ApplicationId
        {
            get
            {
                return this.applicationIdField;
            }
            set
            {
                this.applicationIdField = value;
            }
        }

        /// <remarks/>
        public string Scenario
        {
            get
            {
                return this.scenarioField;
            }
            set
            {
                this.scenarioField = value;
            }
        }

        /// <remarks/>
        public string TransactionId
        {
            get
            {
                return this.transactionIdField;
            }
            set
            {
                this.transactionIdField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr
        {
            get
            {
                return this.anyAttrField;
            }
            set
            {
                this.anyAttrField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class CallInformation
    {

        private string serverNameField;

        private long elapsedMillisecondsField;

        private string[] extendedInfoField;

        private System.Xml.XmlElement traceGraphField;

        /// <remarks/>
        public string ServerName
        {
            get
            {
                return this.serverNameField;
            }
            set
            {
                this.serverNameField = value;
            }
        }

        /// <remarks/>
        public long ElapsedMilliseconds
        {
            get
            {
                return this.elapsedMillisecondsField;
            }
            set
            {
                this.elapsedMillisecondsField = value;
            }
        }

        /// <remarks/>
        public string[] ExtendedInfo
        {
            get
            {
                return this.extendedInfoField;
            }
            set
            {
                this.extendedInfoField = value;
            }
        }

        /// <remarks/>
        public System.Xml.XmlElement TraceGraph
        {
            get
            {
                return this.traceGraphField;
            }
            set
            {
                this.traceGraphField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class ErrorInfo
    {

        private ProfileErrorCodes resultCodeField;

        private string messageField;

        private string[] extendedInfoField;

        /// <remarks/>
        public ProfileErrorCodes ResultCode
        {
            get
            {
                return this.resultCodeField;
            }
            set
            {
                this.resultCodeField = value;
            }
        }

        /// <remarks/>
        public string Message
        {
            get
            {
                return this.messageField;
            }
            set
            {
                this.messageField = value;
            }
        }

        /// <remarks/>
        public string[] ExtendedInfo
        {
            get
            {
                return this.extendedInfoField;
            }
            set
            {
                this.extendedInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public enum ProfileErrorCodes
    {

        /// <remarks/>
        None,

        /// <remarks/>
        InvalidIdType,

        /// <remarks/>
        MissingConfigurationSetting,

        /// <remarks/>
        ConfigurationError,

        /// <remarks/>
        InvalidRequestParameters,

        /// <remarks/>
        InvalidRequestBatch,

        /// <remarks/>
        InvalidPartnerId,

        /// <remarks/>
        InvalidView,

        /// <remarks/>
        InvalidArgument,

        /// <remarks/>
        InvalidCallerId,

        /// <remarks/>
        InvalidRpsToken,

        /// <remarks/>
        InvalidScenario,

        /// <remarks/>
        DataVersionConflict,

        /// <remarks/>
        GeneralServerError,

        /// <remarks/>
        UserNotFound,

        /// <remarks/>
        Timeout,

        /// <remarks/>
        NetworkError,

        /// <remarks/>
        PermissionDenied,

        /// <remarks/>
        InvalidProfileAttributeValues,

        /// <remarks/>
        ServerBusy,

        /// <remarks/>
        UserMoved,

        /// <remarks/>
        ServiceUnavailable,

        /// <remarks/>
        SchemaVersionConflict,

        /// <remarks/>
        GeneralCacheError,

        /// <remarks/>
        GeneralCacheNetworkError,

        /// <remarks/>
        GeneralCacheConfigurationError,

        /// <remarks/>
        OperationNotAllowedOnPublicInterface,

        /// <remarks/>
        ActivityLimitReached,
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(SetProfileResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetProfilesResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(InvalidateUserCacheResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(CacheWarmerResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetSettingsResponse))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetProfileResponse))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public abstract partial class ProfileResponse
    {

        private ErrorInfo[] errorsField;

        private CallInformation callStatisticsField;

        /// <remarks/>
        public ErrorInfo[] Errors
        {
            get
            {
                return this.errorsField;
            }
            set
            {
                this.errorsField = value;
            }
        }

        /// <remarks/>
        public CallInformation CallStatistics
        {
            get
            {
                return this.callStatisticsField;
            }
            set
            {
                this.callStatisticsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class SetProfileResponse : ProfileResponse
    {

        private ProfileId idField;

        private View viewField;

        /// <remarks/>
        public ProfileId Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public View View
        {
            get
            {
                return this.viewField;
            }
            set
            {
                this.viewField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class ProfileId
    {

        private IdNamespace ns1Field;

        private object v1Field;

        private IdNamespace ns2Field;

        private object v2Field;

        private IdNamespace ns3Field;

        private object v3Field;

        /// <remarks/>
        public IdNamespace Ns1
        {
            get
            {
                return this.ns1Field;
            }
            set
            {
                this.ns1Field = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable = true)]
        public object V1
        {
            get
            {
                return this.v1Field;
            }
            set
            {
                this.v1Field = value;
            }
        }

        /// <remarks/>
        public IdNamespace Ns2
        {
            get
            {
                return this.ns2Field;
            }
            set
            {
                this.ns2Field = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable = true)]
        public object V2
        {
            get
            {
                return this.v2Field;
            }
            set
            {
                this.v2Field = value;
            }
        }

        /// <remarks/>
        public IdNamespace Ns3
        {
            get
            {
                return this.ns3Field;
            }
            set
            {
                this.ns3Field = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable = true)]
        public object V3
        {
            get
            {
                return this.v3Field;
            }
            set
            {
                this.v3Field = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public enum IdNamespace
    {

        /// <remarks/>
        Unspecified,

        /// <remarks/>
        Cid,

        /// <remarks/>
        Puid,

        /// <remarks/>
        CircleId,

        /// <remarks/>
        AppId,

        /// <remarks/>
        Anonymous,

        /// <remarks/>
        AsOwner,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class View
    {

        private string viewNameField;

        private A[] attributesField;

        private string viewVersionField;

        /// <remarks/>
        public string ViewName
        {
            get
            {
                return this.viewNameField;
            }
            set
            {
                this.viewNameField = value;
            }
        }

        /// <remarks/>
        public A[] Attributes
        {
            get
            {
                return this.attributesField;
            }
            set
            {
                this.attributesField = value;
            }
        }

        /// <remarks/>
        public string ViewVersion
        {
            get
            {
                return this.viewVersionField;
            }
            set
            {
                this.viewVersionField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class A
    {

        private string nField;

        private object vField;

        /// <remarks/>
        public string N
        {
            get
            {
                return this.nField;
            }
            set
            {
                this.nField = value;
            }
        }

        /// <remarks/>
        public object V
        {
            get
            {
                return this.vField;
            }
            set
            {
                this.vField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class GetProfilesResponse : ProfileResponse
    {

        private ProfileId[] idsField;

        private View[] viewsField;

        /// <remarks/>
        public ProfileId[] Ids
        {
            get
            {
                return this.idsField;
            }
            set
            {
                this.idsField = value;
            }
        }

        /// <remarks/>
        public View[] Views
        {
            get
            {
                return this.viewsField;
            }
            set
            {
                this.viewsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class InvalidateUserCacheResponse : ProfileResponse
    {
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class CacheWarmerResponse : ProfileResponse
    {
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class GetSettingsResponse : ProfileResponse
    {

        private string[] settingsField;

        /// <remarks/>
        public string[] Settings
        {
            get
            {
                return this.settingsField;
            }
            set
            {
                this.settingsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class GetProfileResponse : ProfileResponse
    {

        private ProfileId idField;

        private View viewField;

        /// <remarks/>
        public ProfileId Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public View View
        {
            get
            {
                return this.viewField;
            }
            set
            {
                this.viewField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class AttributeEnumValue
    {

        private short codeField;

        private string nameField;

        /// <remarks/>
        public short Code
        {
            get
            {
                return this.codeField;
            }
            set
            {
                this.codeField = value;
            }
        }

        /// <remarks/>
        public string Name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(SetProfileRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetSettingsRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(InvalidateUserCacheRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(AsyncProfileRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(CacheWarmerRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(BaseGetProfileRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetProfilesRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetProfileRequest))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public abstract partial class ProfileRequest
    {
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class SetProfileRequest : ProfileRequest
    {

        private ProfileId idField;

        private string viewNameField;

        private A[] attributesField;

        private string viewVersionField;

        private bool getUpdatedProfileOnSetField;

        /// <remarks/>
        public ProfileId Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public string ViewName
        {
            get
            {
                return this.viewNameField;
            }
            set
            {
                this.viewNameField = value;
            }
        }

        /// <remarks/>
        public A[] Attributes
        {
            get
            {
                return this.attributesField;
            }
            set
            {
                this.attributesField = value;
            }
        }

        /// <remarks/>
        public string ViewVersion
        {
            get
            {
                return this.viewVersionField;
            }
            set
            {
                this.viewVersionField = value;
            }
        }

        /// <remarks/>
        public bool GetUpdatedProfileOnSet
        {
            get
            {
                return this.getUpdatedProfileOnSetField;
            }
            set
            {
                this.getUpdatedProfileOnSetField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class GetSettingsRequest : ProfileRequest
    {

        private ProfileId idField;

        private string[] settingsField;

        /// <remarks/>
        public ProfileId Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public string[] Settings
        {
            get
            {
                return this.settingsField;
            }
            set
            {
                this.settingsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class InvalidateUserCacheRequest : ProfileRequest
    {

        private ProfileId idField;

        private bool invalidateDataCacheField;

        private string[] viewsField;

        private bool invalidateAclCacheField;

        private string[] rolesField;

        /// <remarks/>
        public ProfileId Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public bool InvalidateDataCache
        {
            get
            {
                return this.invalidateDataCacheField;
            }
            set
            {
                this.invalidateDataCacheField = value;
            }
        }

        /// <remarks/>
        public string[] Views
        {
            get
            {
                return this.viewsField;
            }
            set
            {
                this.viewsField = value;
            }
        }

        /// <remarks/>
        public bool InvalidateAclCache
        {
            get
            {
                return this.invalidateAclCacheField;
            }
            set
            {
                this.invalidateAclCacheField = value;
            }
        }

        /// <remarks/>
        public string[] Roles
        {
            get
            {
                return this.rolesField;
            }
            set
            {
                this.rolesField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(CacheWarmerRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(BaseGetProfileRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetProfilesRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetProfileRequest))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public abstract partial class AsyncProfileRequest : ProfileRequest
    {
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class CacheWarmerRequest : AsyncProfileRequest
    {

        private string[] viewsField;

        private ProfileId[] idsField;

        /// <remarks/>
        public string[] Views
        {
            get
            {
                return this.viewsField;
            }
            set
            {
                this.viewsField = value;
            }
        }

        /// <remarks/>
        public ProfileId[] Ids
        {
            get
            {
                return this.idsField;
            }
            set
            {
                this.idsField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetProfilesRequest))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GetProfileRequest))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public abstract partial class BaseGetProfileRequest : AsyncProfileRequest
    {

        private string viewNameField;

        /// <remarks/>
        public string ViewName
        {
            get
            {
                return this.viewNameField;
            }
            set
            {
                this.viewNameField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class GetProfilesRequest : BaseGetProfileRequest
    {

        private ProfileId[] idsField;

        /// <remarks/>
        public ProfileId[] Ids
        {
            get
            {
                return this.idsField;
            }
            set
            {
                this.idsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    public partial class GetProfileRequest : BaseGetProfileRequest
    {

        private ProfileId idField;

        /// <remarks/>
        public ProfileId Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://profile.live.com/")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://profile.live.com/", IsNullable = false)]
    public partial class SOAPUserHeader : System.Web.Services.Protocols.SoapHeader
    {

        private ProfileId callerField;

        private string ticketTokenField;

        private System.Xml.XmlAttribute[] anyAttrField;

        /// <remarks/>
        public ProfileId Caller
        {
            get
            {
                return this.callerField;
            }
            set
            {
                this.callerField = value;
            }
        }

        /// <remarks/>
        public string TicketToken
        {
            get
            {
                return this.ticketTokenField;
            }
            set
            {
                this.ticketTokenField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr
        {
            get
            {
                return this.anyAttrField;
            }
            set
            {
                this.anyAttrField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetCompletedEventHandler(object sender, GetCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public GetProfileResponse Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((GetProfileResponse)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void GetManyCompletedEventHandler(object sender, GetManyCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetManyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetManyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public GetProfilesResponse Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((GetProfilesResponse)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void SetCompletedEventHandler(object sender, SetCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public SetProfileResponse Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((SetProfileResponse)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    public delegate void BatchCompletedEventHandler(object sender, BatchCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.3038")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BatchCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal BatchCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public ProfileResponse[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((ProfileResponse[])(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\HttpClientEventArgs.cs ===
﻿namespace Gds
{
    using System;
    using System.ComponentModel;

    public class HttpClientEventArgs : AsyncCompletedEventArgs
    {
        public HttpClientEventArgs(object responseObject, Exception exception, bool cancelled, object userToken)
            : base(exception, cancelled, userToken)
        {
            this.ResponseObject = responseObject;
        }

        public object Result
        {
            get
            {
                RaiseExceptionIfNecessary();
                return this.ResponseObject;
            }
        }

        private object ResponseObject { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\NotificationProxy\INotificationProxy.cs ===
namespace Leet.Silverlight.RESTProxy.NotificationProxy
{
    using System;
    using AsyncMultiplayer.NotificationService;

    public interface INotificationProxy
    {
        /// <summary>
        /// Callback triggered after corresponding *Async() method is called
        /// </summary>
        event EventHandler<NotificationProxyEventArgs<string>> OnGetNotificationCompleted;

        event EventHandler<NotificationProxyEventArgs<string>> OnDeleteNotificationCompleted;

        event EventHandler<NotificationProxyEventArgs<string>> OnUpdateNotificationCompleted;

        event EventHandler<NotificationProxyEventArgs<string>> OnPostInviteCompleted;

        event EventHandler<NotificationProxyEventArgs<string>> OnGetSpotlightCompleted;

        /// <summary>
        /// Retrieve notification information from the NotificationFE service
        /// </summary>
        void GetNotificationAsync(NotificationOptionalFields optionalFields);

        /// <summary>
        /// Retrieve notification information from the NotificationFE service for the specific game
        /// </summary>
        void GetNotificationForSpecificGameAsync(uint gameId, uint gameVariant, NotificationOptionalFields optionalFields);

        /// <summary>
        /// Retrieve notification information from the NotificationFE service for the specific game session
        /// </summary>
        void GetNotificationForSpecificSessionAsync(uint gameId, string sessionId, NotificationOptionalFields optionalFields);

        /// <summary>
        /// Deletes an existing notification specified by its notification ID
        /// </summary>
        void DeleteNotificationAsync(string notificationId);

        /// <summary>
        /// Deletes all notifications for a specific game session
        /// </summary>
        void DeleteAllNotificationsForSpecificSessionAsync(uint gameId, string sessionId);

        /// <summary>
        /// Updates an existing notification specified by its notification ID with the specified status (e.g. Viewed)
        /// </summary>
        void UpdateNotificationAsync(string notificationId, string status);

        /// <summary>
        /// Schedules an invite request to be queued and sent via SMTP
        /// </summary>
        void PostInviteAsync(InviteRequest inviteReq);

        /// <summary>
        /// Get Spotlight (used currently only by the mobile platform)
        /// </summary>
        void GetSpotlightAsync(string carrierString);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\HttpClient.cs ===
﻿namespace Leet.Silverlight.RESTProxy
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Net;
#if SILVERLIGHT
    using System.Net.Browser;
#endif
    using System.Runtime.Serialization;
    using System.Text;
    using System.Xml;
    using System.Xml.Serialization;
    using Gds;
#if !WINDOWS_PHONE && !WINDOWS
    using Leet.UserGameData.DataContracts;
#endif //!WINDOWS_PHONE && !WINDOWS

    // Silverlight 3 supports two HTTP stacks which offers different features
    // Check out http://www.wintellect.com/CS/blogs/jprosise/archive/2009/10/14/silverlight-3-s-new-client-networking-stack.aspx for the differences
    public enum HttpStack
    {
        PlatformDefault = 1,
        SilverlightClientStack
    }

    /// <summary>
    /// A custom wrapper around HttpWebRequest that understands DataContract serialization
    /// </summary>
    public class HttpClient
    {
        private const string InvalidDataContract = "The given type does not have a DataContractAttribute";
        private const int DefaultBufferCopySize = 4096;

        private static Dictionary<Type, DataContractSerializer> deserializerTable = new Dictionary<Type, DataContractSerializer>();

        // Instantiate a lockable object.
        private static object lockObject = new object();

        private WebHeaderCollection headers = null;
        private CookieContainer cookies = null;

        private HttpClient(Uri uri, HttpStack httpStack)
        {
            this.TargetUri = uri;
            this.HttpStack = httpStack; // only applicable for Silverlight 3 clients
        }

        public event EventHandler<HttpClientEventArgs> OnRequestCompleted;

        public string ContentType { get; set; }

        public string Accepted { get; set; }

        // Each instance of HttpClient can specify its own headers; typically this will include the STS token for authentication
        public WebHeaderCollection Headers 
        {
            get
            {
                return this.headers;
            }
            
            set
            {
#if SILVERLIGHT
                if (this.HttpStack == HttpStack.PlatformDefault)
                {
                    throw new InvalidOperationException("this type of HttpClient does NOT support Headers.");
                }
#endif
                this.headers = value;
            }
        }

        // Each instance of HttpClient can specify its own cookies; currently V1 Multiplayer uses UserID cookie for identity
        public CookieContainer Cookies
        {
            get
            {
                return this.cookies;
            }

            set
            {
#if SILVERLIGHT
                if (this.HttpStack == HttpStack.PlatformDefault)
                {
                    throw new InvalidOperationException("this type of HttpClient does NOT support cookie containers.");
                }
#endif
                this.cookies = value;
            }
        }

        private HttpStack HttpStack { get; set; }

        private Uri TargetUri { get; set; }

        private Type RequestObjectType { get; set; }

        private Type ResponseObjectType { get; set; }

        private bool IsRequestDeserializable { get; set; }

        private bool IsResponseDeserializable { get; set; }

#if SILVERLIGHT
        private AsyncOperation AsyncOperation { get; set; }
#endif
        public static HttpClient GetHttpClient(string targetUri, HttpStack httpStack)
        {
#if !SILVERLIGHT
            if (httpStack != HttpStack.PlatformDefault)
            {
                throw new InvalidOperationException("This type of HttpStack is not supported in non-Silverlight Platforms"); // no constructor taking two string parameters
            }
#endif

            return new HttpClient(new Uri(targetUri), httpStack);
        }

        public static HttpClient GetHttpClient(Uri targetUri, HttpStack httpStack)
        {
#if !SILVERLIGHT
            if (httpStack != HttpStack.PlatformDefault)
            {
                throw new InvalidOperationException("This type of HttpStack is not supported in non-Silverlight Platforms"); // no constructor taking two string parameters
            }
#endif

            return new HttpClient(targetUri, httpStack);
        }

        public static HttpClient GetHttpClient(string targetUri)
        {
            return new HttpClient(new Uri(targetUri), HttpStack.PlatformDefault);
        }

        public static HttpClient GetHttpClient(Uri targetUri)
        {
            return new HttpClient(targetUri, HttpStack.PlatformDefault);
        }

        public void PostDataContractAsync<RequestType, ResponseType>(object requestObject)
        {
            this.RequestObjectType = typeof(RequestType);
            this.ResponseObjectType = typeof(ResponseType);

            this.CheckRequestTypes(requestObject);
            this.CheckResponseType();

#if SILVERLIGHT
            this.AsyncOperation = AsyncOperationManager.CreateOperation(this);
#endif
            this.InternalBeginPost(requestObject);
        }
        
        public void GetDataContractAsync<ResponseType>()
        {
            this.ResponseObjectType = typeof(ResponseType);
            this.CheckResponseType();

#if SILVERLIGHT
            this.AsyncOperation = AsyncOperationManager.CreateOperation(this);
#endif
            this.InternalBeginGet();
        }

        public void PutDataContractAsync<RequestType, ResponseType>(object requestObject)
        {
            this.RequestObjectType = typeof(RequestType);
            this.ResponseObjectType = typeof(ResponseType);

            this.CheckRequestTypes(requestObject);
            this.CheckResponseType();

#if SILVERLIGHT
            this.AsyncOperation = AsyncOperationManager.CreateOperation(this);
#endif
            this.InternalBeginPut(requestObject);
        }

        public void DeleteDataContractAsync<ResponseType>(object requestObject)
        {
            this.ResponseObjectType = typeof(ResponseType);
            this.CheckResponseType();

#if SILVERLIGHT
            this.AsyncOperation = AsyncOperationManager.CreateOperation(this);
#endif
            this.InternalBeginDelete(requestObject);
        }

        private static bool HasCustomAttribute<T>(Type dataContractType) where T : Attribute
        {
            if (dataContractType.GetCustomAttributes(typeof(T), false).Length > 0)
            {
                return true;
            }

            return false;
        }

        private static DataContractSerializer TryGetDeserializer(Type serializationType)
        {
            DataContractSerializer returnSerializer = null;
            if (serializationType == null)
            {
                return null;
            }

            if (serializationType == typeof(string))
            {
                return null;
            }

            // Check if this type is previously used otherwise create one.
            if (HttpClient.deserializerTable.TryGetValue(serializationType, out returnSerializer) == false)
            {
                lock (HttpClient.lockObject)
                {
                    if (HttpClient.deserializerTable.TryGetValue(serializationType, out returnSerializer) == false)
                    {
                        returnSerializer = new DataContractSerializer(serializationType);
                        HttpClient.deserializerTable.Add(serializationType, returnSerializer);
                    }
                }
            }

            return returnSerializer;
        }

        private static HttpWebRequest GetHttpStackInitialized(HttpClient httpClient)
        {
            HttpWebRequest hwr = null;

            if (httpClient.HttpStack == HttpStack.PlatformDefault)
            {
                hwr = (HttpWebRequest)WebRequest.Create(httpClient.TargetUri);
            }
#if SILVERLIGHT
            else
            {
                hwr = (HttpWebRequest)WebRequestCreator.ClientHttp.Create(httpClient.TargetUri);
            }
#endif

            if (httpClient.Headers != null)
            {
                hwr.Headers = httpClient.Headers;
            }

            if (httpClient.Cookies != null)
            {
                hwr.CookieContainer = httpClient.Cookies;
            }

            // For some reason, we need to specify these header values after 
            // setting the WebHeaderCollection above since otherwise they will be overwritten 
            // Set the Accepted Type if there is anything specified.
            if (!string.IsNullOrEmpty(httpClient.Accepted))
            {
                hwr.Accept = httpClient.Accepted;
            }

            // Set the ContentType if there is anything specified.
            if (!string.IsNullOrEmpty(httpClient.ContentType))
            {
                hwr.ContentType = httpClient.ContentType;
            }

            return hwr;
        }

        private void InternalBeginPost(object dataContractObject)
        {
            this.InternalBeginHttpAction(dataContractObject, "POST");
        }

        private void InternalBeginPut(object dataContractObject)
        {
            // TODO: This call will throw because PUT and DELETE are not supported in the Browser HTTP stack
            this.InternalBeginHttpAction(dataContractObject, "PUT");
        }

        private void InternalBeginDelete(object dataContractObject)
        {
            // TODO: This call will throw because PUT and DELETE are not supported in the Browser HTTP stack
            this.InternalBeginHttpAction(dataContractObject, "DELETE");
        }

        private void InternalBeginHttpAction(object dataContractObject, string httpMethod)
        {
            HttpWebRequest hwr = GetHttpStackInitialized(this);

            hwr.Method = httpMethod;

            // Using anonymous delegates for conciseness.
            // NOTE: This section could be in another thread. Don't assume it is the UI thread.
            hwr.BeginGetRequestStream(
                delegate(IAsyncResult asyncGetRequestResult)
            {
                try
                {
                    using (Stream stream = hwr.EndGetRequestStream(asyncGetRequestResult))
                    {
                        // Making requests with a null object is valid in scenarios where you don't pass in any extra data other than the URI
                        DataContractSerializer dcs = HttpClient.TryGetDeserializer(this.RequestObjectType);
                        if (dcs != null)
                        {
                            dcs.WriteObject(stream, dataContractObject);
                        }
                    }

                    Logging.Dump(hwr);

                    hwr.BeginGetResponse(
                        delegate(IAsyncResult asyncGetResponseResult)
                    {
                        try
                        {
                            using (HttpWebResponse httpResponse = (HttpWebResponse)hwr.EndGetResponse(asyncGetResponseResult))
                            {
                                // Success -- exceptions 
                                this.FireRequestCompleted(null, httpResponse);
                            }
                        }
                        catch (Exception ex)
                        {
                            // Absorb this exception, as it would blow up app domain if it percolates up.
                            this.FireRequestCompleted(ex, null);
                        }
                    },
                    null);
                }
                catch (Exception ex)
                {
                    // Absorb this exception, as it would blow up app domain if it percolates up.
                    this.FireRequestCompleted(ex, null);
                }
            },
            null);
        }

        private void InternalBeginGet()
        {
            HttpWebRequest hwr = GetHttpStackInitialized(this);

            try
            {
                Logging.Dump(hwr);

                hwr.BeginGetResponse(
                    delegate(IAsyncResult asyncResultResponse)
                {
                    try
                    {
                        using (HttpWebResponse httpResponse = (HttpWebResponse)hwr.EndGetResponse(asyncResultResponse))
                        {
                            // Success 
                            this.FireRequestCompleted(null, httpResponse);
                        }
                    }
                    catch (Exception ex)
                    {
                        // Absorb this exception, as it would blow up app domain if it percolates up.
                        this.FireRequestCompleted(ex, null);
                    }
                },
                null);
            }
            catch (Exception ex)
            {
                // Absorb this exception, as it would blow up app domain if it percolates up.
                this.FireRequestCompleted(ex, null);
            }
        }

        private void FireRequestCompleted(Exception exception, HttpWebResponse httpWebResponse)
        {
            if (null == exception)
            {
                Logging.Dump(httpWebResponse);
            }
            else
            {
                Logging.Dump(exception);
            }

            object outObject = null;

            // Check if we have a non-null response
            if (httpWebResponse != null && httpWebResponse.ContentLength > 0 && exception == null)
            {
                // Read the contents from the response stream
                using (Stream httpStream = httpWebResponse.GetResponseStream())
                {
                    // TODO: The Profile.SVC has a Profile type that implements its own IXmlSerializable read/write functions which doesn't 
                    // play nice with the the HttpClient DCS implementation. In future, we might want to remove the special-casing for the Profile type. 
                    // The service team should decide on the correct way to serialize/deserialize the input/output data and update this HttpClient engine
#if !WINDOWS_PHONE && !WINDOWS
                    if (this.ResponseObjectType == typeof(Profile))
                    {
                        XmlSerializer xmlSerializer = new XmlSerializer(typeof(Profile));
                        outObject = xmlSerializer.Deserialize(httpStream);
                    }
                    else
#endif //!WINDOWS_PHONE && !WINDOWS
                    {
                        DataContractSerializer dcs = HttpClient.TryGetDeserializer(this.ResponseObjectType);
                        if (dcs != null)
                        {
                            try
                            {
                                outObject = dcs.ReadObject(httpStream);
                            }
                            catch (SerializationException ex)
                            {
                                exception = ex;
                            }
                        }
                        else
                        {
                            // Default to string, if there is no deserialization available.
                            using (StreamReader streamReader = new StreamReader(httpStream, Encoding.UTF8))
                            {
                                outObject = streamReader.ReadToEnd();
                            }
                        }
                    }
                }
            }

            // It's good practice to create a new reference to the event handler to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<HttpClientEventArgs> tmpEvent = this.OnRequestCompleted;
            if (tmpEvent != null)
            {
                HttpClientEventArgs rpea = new HttpClientEventArgs(outObject, exception, false, null);

#if SILVERLIGHT
                // In Silverlight we would like to complete the event on the same thread that initiated it.
                // To be precise, we would like to complete on the UI thread.
                // for calls initiated from non-UI thread, it is ok to complete on non-UI threads.
                this.AsyncOperation.PostOperationCompleted(
                    delegate(object obj)
                {
                    tmpEvent(this, rpea);
                },
                null);
#else
                // On non-Silverlight platforms it is ok to complete on any thread, 
                // typically a background thread
                tmpEvent(this, rpea);
#endif
            }
        }

        private Stream CopyStream(Stream httpResponseStream)
        {
            if (httpResponseStream == null)
            {
                throw new InvalidOperationException("Invalid Stream to Copy");
            }

            MemoryStream memStream = new MemoryStream((int)httpResponseStream.Length);

            if (httpResponseStream.Length > 0)
            {
                byte[] buffer = new byte[HttpClient.DefaultBufferCopySize];
                int readLen = 0;
                while ((readLen = httpResponseStream.Read(buffer, 0, HttpClient.DefaultBufferCopySize)) > 0)
                {
                    memStream.Write(buffer, 0, readLen);
                }
            }

            memStream.Position = 0;

            return memStream;
        }

        private void CheckRequestTypes(object requestObject)
        {
            // Make sure types are matched properly
            if (requestObject.GetType() != this.RequestObjectType)
            {
                throw new ArgumentException("requestObject type mismatch with RequestType", "dataContractObject");
            }

            // Make sure RequestObjectType has a DataContractAttribute or is string.
            if (!HttpClient.HasCustomAttribute<DataContractAttribute>(this.RequestObjectType))
            {
                this.IsRequestDeserializable = false;

                // Make sure the requestdatacontracttype is a string
                if (requestObject.GetType() != typeof(string))
                {
                    throw new InvalidOperationException("requestObject cannot be a non-string non-serializable object");
                }
            }
        }

        private void CheckResponseType()
        {
            // If request type is an array, remove the brackets before calling to make sure the element type is serializable
            Type responseBaseType;
            if (this.ResponseObjectType.IsArray)
            {
                char[] trimChars = new char[] { '[', ']' };
                responseBaseType = Type.GetType(this.ResponseObjectType.FullName.TrimEnd(trimChars));
            }
            else
            {
                responseBaseType = this.ResponseObjectType;
            }

            // Make sure RequestObjectType has a DataContractAttribute or is string.
            if (!HttpClient.HasCustomAttribute<DataContractAttribute>(responseBaseType))
            {
                this.IsResponseDeserializable = false;

                // Make sure the requestdatacontracttype is a string
                if (this.ResponseObjectType != typeof(string))
                {
                    throw new InvalidOperationException("ResponseType cannot be a non-string non-serializable type");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\NotificationProxy\NotificationProxyEventArgs.cs ===
﻿namespace Leet.Silverlight.RESTProxy.NotificationProxy
{
    using System;
    using System.ComponentModel;

    public class NotificationProxyEventArgs<ReturnType> : AsyncCompletedEventArgs
    {
        private object result;

        internal NotificationProxyEventArgs(object objectResult, Exception exception, bool cancelled, object userToken)
            : base(exception, cancelled, userToken)
        {
            this.result = objectResult;
        }

        public ReturnType Result
        {
            get
            {
                RaiseExceptionIfNecessary();

                if (this.result == null)
                {
                    return (ReturnType)this.result;
                }
                else if (this.result.GetType() == typeof(ReturnType))
                {
                    return (ReturnType)this.result;
                }

                return default(ReturnType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\Logging.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="Logging.cs" company="Microsoft" author="HughV">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>Fiddler like logging to enable web debuging when Fiddler cannot be used</summary>
//-------------------------------------------------------------------------------------------------

// uncomment next line to enable logging - useful for tracking
// down problems where fiddler can't be used - like on mobile
////#define LOG

namespace Leet.Silverlight.RESTProxy
{
    using System;
    using System.Diagnostics;
    using System.Net;

    // define LOG above or in the project to enable (otherwise, this will never be called)

    /// <summary>Logging interface</summary>
    public interface ILogging
    {
        /// <summary>Generic handler to write object as string</summary>
        /// <typeparam name="T">allow any type</typeparam>
        /// <param name="o">The object to log</param>
        void Dump<T>(T o);
    }

    /// <summary>Class to abstract away whether or not there is a registered logging instance</summary>
    public class Logging
    {
#if LOG
        /// <summary>Initializes static members of the Logging class</summary>
        static Logging()
        {
            // create current logging class
            CurrentLogger = new MobileLogging();
        }
#endif //LOG

        /// <summary>Gets the currently defined Logging instance - can be null</summary>
        public static ILogging CurrentLogger { get; private set; }

        /// <summary>Generic handler to write object as string</summary>
        /// <typeparam name="T">allow any type</typeparam>
        /// <param name="o">The object to log</param>
        public static void Dump<T>(T o)
        {
            if (null != CurrentLogger)
            {
                CurrentLogger.Dump(o);
            }
        }
    }

    /// <summary>Class intended to log requests on mobile</summary>
    public class MobileLogging : ILogging
    {
        // dump all requests and responses to debug output
        // on mobile, it is very difficult to get fiddler working
        // so this gives us similar debugging information

        /// <summary>Generic handler to write object as string</summary>
        /// <typeparam name="T">allow any type</typeparam>
        /// <param name="o">The object to log</param>
        public void Dump<T>(T o)
        {
            // somewhat kludgy, but it allows for a simple interface and doesn't require future
            // logging classes to care about the same types of arguments as this one.
            if (o is HttpWebRequest)
            {
                Dump(o as HttpWebRequest);
            }
            else if (o is HttpWebResponse)
            {
                Dump(o as HttpWebResponse);
            }
            else
            {
                string s = GetString(o);
                DumpInternal(s, 2);
            }
        }

        /// <summary>Write a request to debug output</summary>
        /// <param name="req">the request to log</param>
        private static void Dump(HttpWebRequest req)
        {
            try
            {
                DumpInternal("Dumping HttpWebRequest", 3);

                if (null == req)
                {
                    Debug.WriteLine("Request is null");
                    return;
                }

                Debug.WriteLine("Request Uri              -> {0}", GetString(req.RequestUri));
                Debug.WriteLine("Method type              -> {0}", GetString(req.Method));
                Debug.WriteLine("Content type             -> {0}", GetString(req.ContentType));
                Debug.WriteLine("HaveResponse             -> {0}", GetString(req.HaveResponse));
                Debug.WriteLine("Accept                   -> {0}", GetString(req.Accept));
#if !WINDOWS
                Debug.WriteLine("AllowReadStreamBuffering -> {0}", GetString(req.AllowReadStreamBuffering));
#endif
#if !WINDOWS_PHONE
                Debug.WriteLine("Headers");
                foreach (string keyString in req.Headers.AllKeys)
                {
                    Debug.WriteLine("     [{0}] {1}", keyString, req.Headers[keyString]);
                }
#endif
            }
            catch (Exception ex)
            {
                DumpInternal(ex.ToString(), 1);
            }
        }

        /// <summary>Write a response to debug output</summary>
        /// <param name="resp">The response to log</param>
        private static void Dump(HttpWebResponse resp)
        {
            try
            {
                DumpInternal("Dumping HttpWebResponse", 3);

                if (null == resp)
                {
                    Debug.WriteLine("Response is null");
                    return;
                }

                Debug.WriteLine("Response Uri   -> {0}", GetString(resp.ResponseUri));
                Debug.WriteLine("Method type    -> {0}", GetString(resp.Method));
                Debug.WriteLine("Status         -> {0}", GetString(resp.StatusDescription));
                Debug.WriteLine("Content type   -> {0}", GetString(resp.ContentType));

#if !WINDOWS_PHONE
                Debug.WriteLine("Headers");
                foreach (string keyString in resp.Headers.AllKeys)
                {
                    Debug.WriteLine("     [{0}] {1}", keyString, resp.Headers[keyString]);
                }
#endif
            }
            catch (Exception ex)
            {
                DumpInternal(ex.ToString(), 1);
            }
        }

        /// <summary>DO NOT USE this method.  It is expensive and should only be used by the class.</summary>
        /// <param name="s">this is a string that should not be used</param>
        /// <param name="framesToSkip">this is an int that should not be used</param>
        private static void DumpInternal(string s, int framesToSkip)
        {
            // This is the base logging method, it will grab the calling method & log.
            StackTrace trace = new StackTrace();
            StackFrame frame = trace.GetFrame(framesToSkip);

            Debug.WriteLine("##########");
            Debug.WriteLine(frame.GetMethod().Name);
            Debug.WriteLine(s);
        }

        /// <summary>Allow any object to be treated as a string for logging purposes</summary>
        /// <param name="o">the object to turn int a string</param>
        /// <returns>a string representation of the object</returns>
        private static string GetString(object o)
        {
            return (null != o) ? o.ToString() : "<null>";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\NotificationProxy\NotificationOptionalFields.cs ===
﻿namespace Leet.Silverlight.RESTProxy.NotificationProxy
{
    using System;
    using System.Text;

    public class NotificationOptionalFields
    {
        public uint? Category { get; set; }

        public uint? LastId { get; set; }

        public uint? Count { get; set; }

        public bool? UserVisibleOnly { get; set; }

        public uint? Platform { get; set; }

        public string URLString()
        {
            const int DefaultOptionalSize = 256;
            StringBuilder sb = new StringBuilder(DefaultOptionalSize);

            // Check that each optional field is non-null before append it to the URL string
            if (this.Category.HasValue)
            {
                sb.AppendFormat("&category={0}", this.Category);
            }

            if (this.LastId.HasValue)
            {
                sb.AppendFormat("&last={0}", this.LastId);
            }

            if (this.Count.HasValue)
            {
                sb.AppendFormat("&count={0}", this.Count);
            }

            if (this.UserVisibleOnly.HasValue)
            {
                sb.AppendFormat("&userVisibleOnly={0}", this.UserVisibleOnly);
            }

            if (this.Platform.HasValue)
            {
                sb.AppendFormat("&platform={0}", this.Platform);
            }

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\UtililityFunctions.cs ===
﻿namespace Leet.Silverlight.RESTProxy
{
    using System.Text;

    /// <summary>
    /// Class that contains useful functions that can be used by several proxy clients
    /// </summary>
    public class UtilityFunctions
    {
        private const int UrlDefaultSize = 1024;

        /// <summary>
        /// Normalizes the Template by combining it w/ the serviceUri and relativePathAndQuery
        /// </summary>
        /// <param name="serviceUri"></param>
        /// <param name="relativePathAndQuery"></param>
        /// <returns></returns>
        public static string GetUriTemplate(System.Uri serviceUri, string relativePathAndQuery)
        {
            // Use string builder for performance gains, and ensure a sufficiently large Uri initial size is picked.
            // this will prevent excessive memory re-allocation.
            StringBuilder sb = new StringBuilder(UrlDefaultSize);

            // URL for the PostGameResult service
            sb.AppendFormat("{0}://{1}:{2}{3}/{4}", serviceUri.Scheme, serviceUri.Host, serviceUri.Port, serviceUri.AbsolutePath, relativePathAndQuery);
            return sb.ToString();
        }

        /// <summary>
        /// Replaces the service name in a URI
        /// </summary>
        /// <param name="serviceUri"></param>
        /// <param name="serviceName"></param>
        /// <returns></returns>
        public static string ReplaceServiceNameInURI(System.Uri serviceUri, string serviceName)
        {
            // Use string builder for performance gains, and ensure a sufficiently large Uri initial size is picked.
            // this will prevent excessive memory re-allocation.
            StringBuilder sb = new StringBuilder(UrlDefaultSize);

            // URL for the PostGameResult service
            sb.AppendFormat("{0}://{1}:{2}/{3}", serviceUri.Scheme, serviceUri.Host, serviceUri.Port, serviceName);
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\NotificationProxy\NotificationProxy.cs ===
﻿// TODO: 1. The notification responses are not deserialized; The ServiceActivationModel is not present in the Silverlight runtime
//          and the inclusion of the NotificationList.cs as a link will not compile because of this dependency. For now
//          the caller of the NotificationProxy will have to parse the response and extract the necessary information.
namespace Leet.Silverlight.RESTProxy.NotificationProxy
{
    using System;
    using System.Net;
    using AsyncMultiplayer.NotificationService;
    using Gds;

    /// <summary>
    /// Silverlight helper client proxy class to interface with the Profile REST service
    /// </summary>
    public class NotificationProxy : INotificationProxy
    {
        private const string InvalidUrlExceptionMessage = "The Uri provided is in an invalid format";
        private const string InvalidStringExceptionMessage = "The provided string or object is either null or empty";
        private const string XmlContentType = "application/xml";

        // Different services have different query strings + optional fields supplied via NotificationOptionalFields
        private const string GetNotificationSpecificGameRelativePathAndQuery              = "?game={gameId}&variant={variant}";
        private const string GetNotificationSpecificSessionRelativePathAndQuery           = "?game={gameId}&session={sessionId}";
        private const string DeleteNotificationRelativePathAndQuery                       = "delete/?notification={notificationId}";
        private const string DeleteAllNotificationsForSpecificSessionRelativePathAndQuery = "deletesession/?game={gameId}&session={sessionId}";
        private const string UpdateNotificationRelativePathAndQuery                       = "update/?notification={notificationId}&status={status}";
        private const string PostInviteRelativePathAndQuery                               = "invite/";
        private const string GetSpotlightRelativePathAndQuery                             = "spotlight/?carrier={carrierString}";

        /// <summary>
        /// Overloaded constructor
        /// </summary>
        /// <param name="uriNotificationService"></param>
        public NotificationProxy(
            Uri uriNotificationService)
            : this(
                 uriNotificationService,
                 null,
                 null)
        {
        }

        /// <summary>
        /// Constructor of NotificationProxy
        /// </summary>
        /// <param name="uriNotificationService">The Uri for the NotificationFE service</param>
        /// <param name="colWebHeaders"></param>
        public NotificationProxy(
            Uri uriNotificationService,
            WebHeaderCollection colWebHeaders,
            CookieContainer containerCookies)
        {
            if (!uriNotificationService.IsAbsoluteUri)
            {
                throw new ArgumentException(NotificationProxy.InvalidUrlExceptionMessage, "uriNotificationService");
            }

            this.NotificationService = uriNotificationService;
            this.WebHeaders = colWebHeaders;
            this.Cookies = containerCookies;
        }

        /// <summary>
        /// Prevents a default instance of the NotificationProxy class from being created.
        /// </summary>
        private NotificationProxy()
        {
        }

        /// <summary>
        /// Callback triggered after corresponding *Async() method is called
        /// </summary>
        public event EventHandler<NotificationProxyEventArgs<string>> OnGetNotificationCompleted;

        public event EventHandler<NotificationProxyEventArgs<string>> OnDeleteNotificationCompleted;

        public event EventHandler<NotificationProxyEventArgs<string>> OnUpdateNotificationCompleted;

        public event EventHandler<NotificationProxyEventArgs<string>> OnPostInviteCompleted;

        public event EventHandler<NotificationProxyEventArgs<string>> OnGetSpotlightCompleted;

        private Uri NotificationService { get; set; }

        // The STS token is included in these headers
        private WebHeaderCollection WebHeaders { get; set; }

        private CookieContainer Cookies { get; set; }

        /// <summary>
        /// Retrieve notification information from the NotificationFE service
        /// </summary>
        public void GetNotificationAsync(NotificationOptionalFields optionalFields)
        {
            // Optional fields are *optional*
            if (optionalFields == null)
            {
                throw new ArgumentNullException(NotificationProxy.InvalidStringExceptionMessage, "optionalFields");
            }

            // URL for the NotificationFE service
            string fullUri = UtilityFunctions.GetUriTemplate(this.NotificationService, String.Empty);

            // Remove the ampersand from the beginning of the optional field string because there is no parameters preceding it in this API
            string optionalFieldsMinusAmpersand = optionalFields.URLString().Remove(0, 1);
            fullUri = String.Format("{0}?{1}", fullUri, optionalFieldsMinusAmpersand);

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetNotificationCompleted);
            httpClient.GetDataContractAsync<string>();
        }

        /// <summary>
        /// Retrieve notification information from the NotificationFE service for the specific game
        /// </summary>
        public void GetNotificationForSpecificGameAsync(uint gameId, uint gameVariant, NotificationOptionalFields optionalFields)
        {
            // URL for the NotificationFE service
            string fullUri = UtilityFunctions.GetUriTemplate(this.NotificationService, NotificationProxy.GetNotificationSpecificGameRelativePathAndQuery);
            fullUri = fullUri.Replace("{gameId}", gameId.ToString());
            fullUri = fullUri.Replace("{variant}", gameVariant.ToString());

            // Optional fields are *optional*
            if (optionalFields != null)
            {
                fullUri = fullUri + optionalFields.URLString();
            }

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetNotificationCompleted);
            httpClient.GetDataContractAsync<string>();
        }

        /// <summary>
        /// Retrieve notification information from the NotificationFE service for the specific game session
        /// </summary>
        public void GetNotificationForSpecificSessionAsync(uint gameId, string sessionId, NotificationOptionalFields optionalFields)
        {
            if (string.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(NotificationProxy.InvalidStringExceptionMessage, "sessionId");
            }

            // URL for the NotificationFE service
            string fullUri = UtilityFunctions.GetUriTemplate(this.NotificationService, NotificationProxy.GetNotificationSpecificSessionRelativePathAndQuery);
            fullUri = fullUri.Replace("{gameId}", gameId.ToString());
            fullUri = fullUri.Replace("{sessionId}", sessionId);

            // Optional fields are *optional*
            if (optionalFields != null)
            {
                fullUri = fullUri + optionalFields.URLString();
            }

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetNotificationCompleted);
            httpClient.GetDataContractAsync<string>();
        }

        /// <summary>
        /// Deletes an existing notification specified by its notification ID
        /// </summary>
        public void DeleteNotificationAsync(string notificationId)
        {
            if (string.IsNullOrEmpty(notificationId))
            {
                throw new ArgumentException(NotificationProxy.InvalidStringExceptionMessage, "notificationId");
            }

            // URL for the NotificationFE service
            string fullUri = UtilityFunctions.GetUriTemplate(this.NotificationService, NotificationProxy.DeleteNotificationRelativePathAndQuery);
            fullUri = fullUri.Replace("{notificationId}", notificationId);

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.ContentType = NotificationProxy.XmlContentType;
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnDeleteNotificationCompleted);
            httpClient.DeleteDataContractAsync<string>(null);
       }

        /// <summary>
        /// Deletes all notifications for a specific game session
        /// </summary>
        public void DeleteAllNotificationsForSpecificSessionAsync(uint gameId, string sessionId)
        {
            if (string.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(NotificationProxy.InvalidStringExceptionMessage, "sessionId");
            }

            // URL for the NotificationFE service
            string fullUri = UtilityFunctions.GetUriTemplate(this.NotificationService, NotificationProxy.DeleteAllNotificationsForSpecificSessionRelativePathAndQuery);
            fullUri = fullUri.Replace("{gameId}", gameId.ToString());
            fullUri = fullUri.Replace("{sessionId}", sessionId);

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.ContentType = NotificationProxy.XmlContentType;
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnDeleteNotificationCompleted);
            httpClient.DeleteDataContractAsync<string>(null);
        }

        /// <summary>
        /// Update an existing notification specified by its notification ID with the new status (e.g. Viewed)
        /// </summary>
        public void UpdateNotificationAsync(string notificationId, string status)
        {
            if (string.IsNullOrEmpty(notificationId))
            {
                throw new ArgumentException(NotificationProxy.InvalidStringExceptionMessage, "notificationId");
            }

            if (string.IsNullOrEmpty(status))
            {
                throw new ArgumentException(NotificationProxy.InvalidStringExceptionMessage, "status");
            }

            // URL for the NotificationFE service
            string fullUri = UtilityFunctions.GetUriTemplate(this.NotificationService, NotificationProxy.UpdateNotificationRelativePathAndQuery);
            fullUri = fullUri.Replace("{notificationId}", notificationId);
            fullUri = fullUri.Replace("{status}", status);

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.ContentType = NotificationProxy.XmlContentType;
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnUpdateNotificationCompleted);
            httpClient.PutDataContractAsync<string, string>(String.Empty);
        }

        /// <summary>
        /// Schedules an invite request to be queued and sent via SMTP
        /// </summary>
        public void PostInviteAsync(InviteRequest inviteReq)
        {
            // URL for the NotificationFE service
            string fullUri = UtilityFunctions.GetUriTemplate(this.NotificationService, NotificationProxy.PostInviteRelativePathAndQuery);

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.ContentType = NotificationProxy.XmlContentType;
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnPostInviteCompleted);
            httpClient.PostDataContractAsync<InviteRequest, string>(inviteReq);
        }

        /// <summary>
        /// Get Spotlight feed items from the CMS store
        /// NOTE: carrierString is currently unused by the mobile platform
        /// </summary>
        public void GetSpotlightAsync(string carrierString)
        {
            if (string.IsNullOrEmpty(carrierString))
            {
                carrierString = String.Empty;
            }

            // URL for the NotificationFE service
            string fullUri = UtilityFunctions.GetUriTemplate(this.NotificationService, NotificationProxy.GetSpotlightRelativePathAndQuery);
            fullUri = fullUri.Replace("{carrierString}", carrierString);

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetSpotlightCompleted);
            httpClient.GetDataContractAsync<string>();
        }

        private void HttpClient_OnGetNotificationCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnGetNotificationCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        private void HttpClient_OnDeleteNotificationCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnDeleteNotificationCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        private void HttpClient_OnUpdateNotificationCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnUpdateNotificationCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        private void HttpClient_OnPostInviteCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnPostInviteCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        private void HttpClient_OnGetSpotlightCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnGetSpotlightCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
        /// <param name="responseObject">Object</param>
        private void FireOnGetNotificationCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<NotificationProxyEventArgs<string>> tmpEvent = this.OnGetNotificationCompleted;
            if (tmpEvent != null)
            {
                NotificationProxyEventArgs<string> npea = new NotificationProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, npea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
        /// <param name="responseObject">Object</param>
        private void FireOnDeleteNotificationCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<NotificationProxyEventArgs<string>> tmpEvent = this.OnDeleteNotificationCompleted;
            if (tmpEvent != null)
            {
                NotificationProxyEventArgs<string> npea = new NotificationProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, npea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
        /// <param name="responseObject">Object</param>
        private void FireOnUpdateNotificationCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<NotificationProxyEventArgs<string>> tmpEvent = this.OnUpdateNotificationCompleted;
            if (tmpEvent != null)
            {
                NotificationProxyEventArgs<string> npea = new NotificationProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, npea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
        /// <param name="responseObject">Object</param>
        private void FireOnPostInviteCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<NotificationProxyEventArgs<string>> tmpEvent = this.OnPostInviteCompleted;
            if (tmpEvent != null)
            {
                NotificationProxyEventArgs<string> npea = new NotificationProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, npea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
        /// <param name="responseObject">Object</param>
        private void FireOnGetSpotlightCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<NotificationProxyEventArgs<string>> tmpEvent = this.OnGetSpotlightCompleted;
            if (tmpEvent != null)
            {
                NotificationProxyEventArgs<string> npea = new NotificationProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, npea);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\ProfileProxy\IProfileProxy.cs ===
namespace Leet.Silverlight.RESTProxy.ProfileProxy
{
    using System;
    using Leet.UserGameData.DataContracts;

    public interface IProfileProxy
    {
        /// <summary>
        /// Callback triggered after corresponding *Async() method is called
        /// </summary>
        event EventHandler<ProfileProxyEventArgs<Profile>> OnGetProfileCompleted;

        /// <summary>
        /// Retrieve my profile information from the profile service
        /// SectionFlags bit field
        /// XBOXLiveProperties   WindowsLiveProperties   Friends   RecentGames   RecentAchievements
        /// -----------------------------------------------------------------------------------------
        ///          1         |           2           |    4    |      8      |         16         |
        /// ------------------------------------------------------------------------------------------
        /// </summary>
        void GetProfileAsync(uint sectionFlags);

        /// <summary>
        /// Retrieve target profile information from the profile service based on the gamertag
        /// SectionFlags bit field
        /// XBOXLiveProperties   WindowsLiveProperties   Friends   RecentGames   RecentAchievements
        /// -----------------------------------------------------------------------------------------
        ///          1         |           2           |    4    |      8      |         16         |
        /// ------------------------------------------------------------------------------------------
        /// </summary>
        void GetProfileAsync(uint sectionFlags, string gamertag);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\RewardsProxy\IRewardsProxy.cs ===
namespace Gds
{
    using System;
    using Gds.Contracts;

    public interface IRewardsProxy
    {
        /// <summary>
        /// Callback triggered after corresponding *Async() method is called
        /// </summary>
        event EventHandler<RewardsProxyEventArgs<string>> OnPostGameResultCompleted;

        event EventHandler<RewardsProxyEventArgs<LeaderboardResult>> OnGetLeaderboardCompleted;

        event EventHandler<RewardsProxyEventArgs<AchievementsResult>> OnGetAchievementsCompleted;

        event EventHandler<RewardsProxyEventArgs<DatablobResult>> OnGetDataBlobCompleted;

        /// <summary>
        /// Submit the GameResult event to the rewards service for processing
        /// </summary>
        /// <param name="gr">The GameResult data e.g. score or time</param>
        void PostGameResultAsync(GameResult gr);

        /// <summary>
        /// Retrieve the leaderboard information from the rewards service
        /// </summary>
        void GetLeaderboardAroundSelfAsync(uint gameId, uint gameVariant, string property, string datagroup, uint numRows, uint socialGraph);

        void GetLeaderboardAsync(uint gameId, uint gameVariant, string property, string datagroup, uint maxResults);

        /// <summary>
        /// Retrieve the leaderboard information from the rewards service
        /// </summary>
        void GetLeaderboardAsync(uint gameId, uint gameVariant, string property, string datagroup, uint numRows, uint rankStart, uint socialGraph);

        /// <summary>
        /// Retrieve the Achievements information from the rewards service
        /// </summary>
        void GetAchievementsAsync(uint gameId, string locale);

        void GetDataBlob(string rpsTicket, Guid dataBlobId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Silverlight.RESTProxy")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// This allows internal methods to visible to the SilverlightTests project
[assembly: InternalsVisibleTo("SilverlightTests")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3038a707-1f40-49b2-b3ad-de25cbfa17a4")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\ProfileProxy\ProfileProxyEventArgs.cs ===
﻿namespace Leet.Silverlight.RESTProxy.ProfileProxy
{
    using System;
    using System.ComponentModel;

    public class ProfileProxyEventArgs<ReturnType> : AsyncCompletedEventArgs
    {
        private object result;

        internal ProfileProxyEventArgs(object objectResult, Exception exception, bool cancelled, object userToken)
            : base(exception, cancelled, userToken)
        {
            this.result = objectResult;
        }

        public ReturnType Result
        {
            get
            {
                RaiseExceptionIfNecessary();

                if (this.result.GetType() == typeof(ReturnType))
                {
                    return (ReturnType)this.result;
                }

                return default(ReturnType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\WebAuthProxy\IWebAuthProxy.cs ===
namespace Leet.Silverlight.RESTProxy.WebAuthProxy
{
    using System;

    public interface IWebAuthProxy
    {
        event EventHandler<WebAuthProxyEventArgs> OnWebAuthRequestCompleted;

        void GetUserTokenHTTP(uint gameId, uint gameVersion);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\NotificationProxy\SerializableAttribute.cs ===
﻿namespace AsyncMultiplayer.NotificationService
{
    using System;

    /// <summary>
    /// This class is needed to be able to include service files directly.
    /// Silverlight doesn't support the [Serializable] attribute so we need to custom handle it here.
    /// </summary>
    [AttributeUsage(AttributeTargets.All)]
    internal class SerializableAttribute : System.Attribute 
    {
        /// <summary>
        ///  Initializes a new instance of the SerializableAttribute class.
        /// </summary>
        public SerializableAttribute()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\RewardsProxy\RewardsProxyEventArgs.cs ===
﻿namespace Gds
{
    using System;
    using System.ComponentModel;

    public class RewardsProxyEventArgs<ReturnType> : AsyncCompletedEventArgs
    {
        private object result;

        internal RewardsProxyEventArgs(object objectResult, Exception exception, bool cancelled, object userToken)
            : base(exception, cancelled, userToken)
        {
            this.result = objectResult;
        }

        public ReturnType Result
        {
            get
            {
                RaiseExceptionIfNecessary();

                if (this.result.GetType() == typeof(ReturnType))
                {
                    return (ReturnType)this.result;
                }

                return default(ReturnType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\RewardsProxy\RewardsProxy.cs ===
﻿namespace Gds
{
    using System;
    using System.Net;
    using Gds.Contracts;
    using Leet.Silverlight.RESTProxy;

    /// <summary>
    /// Silverlight helper client proxy class to interface with the Rewards REST service
    /// </summary>
    public class RewardsProxy : IRewardsProxy
    {
        private const string InvalidUrlExceptionMessage = "The Uri provided is in an invalid format";
        private const string InvalidStringExceptionMessage = "The provided string is either null or empty";
        private const string XmlContentType = "application/xml";

        // Different services have different query strings
        private const string PostGameResultRelativePathAndQuery = "GameResult?format=xml";
        private const string GetLeaderBoardRelativePathAndQuery = "leaderboard?format=xml&gameId={gameId}&variant={variant}&property={property}&datagroup={datagroup}&numRows={numRows}&rankStart={rankStart}&socialGraph={socialGraph}";
        private const string GetAchievementsRelativePathAndQuery = "achievements?format=xml&gameId={gameId}";
        private const string GetDataBlobRelativePathAndQuery = "statistics/datablobId/{dataBlobId}?format=xml";

        // Fixed strings
        private const string UrlScheme = "http";

        /// <summary>
        /// Overloaded constructor
        /// </summary>
        /// <param name="uriRewardsService"></param>
        /// <param name="uriGameData"></param>
        /// <param name="uriGameStatistics"></param>
        public RewardsProxy(
                    Uri uriRewardsService,
                    Uri uriGameData,
                    Uri uriGameStatistics)
            : this(
                    uriRewardsService,
                    uriGameData,
                    uriGameStatistics,
                    null,
                    null)
        {
        }

        /// <summary>
        /// Constructor of RewardsProxy
        /// </summary>
        /// <param name="uriRewardsService">The Uri for the Rewards Service</param>
        /// <param name="uriGameData">The Uri for the Game Data Service</param>
        /// <param name="uriGameStatistics">The Uri for the Game Statistics Service</param>
        public RewardsProxy(
                    Uri uriRewardsService, 
                    Uri uriGameData, 
                    Uri uriGameStatistics, 
                    WebHeaderCollection colWebHeaders, 
                    CookieContainer containerCookies)
        {
            if (!uriRewardsService.IsAbsoluteUri)
            {
                throw new ArgumentException(RewardsProxy.InvalidUrlExceptionMessage, "uriRewardsService");
            }

            if (!uriGameData.IsAbsoluteUri)
            {
                throw new ArgumentException(RewardsProxy.InvalidUrlExceptionMessage, "uriGameData");
            }

            if (!uriGameStatistics.IsAbsoluteUri)
            {
                throw new ArgumentException(RewardsProxy.InvalidUrlExceptionMessage, "uriGameStatistics");
            }

            this.RewardsService = uriRewardsService;
            this.GameData = uriGameData;
            this.GameStatistics = uriGameStatistics;
            this.WebHeaders = colWebHeaders;
            this.Cookies = containerCookies;
        }

        /// <summary>
        /// Callback triggered after corresponding *Async() method is called
        /// </summary>
        public event EventHandler<RewardsProxyEventArgs<string>> OnPostGameResultCompleted;

        public event EventHandler<RewardsProxyEventArgs<LeaderboardResult>> OnGetLeaderboardCompleted;

        public event EventHandler<RewardsProxyEventArgs<AchievementsResult>> OnGetAchievementsCompleted;

        public event EventHandler<RewardsProxyEventArgs<DatablobResult>> OnGetDataBlobCompleted;

        private Uri RewardsService { get; set; }

        private Uri GameData { get; set; }

        private Uri GameStatistics { get; set; }

        // The STS token is included in these headers
        private WebHeaderCollection WebHeaders { get; set; }

        private CookieContainer Cookies { get; set; }

        /// <summary>
        /// Submit the GameResult event to the rewards service for processing
        /// </summary>
        /// <param name="gr">The GameResult data e.g. score or time</param>
        public void PostGameResultAsync(GameResult gr)
        {
            // URL for the PostGameResult service
            string fullUri = UtilityFunctions.GetUriTemplate(this.RewardsService, RewardsProxy.PostGameResultRelativePathAndQuery);
            Uri serviceUri = new Uri(fullUri);

            HttpClient httpClient = HttpClient.GetHttpClient(serviceUri, HttpStack.SilverlightClientStack);
            httpClient.ContentType = RewardsProxy.XmlContentType;
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnPostDataContractCompleted);
            httpClient.PostDataContractAsync<GameResult, string>(gr);
        }

        /// <summary>
        /// Retrieve the leaderboard information from the rewards service
        /// </summary>
        public void GetLeaderboardAroundSelfAsync(uint gameId, uint gameVariant, string property, string datagroup, uint numRows, uint socialGraph)
        {
            this.GetLeaderboardAsync(gameId, gameVariant, property, datagroup, numRows, 0, socialGraph);
        }

        public void GetLeaderboardAsync(uint gameId, uint gameVariant, string property, string datagroup, uint maxResults)
        {
            this.GetLeaderboardAsync(gameId, gameVariant, property, datagroup, maxResults, 0, (uint)LeetSocialGraphs.XboxLiveFriends);
        }

        /// <summary>
        /// Retrieve the leaderboard information from the rewards service
        /// </summary>
        public void GetLeaderboardAsync(uint gameId, uint gameVariant, string property, string datagroup, uint numRows, uint rankStart, uint socialGraph)
        {
            if (string.IsNullOrEmpty(datagroup))
            {
                throw new ArgumentException(RewardsProxy.InvalidStringExceptionMessage, "datagroup");
            }

            if (numRows < 1)
            {
                throw new ArgumentOutOfRangeException("numRows");
            }

            if (!Enum.IsDefined(typeof(LeetSocialGraphs), socialGraph))
            {
                throw new ArgumentOutOfRangeException("socialGraph");
            }

            // URL for the GetLeaderboard service
            string fullUri = UtilityFunctions.GetUriTemplate(this.GameData, RewardsProxy.GetLeaderBoardRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{gameId}", gameId.ToString());
            fullUri = fullUri.Replace("{variant}", gameVariant.ToString());
            fullUri = fullUri.Replace("{property}", property);
            fullUri = fullUri.Replace("{datagroup}", datagroup);
            fullUri = fullUri.Replace("{numRows}", numRows.ToString());
            fullUri = fullUri.Replace("{rankStart}", rankStart.ToString());
            fullUri = fullUri.Replace("{socialGraph}", socialGraph.ToString());

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetDataContractCompleted);
            httpClient.GetDataContractAsync<LeaderboardResult>();
        }

        /// <summary>
        /// Retrieve the Achievements information from the rewards service
        /// </summary>
        public void GetAchievementsAsync(uint gameId, string locale)
        {
            // URL for the achievement service
            string fullUri = UtilityFunctions.GetUriTemplate(this.GameData, RewardsProxy.GetAchievementsRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{gameId}", gameId.ToString());

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetAchievementsCompleted);
            httpClient.GetDataContractAsync<AchievementsResult>();
        }

        public void GetDataBlob(string rpsTicket, Guid dataBlobId)
        {
            string fullUri = UtilityFunctions.GetUriTemplate(this.GameStatistics, RewardsProxy.GetDataBlobRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{dataBlobId}", dataBlobId.ToString());

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetDataBlobCompleted);
            httpClient.GetDataContractAsync<DatablobResult>();
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
        /// <param name="responseObject">Object</param>
        private void FireOnPostGameResultCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<RewardsProxyEventArgs<string>> tmpEvent = this.OnPostGameResultCompleted;
            if (tmpEvent != null)
            {
                RewardsProxyEventArgs<string> rpea = new RewardsProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, rpea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
        /// <param name="responseObject">Object</param>
        private void FireOnGetLeaderboardCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<RewardsProxyEventArgs<LeaderboardResult>> tmpEvent = this.OnGetLeaderboardCompleted;
            if (tmpEvent != null)
            {
                RewardsProxyEventArgs<LeaderboardResult> rpea = new RewardsProxyEventArgs<LeaderboardResult>(responseObject, exception, false, null);
                tmpEvent(this, rpea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
         /// <param name="responseObject">Object</param>
        private void FireOnGetAchievementsCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<RewardsProxyEventArgs<AchievementsResult>> tmpEvent = this.OnGetAchievementsCompleted;
            if (tmpEvent != null)
            {
                RewardsProxyEventArgs<AchievementsResult> rpea = new RewardsProxyEventArgs<AchievementsResult>(responseObject, exception, false, null);
                tmpEvent(this, rpea);
            }
        }

        private void FireOnGetDataBlobCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<RewardsProxyEventArgs<DatablobResult>> tmpEvent = this.OnGetDataBlobCompleted;
            if (tmpEvent != null)
            {
                RewardsProxyEventArgs<DatablobResult> rpea = new RewardsProxyEventArgs<DatablobResult>(responseObject, exception, false, null);
                tmpEvent(this, rpea);
            }
        }

        private void HttpClient_OnGetDataContractCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnGetLeaderboardCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        private void HttpClient_OnGetAchievementsCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnGetAchievementsCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        private void HttpClient_OnPostDataContractCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnPostGameResultCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        private void HttpClient_OnGetDataBlobCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnGetDataBlobCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\ProfileProxy\ProfileProxy.cs ===
﻿namespace Leet.Silverlight.RESTProxy.ProfileProxy
{
    using System;
    using System.Net;
    using Gds;
    using Leet.UserGameData.DataContracts;

    /// <summary>
    /// Silverlight helper client proxy class to interface with the Profile REST service
    /// </summary>
    public class ProfileProxy : IProfileProxy
    {
        private const string InvalidUrlExceptionMessage = "The Uri provided is in an invalid format";
        private const string InvalidStringExceptionMessage = "The provided string is either null or empty";

        // Different services have different query strings
        private const string GetProfileRelativePathAndQuery = "profile?format=xml&sectionflags={sectionFlags}";
        private const string GetTargetProfileRelativePathAndQuery = "profile?format=xml&sectionflags={sectionFlags}&gamertag={gamertag}";

        // Fixed strings
        private const string UrlScheme = "http";

        /// <summary>
        /// Overloaded constructor
        /// </summary>
        /// <param name="uriProfileService"></param>
        public ProfileProxy(
            Uri uriProfileService)
            : this(
                uriProfileService,
                null,
                null)
        {
        }

        /// <summary>
        /// Constructor of ProfileProxyClient
        /// </summary>
        /// <param name="uriProfileService">The Uri for the Profile Service</param>
        public ProfileProxy(
            Uri uriProfileService,
            WebHeaderCollection colWebHeaders,
            CookieContainer containerCookies)
        {
            if (!uriProfileService.IsAbsoluteUri)
            {
                throw new ArgumentException(ProfileProxy.InvalidUrlExceptionMessage, "uriProfileService");
            }

            this.ProfileService = uriProfileService;
            this.WebHeaders = colWebHeaders;
            this.Cookies = containerCookies;
        }

        /// <summary>
        /// Callback triggered after corresponding *Async() method is called
        /// </summary>
        public event EventHandler<ProfileProxyEventArgs<Profile>> OnGetProfileCompleted;

        private Uri ProfileService { get; set; }

        // The STS token is included in these headers
        private WebHeaderCollection WebHeaders { get; set; }

        private CookieContainer Cookies { get; set; }

        /// <summary>
        /// Retrieve the currently signed in users profile information from the profile service
        /// SectionFlags bit field (defined in Leet.UserGameData.DataContracts::ProfileSections)
        /// XBOXLiveProperties   WindowsLiveProperties   Friends   RecentGames   RecentAchievements
        /// -----------------------------------------------------------------------------------------
        ///          1         |           2           |    4    |      8      |         16         |
        /// ------------------------------------------------------------------------------------------
        /// </summary>
        public void GetProfileAsync(uint sectionFlags)
        {
            // URL for the GetProfile service
            string fullUri = UtilityFunctions.GetUriTemplate(this.ProfileService, ProfileProxy.GetProfileRelativePathAndQuery);
            fullUri = fullUri.Replace("{sectionFlags}", sectionFlags.ToString());

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetProfileCompleted);
            httpClient.GetDataContractAsync<Profile>();
        }

        /// <summary>
        /// Retrieve target profile information from the profile service based on the gamertag
        /// SectionFlags bit field
        /// XBOXLiveProperties   WindowsLiveProperties   Friends   RecentGames   RecentAchievements
        /// -----------------------------------------------------------------------------------------
        ///          1         |           2           |    4    |      8      |         16         |
        /// ------------------------------------------------------------------------------------------
        /// </summary>
        public void GetProfileAsync(uint sectionFlags, string gamertag)
        {
            if (string.IsNullOrEmpty(gamertag))
            {
                throw new ArgumentException(ProfileProxy.InvalidStringExceptionMessage, "gamertag");
            }

            // URL for the GetProfile service
            string fullUri = UtilityFunctions.GetUriTemplate(this.ProfileService, ProfileProxy.GetTargetProfileRelativePathAndQuery);
            fullUri = fullUri.Replace("{sectionFlags}", sectionFlags.ToString());
            fullUri = fullUri.Replace("{gamertag}", gamertag);

            HttpClient httpClient = HttpClient.GetHttpClient(fullUri, HttpStack.SilverlightClientStack);
            httpClient.Headers = this.WebHeaders;
            httpClient.Cookies = this.Cookies;

            httpClient.OnRequestCompleted += new EventHandler<HttpClientEventArgs>(this.HttpClient_OnGetProfileCompleted);
            httpClient.GetDataContractAsync<Profile>();
        }

        private void HttpClient_OnGetProfileCompleted(object sender, HttpClientEventArgs e)
        {
            this.FireOnGetProfileCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception</param>
        /// <param name="responseObject">Object</param>
        private void FireOnGetProfileCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<ProfileProxyEventArgs<Profile>> tmpEvent = this.OnGetProfileCompleted;
            if (tmpEvent != null)
            {
                ProfileProxyEventArgs<Profile> ppea = new ProfileProxyEventArgs<Profile>(responseObject, exception, false, null);
                tmpEvent(this, ppea);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Profile\Proxies\ABService.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

namespace Leet.Profile.Proxies
{
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "ABServiceSoap", Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ABService : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        private ABApplicationHeader aBApplicationHeaderValueField;

        private ABAuthHeader aBAuthHeaderValueField;

        private ABTestHeader aBTestHeaderValueField;

        private ServiceHeader serviceHeaderValueField;

        private System.Threading.SendOrPostCallback ABAddOperationCompleted;

        private System.Threading.SendOrPostCallback ABDeleteOperationCompleted;

        private System.Threading.SendOrPostCallback ABUpdateOperationCompleted;

        private System.Threading.SendOrPostCallback ABFindOperationCompleted;

        private System.Threading.SendOrPostCallback AddBrandIdOperationCompleted;

        private System.Threading.SendOrPostCallback DeleteBrandIdOperationCompleted;

        private System.Threading.SendOrPostCallback ABContactUpdateOperationCompleted;

        private System.Threading.SendOrPostCallback ABContactFindOperationCompleted;

        private System.Threading.SendOrPostCallback ABContactAddOperationCompleted;

        private System.Threading.SendOrPostCallback ABContactDeleteOperationCompleted;

        private System.Threading.SendOrPostCallback ABGroupAddOperationCompleted;

        private System.Threading.SendOrPostCallback ABGroupDeleteOperationCompleted;

        private System.Threading.SendOrPostCallback ABGroupUpdateOperationCompleted;

        private System.Threading.SendOrPostCallback ABGroupFindOperationCompleted;

        private System.Threading.SendOrPostCallback ABGroupContactAddOperationCompleted;

        private System.Threading.SendOrPostCallback ABGroupContactDeleteOperationCompleted;

        private System.Threading.SendOrPostCallback ABAllowListSetOperationCompleted;

        private System.Threading.SendOrPostCallback ABAllowListGetOperationCompleted;

        private System.Threading.SendOrPostCallback ABFindAllOperationCompleted;

        private System.Threading.SendOrPostCallback ABFindByContactsOperationCompleted;

        private System.Threading.SendOrPostCallback ABFindMessengerUsersOperationCompleted;

        private System.Threading.SendOrPostCallback ABFindByGroupsOperationCompleted;

        private System.Threading.SendOrPostCallback ABFindMeContactOperationCompleted;

        private System.Threading.SendOrPostCallback AddCategoryOperationCompleted;

        private System.Threading.SendOrPostCallback DeleteCategoryOperationCompleted;

        private System.Threading.SendOrPostCallback UpdateCategoryOperationCompleted;

        private System.Threading.SendOrPostCallback AddDynamicItemOperationCompleted;

        private System.Threading.SendOrPostCallback UpdateDynamicItemOperationCompleted;

        private System.Threading.SendOrPostCallback CircleUpdateOperationCompleted;

        private System.Threading.SendOrPostCallback ABSetForceFullSyncDateOperationCompleted;

        private System.Threading.SendOrPostCallback MergeABOperationCompleted;

        private System.Threading.SendOrPostCallback AddABNetworksOperationCompleted;

        private System.Threading.SendOrPostCallback DeleteABNetworkOperationCompleted;

        private System.Threading.SendOrPostCallback UpdateABNetworkOperationCompleted;

        private System.Threading.SendOrPostCallback ViewABNetworksOperationCompleted;

        private System.Threading.SendOrPostCallback CreateContactOperationCompleted;

        private System.Threading.SendOrPostCallback FindContactOperationCompleted;

        private System.Threading.SendOrPostCallback AddMessengerAddressOperationCompleted;

        private System.Threading.SendOrPostCallback UpdateContactOperationCompleted;

        private System.Threading.SendOrPostCallback DeleteContactOperationCompleted;

        private System.Threading.SendOrPostCallback BlockContactOperationCompleted;

        private System.Threading.SendOrPostCallback UnblockContactOperationCompleted;

        private System.Threading.SendOrPostCallback IsContactBlockedOperationCompleted;

        private System.Threading.SendOrPostCallback FindBlockedContactsOperationCompleted;

        private System.Threading.SendOrPostCallback SendContactMessageOperationCompleted;

        private System.Threading.SendOrPostCallback MakeConnectionOperationCompleted;

        private System.Threading.SendOrPostCallback ManageConnectionOperationCompleted;

        private System.Threading.SendOrPostCallback BreakConnectionOperationCompleted;

        private System.Threading.SendOrPostCallback ManageWLConnectionOperationCompleted;

        private System.Threading.SendOrPostCallback StateTransitionOperationCompleted;

        private System.Threading.SendOrPostCallback CreatePendingMemberOperationCompleted;

        private System.Threading.SendOrPostCallback FindWhatsNewSubscriptionsOperationCompleted;

        private System.Threading.SendOrPostCallback CircleUpdateInverseInfoOperationCompleted;

        private System.Threading.SendOrPostCallback ABFindContactsPagedOperationCompleted;

        private System.Threading.SendOrPostCallback ReplaceHandleOperationCompleted;

        private System.Threading.SendOrPostCallback ReserveAndFilterOperationCompleted;

        private System.Threading.SendOrPostCallback MigrateABOperationCompleted;

        private System.Threading.SendOrPostCallback GetGeoLocationOperationCompleted;

        private System.Threading.SendOrPostCallback SetGeoLocationOperationCompleted;

        /// <remarks/>
        public ABService()
        {
            this.Url = "http://pvt-contacts.msn-int.com:81/abservice/ABService.asmx";
        }

        public ABApplicationHeader ABApplicationHeaderValue
        {
            get
            {
                return this.aBApplicationHeaderValueField;
            }
            set
            {
                this.aBApplicationHeaderValueField = value;
            }
        }

        public ABAuthHeader ABAuthHeaderValue
        {
            get
            {
                return this.aBAuthHeaderValueField;
            }
            set
            {
                this.aBAuthHeaderValueField = value;
            }
        }

        public ABTestHeader ABTestHeaderValue
        {
            get
            {
                return this.aBTestHeaderValueField;
            }
            set
            {
                this.aBTestHeaderValueField = value;
            }
        }

        public ServiceHeader ServiceHeaderValue
        {
            get
            {
                return this.serviceHeaderValueField;
            }
            set
            {
                this.serviceHeaderValueField = value;
            }
        }

        /// <remarks/>
        public event ABAddCompletedEventHandler ABAddCompleted;

        /// <remarks/>
        public event ABDeleteCompletedEventHandler ABDeleteCompleted;

        /// <remarks/>
        public event ABUpdateCompletedEventHandler ABUpdateCompleted;

        /// <remarks/>
        public event ABFindCompletedEventHandler ABFindCompleted;

        /// <remarks/>
        public event AddBrandIdCompletedEventHandler AddBrandIdCompleted;

        /// <remarks/>
        public event DeleteBrandIdCompletedEventHandler DeleteBrandIdCompleted;

        /// <remarks/>
        public event ABContactUpdateCompletedEventHandler ABContactUpdateCompleted;

        /// <remarks/>
        public event ABContactFindCompletedEventHandler ABContactFindCompleted;

        /// <remarks/>
        public event ABContactAddCompletedEventHandler ABContactAddCompleted;

        /// <remarks/>
        public event ABContactDeleteCompletedEventHandler ABContactDeleteCompleted;

        /// <remarks/>
        public event ABGroupAddCompletedEventHandler ABGroupAddCompleted;

        /// <remarks/>
        public event ABGroupDeleteCompletedEventHandler ABGroupDeleteCompleted;

        /// <remarks/>
        public event ABGroupUpdateCompletedEventHandler ABGroupUpdateCompleted;

        /// <remarks/>
        public event ABGroupFindCompletedEventHandler ABGroupFindCompleted;

        /// <remarks/>
        public event ABGroupContactAddCompletedEventHandler ABGroupContactAddCompleted;

        /// <remarks/>
        public event ABGroupContactDeleteCompletedEventHandler ABGroupContactDeleteCompleted;

        /// <remarks/>
        public event ABAllowListSetCompletedEventHandler ABAllowListSetCompleted;

        /// <remarks/>
        public event ABAllowListGetCompletedEventHandler ABAllowListGetCompleted;

        /// <remarks/>
        public event ABFindAllCompletedEventHandler ABFindAllCompleted;

        /// <remarks/>
        public event ABFindByContactsCompletedEventHandler ABFindByContactsCompleted;

        /// <remarks/>
        public event ABFindMessengerUsersCompletedEventHandler ABFindMessengerUsersCompleted;

        /// <remarks/>
        public event ABFindByGroupsCompletedEventHandler ABFindByGroupsCompleted;

        /// <remarks/>
        public event ABFindMeContactCompletedEventHandler ABFindMeContactCompleted;

        /// <remarks/>
        public event AddCategoryCompletedEventHandler AddCategoryCompleted;

        /// <remarks/>
        public event DeleteCategoryCompletedEventHandler DeleteCategoryCompleted;

        /// <remarks/>
        public event UpdateCategoryCompletedEventHandler UpdateCategoryCompleted;

        /// <remarks/>
        public event AddDynamicItemCompletedEventHandler AddDynamicItemCompleted;

        /// <remarks/>
        public event UpdateDynamicItemCompletedEventHandler UpdateDynamicItemCompleted;

        /// <remarks/>
        public event CircleUpdateCompletedEventHandler CircleUpdateCompleted;

        /// <remarks/>
        public event ABSetForceFullSyncDateCompletedEventHandler ABSetForceFullSyncDateCompleted;

        /// <remarks/>
        public event MergeABCompletedEventHandler MergeABCompleted;

        /// <remarks/>
        public event AddABNetworksCompletedEventHandler AddABNetworksCompleted;

        /// <remarks/>
        public event DeleteABNetworkCompletedEventHandler DeleteABNetworkCompleted;

        /// <remarks/>
        public event UpdateABNetworkCompletedEventHandler UpdateABNetworkCompleted;

        /// <remarks/>
        public event ViewABNetworksCompletedEventHandler ViewABNetworksCompleted;

        /// <remarks/>
        public event CreateContactCompletedEventHandler CreateContactCompleted;

        /// <remarks/>
        public event FindContactCompletedEventHandler FindContactCompleted;

        /// <remarks/>
        public event AddMessengerAddressCompletedEventHandler AddMessengerAddressCompleted;

        /// <remarks/>
        public event UpdateContactCompletedEventHandler UpdateContactCompleted;

        /// <remarks/>
        public event DeleteContactCompletedEventHandler DeleteContactCompleted;

        /// <remarks/>
        public event BlockContactCompletedEventHandler BlockContactCompleted;

        /// <remarks/>
        public event UnblockContactCompletedEventHandler UnblockContactCompleted;

        /// <remarks/>
        public event IsContactBlockedCompletedEventHandler IsContactBlockedCompleted;

        /// <remarks/>
        public event FindBlockedContactsCompletedEventHandler FindBlockedContactsCompleted;

        /// <remarks/>
        public event SendContactMessageCompletedEventHandler SendContactMessageCompleted;

        /// <remarks/>
        public event MakeConnectionCompletedEventHandler MakeConnectionCompleted;

        /// <remarks/>
        public event ManageConnectionCompletedEventHandler ManageConnectionCompleted;

        /// <remarks/>
        public event BreakConnectionCompletedEventHandler BreakConnectionCompleted;

        /// <remarks/>
        public event ManageWLConnectionCompletedEventHandler ManageWLConnectionCompleted;

        /// <remarks/>
        public event StateTransitionCompletedEventHandler StateTransitionCompleted;

        /// <remarks/>
        public event CreatePendingMemberCompletedEventHandler CreatePendingMemberCompleted;

        /// <remarks/>
        public event FindWhatsNewSubscriptionsCompletedEventHandler FindWhatsNewSubscriptionsCompleted;

        /// <remarks/>
        public event CircleUpdateInverseInfoCompletedEventHandler CircleUpdateInverseInfoCompleted;

        /// <remarks/>
        public event ABFindContactsPagedCompletedEventHandler ABFindContactsPagedCompleted;

        /// <remarks/>
        public event ReplaceHandleCompletedEventHandler ReplaceHandleCompleted;

        /// <remarks/>
        public event ReserveAndFilterCompletedEventHandler ReserveAndFilterCompleted;

        /// <remarks/>
        public event MigrateABCompletedEventHandler MigrateABCompleted;

        /// <remarks/>
        public event GetGeoLocationCompletedEventHandler GetGeoLocationCompleted;

        /// <remarks/>
        public event SetGeoLocationCompletedEventHandler SetGeoLocationCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABAdd", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Guid ABAdd(ABInfo abInfo)
        {
            object[] results = this.Invoke("ABAdd", new object[] {
                                                                     abInfo});
            return ((System.Guid)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABAdd(ABInfo abInfo, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABAdd", new object[] {
                                                              abInfo}, callback, asyncState);
        }

        /// <remarks/>
        public System.Guid EndABAdd(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Guid)(results[0]));
        }

        /// <remarks/>
        public void ABAddAsync(ABInfo abInfo)
        {
            this.ABAddAsync(abInfo, null);
        }

        /// <remarks/>
        public void ABAddAsync(ABInfo abInfo, object userState)
        {
            if ((this.ABAddOperationCompleted == null))
            {
                this.ABAddOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABAddOperationCompleted);
            }
            this.InvokeAsync("ABAdd", new object[] {
                                                       abInfo}, this.ABAddOperationCompleted, userState);
        }

        private void OnABAddOperationCompleted(object arg)
        {
            if ((this.ABAddCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABAddCompleted(this, new ABAddCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABDelete", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABDelete(System.Guid abId)
        {
            this.Invoke("ABDelete", new object[] {
                                                     abId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABDelete(System.Guid abId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABDelete", new object[] {
                                                                 abId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABDelete(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABDeleteAsync(System.Guid abId)
        {
            this.ABDeleteAsync(abId, null);
        }

        /// <remarks/>
        public void ABDeleteAsync(System.Guid abId, object userState)
        {
            if ((this.ABDeleteOperationCompleted == null))
            {
                this.ABDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABDeleteOperationCompleted);
            }
            this.InvokeAsync("ABDelete", new object[] {
                                                          abId}, this.ABDeleteOperationCompleted, userState);
        }

        private void OnABDeleteOperationCompleted(object arg)
        {
            if ((this.ABDeleteCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABUpdate", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABUpdate(AB ab)
        {
            this.Invoke("ABUpdate", new object[] {
                                                     ab});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABUpdate(AB ab, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABUpdate", new object[] {
                                                                 ab}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABUpdate(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABUpdateAsync(AB ab)
        {
            this.ABUpdateAsync(ab, null);
        }

        /// <remarks/>
        public void ABUpdateAsync(AB ab, object userState)
        {
            if ((this.ABUpdateOperationCompleted == null))
            {
                this.ABUpdateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABUpdateOperationCompleted);
            }
            this.InvokeAsync("ABUpdate", new object[] {
                                                          ab}, this.ABUpdateOperationCompleted, userState);
        }

        private void OnABUpdateOperationCompleted(object arg)
        {
            if ((this.ABUpdateCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABUpdateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABFind", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AB[] ABFind(long ownerPuid, long ownerCID)
        {
            object[] results = this.Invoke("ABFind", new object[] {
                                                                      ownerPuid,
                                                                      ownerCID});
            return ((AB[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABFind(long ownerPuid, long ownerCID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABFind", new object[] {
                                                               ownerPuid,
                                                               ownerCID}, callback, asyncState);
        }

        /// <remarks/>
        public AB[] EndABFind(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((AB[])(results[0]));
        }

        /// <remarks/>
        public void ABFindAsync(long ownerPuid, long ownerCID)
        {
            this.ABFindAsync(ownerPuid, ownerCID, null);
        }

        /// <remarks/>
        public void ABFindAsync(long ownerPuid, long ownerCID, object userState)
        {
            if ((this.ABFindOperationCompleted == null))
            {
                this.ABFindOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABFindOperationCompleted);
            }
            this.InvokeAsync("ABFind", new object[] {
                                                        ownerPuid,
                                                        ownerCID}, this.ABFindOperationCompleted, userState);
        }

        private void OnABFindOperationCompleted(object arg)
        {
            if ((this.ABFindCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABFindCompleted(this, new ABFindCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/AddBrandId", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddBrandId(string brandId, bool master)
        {
            this.Invoke("AddBrandId", new object[] {
                                                       brandId,
                                                       master});
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddBrandId(string brandId, bool master, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddBrandId", new object[] {
                                                                   brandId,
                                                                   master}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddBrandId(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void AddBrandIdAsync(string brandId, bool master)
        {
            this.AddBrandIdAsync(brandId, master, null);
        }

        /// <remarks/>
        public void AddBrandIdAsync(string brandId, bool master, object userState)
        {
            if ((this.AddBrandIdOperationCompleted == null))
            {
                this.AddBrandIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddBrandIdOperationCompleted);
            }
            this.InvokeAsync("AddBrandId", new object[] {
                                                            brandId,
                                                            master}, this.AddBrandIdOperationCompleted, userState);
        }

        private void OnAddBrandIdOperationCompleted(object arg)
        {
            if ((this.AddBrandIdCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddBrandIdCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/DeleteBrandId", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteBrandId(string brandId)
        {
            this.Invoke("DeleteBrandId", new object[] {
                                                          brandId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteBrandId(string brandId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteBrandId", new object[] {
                                                                      brandId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteBrandId(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void DeleteBrandIdAsync(string brandId)
        {
            this.DeleteBrandIdAsync(brandId, null);
        }

        /// <remarks/>
        public void DeleteBrandIdAsync(string brandId, object userState)
        {
            if ((this.DeleteBrandIdOperationCompleted == null))
            {
                this.DeleteBrandIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteBrandIdOperationCompleted);
            }
            this.InvokeAsync("DeleteBrandId", new object[] {
                                                               brandId}, this.DeleteBrandIdOperationCompleted, userState);
        }

        private void OnDeleteBrandIdOperationCompleted(object arg)
        {
            if ((this.DeleteBrandIdCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteBrandIdCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABContactUpdate", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABContactUpdate(System.Guid abId, Contact[] contacts, ContactUpdateOptions options)
        {
            this.Invoke("ABContactUpdate", new object[] {
                                                            abId,
                                                            contacts,
                                                            options});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABContactUpdate(System.Guid abId, Contact[] contacts, ContactUpdateOptions options, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABContactUpdate", new object[] {
                                                                        abId,
                                                                        contacts,
                                                                        options}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABContactUpdate(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABContactUpdateAsync(System.Guid abId, Contact[] contacts, ContactUpdateOptions options)
        {
            this.ABContactUpdateAsync(abId, contacts, options, null);
        }

        /// <remarks/>
        public void ABContactUpdateAsync(System.Guid abId, Contact[] contacts, ContactUpdateOptions options, object userState)
        {
            if ((this.ABContactUpdateOperationCompleted == null))
            {
                this.ABContactUpdateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABContactUpdateOperationCompleted);
            }
            this.InvokeAsync("ABContactUpdate", new object[] {
                                                                 abId,
                                                                 contacts,
                                                                 options}, this.ABContactUpdateOperationCompleted, userState);
        }

        private void OnABContactUpdateOperationCompleted(object arg)
        {
            if ((this.ABContactUpdateCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABContactUpdateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABContactFind", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ContactFindResult ABContactFind(System.Guid abId, ContactFilter contactFilter)
        {
            object[] results = this.Invoke("ABContactFind", new object[] {
                                                                             abId,
                                                                             contactFilter});
            return ((ContactFindResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABContactFind(System.Guid abId, ContactFilter contactFilter, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABContactFind", new object[] {
                                                                      abId,
                                                                      contactFilter}, callback, asyncState);
        }

        /// <remarks/>
        public ContactFindResult EndABContactFind(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((ContactFindResult)(results[0]));
        }

        /// <remarks/>
        public void ABContactFindAsync(System.Guid abId, ContactFilter contactFilter)
        {
            this.ABContactFindAsync(abId, contactFilter, null);
        }

        /// <remarks/>
        public void ABContactFindAsync(System.Guid abId, ContactFilter contactFilter, object userState)
        {
            if ((this.ABContactFindOperationCompleted == null))
            {
                this.ABContactFindOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABContactFindOperationCompleted);
            }
            this.InvokeAsync("ABContactFind", new object[] {
                                                               abId,
                                                               contactFilter}, this.ABContactFindOperationCompleted, userState);
        }

        private void OnABContactFindOperationCompleted(object arg)
        {
            if ((this.ABContactFindCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABContactFindCompleted(this, new ABContactFindCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABContactAdd", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Guid[] ABContactAdd(System.Guid abId, Contact[] contacts, ContactAddOptions options)
        {
            object[] results = this.Invoke("ABContactAdd", new object[] {
                                                                            abId,
                                                                            contacts,
                                                                            options});
            return ((System.Guid[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABContactAdd(System.Guid abId, Contact[] contacts, ContactAddOptions options, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABContactAdd", new object[] {
                                                                     abId,
                                                                     contacts,
                                                                     options}, callback, asyncState);
        }

        /// <remarks/>
        public System.Guid[] EndABContactAdd(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Guid[])(results[0]));
        }

        /// <remarks/>
        public void ABContactAddAsync(System.Guid abId, Contact[] contacts, ContactAddOptions options)
        {
            this.ABContactAddAsync(abId, contacts, options, null);
        }

        /// <remarks/>
        public void ABContactAddAsync(System.Guid abId, Contact[] contacts, ContactAddOptions options, object userState)
        {
            if ((this.ABContactAddOperationCompleted == null))
            {
                this.ABContactAddOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABContactAddOperationCompleted);
            }
            this.InvokeAsync("ABContactAdd", new object[] {
                                                              abId,
                                                              contacts,
                                                              options}, this.ABContactAddOperationCompleted, userState);
        }

        private void OnABContactAddOperationCompleted(object arg)
        {
            if ((this.ABContactAddCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABContactAddCompleted(this, new ABContactAddCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABContactDelete", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABContactDelete(System.Guid abId, Contact[] contacts, ContactDeleteOptions options)
        {
            this.Invoke("ABContactDelete", new object[] {
                                                            abId,
                                                            contacts,
                                                            options});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABContactDelete(System.Guid abId, Contact[] contacts, ContactDeleteOptions options, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABContactDelete", new object[] {
                                                                        abId,
                                                                        contacts,
                                                                        options}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABContactDelete(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABContactDeleteAsync(System.Guid abId, Contact[] contacts, ContactDeleteOptions options)
        {
            this.ABContactDeleteAsync(abId, contacts, options, null);
        }

        /// <remarks/>
        public void ABContactDeleteAsync(System.Guid abId, Contact[] contacts, ContactDeleteOptions options, object userState)
        {
            if ((this.ABContactDeleteOperationCompleted == null))
            {
                this.ABContactDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABContactDeleteOperationCompleted);
            }
            this.InvokeAsync("ABContactDelete", new object[] {
                                                                 abId,
                                                                 contacts,
                                                                 options}, this.ABContactDeleteOperationCompleted, userState);
        }

        private void OnABContactDeleteOperationCompleted(object arg)
        {
            if ((this.ABContactDeleteCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABContactDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABGroupAdd", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Guid[] ABGroupAdd(System.Guid abId, GroupInfo[] groupInfo)
        {
            object[] results = this.Invoke("ABGroupAdd", new object[] {
                                                                          abId,
                                                                          groupInfo});
            return ((System.Guid[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABGroupAdd(System.Guid abId, GroupInfo[] groupInfo, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABGroupAdd", new object[] {
                                                                   abId,
                                                                   groupInfo}, callback, asyncState);
        }

        /// <remarks/>
        public System.Guid[] EndABGroupAdd(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Guid[])(results[0]));
        }

        /// <remarks/>
        public void ABGroupAddAsync(System.Guid abId, GroupInfo[] groupInfo)
        {
            this.ABGroupAddAsync(abId, groupInfo, null);
        }

        /// <remarks/>
        public void ABGroupAddAsync(System.Guid abId, GroupInfo[] groupInfo, object userState)
        {
            if ((this.ABGroupAddOperationCompleted == null))
            {
                this.ABGroupAddOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABGroupAddOperationCompleted);
            }
            this.InvokeAsync("ABGroupAdd", new object[] {
                                                            abId,
                                                            groupInfo}, this.ABGroupAddOperationCompleted, userState);
        }

        private void OnABGroupAddOperationCompleted(object arg)
        {
            if ((this.ABGroupAddCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABGroupAddCompleted(this, new ABGroupAddCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABGroupDelete", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABGroupDelete(System.Guid abId, GroupFilter groupFilter)
        {
            this.Invoke("ABGroupDelete", new object[] {
                                                          abId,
                                                          groupFilter});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABGroupDelete(System.Guid abId, GroupFilter groupFilter, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABGroupDelete", new object[] {
                                                                      abId,
                                                                      groupFilter}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABGroupDelete(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABGroupDeleteAsync(System.Guid abId, GroupFilter groupFilter)
        {
            this.ABGroupDeleteAsync(abId, groupFilter, null);
        }

        /// <remarks/>
        public void ABGroupDeleteAsync(System.Guid abId, GroupFilter groupFilter, object userState)
        {
            if ((this.ABGroupDeleteOperationCompleted == null))
            {
                this.ABGroupDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABGroupDeleteOperationCompleted);
            }
            this.InvokeAsync("ABGroupDelete", new object[] {
                                                               abId,
                                                               groupFilter}, this.ABGroupDeleteOperationCompleted, userState);
        }

        private void OnABGroupDeleteOperationCompleted(object arg)
        {
            if ((this.ABGroupDeleteCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABGroupDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABGroupUpdate", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABGroupUpdate(System.Guid abId, Group[] groups)
        {
            this.Invoke("ABGroupUpdate", new object[] {
                                                          abId,
                                                          groups});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABGroupUpdate(System.Guid abId, Group[] groups, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABGroupUpdate", new object[] {
                                                                      abId,
                                                                      groups}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABGroupUpdate(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABGroupUpdateAsync(System.Guid abId, Group[] groups)
        {
            this.ABGroupUpdateAsync(abId, groups, null);
        }

        /// <remarks/>
        public void ABGroupUpdateAsync(System.Guid abId, Group[] groups, object userState)
        {
            if ((this.ABGroupUpdateOperationCompleted == null))
            {
                this.ABGroupUpdateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABGroupUpdateOperationCompleted);
            }
            this.InvokeAsync("ABGroupUpdate", new object[] {
                                                               abId,
                                                               groups}, this.ABGroupUpdateOperationCompleted, userState);
        }

        private void OnABGroupUpdateOperationCompleted(object arg)
        {
            if ((this.ABGroupUpdateCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABGroupUpdateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABGroupFind", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Group[] ABGroupFind(System.Guid abId, GroupFilter groupFilter, bool getAnnotations, Annotation[] annotations)
        {
            object[] results = this.Invoke("ABGroupFind", new object[] {
                                                                           abId,
                                                                           groupFilter,
                                                                           getAnnotations,
                                                                           annotations});
            return ((Group[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABGroupFind(System.Guid abId, GroupFilter groupFilter, bool getAnnotations, Annotation[] annotations, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABGroupFind", new object[] {
                                                                    abId,
                                                                    groupFilter,
                                                                    getAnnotations,
                                                                    annotations}, callback, asyncState);
        }

        /// <remarks/>
        public Group[] EndABGroupFind(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((Group[])(results[0]));
        }

        /// <remarks/>
        public void ABGroupFindAsync(System.Guid abId, GroupFilter groupFilter, bool getAnnotations, Annotation[] annotations)
        {
            this.ABGroupFindAsync(abId, groupFilter, getAnnotations, annotations, null);
        }

        /// <remarks/>
        public void ABGroupFindAsync(System.Guid abId, GroupFilter groupFilter, bool getAnnotations, Annotation[] annotations, object userState)
        {
            if ((this.ABGroupFindOperationCompleted == null))
            {
                this.ABGroupFindOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABGroupFindOperationCompleted);
            }
            this.InvokeAsync("ABGroupFind", new object[] {
                                                             abId,
                                                             groupFilter,
                                                             getAnnotations,
                                                             annotations}, this.ABGroupFindOperationCompleted, userState);
        }

        private void OnABGroupFindOperationCompleted(object arg)
        {
            if ((this.ABGroupFindCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABGroupFindCompleted(this, new ABGroupFindCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABGroupContactAdd", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Guid[] ABGroupContactAdd(System.Guid abId, GroupFilter groupFilter, Contact[] contacts, GroupContactAddOptions groupContactAddOptions)
        {
            object[] results = this.Invoke("ABGroupContactAdd", new object[] {
                                                                                 abId,
                                                                                 groupFilter,
                                                                                 contacts,
                                                                                 groupContactAddOptions});
            return ((System.Guid[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABGroupContactAdd(System.Guid abId, GroupFilter groupFilter, Contact[] contacts, GroupContactAddOptions groupContactAddOptions, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABGroupContactAdd", new object[] {
                                                                          abId,
                                                                          groupFilter,
                                                                          contacts,
                                                                          groupContactAddOptions}, callback, asyncState);
        }

        /// <remarks/>
        public System.Guid[] EndABGroupContactAdd(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Guid[])(results[0]));
        }

        /// <remarks/>
        public void ABGroupContactAddAsync(System.Guid abId, GroupFilter groupFilter, Contact[] contacts, GroupContactAddOptions groupContactAddOptions)
        {
            this.ABGroupContactAddAsync(abId, groupFilter, contacts, groupContactAddOptions, null);
        }

        /// <remarks/>
        public void ABGroupContactAddAsync(System.Guid abId, GroupFilter groupFilter, Contact[] contacts, GroupContactAddOptions groupContactAddOptions, object userState)
        {
            if ((this.ABGroupContactAddOperationCompleted == null))
            {
                this.ABGroupContactAddOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABGroupContactAddOperationCompleted);
            }
            this.InvokeAsync("ABGroupContactAdd", new object[] {
                                                                   abId,
                                                                   groupFilter,
                                                                   contacts,
                                                                   groupContactAddOptions}, this.ABGroupContactAddOperationCompleted, userState);
        }

        private void OnABGroupContactAddOperationCompleted(object arg)
        {
            if ((this.ABGroupContactAddCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABGroupContactAddCompleted(this, new ABGroupContactAddCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABGroupContactDelete", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABGroupContactDelete(System.Guid abId, GroupFilter groupFilter, Contact[] contacts)
        {
            this.Invoke("ABGroupContactDelete", new object[] {
                                                                 abId,
                                                                 groupFilter,
                                                                 contacts});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABGroupContactDelete(System.Guid abId, GroupFilter groupFilter, Contact[] contacts, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABGroupContactDelete", new object[] {
                                                                             abId,
                                                                             groupFilter,
                                                                             contacts}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABGroupContactDelete(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABGroupContactDeleteAsync(System.Guid abId, GroupFilter groupFilter, Contact[] contacts)
        {
            this.ABGroupContactDeleteAsync(abId, groupFilter, contacts, null);
        }

        /// <remarks/>
        public void ABGroupContactDeleteAsync(System.Guid abId, GroupFilter groupFilter, Contact[] contacts, object userState)
        {
            if ((this.ABGroupContactDeleteOperationCompleted == null))
            {
                this.ABGroupContactDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABGroupContactDeleteOperationCompleted);
            }
            this.InvokeAsync("ABGroupContactDelete", new object[] {
                                                                      abId,
                                                                      groupFilter,
                                                                      contacts}, this.ABGroupContactDeleteOperationCompleted, userState);
        }

        private void OnABGroupContactDeleteOperationCompleted(object arg)
        {
            if ((this.ABGroupContactDeleteCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABGroupContactDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABAllowListSet", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABAllowListSet(System.Guid abId, string allowList)
        {
            this.Invoke("ABAllowListSet", new object[] {
                                                           abId,
                                                           allowList});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABAllowListSet(System.Guid abId, string allowList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABAllowListSet", new object[] {
                                                                       abId,
                                                                       allowList}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABAllowListSet(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABAllowListSetAsync(System.Guid abId, string allowList)
        {
            this.ABAllowListSetAsync(abId, allowList, null);
        }

        /// <remarks/>
        public void ABAllowListSetAsync(System.Guid abId, string allowList, object userState)
        {
            if ((this.ABAllowListSetOperationCompleted == null))
            {
                this.ABAllowListSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABAllowListSetOperationCompleted);
            }
            this.InvokeAsync("ABAllowListSet", new object[] {
                                                                abId,
                                                                allowList}, this.ABAllowListSetOperationCompleted, userState);
        }

        private void OnABAllowListSetOperationCompleted(object arg)
        {
            if ((this.ABAllowListSetCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABAllowListSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABAllowListGet", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string ABAllowListGet(System.Guid abId)
        {
            object[] results = this.Invoke("ABAllowListGet", new object[] {
                                                                              abId});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABAllowListGet(System.Guid abId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABAllowListGet", new object[] {
                                                                       abId}, callback, asyncState);
        }

        /// <remarks/>
        public string EndABAllowListGet(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        public void ABAllowListGetAsync(System.Guid abId)
        {
            this.ABAllowListGetAsync(abId, null);
        }

        /// <remarks/>
        public void ABAllowListGetAsync(System.Guid abId, object userState)
        {
            if ((this.ABAllowListGetOperationCompleted == null))
            {
                this.ABAllowListGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABAllowListGetOperationCompleted);
            }
            this.InvokeAsync("ABAllowListGet", new object[] {
                                                                abId}, this.ABAllowListGetOperationCompleted, userState);
        }

        private void OnABAllowListGetOperationCompleted(object arg)
        {
            if ((this.ABAllowListGetCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABAllowListGetCompleted(this, new ABAllowListGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABFindAll", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FindResult ABFindAll(System.Guid abId, ABView abView, bool deltasOnly, System.DateTime lastChange, ABDynamicItemView dynamicItemView, System.DateTime dynamicItemLastChange, RecentActivityViewOptions recentActivityViewOptions)
        {
            object[] results = this.Invoke("ABFindAll", new object[] {
                                                                         abId,
                                                                         abView,
                                                                         deltasOnly,
                                                                         lastChange,
                                                                         dynamicItemView,
                                                                         dynamicItemLastChange,
                                                                         recentActivityViewOptions});
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABFindAll(System.Guid abId, ABView abView, bool deltasOnly, System.DateTime lastChange, ABDynamicItemView dynamicItemView, System.DateTime dynamicItemLastChange, RecentActivityViewOptions recentActivityViewOptions, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABFindAll", new object[] {
                                                                  abId,
                                                                  abView,
                                                                  deltasOnly,
                                                                  lastChange,
                                                                  dynamicItemView,
                                                                  dynamicItemLastChange,
                                                                  recentActivityViewOptions}, callback, asyncState);
        }

        /// <remarks/>
        public FindResult EndABFindAll(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public void ABFindAllAsync(System.Guid abId, ABView abView, bool deltasOnly, System.DateTime lastChange, ABDynamicItemView dynamicItemView, System.DateTime dynamicItemLastChange, RecentActivityViewOptions recentActivityViewOptions)
        {
            this.ABFindAllAsync(abId, abView, deltasOnly, lastChange, dynamicItemView, dynamicItemLastChange, recentActivityViewOptions, null);
        }

        /// <remarks/>
        public void ABFindAllAsync(System.Guid abId, ABView abView, bool deltasOnly, System.DateTime lastChange, ABDynamicItemView dynamicItemView, System.DateTime dynamicItemLastChange, RecentActivityViewOptions recentActivityViewOptions, object userState)
        {
            if ((this.ABFindAllOperationCompleted == null))
            {
                this.ABFindAllOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABFindAllOperationCompleted);
            }
            this.InvokeAsync("ABFindAll", new object[] {
                                                           abId,
                                                           abView,
                                                           deltasOnly,
                                                           lastChange,
                                                           dynamicItemView,
                                                           dynamicItemLastChange,
                                                           recentActivityViewOptions}, this.ABFindAllOperationCompleted, userState);
        }

        private void OnABFindAllOperationCompleted(object arg)
        {
            if ((this.ABFindAllCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABFindAllCompleted(this, new ABFindAllCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABFindByContacts", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FindResult ABFindByContacts(System.Guid abId, ABView abView, System.Guid[] contactIds, ABDynamicItemView dynamicItemView)
        {
            object[] results = this.Invoke("ABFindByContacts", new object[] {
                                                                                abId,
                                                                                abView,
                                                                                contactIds,
                                                                                dynamicItemView});
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABFindByContacts(System.Guid abId, ABView abView, System.Guid[] contactIds, ABDynamicItemView dynamicItemView, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABFindByContacts", new object[] {
                                                                         abId,
                                                                         abView,
                                                                         contactIds,
                                                                         dynamicItemView}, callback, asyncState);
        }

        /// <remarks/>
        public FindResult EndABFindByContacts(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public void ABFindByContactsAsync(System.Guid abId, ABView abView, System.Guid[] contactIds, ABDynamicItemView dynamicItemView)
        {
            this.ABFindByContactsAsync(abId, abView, contactIds, dynamicItemView, null);
        }

        /// <remarks/>
        public void ABFindByContactsAsync(System.Guid abId, ABView abView, System.Guid[] contactIds, ABDynamicItemView dynamicItemView, object userState)
        {
            if ((this.ABFindByContactsOperationCompleted == null))
            {
                this.ABFindByContactsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABFindByContactsOperationCompleted);
            }
            this.InvokeAsync("ABFindByContacts", new object[] {
                                                                  abId,
                                                                  abView,
                                                                  contactIds,
                                                                  dynamicItemView}, this.ABFindByContactsOperationCompleted, userState);
        }

        private void OnABFindByContactsOperationCompleted(object arg)
        {
            if ((this.ABFindByContactsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABFindByContactsCompleted(this, new ABFindByContactsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABFindMessengerUsers", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FindResult ABFindMessengerUsers(System.Guid abId, ABView abView)
        {
            object[] results = this.Invoke("ABFindMessengerUsers", new object[] {
                                                                                    abId,
                                                                                    abView});
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABFindMessengerUsers(System.Guid abId, ABView abView, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABFindMessengerUsers", new object[] {
                                                                             abId,
                                                                             abView}, callback, asyncState);
        }

        /// <remarks/>
        public FindResult EndABFindMessengerUsers(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public void ABFindMessengerUsersAsync(System.Guid abId, ABView abView)
        {
            this.ABFindMessengerUsersAsync(abId, abView, null);
        }

        /// <remarks/>
        public void ABFindMessengerUsersAsync(System.Guid abId, ABView abView, object userState)
        {
            if ((this.ABFindMessengerUsersOperationCompleted == null))
            {
                this.ABFindMessengerUsersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABFindMessengerUsersOperationCompleted);
            }
            this.InvokeAsync("ABFindMessengerUsers", new object[] {
                                                                      abId,
                                                                      abView}, this.ABFindMessengerUsersOperationCompleted, userState);
        }

        private void OnABFindMessengerUsersOperationCompleted(object arg)
        {
            if ((this.ABFindMessengerUsersCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABFindMessengerUsersCompleted(this, new ABFindMessengerUsersCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABFindByGroups", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FindResult ABFindByGroups(System.Guid abId, ABView abView, System.Guid[] groupIds)
        {
            object[] results = this.Invoke("ABFindByGroups", new object[] {
                                                                              abId,
                                                                              abView,
                                                                              groupIds});
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABFindByGroups(System.Guid abId, ABView abView, System.Guid[] groupIds, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABFindByGroups", new object[] {
                                                                       abId,
                                                                       abView,
                                                                       groupIds}, callback, asyncState);
        }

        /// <remarks/>
        public FindResult EndABFindByGroups(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public void ABFindByGroupsAsync(System.Guid abId, ABView abView, System.Guid[] groupIds)
        {
            this.ABFindByGroupsAsync(abId, abView, groupIds, null);
        }

        /// <remarks/>
        public void ABFindByGroupsAsync(System.Guid abId, ABView abView, System.Guid[] groupIds, object userState)
        {
            if ((this.ABFindByGroupsOperationCompleted == null))
            {
                this.ABFindByGroupsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABFindByGroupsOperationCompleted);
            }
            this.InvokeAsync("ABFindByGroups", new object[] {
                                                                abId,
                                                                abView,
                                                                groupIds}, this.ABFindByGroupsOperationCompleted, userState);
        }

        private void OnABFindByGroupsOperationCompleted(object arg)
        {
            if ((this.ABFindByGroupsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABFindByGroupsCompleted(this, new ABFindByGroupsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABFindMeContact", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FindResult ABFindMeContact(System.Guid abId, ABView abView)
        {
            object[] results = this.Invoke("ABFindMeContact", new object[] {
                                                                               abId,
                                                                               abView});
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABFindMeContact(System.Guid abId, ABView abView, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABFindMeContact", new object[] {
                                                                        abId,
                                                                        abView}, callback, asyncState);
        }

        /// <remarks/>
        public FindResult EndABFindMeContact(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((FindResult)(results[0]));
        }

        /// <remarks/>
        public void ABFindMeContactAsync(System.Guid abId, ABView abView)
        {
            this.ABFindMeContactAsync(abId, abView, null);
        }

        /// <remarks/>
        public void ABFindMeContactAsync(System.Guid abId, ABView abView, object userState)
        {
            if ((this.ABFindMeContactOperationCompleted == null))
            {
                this.ABFindMeContactOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABFindMeContactOperationCompleted);
            }
            this.InvokeAsync("ABFindMeContact", new object[] {
                                                                 abId,
                                                                 abView}, this.ABFindMeContactOperationCompleted, userState);
        }

        private void OnABFindMeContactOperationCompleted(object arg)
        {
            if ((this.ABFindMeContactCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABFindMeContactCompleted(this, new ABFindMeContactCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/AddCategory", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Category[] AddCategory(System.Guid abId, string[] name)
        {
            object[] results = this.Invoke("AddCategory", new object[] {
                                                                           abId,
                                                                           name});
            return ((Category[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddCategory(System.Guid abId, string[] name, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddCategory", new object[] {
                                                                    abId,
                                                                    name}, callback, asyncState);
        }

        /// <remarks/>
        public Category[] EndAddCategory(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((Category[])(results[0]));
        }

        /// <remarks/>
        public void AddCategoryAsync(System.Guid abId, string[] name)
        {
            this.AddCategoryAsync(abId, name, null);
        }

        /// <remarks/>
        public void AddCategoryAsync(System.Guid abId, string[] name, object userState)
        {
            if ((this.AddCategoryOperationCompleted == null))
            {
                this.AddCategoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddCategoryOperationCompleted);
            }
            this.InvokeAsync("AddCategory", new object[] {
                                                             abId,
                                                             name}, this.AddCategoryOperationCompleted, userState);
        }

        private void OnAddCategoryOperationCompleted(object arg)
        {
            if ((this.AddCategoryCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCategoryCompleted(this, new AddCategoryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/DeleteCategory", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteCategory(System.Guid abId, Category[] categories)
        {
            this.Invoke("DeleteCategory", new object[] {
                                                           abId,
                                                           categories});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteCategory(System.Guid abId, Category[] categories, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteCategory", new object[] {
                                                                       abId,
                                                                       categories}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteCategory(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void DeleteCategoryAsync(System.Guid abId, Category[] categories)
        {
            this.DeleteCategoryAsync(abId, categories, null);
        }

        /// <remarks/>
        public void DeleteCategoryAsync(System.Guid abId, Category[] categories, object userState)
        {
            if ((this.DeleteCategoryOperationCompleted == null))
            {
                this.DeleteCategoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteCategoryOperationCompleted);
            }
            this.InvokeAsync("DeleteCategory", new object[] {
                                                                abId,
                                                                categories}, this.DeleteCategoryOperationCompleted, userState);
        }

        private void OnDeleteCategoryOperationCompleted(object arg)
        {
            if ((this.DeleteCategoryCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteCategoryCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/UpdateCategory", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateCategory(System.Guid abId, Category[] categories)
        {
            this.Invoke("UpdateCategory", new object[] {
                                                           abId,
                                                           categories});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateCategory(System.Guid abId, Category[] categories, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateCategory", new object[] {
                                                                       abId,
                                                                       categories}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateCategory(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void UpdateCategoryAsync(System.Guid abId, Category[] categories)
        {
            this.UpdateCategoryAsync(abId, categories, null);
        }

        /// <remarks/>
        public void UpdateCategoryAsync(System.Guid abId, Category[] categories, object userState)
        {
            if ((this.UpdateCategoryOperationCompleted == null))
            {
                this.UpdateCategoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateCategoryOperationCompleted);
            }
            this.InvokeAsync("UpdateCategory", new object[] {
                                                                abId,
                                                                categories}, this.UpdateCategoryOperationCompleted, userState);
        }

        private void OnUpdateCategoryOperationCompleted(object arg)
        {
            if ((this.UpdateCategoryCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateCategoryCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/AddDynamicItem", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddDynamicItem(System.Guid abId, DynamicItem[] dynamicItems)
        {
            this.Invoke("AddDynamicItem", new object[] {
                                                           abId,
                                                           dynamicItems});
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddDynamicItem(System.Guid abId, DynamicItem[] dynamicItems, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddDynamicItem", new object[] {
                                                                       abId,
                                                                       dynamicItems}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddDynamicItem(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void AddDynamicItemAsync(System.Guid abId, DynamicItem[] dynamicItems)
        {
            this.AddDynamicItemAsync(abId, dynamicItems, null);
        }

        /// <remarks/>
        public void AddDynamicItemAsync(System.Guid abId, DynamicItem[] dynamicItems, object userState)
        {
            if ((this.AddDynamicItemOperationCompleted == null))
            {
                this.AddDynamicItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddDynamicItemOperationCompleted);
            }
            this.InvokeAsync("AddDynamicItem", new object[] {
                                                                abId,
                                                                dynamicItems}, this.AddDynamicItemOperationCompleted, userState);
        }

        private void OnAddDynamicItemOperationCompleted(object arg)
        {
            if ((this.AddDynamicItemCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddDynamicItemCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/UpdateDynamicItem", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateDynamicItem(System.Guid abId, DynamicItem[] dynamicItems)
        {
            this.Invoke("UpdateDynamicItem", new object[] {
                                                              abId,
                                                              dynamicItems});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateDynamicItem(System.Guid abId, DynamicItem[] dynamicItems, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateDynamicItem", new object[] {
                                                                          abId,
                                                                          dynamicItems}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateDynamicItem(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void UpdateDynamicItemAsync(System.Guid abId, DynamicItem[] dynamicItems)
        {
            this.UpdateDynamicItemAsync(abId, dynamicItems, null);
        }

        /// <remarks/>
        public void UpdateDynamicItemAsync(System.Guid abId, DynamicItem[] dynamicItems, object userState)
        {
            if ((this.UpdateDynamicItemOperationCompleted == null))
            {
                this.UpdateDynamicItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateDynamicItemOperationCompleted);
            }
            this.InvokeAsync("UpdateDynamicItem", new object[] {
                                                                   abId,
                                                                   dynamicItems}, this.UpdateDynamicItemOperationCompleted, userState);
        }

        private void OnUpdateDynamicItemOperationCompleted(object arg)
        {
            if ((this.UpdateDynamicItemCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateDynamicItemCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/CircleUpdate", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CircleUpdate(System.Guid abId, Circle[] circles)
        {
            this.Invoke("CircleUpdate", new object[] {
                                                         abId,
                                                         circles});
        }

        /// <remarks/>
        public System.IAsyncResult BeginCircleUpdate(System.Guid abId, Circle[] circles, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CircleUpdate", new object[] {
                                                                     abId,
                                                                     circles}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCircleUpdate(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void CircleUpdateAsync(System.Guid abId, Circle[] circles)
        {
            this.CircleUpdateAsync(abId, circles, null);
        }

        /// <remarks/>
        public void CircleUpdateAsync(System.Guid abId, Circle[] circles, object userState)
        {
            if ((this.CircleUpdateOperationCompleted == null))
            {
                this.CircleUpdateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCircleUpdateOperationCompleted);
            }
            this.InvokeAsync("CircleUpdate", new object[] {
                                                              abId,
                                                              circles}, this.CircleUpdateOperationCompleted, userState);
        }

        private void OnCircleUpdateOperationCompleted(object arg)
        {
            if ((this.CircleUpdateCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CircleUpdateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABSetForceFullSyncDate", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ABSetForceFullSyncDate(System.Guid abId)
        {
            this.Invoke("ABSetForceFullSyncDate", new object[] {
                                                                   abId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginABSetForceFullSyncDate(System.Guid abId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABSetForceFullSyncDate", new object[] {
                                                                               abId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndABSetForceFullSyncDate(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ABSetForceFullSyncDateAsync(System.Guid abId)
        {
            this.ABSetForceFullSyncDateAsync(abId, null);
        }

        /// <remarks/>
        public void ABSetForceFullSyncDateAsync(System.Guid abId, object userState)
        {
            if ((this.ABSetForceFullSyncDateOperationCompleted == null))
            {
                this.ABSetForceFullSyncDateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABSetForceFullSyncDateOperationCompleted);
            }
            this.InvokeAsync("ABSetForceFullSyncDate", new object[] {
                                                                        abId}, this.ABSetForceFullSyncDateOperationCompleted, userState);
        }

        private void OnABSetForceFullSyncDateOperationCompleted(object arg)
        {
            if ((this.ABSetForceFullSyncDateCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABSetForceFullSyncDateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/MergeAB", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MergeResponse MergeAB(NamespaceHandle targetNamespace, MergeData mergeInfo)
        {
            object[] results = this.Invoke("MergeAB", new object[] {
                                                                       targetNamespace,
                                                                       mergeInfo});
            return ((MergeResponse)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginMergeAB(NamespaceHandle targetNamespace, MergeData mergeInfo, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("MergeAB", new object[] {
                                                                targetNamespace,
                                                                mergeInfo}, callback, asyncState);
        }

        /// <remarks/>
        public MergeResponse EndMergeAB(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((MergeResponse)(results[0]));
        }

        /// <remarks/>
        public void MergeABAsync(NamespaceHandle targetNamespace, MergeData mergeInfo)
        {
            this.MergeABAsync(targetNamespace, mergeInfo, null);
        }

        /// <remarks/>
        public void MergeABAsync(NamespaceHandle targetNamespace, MergeData mergeInfo, object userState)
        {
            if ((this.MergeABOperationCompleted == null))
            {
                this.MergeABOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMergeABOperationCompleted);
            }
            this.InvokeAsync("MergeAB", new object[] {
                                                         targetNamespace,
                                                         mergeInfo}, this.MergeABOperationCompleted, userState);
        }

        private void OnMergeABOperationCompleted(object arg)
        {
            if ((this.MergeABCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MergeABCompleted(this, new MergeABCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/AddABNetworks", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddABNetworks(ABHandle targetAB, NetworkInfo[] networksToAdd)
        {
            this.Invoke("AddABNetworks", new object[] {
                                                          targetAB,
                                                          networksToAdd});
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddABNetworks(ABHandle targetAB, NetworkInfo[] networksToAdd, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddABNetworks", new object[] {
                                                                      targetAB,
                                                                      networksToAdd}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddABNetworks(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void AddABNetworksAsync(ABHandle targetAB, NetworkInfo[] networksToAdd)
        {
            this.AddABNetworksAsync(targetAB, networksToAdd, null);
        }

        /// <remarks/>
        public void AddABNetworksAsync(ABHandle targetAB, NetworkInfo[] networksToAdd, object userState)
        {
            if ((this.AddABNetworksOperationCompleted == null))
            {
                this.AddABNetworksOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddABNetworksOperationCompleted);
            }
            this.InvokeAsync("AddABNetworks", new object[] {
                                                               targetAB,
                                                               networksToAdd}, this.AddABNetworksOperationCompleted, userState);
        }

        private void OnAddABNetworksOperationCompleted(object arg)
        {
            if ((this.AddABNetworksCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddABNetworksCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/DeleteABNetwork", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteABNetwork(ABHandle targetAB, NetworkInfo networkToDelete)
        {
            this.Invoke("DeleteABNetwork", new object[] {
                                                            targetAB,
                                                            networkToDelete});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteABNetwork(ABHandle targetAB, NetworkInfo networkToDelete, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteABNetwork", new object[] {
                                                                        targetAB,
                                                                        networkToDelete}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteABNetwork(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void DeleteABNetworkAsync(ABHandle targetAB, NetworkInfo networkToDelete)
        {
            this.DeleteABNetworkAsync(targetAB, networkToDelete, null);
        }

        /// <remarks/>
        public void DeleteABNetworkAsync(ABHandle targetAB, NetworkInfo networkToDelete, object userState)
        {
            if ((this.DeleteABNetworkOperationCompleted == null))
            {
                this.DeleteABNetworkOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteABNetworkOperationCompleted);
            }
            this.InvokeAsync("DeleteABNetwork", new object[] {
                                                                 targetAB,
                                                                 networkToDelete}, this.DeleteABNetworkOperationCompleted, userState);
        }

        private void OnDeleteABNetworkOperationCompleted(object arg)
        {
            if ((this.DeleteABNetworkCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteABNetworkCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/UpdateABNetwork", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateABNetwork(ABHandle targetAB, NetworkInfo networkToUpdate)
        {
            this.Invoke("UpdateABNetwork", new object[] {
                                                            targetAB,
                                                            networkToUpdate});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateABNetwork(ABHandle targetAB, NetworkInfo networkToUpdate, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateABNetwork", new object[] {
                                                                        targetAB,
                                                                        networkToUpdate}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateABNetwork(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void UpdateABNetworkAsync(ABHandle targetAB, NetworkInfo networkToUpdate)
        {
            this.UpdateABNetworkAsync(targetAB, networkToUpdate, null);
        }

        /// <remarks/>
        public void UpdateABNetworkAsync(ABHandle targetAB, NetworkInfo networkToUpdate, object userState)
        {
            if ((this.UpdateABNetworkOperationCompleted == null))
            {
                this.UpdateABNetworkOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateABNetworkOperationCompleted);
            }
            this.InvokeAsync("UpdateABNetwork", new object[] {
                                                                 targetAB,
                                                                 networkToUpdate}, this.UpdateABNetworkOperationCompleted, userState);
        }

        private void OnUpdateABNetworkOperationCompleted(object arg)
        {
            if ((this.UpdateABNetworkCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateABNetworkCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ViewABNetworks", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public NetworkInfo[] ViewABNetworks(ABHandle targetAB)
        {
            object[] results = this.Invoke("ViewABNetworks", new object[] {
                                                                              targetAB});
            return ((NetworkInfo[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginViewABNetworks(ABHandle targetAB, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ViewABNetworks", new object[] {
                                                                       targetAB}, callback, asyncState);
        }

        /// <remarks/>
        public NetworkInfo[] EndViewABNetworks(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((NetworkInfo[])(results[0]));
        }

        /// <remarks/>
        public void ViewABNetworksAsync(ABHandle targetAB)
        {
            this.ViewABNetworksAsync(targetAB, null);
        }

        /// <remarks/>
        public void ViewABNetworksAsync(ABHandle targetAB, object userState)
        {
            if ((this.ViewABNetworksOperationCompleted == null))
            {
                this.ViewABNetworksOperationCompleted = new System.Threading.SendOrPostCallback(this.OnViewABNetworksOperationCompleted);
            }
            this.InvokeAsync("ViewABNetworks", new object[] {
                                                                targetAB}, this.ViewABNetworksOperationCompleted, userState);
        }

        private void OnViewABNetworksOperationCompleted(object arg)
        {
            if ((this.ViewABNetworksCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ViewABNetworksCompleted(this, new ViewABNetworksCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/CreateContact", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Contact CreateContact(ABHandle abHandle, ContactHandle contactHandle, ContactInfo contactInfo)
        {
            object[] results = this.Invoke("CreateContact", new object[] {
                                                                             abHandle,
                                                                             contactHandle,
                                                                             contactInfo});
            return ((Contact)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreateContact(ABHandle abHandle, ContactHandle contactHandle, ContactInfo contactInfo, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreateContact", new object[] {
                                                                      abHandle,
                                                                      contactHandle,
                                                                      contactInfo}, callback, asyncState);
        }

        /// <remarks/>
        public Contact EndCreateContact(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((Contact)(results[0]));
        }

        /// <remarks/>
        public void CreateContactAsync(ABHandle abHandle, ContactHandle contactHandle, ContactInfo contactInfo)
        {
            this.CreateContactAsync(abHandle, contactHandle, contactInfo, null);
        }

        /// <remarks/>
        public void CreateContactAsync(ABHandle abHandle, ContactHandle contactHandle, ContactInfo contactInfo, object userState)
        {
            if ((this.CreateContactOperationCompleted == null))
            {
                this.CreateContactOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateContactOperationCompleted);
            }
            this.InvokeAsync("CreateContact", new object[] {
                                                               abHandle,
                                                               contactHandle,
                                                               contactInfo}, this.CreateContactOperationCompleted, userState);
        }

        private void OnCreateContactOperationCompleted(object arg)
        {
            if ((this.CreateContactCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateContactCompleted(this, new CreateContactCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/FindContact", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FindContactResult FindContact(ABHandle abHandle, System.Guid contactId, ContactHandle contactHandle, ABView abView)
        {
            object[] results = this.Invoke("FindContact", new object[] {
                                                                           abHandle,
                                                                           contactId,
                                                                           contactHandle,
                                                                           abView});
            return ((FindContactResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginFindContact(ABHandle abHandle, System.Guid contactId, ContactHandle contactHandle, ABView abView, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("FindContact", new object[] {
                                                                    abHandle,
                                                                    contactId,
                                                                    contactHandle,
                                                                    abView}, callback, asyncState);
        }

        /// <remarks/>
        public FindContactResult EndFindContact(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((FindContactResult)(results[0]));
        }

        /// <remarks/>
        public void FindContactAsync(ABHandle abHandle, System.Guid contactId, ContactHandle contactHandle, ABView abView)
        {
            this.FindContactAsync(abHandle, contactId, contactHandle, abView, null);
        }

        /// <remarks/>
        public void FindContactAsync(ABHandle abHandle, System.Guid contactId, ContactHandle contactHandle, ABView abView, object userState)
        {
            if ((this.FindContactOperationCompleted == null))
            {
                this.FindContactOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFindContactOperationCompleted);
            }
            this.InvokeAsync("FindContact", new object[] {
                                                             abHandle,
                                                             contactId,
                                                             contactHandle,
                                                             abView}, this.FindContactOperationCompleted, userState);
        }

        private void OnFindContactOperationCompleted(object arg)
        {
            if ((this.FindContactCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.FindContactCompleted(this, new FindContactCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/AddMessengerAddress", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Contact AddMessengerAddress(ABHandle abHandle, System.Guid contactId, string imAddress, int imAddressType, Annotation[] annotations)
        {
            object[] results = this.Invoke("AddMessengerAddress", new object[] {
                                                                                   abHandle,
                                                                                   contactId,
                                                                                   imAddress,
                                                                                   imAddressType,
                                                                                   annotations});
            return ((Contact)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddMessengerAddress(ABHandle abHandle, System.Guid contactId, string imAddress, int imAddressType, Annotation[] annotations, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddMessengerAddress", new object[] {
                                                                            abHandle,
                                                                            contactId,
                                                                            imAddress,
                                                                            imAddressType,
                                                                            annotations}, callback, asyncState);
        }

        /// <remarks/>
        public Contact EndAddMessengerAddress(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((Contact)(results[0]));
        }

        /// <remarks/>
        public void AddMessengerAddressAsync(ABHandle abHandle, System.Guid contactId, string imAddress, int imAddressType, Annotation[] annotations)
        {
            this.AddMessengerAddressAsync(abHandle, contactId, imAddress, imAddressType, annotations, null);
        }

        /// <remarks/>
        public void AddMessengerAddressAsync(ABHandle abHandle, System.Guid contactId, string imAddress, int imAddressType, Annotation[] annotations, object userState)
        {
            if ((this.AddMessengerAddressOperationCompleted == null))
            {
                this.AddMessengerAddressOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddMessengerAddressOperationCompleted);
            }
            this.InvokeAsync("AddMessengerAddress", new object[] {
                                                                     abHandle,
                                                                     contactId,
                                                                     imAddress,
                                                                     imAddressType,
                                                                     annotations}, this.AddMessengerAddressOperationCompleted, userState);
        }

        private void OnAddMessengerAddressOperationCompleted(object arg)
        {
            if ((this.AddMessengerAddressCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddMessengerAddressCompleted(this, new AddMessengerAddressCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/UpdateContact", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Contact UpdateContact(ABHandle abHandle, System.Guid contactId, ContactInfo contactInfo)
        {
            object[] results = this.Invoke("UpdateContact", new object[] {
                                                                             abHandle,
                                                                             contactId,
                                                                             contactInfo});
            return ((Contact)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateContact(ABHandle abHandle, System.Guid contactId, ContactInfo contactInfo, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateContact", new object[] {
                                                                      abHandle,
                                                                      contactId,
                                                                      contactInfo}, callback, asyncState);
        }

        /// <remarks/>
        public Contact EndUpdateContact(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((Contact)(results[0]));
        }

        /// <remarks/>
        public void UpdateContactAsync(ABHandle abHandle, System.Guid contactId, ContactInfo contactInfo)
        {
            this.UpdateContactAsync(abHandle, contactId, contactInfo, null);
        }

        /// <remarks/>
        public void UpdateContactAsync(ABHandle abHandle, System.Guid contactId, ContactInfo contactInfo, object userState)
        {
            if ((this.UpdateContactOperationCompleted == null))
            {
                this.UpdateContactOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateContactOperationCompleted);
            }
            this.InvokeAsync("UpdateContact", new object[] {
                                                               abHandle,
                                                               contactId,
                                                               contactInfo}, this.UpdateContactOperationCompleted, userState);
        }

        private void OnUpdateContactOperationCompleted(object arg)
        {
            if ((this.UpdateContactCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateContactCompleted(this, new UpdateContactCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/DeleteContact", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteContact(ABHandle abHandle, System.Guid contactId)
        {
            this.Invoke("DeleteContact", new object[] {
                                                          abHandle,
                                                          contactId});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteContact(ABHandle abHandle, System.Guid contactId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteContact", new object[] {
                                                                      abHandle,
                                                                      contactId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteContact(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void DeleteContactAsync(ABHandle abHandle, System.Guid contactId)
        {
            this.DeleteContactAsync(abHandle, contactId, null);
        }

        /// <remarks/>
        public void DeleteContactAsync(ABHandle abHandle, System.Guid contactId, object userState)
        {
            if ((this.DeleteContactOperationCompleted == null))
            {
                this.DeleteContactOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDeleteContactOperationCompleted);
            }
            this.InvokeAsync("DeleteContact", new object[] {
                                                               abHandle,
                                                               contactId}, this.DeleteContactOperationCompleted, userState);
        }

        private void OnDeleteContactOperationCompleted(object arg)
        {
            if ((this.DeleteContactCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DeleteContactCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/BlockContact", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void BlockContact(ABHandle abHandle, ContactHandle contactHandle)
        {
            this.Invoke("BlockContact", new object[] {
                                                         abHandle,
                                                         contactHandle});
        }

        /// <remarks/>
        public System.IAsyncResult BeginBlockContact(ABHandle abHandle, ContactHandle contactHandle, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("BlockContact", new object[] {
                                                                     abHandle,
                                                                     contactHandle}, callback, asyncState);
        }

        /// <remarks/>
        public void EndBlockContact(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void BlockContactAsync(ABHandle abHandle, ContactHandle contactHandle)
        {
            this.BlockContactAsync(abHandle, contactHandle, null);
        }

        /// <remarks/>
        public void BlockContactAsync(ABHandle abHandle, ContactHandle contactHandle, object userState)
        {
            if ((this.BlockContactOperationCompleted == null))
            {
                this.BlockContactOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBlockContactOperationCompleted);
            }
            this.InvokeAsync("BlockContact", new object[] {
                                                              abHandle,
                                                              contactHandle}, this.BlockContactOperationCompleted, userState);
        }

        private void OnBlockContactOperationCompleted(object arg)
        {
            if ((this.BlockContactCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BlockContactCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/UnblockContact", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UnblockContact(ABHandle abHandle, ContactHandle contactHandle)
        {
            this.Invoke("UnblockContact", new object[] {
                                                           abHandle,
                                                           contactHandle});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUnblockContact(ABHandle abHandle, ContactHandle contactHandle, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UnblockContact", new object[] {
                                                                       abHandle,
                                                                       contactHandle}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUnblockContact(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void UnblockContactAsync(ABHandle abHandle, ContactHandle contactHandle)
        {
            this.UnblockContactAsync(abHandle, contactHandle, null);
        }

        /// <remarks/>
        public void UnblockContactAsync(ABHandle abHandle, ContactHandle contactHandle, object userState)
        {
            if ((this.UnblockContactOperationCompleted == null))
            {
                this.UnblockContactOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnblockContactOperationCompleted);
            }
            this.InvokeAsync("UnblockContact", new object[] {
                                                                abHandle,
                                                                contactHandle}, this.UnblockContactOperationCompleted, userState);
        }

        private void OnUnblockContactOperationCompleted(object arg)
        {
            if ((this.UnblockContactCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnblockContactCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/IsContactBlocked", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool IsContactBlocked(ABHandle abHandle, ContactHandle contactHandle)
        {
            object[] results = this.Invoke("IsContactBlocked", new object[] {
                                                                                abHandle,
                                                                                contactHandle});
            return ((bool)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginIsContactBlocked(ABHandle abHandle, ContactHandle contactHandle, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("IsContactBlocked", new object[] {
                                                                         abHandle,
                                                                         contactHandle}, callback, asyncState);
        }

        /// <remarks/>
        public bool EndIsContactBlocked(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }

        /// <remarks/>
        public void IsContactBlockedAsync(ABHandle abHandle, ContactHandle contactHandle)
        {
            this.IsContactBlockedAsync(abHandle, contactHandle, null);
        }

        /// <remarks/>
        public void IsContactBlockedAsync(ABHandle abHandle, ContactHandle contactHandle, object userState)
        {
            if ((this.IsContactBlockedOperationCompleted == null))
            {
                this.IsContactBlockedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIsContactBlockedOperationCompleted);
            }
            this.InvokeAsync("IsContactBlocked", new object[] {
                                                                  abHandle,
                                                                  contactHandle}, this.IsContactBlockedOperationCompleted, userState);
        }

        private void OnIsContactBlockedOperationCompleted(object arg)
        {
            if ((this.IsContactBlockedCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.IsContactBlockedCompleted(this, new IsContactBlockedCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/FindBlockedContacts", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long[] FindBlockedContacts(ABHandle abHandle)
        {
            object[] results = this.Invoke("FindBlockedContacts", new object[] {
                                                                                   abHandle});
            return ((long[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginFindBlockedContacts(ABHandle abHandle, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("FindBlockedContacts", new object[] {
                                                                            abHandle}, callback, asyncState);
        }

        /// <remarks/>
        public long[] EndFindBlockedContacts(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((long[])(results[0]));
        }

        /// <remarks/>
        public void FindBlockedContactsAsync(ABHandle abHandle)
        {
            this.FindBlockedContactsAsync(abHandle, null);
        }

        /// <remarks/>
        public void FindBlockedContactsAsync(ABHandle abHandle, object userState)
        {
            if ((this.FindBlockedContactsOperationCompleted == null))
            {
                this.FindBlockedContactsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFindBlockedContactsOperationCompleted);
            }
            this.InvokeAsync("FindBlockedContacts", new object[] {
                                                                     abHandle}, this.FindBlockedContactsOperationCompleted, userState);
        }

        private void OnFindBlockedContactsOperationCompleted(object arg)
        {
            if ((this.FindBlockedContactsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.FindBlockedContactsCompleted(this, new FindBlockedContactsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/SendContactMessage", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendContactMessage(ABHandle abHandle, System.Guid contactId, EmailContent emailContent, long scenario)
        {
            this.Invoke("SendContactMessage", new object[] {
                                                               abHandle,
                                                               contactId,
                                                               emailContent,
                                                               scenario});
        }

        /// <remarks/>
        public System.IAsyncResult BeginSendContactMessage(ABHandle abHandle, System.Guid contactId, EmailContent emailContent, long scenario, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SendContactMessage", new object[] {
                                                                           abHandle,
                                                                           contactId,
                                                                           emailContent,
                                                                           scenario}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSendContactMessage(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void SendContactMessageAsync(ABHandle abHandle, System.Guid contactId, EmailContent emailContent, long scenario)
        {
            this.SendContactMessageAsync(abHandle, contactId, emailContent, scenario, null);
        }

        /// <remarks/>
        public void SendContactMessageAsync(ABHandle abHandle, System.Guid contactId, EmailContent emailContent, long scenario, object userState)
        {
            if ((this.SendContactMessageOperationCompleted == null))
            {
                this.SendContactMessageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSendContactMessageOperationCompleted);
            }
            this.InvokeAsync("SendContactMessage", new object[] {
                                                                    abHandle,
                                                                    contactId,
                                                                    emailContent,
                                                                    scenario}, this.SendContactMessageOperationCompleted, userState);
        }

        private void OnSendContactMessageOperationCompleted(object arg)
        {
            if ((this.SendContactMessageCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SendContactMessageCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/MakeConnection", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public NetworkInfo[] MakeConnection(ABHandle abHandle, System.Guid contactId, NetworkInfo[] networkInfoList)
        {
            object[] results = this.Invoke("MakeConnection", new object[] {
                                                                              abHandle,
                                                                              contactId,
                                                                              networkInfoList});
            return ((NetworkInfo[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginMakeConnection(ABHandle abHandle, System.Guid contactId, NetworkInfo[] networkInfoList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("MakeConnection", new object[] {
                                                                       abHandle,
                                                                       contactId,
                                                                       networkInfoList}, callback, asyncState);
        }

        /// <remarks/>
        public NetworkInfo[] EndMakeConnection(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((NetworkInfo[])(results[0]));
        }

        /// <remarks/>
        public void MakeConnectionAsync(ABHandle abHandle, System.Guid contactId, NetworkInfo[] networkInfoList)
        {
            this.MakeConnectionAsync(abHandle, contactId, networkInfoList, null);
        }

        /// <remarks/>
        public void MakeConnectionAsync(ABHandle abHandle, System.Guid contactId, NetworkInfo[] networkInfoList, object userState)
        {
            if ((this.MakeConnectionOperationCompleted == null))
            {
                this.MakeConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMakeConnectionOperationCompleted);
            }
            this.InvokeAsync("MakeConnection", new object[] {
                                                                abHandle,
                                                                contactId,
                                                                networkInfoList}, this.MakeConnectionOperationCompleted, userState);
        }

        private void OnMakeConnectionOperationCompleted(object arg)
        {
            if ((this.MakeConnectionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MakeConnectionCompleted(this, new MakeConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ManageConnection", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public NetworkInfo[] ManageConnection(ABHandle abHandle, System.Guid contactId, NetworkInfo[] networkInfoList)
        {
            object[] results = this.Invoke("ManageConnection", new object[] {
                                                                                abHandle,
                                                                                contactId,
                                                                                networkInfoList});
            return ((NetworkInfo[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginManageConnection(ABHandle abHandle, System.Guid contactId, NetworkInfo[] networkInfoList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ManageConnection", new object[] {
                                                                         abHandle,
                                                                         contactId,
                                                                         networkInfoList}, callback, asyncState);
        }

        /// <remarks/>
        public NetworkInfo[] EndManageConnection(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((NetworkInfo[])(results[0]));
        }

        /// <remarks/>
        public void ManageConnectionAsync(ABHandle abHandle, System.Guid contactId, NetworkInfo[] networkInfoList)
        {
            this.ManageConnectionAsync(abHandle, contactId, networkInfoList, null);
        }

        /// <remarks/>
        public void ManageConnectionAsync(ABHandle abHandle, System.Guid contactId, NetworkInfo[] networkInfoList, object userState)
        {
            if ((this.ManageConnectionOperationCompleted == null))
            {
                this.ManageConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnManageConnectionOperationCompleted);
            }
            this.InvokeAsync("ManageConnection", new object[] {
                                                                  abHandle,
                                                                  contactId,
                                                                  networkInfoList}, this.ManageConnectionOperationCompleted, userState);
        }

        private void OnManageConnectionOperationCompleted(object arg)
        {
            if ((this.ManageConnectionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ManageConnectionCompleted(this, new ManageConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/BreakConnection", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void BreakConnection(ABHandle abHandle, System.Guid contactId, bool deleteContact, bool blockContact)
        {
            this.Invoke("BreakConnection", new object[] {
                                                            abHandle,
                                                            contactId,
                                                            deleteContact,
                                                            blockContact});
        }

        /// <remarks/>
        public System.IAsyncResult BeginBreakConnection(ABHandle abHandle, System.Guid contactId, bool deleteContact, bool blockContact, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("BreakConnection", new object[] {
                                                                        abHandle,
                                                                        contactId,
                                                                        deleteContact,
                                                                        blockContact}, callback, asyncState);
        }

        /// <remarks/>
        public void EndBreakConnection(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void BreakConnectionAsync(ABHandle abHandle, System.Guid contactId, bool deleteContact, bool blockContact)
        {
            this.BreakConnectionAsync(abHandle, contactId, deleteContact, blockContact, null);
        }

        /// <remarks/>
        public void BreakConnectionAsync(ABHandle abHandle, System.Guid contactId, bool deleteContact, bool blockContact, object userState)
        {
            if ((this.BreakConnectionOperationCompleted == null))
            {
                this.BreakConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBreakConnectionOperationCompleted);
            }
            this.InvokeAsync("BreakConnection", new object[] {
                                                                 abHandle,
                                                                 contactId,
                                                                 deleteContact,
                                                                 blockContact}, this.BreakConnectionOperationCompleted, userState);
        }

        private void OnBreakConnectionOperationCompleted(object arg)
        {
            if ((this.BreakConnectionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BreakConnectionCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ManageWLConnection", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Contact ManageWLConnection(ABHandle abHandle, System.Guid contactId, bool connection, bool presence, int action, int relationshipType, int relationshipRole, ManageWLConnectionOptions options, Annotation[] annotations)
        {
            object[] results = this.Invoke("ManageWLConnection", new object[] {
                                                                                  abHandle,
                                                                                  contactId,
                                                                                  connection,
                                                                                  presence,
                                                                                  action,
                                                                                  relationshipType,
                                                                                  relationshipRole,
                                                                                  options,
                                                                                  annotations});
            return ((Contact)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginManageWLConnection(ABHandle abHandle, System.Guid contactId, bool connection, bool presence, int action, int relationshipType, int relationshipRole, ManageWLConnectionOptions options, Annotation[] annotations, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ManageWLConnection", new object[] {
                                                                           abHandle,
                                                                           contactId,
                                                                           connection,
                                                                           presence,
                                                                           action,
                                                                           relationshipType,
                                                                           relationshipRole,
                                                                           options,
                                                                           annotations}, callback, asyncState);
        }

        /// <remarks/>
        public Contact EndManageWLConnection(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((Contact)(results[0]));
        }

        /// <remarks/>
        public void ManageWLConnectionAsync(ABHandle abHandle, System.Guid contactId, bool connection, bool presence, int action, int relationshipType, int relationshipRole, ManageWLConnectionOptions options, Annotation[] annotations)
        {
            this.ManageWLConnectionAsync(abHandle, contactId, connection, presence, action, relationshipType, relationshipRole, options, annotations, null);
        }

        /// <remarks/>
        public void ManageWLConnectionAsync(ABHandle abHandle, System.Guid contactId, bool connection, bool presence, int action, int relationshipType, int relationshipRole, ManageWLConnectionOptions options, Annotation[] annotations, object userState)
        {
            if ((this.ManageWLConnectionOperationCompleted == null))
            {
                this.ManageWLConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnManageWLConnectionOperationCompleted);
            }
            this.InvokeAsync("ManageWLConnection", new object[] {
                                                                    abHandle,
                                                                    contactId,
                                                                    connection,
                                                                    presence,
                                                                    action,
                                                                    relationshipType,
                                                                    relationshipRole,
                                                                    options,
                                                                    annotations}, this.ManageWLConnectionOperationCompleted, userState);
        }

        private void OnManageWLConnectionOperationCompleted(object arg)
        {
            if ((this.ManageWLConnectionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ManageWLConnectionCompleted(this, new ManageWLConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/StateTransition", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public RelationshipState StateTransition(System.Guid abId, System.Guid contactABId, NetworkInfo networkInfo, NetworkInfo[] contactNetworkInfoList)
        {
            object[] results = this.Invoke("StateTransition", new object[] {
                                                                               abId,
                                                                               contactABId,
                                                                               networkInfo,
                                                                               contactNetworkInfoList});
            return ((RelationshipState)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginStateTransition(System.Guid abId, System.Guid contactABId, NetworkInfo networkInfo, NetworkInfo[] contactNetworkInfoList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("StateTransition", new object[] {
                                                                        abId,
                                                                        contactABId,
                                                                        networkInfo,
                                                                        contactNetworkInfoList}, callback, asyncState);
        }

        /// <remarks/>
        public RelationshipState EndStateTransition(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((RelationshipState)(results[0]));
        }

        /// <remarks/>
        public void StateTransitionAsync(System.Guid abId, System.Guid contactABId, NetworkInfo networkInfo, NetworkInfo[] contactNetworkInfoList)
        {
            this.StateTransitionAsync(abId, contactABId, networkInfo, contactNetworkInfoList, null);
        }

        /// <remarks/>
        public void StateTransitionAsync(System.Guid abId, System.Guid contactABId, NetworkInfo networkInfo, NetworkInfo[] contactNetworkInfoList, object userState)
        {
            if ((this.StateTransitionOperationCompleted == null))
            {
                this.StateTransitionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnStateTransitionOperationCompleted);
            }
            this.InvokeAsync("StateTransition", new object[] {
                                                                 abId,
                                                                 contactABId,
                                                                 networkInfo,
                                                                 contactNetworkInfoList}, this.StateTransitionOperationCompleted, userState);
        }

        private void OnStateTransitionOperationCompleted(object arg)
        {
            if ((this.StateTransitionCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.StateTransitionCompleted(this, new StateTransitionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/CreatePendingMember", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreatePendingMember(System.Guid abId, long puid, Annotation[] annotations)
        {
            this.Invoke("CreatePendingMember", new object[] {
                                                                abId,
                                                                puid,
                                                                annotations});
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreatePendingMember(System.Guid abId, long puid, Annotation[] annotations, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreatePendingMember", new object[] {
                                                                            abId,
                                                                            puid,
                                                                            annotations}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCreatePendingMember(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void CreatePendingMemberAsync(System.Guid abId, long puid, Annotation[] annotations)
        {
            this.CreatePendingMemberAsync(abId, puid, annotations, null);
        }

        /// <remarks/>
        public void CreatePendingMemberAsync(System.Guid abId, long puid, Annotation[] annotations, object userState)
        {
            if ((this.CreatePendingMemberOperationCompleted == null))
            {
                this.CreatePendingMemberOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreatePendingMemberOperationCompleted);
            }
            this.InvokeAsync("CreatePendingMember", new object[] {
                                                                     abId,
                                                                     puid,
                                                                     annotations}, this.CreatePendingMemberOperationCompleted, userState);
        }

        private void OnCreatePendingMemberOperationCompleted(object arg)
        {
            if ((this.CreatePendingMemberCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreatePendingMemberCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/FindWhatsNewSubscriptions", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public WhatsNewSubscriptionsResult FindWhatsNewSubscriptions(ABHandle abHandle, long hash, bool haveHash)
        {
            object[] results = this.Invoke("FindWhatsNewSubscriptions", new object[] {
                                                                                         abHandle,
                                                                                         hash,
                                                                                         haveHash});
            return ((WhatsNewSubscriptionsResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginFindWhatsNewSubscriptions(ABHandle abHandle, long hash, bool haveHash, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("FindWhatsNewSubscriptions", new object[] {
                                                                                  abHandle,
                                                                                  hash,
                                                                                  haveHash}, callback, asyncState);
        }

        /// <remarks/>
        public WhatsNewSubscriptionsResult EndFindWhatsNewSubscriptions(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((WhatsNewSubscriptionsResult)(results[0]));
        }

        /// <remarks/>
        public void FindWhatsNewSubscriptionsAsync(ABHandle abHandle, long hash, bool haveHash)
        {
            this.FindWhatsNewSubscriptionsAsync(abHandle, hash, haveHash, null);
        }

        /// <remarks/>
        public void FindWhatsNewSubscriptionsAsync(ABHandle abHandle, long hash, bool haveHash, object userState)
        {
            if ((this.FindWhatsNewSubscriptionsOperationCompleted == null))
            {
                this.FindWhatsNewSubscriptionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFindWhatsNewSubscriptionsOperationCompleted);
            }
            this.InvokeAsync("FindWhatsNewSubscriptions", new object[] {
                                                                           abHandle,
                                                                           hash,
                                                                           haveHash}, this.FindWhatsNewSubscriptionsOperationCompleted, userState);
        }

        private void OnFindWhatsNewSubscriptionsOperationCompleted(object arg)
        {
            if ((this.FindWhatsNewSubscriptionsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.FindWhatsNewSubscriptionsCompleted(this, new FindWhatsNewSubscriptionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/CircleUpdateInverseInfo", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CircleUpdateInverseInfo(System.Guid abId, CircleInverseInfo[] circleInverseInfoList)
        {
            this.Invoke("CircleUpdateInverseInfo", new object[] {
                                                                    abId,
                                                                    circleInverseInfoList});
        }

        /// <remarks/>
        public System.IAsyncResult BeginCircleUpdateInverseInfo(System.Guid abId, CircleInverseInfo[] circleInverseInfoList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CircleUpdateInverseInfo", new object[] {
                                                                                abId,
                                                                                circleInverseInfoList}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCircleUpdateInverseInfo(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void CircleUpdateInverseInfoAsync(System.Guid abId, CircleInverseInfo[] circleInverseInfoList)
        {
            this.CircleUpdateInverseInfoAsync(abId, circleInverseInfoList, null);
        }

        /// <remarks/>
        public void CircleUpdateInverseInfoAsync(System.Guid abId, CircleInverseInfo[] circleInverseInfoList, object userState)
        {
            if ((this.CircleUpdateInverseInfoOperationCompleted == null))
            {
                this.CircleUpdateInverseInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCircleUpdateInverseInfoOperationCompleted);
            }
            this.InvokeAsync("CircleUpdateInverseInfo", new object[] {
                                                                         abId,
                                                                         circleInverseInfoList}, this.CircleUpdateInverseInfoOperationCompleted, userState);
        }

        private void OnCircleUpdateInverseInfoOperationCompleted(object arg)
        {
            if ((this.CircleUpdateInverseInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CircleUpdateInverseInfoCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ABFindContactsPaged", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FindContactsPagedResult ABFindContactsPaged(ABHandle abHandle, ABView abView, FindPageContext pageContext, FindSortOptions sortOptions, FindFilterOptions filterOptions, ExtendedContentTypes extendedContent)
        {
            object[] results = this.Invoke("ABFindContactsPaged", new object[] {
                                                                                   abHandle,
                                                                                   abView,
                                                                                   pageContext,
                                                                                   sortOptions,
                                                                                   filterOptions,
                                                                                   extendedContent});
            return ((FindContactsPagedResult)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginABFindContactsPaged(ABHandle abHandle, ABView abView, FindPageContext pageContext, FindSortOptions sortOptions, FindFilterOptions filterOptions, ExtendedContentTypes extendedContent, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ABFindContactsPaged", new object[] {
                                                                            abHandle,
                                                                            abView,
                                                                            pageContext,
                                                                            sortOptions,
                                                                            filterOptions,
                                                                            extendedContent}, callback, asyncState);
        }

        /// <remarks/>
        public FindContactsPagedResult EndABFindContactsPaged(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((FindContactsPagedResult)(results[0]));
        }

        /// <remarks/>
        public void ABFindContactsPagedAsync(ABHandle abHandle, ABView abView, FindPageContext pageContext, FindSortOptions sortOptions, FindFilterOptions filterOptions, ExtendedContentTypes extendedContent)
        {
            this.ABFindContactsPagedAsync(abHandle, abView, pageContext, sortOptions, filterOptions, extendedContent, null);
        }

        /// <remarks/>
        public void ABFindContactsPagedAsync(ABHandle abHandle, ABView abView, FindPageContext pageContext, FindSortOptions sortOptions, FindFilterOptions filterOptions, ExtendedContentTypes extendedContent, object userState)
        {
            if ((this.ABFindContactsPagedOperationCompleted == null))
            {
                this.ABFindContactsPagedOperationCompleted = new System.Threading.SendOrPostCallback(this.OnABFindContactsPagedOperationCompleted);
            }
            this.InvokeAsync("ABFindContactsPaged", new object[] {
                                                                     abHandle,
                                                                     abView,
                                                                     pageContext,
                                                                     sortOptions,
                                                                     filterOptions,
                                                                     extendedContent}, this.ABFindContactsPagedOperationCompleted, userState);
        }

        private void OnABFindContactsPagedOperationCompleted(object arg)
        {
            if ((this.ABFindContactsPagedCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ABFindContactsPagedCompleted(this, new ABFindContactsPagedCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ReplaceHandle", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ReplaceHandle(ABHandle targetAB, ABHandle handleToReplace)
        {
            this.Invoke("ReplaceHandle", new object[] {
                                                          targetAB,
                                                          handleToReplace});
        }

        /// <remarks/>
        public System.IAsyncResult BeginReplaceHandle(ABHandle targetAB, ABHandle handleToReplace, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReplaceHandle", new object[] {
                                                                      targetAB,
                                                                      handleToReplace}, callback, asyncState);
        }

        /// <remarks/>
        public void EndReplaceHandle(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void ReplaceHandleAsync(ABHandle targetAB, ABHandle handleToReplace)
        {
            this.ReplaceHandleAsync(targetAB, handleToReplace, null);
        }

        /// <remarks/>
        public void ReplaceHandleAsync(ABHandle targetAB, ABHandle handleToReplace, object userState)
        {
            if ((this.ReplaceHandleOperationCompleted == null))
            {
                this.ReplaceHandleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReplaceHandleOperationCompleted);
            }
            this.InvokeAsync("ReplaceHandle", new object[] {
                                                               targetAB,
                                                               handleToReplace}, this.ReplaceHandleOperationCompleted, userState);
        }

        private void OnReplaceHandleOperationCompleted(object arg)
        {
            if ((this.ReplaceHandleCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReplaceHandleCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/ReserveAndFilter", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FilterEmail[] ReserveAndFilter(ABHandle abHandle, FilterEmail[] filterEmails)
        {
            object[] results = this.Invoke("ReserveAndFilter", new object[] {
                                                                                abHandle,
                                                                                filterEmails});
            return ((FilterEmail[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginReserveAndFilter(ABHandle abHandle, FilterEmail[] filterEmails, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReserveAndFilter", new object[] {
                                                                         abHandle,
                                                                         filterEmails}, callback, asyncState);
        }

        /// <remarks/>
        public FilterEmail[] EndReserveAndFilter(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((FilterEmail[])(results[0]));
        }

        /// <remarks/>
        public void ReserveAndFilterAsync(ABHandle abHandle, FilterEmail[] filterEmails)
        {
            this.ReserveAndFilterAsync(abHandle, filterEmails, null);
        }

        /// <remarks/>
        public void ReserveAndFilterAsync(ABHandle abHandle, FilterEmail[] filterEmails, object userState)
        {
            if ((this.ReserveAndFilterOperationCompleted == null))
            {
                this.ReserveAndFilterOperationCompleted = new System.Threading.SendOrPostCallback(this.OnReserveAndFilterOperationCompleted);
            }
            this.InvokeAsync("ReserveAndFilter", new object[] {
                                                                  abHandle,
                                                                  filterEmails}, this.ReserveAndFilterOperationCompleted, userState);
        }

        private void OnReserveAndFilterOperationCompleted(object arg)
        {
            if ((this.ReserveAndFilterCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ReserveAndFilterCompleted(this, new ReserveAndFilterCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/MigrateAB", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void MigrateAB(ABHandle abHandle)
        {
            this.Invoke("MigrateAB", new object[] {
                                                      abHandle});
        }

        /// <remarks/>
        public System.IAsyncResult BeginMigrateAB(ABHandle abHandle, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("MigrateAB", new object[] {
                                                                  abHandle}, callback, asyncState);
        }

        /// <remarks/>
        public void EndMigrateAB(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void MigrateABAsync(ABHandle abHandle)
        {
            this.MigrateABAsync(abHandle, null);
        }

        /// <remarks/>
        public void MigrateABAsync(ABHandle abHandle, object userState)
        {
            if ((this.MigrateABOperationCompleted == null))
            {
                this.MigrateABOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMigrateABOperationCompleted);
            }
            this.InvokeAsync("MigrateAB", new object[] {
                                                           abHandle}, this.MigrateABOperationCompleted, userState);
        }

        private void OnMigrateABOperationCompleted(object arg)
        {
            if ((this.MigrateABCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MigrateABCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/GetGeoLocation", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GeoLocation GetGeoLocation(ABHandle abHandle, System.Guid partnerId)
        {
            object[] results = this.Invoke("GetGeoLocation", new object[] {
                                                                              abHandle,
                                                                              partnerId});
            return ((GeoLocation)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetGeoLocation(ABHandle abHandle, System.Guid partnerId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetGeoLocation", new object[] {
                                                                       abHandle,
                                                                       partnerId}, callback, asyncState);
        }

        /// <remarks/>
        public GeoLocation EndGetGeoLocation(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((GeoLocation)(results[0]));
        }

        /// <remarks/>
        public void GetGeoLocationAsync(ABHandle abHandle, System.Guid partnerId)
        {
            this.GetGeoLocationAsync(abHandle, partnerId, null);
        }

        /// <remarks/>
        public void GetGeoLocationAsync(ABHandle abHandle, System.Guid partnerId, object userState)
        {
            if ((this.GetGeoLocationOperationCompleted == null))
            {
                this.GetGeoLocationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetGeoLocationOperationCompleted);
            }
            this.InvokeAsync("GetGeoLocation", new object[] {
                                                                abHandle,
                                                                partnerId}, this.GetGeoLocationOperationCompleted, userState);
        }

        private void OnGetGeoLocationOperationCompleted(object arg)
        {
            if ((this.GetGeoLocationCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetGeoLocationCompleted(this, new GetGeoLocationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABAuthHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABTestHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ABApplicationHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("ServiceHeaderValue", Direction = System.Web.Services.Protocols.SoapHeaderDirection.Out)]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/webservices/AddressBook/SetGeoLocation", RequestNamespace = "http://www.msn.com/webservices/AddressBook", ResponseNamespace = "http://www.msn.com/webservices/AddressBook", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetGeoLocation(ABHandle abHandle, System.Guid partnerId, GeoLocation geoLocation)
        {
            this.Invoke("SetGeoLocation", new object[] {
                                                           abHandle,
                                                           partnerId,
                                                           geoLocation});
        }

        /// <remarks/>
        public System.IAsyncResult BeginSetGeoLocation(ABHandle abHandle, System.Guid partnerId, GeoLocation geoLocation, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SetGeoLocation", new object[] {
                                                                       abHandle,
                                                                       partnerId,
                                                                       geoLocation}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSetGeoLocation(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void SetGeoLocationAsync(ABHandle abHandle, System.Guid partnerId, GeoLocation geoLocation)
        {
            this.SetGeoLocationAsync(abHandle, partnerId, geoLocation, null);
        }

        /// <remarks/>
        public void SetGeoLocationAsync(ABHandle abHandle, System.Guid partnerId, GeoLocation geoLocation, object userState)
        {
            if ((this.SetGeoLocationOperationCompleted == null))
            {
                this.SetGeoLocationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetGeoLocationOperationCompleted);
            }
            this.InvokeAsync("SetGeoLocation", new object[] {
                                                                abHandle,
                                                                partnerId,
                                                                geoLocation}, this.SetGeoLocationOperationCompleted, userState);
        }

        private void OnSetGeoLocationOperationCompleted(object arg)
        {
            if ((this.SetGeoLocationCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetGeoLocationCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://www.msn.com/webservices/AddressBook", IsNullable = false)]
    public partial class ABAuthHeader : System.Web.Services.Protocols.SoapHeader
    {

        private bool managedGroupRequestField;

        private IdentificationHeader callerIdentificationField;

        private string ticketTokenField;

        private System.Xml.XmlAttribute[] anyAttrField;

        /// <remarks/>
        public bool ManagedGroupRequest
        {
            get
            {
                return this.managedGroupRequestField;
            }
            set
            {
                this.managedGroupRequestField = value;
            }
        }

        /// <remarks/>
        public IdentificationHeader CallerIdentification
        {
            get
            {
                return this.callerIdentificationField;
            }
            set
            {
                this.callerIdentificationField = value;
            }
        }

        /// <remarks/>
        public string TicketToken
        {
            get
            {
                return this.ticketTokenField;
            }
            set
            {
                this.ticketTokenField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr
        {
            get
            {
                return this.anyAttrField;
            }
            set
            {
                this.anyAttrField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class IdentificationHeader
    {

        private long callerPassportIdField;

        private string callerPassportNameField;

        private string callerEmailField;

        /// <remarks/>
        public long CallerPassportId
        {
            get
            {
                return this.callerPassportIdField;
            }
            set
            {
                this.callerPassportIdField = value;
            }
        }

        /// <remarks/>
        public string CallerPassportName
        {
            get
            {
                return this.callerPassportNameField;
            }
            set
            {
                this.callerPassportNameField = value;
            }
        }

        /// <remarks/>
        public string CallerEmail
        {
            get
            {
                return this.callerEmailField;
            }
            set
            {
                this.callerEmailField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class GeoLocation
    {

        private short ldcIdField;

        /// <remarks/>
        public short LdcId
        {
            get
            {
                return this.ldcIdField;
            }
            set
            {
                this.ldcIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class FilterEmail
    {

        private string emailAddressField;

        private string wLIDField;

        private long pUIDField;

        private long cIDField;

        private int statusField;

        /// <remarks/>
        public string EmailAddress
        {
            get
            {
                return this.emailAddressField;
            }
            set
            {
                this.emailAddressField = value;
            }
        }

        /// <remarks/>
        public string WLID
        {
            get
            {
                return this.wLIDField;
            }
            set
            {
                this.wLIDField = value;
            }
        }

        /// <remarks/>
        public long PUID
        {
            get
            {
                return this.pUIDField;
            }
            set
            {
                this.pUIDField = value;
            }
        }

        /// <remarks/>
        public long CID
        {
            get
            {
                return this.cIDField;
            }
            set
            {
                this.cIDField = value;
            }
        }

        /// <remarks/>
        public int Status
        {
            get
            {
                return this.statusField;
            }
            set
            {
                this.statusField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class AllCircleInverseInfo
    {

        private CircleInverseInfo[] circlesField;

        private string circleTicketField;

        /// <remarks/>
        public CircleInverseInfo[] Circles
        {
            get
            {
                return this.circlesField;
            }
            set
            {
                this.circlesField = value;
            }
        }

        /// <remarks/>
        public string CircleTicket
        {
            get
            {
                return this.circleTicketField;
            }
            set
            {
                this.circleTicketField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleInverseInfo
    {

        private CircleContent contentField;

        private CirclePersonalInfo personalInfoField;

        private bool deletedField;

        /// <remarks/>
        public CircleContent Content
        {
            get
            {
                return this.contentField;
            }
            set
            {
                this.contentField = value;
            }
        }

        /// <remarks/>
        public CirclePersonalInfo PersonalInfo
        {
            get
            {
                return this.personalInfoField;
            }
            set
            {
                this.personalInfoField = value;
            }
        }

        /// <remarks/>
        public bool Deleted
        {
            get
            {
                return this.deletedField;
            }
            set
            {
                this.deletedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleContent
    {

        private CircleHandle handleField;

        private CircleProperties infoField;

        /// <remarks/>
        public CircleHandle Handle
        {
            get
            {
                return this.handleField;
            }
            set
            {
                this.handleField = value;
            }
        }

        /// <remarks/>
        public CircleProperties Info
        {
            get
            {
                return this.infoField;
            }
            set
            {
                this.infoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleHandle
    {

        private System.Guid idField;

        /// <remarks/>
        public System.Guid Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleProperties
    {

        private int domainField;

        private string hostedDomainField;

        private int typeField;

        private int membershipAccessField;

        private bool isPresenceEnabledField;

        private int requestMembershipOptionField;

        private string displayNameField;

        private string notesField;

        private System.DateTime profileLastUpdatedField;

        private CirclePropertyChanges changesField;

        private System.DateTime createDateField;

        private System.DateTime lastChangedField;

        /// <remarks/>
        public int Domain
        {
            get
            {
                return this.domainField;
            }
            set
            {
                this.domainField = value;
            }
        }

        /// <remarks/>
        public string HostedDomain
        {
            get
            {
                return this.hostedDomainField;
            }
            set
            {
                this.hostedDomainField = value;
            }
        }

        /// <remarks/>
        public int Type
        {
            get
            {
                return this.typeField;
            }
            set
            {
                this.typeField = value;
            }
        }

        /// <remarks/>
        public int MembershipAccess
        {
            get
            {
                return this.membershipAccessField;
            }
            set
            {
                this.membershipAccessField = value;
            }
        }

        /// <remarks/>
        public bool IsPresenceEnabled
        {
            get
            {
                return this.isPresenceEnabledField;
            }
            set
            {
                this.isPresenceEnabledField = value;
            }
        }

        /// <remarks/>
        public int RequestMembershipOption
        {
            get
            {
                return this.requestMembershipOptionField;
            }
            set
            {
                this.requestMembershipOptionField = value;
            }
        }

        /// <remarks/>
        public string DisplayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }

        /// <remarks/>
        public string Notes
        {
            get
            {
                return this.notesField;
            }
            set
            {
                this.notesField = value;
            }
        }

        /// <remarks/>
        public System.DateTime ProfileLastUpdated
        {
            get
            {
                return this.profileLastUpdatedField;
            }
            set
            {
                this.profileLastUpdatedField = value;
            }
        }

        /// <remarks/>
        public CirclePropertyChanges Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }

        /// <remarks/>
        public System.DateTime CreateDate
        {
            get
            {
                return this.createDateField;
            }
            set
            {
                this.createDateField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChanged
        {
            get
            {
                return this.lastChangedField;
            }
            set
            {
                this.lastChangedField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum CirclePropertyChanges
    {

        /// <remarks/>
        MembershipAccess = 1,

        /// <remarks/>
        IsPresenceEnabled = 2,

        /// <remarks/>
        DisplayName = 4,

        /// <remarks/>
        RequestMembershipOption = 8,

        /// <remarks/>
        Notes = 16,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CirclePersonalInfo
    {

        private CirclePersonalMembership[] membershipInfoField;

        private string nameField;

        private bool isNotMobileVisibleField;

        private string sharedFolderInfoField;

        private bool isFavoriteField;

        private bool isFamilyField;

        private CirclePersonalInfoPropertyTypes changesField;

        private string notesField;

        /// <remarks/>
        public CirclePersonalMembership[] MembershipInfo
        {
            get
            {
                return this.membershipInfoField;
            }
            set
            {
                this.membershipInfoField = value;
            }
        }

        /// <remarks/>
        public string Name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public bool IsNotMobileVisible
        {
            get
            {
                return this.isNotMobileVisibleField;
            }
            set
            {
                this.isNotMobileVisibleField = value;
            }
        }

        /// <remarks/>
        public string SharedFolderInfo
        {
            get
            {
                return this.sharedFolderInfoField;
            }
            set
            {
                this.sharedFolderInfoField = value;
            }
        }

        /// <remarks/>
        public bool IsFavorite
        {
            get
            {
                return this.isFavoriteField;
            }
            set
            {
                this.isFavoriteField = value;
            }
        }

        /// <remarks/>
        public bool IsFamily
        {
            get
            {
                return this.isFamilyField;
            }
            set
            {
                this.isFamilyField = value;
            }
        }

        /// <remarks/>
        public CirclePersonalInfoPropertyTypes Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }

        /// <remarks/>
        public string Notes
        {
            get
            {
                return this.notesField;
            }
            set
            {
                this.notesField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CirclePersonalMembership
    {

        private RoleId roleField;

        private MemberState stateField;

        /// <remarks/>
        public RoleId Role
        {
            get
            {
                return this.roleField;
            }
            set
            {
                this.roleField = value;
            }
        }

        /// <remarks/>
        public MemberState State
        {
            get
            {
                return this.stateField;
            }
            set
            {
                this.stateField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum RoleId
    {

        /// <remarks/>
        Admin,

        /// <remarks/>
        AssistantAdmin,

        /// <remarks/>
        Member,

        /// <remarks/>
        Guest,

        /// <remarks/>
        Banned,

        /// <remarks/>
        Delegate,

        /// <remarks/>
        Allow,

        /// <remarks/>
        Block,

        /// <remarks/>
        Reverse,

        /// <remarks/>
        Pending,

        /// <remarks/>
        CalFreeBusy,

        /// <remarks/>
        Contributor,

        /// <remarks/>
        NamespaceQuota,

        /// <remarks/>
        TwoWayRelationship,

        /// <remarks/>
        OneWayRelationship,

        /// <remarks/>
        ProfileCareer,

        /// <remarks/>
        ProfileDating,

        /// <remarks/>
        ProfileEducation,

        /// <remarks/>
        ProfileGaming,

        /// <remarks/>
        ProfileGeneral,

        /// <remarks/>
        ProfilePersonalContact,

        /// <remarks/>
        ProfileProfessionalContact,

        /// <remarks/>
        ProfileSocial,

        /// <remarks/>
        ProfileExpression,

        /// <remarks/>
        CircleProfileGeneral,

        /// <remarks/>
        CircleProfileEvent,

        /// <remarks/>
        Custom,

        /// <remarks/>
        AllMember,

        /// <remarks/>
        AllAdmin,

        /// <remarks/>
        Partner,

        /// <remarks/>
        CircleContactProfile1,

        /// <remarks/>
        CircleContactProfile2,

        /// <remarks/>
        PostPending,

        /// <remarks/>
        VoteAsSpammer,

        /// <remarks/>
        Reader,

        /// <remarks/>
        ReadWrite,

        /// <remarks/>
        ReadOnly,

        /// <remarks/>
        WebProfileList,

        /// <remarks/>
        ReadSpacePhotos,

        /// <remarks/>
        ReadWriteSpacePhotos,

        /// <remarks/>
        CircleProfileEventGeneral,

        /// <remarks/>
        ContactsView,

        /// <remarks/>
        ContactsUpdate,

        /// <remarks/>
        ContactsSyncFullSync,

        /// <remarks/>
        ContactsInvite,

        /// <remarks/>
        ContactsNoUIInvite,

        /// <remarks/>
        IMControlIMAllowAll,

        /// <remarks/>
        MessengerSignIn,

        /// <remarks/>
        IsvOffer8,

        /// <remarks/>
        IsvOffer9,

        /// <remarks/>
        IsvOffer10,

        /// <remarks/>
        ReadService,

        /// <remarks/>
        ReadWriteService,

        /// <remarks/>
        Favorite,

        /// <remarks/>
        CalFreeBusyPlus,

        /// <remarks/>
        StateNone,

        /// <remarks/>
        StatePendingInbound,

        /// <remarks/>
        StatePendingOutbound,

        /// <remarks/>
        StateAccepted,

        /// <remarks/>
        StateDeclined,

        /// <remarks/>
        ProfilePublic,

        /// <remarks/>
        TwoDegrees,

        /// <remarks/>
        AllowHidden,

        /// <remarks/>
        ProfileLocation,

        /// <remarks/>
        ProfileShopping,

        /// <remarks/>
        RecentlySent,

        /// <remarks/>
        BlogsRead,

        /// <remarks/>
        BlogsUpdate,

        /// <remarks/>
        FilesRead,

        /// <remarks/>
        FilesUpdate,

        /// <remarks/>
        ListsRead,

        /// <remarks/>
        ListsUpdate,

        /// <remarks/>
        GroupsRead,

        /// <remarks/>
        GroupsModify,

        /// <remarks/>
        GroupsCreate,

        /// <remarks/>
        EventsRead,

        /// <remarks/>
        EventsModify,

        /// <remarks/>
        EventsCreate,

        /// <remarks/>
        RecentActivitiesRead,

        /// <remarks/>
        WhatsNewRead,

        /// <remarks/>
        ProfileRead,

        /// <remarks/>
        ProfileUpdate,

        /// <remarks/>
        Level1,

        /// <remarks/>
        Level2,

        /// <remarks/>
        Level3,

        /// <remarks/>
        Level4,

        /// <remarks/>
        Level5,

        /// <remarks/>
        Level6,

        /// <remarks/>
        Level7,

        /// <remarks/>
        Level8,

        /// <remarks/>
        Level9,

        /// <remarks/>
        Level10,

        /// <remarks/>
        Level11,

        /// <remarks/>
        Level12,

        /// <remarks/>
        Level13,

        /// <remarks/>
        Level14,

        /// <remarks/>
        ApplicationDelegateRead,

        /// <remarks/>
        ApplicationDelegateWrite,

        /// <remarks/>
        ApplicationRead,

        /// <remarks/>
        ApplicationWrite,

        /// <remarks/>
        SignIn,

        /// <remarks/>
        IMAllowAll,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum MemberState
    {

        /// <remarks/>
        Pending,

        /// <remarks/>
        Declined,

        /// <remarks/>
        Accepted,

        /// <remarks/>
        Removed,

        /// <remarks/>
        Tentative,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum CirclePersonalInfoPropertyTypes
    {

        /// <remarks/>
        Name = 1,

        /// <remarks/>
        IsNotMobileVisible = 2,

        /// <remarks/>
        SharedFolderInfo = 4,

        /// <remarks/>
        IsFavorite = 8,

        /// <remarks/>
        IsFamily = 16,

        /// <remarks/>
        Notes = 32,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class FindContactsPagedResult
    {

        private Group[] groupsField;

        private Contact[] contactsField;

        private Category[] categoriesField;

        private AllCircleInverseInfo circleResultField;

        private AB abField;

        /// <remarks/>
        public Group[] Groups
        {
            get
            {
                return this.groupsField;
            }
            set
            {
                this.groupsField = value;
            }
        }

        /// <remarks/>
        public Contact[] Contacts
        {
            get
            {
                return this.contactsField;
            }
            set
            {
                this.contactsField = value;
            }
        }

        /// <remarks/>
        public Category[] Categories
        {
            get
            {
                return this.categoriesField;
            }
            set
            {
                this.categoriesField = value;
            }
        }

        /// <remarks/>
        public AllCircleInverseInfo CircleResult
        {
            get
            {
                return this.circleResultField;
            }
            set
            {
                this.circleResultField = value;
            }
        }

        /// <remarks/>
        public AB Ab
        {
            get
            {
                return this.abField;
            }
            set
            {
                this.abField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class Group
    {

        private System.Guid groupIdField;

        private GroupInfo groupInfoField;

        private GroupPropertyType propertiesChangedField;

        private bool fDeletedField;

        private System.DateTime lastChangeField;

        /// <remarks/>
        public System.Guid groupId
        {
            get
            {
                return this.groupIdField;
            }
            set
            {
                this.groupIdField = value;
            }
        }

        /// <remarks/>
        public GroupInfo groupInfo
        {
            get
            {
                return this.groupInfoField;
            }
            set
            {
                this.groupInfoField = value;
            }
        }

        /// <remarks/>
        public GroupPropertyType propertiesChanged
        {
            get
            {
                return this.propertiesChangedField;
            }
            set
            {
                this.propertiesChangedField = value;
            }
        }

        /// <remarks/>
        public bool fDeleted
        {
            get
            {
                return this.fDeletedField;
            }
            set
            {
                this.fDeletedField = value;
            }
        }

        /// <remarks/>
        public System.DateTime lastChange
        {
            get
            {
                return this.lastChangeField;
            }
            set
            {
                this.lastChangeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class GroupInfo
    {

        private Annotation[] annotationsField;

        private System.Guid groupTypeField;

        private string nameField;

        private string clientErrorDataField;

        private bool isNotMobileVisibleField;

        private Category[] categoriesField;

        private bool isPrivateField;

        private bool isFavoriteField;

        /// <remarks/>
        public Annotation[] annotations
        {
            get
            {
                return this.annotationsField;
            }
            set
            {
                this.annotationsField = value;
            }
        }

        /// <remarks/>
        public System.Guid groupType
        {
            get
            {
                return this.groupTypeField;
            }
            set
            {
                this.groupTypeField = value;
            }
        }

        /// <remarks/>
        public string name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public string clientErrorData
        {
            get
            {
                return this.clientErrorDataField;
            }
            set
            {
                this.clientErrorDataField = value;
            }
        }

        /// <remarks/>
        public bool IsNotMobileVisible
        {
            get
            {
                return this.isNotMobileVisibleField;
            }
            set
            {
                this.isNotMobileVisibleField = value;
            }
        }

        /// <remarks/>
        public Category[] Categories
        {
            get
            {
                return this.categoriesField;
            }
            set
            {
                this.categoriesField = value;
            }
        }

        /// <remarks/>
        public bool IsPrivate
        {
            get
            {
                return this.isPrivateField;
            }
            set
            {
                this.isPrivateField = value;
            }
        }

        /// <remarks/>
        public bool IsFavorite
        {
            get
            {
                return this.isFavoriteField;
            }
            set
            {
                this.isFavoriteField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class Annotation
    {

        private string nameField;

        private string valueField;

        /// <remarks/>
        public string Name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public string Value
        {
            get
            {
                return this.valueField;
            }
            set
            {
                this.valueField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class Category
    {

        private short idField;

        private string nameField;

        private CategoryPropertyType changesField;

        private bool changesFieldSpecified;

        private bool deletedField;

        private bool deletedFieldSpecified;

        private System.DateTime lastChangeField;

        private bool lastChangeFieldSpecified;

        private string clientErrorDataField;

        /// <remarks/>
        public short Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public string Name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public CategoryPropertyType Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ChangesSpecified
        {
            get
            {
                return this.changesFieldSpecified;
            }
            set
            {
                this.changesFieldSpecified = value;
            }
        }

        /// <remarks/>
        public bool Deleted
        {
            get
            {
                return this.deletedField;
            }
            set
            {
                this.deletedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DeletedSpecified
        {
            get
            {
                return this.deletedFieldSpecified;
            }
            set
            {
                this.deletedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChange
        {
            get
            {
                return this.lastChangeField;
            }
            set
            {
                this.lastChangeField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool LastChangeSpecified
        {
            get
            {
                return this.lastChangeFieldSpecified;
            }
            set
            {
                this.lastChangeFieldSpecified = value;
            }
        }

        /// <remarks/>
        public string ClientErrorData
        {
            get
            {
                return this.clientErrorDataField;
            }
            set
            {
                this.clientErrorDataField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum CategoryPropertyType
    {

        /// <remarks/>
        Name = 1,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum GroupPropertyType
    {

        /// <remarks/>
        GroupName = 1,

        /// <remarks/>
        Annotation = 2,

        /// <remarks/>
        IsNotMobileVisible = 4,

        /// <remarks/>
        Categories = 8,

        /// <remarks/>
        IsPrivate = 16,

        /// <remarks/>
        IsFavorite = 32,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class Contact
    {

        private System.Guid contactIdField;

        private ContactInfo contactInfoField;

        private ContactPropertyType propertiesChangedField;

        private bool fDeletedField;

        private System.DateTime createDateField;

        private System.DateTime lastChangeField;

        private string createdByField;

        private string lastModifiedByField;

        /// <remarks/>
        public System.Guid contactId
        {
            get
            {
                return this.contactIdField;
            }
            set
            {
                this.contactIdField = value;
            }
        }

        /// <remarks/>
        public ContactInfo contactInfo
        {
            get
            {
                return this.contactInfoField;
            }
            set
            {
                this.contactInfoField = value;
            }
        }

        /// <remarks/>
        public ContactPropertyType propertiesChanged
        {
            get
            {
                return this.propertiesChangedField;
            }
            set
            {
                this.propertiesChangedField = value;
            }
        }

        /// <remarks/>
        public bool fDeleted
        {
            get
            {
                return this.fDeletedField;
            }
            set
            {
                this.fDeletedField = value;
            }
        }

        /// <remarks/>
        public System.DateTime CreateDate
        {
            get
            {
                return this.createDateField;
            }
            set
            {
                this.createDateField = value;
            }
        }

        /// <remarks/>
        public System.DateTime lastChange
        {
            get
            {
                return this.lastChangeField;
            }
            set
            {
                this.lastChangeField = value;
            }
        }

        /// <remarks/>
        public string CreatedBy
        {
            get
            {
                return this.createdByField;
            }
            set
            {
                this.createdByField = value;
            }
        }

        /// <remarks/>
        public string LastModifiedBy
        {
            get
            {
                return this.lastModifiedByField;
            }
            set
            {
                this.lastModifiedByField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactInfo
    {

        private ContactEmail[] emailsField;

        private ContactPhone[] phonesField;

        private ContactLocation[] locationsField;

        private ContactWebSite[] webSitesField;

        private Annotation[] annotationsField;

        private System.Guid[] groupIdsField;

        private System.Guid[] groupIdsDeletedField;

        private string clientErrorDataField;

        private ContactType contactTypeField;

        private string quickNameField;

        private string firstNameField;

        private string middleNameField;

        private string lastNameField;

        private string suffixField;

        private string nameTitleField;

        private string passportNameField;

        private bool isPassportNameHiddenField;

        private string displayNameField;

        private long puidField;

        private long cIDField;

        private string brandIdMasterField;

        private string brandIdListField;

        private string commentField;

        private bool isNotMobileVisibleField;

        private bool isMobileIMEnabledField;

        private bool isMessengerUserField;

        private bool isFavoriteField;

        private bool isSmtpField;

        private bool hasSpaceField;

        private SpotType spotWatchStateField;

        private System.DateTime birthdateField;

        private ContactEmailType primaryEmailTypeField;

        private ContactLocationType primaryLocationField;

        private ContactPhoneType primaryPhoneField;

        private Category[] categoriesField;

        private string fileAsField;

        private bool isPrivateField;

        private bool isHiddenField;

        private string anniversaryField;

        private GenderType genderField;

        private TimeZoneRange timeZoneField;

        private MessengerMemberInfo messengerMemberInfoField;

        private string yomiFirstNameField;

        private string yomiLastNameField;

        private ContactURL[] uRLsField;

        private ContactRelationship[] relationshipsField;

        private NetworkInfo[] networkInfoListField;

        private string publicDisplayNameField;

        private bool isAutoUpdateDisabledField;

        private ContactProperties propertiesChangedField;

        /// <remarks/>
        public ContactEmail[] emails
        {
            get
            {
                return this.emailsField;
            }
            set
            {
                this.emailsField = value;
            }
        }

        /// <remarks/>
        public ContactPhone[] phones
        {
            get
            {
                return this.phonesField;
            }
            set
            {
                this.phonesField = value;
            }
        }

        /// <remarks/>
        public ContactLocation[] locations
        {
            get
            {
                return this.locationsField;
            }
            set
            {
                this.locationsField = value;
            }
        }

        /// <remarks/>
        public ContactWebSite[] webSites
        {
            get
            {
                return this.webSitesField;
            }
            set
            {
                this.webSitesField = value;
            }
        }

        /// <remarks/>
        public Annotation[] annotations
        {
            get
            {
                return this.annotationsField;
            }
            set
            {
                this.annotationsField = value;
            }
        }

        /// <remarks/>
        public System.Guid[] groupIds
        {
            get
            {
                return this.groupIdsField;
            }
            set
            {
                this.groupIdsField = value;
            }
        }

        /// <remarks/>
        public System.Guid[] groupIdsDeleted
        {
            get
            {
                return this.groupIdsDeletedField;
            }
            set
            {
                this.groupIdsDeletedField = value;
            }
        }

        /// <remarks/>
        public string clientErrorData
        {
            get
            {
                return this.clientErrorDataField;
            }
            set
            {
                this.clientErrorDataField = value;
            }
        }

        /// <remarks/>
        public ContactType contactType
        {
            get
            {
                return this.contactTypeField;
            }
            set
            {
                this.contactTypeField = value;
            }
        }

        /// <remarks/>
        public string quickName
        {
            get
            {
                return this.quickNameField;
            }
            set
            {
                this.quickNameField = value;
            }
        }

        /// <remarks/>
        public string firstName
        {
            get
            {
                return this.firstNameField;
            }
            set
            {
                this.firstNameField = value;
            }
        }

        /// <remarks/>
        public string MiddleName
        {
            get
            {
                return this.middleNameField;
            }
            set
            {
                this.middleNameField = value;
            }
        }

        /// <remarks/>
        public string lastName
        {
            get
            {
                return this.lastNameField;
            }
            set
            {
                this.lastNameField = value;
            }
        }

        /// <remarks/>
        public string Suffix
        {
            get
            {
                return this.suffixField;
            }
            set
            {
                this.suffixField = value;
            }
        }

        /// <remarks/>
        public string NameTitle
        {
            get
            {
                return this.nameTitleField;
            }
            set
            {
                this.nameTitleField = value;
            }
        }

        /// <remarks/>
        public string passportName
        {
            get
            {
                return this.passportNameField;
            }
            set
            {
                this.passportNameField = value;
            }
        }

        /// <remarks/>
        public bool IsPassportNameHidden
        {
            get
            {
                return this.isPassportNameHiddenField;
            }
            set
            {
                this.isPassportNameHiddenField = value;
            }
        }

        /// <remarks/>
        public string displayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }

        /// <remarks/>
        public long puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }

        /// <remarks/>
        public long CID
        {
            get
            {
                return this.cIDField;
            }
            set
            {
                this.cIDField = value;
            }
        }

        /// <remarks/>
        public string BrandIdMaster
        {
            get
            {
                return this.brandIdMasterField;
            }
            set
            {
                this.brandIdMasterField = value;
            }
        }

        /// <remarks/>
        public string BrandIdList
        {
            get
            {
                return this.brandIdListField;
            }
            set
            {
                this.brandIdListField = value;
            }
        }

        /// <remarks/>
        public string comment
        {
            get
            {
                return this.commentField;
            }
            set
            {
                this.commentField = value;
            }
        }

        /// <remarks/>
        public bool IsNotMobileVisible
        {
            get
            {
                return this.isNotMobileVisibleField;
            }
            set
            {
                this.isNotMobileVisibleField = value;
            }
        }

        /// <remarks/>
        public bool isMobileIMEnabled
        {
            get
            {
                return this.isMobileIMEnabledField;
            }
            set
            {
                this.isMobileIMEnabledField = value;
            }
        }

        /// <remarks/>
        public bool isMessengerUser
        {
            get
            {
                return this.isMessengerUserField;
            }
            set
            {
                this.isMessengerUserField = value;
            }
        }

        /// <remarks/>
        public bool isFavorite
        {
            get
            {
                return this.isFavoriteField;
            }
            set
            {
                this.isFavoriteField = value;
            }
        }

        /// <remarks/>
        public bool isSmtp
        {
            get
            {
                return this.isSmtpField;
            }
            set
            {
                this.isSmtpField = value;
            }
        }

        /// <remarks/>
        public bool hasSpace
        {
            get
            {
                return this.hasSpaceField;
            }
            set
            {
                this.hasSpaceField = value;
            }
        }

        /// <remarks/>
        public SpotType spotWatchState
        {
            get
            {
                return this.spotWatchStateField;
            }
            set
            {
                this.spotWatchStateField = value;
            }
        }

        /// <remarks/>
        public System.DateTime birthdate
        {
            get
            {
                return this.birthdateField;
            }
            set
            {
                this.birthdateField = value;
            }
        }

        /// <remarks/>
        public ContactEmailType primaryEmailType
        {
            get
            {
                return this.primaryEmailTypeField;
            }
            set
            {
                this.primaryEmailTypeField = value;
            }
        }

        /// <remarks/>
        public ContactLocationType PrimaryLocation
        {
            get
            {
                return this.primaryLocationField;
            }
            set
            {
                this.primaryLocationField = value;
            }
        }

        /// <remarks/>
        public ContactPhoneType PrimaryPhone
        {
            get
            {
                return this.primaryPhoneField;
            }
            set
            {
                this.primaryPhoneField = value;
            }
        }

        /// <remarks/>
        public Category[] Categories
        {
            get
            {
                return this.categoriesField;
            }
            set
            {
                this.categoriesField = value;
            }
        }

        /// <remarks/>
        public string FileAs
        {
            get
            {
                return this.fileAsField;
            }
            set
            {
                this.fileAsField = value;
            }
        }

        /// <remarks/>
        public bool IsPrivate
        {
            get
            {
                return this.isPrivateField;
            }
            set
            {
                this.isPrivateField = value;
            }
        }

        /// <remarks/>
        public bool IsHidden
        {
            get
            {
                return this.isHiddenField;
            }
            set
            {
                this.isHiddenField = value;
            }
        }

        /// <remarks/>
        public string Anniversary
        {
            get
            {
                return this.anniversaryField;
            }
            set
            {
                this.anniversaryField = value;
            }
        }

        /// <remarks/>
        public GenderType Gender
        {
            get
            {
                return this.genderField;
            }
            set
            {
                this.genderField = value;
            }
        }

        /// <remarks/>
        public TimeZoneRange TimeZone
        {
            get
            {
                return this.timeZoneField;
            }
            set
            {
                this.timeZoneField = value;
            }
        }

        /// <remarks/>
        public MessengerMemberInfo MessengerMemberInfo
        {
            get
            {
                return this.messengerMemberInfoField;
            }
            set
            {
                this.messengerMemberInfoField = value;
            }
        }

        /// <remarks/>
        public string YomiFirstName
        {
            get
            {
                return this.yomiFirstNameField;
            }
            set
            {
                this.yomiFirstNameField = value;
            }
        }

        /// <remarks/>
        public string YomiLastName
        {
            get
            {
                return this.yomiLastNameField;
            }
            set
            {
                this.yomiLastNameField = value;
            }
        }

        /// <remarks/>
        public ContactURL[] URLs
        {
            get
            {
                return this.uRLsField;
            }
            set
            {
                this.uRLsField = value;
            }
        }

        /// <remarks/>
        public ContactRelationship[] Relationships
        {
            get
            {
                return this.relationshipsField;
            }
            set
            {
                this.relationshipsField = value;
            }
        }

        /// <remarks/>
        public NetworkInfo[] NetworkInfoList
        {
            get
            {
                return this.networkInfoListField;
            }
            set
            {
                this.networkInfoListField = value;
            }
        }

        /// <remarks/>
        public string PublicDisplayName
        {
            get
            {
                return this.publicDisplayNameField;
            }
            set
            {
                this.publicDisplayNameField = value;
            }
        }

        /// <remarks/>
        public bool IsAutoUpdateDisabled
        {
            get
            {
                return this.isAutoUpdateDisabledField;
            }
            set
            {
                this.isAutoUpdateDisabledField = value;
            }
        }

        /// <remarks/>
        public ContactProperties PropertiesChanged
        {
            get
            {
                return this.propertiesChangedField;
            }
            set
            {
                this.propertiesChangedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactEmail
    {

        private ContactEmailType contactEmailTypeField;

        private string emailField;

        private bool isMessengerEnabledField;

        private long capabilityField;

        private bool messengerEnabledExternallyField;

        private ContactEmailPropertyType propertiesChangedField;

        /// <remarks/>
        public ContactEmailType contactEmailType
        {
            get
            {
                return this.contactEmailTypeField;
            }
            set
            {
                this.contactEmailTypeField = value;
            }
        }

        /// <remarks/>
        public string email
        {
            get
            {
                return this.emailField;
            }
            set
            {
                this.emailField = value;
            }
        }

        /// <remarks/>
        public bool isMessengerEnabled
        {
            get
            {
                return this.isMessengerEnabledField;
            }
            set
            {
                this.isMessengerEnabledField = value;
            }
        }

        /// <remarks/>
        public long Capability
        {
            get
            {
                return this.capabilityField;
            }
            set
            {
                this.capabilityField = value;
            }
        }

        /// <remarks/>
        public bool MessengerEnabledExternally
        {
            get
            {
                return this.messengerEnabledExternallyField;
            }
            set
            {
                this.messengerEnabledExternallyField = value;
            }
        }

        /// <remarks/>
        public ContactEmailPropertyType propertiesChanged
        {
            get
            {
                return this.propertiesChangedField;
            }
            set
            {
                this.propertiesChangedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactEmailType
    {

        /// <remarks/>
        ContactEmailPersonal,

        /// <remarks/>
        ContactEmailBusiness,

        /// <remarks/>
        ContactEmailOther,

        /// <remarks/>
        ContactEmailMessenger,

        /// <remarks/>
        Messenger2,

        /// <remarks/>
        Messenger3,

        /// <remarks/>
        Messenger4,

        /// <remarks/>
        Passport,

        /// <remarks/>
        Messenger5,

        /// <remarks/>
        Messenger6,

        /// <remarks/>
        Messenger7,

        /// <remarks/>
        Messenger8,

        /// <remarks/>
        Messenger9,

        /// <remarks/>
        Messenger10,

        /// <remarks/>
        Messenger11,

        /// <remarks/>
        Messenger12,

        /// <remarks/>
        Messenger13,

        /// <remarks/>
        Messenger14,

        /// <remarks/>
        Messenger15,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactEmailPropertyType
    {

        /// <remarks/>
        Email = 1,

        /// <remarks/>
        IsMessengerEnabled = 2,

        /// <remarks/>
        Capability = 4,

        /// <remarks/>
        MessengerEnabledExternally = 8,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactPhone
    {

        private ContactPhoneType contactPhoneTypeField;

        private string numberField;

        private bool isMessengerEnabledField;

        private string speedDialField;

        private ContactPhonePropertyType propertiesChangedField;

        /// <remarks/>
        public ContactPhoneType contactPhoneType
        {
            get
            {
                return this.contactPhoneTypeField;
            }
            set
            {
                this.contactPhoneTypeField = value;
            }
        }

        /// <remarks/>
        public string number
        {
            get
            {
                return this.numberField;
            }
            set
            {
                this.numberField = value;
            }
        }

        /// <remarks/>
        public bool isMessengerEnabled
        {
            get
            {
                return this.isMessengerEnabledField;
            }
            set
            {
                this.isMessengerEnabledField = value;
            }
        }

        /// <remarks/>
        public string SpeedDial
        {
            get
            {
                return this.speedDialField;
            }
            set
            {
                this.speedDialField = value;
            }
        }

        /// <remarks/>
        public ContactPhonePropertyType propertiesChanged
        {
            get
            {
                return this.propertiesChangedField;
            }
            set
            {
                this.propertiesChangedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactPhoneType
    {

        /// <remarks/>
        ContactPhonePersonal,

        /// <remarks/>
        ContactPhoneBusiness,

        /// <remarks/>
        ContactPhoneMobile,

        /// <remarks/>
        ContactPhonePager,

        /// <remarks/>
        ContactPhoneFax,

        /// <remarks/>
        ContactPhoneOther,

        /// <remarks/>
        Personal2,

        /// <remarks/>
        Business2,

        /// <remarks/>
        BusinessFax,

        /// <remarks/>
        Company,

        /// <remarks/>
        Assistant,

        /// <remarks/>
        Callback,

        /// <remarks/>
        Car,

        /// <remarks/>
        ISDN,

        /// <remarks/>
        OtherFax,

        /// <remarks/>
        Primary,

        /// <remarks/>
        Radio,

        /// <remarks/>
        Telex,

        /// <remarks/>
        TTY,

        /// <remarks/>
        MSN,

        /// <remarks/>
        IP,

        /// <remarks/>
        BusinessMobile,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactPhonePropertyType
    {

        /// <remarks/>
        Number = 1,

        /// <remarks/>
        IsMessengerEnabled = 2,

        /// <remarks/>
        SpeedDial = 4,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactLocation
    {

        private ContactLocationType contactLocationTypeField;

        private string nameField;

        private string streetField;

        private string cityField;

        private string stateField;

        private string countryField;

        private string postalCodeField;

        private string officeField;

        private string departmentField;

        private double latitudeField;

        private bool latitudeFieldSpecified;

        private double longitudeField;

        private bool longitudeFieldSpecified;

        private ContactLocationProperty changesField;

        private string yomiCompanyNameField;

        private string streetSecondaryField;

        private string citySecondaryField;

        /// <remarks/>
        public ContactLocationType contactLocationType
        {
            get
            {
                return this.contactLocationTypeField;
            }
            set
            {
                this.contactLocationTypeField = value;
            }
        }

        /// <remarks/>
        public string name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public string street
        {
            get
            {
                return this.streetField;
            }
            set
            {
                this.streetField = value;
            }
        }

        /// <remarks/>
        public string city
        {
            get
            {
                return this.cityField;
            }
            set
            {
                this.cityField = value;
            }
        }

        /// <remarks/>
        public string state
        {
            get
            {
                return this.stateField;
            }
            set
            {
                this.stateField = value;
            }
        }

        /// <remarks/>
        public string country
        {
            get
            {
                return this.countryField;
            }
            set
            {
                this.countryField = value;
            }
        }

        /// <remarks/>
        public string postalCode
        {
            get
            {
                return this.postalCodeField;
            }
            set
            {
                this.postalCodeField = value;
            }
        }

        /// <remarks/>
        public string Office
        {
            get
            {
                return this.officeField;
            }
            set
            {
                this.officeField = value;
            }
        }

        /// <remarks/>
        public string Department
        {
            get
            {
                return this.departmentField;
            }
            set
            {
                this.departmentField = value;
            }
        }

        /// <remarks/>
        public double Latitude
        {
            get
            {
                return this.latitudeField;
            }
            set
            {
                this.latitudeField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool LatitudeSpecified
        {
            get
            {
                return this.latitudeFieldSpecified;
            }
            set
            {
                this.latitudeFieldSpecified = value;
            }
        }

        /// <remarks/>
        public double Longitude
        {
            get
            {
                return this.longitudeField;
            }
            set
            {
                this.longitudeField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool LongitudeSpecified
        {
            get
            {
                return this.longitudeFieldSpecified;
            }
            set
            {
                this.longitudeFieldSpecified = value;
            }
        }

        /// <remarks/>
        public ContactLocationProperty Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }

        /// <remarks/>
        public string YomiCompanyName
        {
            get
            {
                return this.yomiCompanyNameField;
            }
            set
            {
                this.yomiCompanyNameField = value;
            }
        }

        /// <remarks/>
        public string StreetSecondary
        {
            get
            {
                return this.streetSecondaryField;
            }
            set
            {
                this.streetSecondaryField = value;
            }
        }

        /// <remarks/>
        public string CitySecondary
        {
            get
            {
                return this.citySecondaryField;
            }
            set
            {
                this.citySecondaryField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactLocationType
    {

        /// <remarks/>
        ContactLocationPersonal,

        /// <remarks/>
        ContactLocationBusiness,

        /// <remarks/>
        Other,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactLocationProperty
    {

        /// <remarks/>
        Name = 1,

        /// <remarks/>
        Street = 2,

        /// <remarks/>
        City = 4,

        /// <remarks/>
        State = 8,

        /// <remarks/>
        Country = 16,

        /// <remarks/>
        PostalCode = 32,

        /// <remarks/>
        Office = 64,

        /// <remarks/>
        Department = 128,

        /// <remarks/>
        Latitude = 256,

        /// <remarks/>
        Longitude = 512,

        /// <remarks/>
        YomiCompanyName = 1024,

        /// <remarks/>
        StreetSecondary = 2048,

        /// <remarks/>
        CitySecondary = 4096,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactWebSite
    {

        private ContactWebSiteType contactWebSiteTypeField;

        private string webURLField;

        /// <remarks/>
        public ContactWebSiteType contactWebSiteType
        {
            get
            {
                return this.contactWebSiteTypeField;
            }
            set
            {
                this.contactWebSiteTypeField = value;
            }
        }

        /// <remarks/>
        public string webURL
        {
            get
            {
                return this.webURLField;
            }
            set
            {
                this.webURLField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactWebSiteType
    {

        /// <remarks/>
        ContactWebSitePersonal,

        /// <remarks/>
        ContactWebSiteBusiness,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactType
    {

        /// <remarks/>
        Regular,

        /// <remarks/>
        Me,

        /// <remarks/>
        Live,

        /// <remarks/>
        LiveDropped,

        /// <remarks/>
        LivePending,

        /// <remarks/>
        LiveRejected,

        /// <remarks/>
        Circle,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum SpotType
    {

        /// <remarks/>
        NoDevice,

        /// <remarks/>
        NoMessaging,

        /// <remarks/>
        MessagingEnabled,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum GenderType
    {

        /// <remarks/>
        Unspecified,

        /// <remarks/>
        Female,

        /// <remarks/>
        Male,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum TimeZoneRange
    {

        /// <remarks/>
        None,

        /// <remarks/>
        GmtMinus12h,

        /// <remarks/>
        GmtMinus11h,

        /// <remarks/>
        GmtMinus10h,

        /// <remarks/>
        GmtMinus9h,

        /// <remarks/>
        GmtMinus8h,

        /// <remarks/>
        GmtMinus7h,

        /// <remarks/>
        GmtMinus6h,

        /// <remarks/>
        GmtMinus5h,

        /// <remarks/>
        GmtMinus4h,

        /// <remarks/>
        GmtMinus3h30,

        /// <remarks/>
        GmtMinus3h,

        /// <remarks/>
        GmtMinus2h,

        /// <remarks/>
        GmtMinus1h,

        /// <remarks/>
        Gmt,

        /// <remarks/>
        GmtPlus1h,

        /// <remarks/>
        GmtPlus2h,

        /// <remarks/>
        GmtPlus3h,

        /// <remarks/>
        GmtPlus3h30,

        /// <remarks/>
        GmtPlus4h,

        /// <remarks/>
        GmtPlus4h30,

        /// <remarks/>
        GmtPlus5h,

        /// <remarks/>
        GmtPlus5h30,

        /// <remarks/>
        GmtPlus5h45,

        /// <remarks/>
        GmtPlus6h,

        /// <remarks/>
        GmtPlus6h30,

        /// <remarks/>
        GmtPlus7h,

        /// <remarks/>
        GmtPlus8h,

        /// <remarks/>
        GmtPlus9h,

        /// <remarks/>
        GmtPlus9h30,

        /// <remarks/>
        GmtPlus10h,

        /// <remarks/>
        GmtPlus11h,

        /// <remarks/>
        GmtPlus12h,

        /// <remarks/>
        GmtPlus13h,

        /// <remarks/>
        GmtPlus11h30,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class MessengerMemberInfo
    {

        private Annotation[] pendingAnnotationsField;

        private Annotation[] allowAnnotationsField;

        private string displayNameField;

        /// <remarks/>
        public Annotation[] PendingAnnotations
        {
            get
            {
                return this.pendingAnnotationsField;
            }
            set
            {
                this.pendingAnnotationsField = value;
            }
        }

        /// <remarks/>
        public Annotation[] AllowAnnotations
        {
            get
            {
                return this.allowAnnotationsField;
            }
            set
            {
                this.allowAnnotationsField = value;
            }
        }

        /// <remarks/>
        public string DisplayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactURL
    {

        private ContactURLProperty changesField;

        private short uRLIdField;

        private ContactURLType uRLTypeField;

        private string uRLNameField;

        private string uRLField;

        private System.DateTime lastChangeField;

        /// <remarks/>
        public ContactURLProperty Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }

        /// <remarks/>
        public short URLId
        {
            get
            {
                return this.uRLIdField;
            }
            set
            {
                this.uRLIdField = value;
            }
        }

        /// <remarks/>
        public ContactURLType URLType
        {
            get
            {
                return this.uRLTypeField;
            }
            set
            {
                this.uRLTypeField = value;
            }
        }

        /// <remarks/>
        public string URLName
        {
            get
            {
                return this.uRLNameField;
            }
            set
            {
                this.uRLNameField = value;
            }
        }

        /// <remarks/>
        public string URL
        {
            get
            {
                return this.uRLField;
            }
            set
            {
                this.uRLField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChange
        {
            get
            {
                return this.lastChangeField;
            }
            set
            {
                this.lastChangeField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactURLProperty
    {

        /// <remarks/>
        URLId = 1,

        /// <remarks/>
        URLType = 2,

        /// <remarks/>
        URLName = 4,

        /// <remarks/>
        URL = 8,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactURLType
    {

        /// <remarks/>
        Personal,

        /// <remarks/>
        Business,

        /// <remarks/>
        Image,

        /// <remarks/>
        Attachment,

        /// <remarks/>
        EBCDisplayDefinition,

        /// <remarks/>
        EBCLogo,

        /// <remarks/>
        EBCFinalImage,

        /// <remarks/>
        Feed,

        /// <remarks/>
        Other,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactRelationship
    {

        private ContactRelationshipProperty changesField;

        private byte relationshipTypeField;

        private System.Guid relationContactIdField;

        /// <remarks/>
        public ContactRelationshipProperty Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }

        /// <remarks/>
        public byte RelationshipType
        {
            get
            {
                return this.relationshipTypeField;
            }
            set
            {
                this.relationshipTypeField = value;
            }
        }

        /// <remarks/>
        public System.Guid RelationContactId
        {
            get
            {
                return this.relationContactIdField;
            }
            set
            {
                this.relationContactIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactRelationshipProperty
    {

        /// <remarks/>
        RelationshipType = 1,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class NetworkInfo
    {

        private int domainIdField;

        private string domainTagField;

        private string userTileURLField;

        private string profileURLField;

        private string displayNameField;

        private int relationshipTypeField;

        private int relationshipStateField;

        private System.DateTime relationshipStateDateField;

        private long relationshipRoleField;

        private string extendedDataField;

        private int nDRCountField;

        private string inviterMessageField;

        private long inviterCIDField;

        private string inviterNameField;

        private string inviterEmailField;

        private System.DateTime createDateField;

        private System.DateTime lastChangedField;

        private NetworkInfoProperties propertiesChangedField;

        /// <remarks/>
        public int DomainId
        {
            get
            {
                return this.domainIdField;
            }
            set
            {
                this.domainIdField = value;
            }
        }

        /// <remarks/>
        public string DomainTag
        {
            get
            {
                return this.domainTagField;
            }
            set
            {
                this.domainTagField = value;
            }
        }

        /// <remarks/>
        public string UserTileURL
        {
            get
            {
                return this.userTileURLField;
            }
            set
            {
                this.userTileURLField = value;
            }
        }

        /// <remarks/>
        public string ProfileURL
        {
            get
            {
                return this.profileURLField;
            }
            set
            {
                this.profileURLField = value;
            }
        }

        /// <remarks/>
        public string DisplayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }

        /// <remarks/>
        public int RelationshipType
        {
            get
            {
                return this.relationshipTypeField;
            }
            set
            {
                this.relationshipTypeField = value;
            }
        }

        /// <remarks/>
        public int RelationshipState
        {
            get
            {
                return this.relationshipStateField;
            }
            set
            {
                this.relationshipStateField = value;
            }
        }

        /// <remarks/>
        public System.DateTime RelationshipStateDate
        {
            get
            {
                return this.relationshipStateDateField;
            }
            set
            {
                this.relationshipStateDateField = value;
            }
        }

        /// <remarks/>
        public long RelationshipRole
        {
            get
            {
                return this.relationshipRoleField;
            }
            set
            {
                this.relationshipRoleField = value;
            }
        }

        /// <remarks/>
        public string ExtendedData
        {
            get
            {
                return this.extendedDataField;
            }
            set
            {
                this.extendedDataField = value;
            }
        }

        /// <remarks/>
        public int NDRCount
        {
            get
            {
                return this.nDRCountField;
            }
            set
            {
                this.nDRCountField = value;
            }
        }

        /// <remarks/>
        public string InviterMessage
        {
            get
            {
                return this.inviterMessageField;
            }
            set
            {
                this.inviterMessageField = value;
            }
        }

        /// <remarks/>
        public long InviterCID
        {
            get
            {
                return this.inviterCIDField;
            }
            set
            {
                this.inviterCIDField = value;
            }
        }

        /// <remarks/>
        public string InviterName
        {
            get
            {
                return this.inviterNameField;
            }
            set
            {
                this.inviterNameField = value;
            }
        }

        /// <remarks/>
        public string InviterEmail
        {
            get
            {
                return this.inviterEmailField;
            }
            set
            {
                this.inviterEmailField = value;
            }
        }

        /// <remarks/>
        public System.DateTime CreateDate
        {
            get
            {
                return this.createDateField;
            }
            set
            {
                this.createDateField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChanged
        {
            get
            {
                return this.lastChangedField;
            }
            set
            {
                this.lastChangedField = value;
            }
        }

        /// <remarks/>
        public NetworkInfoProperties PropertiesChanged
        {
            get
            {
                return this.propertiesChangedField;
            }
            set
            {
                this.propertiesChangedField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum NetworkInfoProperties
    {

        /// <remarks/>
        DomainTag = 1,

        /// <remarks/>
        UserTileURL = 2,

        /// <remarks/>
        ProfileURL = 4,

        /// <remarks/>
        DisplayName = 8,

        /// <remarks/>
        InviterMessage = 16,

        /// <remarks/>
        InviterCID = 32,

        /// <remarks/>
        InviterName = 64,

        /// <remarks/>
        InviterEmail = 128,

        /// <remarks/>
        RelationshipState = 256,

        /// <remarks/>
        RelationshipRole = 512,

        /// <remarks/>
        ExtendedData = 1024,

        /// <remarks/>
        NDRCount = 2048,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactProperties
    {

        /// <remarks/>
        NameTitle = 1,

        /// <remarks/>
        FirstName = 2,

        /// <remarks/>
        MiddleName = 4,

        /// <remarks/>
        LastName = 8,

        /// <remarks/>
        Suffix = 16,

        /// <remarks/>
        FileAs = 32,

        /// <remarks/>
        YomiFirstName = 64,

        /// <remarks/>
        YomiLastName = 128,

        /// <remarks/>
        BirthDate = 256,

        /// <remarks/>
        Anniversary = 512,

        /// <remarks/>
        Gender = 1024,

        /// <remarks/>
        TimeZone = 2048,

        /// <remarks/>
        Emails = 4096,

        /// <remarks/>
        Phones = 8192,

        /// <remarks/>
        Locations = 16384,

        /// <remarks/>
        URLs = 32768,

        /// <remarks/>
        Relationships = 65536,

        /// <remarks/>
        Categories = 131072,

        /// <remarks/>
        Annotations = 262144,

        /// <remarks/>
        Comment = 524288,

        /// <remarks/>
        PrimaryEmailType = 1048576,

        /// <remarks/>
        PrimaryPhone = 2097152,

        /// <remarks/>
        PrimaryLocation = 4194304,

        /// <remarks/>
        Passport = 8388608,

        /// <remarks/>
        DisplayName = 16777216,

        /// <remarks/>
        PublicDisplayName = 33554432,

        /// <remarks/>
        IsNotMobileVisible = 67108864,

        /// <remarks/>
        IsMobileIMEnabled = 134217728,

        /// <remarks/>
        IsAutoUpdateDisabled = 268435456,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactPropertyType : long
    {

        /// <remarks/>
        ContactPrimaryEmailType = 1,

        /// <remarks/>
        ContactFirstName = 2,

        /// <remarks/>
        ContactLastName = 4,

        /// <remarks/>
        ContactQuickName = 8,

        /// <remarks/>
        ContactBirthDate = 16,

        /// <remarks/>
        ContactEmail = 32,

        /// <remarks/>
        ContactPhone = 64,

        /// <remarks/>
        ContactLocation = 128,

        /// <remarks/>
        ContactWebSite = 256,

        /// <remarks/>
        Annotation = 512,

        /// <remarks/>
        Passport = 1024,

        /// <remarks/>
        Comment = 2048,

        /// <remarks/>
        IsNotMobileVisible = 4096,

        /// <remarks/>
        IsMobileIMEnabled = 8192,

        /// <remarks/>
        IsMessengerUser = 16384,

        /// <remarks/>
        IsFavorite = 32768,

        /// <remarks/>
        IsSmtp = 65536,

        /// <remarks/>
        SpotWatchState = 131072,

        /// <remarks/>
        DisplayName = 262144,

        /// <remarks/>
        HasSpace = 524288,

        /// <remarks/>
        Categories = 1048576,

        /// <remarks/>
        FileAs = 2097152,

        /// <remarks/>
        IsPrivate = 4194304,

        /// <remarks/>
        Anniversary = 8388608,

        /// <remarks/>
        MiddleName = 16777216,

        /// <remarks/>
        NameTitle = 33554432,

        /// <remarks/>
        Suffix = 67108864,

        /// <remarks/>
        PrimaryLocation = 134217728,

        /// <remarks/>
        PrimaryPhone = 268435456,

        /// <remarks/>
        Gender = 536870912,

        /// <remarks/>
        TimeZone = 1073741824,

        /// <remarks/>
        ContactType = 2147483648,

        /// <remarks/>
        IsPassportNameHidden = 4294967296,

        /// <remarks/>
        MessengerMemberInfo = 8589934592,

        /// <remarks/>
        YomiFirstName = 17179869184,

        /// <remarks/>
        YomiLastName = 34359738368,

        /// <remarks/>
        URLs = 68719476736,

        /// <remarks/>
        Relationships = 137438953472,

        /// <remarks/>
        NetworkInfoList = 274877906944,

        /// <remarks/>
        PublicDisplayName = 549755813888,

        /// <remarks/>
        IsHidden = 1099511627776,

        /// <remarks/>
        IsAutoUpdateDisabled = 2199023255552,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class AB
    {

        private System.Guid abIdField;

        private ABInfo abInfoField;

        private System.DateTime lastChangeField;

        private System.DateTime dynamicItemLastChangedField;

        private System.DateTime recentActivityItemLastChangedField;

        private System.DateTime createDateField;

        private ABPropertyType propertiesChangedField;

        /// <remarks/>
        public System.Guid abId
        {
            get
            {
                return this.abIdField;
            }
            set
            {
                this.abIdField = value;
            }
        }

        /// <remarks/>
        public ABInfo abInfo
        {
            get
            {
                return this.abInfoField;
            }
            set
            {
                this.abInfoField = value;
            }
        }

        /// <remarks/>
        public System.DateTime lastChange
        {
            get
            {
                return this.lastChangeField;
            }
            set
            {
                this.lastChangeField = value;
            }
        }

        /// <remarks/>
        public System.DateTime DynamicItemLastChanged
        {
            get
            {
                return this.dynamicItemLastChangedField;
            }
            set
            {
                this.dynamicItemLastChangedField = value;
            }
        }

        /// <remarks/>
        public System.DateTime RecentActivityItemLastChanged
        {
            get
            {
                return this.recentActivityItemLastChangedField;
            }
            set
            {
                this.recentActivityItemLastChangedField = value;
            }
        }

        /// <remarks/>
        public System.DateTime createDate
        {
            get
            {
                return this.createDateField;
            }
            set
            {
                this.createDateField = value;
            }
        }

        /// <remarks/>
        public ABPropertyType propertiesChanged
        {
            get
            {
                return this.propertiesChangedField;
            }
            set
            {
                this.propertiesChangedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ABInfo
    {

        private string nameField;

        private long ownerPuidField;

        private long ownerCIDField;

        private string ownerEmailField;

        private bool fDefaultField;

        private bool joinedNamespaceField;

        private bool isBotField;

        private bool isParentManagedField;

        private bool subscribeExternalPartnerField;

        private bool notifyExternalPartnerField;

        private ABType addressBookTypeField;

        private bool messengerApplicationServiceCreatedField;

        private bool isBetaMigratedField;

        /// <remarks/>
        public string name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public long ownerPuid
        {
            get
            {
                return this.ownerPuidField;
            }
            set
            {
                this.ownerPuidField = value;
            }
        }

        /// <remarks/>
        public long OwnerCID
        {
            get
            {
                return this.ownerCIDField;
            }
            set
            {
                this.ownerCIDField = value;
            }
        }

        /// <remarks/>
        public string ownerEmail
        {
            get
            {
                return this.ownerEmailField;
            }
            set
            {
                this.ownerEmailField = value;
            }
        }

        /// <remarks/>
        public bool fDefault
        {
            get
            {
                return this.fDefaultField;
            }
            set
            {
                this.fDefaultField = value;
            }
        }

        /// <remarks/>
        public bool joinedNamespace
        {
            get
            {
                return this.joinedNamespaceField;
            }
            set
            {
                this.joinedNamespaceField = value;
            }
        }

        /// <remarks/>
        public bool IsBot
        {
            get
            {
                return this.isBotField;
            }
            set
            {
                this.isBotField = value;
            }
        }

        /// <remarks/>
        public bool IsParentManaged
        {
            get
            {
                return this.isParentManagedField;
            }
            set
            {
                this.isParentManagedField = value;
            }
        }

        /// <remarks/>
        public bool SubscribeExternalPartner
        {
            get
            {
                return this.subscribeExternalPartnerField;
            }
            set
            {
                this.subscribeExternalPartnerField = value;
            }
        }

        /// <remarks/>
        public bool NotifyExternalPartner
        {
            get
            {
                return this.notifyExternalPartnerField;
            }
            set
            {
                this.notifyExternalPartnerField = value;
            }
        }

        /// <remarks/>
        public ABType AddressBookType
        {
            get
            {
                return this.addressBookTypeField;
            }
            set
            {
                this.addressBookTypeField = value;
            }
        }

        /// <remarks/>
        public bool MessengerApplicationServiceCreated
        {
            get
            {
                return this.messengerApplicationServiceCreatedField;
            }
            set
            {
                this.messengerApplicationServiceCreatedField = value;
            }
        }

        /// <remarks/>
        public bool IsBetaMigrated
        {
            get
            {
                return this.isBetaMigratedField;
            }
            set
            {
                this.isBetaMigratedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ABType
    {

        /// <remarks/>
        None,

        /// <remarks/>
        Individual,

        /// <remarks/>
        Group,

        /// <remarks/>
        Bot,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ABPropertyType
    {

        /// <remarks/>
        Name = 1,

        /// <remarks/>
        IsBot = 2,

        /// <remarks/>
        IsParentManaged = 4,

        /// <remarks/>
        Subscribe = 8,

        /// <remarks/>
        Unsubscribe = 16,

        /// <remarks/>
        IsBetaMigrated = 32,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class NetworkFilterOptions
    {

        private NetworkInfo[] networkFilterField;

        /// <remarks/>
        public NetworkInfo[] NetworkFilter
        {
            get
            {
                return this.networkFilterField;
            }
            set
            {
                this.networkFilterField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactFilterOption
    {

        private int fieldField;

        private string valueField;

        /// <remarks/>
        public int Field
        {
            get
            {
                return this.fieldField;
            }
            set
            {
                this.fieldField = value;
            }
        }

        /// <remarks/>
        public string Value
        {
            get
            {
                return this.valueField;
            }
            set
            {
                this.valueField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactFilterOptions
    {

        private ContactFilterOption[] filtersField;

        private bool includeHiddenContactsField;

        /// <remarks/>
        public ContactFilterOption[] Filters
        {
            get
            {
                return this.filtersField;
            }
            set
            {
                this.filtersField = value;
            }
        }

        /// <remarks/>
        public bool IncludeHiddenContacts
        {
            get
            {
                return this.includeHiddenContactsField;
            }
            set
            {
                this.includeHiddenContactsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class FindFilterOptions
    {

        private bool deltasOnlyField;

        private System.DateTime lastChangedField;

        private ContactFilterOptions contactFilterField;

        private NetworkFilterOptions networkFilterField;

        /// <remarks/>
        public bool DeltasOnly
        {
            get
            {
                return this.deltasOnlyField;
            }
            set
            {
                this.deltasOnlyField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChanged
        {
            get
            {
                return this.lastChangedField;
            }
            set
            {
                this.lastChangedField = value;
            }
        }

        /// <remarks/>
        public ContactFilterOptions ContactFilter
        {
            get
            {
                return this.contactFilterField;
            }
            set
            {
                this.contactFilterField = value;
            }
        }

        /// <remarks/>
        public NetworkFilterOptions NetworkFilter
        {
            get
            {
                return this.networkFilterField;
            }
            set
            {
                this.networkFilterField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactSortOption
    {

        private int fieldField;

        /// <remarks/>
        public int Field
        {
            get
            {
                return this.fieldField;
            }
            set
            {
                this.fieldField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class FindSortOptions
    {

        private ContactSortOption[] optionsField;

        /// <remarks/>
        public ContactSortOption[] Options
        {
            get
            {
                return this.optionsField;
            }
            set
            {
                this.optionsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class FindPageContext
    {

        private Contact startContactField;

        private int pageSizeField;

        private FindPageDirection directionField;

        /// <remarks/>
        public Contact StartContact
        {
            get
            {
                return this.startContactField;
            }
            set
            {
                this.startContactField = value;
            }
        }

        /// <remarks/>
        public int PageSize
        {
            get
            {
                return this.pageSizeField;
            }
            set
            {
                this.pageSizeField = value;
            }
        }

        /// <remarks/>
        public FindPageDirection Direction
        {
            get
            {
                return this.directionField;
            }
            set
            {
                this.directionField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum FindPageDirection
    {

        /// <remarks/>
        None,

        /// <remarks/>
        Forward,

        /// <remarks/>
        Backward,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class WhatsNewSubscriptionsResult
    {

        private long ownerPuidField;

        private long ownerCidField;

        private System.DateTime addressBookTimestampField;

        private long[] publishersField;

        private long[] blockedPublishersField;

        private long[] blockedApplicationsField;

        private long subscriptionsHashField;

        /// <remarks/>
        public long OwnerPuid
        {
            get
            {
                return this.ownerPuidField;
            }
            set
            {
                this.ownerPuidField = value;
            }
        }

        /// <remarks/>
        public long OwnerCid
        {
            get
            {
                return this.ownerCidField;
            }
            set
            {
                this.ownerCidField = value;
            }
        }

        /// <remarks/>
        public System.DateTime AddressBookTimestamp
        {
            get
            {
                return this.addressBookTimestampField;
            }
            set
            {
                this.addressBookTimestampField = value;
            }
        }

        /// <remarks/>
        public long[] Publishers
        {
            get
            {
                return this.publishersField;
            }
            set
            {
                this.publishersField = value;
            }
        }

        /// <remarks/>
        public long[] BlockedPublishers
        {
            get
            {
                return this.blockedPublishersField;
            }
            set
            {
                this.blockedPublishersField = value;
            }
        }

        /// <remarks/>
        public long[] BlockedApplications
        {
            get
            {
                return this.blockedApplicationsField;
            }
            set
            {
                this.blockedApplicationsField = value;
            }
        }

        /// <remarks/>
        public long SubscriptionsHash
        {
            get
            {
                return this.subscriptionsHashField;
            }
            set
            {
                this.subscriptionsHashField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://partners.live.com/")]
    public partial class MailHeader
    {

        private string nameField;

        private string valueField;

        /// <remarks/>
        public string Name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public string Value
        {
            get
            {
                return this.valueField;
            }
            set
            {
                this.valueField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://partners.live.com/")]
    public partial class MailPart
    {

        private string textField;

        private string charSetField;

        /// <remarks/>
        public string Text
        {
            get
            {
                return this.textField;
            }
            set
            {
                this.textField = value;
            }
        }

        /// <remarks/>
        public string CharSet
        {
            get
            {
                return this.charSetField;
            }
            set
            {
                this.charSetField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://partners.live.com/")]
    public partial class MailUser
    {

        private string addressField;

        private MailPart displayNameField;

        /// <remarks/>
        public string Address
        {
            get
            {
                return this.addressField;
            }
            set
            {
                this.addressField = value;
            }
        }

        /// <remarks/>
        public MailPart DisplayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://partners.live.com/")]
    public partial class EmailContent
    {

        private MailUser fromField;

        private MailUser toField;

        private MailPart subjectField;

        private MailPart htmlBodyField;

        private MailPart textBodyField;

        private MailHeader[] headersField;

        private EmailStatus statusField;

        /// <remarks/>
        public MailUser From
        {
            get
            {
                return this.fromField;
            }
            set
            {
                this.fromField = value;
            }
        }

        /// <remarks/>
        public MailUser To
        {
            get
            {
                return this.toField;
            }
            set
            {
                this.toField = value;
            }
        }

        /// <remarks/>
        public MailPart Subject
        {
            get
            {
                return this.subjectField;
            }
            set
            {
                this.subjectField = value;
            }
        }

        /// <remarks/>
        public MailPart HtmlBody
        {
            get
            {
                return this.htmlBodyField;
            }
            set
            {
                this.htmlBodyField = value;
            }
        }

        /// <remarks/>
        public MailPart TextBody
        {
            get
            {
                return this.textBodyField;
            }
            set
            {
                this.textBodyField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public MailHeader[] Headers
        {
            get
            {
                return this.headersField;
            }
            set
            {
                this.headersField = value;
            }
        }

        /// <remarks/>
        public EmailStatus Status
        {
            get
            {
                return this.statusField;
            }
            set
            {
                this.statusField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://partners.live.com/")]
    public enum EmailStatus
    {

        /// <remarks/>
        InvalidRequest,

        /// <remarks/>
        ReadyToSend,

        /// <remarks/>
        AlreadySent,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class FindContactResult
    {

        private Contact contactField;

        /// <remarks/>
        public Contact Contact
        {
            get
            {
                return this.contactField;
            }
            set
            {
                this.contactField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactHandle
    {

        private string emailField;

        private long puidField;

        private long cidField;

        private System.Guid circleIdField;

        private string thirdPartyEmailField;

        /// <remarks/>
        public string Email
        {
            get
            {
                return this.emailField;
            }
            set
            {
                this.emailField = value;
            }
        }

        /// <remarks/>
        public long Puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }

        /// <remarks/>
        public long Cid
        {
            get
            {
                return this.cidField;
            }
            set
            {
                this.cidField = value;
            }
        }

        /// <remarks/>
        public System.Guid CircleId
        {
            get
            {
                return this.circleIdField;
            }
            set
            {
                this.circleIdField = value;
            }
        }

        /// <remarks/>
        public string ThirdPartyEmail
        {
            get
            {
                return this.thirdPartyEmailField;
            }
            set
            {
                this.thirdPartyEmailField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ABHandle
    {

        private System.Guid aBIdField;

        private long puidField;

        private long cidField;

        private string wlidField;

        /// <remarks/>
        public System.Guid ABId
        {
            get
            {
                return this.aBIdField;
            }
            set
            {
                this.aBIdField = value;
            }
        }

        /// <remarks/>
        public long Puid
        {
            get
            {
                return this.puidField;
            }
            set
            {
                this.puidField = value;
            }
        }

        /// <remarks/>
        public long Cid
        {
            get
            {
                return this.cidField;
            }
            set
            {
                this.cidField = value;
            }
        }

        /// <remarks/>
        public string Wlid
        {
            get
            {
                return this.wlidField;
            }
            set
            {
                this.wlidField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class MergeResponse
    {

        private bool succeededField;

        /// <remarks/>
        public bool Succeeded
        {
            get
            {
                return this.succeededField;
            }
            set
            {
                this.succeededField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class MergeData
    {

        private string sourceWLIDField;

        private long sourcePUIDField;

        /// <remarks/>
        public string SourceWLID
        {
            get
            {
                return this.sourceWLIDField;
            }
            set
            {
                this.sourceWLIDField = value;
            }
        }

        /// <remarks/>
        public long SourcePUID
        {
            get
            {
                return this.sourcePUIDField;
            }
            set
            {
                this.sourcePUIDField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class RecentActivityItem
    {

        private long changerCIDField;

        private long ownerCIDField;

        private System.DateTime lastChangedField;

        private short changeTypeField;

        private string objectIDField;

        private string titleField;

        private string dataField;

        private CircleAttributes circleAttributesField;

        private System.DateTime lastModifiedDateField;

        private bool deletedField;

        /// <remarks/>
        public long ChangerCID
        {
            get
            {
                return this.changerCIDField;
            }
            set
            {
                this.changerCIDField = value;
            }
        }

        /// <remarks/>
        public long OwnerCID
        {
            get
            {
                return this.ownerCIDField;
            }
            set
            {
                this.ownerCIDField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChanged
        {
            get
            {
                return this.lastChangedField;
            }
            set
            {
                this.lastChangedField = value;
            }
        }

        /// <remarks/>
        public short ChangeType
        {
            get
            {
                return this.changeTypeField;
            }
            set
            {
                this.changeTypeField = value;
            }
        }

        /// <remarks/>
        public string ObjectID
        {
            get
            {
                return this.objectIDField;
            }
            set
            {
                this.objectIDField = value;
            }
        }

        /// <remarks/>
        public string Title
        {
            get
            {
                return this.titleField;
            }
            set
            {
                this.titleField = value;
            }
        }

        /// <remarks/>
        public string Data
        {
            get
            {
                return this.dataField;
            }
            set
            {
                this.dataField = value;
            }
        }

        /// <remarks/>
        public CircleAttributes CircleAttributes
        {
            get
            {
                return this.circleAttributesField;
            }
            set
            {
                this.circleAttributesField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastModifiedDate
        {
            get
            {
                return this.lastModifiedDateField;
            }
            set
            {
                this.lastModifiedDateField = value;
            }
        }

        /// <remarks/>
        public bool Deleted
        {
            get
            {
                return this.deletedField;
            }
            set
            {
                this.deletedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleAttributes
    {

        private bool isPresenceEnabledField;

        private CircleDomain domainField;

        /// <remarks/>
        public bool IsPresenceEnabled
        {
            get
            {
                return this.isPresenceEnabledField;
            }
            set
            {
                this.isPresenceEnabledField = value;
            }
        }

        /// <remarks/>
        public CircleDomain Domain
        {
            get
            {
                return this.domainField;
            }
            set
            {
                this.domainField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum CircleDomain
    {

        /// <remarks/>
        None,

        /// <remarks/>
        WindowsLive,

        /// <remarks/>
        Xbox,

        /// <remarks/>
        Zune,

        /// <remarks/>
        OfficeLive,

        /// <remarks/>
        Edu,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleMembershipInfo
    {

        private RoleId roleField;

        private int stateField;

        /// <remarks/>
        public RoleId Role
        {
            get
            {
                return this.roleField;
            }
            set
            {
                this.roleField = value;
            }
        }

        /// <remarks/>
        public int State
        {
            get
            {
                return this.stateField;
            }
            set
            {
                this.stateField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleInfo
    {

        private CircleMembershipInfo[] membershipInfoField;

        private CircleAttributes circleAttributesField;

        private string nameField;

        private string displayNameField;

        private bool isNotMobileVisibleField;

        private string notesField;

        private string sharedFolderInfoField;

        /// <remarks/>
        public CircleMembershipInfo[] MembershipInfo
        {
            get
            {
                return this.membershipInfoField;
            }
            set
            {
                this.membershipInfoField = value;
            }
        }

        /// <remarks/>
        public CircleAttributes CircleAttributes
        {
            get
            {
                return this.circleAttributesField;
            }
            set
            {
                this.circleAttributesField = value;
            }
        }

        /// <remarks/>
        public string Name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public string DisplayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }

        /// <remarks/>
        public bool IsNotMobileVisible
        {
            get
            {
                return this.isNotMobileVisibleField;
            }
            set
            {
                this.isNotMobileVisibleField = value;
            }
        }

        /// <remarks/>
        public string Notes
        {
            get
            {
                return this.notesField;
            }
            set
            {
                this.notesField = value;
            }
        }

        /// <remarks/>
        public string SharedFolderInfo
        {
            get
            {
                return this.sharedFolderInfoField;
            }
            set
            {
                this.sharedFolderInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class Circle
    {

        private System.Guid idField;

        private CircleInfo infoField;

        private CirclePropertyTypes changesField;

        private System.DateTime lastChangedField;

        private bool deletedField;

        /// <remarks/>
        public System.Guid Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public CircleInfo Info
        {
            get
            {
                return this.infoField;
            }
            set
            {
                this.infoField = value;
            }
        }

        /// <remarks/>
        public CirclePropertyTypes Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChanged
        {
            get
            {
                return this.lastChangedField;
            }
            set
            {
                this.lastChangedField = value;
            }
        }

        /// <remarks/>
        public bool Deleted
        {
            get
            {
                return this.deletedField;
            }
            set
            {
                this.deletedField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum CirclePropertyTypes
    {

        /// <remarks/>
        DisplayName = 1,

        /// <remarks/>
        Notes = 2,

        /// <remarks/>
        IsNotMobileVisible = 4,

        /// <remarks/>
        SharedFolderInfo = 8,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleResult
    {

        private Circle[] circlesField;

        private string circleTicketField;

        /// <remarks/>
        public Circle[] Circles
        {
            get
            {
                return this.circlesField;
            }
            set
            {
                this.circlesField = value;
            }
        }

        /// <remarks/>
        public string CircleTicket
        {
            get
            {
                return this.circleTicketField;
            }
            set
            {
                this.circleTicketField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class NotificationDetails
    {

        private long cIDField;

        private short changeTypeField;

        private string objectIDField;

        private string titleField;

        private string dataField;

        /// <remarks/>
        public long CID
        {
            get
            {
                return this.cIDField;
            }
            set
            {
                this.cIDField = value;
            }
        }

        /// <remarks/>
        public short ChangeType
        {
            get
            {
                return this.changeTypeField;
            }
            set
            {
                this.changeTypeField = value;
            }
        }

        /// <remarks/>
        public string ObjectID
        {
            get
            {
                return this.objectIDField;
            }
            set
            {
                this.objectIDField = value;
            }
        }

        /// <remarks/>
        public string Title
        {
            get
            {
                return this.titleField;
            }
            set
            {
                this.titleField = value;
            }
        }

        /// <remarks/>
        public string Data
        {
            get
            {
                return this.dataField;
            }
            set
            {
                this.dataField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class AliasChangeInfo
    {

        private string newAliasField;

        private AliasChangeType changeTypeField;

        /// <remarks/>
        public string NewAlias
        {
            get
            {
                return this.newAliasField;
            }
            set
            {
                this.newAliasField = value;
            }
        }

        /// <remarks/>
        public AliasChangeType ChangeType
        {
            get
            {
                return this.changeTypeField;
            }
            set
            {
                this.changeTypeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum AliasChangeType
    {

        /// <remarks/>
        Add,

        /// <remarks/>
        Delete,

        /// <remarks/>
        Update,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class AliasInfo
    {

        private string aliasField;

        private AliasChangeInfo changeInfoField;

        /// <remarks/>
        public string Alias
        {
            get
            {
                return this.aliasField;
            }
            set
            {
                this.aliasField = value;
            }
        }

        /// <remarks/>
        public AliasChangeInfo ChangeInfo
        {
            get
            {
                return this.changeInfoField;
            }
            set
            {
                this.changeInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ServiceInfo
    {

        private Annotation[] annotationsField;

        private AliasInfo[] aliasesField;

        private ServiceHandle handleField;

        private string displayNameField;

        private bool inverseRequiredField;

        private string urlField;

        private string rSSUrlField;

        private string authorizationCriteriaField;

        private bool isBotField;

        private string publishersInverseNoteField;

        private bool notifySubscribersOnUpdatesField;

        public ServiceInfo()
        {
            this.notifySubscribersOnUpdatesField = true;
        }

        /// <remarks/>
        public Annotation[] Annotations
        {
            get
            {
                return this.annotationsField;
            }
            set
            {
                this.annotationsField = value;
            }
        }

        /// <remarks/>
        public AliasInfo[] Aliases
        {
            get
            {
                return this.aliasesField;
            }
            set
            {
                this.aliasesField = value;
            }
        }

        /// <remarks/>
        public ServiceHandle Handle
        {
            get
            {
                return this.handleField;
            }
            set
            {
                this.handleField = value;
            }
        }

        /// <remarks/>
        public string DisplayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }

        /// <remarks/>
        public bool InverseRequired
        {
            get
            {
                return this.inverseRequiredField;
            }
            set
            {
                this.inverseRequiredField = value;
            }
        }

        /// <remarks/>
        public string Url
        {
            get
            {
                return this.urlField;
            }
            set
            {
                this.urlField = value;
            }
        }

        /// <remarks/>
        public string RSSUrl
        {
            get
            {
                return this.rSSUrlField;
            }
            set
            {
                this.rSSUrlField = value;
            }
        }

        /// <remarks/>
        public string AuthorizationCriteria
        {
            get
            {
                return this.authorizationCriteriaField;
            }
            set
            {
                this.authorizationCriteriaField = value;
            }
        }

        /// <remarks/>
        public bool IsBot
        {
            get
            {
                return this.isBotField;
            }
            set
            {
                this.isBotField = value;
            }
        }

        /// <remarks/>
        public string PublishersInverseNote
        {
            get
            {
                return this.publishersInverseNoteField;
            }
            set
            {
                this.publishersInverseNoteField = value;
            }
        }

        /// <remarks/>
        [System.ComponentModel.DefaultValueAttribute(true)]
        public bool NotifySubscribersOnUpdates
        {
            get
            {
                return this.notifySubscribersOnUpdatesField;
            }
            set
            {
                this.notifySubscribersOnUpdatesField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ServiceHandle
    {

        private short idField;

        private ServiceType typeField;

        private string foreignIdField;

        /// <remarks/>
        public short Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public ServiceType Type
        {
            get
            {
                return this.typeField;
            }
            set
            {
                this.typeField = value;
            }
        }

        /// <remarks/>
        public string ForeignId
        {
            get
            {
                return this.foreignIdField;
            }
            set
            {
                this.foreignIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ServiceType
    {

        /// <remarks/>
        Namespace,

        /// <remarks/>
        Calendar,

        /// <remarks/>
        Folder,

        /// <remarks/>
        ContactInfo,

        /// <remarks/>
        AddressBook,

        /// <remarks/>
        Favorites,

        /// <remarks/>
        Messenger,

        /// <remarks/>
        Space,

        /// <remarks/>
        MessageContainer,

        /// <remarks/>
        PhotoAlbum,

        /// <remarks/>
        List,

        /// <remarks/>
        ABCHInternal,

        /// <remarks/>
        Invitation,

        /// <remarks/>
        SocialNetwork,

        /// <remarks/>
        Profile,

        /// <remarks/>
        EmailNotifications,

        /// <remarks/>
        BlindEmail,

        /// <remarks/>
        Classifieds,

        /// <remarks/>
        CommunityQuestionAnswer,

        /// <remarks/>
        OfficeLiveWebNotification,

        /// <remarks/>
        SharedCircles,

        /// <remarks/>
        Custom,

        /// <remarks/>
        Email,

        /// <remarks/>
        Subscriber,

        /// <remarks/>
        ContentSet,

        /// <remarks/>
        TryStar,

        /// <remarks/>
        MessengerApplications,

        /// <remarks/>
        MailingList,

        /// <remarks/>
        MessengerPrivate,

        /// <remarks/>
        Event,

        /// <remarks/>
        Match,

        /// <remarks/>
        Contoso,

        /// <remarks/>
        Cumulus,

        /// <remarks/>
        MessengerPlatform01,

        /// <remarks/>
        MessengerPlatform02,

        /// <remarks/>
        MessengerPlatform03,

        /// <remarks/>
        MessengerPlatform04,

        /// <remarks/>
        MessengerPlatform05,

        /// <remarks/>
        MessengerPlatform06,

        /// <remarks/>
        MessengerPlatform07,

        /// <remarks/>
        MessengerPlatform08,

        /// <remarks/>
        WLCalendar,

        /// <remarks/>
        MessengerPlatform09,

        /// <remarks/>
        MessengerPlatform10,

        /// <remarks/>
        MessengerPlatform11,

        /// <remarks/>
        MessengerPlatform12,

        /// <remarks/>
        MessengerPlatform13,

        /// <remarks/>
        MessengerPlatform14,

        /// <remarks/>
        MessengerPlatform15,

        /// <remarks/>
        MessengerPlatform16,

        /// <remarks/>
        MessengerPlatform17,

        /// <remarks/>
        MessengerPlatform18,

        /// <remarks/>
        GroupSpace,

        /// <remarks/>
        GleamNotifications,

        /// <remarks/>
        PopFly,

        /// <remarks/>
        AppStorage,

        /// <remarks/>
        SkyDrive,

        /// <remarks/>
        VideoMail,

        /// <remarks/>
        XboxLive,

        /// <remarks/>
        Zune,

        /// <remarks/>
        PrivateNetwork,

        /// <remarks/>
        PhotoTagging,

        /// <remarks/>
        Reserved1,

        /// <remarks/>
        Reserved2,

        /// <remarks/>
        Reserved3,

        /// <remarks/>
        Reserved4,

        /// <remarks/>
        Reserved5,

        /// <remarks/>
        Reserved6,

        /// <remarks/>
        EduBlog,

        /// <remarks/>
        EduMessageBoard,

        /// <remarks/>
        EduWiki,

        /// <remarks/>
        EduTasks,

        /// <remarks/>
        EduCoursePlan,

        /// <remarks/>
        EduEPortfolio,

        /// <remarks/>
        EduStudentTracker,

        /// <remarks/>
        EduMarketplaceListing,

        /// <remarks/>
        EduEntity,

        /// <remarks/>
        EduList,

        /// <remarks/>
        EduContentSet,

        /// <remarks/>
        EduFolder,

        /// <remarks/>
        EduProfile,

        /// <remarks/>
        EduReserved1,

        /// <remarks/>
        EduReserved2,

        /// <remarks/>
        EduReserved3,

        /// <remarks/>
        EduReserved4,

        /// <remarks/>
        EduReserved5,

        /// <remarks/>
        LiveMobile,

        /// <remarks/>
        SNAPIFramework,

        /// <remarks/>
        Polaris,

        /// <remarks/>
        OfficeLive,

        /// <remarks/>
        WebActivity,

        /// <remarks/>
        MsnGamer,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class NamespaceHandle
    {

        private System.Guid idField;

        private string passportNameField;

        private bool isPassportNameHiddenField;

        private long cIDField;

        /// <remarks/>
        public System.Guid Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public string PassportName
        {
            get
            {
                return this.passportNameField;
            }
            set
            {
                this.passportNameField = value;
            }
        }

        /// <remarks/>
        public bool IsPassportNameHidden
        {
            get
            {
                return this.isPassportNameHiddenField;
            }
            set
            {
                this.isPassportNameHiddenField = value;
            }
        }

        /// <remarks/>
        public long CID
        {
            get
            {
                return this.cIDField;
            }
            set
            {
                this.cIDField = value;
            }
        }
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PhoneMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PassportMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GroupMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(ServiceMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PartnerMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(EmailMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(GuidMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RoleMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(EveryoneMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(CircleMember))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(DomainMember))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public abstract partial class Member
    {

        private int membershipIdField;

        private MemberType typeField;

        private NamespaceHandle locationField;

        private string displayNameField;

        private MemberState stateField;

        private RoleId newRoleField;

        private bool newRoleFieldSpecified;

        private Annotation[] annotationsField;

        private bool deletedField;

        private System.DateTime lastChangedField;

        private System.DateTime joinedDateField;

        private System.DateTime expirationDateField;

        private MemberPropertyTypes changesField;

        /// <remarks/>
        public int MembershipId
        {
            get
            {
                return this.membershipIdField;
            }
            set
            {
                this.membershipIdField = value;
            }
        }

        /// <remarks/>
        public MemberType Type
        {
            get
            {
                return this.typeField;
            }
            set
            {
                this.typeField = value;
            }
        }

        /// <remarks/>
        public NamespaceHandle Location
        {
            get
            {
                return this.locationField;
            }
            set
            {
                this.locationField = value;
            }
        }

        /// <remarks/>
        public string DisplayName
        {
            get
            {
                return this.displayNameField;
            }
            set
            {
                this.displayNameField = value;
            }
        }

        /// <remarks/>
        public MemberState State
        {
            get
            {
                return this.stateField;
            }
            set
            {
                this.stateField = value;
            }
        }

        /// <remarks/>
        public RoleId NewRole
        {
            get
            {
                return this.newRoleField;
            }
            set
            {
                this.newRoleField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool NewRoleSpecified
        {
            get
            {
                return this.newRoleFieldSpecified;
            }
            set
            {
                this.newRoleFieldSpecified = value;
            }
        }

        /// <remarks/>
        public Annotation[] Annotations
        {
            get
            {
                return this.annotationsField;
            }
            set
            {
                this.annotationsField = value;
            }
        }

        /// <remarks/>
        public bool Deleted
        {
            get
            {
                return this.deletedField;
            }
            set
            {
                this.deletedField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChanged
        {
            get
            {
                return this.lastChangedField;
            }
            set
            {
                this.lastChangedField = value;
            }
        }

        /// <remarks/>
        public System.DateTime JoinedDate
        {
            get
            {
                return this.joinedDateField;
            }
            set
            {
                this.joinedDateField = value;
            }
        }

        /// <remarks/>
        public System.DateTime ExpirationDate
        {
            get
            {
                return this.expirationDateField;
            }
            set
            {
                this.expirationDateField = value;
            }
        }

        /// <remarks/>
        public MemberPropertyTypes Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum MemberType
    {

        /// <remarks/>
        Passport,

        /// <remarks/>
        Everyone,

        /// <remarks/>
        Phone,

        /// <remarks/>
        Email,

        /// <remarks/>
        Group,

        /// <remarks/>
        Guid,

        /// <remarks/>
        Role,

        /// <remarks/>
        Service,

        /// <remarks/>
        Circle,

        /// <remarks/>
        Domain,

        /// <remarks/>
        Partner,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum MemberPropertyTypes
    {

        /// <remarks/>
        State = 1,

        /// <remarks/>
        Annotations = 2,

        /// <remarks/>
        DisplayName = 4,

        /// <remarks/>
        NewRole = 8,

        /// <remarks/>
        JoinedDate = 16,

        /// <remarks/>
        ExpirationDate = 32,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class PhoneMember : Member
    {

        private string phoneNumberField;

        /// <remarks/>
        public string PhoneNumber
        {
            get
            {
                return this.phoneNumberField;
            }
            set
            {
                this.phoneNumberField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class PassportMember : Member
    {

        private string passportNameField;

        private bool isPassportNameHiddenField;

        private long passportIdField;

        private long cIDField;

        private PassportMemberPropertyTypes passportChangesField;

        /// <remarks/>
        public string PassportName
        {
            get
            {
                return this.passportNameField;
            }
            set
            {
                this.passportNameField = value;
            }
        }

        /// <remarks/>
        public bool IsPassportNameHidden
        {
            get
            {
                return this.isPassportNameHiddenField;
            }
            set
            {
                this.isPassportNameHiddenField = value;
            }
        }

        /// <remarks/>
        public long PassportId
        {
            get
            {
                return this.passportIdField;
            }
            set
            {
                this.passportIdField = value;
            }
        }

        /// <remarks/>
        public long CID
        {
            get
            {
                return this.cIDField;
            }
            set
            {
                this.cIDField = value;
            }
        }

        /// <remarks/>
        public PassportMemberPropertyTypes PassportChanges
        {
            get
            {
                return this.passportChangesField;
            }
            set
            {
                this.passportChangesField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum PassportMemberPropertyTypes
    {

        /// <remarks/>
        IsPassportNameHidden = 1,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class GroupMember : Member
    {

        private System.Guid idField;

        /// <remarks/>
        public System.Guid Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ServiceMember : Member
    {

        private ServiceHandle serviceField;

        /// <remarks/>
        public ServiceHandle Service
        {
            get
            {
                return this.serviceField;
            }
            set
            {
                this.serviceField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class PartnerMember : Member
    {

        private long appIdField;

        private int scopeField;

        /// <remarks/>
        public long AppId
        {
            get
            {
                return this.appIdField;
            }
            set
            {
                this.appIdField = value;
            }
        }

        /// <remarks/>
        public int Scope
        {
            get
            {
                return this.scopeField;
            }
            set
            {
                this.scopeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class EmailMember : Member
    {

        private string emailField;

        /// <remarks/>
        public string Email
        {
            get
            {
                return this.emailField;
            }
            set
            {
                this.emailField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class GuidMember : Member
    {

        private System.Guid idField;

        /// <remarks/>
        public System.Guid Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class RoleMember : Member
    {

        private RoleId idField;

        private ServiceHandle definingServiceField;

        private int maxRoleRecursionDepthField;

        private int maxDegreesSeparationField;

        /// <remarks/>
        public RoleId Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public ServiceHandle DefiningService
        {
            get
            {
                return this.definingServiceField;
            }
            set
            {
                this.definingServiceField = value;
            }
        }

        /// <remarks/>
        public int MaxRoleRecursionDepth
        {
            get
            {
                return this.maxRoleRecursionDepthField;
            }
            set
            {
                this.maxRoleRecursionDepthField = value;
            }
        }

        /// <remarks/>
        public int MaxDegreesSeparation
        {
            get
            {
                return this.maxDegreesSeparationField;
            }
            set
            {
                this.maxDegreesSeparationField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class EveryoneMember : Member
    {
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleMember : Member
    {

        private System.Guid circleIdField;

        /// <remarks/>
        public System.Guid CircleId
        {
            get
            {
                return this.circleIdField;
            }
            set
            {
                this.circleIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class DomainMember : Member
    {

        private string domainNameField;

        /// <remarks/>
        public string DomainName
        {
            get
            {
                return this.domainNameField;
            }
            set
            {
                this.domainNameField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class Membership
    {

        private RoleId memberRoleField;

        private Member[] membersField;

        private bool membershipIsCompleteField;

        /// <remarks/>
        public RoleId MemberRole
        {
            get
            {
                return this.memberRoleField;
            }
            set
            {
                this.memberRoleField = value;
            }
        }

        /// <remarks/>
        public Member[] Members
        {
            get
            {
                return this.membersField;
            }
            set
            {
                this.membersField = value;
            }
        }

        /// <remarks/>
        public bool MembershipIsComplete
        {
            get
            {
                return this.membershipIsCompleteField;
            }
            set
            {
                this.membershipIsCompleteField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class Service
    {

        private Membership[] membershipsField;

        private ServiceInfo infoField;

        private ServicePropertyType changesField;

        private System.DateTime lastChangeField;

        private System.DateTime createdDateField;

        private bool deletedField;

        /// <remarks/>
        public Membership[] Memberships
        {
            get
            {
                return this.membershipsField;
            }
            set
            {
                this.membershipsField = value;
            }
        }

        /// <remarks/>
        public ServiceInfo Info
        {
            get
            {
                return this.infoField;
            }
            set
            {
                this.infoField = value;
            }
        }

        /// <remarks/>
        public ServicePropertyType Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChange
        {
            get
            {
                return this.lastChangeField;
            }
            set
            {
                this.lastChangeField = value;
            }
        }

        /// <remarks/>
        public System.DateTime CreatedDate
        {
            get
            {
                return this.createdDateField;
            }
            set
            {
                this.createdDateField = value;
            }
        }

        /// <remarks/>
        public bool Deleted
        {
            get
            {
                return this.deletedField;
            }
            set
            {
                this.deletedField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ServicePropertyType
    {

        /// <remarks/>
        DisplayName = 1,

        /// <remarks/>
        Url = 2,

        /// <remarks/>
        Annotation = 4,

        /// <remarks/>
        RSSUrl = 8,

        /// <remarks/>
        IsBot = 16,

        /// <remarks/>
        Alias = 32,

        /// <remarks/>
        PublishersInverseNote = 64,

        /// <remarks/>
        NotifySubscribersOnUpdates = 128,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class NotificationData
    {

        private Service storeServiceField;

        private RoleMember[] allowedRolesField;

        private StoreStatusTypes statusField;

        private bool statusFieldSpecified;

        private System.DateTime lastChangedField;

        private bool lastChangedFieldSpecified;

        private System.DateTime lastViewedField;

        private bool lastViewedFieldSpecified;

        private bool gleamField;

        private bool gleamFieldSpecified;

        private byte instanceIdField;

        private NotificationDetails notificationDetailsField;

        /// <remarks/>
        public Service StoreService
        {
            get
            {
                return this.storeServiceField;
            }
            set
            {
                this.storeServiceField = value;
            }
        }

        /// <remarks/>
        public RoleMember[] AllowedRoles
        {
            get
            {
                return this.allowedRolesField;
            }
            set
            {
                this.allowedRolesField = value;
            }
        }

        /// <remarks/>
        public StoreStatusTypes Status
        {
            get
            {
                return this.statusField;
            }
            set
            {
                this.statusField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool StatusSpecified
        {
            get
            {
                return this.statusFieldSpecified;
            }
            set
            {
                this.statusFieldSpecified = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChanged
        {
            get
            {
                return this.lastChangedField;
            }
            set
            {
                this.lastChangedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool LastChangedSpecified
        {
            get
            {
                return this.lastChangedFieldSpecified;
            }
            set
            {
                this.lastChangedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastViewed
        {
            get
            {
                return this.lastViewedField;
            }
            set
            {
                this.lastViewedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool LastViewedSpecified
        {
            get
            {
                return this.lastViewedFieldSpecified;
            }
            set
            {
                this.lastViewedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public bool Gleam
        {
            get
            {
                return this.gleamField;
            }
            set
            {
                this.gleamField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool GleamSpecified
        {
            get
            {
                return this.gleamFieldSpecified;
            }
            set
            {
                this.gleamFieldSpecified = value;
            }
        }

        /// <remarks/>
        public byte InstanceId
        {
            get
            {
                return this.instanceIdField;
            }
            set
            {
                this.instanceIdField = value;
            }
        }

        /// <remarks/>
        public NotificationDetails NotificationDetails
        {
            get
            {
                return this.notificationDetailsField;
            }
            set
            {
                this.notificationDetailsField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum StoreStatusTypes
    {

        /// <remarks/>
        Exist = 1,

        /// <remarks/>
        Access = 2,
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(CircleDynamicItem))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(PassportDynamicItem))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public abstract partial class DynamicItem
    {

        private DynamicItemType typeField;

        private bool deletedField;

        private System.DateTime lastChangedField;

        /// <remarks/>
        public DynamicItemType Type
        {
            get
            {
                return this.typeField;
            }
            set
            {
                this.typeField = value;
            }
        }

        /// <remarks/>
        public bool Deleted
        {
            get
            {
                return this.deletedField;
            }
            set
            {
                this.deletedField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChanged
        {
            get
            {
                return this.lastChangedField;
            }
            set
            {
                this.lastChangedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum DynamicItemType
    {

        /// <remarks/>
        Passport,

        /// <remarks/>
        Circle,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CircleDynamicItem : DynamicItem
    {

        private long idField;

        private NotificationData[] notificationsField;

        private CircleDynamicItemPropertyTypes changesField;

        /// <remarks/>
        public long Id
        {
            get
            {
                return this.idField;
            }
            set
            {
                this.idField = value;
            }
        }

        /// <remarks/>
        public NotificationData[] Notifications
        {
            get
            {
                return this.notificationsField;
            }
            set
            {
                this.notificationsField = value;
            }
        }

        /// <remarks/>
        public CircleDynamicItemPropertyTypes Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum CircleDynamicItemPropertyTypes
    {

        /// <remarks/>
        Notifications = 1,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class PassportDynamicItem : DynamicItem
    {

        private string passportNameField;

        private long passportIdField;

        private long cIDField;

        private SpaceStatusType spaceStatusField;

        private System.DateTime spaceLastChangedField;

        private bool spaceLastChangedFieldSpecified;

        private System.DateTime spaceLastViewedField;

        private bool spaceLastViewedFieldSpecified;

        private bool spaceGleamField;

        private ProfileStatusType profileStatusField;

        private System.DateTime profileLastChangedField;

        private bool profileLastChangedFieldSpecified;

        private System.DateTime profileLastViewedField;

        private bool profileLastViewedFieldSpecified;

        private bool profileGleamField;

        private System.DateTime profileLastComparedField;

        private bool profileLastComparedFieldSpecified;

        private ContactProfileStatusType contactProfileStatusField;

        private System.DateTime contactProfileLastChangedField;

        private bool contactProfileLastChangedFieldSpecified;

        private System.DateTime contactProfileLastViewedField;

        private bool contactProfileLastViewedFieldSpecified;

        private System.DateTime liveContactLastChangedField;

        private bool liveContactLastChangedFieldSpecified;

        private System.DateTime contactLastComparedField;

        private bool contactLastComparedFieldSpecified;

        private NotificationData[] notificationsField;

        private PassportDynamicItemPropertyType changesField;

        /// <remarks/>
        public string PassportName
        {
            get
            {
                return this.passportNameField;
            }
            set
            {
                this.passportNameField = value;
            }
        }

        /// <remarks/>
        public long PassportId
        {
            get
            {
                return this.passportIdField;
            }
            set
            {
                this.passportIdField = value;
            }
        }

        /// <remarks/>
        public long CID
        {
            get
            {
                return this.cIDField;
            }
            set
            {
                this.cIDField = value;
            }
        }

        /// <remarks/>
        public SpaceStatusType SpaceStatus
        {
            get
            {
                return this.spaceStatusField;
            }
            set
            {
                this.spaceStatusField = value;
            }
        }

        /// <remarks/>
        public System.DateTime SpaceLastChanged
        {
            get
            {
                return this.spaceLastChangedField;
            }
            set
            {
                this.spaceLastChangedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool SpaceLastChangedSpecified
        {
            get
            {
                return this.spaceLastChangedFieldSpecified;
            }
            set
            {
                this.spaceLastChangedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public System.DateTime SpaceLastViewed
        {
            get
            {
                return this.spaceLastViewedField;
            }
            set
            {
                this.spaceLastViewedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool SpaceLastViewedSpecified
        {
            get
            {
                return this.spaceLastViewedFieldSpecified;
            }
            set
            {
                this.spaceLastViewedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public bool SpaceGleam
        {
            get
            {
                return this.spaceGleamField;
            }
            set
            {
                this.spaceGleamField = value;
            }
        }

        /// <remarks/>
        public ProfileStatusType ProfileStatus
        {
            get
            {
                return this.profileStatusField;
            }
            set
            {
                this.profileStatusField = value;
            }
        }

        /// <remarks/>
        public System.DateTime ProfileLastChanged
        {
            get
            {
                return this.profileLastChangedField;
            }
            set
            {
                this.profileLastChangedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ProfileLastChangedSpecified
        {
            get
            {
                return this.profileLastChangedFieldSpecified;
            }
            set
            {
                this.profileLastChangedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public System.DateTime ProfileLastViewed
        {
            get
            {
                return this.profileLastViewedField;
            }
            set
            {
                this.profileLastViewedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ProfileLastViewedSpecified
        {
            get
            {
                return this.profileLastViewedFieldSpecified;
            }
            set
            {
                this.profileLastViewedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public bool ProfileGleam
        {
            get
            {
                return this.profileGleamField;
            }
            set
            {
                this.profileGleamField = value;
            }
        }

        /// <remarks/>
        public System.DateTime ProfileLastCompared
        {
            get
            {
                return this.profileLastComparedField;
            }
            set
            {
                this.profileLastComparedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ProfileLastComparedSpecified
        {
            get
            {
                return this.profileLastComparedFieldSpecified;
            }
            set
            {
                this.profileLastComparedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public ContactProfileStatusType ContactProfileStatus
        {
            get
            {
                return this.contactProfileStatusField;
            }
            set
            {
                this.contactProfileStatusField = value;
            }
        }

        /// <remarks/>
        public System.DateTime ContactProfileLastChanged
        {
            get
            {
                return this.contactProfileLastChangedField;
            }
            set
            {
                this.contactProfileLastChangedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ContactProfileLastChangedSpecified
        {
            get
            {
                return this.contactProfileLastChangedFieldSpecified;
            }
            set
            {
                this.contactProfileLastChangedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public System.DateTime ContactProfileLastViewed
        {
            get
            {
                return this.contactProfileLastViewedField;
            }
            set
            {
                this.contactProfileLastViewedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ContactProfileLastViewedSpecified
        {
            get
            {
                return this.contactProfileLastViewedFieldSpecified;
            }
            set
            {
                this.contactProfileLastViewedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public System.DateTime LiveContactLastChanged
        {
            get
            {
                return this.liveContactLastChangedField;
            }
            set
            {
                this.liveContactLastChangedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool LiveContactLastChangedSpecified
        {
            get
            {
                return this.liveContactLastChangedFieldSpecified;
            }
            set
            {
                this.liveContactLastChangedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public System.DateTime ContactLastCompared
        {
            get
            {
                return this.contactLastComparedField;
            }
            set
            {
                this.contactLastComparedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ContactLastComparedSpecified
        {
            get
            {
                return this.contactLastComparedFieldSpecified;
            }
            set
            {
                this.contactLastComparedFieldSpecified = value;
            }
        }

        /// <remarks/>
        public NotificationData[] Notifications
        {
            get
            {
                return this.notificationsField;
            }
            set
            {
                this.notificationsField = value;
            }
        }

        /// <remarks/>
        public PassportDynamicItemPropertyType Changes
        {
            get
            {
                return this.changesField;
            }
            set
            {
                this.changesField = value;
            }
        }
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum SpaceStatusType
    {

        /// <remarks/>
        Exist = 1,

        /// <remarks/>
        Access = 2,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ProfileStatusType
    {

        /// <remarks/>
        Exist = 1,

        /// <remarks/>
        Access = 2,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactProfileStatusType
    {

        /// <remarks/>
        Exist = 1,

        /// <remarks/>
        Access = 2,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum PassportDynamicItemPropertyType
    {

        /// <remarks/>
        SpaceStatus = 1,

        /// <remarks/>
        SpaceLastChanged = 2,

        /// <remarks/>
        SpaceLastViewed = 4,

        /// <remarks/>
        SpaceGleam = 8,

        /// <remarks/>
        ProfileStatus = 16,

        /// <remarks/>
        ProfileLastChanged = 32,

        /// <remarks/>
        ProfileLastViewed = 64,

        /// <remarks/>
        ProfileGleam = 128,

        /// <remarks/>
        ProfileLastCompared = 256,

        /// <remarks/>
        ContactProfileStatus = 512,

        /// <remarks/>
        ContactProfileLastChanged = 1024,

        /// <remarks/>
        ContactProfileLastViewed = 2048,

        /// <remarks/>
        LiveContactLastChanged = 4096,

        /// <remarks/>
        ContactLastCompared = 8192,

        /// <remarks/>
        Notifications = 16384,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class FindResult
    {

        private Group[] groupsField;

        private Contact[] contactsField;

        private Category[] categoriesField;

        private DynamicItem[] dynamicItemsField;

        private CircleResult circleResultField;

        private RecentActivityItem[] recentActivitiesField;

        private AB abField;

        /// <remarks/>
        public Group[] groups
        {
            get
            {
                return this.groupsField;
            }
            set
            {
                this.groupsField = value;
            }
        }

        /// <remarks/>
        public Contact[] contacts
        {
            get
            {
                return this.contactsField;
            }
            set
            {
                this.contactsField = value;
            }
        }

        /// <remarks/>
        public Category[] Categories
        {
            get
            {
                return this.categoriesField;
            }
            set
            {
                this.categoriesField = value;
            }
        }

        /// <remarks/>
        public DynamicItem[] DynamicItems
        {
            get
            {
                return this.dynamicItemsField;
            }
            set
            {
                this.dynamicItemsField = value;
            }
        }

        /// <remarks/>
        public CircleResult CircleResult
        {
            get
            {
                return this.circleResultField;
            }
            set
            {
                this.circleResultField = value;
            }
        }

        /// <remarks/>
        public RecentActivityItem[] RecentActivities
        {
            get
            {
                return this.recentActivitiesField;
            }
            set
            {
                this.recentActivitiesField = value;
            }
        }

        /// <remarks/>
        public AB ab
        {
            get
            {
                return this.abField;
            }
            set
            {
                this.abField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class RecentActivityViewOptions
    {

        private RecentActivityViewMode viewField;

        private System.DateTime lastChangeField;

        /// <remarks/>
        public RecentActivityViewMode View
        {
            get
            {
                return this.viewField;
            }
            set
            {
                this.viewField = value;
            }
        }

        /// <remarks/>
        public System.DateTime LastChange
        {
            get
            {
                return this.lastChangeField;
            }
            set
            {
                this.lastChangeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum RecentActivityViewMode
    {

        /// <remarks/>
        None,

        /// <remarks/>
        Full,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class GroupContactAddOptions
    {

        private bool fMergeField;

        private bool fGenerateMissingQuickNameField;

        private bool enableAllowListManagementField;

        private bool disableIMListManagementField;

        /// <remarks/>
        public bool fMerge
        {
            get
            {
                return this.fMergeField;
            }
            set
            {
                this.fMergeField = value;
            }
        }

        /// <remarks/>
        public bool fGenerateMissingQuickName
        {
            get
            {
                return this.fGenerateMissingQuickNameField;
            }
            set
            {
                this.fGenerateMissingQuickNameField = value;
            }
        }

        /// <remarks/>
        public bool EnableAllowListManagement
        {
            get
            {
                return this.enableAllowListManagementField;
            }
            set
            {
                this.enableAllowListManagementField = value;
            }
        }

        /// <remarks/>
        public bool DisableIMListManagement
        {
            get
            {
                return this.disableIMListManagementField;
            }
            set
            {
                this.disableIMListManagementField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactDeleteOptions
    {

        private bool enableAllowListManagementField;

        private bool disableIMListManagementField;

        /// <remarks/>
        public bool EnableAllowListManagement
        {
            get
            {
                return this.enableAllowListManagementField;
            }
            set
            {
                this.enableAllowListManagementField = value;
            }
        }

        /// <remarks/>
        public bool DisableIMListManagement
        {
            get
            {
                return this.disableIMListManagementField;
            }
            set
            {
                this.disableIMListManagementField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactAddOptions
    {

        private bool enableAllowListManagementField;

        private bool disableIMListManagementField;

        /// <remarks/>
        public bool EnableAllowListManagement
        {
            get
            {
                return this.enableAllowListManagementField;
            }
            set
            {
                this.enableAllowListManagementField = value;
            }
        }

        /// <remarks/>
        public bool DisableIMListManagement
        {
            get
            {
                return this.disableIMListManagementField;
            }
            set
            {
                this.disableIMListManagementField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactFindResult
    {

        private Group[] groupsField;

        private Contact[] contactsField;

        private System.DateTime ablastChangeField;

        /// <remarks/>
        public Group[] groups
        {
            get
            {
                return this.groupsField;
            }
            set
            {
                this.groupsField = value;
            }
        }

        /// <remarks/>
        public Contact[] contacts
        {
            get
            {
                return this.contactsField;
            }
            set
            {
                this.contactsField = value;
            }
        }

        /// <remarks/>
        public System.DateTime ablastChange
        {
            get
            {
                return this.ablastChangeField;
            }
            set
            {
                this.ablastChangeField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class GroupFilter
    {

        private System.Guid[] groupIdsField;

        private System.Guid[] groupTypesField;

        /// <remarks/>
        public System.Guid[] groupIds
        {
            get
            {
                return this.groupIdsField;
            }
            set
            {
                this.groupIdsField = value;
            }
        }

        /// <remarks/>
        public System.Guid[] groupTypes
        {
            get
            {
                return this.groupTypesField;
            }
            set
            {
                this.groupTypesField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactFilter
    {

        private System.Guid[] contactIdsField;

        private GroupFilter groupFilterField;

        private System.DateTime lastChangeField;

        private ContactInfoType contactInfoViewField;

        private bool fDeltasOnlyField;

        /// <remarks/>
        public System.Guid[] contactIds
        {
            get
            {
                return this.contactIdsField;
            }
            set
            {
                this.contactIdsField = value;
            }
        }

        /// <remarks/>
        public GroupFilter groupFilter
        {
            get
            {
                return this.groupFilterField;
            }
            set
            {
                this.groupFilterField = value;
            }
        }

        /// <remarks/>
        public System.DateTime lastChange
        {
            get
            {
                return this.lastChangeField;
            }
            set
            {
                this.lastChangeField = value;
            }
        }

        /// <remarks/>
        public ContactInfoType contactInfoView
        {
            get
            {
                return this.contactInfoViewField;
            }
            set
            {
                this.contactInfoViewField = value;
            }
        }

        /// <remarks/>
        public bool fDeltasOnly
        {
            get
            {
                return this.fDeltasOnlyField;
            }
            set
            {
                this.fDeltasOnlyField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ContactInfoType
    {

        /// <remarks/>
        ContactInfoHotmail,

        /// <remarks/>
        ContactInfoMessenger,

        /// <remarks/>
        ContactInfoAll,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ContactUpdateOptions
    {

        private bool enableAllowListManagementField;

        private bool disableIMListManagementField;

        /// <remarks/>
        public bool EnableAllowListManagement
        {
            get
            {
                return this.enableAllowListManagementField;
            }
            set
            {
                this.enableAllowListManagementField = value;
            }
        }

        /// <remarks/>
        public bool DisableIMListManagement
        {
            get
            {
                return this.disableIMListManagementField;
            }
            set
            {
                this.disableIMListManagementField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CallTraceEntry
    {

        private short depthField;

        private string hostNameField;

        private string apiField;

        private long partitionKeyField;

        private short partitionIdField;

        private CallResponseType responseField;

        private string errorInfoField;

        /// <remarks/>
        public short Depth
        {
            get
            {
                return this.depthField;
            }
            set
            {
                this.depthField = value;
            }
        }

        /// <remarks/>
        public string HostName
        {
            get
            {
                return this.hostNameField;
            }
            set
            {
                this.hostNameField = value;
            }
        }

        /// <remarks/>
        public string Api
        {
            get
            {
                return this.apiField;
            }
            set
            {
                this.apiField = value;
            }
        }

        /// <remarks/>
        public long PartitionKey
        {
            get
            {
                return this.partitionKeyField;
            }
            set
            {
                this.partitionKeyField = value;
            }
        }

        /// <remarks/>
        public short PartitionId
        {
            get
            {
                return this.partitionIdField;
            }
            set
            {
                this.partitionIdField = value;
            }
        }

        /// <remarks/>
        public CallResponseType Response
        {
            get
            {
                return this.responseField;
            }
            set
            {
                this.responseField = value;
            }
        }

        /// <remarks/>
        public string ErrorInfo
        {
            get
            {
                return this.errorInfoField;
            }
            set
            {
                this.errorInfoField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum CallResponseType
    {

        /// <remarks/>
        Unknown,

        /// <remarks/>
        Success,

        /// <remarks/>
        ClientError,

        /// <remarks/>
        ServerError,

        /// <remarks/>
        CommunicationError,

        /// <remarks/>
        Redirect,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CallTraceHeader
    {

        private short maxDepthField;

        private short redirectsField;

        private short failuresField;

        private CallTraceEntry[] callsField;

        /// <remarks/>
        public short MaxDepth
        {
            get
            {
                return this.maxDepthField;
            }
            set
            {
                this.maxDepthField = value;
            }
        }

        /// <remarks/>
        public short Redirects
        {
            get
            {
                return this.redirectsField;
            }
            set
            {
                this.redirectsField = value;
            }
        }

        /// <remarks/>
        public short Failures
        {
            get
            {
                return this.failuresField;
            }
            set
            {
                this.failuresField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Calls")]
        public CallTraceEntry[] Calls
        {
            get
            {
                return this.callsField;
            }
            set
            {
                this.callsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CrossClusterSettings
    {

        private int timeoutField;

        private int maxRecursionDepthField;

        private int maxRedirectsField;

        private int maxRetriesField;

        private int maxConsecutiveErrorsField;

        private int maxConnectionLifetimeField;

        private string proxyServerField;

        /// <remarks/>
        public int Timeout
        {
            get
            {
                return this.timeoutField;
            }
            set
            {
                this.timeoutField = value;
            }
        }

        /// <remarks/>
        public int MaxRecursionDepth
        {
            get
            {
                return this.maxRecursionDepthField;
            }
            set
            {
                this.maxRecursionDepthField = value;
            }
        }

        /// <remarks/>
        public int MaxRedirects
        {
            get
            {
                return this.maxRedirectsField;
            }
            set
            {
                this.maxRedirectsField = value;
            }
        }

        /// <remarks/>
        public int MaxRetries
        {
            get
            {
                return this.maxRetriesField;
            }
            set
            {
                this.maxRetriesField = value;
            }
        }

        /// <remarks/>
        public int MaxConsecutiveErrors
        {
            get
            {
                return this.maxConsecutiveErrorsField;
            }
            set
            {
                this.maxConsecutiveErrorsField = value;
            }
        }

        /// <remarks/>
        public int MaxConnectionLifetime
        {
            get
            {
                return this.maxConnectionLifetimeField;
            }
            set
            {
                this.maxConnectionLifetimeField = value;
            }
        }

        /// <remarks/>
        public string ProxyServer
        {
            get
            {
                return this.proxyServerField;
            }
            set
            {
                this.proxyServerField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class PartitionedResource
    {

        private System.Guid partitionKeyField;

        private short partitionIdField;

        private short ldcIdField;

        /// <remarks/>
        public System.Guid PartitionKey
        {
            get
            {
                return this.partitionKeyField;
            }
            set
            {
                this.partitionKeyField = value;
            }
        }

        /// <remarks/>
        public short PartitionId
        {
            get
            {
                return this.partitionIdField;
            }
            set
            {
                this.partitionIdField = value;
            }
        }

        /// <remarks/>
        public short LdcId
        {
            get
            {
                return this.ldcIdField;
            }
            set
            {
                this.ldcIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class ABContext
    {

        private System.Guid aBIdField;

        private long ownerPuidField;

        private long ownerCidField;

        private string ownerPassportField;

        private string ownerDisplayNameField;

        private System.Nullable<bool> ownerIsManagedField;

        private System.Nullable<bool> ownerIsRestrictedField;

        private short ldcIdField;

        private short partitionIdField;

        private bool partitionIdChangedField;

        private PartitionedResource sqlResField;

        private short partitionIdFromCacheField;

        private short ldcIdFromCacheField;

        private bool lpsMappingAddedField;

        /// <remarks/>
        public System.Guid ABId
        {
            get
            {
                return this.aBIdField;
            }
            set
            {
                this.aBIdField = value;
            }
        }

        /// <remarks/>
        public long OwnerPuid
        {
            get
            {
                return this.ownerPuidField;
            }
            set
            {
                this.ownerPuidField = value;
            }
        }

        /// <remarks/>
        public long OwnerCid
        {
            get
            {
                return this.ownerCidField;
            }
            set
            {
                this.ownerCidField = value;
            }
        }

        /// <remarks/>
        public string OwnerPassport
        {
            get
            {
                return this.ownerPassportField;
            }
            set
            {
                this.ownerPassportField = value;
            }
        }

        /// <remarks/>
        public string OwnerDisplayName
        {
            get
            {
                return this.ownerDisplayNameField;
            }
            set
            {
                this.ownerDisplayNameField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable = true)]
        public System.Nullable<bool> OwnerIsManaged
        {
            get
            {
                return this.ownerIsManagedField;
            }
            set
            {
                this.ownerIsManagedField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable = true)]
        public System.Nullable<bool> OwnerIsRestricted
        {
            get
            {
                return this.ownerIsRestrictedField;
            }
            set
            {
                this.ownerIsRestrictedField = value;
            }
        }

        /// <remarks/>
        public short LdcId
        {
            get
            {
                return this.ldcIdField;
            }
            set
            {
                this.ldcIdField = value;
            }
        }

        /// <remarks/>
        public short PartitionId
        {
            get
            {
                return this.partitionIdField;
            }
            set
            {
                this.partitionIdField = value;
            }
        }

        /// <remarks/>
        public bool PartitionIdChanged
        {
            get
            {
                return this.partitionIdChangedField;
            }
            set
            {
                this.partitionIdChangedField = value;
            }
        }

        /// <remarks/>
        public PartitionedResource SqlRes
        {
            get
            {
                return this.sqlResField;
            }
            set
            {
                this.sqlResField = value;
            }
        }

        /// <remarks/>
        public short PartitionIdFromCache
        {
            get
            {
                return this.partitionIdFromCacheField;
            }
            set
            {
                this.partitionIdFromCacheField = value;
            }
        }

        /// <remarks/>
        public short LdcIdFromCache
        {
            get
            {
                return this.ldcIdFromCacheField;
            }
            set
            {
                this.ldcIdFromCacheField = value;
            }
        }

        /// <remarks/>
        public bool LpsMappingAdded
        {
            get
            {
                return this.lpsMappingAddedField;
            }
            set
            {
                this.lpsMappingAddedField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public partial class CallForwardHeader
    {

        private System.Guid originalApplicationIdField;

        private ABSecurityPrivilege originalPrivilegeField;

        private bool isSecureConnectionField;

        private bool callerIsAdminField;

        private ABContext targetABField;

        private short callDepthField;

        private bool callerIsNamespaceOwnerField;

        private bool isApplicationAuthField;

        private bool isDelegatedAuthField;

        private long idsAppIdField;

        private string offerNameField;

        private string callPathField;

        /// <remarks/>
        public System.Guid OriginalApplicationId
        {
            get
            {
                return this.originalApplicationIdField;
            }
            set
            {
                this.originalApplicationIdField = value;
            }
        }

        /// <remarks/>
        public ABSecurityPrivilege OriginalPrivilege
        {
            get
            {
                return this.originalPrivilegeField;
            }
            set
            {
                this.originalPrivilegeField = value;
            }
        }

        /// <remarks/>
        public bool IsSecureConnection
        {
            get
            {
                return this.isSecureConnectionField;
            }
            set
            {
                this.isSecureConnectionField = value;
            }
        }

        /// <remarks/>
        public bool CallerIsAdmin
        {
            get
            {
                return this.callerIsAdminField;
            }
            set
            {
                this.callerIsAdminField = value;
            }
        }

        /// <remarks/>
        public ABContext TargetAB
        {
            get
            {
                return this.targetABField;
            }
            set
            {
                this.targetABField = value;
            }
        }

        /// <remarks/>
        public short CallDepth
        {
            get
            {
                return this.callDepthField;
            }
            set
            {
                this.callDepthField = value;
            }
        }

        /// <remarks/>
        public bool CallerIsNamespaceOwner
        {
            get
            {
                return this.callerIsNamespaceOwnerField;
            }
            set
            {
                this.callerIsNamespaceOwnerField = value;
            }
        }

        /// <remarks/>
        public bool IsApplicationAuth
        {
            get
            {
                return this.isApplicationAuthField;
            }
            set
            {
                this.isApplicationAuthField = value;
            }
        }

        /// <remarks/>
        public bool IsDelegatedAuth
        {
            get
            {
                return this.isDelegatedAuthField;
            }
            set
            {
                this.isDelegatedAuthField = value;
            }
        }

        /// <remarks/>
        public long IdsAppId
        {
            get
            {
                return this.idsAppIdField;
            }
            set
            {
                this.idsAppIdField = value;
            }
        }

        /// <remarks/>
        public string OfferName
        {
            get
            {
                return this.offerNameField;
            }
            set
            {
                this.offerNameField = value;
            }
        }

        /// <remarks/>
        public string CallPath
        {
            get
            {
                return this.callPathField;
            }
            set
            {
                this.callPathField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ABSecurityPrivilege
    {

        /// <remarks/>
        Partner,

        /// <remarks/>
        Public,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://www.msn.com/webservices/AddressBook", IsNullable = false)]
    public partial class ABTestHeader : System.Web.Services.Protocols.SoapHeader
    {

        private bool disableAuthField;

        private bool enableHiddenAPIField;

        private bool skipCIDLookupField;

        private string provisionPartitionIdField;

        private bool resetClusterMembershipField;

        private bool traceCrossClusterCallsField;

        private CrossClusterSettings clusterSettingsField;

        private System.Xml.XmlAttribute[] anyAttrField;

        /// <remarks/>
        public bool DisableAuth
        {
            get
            {
                return this.disableAuthField;
            }
            set
            {
                this.disableAuthField = value;
            }
        }

        /// <remarks/>
        public bool EnableHiddenAPI
        {
            get
            {
                return this.enableHiddenAPIField;
            }
            set
            {
                this.enableHiddenAPIField = value;
            }
        }

        /// <remarks/>
        public bool SkipCIDLookup
        {
            get
            {
                return this.skipCIDLookupField;
            }
            set
            {
                this.skipCIDLookupField = value;
            }
        }

        /// <remarks/>
        public string ProvisionPartitionId
        {
            get
            {
                return this.provisionPartitionIdField;
            }
            set
            {
                this.provisionPartitionIdField = value;
            }
        }

        /// <remarks/>
        public bool ResetClusterMembership
        {
            get
            {
                return this.resetClusterMembershipField;
            }
            set
            {
                this.resetClusterMembershipField = value;
            }
        }

        /// <remarks/>
        public bool TraceCrossClusterCalls
        {
            get
            {
                return this.traceCrossClusterCallsField;
            }
            set
            {
                this.traceCrossClusterCallsField = value;
            }
        }

        /// <remarks/>
        public CrossClusterSettings ClusterSettings
        {
            get
            {
                return this.clusterSettingsField;
            }
            set
            {
                this.clusterSettingsField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr
        {
            get
            {
                return this.anyAttrField;
            }
            set
            {
                this.anyAttrField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://www.msn.com/webservices/AddressBook", IsNullable = false)]
    public partial class ABApplicationHeader : System.Web.Services.Protocols.SoapHeader
    {

        private System.Guid applicationIdField;

        private bool isMigrationField;

        private string partnerScenarioField;

        private string brandIdField;

        private string sessionIdField;

        private string cacheKeyField;

        private CallForwardHeader callForwardInfoField;

        private System.Xml.XmlAttribute[] anyAttrField;

        /// <remarks/>
        public System.Guid ApplicationId
        {
            get
            {
                return this.applicationIdField;
            }
            set
            {
                this.applicationIdField = value;
            }
        }

        /// <remarks/>
        public bool IsMigration
        {
            get
            {
                return this.isMigrationField;
            }
            set
            {
                this.isMigrationField = value;
            }
        }

        /// <remarks/>
        public string PartnerScenario
        {
            get
            {
                return this.partnerScenarioField;
            }
            set
            {
                this.partnerScenarioField = value;
            }
        }

        /// <remarks/>
        public string BrandId
        {
            get
            {
                return this.brandIdField;
            }
            set
            {
                this.brandIdField = value;
            }
        }

        /// <remarks/>
        public string SessionId
        {
            get
            {
                return this.sessionIdField;
            }
            set
            {
                this.sessionIdField = value;
            }
        }

        /// <remarks/>
        public string CacheKey
        {
            get
            {
                return this.cacheKeyField;
            }
            set
            {
                this.cacheKeyField = value;
            }
        }

        /// <remarks/>
        public CallForwardHeader CallForwardInfo
        {
            get
            {
                return this.callForwardInfoField;
            }
            set
            {
                this.callForwardInfoField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr
        {
            get
            {
                return this.anyAttrField;
            }
            set
            {
                this.anyAttrField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://www.msn.com/webservices/AddressBook", IsNullable = false)]
    public partial class ServiceHeader : System.Web.Services.Protocols.SoapHeader
    {

        private string versionField;

        private string cacheKeyField;

        private bool cacheKeyChangedField;

        private string preferredHostNameField;

        private CallTraceHeader crossClusterCallsField;

        private string emailValidationTokenField;

        private string serverNameField;

        private string sessionIdField;

        private System.Xml.XmlAttribute[] anyAttrField;

        /// <remarks/>
        public string Version
        {
            get
            {
                return this.versionField;
            }
            set
            {
                this.versionField = value;
            }
        }

        /// <remarks/>
        public string CacheKey
        {
            get
            {
                return this.cacheKeyField;
            }
            set
            {
                this.cacheKeyField = value;
            }
        }

        /// <remarks/>
        public bool CacheKeyChanged
        {
            get
            {
                return this.cacheKeyChangedField;
            }
            set
            {
                this.cacheKeyChangedField = value;
            }
        }

        /// <remarks/>
        public string PreferredHostName
        {
            get
            {
                return this.preferredHostNameField;
            }
            set
            {
                this.preferredHostNameField = value;
            }
        }

        /// <remarks/>
        public CallTraceHeader CrossClusterCalls
        {
            get
            {
                return this.crossClusterCallsField;
            }
            set
            {
                this.crossClusterCallsField = value;
            }
        }

        /// <remarks/>
        public string EmailValidationToken
        {
            get
            {
                return this.emailValidationTokenField;
            }
            set
            {
                this.emailValidationTokenField = value;
            }
        }

        /// <remarks/>
        public string ServerName
        {
            get
            {
                return this.serverNameField;
            }
            set
            {
                this.serverNameField = value;
            }
        }

        /// <remarks/>
        public string SessionId
        {
            get
            {
                return this.sessionIdField;
            }
            set
            {
                this.sessionIdField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr
        {
            get
            {
                return this.anyAttrField;
            }
            set
            {
                this.anyAttrField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ABView
    {

        /// <remarks/>
        Full,

        /// <remarks/>
        Hotmail,

        /// <remarks/>
        MessengerServer,

        /// <remarks/>
        MessengerClient,

        /// <remarks/>
        Phone,

        /// <remarks/>
        MinimalPhone,

        /// <remarks/>
        MapPoint,

        /// <remarks/>
        None,

        /// <remarks/>
        ContactControl,

        /// <remarks/>
        Circle,

        /// <remarks/>
        CircleTicket,

        /// <remarks/>
        MessengerClient8,

        /// <remarks/>
        ContactId,

        /// <remarks/>
        ContactPicker,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ABDynamicItemView
    {

        /// <remarks/>
        None,

        /// <remarks/>
        Full,

        /// <remarks/>
        Gleam,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ManageWLConnectionOptions
    {

        /// <remarks/>
        SkipSendMail = 1,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum RelationshipState
    {

        /// <remarks/>
        None,

        /// <remarks/>
        PendingInbound,

        /// <remarks/>
        PendingOutbound,

        /// <remarks/>
        Accepted,

        /// <remarks/>
        Declined,
    }

    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.msn.com/webservices/AddressBook")]
    public enum ExtendedContentTypes
    {

        /// <remarks/>
        AB = 1,

        /// <remarks/>
        AllGroups = 2,

        /// <remarks/>
        AllCategories = 4,

        /// <remarks/>
        CircleResult = 8,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABAddCompletedEventHandler(object sender, ABAddCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABAddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABAddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public System.Guid Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABUpdateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindCompletedEventHandler(object sender, ABFindCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABFindCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public AB[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((AB[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddBrandIdCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteBrandIdCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABContactUpdateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABContactFindCompletedEventHandler(object sender, ABContactFindCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABContactFindCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABContactFindCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public ContactFindResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((ContactFindResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABContactAddCompletedEventHandler(object sender, ABContactAddCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABContactAddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABContactAddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public System.Guid[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABContactDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupAddCompletedEventHandler(object sender, ABGroupAddCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABGroupAddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABGroupAddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public System.Guid[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupUpdateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupFindCompletedEventHandler(object sender, ABGroupFindCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABGroupFindCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABGroupFindCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public Group[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((Group[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupContactAddCompletedEventHandler(object sender, ABGroupContactAddCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABGroupContactAddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABGroupContactAddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public System.Guid[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupContactDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABAllowListSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABAllowListGetCompletedEventHandler(object sender, ABAllowListGetCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABAllowListGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABAllowListGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindAllCompletedEventHandler(object sender, ABFindAllCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindAllCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABFindAllCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FindResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindByContactsCompletedEventHandler(object sender, ABFindByContactsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindByContactsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABFindByContactsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FindResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindMessengerUsersCompletedEventHandler(object sender, ABFindMessengerUsersCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindMessengerUsersCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABFindMessengerUsersCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FindResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindByGroupsCompletedEventHandler(object sender, ABFindByGroupsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindByGroupsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABFindByGroupsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FindResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindMeContactCompletedEventHandler(object sender, ABFindMeContactCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindMeContactCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABFindMeContactCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FindResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCategoryCompletedEventHandler(object sender, AddCategoryCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCategoryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AddCategoryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public Category[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((Category[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteCategoryCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateCategoryCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddDynamicItemCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateDynamicItemCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CircleUpdateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABSetForceFullSyncDateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void MergeABCompletedEventHandler(object sender, MergeABCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class MergeABCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal MergeABCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public MergeResponse Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((MergeResponse)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddABNetworksCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteABNetworkCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateABNetworkCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ViewABNetworksCompletedEventHandler(object sender, ViewABNetworksCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ViewABNetworksCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ViewABNetworksCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public NetworkInfo[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((NetworkInfo[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateContactCompletedEventHandler(object sender, CreateContactCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateContactCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CreateContactCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public Contact Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((Contact)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void FindContactCompletedEventHandler(object sender, FindContactCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class FindContactCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal FindContactCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FindContactResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FindContactResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddMessengerAddressCompletedEventHandler(object sender, AddMessengerAddressCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddMessengerAddressCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AddMessengerAddressCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public Contact Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((Contact)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateContactCompletedEventHandler(object sender, UpdateContactCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateContactCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal UpdateContactCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public Contact Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((Contact)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteContactCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BlockContactCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnblockContactCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void IsContactBlockedCompletedEventHandler(object sender, IsContactBlockedCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class IsContactBlockedCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal IsContactBlockedCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public bool Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void FindBlockedContactsCompletedEventHandler(object sender, FindBlockedContactsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class FindBlockedContactsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal FindBlockedContactsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public long[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((long[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendContactMessageCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void MakeConnectionCompletedEventHandler(object sender, MakeConnectionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class MakeConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal MakeConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public NetworkInfo[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((NetworkInfo[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ManageConnectionCompletedEventHandler(object sender, ManageConnectionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ManageConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ManageConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public NetworkInfo[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((NetworkInfo[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BreakConnectionCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ManageWLConnectionCompletedEventHandler(object sender, ManageWLConnectionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ManageWLConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ManageWLConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public Contact Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((Contact)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void StateTransitionCompletedEventHandler(object sender, StateTransitionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class StateTransitionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal StateTransitionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public RelationshipState Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((RelationshipState)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreatePendingMemberCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void FindWhatsNewSubscriptionsCompletedEventHandler(object sender, FindWhatsNewSubscriptionsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class FindWhatsNewSubscriptionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal FindWhatsNewSubscriptionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public WhatsNewSubscriptionsResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((WhatsNewSubscriptionsResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CircleUpdateInverseInfoCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindContactsPagedCompletedEventHandler(object sender, ABFindContactsPagedCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindContactsPagedCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ABFindContactsPagedCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FindContactsPagedResult Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FindContactsPagedResult)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReplaceHandleCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReserveAndFilterCompletedEventHandler(object sender, ReserveAndFilterCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReserveAndFilterCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ReserveAndFilterCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public FilterEmail[] Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((FilterEmail[])(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void MigrateABCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetGeoLocationCompletedEventHandler(object sender, GetGeoLocationCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetGeoLocationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetGeoLocationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState)
            :
                base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public GeoLocation Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((GeoLocation)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetGeoLocationCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy.Test\App.xaml.cs ===
﻿namespace Leet.Silverlight.RESTProxy.Test
{
    using System;
    using System.Xml.Linq;
    using System.Windows;
    using Microsoft.Silverlight.Testing;
    using Microsoft.Silverlight.Testing.Harness;
    using Microsoft.Silverlight.Testing.UnitTesting.Harness;
    using System.Text;
    using System.Windows.Browser;

    public partial class App : Application
    {
        public App()
        {
            this.Startup += this.Application_Startup;
            this.Exit += this.Application_Exit;
            this.UnhandledException += this.Application_UnhandledException;

            InitializeComponent();
        }

        ParsableLogProvider p;
        private void Application_Startup(object sender, StartupEventArgs e)
        {
            UnitTestSettings settings = UnitTestSystem.CreateDefaultSettings();
            p = new ParsableLogProvider();
            settings.LogProviders.Add(p);
            if (HtmlPage.Document.QueryString.ContainsKey("TestClass"))
            {
                settings.TestClassesToRun.Clear();
                settings.TestClassesToRun.Add(HtmlPage.Document.QueryString["TestClass"]);
            }
            settings.TestHarness.TestHarnessCompleted += new EventHandler<TestHarnessCompletedEventArgs>(TestHarness_TestHarnessCompleted);

            HtmlPage.Window.Invoke("TestStarted");
            this.RootVisual = UnitTestSystem.CreateTestPage(settings);
            
        }

        void TestHarness_TestHarnessCompleted(object sender, TestHarnessCompletedEventArgs e)
        {
            HtmlPage.Window.Invoke("TestFinished");
            HtmlPage.Window.Invoke("SetTestResult", p.ToString());
        }

        private void Application_Exit(object sender, EventArgs e)
        {
        }

        private void Application_UnhandledException(object sender, ApplicationUnhandledExceptionEventArgs e)
        {
            // If the app is running outside of the debugger then report the exception using
            // the browser's exception mechanism. On IE this will display it a yellow alert 
            // icon in the status bar and Firefox will display a script error.
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                // NOTE: This will allow the application to continue running after an exception has been thrown
                // but not handled. 
                // For production applications this error handling should be replaced with something that will 
                // report the error to the website and stop the application.
                e.Handled = true;
                Deployment.Current.Dispatcher.BeginInvoke(delegate { this.ReportErrorToDOM(e); });
            }
        }

        private void ReportErrorToDOM(ApplicationUnhandledExceptionEventArgs e)
        {
            try
            {
                string errorMsg = e.ExceptionObject.Message + e.ExceptionObject.StackTrace;
                errorMsg = errorMsg.Replace('"', '\'').Replace("\r\n", @"\n");
                HtmlPage.Window.Eval("throw new Error(\"Unhandled Error in Silverlight 3 Application " + errorMsg + "\");");
            }
            catch (Exception)
            {
            }
        }
    }

    public class ParsableLogProvider : LogProvider
    {
        private XDocument doc;
        private XElement root;

        public ParsableLogProvider()
            : base()
        {
            doc = new XDocument(
                root = new XElement("TestResults"));
        }

        string lastClass;
        /// <summary>
        /// Processes the specified log message.
        /// Happens once for TestGranularity of Harness, then twice for each of TestGroup (assembly), Test (class) and TestScenario (method) 
        /// </summary>
        /// <param name="logMessage">The log message.</param>
        public override void Process(LogMessage logMessage)
        {
            base.Process(logMessage);
            string messageString = ExtractText(logMessage);

            if (logMessage.Decorators.ContainsKey(UnitTestLogDecorator.TestClassMetadata))
            {
                lastClass = logMessage.Decorators[UnitTestLogDecorator.TestClassMetadata].ToString();
            }
            if (logMessage.MessageType == LogMessageType.TestExecution &&
                logMessage.Decorators.ContainsKey(UnitTestLogDecorator.IgnoreMessage))
            {
                DateTime now = DateTime.Now;
                XElement result =
                    new XElement("TestResult",
                        new XAttribute("Class", lastClass),
                        new XAttribute("Method", logMessage.Decorators[LogDecorator.NameProperty].ToString()),
                        new XAttribute("Started", now.ToString()),
                        new XAttribute("Finished", now.ToString()),
                        new XAttribute("Result", "Ignored"));
                root.Add(result);
            }
            else if (logMessage.MessageType == LogMessageType.TestResult)
            {
                ScenarioResult sr = (ScenarioResult)logMessage.Decorators[UnitTestLogDecorator.ScenarioResult];
                XElement result =
                    new XElement("TestResult",
                        new XAttribute("Class", lastClass),//logMessage.Decorators[UnitTestLogDecorator.TestClassMetadata].ToString()),
                        new XAttribute("Method", logMessage.Decorators[UnitTestLogDecorator.TestMethodMetadata].ToString()),
                        new XAttribute("Started", sr.Started.ToString()),
                        new XAttribute("Finished", sr.Finished.ToString()),
                        new XAttribute("Result", sr.Result.ToString()));
                
                if (sr.Exception != null)
                {
                    result.Add(
                        new XText(sr.Exception.ToString()));
                }

                root.Add(result);
            }
        }

        private string ExtractText(LogMessage logMessage)
        {
            StringBuilder msg = new StringBuilder();

            msg.AppendLine("MessageType: " + logMessage.MessageType.ToString());
            msg.AppendLine("Message: " + logMessage.Message);
            foreach (var d in logMessage.Decorators.Keys)
            {
                msg.AppendLine(" - " + d + ": " + logMessage.Decorators[d]);
            }
            string messageString = msg.ToString();

            HtmlPage.Window.Invoke("ReportTestResult", messageString);
            return messageString;
        }

        public override string ToString()
        {
            return doc.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\WebAuthProxy\WebAuthProxyEventArgs.cs ===
﻿namespace Leet.Silverlight.RESTProxy.WebAuthProxy
{
    using System;
    using System.ComponentModel;
    using System.Net;
    using System.Threading;
    using Leet.Core.Utils;

    public class WebAuthProxyEventArgs : AsyncCompletedEventArgs
    {
        // TODO: The platform ID for the web platform is hardcoded for now
        private const uint PlatformID = 6; // WebGames
        private const string SamlTokenPreamble = "XBL1.0 x=";

        public WebAuthProxyEventArgs(string authToken, bool isPartnerToken, Exception exception, bool cancelled, object userToken)
            : base(exception, cancelled, userToken)
        {
            if (!String.IsNullOrEmpty(authToken))
            {
                this.WebHeaders = new WebHeaderCollection();
                this.WebHeaders[CustomWebHeaderNames.XLocale] = Thread.CurrentThread.CurrentUICulture.ToString();
                this.WebHeaders[CustomWebHeaderNames.XPlatformType] = PlatformID.ToString();

                // TODO: Move XBL1.0 and WLID1.0 to the Leet.Core.Utils webheaders namespace
                if (isPartnerToken)
                {
                    this.WebHeaders[CustomWebHeaderNames.XPartnerAuthorization] = SamlTokenPreamble + authToken;
                }
                else
                {
                    this.WebHeaders[CustomWebHeaderNames.XAuthorization] = SamlTokenPreamble + authToken;
                }
            }
        }

        public WebHeaderCollection Result
        {
            get
            {
                RaiseExceptionIfNecessary();
                return this.WebHeaders;
            }
        }

        private WebHeaderCollection WebHeaders { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.RESTProxy\WebAuthProxy\WebAuthProxy.cs ===
﻿namespace Leet.Silverlight.RESTProxy.WebAuthProxy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Xml.Linq;

    /// <summary>
    /// WebAuthProxy is designed to convert the HttpOnly CompactTicket provided during
    /// signin process into a form that can be used by other Silverlight plugins that
    /// access ActiveAuth-gated LiveN services
    /// </summary>
    public class WebAuthProxy : IWebAuthProxy
    {
        private const string InvalidUrlExceptionMessage = "The Uri provided is in an invalid format";
        private const string StsServiceRelativePathAndQuery = "token?gameID={gameId}&gameversion={gameVersion}";

        /// <summary>
        /// Initializes a new instance of the WebAuthProxy class
        /// </summary>
        /// <param name="uriStsService">The Uri for the STS Service</param>
        public WebAuthProxy(Uri uriStsService)
        {
            if (!uriStsService.IsAbsoluteUri)
            {
                throw new ArgumentException(WebAuthProxy.InvalidUrlExceptionMessage, "uriStsService");
            }

            this.StsService = uriStsService;
        }

        // Callers will have to subscribe to this event to capture the output
        public event EventHandler<WebAuthProxyEventArgs> OnWebAuthRequestCompleted;

        private Uri StsService { get; set; }

        public void GetUserTokenHTTP(uint gameId, uint gameVersion)
        {
            // URL for the STS Token service
            string fullUri = this.GetUriTemplate(this.StsService, WebAuthProxy.StsServiceRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{gameId}", gameId.ToString());
            fullUri = fullUri.Replace("{gameVersion}", gameVersion.ToString());
            Uri serviceUri = new Uri(fullUri);

#if WINDOWS
            WebClient browserStackCall = new WebClient();
#else
            WebClient browserStackCall = new WebClient { AllowReadStreamBuffering = true };
#endif
            browserStackCall.DownloadStringCompleted += this.OnDownloadUserTokenCompleted;
            browserStackCall.DownloadStringAsync(serviceUri);
        }

        private void OnDownloadUserTokenCompleted(object sender, DownloadStringCompletedEventArgs e)
        {
            string userToken = null;
            Exception wapException = null;

            if (e.Error == null)
            {
                try
                {
                    // Extract the partner token XML field - we expect at least 1 user token node but
                    // if we support more claims or priviledges we can support more in the web header
                    XElement xmlRoot = XElement.Parse(e.Result);
                    IEnumerable<XElement> userTokens = (from item in xmlRoot.Elements() where item.Name.LocalName == "User" select item);
                    if (userTokens.Count() > 0)
                    {
                        userToken = userTokens.First<XElement>().Value;
                    }
                    else
                    {
                        wapException = new ArgumentException("Incorrect number of user tokens");
                    }
                }
                catch (Exception ex)
                {
                    // Pass any parsing exceptions back to the caller
                    wapException = ex;
                }
            }
            else
            {
                // Pass any HTTP exceptions back to the caller
                wapException = e.Error;
            }

            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<WebAuthProxyEventArgs> tmpEvent = this.OnWebAuthRequestCompleted;
            if (tmpEvent != null)
            {
                WebAuthProxyEventArgs wapea = new WebAuthProxyEventArgs(userToken, false, wapException, false, null);
                tmpEvent(this, wapea);
            }
        }

        /// <summary>
        /// Normalizes the template by combining it w/ the serviceUri and relativePathAndQuery
        /// </summary>
        /// <param name="serviceUri">Uri of the service</param>
        /// <param name="relativePathAndQuery">Path of the URL</param>
        /// <returns>Well-formed URL string</returns>
        private string GetUriTemplate(Uri serviceUri, string relativePathAndQuery)
        {
            // Use string builder for performance gains, and ensure a sufficiently large Uri initial size is picked.
            // this will prevent excessive memory re-allocation.
            StringBuilder sb = new StringBuilder(1024);

            // URL for the PostGameResult service
            sb.AppendFormat("{0}://{1}:{2}{3}/{4}", serviceUri.Scheme, serviceUri.Host, serviceUri.Port, serviceUri.AbsolutePath, relativePathAndQuery);
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\XLiveWebHttpClientEventArgs.cs ===
﻿namespace Leet.Silverlight.XLiveWeb
{
    using System;
    using System.ComponentModel;

    public class XLiveWebHttpClientEventArgs : AsyncCompletedEventArgs
    {
        public XLiveWebHttpClientEventArgs(object responseObject, Exception exception, bool cancelled, object userToken)
            : base(exception, cancelled, userToken)
        {
            this.ResponseObject = responseObject;
        }

        public object Result
        {
            get
            {
                RaiseExceptionIfNecessary();
                return this.ResponseObject;
            }
        }

        private object ResponseObject { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\XLiveWebHttpClient.cs ===
﻿namespace Leet.Silverlight.XLiveWeb
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Net;
#if SILVERLIGHT
    using System.Net.Browser;
#endif
    using System.Runtime.Serialization;
    using System.Text;
    using Leet.Silverlight.RESTProxy; // Logging support

    // Silverlight 3 supports two HTTP stacks which offers different features
    // Check out http://www.wintellect.com/CS/blogs/jprosise/archive/2009/10/14/silverlight-3-s-new-client-networking-stack.aspx for the differences
    public enum HttpStack
    {
        PlatformDefault = 1,
        SilverlightClientStack
    }

    /// <summary>
    /// A custom wrapper around HttpWebRequest that understands DataContract serialization
    /// </summary>
    public class XLiveWebHttpClient
    {
        private const string InvalidDataContract = "The given type does not have a DataContractAttribute";
        private const int DefaultBufferCopySize = 4096;

        private static Dictionary<Type, DataContractSerializer> deserializerTable = new Dictionary<Type, DataContractSerializer>();

        // Instantiate a lockable object.
        private static object lockObject = new object();

        private WebHeaderCollection headers = null;
        private CookieContainer cookies = null;

        private XLiveWebHttpClient(Uri uri, HttpStack httpStack)
        {
            this.TargetUri = uri;
            this.HttpStack = httpStack; // only applicable for Silverlight 3 clients
        }

        public event EventHandler<XLiveWebHttpClientEventArgs> OnRequestCompleted;

        public string ContentType { get; set; }

        public string Accepted { get; set; }

        // Each instance of XLiveWebHttpClient can specify its own headers; typically this will include the STS token for authentication
        public WebHeaderCollection Headers 
        {
            get
            {
                return this.headers;
            }
            
            set
            {
#if SILVERLIGHT
                if (this.HttpStack == HttpStack.PlatformDefault)
                {
                    throw new InvalidOperationException("this type of XLiveWebHttpClient does NOT support Headers.");
                }
#endif
                this.headers = value;
            }
        }

        // Each instance of XLiveWebHttpClient can specify its own cookies; currently V1 Multiplayer uses UserID cookie for identity
        public CookieContainer Cookies
        {
            get
            {
                return this.cookies;
            }

            set
            {
#if SILVERLIGHT
                if (this.HttpStack == HttpStack.PlatformDefault)
                {
                    throw new InvalidOperationException("this type of XLiveWebHttpClient does NOT support cookie containers.");
                }
#endif
                this.cookies = value;
            }
        }

        private HttpStack HttpStack { get; set; }

        private Uri TargetUri { get; set; }

        private Type RequestObjectType { get; set; }

        private Type ResponseObjectType { get; set; }

        private bool IsRequestDeserializable { get; set; }

        private bool IsResponseDeserializable { get; set; }

#if SILVERLIGHT
        private AsyncOperation AsyncOperation { get; set; }
#endif
        public static XLiveWebHttpClient GetHttpClient(string targetUri, HttpStack httpStack)
        {
#if !SILVERLIGHT
            if (httpStack != HttpStack.PlatformDefault)
            {
                throw new InvalidOperationException("This type of HttpStack is not supported in non-Silverlight Platforms"); // no constructor taking two string parameters
            }
#endif

            return new XLiveWebHttpClient(new Uri(targetUri), httpStack);
        }

        public static XLiveWebHttpClient GetHttpClient(Uri targetUri, HttpStack httpStack)
        {
#if !SILVERLIGHT
            if (httpStack != HttpStack.PlatformDefault)
            {
                throw new InvalidOperationException("This type of HttpStack is not supported in non-Silverlight Platforms"); // no constructor taking two string parameters
            }
#endif

            return new XLiveWebHttpClient(targetUri, httpStack);
        }

        public static XLiveWebHttpClient GetHttpClient(string targetUri)
        {
            return new XLiveWebHttpClient(new Uri(targetUri), HttpStack.PlatformDefault);
        }

        public static XLiveWebHttpClient GetHttpClient(Uri targetUri)
        {
            return new XLiveWebHttpClient(targetUri, HttpStack.PlatformDefault);
        }

        public void PostDataContractAsync<RequestType, ResponseType>(object requestObject)
        {
            this.RequestObjectType = typeof(RequestType);
            this.ResponseObjectType = typeof(ResponseType);

            this.CheckRequestTypes(requestObject);
            this.CheckResponseType();

#if SILVERLIGHT
            this.AsyncOperation = AsyncOperationManager.CreateOperation(this);
#endif
            this.InternalBeginPost(requestObject);
        }
        
        public void GetDataContractAsync<ResponseType>()
        {
            this.ResponseObjectType = typeof(ResponseType);
            this.CheckResponseType();

#if SILVERLIGHT
            this.AsyncOperation = AsyncOperationManager.CreateOperation(this);
#endif
            this.InternalBeginGet();
        }

        public void PutDataContractAsync<RequestType, ResponseType>(object requestObject)
        {
            this.RequestObjectType = typeof(RequestType);
            this.ResponseObjectType = typeof(ResponseType);

            this.CheckRequestTypes(requestObject);
            this.CheckResponseType();

#if SILVERLIGHT
            this.AsyncOperation = AsyncOperationManager.CreateOperation(this);
#endif
            this.InternalBeginPut(requestObject);
        }

        public void DeleteDataContractAsync<ResponseType>(object requestObject)
        {
            this.ResponseObjectType = typeof(ResponseType);
            this.CheckResponseType();

#if SILVERLIGHT
            this.AsyncOperation = AsyncOperationManager.CreateOperation(this);
#endif
            this.InternalBeginDelete(requestObject);
        }

        private static bool HasCustomAttribute<T>(Type dataContractType) where T : Attribute
        {
            if (dataContractType.GetCustomAttributes(typeof(T), false).Length > 0)
            {
                return true;
            }

            return false;
        }

        private static DataContractSerializer TryGetDeserializer(Type serializationType)
        {
            DataContractSerializer returnSerializer = null;
            if (serializationType == null)
            {
                return null;
            }

            if (serializationType == typeof(string))
            {
                return null;
            }

            // Check if this type is previously used otherwise create one.
            if (XLiveWebHttpClient.deserializerTable.TryGetValue(serializationType, out returnSerializer) == false)
            {
                lock (XLiveWebHttpClient.lockObject)
                {
                    if (XLiveWebHttpClient.deserializerTable.TryGetValue(serializationType, out returnSerializer) == false)
                    {
                        returnSerializer = new DataContractSerializer(serializationType);
                        XLiveWebHttpClient.deserializerTable.Add(serializationType, returnSerializer);
                    }
                }
            }

            return returnSerializer;
        }

        private static HttpWebRequest GetHttpStackInitialized(XLiveWebHttpClient XLiveWebHttpClient)
        {
            HttpWebRequest hwr = null;

            if (XLiveWebHttpClient.HttpStack == HttpStack.PlatformDefault)
            {
                hwr = (HttpWebRequest)WebRequest.Create(XLiveWebHttpClient.TargetUri);
            }
#if SILVERLIGHT
            else
            {
                hwr = (HttpWebRequest)WebRequestCreator.ClientHttp.Create(XLiveWebHttpClient.TargetUri);
            }
#endif

            if (XLiveWebHttpClient.Headers != null)
            {
                hwr.Headers = XLiveWebHttpClient.Headers;
            }

            if (XLiveWebHttpClient.Cookies != null)
            {
                hwr.CookieContainer = XLiveWebHttpClient.Cookies;
            }

            // For some reason, we need to specify these header values after 
            // setting the WebHeaderCollection above since otherwise they will be overwritten 
            // Set the Accepted Type if there is anything specified.
            if (!string.IsNullOrEmpty(XLiveWebHttpClient.Accepted))
            {
                hwr.Accept = XLiveWebHttpClient.Accepted;
            }

            // Set the ContentType if there is anything specified.
            if (!string.IsNullOrEmpty(XLiveWebHttpClient.ContentType))
            {
                hwr.ContentType = XLiveWebHttpClient.ContentType;
            }

            return hwr;
        }

        private void InternalBeginPost(object dataContractObject)
        {
            this.InternalBeginHttpAction(dataContractObject, "POST");
        }

        private void InternalBeginPut(object dataContractObject)
        {
            // TODO: This call will throw because PUT and DELETE are not supported in the Browser HTTP stack
            this.InternalBeginHttpAction(dataContractObject, "PUT");
        }

        private void InternalBeginDelete(object dataContractObject)
        {
            // TODO: This call will throw because PUT and DELETE are not supported in the Browser HTTP stack
            this.InternalBeginHttpAction(dataContractObject, "DELETE");
        }

        private void InternalBeginHttpAction(object dataContractObject, string httpMethod)
        {
            HttpWebRequest hwr = GetHttpStackInitialized(this);

            hwr.Method = httpMethod;

            // Using anonymous delegates for conciseness.
            // NOTE: This section could be in another thread. Don't assume it is the UI thread.
            hwr.BeginGetRequestStream(
                delegate(IAsyncResult asyncGetRequestResult)
            {
                try
                {
                    using (Stream stream = hwr.EndGetRequestStream(asyncGetRequestResult))
                    {
                        // Making requests with a null object is valid in scenarios where you don't pass in any extra data other than the URI
                        DataContractSerializer dcs = XLiveWebHttpClient.TryGetDeserializer(this.RequestObjectType);
                        if (dcs != null)
                        {
                            dcs.WriteObject(stream, dataContractObject);
                        }
                    }

                    Logging.Dump(hwr);

                    hwr.BeginGetResponse(
                        delegate(IAsyncResult asyncGetResponseResult)
                    {
                        try
                        {
                            using (HttpWebResponse httpResponse = (HttpWebResponse)hwr.EndGetResponse(asyncGetResponseResult))
                            {
                                // Success -- exceptions 
                                this.FireRequestCompleted(null, httpResponse);
                            }
                        }
                        catch (Exception ex)
                        {
                            // Absorb this exception, as it would blow up app domain if it percolates up.
                            this.FireRequestCompleted(ex, null);
                        }
                    },
                    null);
                }
                catch (Exception ex)
                {
                    // Absorb this exception, as it would blow up app domain if it percolates up.
                    this.FireRequestCompleted(ex, null);
                }
            },
            null);
        }

        private void InternalBeginGet()
        {
            HttpWebRequest hwr = GetHttpStackInitialized(this);

            try
            {
                Logging.Dump(hwr);

                hwr.BeginGetResponse(
                    delegate(IAsyncResult asyncResultResponse)
                {
                    try
                    {
                        using (HttpWebResponse httpResponse = (HttpWebResponse)hwr.EndGetResponse(asyncResultResponse))
                        {
                            // Success 
                            this.FireRequestCompleted(null, httpResponse);
                        }
                    }
                    catch (Exception ex)
                    {
                        // Absorb this exception, as it would blow up app domain if it percolates up.
                        this.FireRequestCompleted(ex, null);
                    }
                },
                null);
            }
            catch (Exception ex)
            {
                // Absorb this exception, as it would blow up app domain if it percolates up.
                this.FireRequestCompleted(ex, null);
            }
        }

        private void FireRequestCompleted(Exception exception, HttpWebResponse httpWebResponse)
        {
            if (null == exception)
            {
                Logging.Dump(httpWebResponse);
            }
            else
            {
                Logging.Dump(exception);
            }

            object outObject = null;

            // Check if we have a non-null response
            if (httpWebResponse != null && httpWebResponse.ContentLength > 0 && exception == null)
            {
                // Read the contents from the response stream
                using (Stream httpStream = httpWebResponse.GetResponseStream())
                {
                    DataContractSerializer dcs = XLiveWebHttpClient.TryGetDeserializer(this.ResponseObjectType);
                    if (dcs != null)
                    {
                        try
                        {
                            outObject = dcs.ReadObject(httpStream);
                        }
                        catch (SerializationException ex)
                        {
                            exception = ex;
                        }
                    }
                    else
                    {
                        // Default to string, if there is no deserialization available.
                        using (StreamReader streamReader = new StreamReader(httpStream, Encoding.UTF8))
                        {
                            outObject = streamReader.ReadToEnd();
                        }
                    }
                }
            }

            // It's good practice to create a new reference to the event handler to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<XLiveWebHttpClientEventArgs> tmpEvent = this.OnRequestCompleted;
            if (tmpEvent != null)
            {
                XLiveWebHttpClientEventArgs rpea = new XLiveWebHttpClientEventArgs(outObject, exception, false, null);

#if SILVERLIGHT
                // In Silverlight we would like to complete the event on the same thread that initiated it.
                // To be precise, we would like to complete on the UI thread.
                // for calls initiated from non-UI thread, it is ok to complete on non-UI threads.
                this.AsyncOperation.PostOperationCompleted(
                    delegate(object obj)
                {
                    tmpEvent(this, rpea);
                },
                null);
#else
                // On non-Silverlight platforms it is ok to complete on any thread, 
                // typically a background thread
                tmpEvent(this, rpea);
#endif
            }
        }

        private Stream CopyStream(Stream httpResponseStream)
        {
            if (httpResponseStream == null)
            {
                throw new InvalidOperationException("Invalid Stream to Copy");
            }

            MemoryStream memStream = new MemoryStream((int)httpResponseStream.Length);

            if (httpResponseStream.Length > 0)
            {
                byte[] buffer = new byte[XLiveWebHttpClient.DefaultBufferCopySize];
                int readLen = 0;
                while ((readLen = httpResponseStream.Read(buffer, 0, XLiveWebHttpClient.DefaultBufferCopySize)) > 0)
                {
                    memStream.Write(buffer, 0, readLen);
                }
            }

            memStream.Position = 0;

            return memStream;
        }

        private void CheckRequestTypes(object requestObject)
        {
            // Make sure types are matched properly
            if (requestObject.GetType() != this.RequestObjectType)
            {
                throw new ArgumentException("requestObject type mismatch with RequestType", "dataContractObject");
            }

            // Make sure RequestObjectType has a DataContractAttribute or is string.
            if (!XLiveWebHttpClient.HasCustomAttribute<DataContractAttribute>(this.RequestObjectType))
            {
                this.IsRequestDeserializable = false;

                // Make sure the requestdatacontracttype is a string
                if (requestObject.GetType() != typeof(string))
                {
                    throw new InvalidOperationException("requestObject cannot be a non-string non-serializable object");
                }
            }
        }

        private void CheckResponseType()
        {
            // If request type is an array, remove the brackets before calling to make sure the element type is serializable
            Type responseBaseType;
            if (this.ResponseObjectType.IsArray)
            {
                char[] trimChars = new char[] { '[', ']' };
                responseBaseType = Type.GetType(this.ResponseObjectType.FullName.TrimEnd(trimChars));
            }
            else
            {
                responseBaseType = this.ResponseObjectType;
            }

            // Make sure RequestObjectType has a DataContractAttribute or is string.
            if (!XLiveWebHttpClient.HasCustomAttribute<DataContractAttribute>(responseBaseType))
            {
                this.IsResponseDeserializable = false;

                // Make sure the requestdatacontracttype is a string
                if (this.ResponseObjectType != typeof(string))
                {
                    throw new InvalidOperationException("ResponseType cannot be a non-string non-serializable type");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\GameSessionProxy\EventsCollection.cs ===
﻿// <copyright file="EventsCollection.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-06</date>
// <summary>
//  This module contains the dummy EventsCollection class.
//  WARNING: DO NOT USE THIS FILE, THIS IS MEANT ONLY FOR THE MULTIPLAYER PROXY.
// </summary>

namespace Leet.Silverlight.XLiveWeb.GameSessionProxy
{
    /// <summary>
    /// Dummy class used to fake the monitoring events collection.
    /// NOTE: DO NOT USE THIS CLASS, THIS IS MEANT ONLY FOR THE MULTIPLAYER PROXY.
    /// </summary>
    public class EventsCollection
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\GameSessionProxy\IGameSessionProxy.cs ===
namespace AsyncMultiplayer.GameSessionProxy
{
    using System;
    using AsyncMultiplayer.SessionCommon;

    public interface IGameSessionProxy
    {
        /// <summary>
        /// Callback triggered after CreateSessionAsync method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<SessionState>> OnCreateSessionCompleted;

        /// <summary>
        /// Callback triggered after JoinSessionAsync method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<SessionState>> OnJoinSessionCompleted;

        /// <summary>
        /// Callback triggered after LeaveSessionAsync method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<string>> OnRejectInvitationCompleted;

        /// <summary>
        /// Callback triggered after LeaveSessionAsync method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<string>> OnLeaveSessionCompleted;

        /// <summary>
        /// Callback triggered after ModifySessionAsync method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<string>> OnModifySessionCompleted;

        /// <summary>
        /// Callback triggered after ViewSessionAsync method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<SessionState>> OnViewSessionCompleted;

        /// <summary>
        /// Callback triggered after ViewSessionSummariesAsync method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<SessionEntry[]>> OnViewSessionSummariesCompleted;

        /// <summary>
        /// Callback triggered after GetGameState method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<FullGameState>> OnGetGameStateCompleted;

        /// <summary>
        /// Callback triggered after PutGameState method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<string>> OnPutGameStateCompleted;

        /// <summary>
        /// Callback triggered after PutGameState method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<string>> OnPostGameEndCompleted;

        /// <summary>
        /// Callback triggered after PostGameAction method is called
        /// </summary>
        event EventHandler<GameSessionProxyEventArgs<string>> OnPostGameActionCompleted;

        /// <summary>
        /// Create a new game session
        /// </summary>
        /// <param name="gameId">Title ID for the game to create a session for</param>
        /// <param name="creationData">Session metadata</param>
        void CreateSessionAsync(uint gameId, CreationData creationData);

        /// <summary>
        /// Join a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to join</param>
        /// <param name="joinData">Join information</param>
        void JoinSessionAsync(string sessionId, JoinData joinData);

        /// <summary>
        /// Reject an invitation.
        /// </summary>
        /// <param name="gameId">The game Id.</param>
        /// <param name="sessionId">The session Id. </param>
        void RejectInvitationAsync(uint gameId, string sessionId);

        /// <summary>
        /// Leave a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to leave</param>
        /// <param name="gameId">GameID of the game to leave the session for</param>
        void LeaveSessionAsync(string sessionId, uint gameId);

        /// <summary>
        /// Modify settings for a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to modify</param>
        /// <param name="gameId">GameID of the game to modify</param>
        /// <param name="modificationData">New session parameters to apply</param>
        void ModifySessionAsync(string sessionId, uint gameId, ModificationData modificationData);

        /// <summary>
        /// View a game session state
        /// </summary>
        /// <param name="sessionId">SessionID to view session information from</param>
        /// <param name="gameId">GameID of the game to view session information from</param>
        void ViewSessionAsync(string sessionId, uint gameId);

        /// <summary>
        /// View a list of active game sessions for the current User
        /// </summary>
        void ViewSessionSummariesAsync();

        /// <summary>
        /// Get the active GameState object
        /// </summary>
        void GetGameStateAsync(string sessionId, uint gameId);

        /// <summary>
        /// Update the active GameState object
        /// </summary>
        void PutGameStateAsync(string sessionId, uint gameId, ModifiableGameState modifiableGameState);

        /// <summary>
        /// Submits the end of game information
        /// </summary>
        /// <param name="sessionId">SessionID of the game session</param>
        /// <param name="gameId">GameID of the game</param>
        /// <param name="results"></param>
        void PostGameEndAsync(string sessionId, uint gameId, GameResults results);

        /// <summary>
        /// Submits a new game action for a particular game session.
        /// </summary>
        /// <param name="sessionID">SessionID for which to submit a new game action.</param>
        /// <param name="gameID">GameID for which to submit a new game action.</param>
        /// <param name="gameAction">The GameAction to be submitted.</param>
        void PostGameActionAsync(string sessionID, uint gameID, GameAction gameAction);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\WebAuthProxy\IWebAuthProxy.cs ===
namespace Leet.Silverlight.XLiveWeb.WebAuthProxy
{
    using System;

    public interface IWebAuthProxy
    {
        event EventHandler<WebAuthProxyEventArgs> OnWebAuthRequestCompleted;
        void GetPartnerTokenHTTP(uint gameId, uint gameVersion);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\GameSessionProxy\SessionServiceEvents.cs ===
﻿// <copyright file="SessionServiceEvents.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-06</date>
// <summary>
// Contains the dummy events definition for the Session Management Service
// WARNING: DO NOT USE THIS FILE, THIS IS MEANT ONLY FOR THE MULTIPLAYER PROXY.
// </summary>

namespace AsyncMultiplayer.SessionCommon
{
    using System.Diagnostics.CodeAnalysis;
    using Leet.Silverlight.XLiveWeb.GameSessionProxy;

    /// <summary>
    /// Dummy class used to fake the SessionServiceEvents class.
    /// NOTE: DO NOT USE THIS CLASS, THIS IS MEANT ONLY FOR THE MULTIPLAYER PROXY.
    /// </summary>
    [SuppressMessage("Microsoft.StyleCop.CSharp.MaintainabilityRules", "SA1401:FieldsMustBePrivate",
    Justification = "Special class to define error codes.")]
    public class SessionServiceEvents
    {
        /// <summary>
        /// Reserved seats more than total seats.
        /// </summary>
        public static int ReservedSeatsMoreThanTotalSeats = 0;

        /// <summary>
        /// Session events collection.
        /// </summary>
        private static EventsCollection sessionEventsCollection;

        /// <summary>
        /// Gets or sets events.
        /// </summary>
        public static EventsCollection Events
        {
            get { return sessionEventsCollection; }
            set { sessionEventsCollection = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\GameSessionProxy\SerializableAttribute.cs ===
﻿// <copyright file="SerializableAttribute.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Jorge Lopez de Luna</author>
// <email>jorgel@microsoft.com</email>
// <date>2009-10-15</date>
// <summary>Contains the class definition for SerializableAttribute class.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;

    /// <summary>
    /// This class is needed to be able to include service files directly.
    /// Silverlight doesn't support the [Serializable] attribute so we need to custom handle it here.
    /// </summary>
    [AttributeUsage(AttributeTargets.All)]
    internal class SerializableAttribute : System.Attribute 
    {
        /// <summary>
        ///  Initializes a new instance of the SerializableAttribute class.
        /// </summary>
        public SerializableAttribute()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\GameSessionProxy\GameSessionProxyEventArgs.cs ===
﻿// <copyright file="GameSessionProxyEventArgs.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Jorge Lopez de Luna</author>
// <email>jorgel@microsoft.com</email>
// <date>2009-10-15</date>
// <summary>Contains the class definition for GameSessionProxy class.</summary>

namespace AsyncMultiplayer.GameSessionProxy
{
    using System;
    using System.ComponentModel;
    using AsyncMultiplayer.SessionCommon;

    /// <summary>
    /// Implements the EventArgs structure, used when calling back events from GameSessionProxyClient
    /// </summary>
    /// <typeparam name="ReturnType">Return type, used to strongly-type the Return value in EventArgs</typeparam>
    public class GameSessionProxyEventArgs<ReturnType> : AsyncCompletedEventArgs
    {
        /// <summary>
        /// Internal result object
        /// </summary>
        private object result;

        /// <summary>
        /// Initializes a new instance of the GameSessionProxyEventArgs class
        /// </summary>
        /// <param name="objectResult">Result object</param>
        /// <param name="exception">Exception associated with this EventArgs structure</param>
        /// <param name="cancelled">Has this event been cancelled</param>
        /// <param name="userToken">The UserToken object</param>
        public GameSessionProxyEventArgs(object objectResult, Exception exception, bool cancelled, object userToken)
            : base(exception, cancelled, userToken)
        {
            this.result = objectResult;
        }

        /// <summary>
        /// Gets a ReturnType value
        /// </summary>
        public ReturnType Result
        {
            get
            {
                RaiseExceptionIfNecessary();
                return (ReturnType)this.result;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\GameSessionProxy\LIVEnException.cs ===
﻿// <copyright file="LIVEnException.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-06</date>
// <summary>
//  This module contains the dummy exception wrappers Live Engagement Team.
//  WARNING: DO NOT USE THIS FILE, THIS IS MEANT ONLY FOR THE MULTIPLAYER PROXY.
// </summary>

namespace Leet.Core.Utils
{
    using System;
    using System.Net;
    using Silverlight.XLiveWeb.GameSessionProxy;

    /// <summary>
    /// Dummy encapsulating class for exceptions thrown by Live Engagement Services.
    /// NOTE: DO NOT USE THIS CLASS, THIS IS MEANT ONLY FOR THE MULTIPLAYER PROXY.
    /// </summary>
    public class LIVEnException : Exception
    {
        #region Mandatory Exception constructors

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        public LIVEnException()
            : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="message">Error message.</param>
        public LIVEnException(string message) :
            this(0, HttpStatusCode.InternalServerError, message, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="message">Error message.</param>
        /// <param name="innerException">Inner exception.</param>
        public LIVEnException(string message, Exception innerException) :
            base(message, innerException)
        {
        }

        #endregion

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="events">Events collection.</param>
        /// <param name="errorCode">Error code.</param>
        /// <param name="statusCode">HTTP Status code.</param>
        /// <param name="innerException">Inner exception.</param>
        /// <param name="publishEvent">Whether to publish event log or not.</param>
        /// <param name="arguments">Insertions strings for the message in message resource.</param>
        public LIVEnException(
            EventsCollection events,
            int errorCode,
            HttpStatusCode statusCode,
            Exception innerException,
            bool publishEvent,
            params string[] arguments) :
            this(
                0,
                statusCode,
                String.Empty,
                innerException)
        {
            // Dummy method
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// This is the most basic version of the constructor which
        /// only initializes all values. After other constructors
        /// formats the message, this constructor gets called to 
        /// initialize all member fields.
        /// </summary>
        /// <param name="errorCode">Error Code.</param>
        /// <param name="httpStatusCode">HTTP Status code.</param>
        /// <param name="message">Error message.</param>
        /// <param name="innerException">Inner exception.</param>
        public LIVEnException(
            int errorCode,
            HttpStatusCode httpStatusCode,
            string message,
            Exception innerException)
            : base(message, innerException)
        {
            // Dummy method
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Silverlight.XLiveWeb")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\WebAuthProxy\WebAuthProxy.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.WebAuthProxy
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Text;
    using System.Xml.Linq;

    /// <summary>
    /// WebAuthProxy is designed to convert the HttpOnly CompactTicket provided during
    /// signin process into a form that can be used by other Silverlight plugins that
    /// access ActiveAuth-gated LiveN services
    /// </summary>
    public class WebAuthProxy : IWebAuthProxy
    {
        private const string InvalidUrlExceptionMessage = "The Uri provided is in an invalid format";
        private const string StsServiceRelativePathAndQuery = "token?gameID={gameId}&gameversion={gameVersion}";

        /// <summary>
        /// Initializes a new instance of the WebAuthProxy class
        /// </summary>
        /// <param name="uriStsService">The Uri for the STS Service</param>
        public WebAuthProxy(Uri uriStsService)
        {
            if (!uriStsService.IsAbsoluteUri)
            {
                throw new ArgumentException(WebAuthProxy.InvalidUrlExceptionMessage, "uriStsService");
            }

            this.StsService = uriStsService;
        }

        // Callers will have to subscribe to this event to capture the output
        public event EventHandler<WebAuthProxyEventArgs> OnWebAuthRequestCompleted;

        private Uri StsService { get; set; }

        public void GetPartnerTokenHTTP(uint gameId, uint gameVersion)
        {
            // URL for the STS Token service
            string fullUri = this.GetUriTemplate(this.StsService, WebAuthProxy.StsServiceRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{gameId}", gameId.ToString());
            fullUri = fullUri.Replace("{gameVersion}", gameVersion.ToString());
            Uri serviceUri = new Uri(fullUri);

#if WINDOWS
            WebClient browserStackCall = new WebClient();
#else
            WebClient browserStackCall = new WebClient { AllowReadStreamBuffering = true };
#endif
            browserStackCall.DownloadStringCompleted += this.OnDownloadPartnerTokenCompleted;
            browserStackCall.DownloadStringAsync(serviceUri);
        }

        private void OnDownloadPartnerTokenCompleted(object sender, DownloadStringCompletedEventArgs e)
        {
            string partnerToken = null;
            Exception wapException = null;

            if (e.Error == null)
            {
                try
                {
                    // Extract the partner token XML field - we expect at least 1 partner token node but
                    // if we support more claims or priviledges we can support more in the web header
                    XElement xmlRoot = XElement.Parse(e.Result);
                    IEnumerable<XElement> partnerTokens = (from item in xmlRoot.Elements() where item.Name.LocalName == "Partner" select item);
                    if (partnerTokens.Count() > 0)
                    {
                        partnerToken = partnerTokens.First<XElement>().Value;
                    }
                    else
                    {
                        wapException = new ArgumentException("Incorrect number of partner tokens");
                    }
                }
                catch (Exception ex)
                {
                    // Pass any parsing exceptions back to the caller
                    wapException = ex;
                }
            }
            else
            {
                // Pass any HTTP exceptions back to the caller
                wapException = e.Error;
            }

            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<WebAuthProxyEventArgs> tmpEvent = this.OnWebAuthRequestCompleted;
            if (tmpEvent != null)
            {
                WebAuthProxyEventArgs wapea = new WebAuthProxyEventArgs(partnerToken, true, wapException, false, null);
                tmpEvent(this, wapea);
            }
        }

        /// <summary>
        /// Normalizes the template by combining it w/ the serviceUri and relativePathAndQuery
        /// </summary>
        /// <param name="serviceUri">Uri of the service</param>
        /// <param name="relativePathAndQuery">Path of the URL</param>
        /// <returns>Well-formed URL string</returns>
        private string GetUriTemplate(Uri serviceUri, string relativePathAndQuery)
        {
            // Use string builder for performance gains, and ensure a sufficiently large Uri initial size is picked.
            // this will prevent excessive memory re-allocation.
            StringBuilder sb = new StringBuilder(1024);

            // URL for the PostGameResult service
            sb.AppendFormat("{0}://{1}:{2}{3}/{4}", serviceUri.Scheme, serviceUri.Host, serviceUri.Port, serviceUri.AbsolutePath, relativePathAndQuery);
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\App.xaml.cs ===
﻿using System;
using System.Windows;
using Microsoft.Silverlight.Testing;

namespace Leet.Silverlight.XLiveWeb.Test
{
    public partial class App : Application
    {

        public App()
        {
            this.Startup += this.Application_Startup;
            this.Exit += this.Application_Exit;
            this.UnhandledException += this.Application_UnhandledException;

            InitializeComponent();
        }

        private void Application_Startup(object sender, StartupEventArgs e)
        {
            RootVisual = UnitTestSystem.CreateTestPage();
        }

        private void Application_Exit(object sender, EventArgs e)
        {

        }
        private void Application_UnhandledException(object sender, ApplicationUnhandledExceptionEventArgs e)
        {
            // If the app is running outside of the debugger then report the exception using
            // the browser's exception mechanism. On IE this will display it a yellow alert 
            // icon in the status bar and Firefox will display a script error.
            if (!System.Diagnostics.Debugger.IsAttached)
            {

                // NOTE: This will allow the application to continue running after an exception has been thrown
                // but not handled. 
                // For production applications this error handling should be replaced with something that will 
                // report the error to the website and stop the application.
                e.Handled = true;
                Deployment.Current.Dispatcher.BeginInvoke(delegate { ReportErrorToDOM(e); });
            }
        }
        private void ReportErrorToDOM(ApplicationUnhandledExceptionEventArgs e)
        {
            try
            {
                string errorMsg = e.ExceptionObject.Message + e.ExceptionObject.StackTrace;
                errorMsg = errorMsg.Replace('"', '\'').Replace("\r\n", @"\n");

                System.Windows.Browser.HtmlPage.Window.Eval("throw new Error(\"Unhandled Error in Silverlight Application " + errorMsg + "\");");
            }
            catch (Exception)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\WebAuthProxy\WebAuthProxyEventArgs.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.WebAuthProxy
{
    using System;
    using System.ComponentModel;
    using System.Net;
    using System.Threading;
    using Leet.Core.Utils;

    public class WebAuthProxyEventArgs : AsyncCompletedEventArgs
    {
        // TODO: The platform ID for the web platform is hardcoded for now
        private const uint PlatformID = 6; // WebGames
        private const string SamlTokenPreamble = "XBL1.0 x=";

        public WebAuthProxyEventArgs(string authToken, bool isPartnerToken, Exception exception, bool cancelled, object userToken)
            : base(exception, cancelled, userToken)
        {
            if (!String.IsNullOrEmpty(authToken))
            {
                this.WebHeaders = new WebHeaderCollection();
                this.WebHeaders[CustomWebHeaderNames.XLocale] = Thread.CurrentThread.CurrentUICulture.ToString();
                this.WebHeaders[CustomWebHeaderNames.XPlatformType] = PlatformID.ToString();

                // TODO: Move XBL1.0 and WLID1.0 to the Leet.Core.Utils webheaders namespace
                if (isPartnerToken)
                {
                    this.WebHeaders[CustomWebHeaderNames.XPartnerAuthorization] = SamlTokenPreamble + authToken;
                }
                else
                {
                    this.WebHeaders[CustomWebHeaderNames.XAuthorization] = SamlTokenPreamble + authToken;
                }
            }
        }

        public WebHeaderCollection Result
        {
            get
            {
                RaiseExceptionIfNecessary();
                return this.WebHeaders;
            }
        }

        private WebHeaderCollection WebHeaders { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb\GameSessionProxy\GameSessionProxy.cs ===
﻿// <copyright file="GameSessionProxyClient.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Jorge Lopez de Luna</author>
// <email>jorgel@microsoft.com</email>
// <date>2009-10-15</date>
// <summary>Contains the class definition for GameSessionProxy class.</summary>

namespace AsyncMultiplayer.GameSessionProxy
{
    using System;
    using System.Net;
    using Leet.Silverlight.XLiveWeb;
    using Leet.Silverlight.RESTProxy; // UtilityFunctions and Logging support
    using SessionCommon;

    /// <summary>
    /// Client wrapper for the Game Session Service
    /// </summary>
    public class GameSessionProxy : IGameSessionProxy
    {
        /// <summary>
        /// Invalid URI format message
        /// </summary>
        private const string InvalidUrlExceptionMessage = "The Uri provided is in an invalid format";

        /// <summary>
        /// Null or empty string error message
        /// </summary>
        private const string InvalidStringExceptionMessage = "The provided string is either null or empty";

        /// <summary>
        /// Xml content type, used for return strings
        /// </summary>
        private const string XmlContentType = "application/xml";

        /// <summary>
        /// Query string for CreateSession: this is called with HTTP POST
        /// </summary>
        private const string CreateSessionRelativePathAndQuery = "game/{gameID}";

        /// <summary>
        /// Query string for JoinSession: this is called with HTTP POST
        /// </summary>
        private const string JoinSessionRelativePathAndQuery = "session/{sessionID}";

        /// <summary>
        /// The query string for reject invite. This is called with HTTP DELETE. 
        /// </summary>
        private const string RejectInvitationRelativePath = "invite/{sessionID}/{gameID}"; 

        /// <summary>
        /// Query string for LeaveSession: this is called with HTTP DELETE
        /// </summary>
        private const string LeaveSessionRelativePathAndQuery = "session/{sessionID}/{gameID}";

        /// <summary>
        /// Query string for ModifySession: this is called with HTTP PUT
        /// </summary>
        private const string ModifySessionRelativePathAndQuery = "session/{sessionID}/{gameID}";

        /// <summary>
        /// Query string for ViewSession: this is called with HTTP GET
        /// </summary>
        private const string ViewSessionRelativePathAndQuery = "session/{sessionID}/{gameID}";

        /// <summary>
        /// Query string for ViewSessionSummaries: this is called with HTTP GET
        /// </summary>
        private const string ViewSessionSummariesRelativePathAndQuery = "game";

        /// <summary>
        /// Query string for GetGameState: this is called with HTTP GET
        /// </summary>
        private const string GetGameStateRelativePathAndQuery = "GameState/{sessionID}/{gameID}";

        /// <summary>
        /// Query string for PutGameState: this is called with HTTP PUT
        /// </summary>
        private const string PutGameStateRelativePathAndQuery = "GameState/{sessionID}/{gameID}";
        
        /// <summary>
        /// Query string for PostGameAction: this is called with HTTP POST
        /// </summary>
        private const string PostGameActionRelativePathAndQuery = "GameAction/{sessionID}/{gameID}";

        /// <summary>
        /// The filename for GameState service, to be used when building the URI to do actions on the service
        /// </summary>
        private const string GameStateServiceFilename = "GameState.svc";

        /// <summary>
        /// The default HttpStack type to use.  This is set at compile time based on the desired proxy type
        /// </summary>
        private const HttpStack StackType =
#if SILVERLIGHT
            HttpStack.SilverlightClientStack;
#else // !SILVERLIGHT
            HttpStack.PlatformDefault;
#endif

        /// <summary>
        /// Initializes a new instance of the GameSessionProxy class to talk to the specified Service URI
        /// </summary>
        /// <param name="uriGameSessionService">Game Session URI </param>
        public GameSessionProxy(Uri uriGameSessionService, WebHeaderCollection colWebHeaders, CookieContainer containerCookies)
        {
            if (uriGameSessionService == null)
            {
                throw new ArgumentNullException("uriGameSessionService");
            }

            if (!uriGameSessionService.IsAbsoluteUri)
            {
                throw new ArgumentException(GameSessionProxy.InvalidUrlExceptionMessage, "uriGameSessionService");
            }

            this.GameSessionUri = uriGameSessionService;
            this.WebHeaders = colWebHeaders;
            this.Cookies = containerCookies;

            string gameStateSvc = UtilityFunctions.ReplaceServiceNameInURI(
                uriGameSessionService,
                GameStateServiceFilename);
            this.GameStateUri = new Uri(gameStateSvc);
        }

        /// <summary>
        /// Prevents a default instance of the GameSessionProxy class from being created.
        /// This class requires a Service URI and User ID to work so there's no way of instantiating it without those parameters.
        /// </summary>
        private GameSessionProxy()
        {
        }

        /// <summary>
        /// Callback triggered after CreateSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<SessionState>> OnCreateSessionCompleted;

        /// <summary>
        /// Callback triggered after JoinSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<SessionState>> OnJoinSessionCompleted;

        /// <summary>
        /// Callback triggered after LeaveSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnRejectInvitationCompleted;

        /// <summary>
        /// Callback triggered after LeaveSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnLeaveSessionCompleted;

        /// <summary>
        /// Callback triggered after ModifySessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnModifySessionCompleted;

        /// <summary>
        /// Callback triggered after ViewSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<SessionState>> OnViewSessionCompleted;

        /// <summary>
        /// Callback triggered after ViewSessionSummariesAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<SessionEntry[]>> OnViewSessionSummariesCompleted;

        /// <summary>
        /// Callback triggered after GetGameState method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<FullGameState>> OnGetGameStateCompleted;

        /// <summary>
        /// Callback triggered after PutGameState method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnPutGameStateCompleted;

        /// <summary>
        /// Callback triggered after PutGameState method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnPostGameEndCompleted;

        /// <summary>
        /// Callback triggered after PostGameAction method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnPostGameActionCompleted;

        /// <summary>
        /// Gets or sets the main URI to access the Game Session service, e.g. http://localhost:8081/Sessions.svc
        /// </summary>
        private Uri GameSessionUri { get; set; }
        
        /// <summary>
        /// Gets or sets the main URI to access the Game State service, e.g. http://localhost:8081/GameState.svc
        /// </summary>
        private Uri GameStateUri { get; set; }

        /// <summary>
        /// The partner token for game session and game state services will be included as a header
        /// </summary>
        private WebHeaderCollection WebHeaders { get; set; }

        private CookieContainer Cookies { get; set; }

        /// <summary>
        /// Create a new game session
        /// </summary>
        /// <param name="gameId">Title ID for the game to create a session for</param>
        /// <param name="creationData">Session metadata</param>
        public void CreateSessionAsync(uint gameId, CreationData creationData)
        {
            if (creationData == null)
            {
                throw new ArgumentNullException("creationData");
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameSessionUri, GameSessionProxy.CreateSessionRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.ContentType = GameSessionProxy.XmlContentType;
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnCreateSessionCompleted);
            XLiveWebHttpClient.PostDataContractAsync<CreationData, SessionState>(creationData);
        }

        /// <summary>
        /// Join a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to join</param>
        /// <param name="joinData">Join information</param>
        public void JoinSessionAsync(string sessionId, JoinData joinData)
        {
            if (String.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(GameSessionProxy.InvalidStringExceptionMessage, "sessionId");
            }

            if (joinData == null)
            {
                throw new ArgumentNullException("joinData");
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameSessionUri, GameSessionProxy.JoinSessionRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.ContentType = GameSessionProxy.XmlContentType;
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnJoinSessionCompleted);
            XLiveWebHttpClient.PostDataContractAsync<JoinData, SessionState>(joinData);
        }

        /// <summary>
        /// Reject an invitation.
        /// </summary>
        /// <param name="gameId">The game Id.</param>
        /// <param name="sessionId">The session Id. </param>
        public void RejectInvitationAsync(uint gameId, string sessionId)
        {
            if (String.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(GameSessionProxy.InvalidStringExceptionMessage, "sessionId");
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameSessionUri, GameSessionProxy.RejectInvitationRelativePath);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.ContentType = GameSessionProxy.XmlContentType;
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnRejectInvitationCompleted);
            XLiveWebHttpClient.DeleteDataContractAsync<string>(null);
        }

        /// <summary>
        /// Leave a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to leave</param>
        /// <param name="gameId">GameID of the game to leave the session for</param>
        public void LeaveSessionAsync(string sessionId, uint gameId)
        {
            if (String.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(GameSessionProxy.InvalidStringExceptionMessage, "sessionId"); 
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameSessionUri, GameSessionProxy.LeaveSessionRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.ContentType = GameSessionProxy.XmlContentType;
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnLeaveSessionCompleted);
            XLiveWebHttpClient.DeleteDataContractAsync<string>(null);
        }

        /// <summary>
        /// Modify settings for a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to modify</param>
        /// <param name="gameId">GameID of the game to modify</param>
        /// <param name="modificationData">New session parameters to apply</param>
        public void ModifySessionAsync(string sessionId, uint gameId, ModificationData modificationData)
        {
            if (String.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(GameSessionProxy.InvalidStringExceptionMessage, "sessionId");
            }

            if (modificationData == null)
            {
                throw new ArgumentNullException("modificationData");
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameSessionUri, GameSessionProxy.ModifySessionRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.ContentType = GameSessionProxy.XmlContentType;
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnModifySessionCompleted);
            XLiveWebHttpClient.PutDataContractAsync<ModificationData, string>(modificationData);
        }

        /// <summary>
        /// View a game session state
        /// </summary>
        /// <param name="sessionId">SessionID to view session information from</param>
        /// <param name="gameId">GameID of the game to view session information from</param>
        public void ViewSessionAsync(string sessionId, uint gameId)
        {
            if (String.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(GameSessionProxy.InvalidStringExceptionMessage, "sessionId");
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameSessionUri, GameSessionProxy.ViewSessionRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());
            
            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnViewSessionCompleted);
            XLiveWebHttpClient.GetDataContractAsync<SessionState>();
        }

        /// <summary>
        /// View a list of active game sessions for the current User
        /// </summary>
        public void ViewSessionSummariesAsync()
        {
            string fullUri = UtilityFunctions.GetUriTemplate(this.GameSessionUri, GameSessionProxy.ViewSessionSummariesRelativePathAndQuery);

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnViewSessionSummariesCompleted);
            XLiveWebHttpClient.GetDataContractAsync<SessionEntry[]>();
        }

        /// <summary>
        /// Get the active GameState object
        /// </summary>
        public void GetGameStateAsync(string sessionId, uint gameId)
        {
            if (String.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(GameSessionProxy.InvalidStringExceptionMessage, "sessionId");
            }
            
            string fullUri = UtilityFunctions.GetUriTemplate(this.GameStateUri, GameSessionProxy.GetGameStateRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnGetGameStateCompleted);
            XLiveWebHttpClient.GetDataContractAsync<FullGameState>();
        }

        /// <summary>
        /// Update the active GameState object
        /// </summary>
        public void PutGameStateAsync(string sessionId, uint gameId, ModifiableGameState modifiableGameState)
        {
            if (String.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(GameSessionProxy.InvalidStringExceptionMessage, "sessionId");
            }

            if (modifiableGameState == null)
            {
                throw new ArgumentNullException("modificationData");
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameStateUri, GameSessionProxy.GetGameStateRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.ContentType = GameSessionProxy.XmlContentType;
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnPutGameStateCompleted);
            XLiveWebHttpClient.PutDataContractAsync<ModifiableGameState, string>(modifiableGameState);
        }

        public void PostGameEndAsync(string sessionId, uint gameId, GameResults results)
        {
            if (results == null)
            {
                throw new ArgumentException("results");
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameStateUri, GameSessionProxy.GetGameStateRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.ContentType = GameSessionProxy.XmlContentType;
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnPostGameEndCompleted);
            XLiveWebHttpClient.PostDataContractAsync<GameResults, string>(results);
        }

        /// <summary>
        /// Do a POST GameAction to the Game State service. This is used to submit a user nudge when gameAction.ActionType = UserNudge
        /// </summary>
        /// <param name="sessionId">Session that will receive the GameAction command</param>
        /// <param name="gameId">GameID that will receive the GameAction command</param>
        /// <param name="gameAction">GameAction structure with info on what action to submit</param>
        public void PostGameActionAsync(string sessionId, uint gameId, GameAction gameAction)
        {
            if (String.IsNullOrEmpty(sessionId))
            {
                throw new ArgumentException(GameSessionProxy.InvalidStringExceptionMessage, "sessionId");
            }

            if (gameAction == null)
            {
                throw new ArgumentException("gameAction");
            }

            string fullUri = UtilityFunctions.GetUriTemplate(this.GameStateUri, GameSessionProxy.PostGameActionRelativePathAndQuery);

            // Fill in the data for the path attributes
            fullUri = fullUri.Replace("{sessionID}", sessionId.ToString());
            fullUri = fullUri.Replace("{gameID}", gameId.ToString());

            // Set up XLiveWebHttpClient object
            XLiveWebHttpClient XLiveWebHttpClient = XLiveWebHttpClient.GetHttpClient(fullUri, StackType);
            XLiveWebHttpClient.ContentType = GameSessionProxy.XmlContentType;
            XLiveWebHttpClient.Headers = this.WebHeaders;
            XLiveWebHttpClient.Cookies = this.Cookies;

            XLiveWebHttpClient.OnRequestCompleted += new EventHandler<XLiveWebHttpClientEventArgs>(this.HttpClient_OnPostGameActionCompleted);
            XLiveWebHttpClient.PostDataContractAsync<GameAction, string>(gameAction);
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnCreateSessionCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<SessionState>> tmpEvent = this.OnCreateSessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<SessionState> gsea = new GameSessionProxyEventArgs<SessionState>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnJoinSessionCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<SessionState>> tmpEvent = this.OnJoinSessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<SessionState> gsea = new GameSessionProxyEventArgs<SessionState>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnRejectInvitationCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnRejectInvitationCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnLeaveSessionCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnLeaveSessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnModifySessionCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnModifySessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnViewSessionCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<SessionState>> tmpEvent = this.OnViewSessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<SessionState> gsea = new GameSessionProxyEventArgs<SessionState>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnViewSessionSummariesCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<SessionEntry[]>> tmpEvent = this.OnViewSessionSummariesCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<SessionEntry[]> gsea = new GameSessionProxyEventArgs<SessionEntry[]>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnGetGameStateCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<FullGameState>> tmpEvent = this.OnGetGameStateCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<FullGameState> gsea = new GameSessionProxyEventArgs<FullGameState>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnPutGameStateCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnPutGameStateCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnPostGameEndCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnPostGameEndCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Extract the response from the HttpWebResponse object and trigger the appropriate event handler
        /// </summary>
        /// <param name="exception">Exception to pass through to handler</param>
        /// <param name="responseObject">HttpWebResponse object to pass through to handler</param>
        private void FireOnPostGameActionCompleted(Exception exception, object responseObject)
        {
            // It's good practice to create a new reference to the event handler
            // to avoid race conditions between multiple threads subscribing to the same event
            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnPostGameActionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Connect the OnCreateSessionCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnCreateSessionCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnCreateSessionCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnJoinSessionCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnJoinSessionCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnJoinSessionCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnRejectInvitation event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnRejectInvitationCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnRejectInvitationCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnLeaveSessionCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnLeaveSessionCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnLeaveSessionCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnModifySessionCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnModifySessionCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnModifySessionCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnViewSessionCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event ender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnViewSessionCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnViewSessionCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }
        
        /// <summary>
        /// Connect the OnViewSessionSummariesCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnViewSessionSummariesCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnViewSessionSummariesCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnGetGameStateCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnGetGameStateCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnGetGameStateCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnPutGameStateCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnPutGameStateCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnPutGameStateCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnPostGameEndCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnPostGameEndCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnPostGameEndCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }

        /// <summary>
        /// Connect the OnPostGameActionCompleted event with its matching Fire method
        /// </summary>
        /// <param name="sender">Event sender</param>
        /// <param name="e">XLiveWebHttpClientEventArgs object</param>
        private void HttpClient_OnPostGameActionCompleted(object sender, XLiveWebHttpClientEventArgs e)
        {
            this.FireOnPostGameActionCompleted(e.Error, (e.Error == null) ? e.Result : null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\ParsableLogProvider.cs ===
﻿// <copyright file="ParsableLogProvider.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Filip Skakun</author>
// <email>filip.skakun@gmail.com</email>
// <date>2010-02-18</date>
// <summary>Contains the class definition for ParsableLogProvider class.</summary>
namespace Leet.Silverlight.XLiveWeb.Test
{
    using System;
    using System.Text;
    using System.Windows.Browser;
    using System.Xml.Linq;
    using Microsoft.Silverlight.Testing.Harness;
    using Microsoft.Silverlight.Testing.UnitTesting.Harness;

    /// <summary>
    /// Log provider for Silverlight Unit Test framework that produces concise XML test result reports
    /// for use when running the SL tests from within KAF tests.
    /// </summary>
    public class ParsableLogProvider : LogProvider
    {
        /// <summary>
        /// The XML document object for building the report
        /// </summary>
        private XDocument doc;

        /// <summary>
        /// The root element of the report
        /// </summary>
        private XElement root;

        /// <summary>
        /// The last test class indicated by log messages processed so far
        /// </summary>
        private string lastClass;

        /// <summary>
        /// Initializes a new instance of the <see cref="ParsableLogProvider"/> class.
        /// </summary>
        public ParsableLogProvider()
            : base()
        {
            this.doc = new XDocument(
                this.root = new XElement("TestResults"));
        }

        /// <summary>
        /// Processes the specified log message.
        /// Happens once for TestGranularity of Harness, then twice for each of TestGroup (assembly), Test (class) and TestScenario (method)
        /// </summary>
        /// <param name="logMessage">The log message.</param>
        public override void Process(LogMessage logMessage)
        {
            base.Process(logMessage);

            // Extract interesting text from the message and trace it on the page
            string messageString = this.ExtractText(logMessage);
            HtmlPage.Window.Invoke("ReportTestResult", messageString);

            // Check if the message contains the current test class name and update lastClass with the result.
            if (logMessage.Decorators.ContainsKey(UnitTestLogDecorator.TestClassMetadata))
            {
                this.lastClass = logMessage.Decorators[UnitTestLogDecorator.TestClassMetadata].ToString();
            }

            if (logMessage.MessageType == LogMessageType.TestExecution &&
                logMessage.Decorators.ContainsKey(UnitTestLogDecorator.IgnoreMessage))
            {
                // Report ignored test methods as ignored
                DateTime now = DateTime.Now;
                XElement result =
                    new XElement(
                        "TestResult",
                        new XAttribute("Class", this.lastClass),
                        new XAttribute("Method", logMessage.Decorators[LogDecorator.NameProperty].ToString()),
                        new XAttribute("Started", now.ToString()),
                        new XAttribute("Finished", now.ToString()),
                        new XAttribute("Result", "Ignored"));
                this.root.Add(result);
            }
            else if (logMessage.MessageType == LogMessageType.TestResult)
            {
                // Report test method result
                ScenarioResult sr = (ScenarioResult)logMessage.Decorators[UnitTestLogDecorator.ScenarioResult];
                XElement result =
                    new XElement(
                        "TestResult",
                        new XAttribute("Class", this.lastClass),
                        new XAttribute("Method", logMessage.Decorators[UnitTestLogDecorator.TestMethodMetadata].ToString()),
                        new XAttribute("Started", sr.Started.ToString()),
                        new XAttribute("Finished", sr.Finished.ToString()),
                        new XAttribute("Result", sr.Result.ToString()));
                if (sr.Exception != null)
                {
                    result.Add(
                        new XText(sr.Exception.ToString()));
                }

                this.root.Add(result);
            }
        }

        /// <summary>
        /// Returns the string with the xml document with test run results.
        /// </summary>
        /// <returns>
        /// The string with the xml document with test run results.
        /// </returns>
        public override string ToString()
        {
            return this.doc.ToString();
        }

        /// <summary>
        /// Extracts the text from the log message for tracing purposes.
        /// </summary>
        /// <param name="logMessage">The log message.</param>
        /// <returns>The message as a string</returns>
        private string ExtractText(LogMessage logMessage)
        {
            StringBuilder msg = new StringBuilder();

            msg.AppendLine("MessageType: " + logMessage.MessageType.ToString());
            msg.AppendLine("Message: " + logMessage.Message);

            foreach (var d in logMessage.Decorators.Keys)
            {
                msg.AppendLine(" - " + d + ": " + logMessage.Decorators[d]);
            }

            return msg.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\TestController.xaml.cs ===
﻿// <copyright file="TestController.xaml.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Jiunwei Chen</author>
// <email>jiunchen@microsoft.com</email>
// <date>2010-02-18</date>
// <summary>Contains the class definition for TestController class.</summary>
namespace Leet.Silverlight.XLiveWeb.Test
{
    using System;
    using System.Windows;
    using System.Windows.Browser;
    using System.Windows.Controls;
    using System.Windows.Media;
    using Leet.Silverlight.XLiveWeb.Test.UI;
    using Microsoft.Silverlight.Testing;
    using Microsoft.Silverlight.Testing.Harness;

    /// <summary>
    /// Controls the Silverlight tests to run
    /// </summary>
    public partial class TestController : UserControl
    {
        /// <summary>
        /// The SL UT Framework log provider for reporting test results in a concise easily parsable form
        /// for interpreting with KAF tests.
        /// </summary>
        private ParsableLogProvider p;

        /// <summary>
        /// Tag expressions are used to specify which tests to run by the tag set for that test, the test name itself is also an implicit tag
        /// </summary>
        private string tagExpression;

        /// <summary>
        /// Initializes a new instance of the <see cref="TestController"/> class.
        /// </summary>
        public TestController()
        {
            InitializeComponent();

            HtmlPage.RegisterScriptableObject("TestController", this);

            this.Loaded += new RoutedEventHandler(this.TestController_Loaded);
        }

        /// <summary>
        /// Gets the control currently under test
        /// </summary>
        /// <value>The test control.</value>
        public UIElement TestControl
        {
            get
            {
                return ControlUnderTest.Children[0];
            }
        }

        public void SetTestControl(UIElement controlToTest)
        {
            SetTestControl(controlToTest, 1.0);
        }

        /// <summary>
        /// Sets the control to test
        /// </summary>
        /// <param name="controlToTest">the UIElement representing the control to test</param>
        public void SetTestControl(UIElement controlToTest, double scale)
        {
            ControlUnderTest.Children.Clear();
            ControlUnderTest.Children.Add(controlToTest);
        }

        private void SetScale(ScaleTransform scaleTransform, double scale)
        {
            scaleTransform.ScaleX = scale;
            scaleTransform.ScaleY = scale;
        }

        /// <summary>
        /// Runs the tests
        /// </summary>
        /// <param name="testClassesToRun">The test classes to run</param>
        /// <param name="testClassesToRun">The tag expression to use</param>
        public void StartTest(string testClassesToRun, string tagExpression)
        {
            // Reset the test results section and set the other labels appropriately
            this.UpdatePageText("testClassSetting", testClassesToRun);
            this.UpdatePageText("txtStatus", "Running");
            this.UpdatePageText("txtTestResult", "--");
            this.UpdatePageText("txtTestCount", "--");
            this.UpdatePageText("txtPassedTests", "--");
            this.UpdatePageText("txtFailedTests", "--");

            // Create default settings to work with then add in the test we want to run, as well as the eventing
            UnitTestSettings settings = UnitTestSystem.CreateDefaultSettings();
            settings.TestHarness.TestHarnessCompleted += new EventHandler<TestHarnessCompletedEventArgs>(this.OnTestHarnessCompleted);
            if (testClassesToRun != "all")
            {
                string[] list = testClassesToRun.Split(',');
                foreach (var className in list)
                {
                    settings.TestClassesToRun.Add(className);
                }
            }

            settings.TagExpression = tagExpression;

            this.p = new ParsableLogProvider();
            settings.LogProviders.Clear();
            settings.LogProviders.Add(new WebpageHeaderLogProvider("Silverlight Unit Test Framework"));
            settings.LogProviders.Add(new UnitTestWebpageLog());
            settings.LogProviders.Add(this.p);

            

            // Run the test!
            UnitTestSystem.CreateTestPage(settings);
        }

        /// <summary>
        /// Loads the Friend Picker and runs the appropriate test
        /// </summary>
        /// <param name="sender">the sender</param>
        /// <param name="e">any event args</param>
        private void TestController_Loaded(object sender, RoutedEventArgs e)
        {
            this.RunTestsOrQueryStringCustomCommands();
        }

        /// <summary>
        /// Runs the tests via the name of the test class and test method name or attribute
        /// </summary>
        /// <param name="className">the name of the test class to run</param>
        /// <param name="testName">the name of the test method or attribute to run</param>
        [ScriptableMember]
        public void RunTests(string className, string testName)
        {
            this.StartTest(className, testName);
        }

        /// <summary>
        /// Runs the tests or query string custom commands.
        /// </summary>
        private void RunTestsOrQueryStringCustomCommands()
        {
            // Run tests if the URL is in the right form (it makes the test page view include these parameters too)
            // Eg. http://games.dev.xbox.com/TestTools/SilverlightTestPage/TestGameSessionProxyClient/true
            HtmlElement autoRunSetting = HtmlPage.Document.GetElementById("autoRunSetting");
            HtmlElement testClassSetting = HtmlPage.Document.GetElementById("testClassSetting");
            HtmlElement tagExpressionSetting = HtmlPage.Document.GetElementById("tagExpressionSetting");

            bool autoRun = Boolean.Parse(autoRunSetting.GetProperty("innerHTML").ToString());
            string testClasses = testClassSetting.GetProperty("innerHTML").ToString();
            tagExpression = tagExpressionSetting.GetProperty("innerHTML").ToString();

            if (!string.IsNullOrEmpty(testClasses) && autoRun)
            {
                this.StartTest(testClasses, tagExpression);
            }
        }

        /// <summary>
        /// Triggered by the test harness when it is done
        /// </summary>
        /// <param name="sender">object sender</param>
        /// <param name="e">event args that contain the results</param>
        private void OnTestHarnessCompleted(object sender, TestHarnessCompletedEventArgs e)
        {
            if (e != null)
            {
                int totalTests = e.State.TotalScenarios;
                int failedTests = e.State.Failures;
                int passedTests = totalTests - failedTests;

                this.UpdatePageText("txtStatus", "Completed");

                if (e.State.Failed)
                {
                    this.UpdatePageText("txtTestResult", "FAILED", "Red");
                }
                else
                {
                    this.UpdatePageText("txtTestResult", "PASSED", "Green");
                }

                this.UpdatePageText("txtTestCount", totalTests.ToString());
                this.UpdatePageText("txtPassedTests", passedTests.ToString());
                this.UpdatePageText("txtFailedTests", failedTests.ToString());
            }
            else
            {
                this.UpdatePageText("txtStatus", "Error: Test harness returned null results");
            }

            HtmlPage.Window.Invoke("SetTestResult", this.p.ToString());
        }

        /// <summary>
        /// Updates the text in the page given the id of html element.
        /// </summary>
        /// <param name="elementName">Name of the element.</param>
        /// <param name="value">The value.</param>
        private void UpdatePageText(string elementName, string value)
        {
            HtmlElement element = HtmlPage.Document.GetElementById(elementName);

            element.SetProperty("innerHtml", value);
        }

        /// <summary>
        /// Updates the text in the page given the id of html element.
        /// Also sets the text color.
        /// </summary>
        /// <param name="elementName">Name of the element.</param>
        /// <param name="value">The value.</param>
        /// <param name="textColor">Color of the text.</param>
        private void UpdatePageText(string elementName, string value, string textColor)
        {
            HtmlElement element = HtmlPage.Document.GetElementById(elementName);

            element.SetProperty("innerHtml", value);
            element.SetStyleAttribute("color", textColor);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\MockedProxies\MockedWebAuthProxy.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test
{
    using System;
    using Leet.Silverlight.XLiveWeb.WebAuthProxy;

    /// <summary>
    /// WebAuthProxy is designed to convert the HttpOnly CompactTicket provided during
    /// signin process into a form that can be used by other Silverlight plugins that
    /// access ActiveAuth-gated LiveN services
    /// </summary>
    public class MockedWebAuthProxy : IWebAuthProxy
    {
        /// <summary>
        /// Initializes a new instance of the WebAuthProxy class
        /// </summary>
        /// <param name="uriStsService">The Uri for the STS Service</param>
        public MockedWebAuthProxy(Uri uriStsService)
        {
            this.MockException = null;

            this.StsService = uriStsService;
        }

        // Callers will have to subscribe to this event to capture the output
        public event EventHandler<WebAuthProxyEventArgs> OnWebAuthRequestCompleted;
        
        /// <summary>
        /// Set whether the proxy should return an exception
        /// </summary>
        public Exception MockException { get; set; }

        private Uri StsService { get; set; }

        public void GetPartnerTokenHTTP(uint gameId, uint gameVersion)
        {
            string partnerToken = "PartnerToken";

            EventHandler<WebAuthProxyEventArgs> tmpEvent = this.OnWebAuthRequestCompleted;
            if (tmpEvent != null)
            {
                WebAuthProxyEventArgs wapea = new WebAuthProxyEventArgs(partnerToken, true, this.MockException, false, null);
                tmpEvent(this, wapea);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\MockedProxies\MockedGameSessionProxy.cs ===
﻿namespace TicTacToe
{
    using System;
    using System.Net;
    using AsyncMultiplayer.GameSessionProxy;
    using AsyncMultiplayer.SessionCommon;

    /// <summary>
    /// Client wrapper for the Game Session Service
    /// </summary>
    public class MockedGameSessionProxy : IGameSessionProxy
    {
        /// <summary>
        /// Mock session for Pickup game
        /// </summary>
        private const string TestSessionA = "aaaaaaaa-92fb-4aec-82d3-05ab9382e653";

        /// <summary>
        /// Mock session for Rematch game
        /// </summary>
        private const string TestSessionB = "bbbbbbbb-92fb-4aec-82d3-05ab9382e653";

        /// <summary>
        /// Mock session for Finished game
        /// </summary>
        private const string TestSessionC = "cccccccc-92fb-4aec-82d3-05ab9382e653";

        /// <summary>
        /// Mock session for About to Win game
        /// </summary>
        private const string TestSessionD = "dddddddd-92fb-4aec-82d3-05ab9382e653";

        /// <summary>
        /// Mock session for New game
        /// </summary>
        private const string TestSessionNew = "creating-anew-sess-iono-ftictactoe10";

        /// <summary>
        /// General access random
        /// </summary>
        private Random rand;

        /// <summary>
        /// Initializes a new instance of the MockedGameSessionProxy class to talk to the specified Service URI
        /// </summary>
        /// <param name="uriGameSessionService">The main URI to access the Game Session service, e.g. http://localhost:8081/Sessions.svc</param>
        /// <param name="colWebHeaders">The parameter is not used.</param>
        /// <param name="containerCookies">The parameter is not used.</param>
        public MockedGameSessionProxy(Uri uriGameSessionService, WebHeaderCollection colWebHeaders, CookieContainer containerCookies)
        {
            if (uriGameSessionService == null)
            {
                throw new ArgumentNullException("uriGameSessionService");
            }

            this.GameSessionUri = uriGameSessionService;

            this.rand = new Random();
        }

        /// <summary>
        /// Prevents a default instance of the GameSessionProxy class from being created.
        /// This class requires a Service URI and User ID to work so there's no way of instantiating it 
        /// without those parameters.
        /// </summary>
        private MockedGameSessionProxy()
        {
        }

        /// <summary>
        /// Callback triggered after CreateSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<SessionState>> OnCreateSessionCompleted;

        /// <summary>
        /// Callback triggered after JoinSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<SessionState>> OnJoinSessionCompleted;

        /// <summary>
        /// Callback triggered after LeaveSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnRejectInvitationCompleted;

        /// <summary>
        /// Callback triggered after LeaveSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnLeaveSessionCompleted;

        /// <summary>
        /// Callback triggered after ModifySessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnModifySessionCompleted;

        /// <summary>
        /// Callback triggered after ViewSessionAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<SessionState>> OnViewSessionCompleted;

        /// <summary>
        /// Callback triggered after ViewSessionSummariesAsync method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<SessionEntry[]>> OnViewSessionSummariesCompleted;

        /// <summary>
        /// Callback triggered after GetGameState method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<FullGameState>> OnGetGameStateCompleted;

        /// <summary>
        /// Callback triggered after PutGameState method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnPutGameStateCompleted;

        /// <summary>
        /// Callback triggered after PostGameEnd method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnPostGameEndCompleted;

        /// <summary>
        /// Callback triggered after PostGameAction method is called
        /// </summary>
        public event EventHandler<GameSessionProxyEventArgs<string>> OnPostGameActionCompleted;

        /// <summary>
        /// Gets or sets the main URI to access the Game Session service, e.g. http://localhost:8081/Sessions.svc
        /// </summary>
        private Uri GameSessionUri { get; set; }

        /// <summary>
        /// Gets or sets the main URI to access the Game State service, e.g. http://localhost:8081/GameState.svc
        /// </summary>
        private Uri GameStateUri { get; set; }

        /// <summary>
        /// Create a new game session
        /// </summary>
        /// <param name="gameId">Title ID for the game to create a session for</param>
        /// <param name="creationData">Session metadata</param>
        public void CreateSessionAsync(uint gameId, CreationData creationData)
        {
            if (creationData == null)
            {
                throw new ArgumentNullException("creationData");
            }

            SessionState responseObject = this.CreateNewSession(creationData);
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<SessionState>> tmpEvent = this.OnCreateSessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<SessionState> gsea = new GameSessionProxyEventArgs<SessionState>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Create a mock session
        /// </summary>
        /// <param name="creationData">Data to insert into mock session</param>
        /// <returns>Mocked session state</returns>
        public SessionState CreateNewSession(CreationData creationData)
        {
            SessionState state = new SessionState();

            state.SessionID = TestSessionNew;
            state.GameID = creationData.GameID;
            state.ActorSeat = 0;
            state.IsClosed = false;
            state.SeatsAvailable = creationData.TotalSeatsAvailable - 1;
            state.DisplayName = creationData.DisplayName;
            state.Variant = creationData.Variant;
            state.Seats = new SeatInfo[1];
            state.Seats[0] = this.CreateSeatInfo("Rooks");
            state.ReservedSeatsAvailable = creationData.ReservedSeatsAvailable;
            state.SessionParameters = creationData.SessionParameters;
            state.InactivityWarning = creationData.InactivityWarning;
            state.CanRemoveEmptySeats = creationData.CanRemoveEmptySeats;

            return state;
        }

        /// <summary>
        /// Join a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to join</param>
        /// <param name="joinData">Join information</param>
        public void JoinSessionAsync(string sessionId, JoinData joinData)
        {
            if (joinData == null)
            {
                throw new ArgumentNullException("joinData");
            }

            SessionState responseObject = null;
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<SessionState>> tmpEvent = this.OnJoinSessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<SessionState> gsea = new GameSessionProxyEventArgs<SessionState>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Reject an invitation.
        /// </summary>
        /// <param name="gameId">The game Id.</param>
        /// <param name="sessionId">The session Id. </param>
        public void RejectInvitationAsync(uint gameId, string sessionId)
        {
            string responseObject = null;
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnRejectInvitationCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Leave a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to leave</param>
        /// <param name="gameId">GameID of the game to leave the session for</param>
        public void LeaveSessionAsync(string sessionId, uint gameId)
        {
            string responseObject = null;
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnLeaveSessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Modify settings for a game session
        /// </summary>
        /// <param name="sessionId">SessionID of the game session to modify</param>
        /// <param name="gameId">GameID of the game to modify</param>
        /// <param name="modificationData">New session parameters to apply</param>
        public void ModifySessionAsync(string sessionId, uint gameId, ModificationData modificationData)
        {
            if (modificationData == null)
            {
                throw new ArgumentNullException("modificationData");
            }

            string responseObject = null;
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnModifySessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// View a game session state
        /// </summary>
        /// <param name="sessionId">SessionID to view session information from</param>
        /// <param name="gameId">GameID of the game to view session information from</param>
        public void ViewSessionAsync(string sessionId, uint gameId)
        {
            SessionState responseObject = this.GetTestSessionState(sessionId);
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<SessionState>> tmpEvent = this.OnViewSessionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<SessionState> gsea = new GameSessionProxyEventArgs<SessionState>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// View a list of active game sessions for the current User
        /// </summary>
        public void ViewSessionSummariesAsync()
        {
            SessionEntry[] responseObject = null;
            Exception exception = null;

            responseObject = new SessionEntry[4];
            responseObject[0] = this.CreateSessionEntry(TestSessionA);
            responseObject[1] = this.CreateSessionEntry(TestSessionB);
            responseObject[2] = this.CreateSessionEntry(TestSessionC);
            responseObject[3] = this.CreateSessionEntry(TestSessionD);

            EventHandler<GameSessionProxyEventArgs<SessionEntry[]>> tmpEvent = this.OnViewSessionSummariesCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<SessionEntry[]> gsea = new GameSessionProxyEventArgs<SessionEntry[]>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        public SessionEntry CreateSessionEntry(string sessionId)
        {
            SessionEntry entry = new SessionEntry();

            // Common data for every entry
            entry.SessionID = sessionId;
            entry.GameID = 0x4D5308F0;
            entry.SessionParameters = new byte[] { 1, 2, 3 };
            entry.Variant = 0;

            switch (sessionId)
            {
                case TestSessionA:
                    entry.DisplayName = "Pickup game";
                    entry.LastModified = DateTime.Now.Subtract(new TimeSpan(3, 2, 0, 0));
                    break;
                case TestSessionB:
                    entry.DisplayName = "Rematch";
                    entry.LastModified = DateTime.Now.Subtract(new TimeSpan(2, 2, 0, 0));
                    break;
                case TestSessionC:
                    entry.DisplayName = "Finished game";
                    entry.LastModified = DateTime.Now.Subtract(new TimeSpan(1, 2, 0, 0));
                    break;
                case TestSessionD:
                    entry.DisplayName = "About to win";
                    entry.LastModified = DateTime.Now.Subtract(new TimeSpan(1, 1, 0, 0));
                    break;
            }

            return entry;
        }

        /// <summary>
        /// Get the active GameState object
        /// </summary>
        public void GetGameStateAsync(string sessionId, uint gameId)
        {
            FullGameState responseObject = this.GetTestFullGameState(sessionId);
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<FullGameState>> tmpEvent = this.OnGetGameStateCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<FullGameState> gsea = new GameSessionProxyEventArgs<FullGameState>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Update the active GameState object
        /// </summary>
        public void PutGameStateAsync(string sessionId, uint gameId, ModifiableGameState modifiableGameState)
        {
            string responseObject = null;
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnPutGameStateCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Submits the end of game information
        /// </summary>
        /// <param name="sessionId">SessionID of the game session</param>
        /// <param name="gameId">GameID of the game</param>
        /// <param name="results">Results of the game</param>
        public void PostGameEndAsync(string sessionId, uint gameId, GameResults results)
        {
            if (results == null)
            {
                throw new ArgumentException("results");
            }

            string responseObject = null;
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnPostGameEndCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Submits a new game action for a particular game session.
        /// </summary>
        /// <param name="sessionID">SessionID for which to submit a new game action.</param>
        /// <param name="gameID">GameID for which to submit a new game action.</param>
        /// <param name="gameAction">The GameAction to be submitted.</param>
        public void PostGameActionAsync(string sessionId, uint gameId, GameAction gameAction)
        {
            if (gameAction == null)
            {
                throw new ArgumentException("gameAction");
            }

            string responseObject = null;
            Exception exception = null;

            EventHandler<GameSessionProxyEventArgs<string>> tmpEvent = this.OnPostGameActionCompleted;
            if (tmpEvent != null)
            {
                GameSessionProxyEventArgs<string> gsea = new GameSessionProxyEventArgs<string>(responseObject, exception, false, null);
                tmpEvent(this, gsea);
            }
        }

        /// <summary>
        /// Returns a test SessionState instance, depending on the session ID passed in
        /// </summary>
        /// <param name="sessionId">the session ID to get</param>
        /// <returns>the SessionState instance corresponding to the session ID</returns>
        private SessionState GetTestSessionState(string sessionId)
        {
            SessionState state = new SessionState();

            state.SessionID = sessionId;
            state.DisplayName = "Tic Tac Toe v1";

            switch (sessionId)
            {
                case TestSessionA:
                    state.SeatsAvailable = 1;
                    state.ActorSeat = 0;
                    state.Seats = new SeatInfo[1];
                    state.Seats[0] = this.CreateSeatInfo("Rooks");
                    state.State = this.CreateGameState(sessionId);
                    state.CreationTime = DateTime.Now.Subtract(new TimeSpan(1, 10, 0, 0));
                    break;
                case TestSessionB:
                    state.SeatsAvailable = 0;
                    state.ActorSeat = 0;
                    state.Seats = new SeatInfo[2];
                    state.Seats[0] = this.CreateSeatInfo("Rooks");
                    state.Seats[1] = this.CreateSeatInfo("Horatio");
                    state.State = this.CreateGameState(sessionId);
                    state.CreationTime = DateTime.Now.Subtract(new TimeSpan(5, 0, 0));
                    break;
                case TestSessionC:
                    state.SeatsAvailable = 0;
                    state.ActorSeat = 0;
                    state.Seats = new SeatInfo[2];
                    state.Seats[0] = this.CreateSeatInfo("Rooks");
                    state.Seats[1] = this.CreateSeatInfo("Rosencrantz");
                    state.State = this.CreateGameState(sessionId);
                    state.CreationTime = DateTime.Now.Subtract(new TimeSpan(2, 0, 0));
                    break;
                case TestSessionD:
                    state.SeatsAvailable = 0;
                    state.ActorSeat = 0;
                    state.Seats = new SeatInfo[2];
                    state.Seats[0] = this.CreateSeatInfo("Rooks");
                    state.Seats[1] = this.CreateSeatInfo("Rosencrantz");
                    state.State = this.CreateGameState(sessionId);
                    state.CreationTime = DateTime.Now.Subtract(new TimeSpan(2, 0, 0));
                    break;
                case TestSessionNew:
                    state.SeatsAvailable = 1;
                    state.ActorSeat = 0;
                    state.Seats = new SeatInfo[1];
                    state.Seats[0] = this.CreateSeatInfo("Rooks");
                    state.State = this.CreateGameState(sessionId);
                    state.CreationTime = DateTime.Now.Subtract(new TimeSpan(0, 1, 0));
                    break;
            }

            return state;
        }

        private SeatInfo CreateSeatInfo(string displayName)
        {
            SeatInfo seatInfo = new SeatInfo();

            seatInfo.DisplayName = displayName;
            seatInfo.Index = 0;
            seatInfo.IsAI = false;

            return seatInfo;
        }

        private GameState CreateGameState(string sessionId)
        {
            GameState gameState = new GameState();

            switch (sessionId)
            {
                case TestSessionA:
                    gameState.SequenceNumber = 0;
                    gameState.IsComplete = false;
                    break;
                case TestSessionB:
                    gameState.SequenceNumber = 1;
                    gameState.ActiveSeatIndex = 0;
                    gameState.IsComplete = false;
                    break;
                case TestSessionC:
                    gameState.SequenceNumber = 5;
                    gameState.IsComplete = true;
                    break;
                case TestSessionD:
                    gameState.SequenceNumber = 5;
                    gameState.ActiveSeatIndex = 0;
                    gameState.IsComplete = false;
                    break;
            }

            return gameState;
        }

        private FullGameState GetTestFullGameState(string sessionId)
        {
            FullGameState state = new FullGameState();

            switch (sessionId)
            {
                case TestSessionB:
                    state.GameStateInfo = this.CreateGameState(sessionId);
                    state.GameData = new byte[9];
                    break;
                case TestSessionC:
                    state.GameStateInfo = this.CreateGameState(sessionId);
                    state.GameData = new byte[9];
                    state.GameData[0] = byte.MaxValue;
                    state.GameData[1] = byte.MaxValue;
                    state.GameData[2] = byte.MaxValue;
                    state.GameData[3] = 1;
                    state.GameData[4] = 1;
                    state.GameData[5] = 0;
                    state.GameData[6] = 1;
                    break;
                case TestSessionD:
                    state.GameStateInfo = this.CreateGameState(sessionId);
                    state.GameData = new byte[9];
                    state.GameData[0] = byte.MaxValue;
                    state.GameData[1] = byte.MaxValue;
                    state.GameData[2] = 0;
                    state.GameData[3] = 1;
                    state.GameData[4] = 1;
                    state.GameData[5] = 0;
                    break;
            }

            return state;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\Tests\ServiceProxies\GameSessionGenerator.cs ===
﻿// <copyright file="GameSessionGenerator.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Filip Skakun</author>
// <email>filip.skakun@gmail.com</email>
// <date>2010-02-18</date>
// <summary>Contains the class definition for GameSessionGenerator class.</summary>

namespace Leet.Silverlight.XLiveWeb.Test
{
    using System;
    using System.Net;
    using System.Windows.Browser;
    using AsyncMultiplayer.GameSessionProxy;
    using AsyncMultiplayer.SessionCommon;
    using Leet.Silverlight.XLiveWeb.Test.Utilities;
    using Leet.Silverlight.XLiveWeb.WebAuthProxy;

    /// <summary>
    /// Constants and initialization methods for game session tests
    /// </summary>
    internal class GameSessionGenerator
    {
        /// <summary>
        /// The test game's unique ID
        /// </summary>
        internal const uint TestGameId = 1297287394; // backgammon

        /// <summary>
        /// The test game's non-zero variant
        /// </summary>
        internal const uint TestGameVariant = 1;

        /// <summary>
        /// The test game's non-zero version
        /// </summary>
        internal const uint TestGameVersion = 0;

        /// <summary>
        /// The message that gets logged when there is a problem getting the session id used in session join/leave tests
        /// </summary>
        internal const string SessionsNotCreatedMessage =
@"Something failed and the session id information was not passed to the test.
You need to go to the URL like below, signed in with a different account before running this test.
http://games.dev.xbox.com/TestTools/SilverlightTestPage?CreateTwoSessions";

        /// <summary>
        /// The name of the file that stores the session id for the join session test
        /// </summary>
        internal const string SessionIdFileNameForJoinSessionTest = "session1.txt";

        /// <summary>
        /// The name of the file that stores the session id for the leave session test
        /// </summary>
        internal const string SessionIdFileNameForLeaveSessionTest = "session2.txt";

        /// <summary>
        /// Common CreationData structure used in multiple unit tests
        /// </summary>
        private readonly CreationData creationData;

        /// <summary>
        /// The Url of the STS proxy service
        /// </summary>
        private static Uri stsProxyServiceUrl;

        /// <summary>
        /// The Url of the game session service
        /// </summary>
        private static Uri gameSessionServiceUrl;

        /// <summary>
        /// The authorization, locale and platform type headers are populated by the WebAuthProxy
        /// </summary>
        private WebHeaderCollection colWebHeaders = null;

        /// <summary>
        /// Initializes a new instance of the <see cref="GameSessionGenerator"/> class.
        /// Initializes the creation data.
        /// </summary>
        internal GameSessionGenerator()
        {
            this.creationData = InitializeCreationData();
        }

        /// <summary>
        /// Occurs when two sessions get created.
        /// </summary>
        public event EventHandler OnCreateTwoSessionsCompleted;

        /// <summary>
        /// Gets or sets the count of sessions created during the sequence of async calls triggered by CreateTwoSessions().
        /// </summary>
        private int SessionsCreated { get; set; }

        /// <summary>
        /// Constructs and initializes the creation data object for test purposes.
        /// </summary>
        /// <returns>A new instance of CreationData</returns>
        internal static CreationData InitializeCreationData()
        {
            CreationData creationData;
            creationData = new CreationData();
            creationData.DisplayName = "Leet.Silverlight.RESTProxy integration session test";
            creationData.InactivityWarning = new InactivityWarningBehavior();
            creationData.InactivityWarning.Action = InactivityWarningAction.None;
            creationData.InactivityWarning.Interval = 30;
            creationData.InactivityWarning.MaxNumberOfNudges = 2;
            creationData.GameID = TestGameId;
            creationData.ReservedSeatsAvailable = 2;
            creationData.SessionParameters = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            creationData.TotalSeatsAvailable = 2;

            // TODO: Seems like this is bug on the MP creation data type. Variant should be uint
            creationData.Variant = (int)TestGameVariant;
            return creationData;
        }

        /// <summary>
        /// Get service URLs from the global JS variables in the page
        /// </summary>
        internal void GetServiceUrls()
        {
            string stsProxyServiceUrlString = HtmlPage.Window.Eval("window.g_stsServiceUrl").ToString();
            stsProxyServiceUrl = new Uri(stsProxyServiceUrlString);

            string gameSessionServiceUrlString = HtmlPage.Window.Eval("window.g_gameSessionServiceUrl").ToString();
            gameSessionServiceUrl = new Uri(gameSessionServiceUrlString);
        }

        /// <summary>
        /// Creates two sessions required by some tests.
        /// 
        /// It is triggered from TestController.CreateTwoSessions()
        /// It needs to be run when signed in with another account than the one used in testing.
        /// It gets run when you browse to:
        /// http://games.dev.xbox.com/TestTools/SilverlightTestPage?CreateTwoSessions
        /// 
        /// It is normally used by test automation through KAF
        /// </summary>
        internal void CreateTwoSessions()
        {
            this.GetServiceUrls();

            FileStorage.DeleteFileFromIsolatedStorage(GameSessionGenerator.SessionIdFileNameForJoinSessionTest);
            FileStorage.DeleteFileFromIsolatedStorage(GameSessionGenerator.SessionIdFileNameForLeaveSessionTest);

            WebAuthProxy wapPartner = new WebAuthProxy(stsProxyServiceUrl);
            wapPartner.OnWebAuthRequestCompleted += new EventHandler<WebAuthProxyEventArgs>(this.OnWebAuthRequestCompleted);
            wapPartner.GetPartnerTokenHTTP(TestGameId, TestGameVersion);
        }

        /// <summary>
        /// Handles the OnWebAuthRequestCompleted event of the createTwoSessions control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="Leet.Silverlight.RESTProxy.WebAuthProxy.WebAuthProxyEventArgs"/> instance containing the event data.</param>
        private void OnWebAuthRequestCompleted(object sender, WebAuthProxyEventArgs e)
        {
            // WebAuthProxy should return a non-empty, non-null result to use as the authorization token
            if (e.Error == null)
            {
                // IMPORTANT: Store this webheader collection since it's required by the other tests
                this.colWebHeaders = e.Result;

                // Create the first session
                GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
                this.creationData.DisplayName = "Test Session 1 of 2";
                gameSessionProxy.OnCreateSessionCompleted += new EventHandler<GameSessionProxyEventArgs<SessionState>>(this.OnCreateSessionCompleted);
                this.SessionsCreated = 0;
                gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
            }
            else
            {
                // If web auth fails - let both tests know about it
                FileStorage.SaveStringToFileInIsolatedStorage(
                    SessionIdFileNameForJoinSessionTest,
                    "Exception:\r\n" + e.Error.ToString());
                FileStorage.SaveStringToFileInIsolatedStorage(
                    SessionIdFileNameForLeaveSessionTest,
                    "Exception:\r\n" + e.Error.ToString());

                // This calls back to TestController
                this.OnCreateTwoSessionsCompleted(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Occurs when a session gets created in a sequence of calls initiated with CreateTwoSessions().
        /// It writes the sessionid to isolated storage, so it can be used when this silverlight app gets
        /// reloaded with another user signed in.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="AsyncMultiplayer.GameSessionProxy.GameSessionProxyEventArgs&lt;AsyncMultiplayer.SessionCommon.SessionState&gt;"/> instance containing the event data.</param>
        private void OnCreateSessionCompleted(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            if (e.Error == null)
            {
                this.SessionsCreated++;

                // Display the sessionid in the log on the test page
                HtmlPage.Window.Invoke(
                    "ReportTestResult",
                    "<sessionid>" + e.Result.SessionID + "</sessionid>\n");

                if (this.SessionsCreated == 1)
                {
                    FileStorage.SaveStringToFileInIsolatedStorage(
                        SessionIdFileNameForJoinSessionTest,
                        e.Result.SessionID);

                    // Create another session
                    this.creationData.DisplayName = "Test Session 2 of 2";
                    ((GameSessionProxy)sender).CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
                }
                else if (this.SessionsCreated == 2)
                {
                    FileStorage.SaveStringToFileInIsolatedStorage(
                        SessionIdFileNameForLeaveSessionTest,
                        e.Result.SessionID);

                    // Complete sequence of session creation calls - call back to TestController
                    this.OnCreateTwoSessionsCompleted(this, EventArgs.Empty);
                }
            }
            else
            {
                // Display the sessionid in the log on the test page
                HtmlPage.Window.Invoke(
                    "ReportTestResult",
                    "<sessionid>" + e.Error.ToString() + "</sessionid>");

                if (this.SessionsCreated < 1)
                {
                    FileStorage.SaveStringToFileInIsolatedStorage(
                        SessionIdFileNameForJoinSessionTest,
                        "Exception:\r\n" + e.Error.ToString());
                }

                if (this.SessionsCreated < 2)
                {
                    FileStorage.SaveStringToFileInIsolatedStorage(
                        SessionIdFileNameForLeaveSessionTest,
                        "Exception:\r\n" + e.Error.ToString());
                }

                // Complete sequence of session creation calls - call back to TestController
                this.OnCreateTwoSessionsCompleted(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Creates and initializes a new GameSessionProxy class, useful when registering for callbacks
        /// </summary>
        /// <returns>An initialized GameSessionProxy object</returns>
        private GameSessionProxy CreateNewGameSessionProxy()
        {
            return new GameSessionProxy(gameSessionServiceUrl, this.colWebHeaders, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Silverlight.XLiveWeb.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\Tests\TicTacToe\TicTacToeIntegratedTests.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test
{
    using System.Windows;
    using Microsoft.Silverlight.Testing;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using TicTacToe;

    /// <summary>
    /// Test class for all Tic Tac Toe tests
    /// </summary>
    [TestClass]
    public class TicTacToeIntegratedTests : SilverlightTest
    {
        /// <summary>
        /// Local copy of the game for all the tests to share
        /// </summary>
        private MainPage ticTacToe;

        /// <summary>
        /// Intializes the test class by creating the control to test and adding it to the main controller
        /// </summary>
        [ClassInitialize]
        public void ClassInitialize()
        {
            // Create the new control and add it to the test controller so we can see it
            this.ticTacToe = new TicTacToe.MainPage(false);

            TestController controller = (TestController)App.Current.RootVisual;
            controller.SetTestControl(this.ticTacToe);
        }

        /// <summary>
        /// Intializes all tests with a friend picker
        /// </summary>
        [TestInitialize]
        public void TestInitialize()
        {
        }

        /// <summary>
        /// Tests to see if the gamsd synce is visible or not
        /// </summary>
        [TestMethod]
        public void IsVisible()
        {
            Assert.AreEqual(Visibility.Visible, this.ticTacToe.Visibility, "Friend picker is not visible");
        }

        /// <summary>
        /// Clicks on View Games and verifies that the session list is not empty
        /// IGNORE: Right now, the test is failing due to a timing issue ... need to investigate a way to fix this
        /// </summary>
        [TestMethod]
        [Asynchronous]
        public void ViewGames()
        {
            EnqueueConditional(() => this.ticTacToe.MainMenuWindow.Visibility == Visibility.Visible);

            EnqueueCallback(() =>
            {
                this.ticTacToe.MainMenuWindow.btnViewGames_Click(this, null);
            });

            EnqueueConditional(() => this.ticTacToe.SessionBrowserWindow.Visibility == Visibility.Visible);

            EnqueueCallback(() =>
            {
                Assert.IsTrue(this.ticTacToe.SessionBrowserWindow.SessionList.Items.Count > 0, "Session list is empty");
            });

            EnqueueTestComplete();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\Tests\TicTacToe\TicTacToeTests.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test
{
    using System;
    using System.Windows;
    using Microsoft.Silverlight.Testing;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Leet.Silverlight.XLiveWeb.WebAuthProxy;
    using TicTacToe;
    using NGGamePlayer;

    /// <summary>
    /// Test class for all Tic Tac Toe tests
    /// </summary>
    [TestClass]
    public class TicTacToeTests : SilverlightTest
    {
        /// <summary>
        /// Local copy of the game for all the tests to share
        /// </summary>
        private MainPage ticTacToe;

        /// <summary>
        /// Intializes the test class by creating the control to test and adding it to the main controller
        /// </summary>
        [ClassInitialize]
        public void ClassInitialize()
        {
            // Create the new control and add it to the test controller so we can see it
            MockedWebAuthProxy webAuthProxy = new MockedWebAuthProxy(new Uri("http://sts.mock.xbox.com/Tokens.svc"));
            MockedGameSessionProxy gameSessionProxy = new MockedGameSessionProxy(new Uri("http://sessions.mock.xboxlive.com/Sessions.svc"), null, null);
            this.ticTacToe = new MainPage(webAuthProxy, gameSessionProxy);
            
            TestController controller = (TestController)App.Current.RootVisual;
            controller.SetTestControl(this.ticTacToe);
        }

        /// <summary>
        /// Intializes all tests with a friend picker
        /// </summary>
        [TestInitialize]
        public void TestInitialize()
        {
        }

        /// <summary>
        /// Tests to see if the game is visible or not
        /// </summary>
        [TestMethod]
        public void IsVisible()
        {
            Assert.AreEqual(Visibility.Visible, this.ticTacToe.Visibility, "Friend picker is not visible");
        }

        /// <summary>
        /// Clicks on View Games and verifies that the session list is not empty
        /// </summary>
        [TestMethod]
        public void ViewGames()
        {
            this.ticTacToe.MainMenuWindow.btnViewGames_Click(this, null);

            Assert.IsTrue(this.ticTacToe.SessionBrowserWindow.SessionList.Items.Count > 0, "Session list is empty");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\Color.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    /// <summary>
    /// String definitions for the test framework.
    /// </summary>
    public static class Color
    {
        /// <summary>
        /// Very light gray representing #eee color.
        /// </summary>
        public const string VeryLightGray = "#eee";

        /// <summary>
        /// Another grey color, #ddd.
        /// </summary>
        public const string AnotherLightGray = "#ddd";

        /// <summary>
        /// Light gray representing #999 color.
        /// </summary>
        public const string LightGray = "#999";

        /// <summary>
        /// Dark gray representing #333 color.
        /// </summary>
        public const string DarkGray = "#333";

        /// <summary>
        /// Blue color #00f.
        /// </summary>
        public const string Blue = "#00f";

        /// <summary>
        /// Manila folder color color.
        /// </summary>
        public const string Manila = "#fff9d8";

        /// <summary>
        /// Border that pairs well with the "Manila" color color.
        /// </summary>
        public const string ManilaBorder = "#ffe8cd";

        /// <summary>
        /// Tan color color.
        /// </summary>
        public const string Tan = "#d2b48c";

        /// <summary>
        /// White color.
        /// </summary>
        public const string White = "#fff";

        /// <summary>
        /// Black color.
        /// </summary>
        public const string Black = "#000";

        /// <summary>
        /// Pure Red color.
        /// </summary>
        public const string Red = "#f00";

        /// <summary>
        /// Yellow color.
        /// </summary>
        public const string Yellow = "#ff0";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\Tests\ServiceProxies\TestGameSessionProxyClient.cs ===
﻿// <copyright file="TestGameSessionProxyClient.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Jorge Lopez de Luna</author>
// <email>jorgel@microsoft.com</email>
// <date>2009-10-15</date>
// <summary>Contains the class definition for GameSessionProxyTests class.</summary>

namespace Leet.Silverlight.XLiveWeb.Test
{
    using System;
    using System.IO.IsolatedStorage;
    using System.Net;
    using System.Threading;
    using System.Windows.Browser;
    using AsyncMultiplayer.GameSessionProxy;
    using AsyncMultiplayer.SessionCommon;
    using Leet.Silverlight.XLiveWeb.Test.Utilities;
    using Leet.Silverlight.XLiveWeb.WebAuthProxy;
    using Microsoft.Silverlight.Testing;
    using Microsoft.VisualStudio.TestTools.UnitTesting;

    /// <summary>
    /// Tests the GameSessionProxy implementation
    /// </summary>
    [TestClass]
    public class TestGameSessionProxyClient : SilverlightTest
    {
        /// <summary>
        /// Error message used when callbacks get executed in a non-UI thread
        /// </summary>
        private const string NonUiCompletion = "The async operation completed on a non-UI thread.";

        /// <summary>
        /// Error message used when callbacks result in errors
        /// </summary>
        private const string ErrorOnAsyncCompletion = "The async operation completed with an error";

        /// <summary>
        /// Common CreationData structure used in multiple unit tests
        /// </summary>
        private readonly CreationData creationData;

        /// <summary>
        /// Common ModificationData structure used in multiple unit tests
        /// </summary>
        private readonly ModificationData modificationData;

        /// <summary>
        /// The Url of the STS proxy service
        /// </summary>
        private static Uri stsProxyServiceUrl;

        /// <summary>
        /// The Url of the game session service
        /// </summary>
        private static Uri gameSessionServiceUrl;
        
        /// <summary>
        /// The instance of the tets context used by the test cases in this class.
        /// </summary>
        private TestContext testContextInstance;

        /// <summary>
        /// The authorization, locale and platform type headers are populated by the WebAuthProxy
        /// </summary>
        private WebHeaderCollection colWebHeaders = null;

        /// <summary>
        /// Initializes a new instance of the TestGameSessionProxyClient class.
        /// </summary>
        /// <remarks>
        /// To run these tests you will need to change your App.config file to have an active server deployed to
        /// the URI pointed to in the GameSessionServiceUriString config key. This can be on localhost, but it does have
        /// to be actively hosted and dispatching requests.
        /// </remarks>
        public TestGameSessionProxyClient()
        {
            // Initialize CreationData structure
            this.creationData = GameSessionGenerator.InitializeCreationData();

            // Initialize modificationData
            this.modificationData = new ModificationData();
            this.modificationData.CanRemoveEmptySeats = false;
            this.modificationData.DisplayName = "Leet.Silverlight.RESTProxy modified session test";
            this.modificationData.InactivityWarning = new InactivityWarningBehavior();
            this.modificationData.InactivityWarning.Action = InactivityWarningAction.None;
            this.modificationData.InactivityWarning.Interval = 30;
            this.modificationData.InactivityWarning.MaxNumberOfNudges = 2;
            this.modificationData.IsFriendsOnly = true;
            this.modificationData.ReservedSeatsAvailable = 5;
            this.modificationData.SessionParameters = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            this.modificationData.TotalSeatsAvailable = 5;
        }

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        /// </summary>
        /// <value>The test context.</value>
        public TestContext TestContext
        {
            get
            {
                return this.testContextInstance;
            }

            set
            {
                this.testContextInstance = value;
            }
        }

        /// <summary>
        /// Gets or sets the current session ID for the game being tested - used to pass SessionID around callbacks
        /// </summary>
        private static string CurrentSessionID { get; set; }

        /// <summary>
        /// Gets or sets the thread that's responsible for UI rendering on the current test
        /// </summary>
        private Thread UIThread { get; set; }

        /// <summary>
        /// Gets or sets the UI Synchronization Context for the current test
        /// </summary>
        private SynchronizationContext UISyncContext { get; set; }

        /// <summary>
        /// Gets or sets the count of sessions created - used for testing ViewSessionSummaries to create several sessions in succession
        /// </summary>
        private int SessionsCreated { get; set; }

        /// <summary>
        /// Get service URLs from the global JS variables in the page
        /// </summary>
        [ClassInitialize]
        public void GetServiceUrls()
        {    
            string stsProxyServiceUrlString = HtmlPage.Window.Eval("window.g_stsServiceUrl").ToString();
            stsProxyServiceUrl = new Uri(stsProxyServiceUrlString);
           
            string gameSessionServiceUrlString = HtmlPage.Window.Eval("window.g_gameSessionServiceUrl").ToString();
            gameSessionServiceUrl = new Uri(gameSessionServiceUrlString);
        }

        /// <summary>
        /// Extract the authentication token required for GameSession and GameState calls
        /// </summary>
        [TestInitialize]
        [Asynchronous]
        public void ExtractPartnerAuthTokenRequiredForEachTest()
        {
            // Extract the partner token which is used to authenticate the client against the GameSession and GameState services
            WebAuthProxy wapPartner = new WebAuthProxy(stsProxyServiceUrl);
            wapPartner.OnWebAuthRequestCompleted += this.OnWebAuthRequestCompleted;
            wapPartner.GetPartnerTokenHTTP(GameSessionGenerator.TestGameId, GameSessionGenerator.TestGameVersion);
        }

        /// <summary>
        /// Test CreateSession
        /// </summary>
        [TestMethod]
        [Tag("BVT")]
        [Asynchronous]
        public void TestCreateSession()
        {
            this.StoreUIThread();

            // TestUser1 creates a game session
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            this.creationData.DisplayName = "Test Session 1";
            gameSessionProxy.OnCreateSessionCompleted += this.OnCreateSessionCompleted;
            gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
        }

        /// <summary>
        /// Test JoinSession
        /// Disabled since we have no way currently to join a session created by someone else.
        /// </summary>
        [TestMethod]
        [Tag("FVT")] 
        [Description("Attempts to JOIN a new session as a second user")]
        [Asynchronous]
        public void TestJoinSession()
        {
            this.StoreUIThread();

            // Get the session ID for a session to join from isolated storage.
            try
            {
                TestGameSessionProxyClient.CurrentSessionID = FileStorage.LoadStringFromFileInIsolatedStorage(GameSessionGenerator.SessionIdFileNameForJoinSessionTest);
            }
            catch (IsolatedStorageException ex)
            {
                throw new InvalidOperationException(GameSessionGenerator.SessionsNotCreatedMessage, ex);
            }

            // Check for null session id or exception passed from the test initialization instead of a session id
            Assert.IsNotNull(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.SessionsNotCreatedMessage);
            Assert.IsFalse(TestGameSessionProxyClient.CurrentSessionID.StartsWith("Exception"), GameSessionGenerator.SessionsNotCreatedMessage + "\r\n" + TestGameSessionProxyClient.CurrentSessionID);

            // Delete the file now, so we don't have any future test runs trying to use the same session id
            FileStorage.DeleteFileFromIsolatedStorage(GameSessionGenerator.SessionIdFileNameForJoinSessionTest);

            // Now try to join the session
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            JoinData joinData = new JoinData();
            joinData.GameID = GameSessionGenerator.TestGameId;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            joinData.SessionID = TestGameSessionProxyClient.CurrentSessionID;

            // TestUser2 joins game session
            GameSessionProxy gameSessionProxy2 = this.CreateNewGameSessionProxy();
            gameSessionProxy2.OnJoinSessionCompleted += this.OnJoinSessionCompleted;
            gameSessionProxy2.JoinSessionAsync(TestGameSessionProxyClient.CurrentSessionID, joinData);
        }

        /// <summary>
        /// Test LeaveSession
        /// TODO: Ignoring this integration test until we can simulate a second user signing in
        /// </summary>
        [TestMethod]
        [Tag("FVT")]
        [Description("Attempts to LEAVE a session after two users have joined it")]
        [Asynchronous]
        public void TestLeaveSession()
        {
            this.StoreUIThread();

            // Get the session ID for a session to join from isolated storage.
            try
            {
                TestGameSessionProxyClient.CurrentSessionID = FileStorage.LoadStringFromFileInIsolatedStorage(GameSessionGenerator.SessionIdFileNameForLeaveSessionTest);
            }
            catch (IsolatedStorageException ex)
            {
                throw new InvalidOperationException(GameSessionGenerator.SessionsNotCreatedMessage, ex);
            }

            // Check for null session id or exception passed from the test initialization instead of a session id
            Assert.IsNotNull(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.SessionsNotCreatedMessage);
            Assert.IsFalse(TestGameSessionProxyClient.CurrentSessionID.StartsWith("Exception"), GameSessionGenerator.SessionsNotCreatedMessage + "\r\n" + TestGameSessionProxyClient.CurrentSessionID);

            // Delete the file now, so we don't have any future test runs trying to use the same session id
            FileStorage.DeleteFileFromIsolatedStorage(GameSessionGenerator.SessionIdFileNameForLeaveSessionTest);

            // Now join the session with a plan to leave it in the future
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            Assert.IsNotNull(TestGameSessionProxyClient.CurrentSessionID, "Could not find Session ID being tested. Aborting... (It could mean the session was not created with another account by going to http://games.dev.xbox.com/TestTools/SilverlightTestPage?CreateTwoSessions)");

            // Now try to join the session
            TestGameSessionProxyClient.CurrentSessionID = TestGameSessionProxyClient.CurrentSessionID;
            JoinData joinData = new JoinData();
            joinData.GameID = GameSessionGenerator.TestGameId;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            joinData.SessionID = TestGameSessionProxyClient.CurrentSessionID;

            // TestUser2 must first join the game session before someone can leave (needs at least 2 players)
            GameSessionProxy gameSessionProxy2 = this.CreateNewGameSessionProxy();
            gameSessionProxy2.OnJoinSessionCompleted += this.OnInitialJoinBeforeLeaveCompleted;
            gameSessionProxy2.JoinSessionAsync(TestGameSessionProxyClient.CurrentSessionID, joinData);
        }

        /// <summary>
        /// Test ModifySession
        /// </summary>
        [TestMethod]
        [Tag("BVT")]
        [Asynchronous]
        public void TestModifySession()
        {
            this.StoreUIThread();

            // TestUser1 creates a game session
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            this.creationData.DisplayName = "Test Session 1";
            gameSessionProxy.OnCreateSessionCompleted += this.CreateSessionAndCallModify;
            gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
        }

        /// <summary>
        /// Test ViewSession
        /// </summary>
        [TestMethod]
        [Tag("BVT")]
        [Asynchronous]
        public void TestViewSession()
        {
            this.StoreUIThread();

            // TestUser1 creates a game session
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            this.creationData.DisplayName = "Test Session 1";
            gameSessionProxy.OnCreateSessionCompleted += this.CreateSessionAndCallView;
            gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
        }

        /// <summary>
        /// Test ViewSessionSummaries
        /// </summary>
        [TestMethod]
        [Tag("BVT")]
        [Asynchronous]
        public void TestViewSessionSummaries()
        {
            this.StoreUIThread();

            this.SessionsCreated = 0;

            // TestUser1 creates a game session
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            this.creationData.DisplayName = "Test Session 1";
            gameSessionProxy.OnCreateSessionCompleted += this.CreateSessionAndCallCreate;
            gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
        }

        /// <summary>
        /// Test PutGameState
        /// </summary>
        [TestMethod]
        [Tag("BVT")]
        [Asynchronous]
        public void TestPutGameState()
        {
            this.StoreUIThread();

            // TestUser1 creates a game session
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            this.creationData.DisplayName = "Test Session 1";
            gameSessionProxy.OnCreateSessionCompleted += this.CreateSessionAndCallPutGameState;
            gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
        }

        /// <summary>
        /// Test GetGameState
        /// </summary>
        [TestMethod]
        [Tag("BVT")]
        [Asynchronous]
        public void TestGetGameState()
        {
            this.StoreUIThread();

            // TestUser1 creates a game session
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            this.creationData.DisplayName = "Test Session 1";
            gameSessionProxy.OnCreateSessionCompleted += this.CreateSessionAndInitializeGameState;
            gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
        }

        /// <summary>
        /// Test PostGameAction
        /// </summary>
        [TestMethod]
        [Tag("BVT")]
        [Asynchronous]
        public void TestPostGameAction()
        {
            this.StoreUIThread();

            // TestUser1 creates a game session
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            this.creationData.DisplayName = "Test Session 1";
            gameSessionProxy.OnCreateSessionCompleted += this.CreateSessionAndCallNudge;
            gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
        }

        /// <summary>
        /// Creates and initializes a new GameSessionProxy class, useful when registering for callbacks
        /// </summary>
        /// <returns>An initialized GameSessionProxy object</returns>
        private GameSessionProxy CreateNewGameSessionProxy()
        {
            return new GameSessionProxy(TestGameSessionProxyClient.gameSessionServiceUrl, this.colWebHeaders, null);
        }

        /// <summary>
        /// This test should always execute before the others. For some reason under the SL UT framework, TestInitialize
        /// and ClassInitialize didn't work
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="Leet.Silverlight.RESTProxy.WebAuthProxy.WebAuthProxyEventArgs"/> instance containing the event data.</param>
        private void OnWebAuthRequestCompleted(object sender, WebAuthProxyEventArgs e)
        {
            // WebAuthProxy should return a non-empty, non-null result to use as the authorization token
            if (e.Error == null)
            {
                // IMPORTANT: Store this webheader collection since it's required by the other tests
                this.colWebHeaders = e.Result;
            }

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnCreateSessionCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnCreateSessionCompleted(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST CreateSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");
            } 
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnJoinSessionCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnJoinSessionCompleted(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST JoinSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }

            TestGameSessionProxyClient.CurrentSessionID = null;

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnInitialJoinBeforeLeaveCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnInitialJoinBeforeLeaveCompleted(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST JoinSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");

                // TestUser1 leaves the game session
                GameSessionProxy gameSessionProxy2 = this.CreateNewGameSessionProxy();
                gameSessionProxy2.OnLeaveSessionCompleted += this.OnLeaveSessionCompleted;
                gameSessionProxy2.LeaveSessionAsync(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.TestGameId);
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }
        }

        /// <summary>
        /// Event handler for OnLeaveSessionCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnLeaveSessionCompleted(object sender, GameSessionProxyEventArgs<string> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(e.Result == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnCreateSessionCompleted -- to be used when testing ModifySession when you need to create a session and follow up actions
        /// This method doesn't call EnqueueTestComplete() on purpose - it's not the end of the test case until OnModifySessionCompleted is called
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void CreateSessionAndCallModify(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST CreateSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");

                TestGameSessionProxyClient.CurrentSessionID = serviceReponse.SessionID;
                Assert.IsNotNull(TestGameSessionProxyClient.CurrentSessionID, "Could not find Session ID being tested. Aborting...");

                // TestUser1 modifies the game session
                GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
                gameSessionProxy.OnModifySessionCompleted += this.OnModifySessionCompleted;
                gameSessionProxy.ModifySessionAsync(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.TestGameId, this.modificationData);
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }
        }

        /// <summary>
        /// Event handler for OnModifySessionCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnModifySessionCompleted(object sender, GameSessionProxyEventArgs<string> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(e.Result == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnCreateSessionCompleted -- to be used when testing ViewSession when you need to create a session and follow up actions
        /// This method doesn't call EnqueueTestComplete() on purpose - it's not the end of the test case until OnViewSessionCompleted is called
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void CreateSessionAndCallView(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST CreateSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");

                TestGameSessionProxyClient.CurrentSessionID = serviceReponse.SessionID;
                Assert.IsNotNull(TestGameSessionProxyClient.CurrentSessionID, "Could not find Session ID being tested. Aborting...");

                // TestUser1 views the active game session
                GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
                gameSessionProxy.OnViewSessionCompleted += this.OnViewSessionCompleted;
                gameSessionProxy.ViewSessionAsync(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.TestGameId);
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }
        }

        /// <summary>
        /// Event handler for OnViewSessionCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnViewSessionCompleted(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from GET ViewSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnCreateSessionCompleted -- to be used when testing ViewSession when you need to create a session and follow up actions
        /// This method doesn't call EnqueueTestComplete() on purpose - it's not the end of the test case until OnViewSessionCompleted is called
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void CreateSessionAndCallCreate(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST CreateSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");

                this.SessionsCreated++;

                // If current session count is < 3, keep creating more. Otherwise, call ViewSessionSummaries since we're done creating sessions
                GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();

                if (this.SessionsCreated < 3)
                {
                    // TestUser1 creates a new game session
                    this.creationData.DisplayName = "Test Session " + (this.SessionsCreated + 1);
                    gameSessionProxy.OnCreateSessionCompleted += this.CreateSessionAndCallCreate;
                    gameSessionProxy.CreateSessionAsync(GameSessionGenerator.TestGameId, this.creationData);
                }
                else
                {
                    // TestUser1 queries for active game sessions
                    gameSessionProxy.OnViewSessionSummariesCompleted += this.OnViewSessionSummariesCompleted;
                    gameSessionProxy.ViewSessionSummariesAsync();
                }
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }
        }

        /// <summary>
        /// Event handler for OnViewSessionSummariesCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnViewSessionSummariesCompleted(object sender, GameSessionProxyEventArgs<SessionEntry[]> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionEntry[]), "Result type from GET ViewSessionSummaries is NOT SessionState");
                SessionEntry[] serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionEntry List is null");
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnCreateSessionCompleted -- to be used when testing PutGameState when you need to create a session and follow up actions
        /// This method doesn't call EnqueueTestComplete() on purpose - it's not the end of the test case until OnViewSessionCompleted is called
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void CreateSessionAndCallPutGameState(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST CreateSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");

                // Modify the GameState
                ModifiableGameState modifiableGameState = new ModifiableGameState();
                modifiableGameState.ActiveSeatIndex = 0;
                modifiableGameState.GameData = new byte[] { 0xDD, 0xEE, 0xAA, 0xDD, 0xBB, 0xEE, 0xEE, 0xFF };

                TestGameSessionProxyClient.CurrentSessionID = serviceReponse.SessionID;
                Assert.IsNotNull(TestGameSessionProxyClient.CurrentSessionID, "Could not find Session ID being tested. Aborting...");

                // TestUser1 modifies the active game state
                GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
                gameSessionProxy.OnPutGameStateCompleted += this.OnPutGameStateCompleted;
                gameSessionProxy.PutGameStateAsync(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.TestGameId, modifiableGameState);
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }
        }

        /// <summary>
        /// Event handler for OnPutGameStateCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnPutGameStateCompleted(object sender, GameSessionProxyEventArgs<string> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(e.Result == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnCreateSessionCompleted -- to be used when testing GetGameState when you need to create a session and follow up actions
        /// This method doesn't call EnqueueTestComplete() on purpose - it's not the end of the test case until OnViewSessionCompleted is called
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void CreateSessionAndInitializeGameState(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST CreateSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");

                // The response from a PutGameStateAsync does not indicate the Session ID so we're storing internally for now for this test
                TestGameSessionProxyClient.CurrentSessionID = serviceReponse.SessionID;
                Assert.IsNotNull(TestGameSessionProxyClient.CurrentSessionID, "Could not find Session ID being tested. Aborting...");

                // NOTE: We need to initialize the state with PutGameStateAsync to workaround the current issue
                ModifiableGameState modifiableGameState = new ModifiableGameState();
                modifiableGameState.ActiveSeatIndex = 0;
                modifiableGameState.GameData = new byte[] { 0xDD, 0xEE, 0xAA, 0xDD, 0xBB, 0xEE, 0xEE, 0xFF };

                // TestUser1 modifies the active game state
                GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
                gameSessionProxy.OnPutGameStateCompleted += this.OnInitializedGameStateCompleted;
                gameSessionProxy.PutGameStateAsync(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.TestGameId, modifiableGameState);
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }
        }

        /// <summary>
        /// Event handler for OnPutGameStateCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnInitializedGameStateCompleted(object sender, GameSessionProxyEventArgs<string> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            // TestUser1 gets the active game state
            GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
            gameSessionProxy.OnGetGameStateCompleted += this.OnGetGameStateCompleted;
            gameSessionProxy.GetGameStateAsync(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.TestGameId);
        }

        /// <summary>
        /// Event handler for OnGetGameStateCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnGetGameStateCompleted(object sender, GameSessionProxyEventArgs<FullGameState> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(FullGameState), "Result type from GET GameState is NOT FullGameState");
                FullGameState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved FullGameState is null");
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Event handler for OnCreateSessionCompleted --  to be used when testing PostGameAction when you need to create a session and follow up actions
        /// This method doesn't call EnqueueTestComplete() on purpose - it's not the end of the test case until OnPostGameActionCompleted is called
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void CreateSessionAndCallNudge(object sender, GameSessionProxyEventArgs<SessionState> e)
        {
            try
            {
                Assert.IsTrue(e.Result.GetType() == typeof(SessionState), "Result type from POST CreateSession is NOT SessionState");
                SessionState serviceReponse = e.Result;
                Assert.IsNotNull(serviceReponse, "Retrieved SessionState is null");

                TestGameSessionProxyClient.CurrentSessionID = serviceReponse.SessionID;
                Assert.IsNotNull(TestGameSessionProxyClient.CurrentSessionID, "Could not find Session ID being tested. Aborting...");

                // Per Multiplayer service, ActionData for Nudge is expected to be a single byte in length and indicate the zero-based index
                // of the user to be nudged. In this case, we're just nudging ourselves so the value is a single 0x00.
                GameAction gameAction = new GameAction();
                gameAction.ActionData = new byte[] { 0x00 };
                gameAction.ActionTime = DateTime.Now;
                gameAction.ActionType = GameActionType.UserNudge;
                gameAction.SequenceNumber = 1;

                // TestUser1 calls PostGameAction to Nudge
                GameSessionProxy gameSessionProxy = this.CreateNewGameSessionProxy();
                gameSessionProxy.OnPostGameActionCompleted += this.OnPostGameActionCompleted;
                gameSessionProxy.PostGameActionAsync(TestGameSessionProxyClient.CurrentSessionID, GameSessionGenerator.TestGameId, gameAction);
            }
            catch (Exception ex)
            {
                // Fail the test because we hit an exception.
                Assert.Fail(ex.Message.ToString());
            }
        }

        /// <summary>
        /// Event handler for OnPostGameActionCompleted
        /// </summary>
        /// <param name="sender">Event sending object</param>
        /// <param name="e">Event Args structure</param>
        private void OnPostGameActionCompleted(object sender, GameSessionProxyEventArgs<string> e)
        {
            Assert.IsTrue(e.Error == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(e.Result == null, TestGameSessionProxyClient.ErrorOnAsyncCompletion);
            Assert.IsTrue(this.IsUIThread(), TestGameSessionProxyClient.NonUiCompletion);

            // This marks the end of the asynchronous test
            EnqueueTestComplete();
        }

        /// <summary>
        /// Save the current UI thread for future comparison purposes
        /// </summary>
        private void StoreUIThread()
        {
            this.UIThread = Thread.CurrentThread;
            this.UISyncContext = SynchronizationContext.Current;
        }

        /// <summary>
        /// Validate whether current thread is the main UI thread or not
        /// </summary>
        /// <returns>true if the current thread is the main UI thread, false otherwise</returns>
        private bool IsUIThread()
        {
            if (this.UIThread.ManagedThreadId != Thread.CurrentThread.ManagedThreadId)
            {
                return false;
            }

            if (this.UISyncContext != SynchronizationContext.Current)
            {
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\HtmlTestColumn.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System;
    using System.Windows.Browser;
    using Microsoft.Silverlight.Testing.Html;

    /// <summary>
    /// A type that represents a web page used for test purposes of the current 
    /// Silverlight plugin.
    /// </summary>
    public class HtmlTestColumn : HtmlContainerControl
    {
        /// <summary>
        /// Padding that is always present between the control and plugin.
        /// </summary>
        private const int ImplicitPadding = 10;

        /// <summary>
        /// Initializes the HtmlTestColumn control.
        /// </summary>
        /// <param name="allocatedColumnWidth">The allocated width in pixels of
        /// the test column.</param>
        /// <param name="leftMargin">The left margin size, in pixels.</param>
        /// <param name="clientHeight">The calculated height of the browser's 
        /// client space.</param>
        public HtmlTestColumn(int allocatedColumnWidth, int leftMargin, int clientHeight)
            : base(HtmlTag.Div)
        {
            if (allocatedColumnWidth > ImplicitPadding)
            {
                allocatedColumnWidth -= ImplicitPadding;
            }

            Width = allocatedColumnWidth;
            SetStyleAttribute(CssAttribute.MinHeight, clientHeight);
            SetStyleAttribute(CssAttribute.BackgroundColor, "white");
            this.PreparePositioning();
            this.PrepareLeftEdge(leftMargin);
        }

        /// <summary>
        /// Positions the column absolutely.
        /// </summary>
        private void PreparePositioning()
        {
            SetStyleAttribute(CssAttribute.Position, "absolute");
            Position.Top = 80;
            Position.Right = 0;
        }

        /// <summary>
        /// Creates a border on the left side of the column.
        /// </summary>
        /// <param name="leftMargin">The margin on the left.</param>
        private void PrepareLeftEdge(int leftMargin)
        {
            Margin.Left = leftMargin;
            BorderWidth = 0;
            SetStyleAttribute(CssAttribute.BorderLeftStyle, BorderStyle.Solid);
            SetStyleAttribute(CssAttribute.BorderLeftColor, Color.AnotherLightGray);
            BorderWidthAdvanced.Left = 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\ResultIndicatorColor.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System;
    using System.Windows.Browser;
    using Microsoft.Silverlight.Testing.Html;

    /// <summary>
    /// A type that represents a web page used for test purposes of the current 
    /// Silverlight plugin.
    /// </summary>
    public static class ResultIndicatorColor
    {
        /// <summary>
        /// The color used to indicate a failed run.
        /// </summary>
        public const string FinishedFailure = "#f00";

        /// <summary>
        /// The color used to indicate that a failure has happened during an 
        /// in-progress run.
        /// </summary>
        public const string InProgressFailure = "#f99";

        /// <summary>
        /// The color used to indicate a good run.
        /// </summary>
        public const string FinishedSuccess = "#0f0";

        /// <summary>
        /// The color used to indicate that there have been no failures yet, but
        /// the run is in-progress.
        /// </summary>
        public const string InProgressSuccess = "#9f9";

        /// <summary>
        /// The background color used to indicate a failing run.
        /// </summary>
        public const string BackgroundFailure = "#fee";

        /// <summary>
        /// The background color used to indicate a passing run.
        /// </summary>
        public const string BackgroundSuccess = "#efe";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\TestColumnHeader.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System;
    using System.Windows.Browser;
    using Microsoft.Silverlight.Testing.Html;

    /// <summary>
    /// The test column's header control.
    /// </summary>
    public class TestColumnHeader : HtmlDiv
    {
        /// <summary>
        /// The fixed name used for test column indicator's class names.
        /// </summary>
        public const string TestColumnIndicator = "test-column-indicator";

        /// <summary>
        /// The pass/fail indicator area.
        /// </summary>
        private HtmlDiv _indicator;

        /// <summary>
        /// The framework title.
        /// </summary>
        private Paragraph _about;

        /// <summary>
        /// Initializes a new column header.
        /// </summary>
        public TestColumnHeader()
            : base()
        {
            StylizeHeader();
            CreateAbout();
            CreateIndicator();
        }

        /// <summary>
        /// Initializes a new column header.
        /// </summary>
        /// <param name="displayName">The display name of the framework.</param>
        public TestColumnHeader(string displayName)
            : this()
        {
            DisplayProductName = displayName;
        }

        /// <summary>
        /// Gets or sets the display name for the framework/product.
        /// </summary>
        public string DisplayProductName
        {
            get
            {
                return _about.InnerHtml;
            }

            set
            {
                _about.InnerHtml = value;
            }
        }

        /// <summary>
        /// Sets the color of the result indicator in the header.
        /// </summary>
        /// <param name="runInProgress">A value indicating whether the run is 
        /// still in progress, or has completed.</param>
        /// <param name="runIsSuccessful">A value indicating whether the run 
        /// results indicate success so far.</param>
        public void UpdateIndicatorColoring(bool runInProgress, bool runIsSuccessful)
        {
            string color = runIsSuccessful ?
                /* pass */ (runInProgress ? ResultIndicatorColor.InProgressSuccess : ResultIndicatorColor.FinishedSuccess) :
                /* fail */ (runInProgress ? ResultIndicatorColor.InProgressFailure : ResultIndicatorColor.FinishedFailure);
            string background = runIsSuccessful ? ResultIndicatorColor.BackgroundSuccess : ResultIndicatorColor.BackgroundFailure;

            _indicator.BackgroundColor = color;
            BackgroundColor = background;
        }

        /// <summary>
        /// Creates the section that displays that about box / framework title.
        /// </summary>
        private void CreateAbout()
        {
            _about = new Paragraph();
            _about.Font.Size = new FontUnit(16, UnitType.Pixel);
            _about.Margin.All = 0;
            _about.Padding.All = 0;
            Controls.Add(_about);
        }

        /// <summary>
        /// Creates the indicator area.
        /// </summary>
        private void CreateIndicator()
        {
            _indicator = new HtmlDiv();
            _indicator.Position.Bottom = _indicator.Position.Left = _indicator.Position.Right = 0;
            _indicator.Height = new Unit(12, UnitType.Pixel);
            _indicator.CssClass = TestColumnIndicator;
            _indicator.SetStyleAttribute(CssAttribute.Position, "absolute");
            Controls.Add(_indicator);
        }

        /// <summary>
        /// Styles the header.
        /// </summary>
        private void StylizeHeader()
        {
            Height = 34;
            SetStyleAttribute(CssAttribute.Position, "relative");
            Padding.All = 5;
            BackgroundColor = "#fff9d8";
            BorderWidth = 0;
            BorderWidthAdvanced.Bottom = 1;
            BorderStyle = BorderStyle.Dotted;
            BorderColor = "#ffe8cd";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\TestStyleProvider.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System;
    using System.Windows.Browser;
    using Microsoft.Silverlight.Testing.Html;

    /// <summary>
    /// Style provider for the test framework.
    /// </summary>
    public class TestStyleProvider : StyleProvider
    {
        /// <summary>
        /// Applies the test framework styles to the control.
        /// </summary>
        /// <param name="control">The control reference.</param>
        public override void ApplyStyle(HtmlControl control)
        {
            // For all controls, set the default font and size
            WebBrowserTestPage.SetDefaultFont(control);
            WebBrowserTestPage.SetDefaultFontSize(control);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\WebpageLogProviderBase.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System.Diagnostics.CodeAnalysis;
    using Microsoft.Silverlight.Testing.Harness;
    using Microsoft.Silverlight.Testing.UnitTesting.UI;

    /// <summary>
    /// Base class for Html-based web page providers, with utility methods 
    /// and optional style sheet injection.
    /// </summary>
    public abstract class WebpageLogProviderBase : LogProvider, ITestSettingsLogProvider
    {
        /// <summary>
        /// The key name for changing the resize behavior.
        /// </summary>
        private const string EnablePluginResizeKeyName = "enablePluginResize";

        /// <summary>
        /// The key name for a custom test column width.
        /// </summary>
        private const string TestColumnWidthKeyName = "testColumnWidth";

        /// <summary>
        /// Gets a value indicating what width to use for the HTML log.
        /// </summary>
        protected static int TestColumnWidth { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the plugin should be resized.
        /// </summary>
        protected static bool EnablePluginResize { get; private set; }

        /// <summary>
        /// The test page control.
        /// </summary>
        private static WebBrowserTestPage _testPage;

        /// <summary>
        /// Base constructor for the WebPageProvider.
        /// </summary>
        protected WebpageLogProviderBase()
        {
            EnablePluginResize = true;
            TestColumnWidth = WebBrowserTestPage.DefaultTestColumnWidth;
        }

        /// <summary>
        /// Gets the test page control.  There is only one (static) instance per 
        /// application/plugin.
        /// </summary>
        public static WebBrowserTestPage TestPage
        {
            get
            {
                if (_testPage == null)
                {
                    _testPage = new WebBrowserTestPage(WebBrowserTestPage.DefaultMinimumPluginWidth, WebBrowserTestPage.DefaultMinimumPluginHeight, TestColumnWidth, EnablePluginResize);
                }

                return _testPage;
            }
        }

        /// <summary>
        /// Gets the test column element.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "Provided here so that the static, single-column instance could be removed in the future easily.")]
        protected HtmlTestColumn TestColumn
        {
            get
            {
                return TestPage.TestColumn;
            }
        }

        /// <summary>
        /// Initializes the test harness.
        /// </summary>
        /// <param name="settings">The test harness settings object.</param>
        public virtual void Initialize(TestHarnessSettings settings)
        {
            // Look in the settings for the resize override
            string resizeString;
            if (settings.Parameters.TryGetValue(EnablePluginResizeKeyName, out resizeString))
            {
                bool value;
                if (bool.TryParse(resizeString, out value))
                {
                    EnablePluginResize = value;
                }
            }

            string widthString;
            if (settings.Parameters.TryGetValue(TestColumnWidthKeyName, out widthString))
            {
                int value;
                if (int.TryParse(widthString, out value))
                {
                    TestColumnWidth = value;
                }
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\WebpageHeaderLogProvider.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System.Windows.Browser;
    using Microsoft.Silverlight.Testing.Harness;
    using Microsoft.Silverlight.Testing.Html;
    using Microsoft.Silverlight.Testing.UnitTesting.UI;
    using Microsoft.Silverlight.Testing.UI;

    /// <summary>
    /// A log provider that operates on the live HtmlPage by logging very 
    /// high-level pass/fail status to the screen.
    /// </summary>
    public class WebpageHeaderLogProvider : WebpageLogProviderBase
    {
        /// <summary>
        /// Name to display in the header for the test harness or test product 
        /// name.
        /// </summary>
        private const string DefaultDisplayName = "Microsoft.Silverlight.Testing Framework";

        /// <summary>
        /// Gets or sets the display name.
        /// </summary>
        private string DisplayName { get; set; }

        /// <summary>
        /// The test column header control.
        /// </summary>
        private TestColumnHeader _control;

        /// <summary>
        /// Whether any failures have been found.
        /// </summary>
        private bool _hasFailed;

        /// <summary>
        /// Whether we've had any results at all.
        /// </summary>
        private bool _hasResults;

        /// <summary>
        /// Has a granular TestGroup completion been processed.
        /// </summary>
        private bool _hasFinished;

        /// <summary>
        /// Creates a new web page header provider.
        /// </summary>
        public WebpageHeaderLogProvider() : this(DefaultDisplayName) { }

        /// <summary>
        /// Creates a new web page header provider.
        /// </summary>
        /// <param name="displayName">The display name for the harness.</param>
        public WebpageHeaderLogProvider(string displayName)
            : base()
        {
            DisplayName = displayName;
        }

        /// <summary>
        /// Initializes the test harness.
        /// </summary>
        /// <param name="settings">The test harness settings object.</param>
        public override void Initialize(TestHarnessSettings settings)
        {
            base.Initialize(settings);

            RegisterLoggingHandlers();

            // Initializes the static provider control if it does not yet exist
            WebBrowserTestPage page = WebpageLogProviderBase.TestPage;

            // Creates and appends the header control
            _control = new TestColumnHeader(DisplayName);
            page.TestColumn.Controls.Add(_control);
        }

        /// <summary>
        /// Registers the conditional delegates.
        /// </summary>
        private void RegisterLoggingHandlers()
        {
            // Check for and result to results
            RegisterConditionalHandler(
                NotFailedButWithResults,
                delegate(LogMessage message)
                {
                    TestOutcome outcome = (TestOutcome)message[LogDecorator.TestOutcome];
                    _hasResults = true;
                    if (outcome != TestOutcome.Passed)
                    {
                        _hasFailed = true;
                        UpdateIndicator();
                    }
                    else if (_hasFailed == false)
                    {
                        UpdateIndicator();
                    }
                });

            // Record the completion of the test group

            // NOTE: This could be done at the harness level, but logs may not 
            // be processed by the harness provider post-completion, so a single
            // test group at least improves the experience some.
            RegisterConditionalHandler(
                MarksTestGroupCompletion,
                delegate(LogMessage message)
                {
                    _hasFinished = true;
                    UpdateIndicator();
                });
        }

        /// <summary>
        /// Conditional check, if the message has results and the current state 
        /// of the run, as tracked by this provider, is "pass".
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <returns>Returns true when the conditions are met.</returns>
        private bool NotFailedButWithResults(LogMessage message)
        {
            // A. Must be in a passing state
            // B. Must have results
            return (!_hasFailed && message.HasDecorator(LogDecorator.TestOutcome));
        }

        /// <summary>
        /// Conditional check, if the message is of a granular nature, a test 
        /// group, and in the finishing stage.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <returns>Returns true when the conditions are met.</returns>
        private bool MarksTestGroupCompletion(LogMessage message)
        {
            if (message.HasDecorators(LogDecorator.TestGranularity, LogDecorator.TestStage))
            {
                TestGranularity granularity = (TestGranularity)message[LogDecorator.TestGranularity];
                TestStage stage = (TestStage)message[LogDecorator.TestStage];

                bool ok = granularity == TestGranularity.TestGroup || granularity == TestGranularity.Harness;
                return ok && stage == TestStage.Finishing;
            }
            return false;
        }

        /// <summary>
        /// Alter the coloring to indicate the status.
        /// </summary>
        private void UpdateIndicator()
        {
            if (_hasResults)
            {
                _control.UpdateIndicatorColoring(!_hasFinished, !_hasFailed);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\WebBrowserTestPage.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System;
    using System.Windows.Browser;
    using Microsoft.Silverlight.Testing.Html;
    using Microsoft.Silverlight.Testing.UnitTesting.UI;
    using Microsoft.Silverlight.Testing.UI;

    /// <summary>
    /// A type that represents a web page used for test purposes of the current 
    /// Silverlight plugin.
    /// </summary>
    public class WebBrowserTestPage
    {
        /// <summary>
        /// The default minimum size of the plugin width.
        /// </summary>
        internal const int DefaultMinimumPluginWidth = 400;

        /// <summary>
        /// The default minimum size of the plugin height.
        /// </summary>
        internal const int DefaultMinimumPluginHeight = 280;

        /// <summary>
        /// The default width of the test column.
        /// </summary>
        internal const int DefaultTestColumnWidth = 370;

        /// <summary>
        /// Amount of padding to have between the column and the plugin. 
        /// Not adjustable.
        /// </summary>
        private const int ImplicitPadding = 10;

        /// <summary>
        /// The default font size to use in logging operations.
        /// </summary>
        public readonly static Unit DefaultFontSize = new Unit(12, UnitType.Pixel);

        /// <summary>
        /// Font used for text.
        /// </summary>
        public const string DefaultFontFamily = "Calibri, Arial, sans-serif";

        /// <summary>
        /// Font used to fixed width text.
        /// </summary>
        public const string DefaultFixedFontFamily = "Consolas, Courier New, courier";

        /// <summary>
        /// The set of default fonts.
        /// </summary>
        private static string[] _defaultFontFamilies;

        /// <summary>
        /// The set of default fixed fonts.
        /// </summary>
        private static string[] _defaultFixedFontFamilies;

        /// <summary>
        /// The Silverlight plugin HTML element.
        /// </summary>
        private HtmlControl _plugin;

        /// <summary>
        /// The container of the Silverlight plugin.
        /// </summary>
        private HtmlControl _pluginContainer;

        /// <summary>
        /// The primary test column.
        /// </summary>
        private HtmlTestColumn _testColumn;

        /// <summary>
        /// The minimum size of the plugin.
        /// </summary>
        private Size<int> _minimumPluginSize;

        /// <summary>
        /// The known size of the client.
        /// </summary>
        private Size<int> _browserClientSize;

        /// <summary>
        /// The current size allocated and calculated for the plugin.
        /// </summary>
        private Size<int> _pluginSize;

        /// <summary>
        /// The width allocated for the test column.
        /// </summary>
        private int _testColumnWidth;

        /// <summary>
        /// Initializes the HtmlTestPage Control.
        /// </summary>
        /// <param name="permitResizing">A value indicating whether to allow 
        /// the plugin and page to resize the contents.</param>
        public WebBrowserTestPage(bool permitResizing) : this(DefaultMinimumPluginWidth, DefaultMinimumPluginHeight, DefaultTestColumnWidth, permitResizing) { }

        /// <summary>
        /// Initializes the HtmlTestPage Control with a specific minimum plugin 
        /// size requirement.
        /// </summary>
        /// <param name="minimumPluginWidth">The minimum width that the plugin 
        /// can be sized to.</param>
        /// <param name="minimumPluginHeight">The minimum height that the plugin
        /// can be sized to.</param>
        /// <param name="testColumnWidth">The width to allocate for the test 
        /// column.</param>
        /// <param name="permitResizing">A value indicating whether to allow 
        /// the plugin and page to resize the contents.</param>
        public WebBrowserTestPage(int minimumPluginWidth, int minimumPluginHeight, int testColumnWidth, bool permitResizing)
        {
            PrepareApplicationFonts();

            _testColumnWidth = testColumnWidth;
            _minimumPluginSize = new Size<int>(minimumPluginWidth, minimumPluginHeight);
            _pluginContainer = new HtmlControl(HtmlPage.Plugin.Parent);
            _plugin = new HtmlControl(HtmlPage.Plugin);

            CalculatePreferredPluginSize();

            if (permitResizing)
            {
                ResizeSilverlightPlugin();
            }

            // Appended directly into the document body
            _testColumn = new HtmlTestColumn(_testColumnWidth, ImplicitPadding, _browserClientSize.Height);
            HtmlPage.Document.Body.AppendChild(_testColumn);
        }

        /// <summary>
        /// Sets the font of the control to be the default font for the test 
        /// framework.
        /// </summary>
        /// <param name="control">The managed HTML control.</param>
        public static void SetDefaultFont(HtmlControl control)
        {
            control.Font.Names = _defaultFontFamilies;
        }

        /// <summary>
        /// Sets the font of the control to be the default fixed-size font for 
        /// the test framework.
        /// </summary>
        /// <param name="control">The managed HTML control.</param>
        public static void SetDefaultFixedFont(HtmlControl control)
        {
            control.Font.Names = _defaultFixedFontFamilies;
        }

        /// <summary>
        /// Sets the font size of the control to be the default size for the 
        /// test framework.
        /// </summary>
        /// <param name="control">The managed HTML control.</param>
        public static void SetDefaultFontSize(HtmlControl control)
        {
            control.Font.Size = new FontUnit(DefaultFontSize);
        }

        /// <summary>
        /// Prepares the fonts for use in the HTML-side of the test framework's
        /// application.
        /// </summary>
        private static void PrepareApplicationFonts()
        {
            FontNamesConverter fonts = new FontNamesConverter();
            _defaultFontFamilies = (string[])fonts.ConvertFromString(DefaultFontFamily);
            _defaultFixedFontFamilies = (string[])fonts.ConvertFromString(DefaultFixedFontFamily);

            HtmlControl.StyleProvider = new TestStyleProvider();
        }

        /// <summary>
        /// Calculate the size of the Silverlight control to meet a set of 
        /// hard-coded dimensions and resize the plugin and plugin element.
        /// </summary>
        private void CalculatePreferredPluginSize()
        {
            _browserClientSize = new Size<int>
            {
                Width = (int)BrowserScreenInformation.ClientWidth,
                Height = (int)BrowserScreenInformation.ClientHeight
            };

            int actualWidth = _browserClientSize.Width - ImplicitPadding - _testColumnWidth;
            int controlWidth = actualWidth < _minimumPluginSize.Width ? _minimumPluginSize.Width : actualWidth;
            int actualHeight = _browserClientSize.Height - ImplicitPadding;
            int controlHeight = actualHeight < _minimumPluginSize.Height ? _minimumPluginSize.Height : actualHeight;
            _pluginSize = new Size<int>(controlWidth, controlHeight);

            int columnSizing = _browserClientSize.Width - controlWidth - ImplicitPadding;
            if (columnSizing < _testColumnWidth)
            {
                // Shrink the test column
                _testColumnWidth = columnSizing < 0 ? 0 : columnSizing;
            }
        }

        /// <summary>
        /// Gets the plugin element.
        /// </summary>
        public HtmlControl Plugin
        {
            get
            {
                return _plugin;
            }
        }

        /// <summary>
        /// Gets the container of the plugin object.
        /// </summary>
        public HtmlControl PluginContainer
        {
            get
            {
                return _pluginContainer;
            }
        }

        /// <summary>
        /// Gets the test column.
        /// </summary>
        public HtmlTestColumn TestColumn
        {
            get
            {
                return _testColumn;
            }
        }

        /// <summary>
        /// Resize the plugin using the preferred sizes.
        /// </summary>
        private void ResizeSilverlightPlugin()
        {
            Plugin.Width = _pluginSize.Width;
            Plugin.Height = _pluginSize.Height;
            PluginContainer.Width = Plugin.Width;
            PluginContainer.Height = Plugin.Height;

            // TODO: update the attach and onresize code here [see: below]
        }

        ////HtmlPage.Window.AttachEvent(
        ////    "onresize",
        ////    delegate(object sender, HtmlEventArgs ea)
        ////    {
        ////        // previous size
        ////        int oldWidth = _clientSpace.Width;
        ////        int newWidth = (int)((double)HtmlPage.Document.Body.GetProperty("clientWidth"));

        ////        if (newWidth < oldWidth)
        ////        {
        ////            int change = oldWidth - newWidth;

        ////            // set plugin size
        ////            _pluginSpace.Width = Math.Max(0, _pluginSpace.Width - change);
        ////            pluginElement.SetStyleAttribute("width", AsPixels(_pluginSpace.Width));
        ////            _clientSpace.Width = newWidth;
        ////        }
        ////    });
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\WebpageLogProvider.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System;
    using System.Windows.Browser;
    using Microsoft.Silverlight.Testing;
    using Microsoft.Silverlight.Testing.Harness;
    using Microsoft.Silverlight.Testing.Html;

    /// <summary>
    /// A log provider that operates on the live HtmlPage by logging test 
    /// harness information to the screen.
    /// </summary>
    public class WebpageLogProvider : WebpageLogProviderBase
    {
        /// <summary>
        /// Constant, the right angle quote in HTML.
        /// </summary>
        private const string RightAngleQuote = "&raquo;";

        /// <summary>
        /// Div used for the log of this instance.
        /// </summary>
        private HtmlDiv _myLog;

        /// <summary>
        /// Instantiate a new WebpageLogProvider class.
        /// </summary>
        public WebpageLogProvider()
        {
        }

        /// <summary>
        /// Initializes the test harness.
        /// </summary>
        /// <param name="settings">The test harness settings object.</param>
        public override void Initialize(TestHarnessSettings settings)
        {
            base.Initialize(settings);

            RegisterLogHandlers();

            // Initializes the static provider control if it does not yet exist
            WebBrowserTestPage page = WebpageLogProviderBase.TestPage;

            // Simple div for logging
            _myLog = new HtmlDiv();
            _myLog.Padding.All = 0;
            page.TestColumn.Controls.Add(_myLog);
        }

        /// <summary>
        /// Gets a reference to the HtmlElement that contains the running log 
        /// for this instance.
        /// </summary>
        protected HtmlDiv LogContainer
        {
            get
            {
                return _myLog;
            }
        }

        /// <summary>
        /// Register the log handlers for this provider.
        /// </summary>
        private void RegisterLogHandlers()
        {
            RegisterGranularHandler();
            RegisterInformationHandler();
            RegisterWarningHandler();
        }

        /// <summary>
        /// Register an informational message handler.
        /// </summary>
        protected void RegisterInformationHandler()
        {
            RegisterMessageTypeHandler(LogMessageType.Information, ProcessInformation);
        }

        /// <summary>
        /// Register a warning handler.
        /// </summary>
        protected void RegisterWarningHandler()
        {
            RegisterMessageTypeHandler(LogMessageType.Warning, ProcessWarning);
        }

        /// <summary>
        /// Register a granular handler.
        /// </summary>
        protected void RegisterGranularHandler()
        {
            RegisterConditionalHandler(
                IsGranularMessage,
                delegate(LogMessage message)
                {
                    ProcessGranularEvent(message);
                });
        }

        /// <summary>
        /// Conditional check for the granularity decorator.
        /// </summary>
        /// <param name="message">The log message.</param>
        /// <returns>Returns true if the condition is met.</returns>
        private bool IsGranularMessage(LogMessage message)
        {
            return (message.HasDecorator(LogDecorator.TestGranularity));
        }

        /// <summary>
        /// How to process any remaining messages.
        /// </summary>
        /// <param name="message">The log message.</param>
        protected override void ProcessRemainder(LogMessage message)
        {
            AppendFixedText(message.ToString());
        }

        /// <summary>
        /// Appends text to the log, in a fixed-width font.
        /// </summary>
        /// <param name="value">The string to append.</param>
        protected void AppendFixedText(string value)
        {
            HtmlSpan span = new HtmlSpan();
            WebBrowserTestPage.SetDefaultFixedFont(span);
            WebBrowserTestPage.SetDefaultFontSize(span);
            span.ForegroundColor = Color.LightGray;
            span.InnerHtml = value;

            _myLog.Controls.Add(span);
            _myLog.Controls.Add(new HtmlLineBreak());
        }

        /// <summary>
        /// Display the information associated with a warning message.
        /// </summary>
        /// <remarks>This method does not do anything with an associated 
        /// Exception object stored in the message.</remarks>
        /// <param name="logMessage">Message to process.</param>
        protected virtual void ProcessWarning(LogMessage logMessage)
        {
            AddSimpleMessage(RightAngleQuote + " " + logMessage.Message, Color.Black, Color.Yellow);
        }

        /// <summary>
        /// Display simple information in the log.
        /// </summary>
        /// <param name="logMessage">Message to process.</param>
        protected virtual void ProcessInformation(LogMessage logMessage)
        {
            AddSimpleMessage(RightAngleQuote + " " + logMessage.Message, Color.DarkGray);
        }

        /// <summary>
        /// Appends simple text to the log.
        /// </summary>
        /// <param name="message">The message, HTML permitted.</param>
        protected void AddSimpleMessage(string message)
        {
            AddSimpleMessage(message, null, null);
        }

        /// <summary>
        /// Appends simple text to the log.
        /// </summary>
        /// <param name="message">The message, HTML permitted.</param>
        /// <param name="foregroundColor">The optional foreground color, as a 
        /// string value.</param>
        protected void AddSimpleMessage(string message, string foregroundColor)
        {
            AddSimpleMessage(message, foregroundColor, null);
        }

        /// <summary>
        /// Appends simple text to the log.
        /// </summary>
        /// <param name="message">The message, HTML permitted.</param>
        /// <param name="foregroundColor">The optional foreground color, as a 
        /// string value.</param>
        /// <param name="backgroundColor">The optional background color, as a 
        /// string value.</param>
        protected void AddSimpleMessage(string message, string foregroundColor, string backgroundColor)
        {
            HtmlDiv div = new HtmlDiv();
            div.InnerHtml = message;
            div.Padding.All = 3;
            if (backgroundColor != null)
            {
                div.BackgroundColor = backgroundColor;
            }
            if (foregroundColor != null)
            {
                div.ForegroundColor = foregroundColor;
            }
            this._myLog.Controls.Add(div);
        }

        /// <summary>
        /// Process an event with granular properties.
        /// </summary>
        /// <param name="l">The log message object.</param>
        private void ProcessGranularEvent(LogMessage l)
        {
            TestGranularity granularity = (TestGranularity)l[LogDecorator.TestGranularity];
            HtmlDiv div = new HtmlDiv();
            div.InnerHtml = l.Message;
            div.Padding.All = 2;

            switch (granularity)
            {
                case TestGranularity.Harness:
                    div.BackgroundColor = Color.DarkGray;
                    div.ForegroundColor = Color.VeryLightGray;
                    break;

                case TestGranularity.TestScenario:
                case TestGranularity.Test:
                    break;

                case TestGranularity.TestGroup:
                    div.Font.Bold = true;
                    break;

                default:
                    div = null;
                    this.AppendFixedText(l.ToString());
                    break;
            }
            if (div != null)
            {
                this._myLog.Controls.Add(div);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\Utilities\FileStorage.cs ===
﻿// <copyright file="FileStorage.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Filip Skakun</author>
// <email>filip.skakun@gmail.com</email>
// <date>2010-02-18</date>
// <summary>Contains the class definition for FileStorage class.</summary>
namespace Leet.Silverlight.XLiveWeb.Test.Utilities
{
    using System.IO;
    using System.IO.IsolatedStorage;

    /// <summary>
    /// Static methods container for Isolated Storage access
    /// </summary>
    internal static class FileStorage
    {
        /// <summary>
        /// Saves the given string to a file in isolated storage.
        /// </summary>
        /// <param name="fileName">Name of the file.</param>
        /// <param name="data">The data.</param>
        internal static void SaveStringToFileInIsolatedStorage(string fileName, string data)
        {
            using (IsolatedStorageFile isf = IsolatedStorageFile.GetUserStoreForApplication())
            {
                using (IsolatedStorageFileStream isfs = new IsolatedStorageFileStream(fileName, FileMode.Create, isf))
                {
                    using (StreamWriter sw = new StreamWriter(isfs))
                    {
                        sw.Write(data);
                        sw.Close();
                    }
                }
            }
        }

        /// <summary>
        /// Loads a string from a file in isolated storage.
        /// </summary>
        /// <param name="fileName">Name of the file.</param>
        /// <returns></returns>
        internal static string LoadStringFromFileInIsolatedStorage(string fileName)
        {
            using (IsolatedStorageFile isf = IsolatedStorageFile.GetUserStoreForApplication())
            {
                using (IsolatedStorageFileStream isfs = new IsolatedStorageFileStream(fileName, FileMode.Open, isf))
                {
                    using (StreamReader sr = new StreamReader(isfs))
                    {
                        return sr.ReadToEnd();
                    }
                }
            }
        }

        /// <summary>
        /// Deletes a file in isolated storage.
        /// </summary>
        /// <param name="fileName">Name of the file.</param>
        internal static void DeleteFileFromIsolatedStorage(string fileName)
        {
            using (IsolatedStorageFile isf = IsolatedStorageFile.GetUserStoreForApplication())
            {
                if (isf.FileExists(fileName))
                {
                    isf.DeleteFile(fileName);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Silverlight.XLiveWeb.Test\UI\UnitTestWebpageLog.cs ===
﻿namespace Leet.Silverlight.XLiveWeb.Test.UI
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Windows.Browser;
    using Microsoft.Silverlight.Testing.Harness;
    using Microsoft.Silverlight.Testing.Html;
    using Microsoft.Silverlight.Testing.UI;
    using Microsoft.Silverlight.Testing.UnitTesting.Harness;
    using Microsoft.Silverlight.Testing.UnitTesting.Metadata;
    using Microsoft.Silverlight.Testing.UnitTesting.UI;

    /// <summary>
    /// A web page log provider that is specialized for the unit test framework.
    /// </summary>
    public class UnitTestWebpageLog : WebpageLogProvider
    {
        /// <summary>
        /// String ellipsis.
        /// </summary>
        private const string Ellipsis = "...";

        /// <summary>
        /// The maximum number of characters to display in a name without using 
        /// an ellipsis.
        /// </summary>
        private const int MaximumNameDisplayLength = 52;

        /// <summary>
        /// The associated start element for a test method.
        /// </summary>
        private IDictionary<ITestMethod, HtmlContainerControl> _startElements;

        /// <summary>
        /// Html control that shows the current test method name and other 
        /// information specific to unit testing.
        /// </summary>
        private CurrentTestStatus _statusDisplay;

        /// <summary>
        /// A web page control that displays a summary and links to failures.
        /// </summary>
        private FailureSummaryControl _failureSummary;

        /// <summary>
        /// The number of scenarios encountered.
        /// </summary>
        private int _scenarioCounter;

        /// <summary>
        /// A value indicating whether the copy results link has been added 
        /// to the page yet.
        /// </summary>
        private bool _copyResultsVisible;

        /// <summary>
        /// The most recent harness object.
        /// </summary>
        private HtmlContainerControl _mostRecentHarness;

        /// <summary>
        /// The test run's progress bar.
        /// </summary>
        private TestRunProgress _progressBar;

        /// <summary>
        /// Display progress information and/or elapsed time.
        /// </summary>
        private HtmlDiv _progressText;

        /// <summary>
        /// The unit test harness.
        /// </summary>
        private UnitTestHarness _unitTestHarness;

        /// <summary>
        /// When the test assembly starts.
        /// </summary>
        private DateTime _start;

        /// <summary>
        /// When the test assembly finishes.
        /// </summary>
        private DateTime _end;

        /// <summary>
        /// Creates a new provider for displaying results on the web page, with 
        /// specialized knowledge of the unit test system.
        /// </summary>
        public UnitTestWebpageLog()
            : base()
        {
        }

        /// <summary>
        /// Initializes the test harness.
        /// </summary>
        /// <param name="settings">The test harness settings object.</param>
        public override void Initialize(TestHarnessSettings settings)
        {
            base.Initialize(settings);

            InitializeComponent();
        }

        /// <summary>
        /// Initializes the component.
        /// </summary>
        private void InitializeComponent()
        {
            _startElements = new Dictionary<ITestMethod, HtmlContainerControl>();
            _statusDisplay = new CurrentTestStatus();
            _statusDisplay.Fail = _statusDisplay.Total = 0;
            _failureSummary = new FailureSummaryControl();
            _progressText = new HtmlDiv();
            _progressText.Margin.Bottom = 4;

            LogContainer.Controls.Add(_statusDisplay);
            PlaceProgressBar();
            LogContainer.Controls.Add(_progressText);
            LogContainer.Controls.Add(_failureSummary);

            RegisterLogHandlers();
        }

        /// <summary>
        /// Places the progress bar.  If we can attach inside the existing 
        /// header, then insert inside that - otherwise, the progress bar 
        /// is just inserted inside the test column.
        /// </summary>
        private void PlaceProgressBar()
        {
            _progressBar = new TestRunProgress();
            _progressBar.Height = 12;

            HtmlElement hookupElement = null;
            ScriptObjectCollection hcc = HtmlPage.Document.GetElementsByTagName("div");
            for (int i = 0; i < hcc.Count; ++i)
            {
                HtmlElement htmlElement = hcc[i] as HtmlElement;
                if (htmlElement != null)
                {
                    if (htmlElement.CssClass == TestColumnHeader.TestColumnIndicator)
                    {
                        hookupElement = htmlElement;
                        break;
                    }
                }
            }
            if (hookupElement == null)
            {
                LogContainer.Controls.Add(_progressBar);
            }
            else
            {
                hookupElement.AppendChild(_progressBar);
            }
        }

        /// <summary>
        /// Register the handling conditions for log messages in the unit test 
        /// web page's log provider.
        /// </summary>
        private void RegisterLogHandlers()
        {
            ClearConditionalHandlers();
            ClearMessageTypeHandlers();

            // From the parent
            RegisterWarningHandler();
            RegisterInformationHandler();

            // Our specific handlers
            RegisterConditionalHandler(UnitTestMessageConditional.IsUnitTestEndMessage, ProcessEndMessage);
            RegisterConditionalHandler(UnitTestMessageConditional.IsExceptionLogMessage, ProcessException);
            RegisterConditionalHandler(UnitTestMessageConditional.IsUnitTestStartMessage(UnitTestLogDecorator.UnitTestHarness), UpdateAndStart(UnitTestHarnessStart));
            RegisterConditionalHandler(UnitTestMessageConditional.IsUnitTestStartMessage(UnitTestLogDecorator.TestAssemblyMetadata), UpdateAndStart(TestAssemblyStart));
            RegisterConditionalHandler(UnitTestMessageConditional.IsUnitTestStartMessage(UnitTestLogDecorator.TestClassMetadata), UpdateAndStart(TestClassStart));
            RegisterConditionalHandler(UnitTestMessageConditional.IsUnitTestStartMessage(UnitTestLogDecorator.TestMethodMetadata), UpdateAndStart(TestMethodStart));

            RegisterConditionalHandler(UnitTestMessageConditional.HasUnitTestOutcome, ProcessResult);
            RegisterConditionalHandler(UnitTestMessageConditional.IsIgnoreMessage, ProcessIgnoreMessage);
            RegisterConditionalHandler(UnitTestMessageConditional.IsIncorrectExceptionLogMessage, ProcessIncorrectException);
            RegisterConditionalHandler(UnitTestMessageConditional.IsKnownBug, ProcessBug);
            RegisterMessageTypeHandler(
                LogMessageType.TestInfrastructure,
                delegate(LogMessage message)
                {
                    // Update all infrastructure messages except for overall
                    // status messages
                    if (message.Decorators != null && message.Decorators.ContainsKey("UpdateOverallStatus"))
                    {
                        _statusDisplay.UpdateStatus(message.Message);
                    }
                });
        }

        /// <summary>
        /// Process the log of an exception.
        /// </summary>
        /// <param name="logMessage">The log message.</param>
        protected virtual void ProcessException(LogMessage logMessage)
        {
        }

        /// <summary>
        /// Process the end message.
        /// </summary>
        /// <param name="logMessage">The log message object.</param>
        private void ProcessEndMessage(LogMessage logMessage)
        {
            //// TestStage stage = (TestStage)logMessage[LogDecorator.TestStage];
            if (!logMessage.HasDecorator(LogDecorator.TestGranularity))
            {
                return;
            }

            TestGranularity gran = (TestGranularity)logMessage[LogDecorator.TestGranularity];
            if (gran == TestGranularity.TestGroup)
            {
                CompleteTestGroup();
            }
        }

        /// <summary>
        /// A method that copies the result details into the clipboard and 
        /// displays an alert. On IE-only does the message appear.
        /// </summary>
        /// <param name="text">The details to copy.</param>
        internal static void CopyResultDetails(string text)
        {
            ScriptObject clipboardData = HtmlPage.Window.GetProperty("clipboardData") as ScriptObject;
            if (clipboardData != null)
            {
                bool success = (bool)clipboardData.Invoke("setData", "text", text);
                if (success)
                {
                    HtmlPage.Window.Alert("Results were copied to the clipboard, and will now be displayed in a message box as well.");
                }
            }

            HtmlPage.Window.Alert(text);
        }

        /// <summary>
        /// Method to show the closure of a test group at runtime.
        /// </summary>
        private void CompleteTestGroup()
        {
            _end = DateTime.Now;
            _statusDisplay.UpdateDetails(String.Empty);
            _progressBar.PercentComplete = 0;

            if (_scenarioCounter > 0)
            {
                TimeSpan diff = new TimeSpan(_end.Ticks - _start.Ticks);
                int average = (int)diff.TotalMilliseconds / _scenarioCounter;
                TimeSpan tsd = new TimeSpan(0, 0, 0, 0, average);
                string averagePerTest = ElapsedReadableTime(tsd);
                _progressText.InnerHtml = String.Format(CultureInfo.CurrentCulture, "Running {0} " + "test".Plural(_scenarioCounter) + " took " + ElapsedReadableTime(_start, _end) + "<br />({1} per test method on average)", _scenarioCounter, averagePerTest);
            }
            _scenarioCounter = 0;

            HtmlContainerControl done = new HtmlDiv();
            HtmlAnchor close = new HtmlAnchor(
                "(Close)",
                delegate(object sender, HtmlEventArgs e)
                {
                    HtmlPage.Window.Invoke("close");
                });
            close.ForegroundColor = Color.LightGray;

            done.InnerHtml = "Test run complete ";
            done.Controls.Add(close);

            if (!_copyResultsVisible && _statusDisplay.Fail > 0)
            {
                _copyResultsVisible = true;

                // Attempt to see if the provider is setup
                foreach (LogProvider lp in _unitTestHarness.LogProviders)
                {
                    TextFailuresLogProvider txt = lp as TextFailuresLogProvider;
                    if (txt != null)
                    {
                        HtmlAnchor copy = new HtmlAnchor("(Copy all failing results)", (sender, args) => CopyResultDetails(txt.GetFailuresLog()));
                        copy.Margin.Left = 8;
                        copy.ForegroundColor = Color.LightGray;
                        done.Controls.Add(copy);
                        break;
                    }
                }
            }

            done.Padding.All = 3;
            done.BackgroundColor = Color.DarkGray;
            done.ForegroundColor = Color.VeryLightGray;
            done.SetStyleAttribute(CssAttribute.MarginTop, 4);

            _statusDisplay.ChangeToFinalStyle();
            LogContainer.Controls.Add(done);
        }

        /// <summary>
        /// Returns a human-readable formatting of the time different between 
        /// two DateTime instances.
        /// </summary>
        /// <param name="start">The starting time.</param>
        /// <param name="finish">The finishing time.</param>
        /// <returns>Returns a human-readable string.</returns>
        public static string ElapsedReadableTime(DateTime start, DateTime finish)
        {
            TimeSpan ts = new TimeSpan(finish.Ticks - start.Ticks);
            return ElapsedReadableTime(ts);
        }

        /// <summary>
        /// Returns a human-readable formatting of the time different between 
        /// two DateTime instances.
        /// </summary>
        /// <param name="ts">The time span instance.</param>
        /// <returns>Returns a human-readable string.</returns>
        public static string ElapsedReadableTime(TimeSpan ts)
        {
            List<string> parts = new List<string>();

            if (ts.Milliseconds > 0 && ts.Days == 0 && ts.Hours == 0 && ts.Minutes == 0)
            {
                parts.Add(ts.Milliseconds.ToString(CultureInfo.CurrentCulture) + " ms");
            }
            if (ts.Seconds > 0 && ts.Days == 0 && ts.Hours == 0)
            {
                parts.Add(ts.Seconds.ToString(CultureInfo.CurrentCulture) + " second".Plural(ts.Seconds));
            }
            if (ts.Minutes > 0)
            {
                parts.Add(ts.Minutes.ToString(CultureInfo.CurrentCulture) + " minute".Plural(ts.Minutes));
            }
            if (ts.Hours > 0)
            {
                parts.Add(ts.Hours.ToString(CultureInfo.CurrentCulture) + " hour".Plural(ts.Hours));
            }
            if (ts.Days > 0)
            {
                parts.Add(ts.Days.ToString(CultureInfo.CurrentCulture) + " day".Plural(ts.Days));
            }
            parts.Reverse();
            return String.Join(" ", parts.ToArray());
        }

        /// <summary>
        /// Assembly start code.
        /// </summary>
        /// <param name="l">The log message.</param>
        private void TestAssemblyStart(LogMessage l)
        {
            _statusDisplay.RevertFinalStyle();
            _start = DateTime.Now;

            HtmlPage.Document.SetProperty("title", String.Format(CultureInfo.InvariantCulture, "{0} - Test Run", l[LogDecorator.NameProperty]));
            if (_mostRecentHarness != null)
            {
                _mostRecentHarness.InnerHtml = "&nbsp;<strong>" + l[LogDecorator.NameProperty] + "</strong>";
            }
        }

        /// <summary>
        /// Test method start code.
        /// </summary>
        /// <param name="l">The log message.</param>
        private void TestMethodStart(LogMessage l)
        {
            ITestMethod method = (ITestMethod)l[UnitTestLogDecorator.TestMethodMetadata];
            string name = TruncateNameIfNeeded(l.Message);
            string details = string.IsNullOrEmpty(method.Description) ? l.Message : l.Message + ": " + method.Description;

            HtmlContainerControl elem = CreateText();
            HtmlAnchor anchor = new HtmlAnchor();
            anchor.InnerHtml = name;
            anchor.Title = details;
            anchor.Font.Underline = false;
            anchor.SetStyleAttribute(CssAttribute.BorderBottom, "1px dotted #aaa");
            elem.Controls.Add(anchor);
            // elem.BackgroundColor = Color.White;
            _startElements[method] = elem;

            LogContainer.Controls.Add(elem);
        }

        /// <summary>
        /// Returns either the full string, or a truncated version with an 
        /// ellipsis, if needed.
        /// </summary>
        /// <param name="name">The name string.</param>
        /// <returns>Returns the updated string.</returns>
        internal static string TruncateNameIfNeeded(string name)
        {
            return name.Length > MaximumNameDisplayLength ? name.Substring(0, MaximumNameDisplayLength) + Ellipsis : name;
        }

        /// <summary>
        /// Returns either the full string, or a truncated version with an 
        /// ellipsis, if needed.
        /// </summary>
        /// <param name="name">The name string.</param>
        /// <returns>Returns the updated string.</returns>
        internal static string TruncateNameIfNeededWithHover(string name)
        {
            return name.Length > MaximumNameDisplayLength ? "<span title=\"" + name + "\">" + name.Substring(0, MaximumNameDisplayLength) + Ellipsis + "</span>" : name;
        }

        /// <summary>
        /// Test class start code.
        /// </summary>
        /// <param name="l">Log message.</param>
        private void TestClassStart(LogMessage l)
        {
            //// ITestClass tclass = (ITestClass)l[UnitTestLogDecorator.TestClassMetadata];
            HtmlContainerControl e = CreateText();
            e.InnerHtml = "<em>" + l.Message + "</em>";
            e.BackgroundColor = Color.Manila;
            e.SetStyleAttribute(CssAttribute.Border, "1px solid " + Color.ManilaBorder);
            e.Font.Bold = true;
            e.ForegroundColor = Color.DarkGray;
            e.SetStyleAttribute("borderBottom", "2px solid " + Color.Tan);
            e.Margin.Top = 3;
            LogContainer.Controls.Add(e);

            _statusDisplay.UpdateDetails(TruncateNameIfNeeded(l.Message));
        }

        /// <summary>
        /// Unit test harness starting message.
        /// </summary>
        /// <param name="l">Log message object.</param>
        private void UnitTestHarnessStart(LogMessage l)
        {
            _unitTestHarness = (UnitTestHarness)l[UnitTestLogDecorator.UnitTestHarness];
            string displayName = "Unit Test Run for ";
            HtmlContainerControl harness = new HtmlDiv();
            harness.InnerHtml = displayName;
            harness.Padding.All = 3;
            harness.BackgroundColor = Color.DarkGray;
            harness.ForegroundColor = Color.VeryLightGray;
            _mostRecentHarness = new HtmlSpan();
            _mostRecentHarness.ForegroundColor = Color.White;
            harness.Controls.Add(_mostRecentHarness);
            LogContainer.Controls.Add(harness);
        }

        /// <summary>
        /// Updates the status display for any log message that has a 
        /// name decorator.
        /// </summary>
        /// <param name="l">The log message object.</param>
        private void UpdateStatusDisplay(LogMessage l)
        {
            if (l.HasDecorator(LogDecorator.NameProperty))
            {
                string name = (string)l[LogDecorator.NameProperty];
                _statusDisplay.UpdateStatus(TruncateNameIfNeeded(name));
            }
        }

        /// <summary>
        /// A wrapper that both updates the status and then calls the start 
        /// message handler.
        /// </summary>
        /// <param name="action">The customized handler for the start message.</param>
        /// <returns>Returns an aggregate action that performs both actions.</returns>
        private Action<LogMessage> UpdateAndStart(Action<LogMessage> action)
        {
            return delegate(LogMessage l)
            {
                UpdateStatusDisplay(l);
                action(l);
            };
        }

        /// <summary>
        /// Increments the scenario counter, which includes ignored tests.
        /// </summary>
        private void IncrementScenarioCounter()
        {
            ++_scenarioCounter;
            if (_unitTestHarness != null)
            {
                _progressBar.PercentComplete = _unitTestHarness.TestMethodCount <= 0 ? 0 : Convert.ToInt32(_scenarioCounter * 100 / _unitTestHarness.TestMethodCount);
                _progressText.InnerText = String.Format(System.Globalization.CultureInfo.CurrentCulture, "{0} of {1} test methods complete", _scenarioCounter.ToString(CultureInfo.CurrentCulture), _unitTestHarness.TestMethodCount.ToString(CultureInfo.CurrentCulture));
            }
        }

        /// <summary>
        /// Search in a container control for the first child element of a 
        /// particular type.
        /// </summary>
        /// <param name="container">The container control.</param>
        /// <typeparam name="CONTROL_TYPE">The control type to search for.</typeparam>
        /// <returns>Returns null or the first child element that matches.</returns>
        private static CONTROL_TYPE FindFirstChildElement<CONTROL_TYPE>(HtmlContainerControl container)
            where CONTROL_TYPE : HtmlControlBase
        {
            Type type = typeof(CONTROL_TYPE);
            foreach (HtmlControlBase control in container.Controls)
            {
                if (type.IsInstanceOfType(control))
                {
                    return (CONTROL_TYPE)control;
                }
            }

            return null;
        }

        /// <summary>
        /// Process a UTF result message.
        /// </summary>
        /// <param name="logMessage">The log message object.</param>
        private void ProcessResult(LogMessage logMessage)
        {
            if (logMessage.HasDecorator(UnitTestLogDecorator.TestMethodMetadata))
            {
                ScenarioResult result = (ScenarioResult)logMessage[UnitTestLogDecorator.ScenarioResult];
                TestOutcome outcome = result.Result;
                ITestMethod method = result.TestMethod;
                ITestClass test = result.TestClass;

                if (_startElements.ContainsKey(method))
                {
                    HtmlContainerControl elem = _startElements[method];
                    ++_statusDisplay.Total;
                    IncrementScenarioCounter();

                    switch (outcome)
                    {
                        case TestOutcome.Passed:
                        case TestOutcome.PassedButRunAborted:
                            break;
                        case TestOutcome.Inconclusive:
                        case TestOutcome.Timeout:
                        case TestOutcome.Failed:
                            elem.BackgroundColor = Color.Red;
                            elem.ForegroundColor = Color.White;
                            elem.Font.Bold = true;
                            ++_statusDisplay.Fail;

                            HtmlContainerControl nextSpan = CreateText(/* isDiv */ false);
                            nextSpan.SetStyleAttribute(CssAttribute.Position, "absolute");
                            nextSpan.SetStyleAttribute(CssAttribute.Right, new Unit(10));
                            elem.Controls.Add(nextSpan);

                            _failureSummary.AddFailure(test, method, nextSpan);
                            break;
                        default:
                            break;
                    }
                    _startElements.Remove(method);

                    // Hook up the details inspection control to the name
                    HtmlAnchor anchor = FindFirstChildElement<HtmlAnchor>(elem);
                    if (anchor != null)
                    {
                        ResultInspector inspector = new ResultInspector(result);
                        LogContainer.Controls.Add(inspector);
                        anchor.Click += (sender, args) => inspector.ToggleDropDown();
                        anchor.SetStyleAttribute(CssAttribute.Cursor, "hand");
                    }
                }
            }
        }

        /// <summary>
        /// Process [Bug(...)].
        /// </summary>
        /// <param name="l">A KnownBugLogMessage object.</param>
        private void ProcessBug(LogMessage l)
        {
            HtmlContainerControl container = new HtmlDiv();
            container.Padding.All = 4;
            container.BackgroundColor = Color.AnotherLightGray;

            HtmlContainerControl header = new HtmlDiv();
            header.InnerHtml = "This test has a known issue:";

            HtmlContainerControl message = CreateText();
            message.BorderStyle = BorderStyle.Solid;
            message.BorderWidth = 1;
            message.BorderColor = Color.VeryLightGray;
            message.BackgroundColor = Color.White;
            message.InnerHtml = l.Message;
            message.Padding.All = 2;
            container.Padding.All = 2;
            message.Margin.All = 2;

            container.Controls.Add(header);
            container.Controls.Add(message);
            LogContainer.Controls.Add(container);
        }

        /// <summary>
        /// Process [Ignore].
        /// </summary>
        /// <param name="l">The Ignore message.</param>
        private void ProcessIgnoreMessage(LogMessage l)
        {
            IncrementScenarioCounter();

            string name = (string)l[LogDecorator.NameProperty];
            TestGranularity gran = (TestGranularity)l[LogDecorator.TestGranularity];
            string extra = gran == TestGranularity.Test ? " (test class)" : String.Empty;

            HtmlContainerControl ignore = CreateText();
            ignore.InnerHtml = name + extra;
            ignore.ForegroundColor = Color.LightGray;
            ignore.Font.Strikeout = true;
            LogContainer.Controls.Add(ignore);
        }

        /// <summary>
        /// Process an Exception that was not the expected Exception type.
        /// </summary>
        /// <param name="l">The log message.</param>
        private void ProcessIncorrectException(LogMessage l)
        {
            string html = l.ToString();
            //html += l.Decorators

            HtmlContainerControl text = CreateText();
            text.InnerHtml = html;
            text.BackgroundColor = Color.Manila;
            text.SetStyleAttribute(CssAttribute.Border, "1px solid " + Color.ManilaBorder);
            text.ForegroundColor = Color.DarkGray;
            LogContainer.Controls.Add(text);
        }

        /// <summary>
        /// Creates a new container control for text.
        /// </summary>
        /// <returns>Returns a new container control.</returns>
        private static HtmlContainerControl CreateText()
        {
            return CreateText(/* isDiv */ true);
        }

        /// <summary>
        /// Creates a new container control for text.
        /// </summary>
        /// <param name="isDiv">A value indicating whether this is a div or a 
        /// span (div is for true values).</param>
        /// <returns>Returns a new container control.</returns>
        private static HtmlContainerControl CreateText(bool isDiv)
        {
            HtmlContainerControl control;
            if (isDiv)
            {
                control = new HtmlDiv();
            }
            else
            {
                control = new HtmlSpan();
            }
            control.Margin.Bottom = 1;
            control.Padding.Top = control.Padding.Left = control.Padding.Bottom = 1;
            return control;
        }

        /// <summary>
        /// Remainder objects are just appended.
        /// </summary>
        /// <param name="message">The log message object.</param>
        protected override void ProcessRemainder(LogMessage message)
        {
            AppendFixedText(message.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\AssertCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections;
using System.ComponentModel;


namespace Leet.TestUtilities
{
    public class AssertCollection
    {
        public static void AreEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual)
        {
            AreEqual(expected, actual, (exp, act) => Assert.AreEqual(exp, act));
        }

        public static void AreEqual<T1, T2>(IEnumerable<T1> expected, IEnumerable<T2> actual, Action<T1, T2> assertAreEqualFunction)
        {
            Assert.IsNotNull(expected, "Expected collection can't be null.");
            Assert.IsNotNull(actual, "Actual collection can't be null.");
            
            AreEqualOrderedInternal(expected, actual, assertAreEqualFunction, 
                "Collections mismatch starting at element #{0}.  {1}");
        }

        public static void AreEqualUnordered<T>(IEnumerable<T> expected, IEnumerable<T> actual)
        {
            Assert.IsNotNull(expected, "Expected collection can't be null.");
            Assert.IsNotNull(actual, "Actual collection can't be null.");

            var failTextBuilder = new StringBuilder();
            if (expected.Count() != actual.Count())
            {
                failTextBuilder.AppendLine("Number of elements in expected and actual collection are not the same.");
                failTextBuilder.AppendLine("Expected: " + expected.Count() + ", actual: " + actual.Count() + ".");
            }

            var missingItems = expected.Except(actual);
            if (missingItems.Count() != 0)
            {
                failTextBuilder.AppendLine("The following items were not found in the collection: [");
                failTextBuilder.AppendLine(string.Join("\r\n", missingItems.Select(i => i.ToString()).ToArray()));
                failTextBuilder.AppendLine("]");
            }

            var extraItems = actual.Except(expected);
            if (extraItems.Count() != 0)
            {
                failTextBuilder.AppendLine("The following extra items were found in the collection: [");
                failTextBuilder.AppendLine(string.Join("\r\n", extraItems.Select(i => i.ToString()).ToArray()));
                failTextBuilder.AppendLine("]");
            }

            if (failTextBuilder.ToString() != "")
            {
                Assert.Fail(failTextBuilder.ToString());
            }
        }

        public static void AreEqualUnordered<T>(IEnumerable<T> expected, IEnumerable<T> actual,
            Action<T, T> assertAreEqualFunction, Comparison<T> comparisonForSortingFunction)
        {
            Assert.IsNotNull(expected, "Expected collection can't be null.");
            Assert.IsNotNull(actual, "Actual collection can't be null.");

            var sortedExpected = expected.ToList();
            sortedExpected.Sort(comparisonForSortingFunction);
            var sortedActual = actual.ToList();
            sortedActual.Sort(comparisonForSortingFunction);

            AreEqualOrderedInternal(sortedExpected, sortedActual, assertAreEqualFunction, 
                "When sorted, collections mismatch starting at element #{0}.  {1}");
        }

        private static void AreEqualOrderedInternal<T1, T2>(IEnumerable<T1> expected, IEnumerable<T2> actual, 
            Action<T1, T2> assertAreEqualFunction, 
            string assertFailedMessage)
        {
            Assert.AreEqual(expected.Count(), actual.Count(), "The size of collections is not the same.");

            for (int i = 0; i < expected.Count(); i++)
            {
                try
                {
                    assertAreEqualFunction(expected.ElementAt(i), actual.ElementAt(i));
                }
                catch (AssertFailedException ex)
                {
                    Assert.Fail(String.Format(assertFailedMessage, i, ex.Message));
                }
            }
        }

        public static void AssertAllPropertiesEqual(object expectedObject, object actualObject)
        {
            AssertAllPropertiesEqual(expectedObject, actualObject, null);
        }

        public static void AssertAllPropertiesEqual(object expectedObject, object actualObject, string message)
        {
            Assert.AreEqual(expectedObject.GetType(), actualObject.GetType(), "Two objects being compared were not of the same type.  " + message);

            var properties = TypeDescriptor.GetProperties(expectedObject.GetType()).Cast<PropertyDescriptor>();
            foreach (var property in properties)
            {
                Assert.AreEqual(property.GetValue(expectedObject), property.GetValue(actualObject),
                    property.Name + " does not match.  " + message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\AssertException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.TestUtilities
{
    public static class AssertException
    {
        /// <summary>
        /// Verifies that the provided function throws an exception of expected type.
        /// </summary>
        /// <typeparam name="E">The exception type to expect</typeparam>
        /// <param name="function">The function delegate or lambda to execute</param>
        /// <returns>The caught exception if one happened.  This can be used to do further Asserts on the exception.</returns>
        public static E Expect<E>(Action function) where E : Exception
        {
            return AssertException.Expect<E>(function, null, false, "");
        }

        /// <summary>
        /// Verifies that the provided function throws an exception of expected type and message.
        /// </summary>
        /// <typeparam name="E">The exception type to expect</typeparam>
        /// <param name="function">The function delegate or lambda to execute</param>
        /// <param name="exceptionMessage">The message that exception should have</param>
        /// <returns>The caught exception if one happened.  This can be used to do further Asserts on the exception.</returns>
        public static E Expect<E>(Action function, string exceptionMessage) where E : Exception
        {
            return AssertException.Expect<E>(function, exceptionMessage, false, "");
        }

        /// <summary>
        /// Verifies that the provided function throws an exception of expected type and message.
        /// </summary>
        /// <typeparam name="E">The exception type to expect</typeparam>
        /// <param name="function">The function delegate or lambda to execute</param>
        /// <param name="exceptionMessage">The message that exception should have</param>
        /// <param name="allowDerivedTypes">Whether the exception has to match the type exactly or can inherit from it</param>
        /// <returns>The caught exception if one happened.  This can be used to do further Asserts on the exception.</returns>
        public static E Expect<E>(Action function, string exceptionMessage, bool allowDerivedTypes) where E : Exception
        {
            return AssertException.Expect<E>(function, exceptionMessage, allowDerivedTypes, "");
        }

        /// <summary>
        /// Verifies that the provided function throws an exception of expected type and message.
        /// </summary>
        /// <typeparam name="E">The exception type to expect</typeparam>
        /// <param name="function">The function delegate or lambda to execute</param>
        /// <param name="exceptionMessage">The message that exception should have</param>
        /// <param name="allowDerivedTypes">Whether the exception has to match the type exactly or can inherit from it</param>
        /// <param name="assertionFailedMessage">Message to prepend when assertion fails.</param>
        /// <returns>The caught exception if one happened.  This can be used to do further Asserts on the exception.</returns>
        public static E Expect<E>(Action function, string exceptionMessage, bool allowDerivedTypes, string assertionFailedMessage) where E : Exception
        {
            if (string.IsNullOrEmpty(assertionFailedMessage) == false)
            {
                assertionFailedMessage = assertionFailedMessage + Environment.NewLine;
            }

            E caughtException = null;
            try
            {
                function();
            }
            catch (Exception exception)
            {
                bool isSameType = allowDerivedTypes ? (exception is E) : (exception.GetType() == typeof(E));
                Assert.IsTrue(isSameType, assertionFailedMessage + "Expected exception of type '" + typeof(E) + "' but got an exception of type '" + exception.GetType() +
                    ".  Received exception: " + exception.ToString());
                caughtException = (E)exception;
                if (exceptionMessage != null)
                {
                    Assert.AreEqual(exceptionMessage, exception.Message, 
                        assertionFailedMessage + "Expected exception message does not equal actual exception message.");
                }
            }

            Assert.IsNotNull(caughtException, 
                assertionFailedMessage + "Expected exception of type '" + typeof(E) + "' but didn't get it.");
            return caughtException;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\AssertString.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.TestUtilities
{
    public class AssertString
    {
        public static void IsNullOrEmpty(string actual)
        {
            Assert.IsTrue(string.IsNullOrEmpty(actual), 
                "Expected null or empty, actual: <" + actual + ">.");
        }

        public static void IsNotNullOrEmpty(string actual)
        {
            string displayForError = actual == null ? "null" : "empty";

            Assert.IsFalse(string.IsNullOrEmpty(actual),
                "Expected not null or empty, actual: <" + displayForError + ">.");
        }

        public static void StartsWith(string expectedBeginning, string actualString)
        {
            if (actualString.StartsWith(expectedBeginning) == false)
            {
                throw new AssertFailedException("Expected string to start with '" + expectedBeginning + "' but it didn't.\r\n" +
                    "Actual string: \r\n" + actualString);
            }
        }

        public static void Contains(string expectedSubstring, string actualString)
        {
            Contains(expectedSubstring, actualString, null);
        }

        public static void Contains(string expectedSubstring, string actualString, string message)
        {
            if (actualString.Contains(expectedSubstring) == false)
            {
                throw new AssertFailedException("Did not find expected substring: '" + expectedSubstring + "'.  Actual string: '" + actualString + "'.  " + message);
            }
        }

        public static void DoesNotContain(string expectedSubstring, string actualSuperstring)
        {
            if (actualSuperstring.Contains(expectedSubstring))
            {
                throw new AssertFailedException("Found not expected substring: '" + expectedSubstring + "'.  Actual string: '" + actualSuperstring);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\InstanceLocator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.IoCCo;

namespace Leet.TestUtilities
{
    public class InstanceLocator<TService> : ILocator<TService>
    {
        public static TService InstanceToReturn
        {
            set;
            private get;
        }

        #region ILocator<TService> Members

        public TService LocateComponent()
        {
            return InstanceToReturn;
        }

        #endregion

        #region ILocator Members

        object ILocator.LocateComponent()
        {
            return this.LocateComponent();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\StubLocator.cs ===
﻿using Leet.Core.IoCCo;
using Rhino.Mocks;

namespace Leet.TestUtilities
{
    public class StubLocator<TService> : ILocator<TService> where TService : class
    {
        private static TService _stub;

        public TService LocateComponent()
        {
            if (_stub == null)
            {
                _stub = MockRepository.GenerateStub<TService>();
            }
            return _stub;
        }

        object ILocator.LocateComponent()
        {
            return LocateComponent();
        }

        public static void Clear() {
            _stub = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\ExceptionGenerator.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Reflection;

namespace Leet.TestUtilities
{
    public class ExceptionGenerator
    {
        public static SqlException GenerateSqlException(string message, int errorNumber)
        {
            return GenerateSqlException(message, errorNumber, 0);
        }

        public static SqlException GenerateSqlException(string message, int errorNumber, int errorState)
        {
            SqlError error = CreateInstance<SqlError>(errorNumber, (byte)errorState, (byte)0, "UNITTEST", message, "UNITTEST_NO_PROC", -1);
            Type errorTypeCollection = typeof(SqlErrorCollection);
            SqlErrorCollection collection = Activator.CreateInstance(errorTypeCollection, true) as SqlErrorCollection;
            MethodInfo collectionAddMethod = errorTypeCollection.GetMethod("Add",
                                                                           BindingFlags.Instance |
                                                                           BindingFlags.NonPublic);
            collectionAddMethod.Invoke(collection, new object[] { error });
            return CreateInstance<SqlException>(message, collection);

        }

        private static T CreateInstance<T>(params object[] args) where T : class
        {

            return Activator.CreateInstance(typeof(T), BindingFlags.NonPublic | BindingFlags.Instance, null, args, null) as T;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\Stubber.cs ===
﻿using System;
using System.Collections.Generic;
using System.Reflection;
using Leet.Core.IoCCo;

namespace Leet.TestUtilities
{
    /// <summary>
    /// Used to quickly create Rhino Mocks stubs and register them with the IoCCo container.
    /// </summary>
    public class Stubber
    {
        Dictionary<Type, bool> stubbedTypes;

        public Stubber()
        {
            // We want to reset the static Instance variable for each test
            Container.UseLocalContainer(new Container());
            this.stubbedTypes = new Dictionary<Type, bool>();
        }
        /// <summary>
        /// Creates a RhinoMocks stub and registers it with IoCCo
        /// </summary>
        /// <typeparam name="T">The interface to stub</typeparam>
        /// <returns>The create stub</returns>
        public T RegisterWithContainer<T>() where T : class
        {
            if (IsStubbed<T>() == false)
            {
                // Need to clear StubLocator's static cache of the stub that might be there from previous tests.
                StubLocator<T>.Clear();
                Container.Instance.AddServiceWithLocator<T, StubLocator<T>>();
                this.stubbedTypes.Add(typeof(T), true);
            }
            return GetRegisteredStub<T>();
        }

        private object RegisterWithContainer(Type t)
        {
            if (IsStubbed(t) == false)
            {
                // Need to clear StubLocator's static cache of the stub that might be there from previous tests.
                // Below is equivalent to StubLocator<T>.Clear();
                Type stubLocatorOfT = typeof(StubLocator<>).MakeGenericType(t);
                MethodInfo clearMethod = stubLocatorOfT.GetMethod("Clear", BindingFlags.Public | BindingFlags.Static, null, new Type[] { }, null);
                clearMethod.Invoke(null, new object[] { });

                // Below is equivalent to Container.Instance.AddServiceWithLocator<T, StubLocator<T>>();
                var addServiceMethod = typeof(IContainer).GetMethod("AddServiceWithLocator", BindingFlags.Instance | BindingFlags.Public, null, new Type[] {}, null);
                addServiceMethod = addServiceMethod.MakeGenericMethod(t, stubLocatorOfT);
                addServiceMethod.Invoke(Container.Instance, new object[] { });

                this.stubbedTypes.Add(t, true);
            }
            return GetRegisteredStub(t);
        }

        public void RegisterWithContainer<TInterface, TImplementation>() 
            where TInterface : class 
            where TImplementation : TInterface
        {
            if (IsStubbed<TInterface>() == false)
            {
                // Need to clear StubLocator's static cache of the stub that might be there from previous tests.
                StubLocator<TInterface>.Clear();
                Container.Instance.AddService<TInterface, TImplementation>();
                this.stubbedTypes.Add(typeof(TInterface), true);
            }
        }

        public T RegisterInstanceWithContainer<T>(T instance) where T : class
        {
            Container.Instance.AddServiceWithLocator<T, InstanceLocator<T>>();
            InstanceLocator<T>.InstanceToReturn = instance;
            return instance;
        }

        /// <summary>
        /// Gets the stub that is currently being used for the specified inteface
        /// </summary>
        /// <typeparam name="T">The interface to return the stub for</typeparam>
        /// <returns>The stub from the IoCCo container</returns>
        public T GetRegisteredStub<T>()
        {
            return (T)Container.Instance.GetComponent(typeof(T));
        }

        private object GetRegisteredStub(Type type)
        {
            return Container.Instance.GetComponent(type);
        }

        private bool IsStubbed(Type type)
        {
            return this.stubbedTypes.ContainsKey(type);
        }

        public bool IsStubbed<T>()
        {
            return this.IsStubbed(typeof(T));
        }

        /// <summary>
        /// Calls the constructor on T, and if the constructor has parameters, uses
        /// Stubber.RegisterWithContainer() on each parameter type.
        /// </summary>
        /// <typeparam name="T">The type to instantiate</typeparam>
        /// <returns>The object of type T</returns>
        public T CreateComponent<T>()
        {
            var constructors = typeof(T).GetConstructors();
            if (constructors.Length != 1)
            {
                throw new ArgumentException("Components must have one and only one public constructor.", "T");
            }

            var constructor = constructors[0];

            var parameterInfos = constructor.GetParameters();

            object[] parameters = new object[parameterInfos.Length];
            for (int i = 0; i < parameters.Length; i++)
            {
                parameters[i] = this.RegisterWithContainer(parameterInfos[i].ParameterType);
            }

            return (T) constructor.Invoke(parameters);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\DelegateArg.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Rhino.Mocks;
using Rhino.Mocks.Constraints;

namespace Leet.TestUtilities
{
    /// <summary>
    /// Inline constraint for verifying that the right delegate was passed in RhinoMocks AssertWasCalled function.
    /// Sample usage:
    /// 
    /// Code under test:
    /// 
    /// public void LoadContentTypeWork(DoWorkEventArgs args, WorkArgs workArgs) { some code }
    /// public void LoadContentTypeCompleted(RunWorkerCompletedEventArgs args, WorkArgs workArgs) { some code }
    /// 
    /// worker.Run(this.LoadContentTypeWork, this.LoadContentTypeCompleted, workArgs);
    /// 
    /// Test code:
    /// 
    /// workerStub.AssertWasCalled(
    ///     w => w.Run<WorkArgs>(
    ///         DelegateArg<Action<DoWorkEventArgs, WorkArgs>>.Matches(openContentTypeCommand.LoadContentTypeWork),
    ///         DelegateArg<Action<RunWorkerCompletedEventArgs, WorkArgs>>.Matches(openContentTypeCommand.LoadContentTypeCompleted),
    ///         Arg<WorkArgs>.Is.Anything));
    ///         
    /// </summary>
    /// <typeparam name="TDelegate">Strongly typed delegate to expect</typeparam>   
    public class DelegateArg<TDelegate> : AbstractConstraint // where TDelegate : Delegate (not allowed by the compiler)
    {
        private Delegate expectedDelegate;
        private string message;

        /// <summary>
        /// Defines a delegate constraint.  The Method and Target properties of the delegate must match to satisfy the constraint.
        /// </summary>
        /// <param name="expectedDelegate">The expected delegate.</param>
        public static TDelegate Matches(TDelegate expectedDelegate)
        {
            return Arg<TDelegate>.Matches(new DelegateArg<TDelegate>(expectedDelegate));
        }

        public DelegateArg(TDelegate expected)
        {
            var expectedDelegate = expected as Delegate;
            if (expectedDelegate == null)
            {
                throw new ArgumentException("Expected the parameter to be a delegate, but it's of type '" + expected.GetType() + "'.");
            }

            this.expectedDelegate = expectedDelegate as Delegate;
        }

        public override bool Eval(object obj)
        {
            if (obj == null)
            {
                message = "Null was passed in instead of a delegate.";
                return false;
            }

            var actualDelegate = obj as Delegate;
            if (actualDelegate == null)
            {
                message = "Expected the parameter to be a delegate, but it's of type '" + obj.GetType() + "'.";
                return false;
            }

            if (expectedDelegate.Target != actualDelegate.Target)
            {
                message = "The target of the expected delegate and the actual delegate did not match.  Expected: '" + expectedDelegate.Target +
                    "' actual: '" + actualDelegate.Target + "'.";
                return false;
            }

            if (expectedDelegate.Method != actualDelegate.Method)
            {
                message = "The method of the expected delegate and the actual delegate did not match.  Expected: '" + expectedDelegate.Method +
                    "' actual: '" + actualDelegate.Method + "'.";
                return false;
            }

            return true;
        }

        public override string Message
        {
            get
            {
                return this.message;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Common.TestUtilities")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5c9a2bca-3023-4b48-be78-3f303fc6e24a")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities.Test\AssertExceptionTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Leet.TestUtilities;

namespace Leet.TestUtilities.Test
{
    [TestClass]
    public class AssertExceptionTest
    {
        [TestMethod]
        public void Expect_Does_NOT_Throw_When_ExpectedException_Happened()
        {
            AssertException.Expect<ArgumentException>(() =>
            {
                throw new ArgumentException();
            });
        }
        
        [TestMethod]        
        public void Expect_Throws_When_No_Exception_Was_Thrown()
        {
            Exception actualException = null;
            try
            {
                AssertException.Expect<Exception>(() => { });
            }
            catch (Exception e)
            {
                actualException = e;
            }
            Assert.IsNotNull(actualException);
            Assert.IsInstanceOfType(actualException, typeof(AssertFailedException));
            string expectedMessage = "Expected exception of type '" + typeof(Exception) + "' but didn't get it.";
            Assert.IsTrue(actualException.Message.Contains(expectedMessage),
                "Expected exception message to contain '" + expectedMessage + "', but it didn't.  Actual exception message: " + actualException.Message);
        }

        [TestMethod]
        public void Expect_Throws_When_Exception_Was_Thrown_But_Of_Wrong_Type()
        {
            Exception actualException = null;
            Exception thrownException = null;
            try
            {
                thrownException = AssertException.Expect<ArgumentException>(() =>
                {
                    throw new InvalidOperationException();
                });
            }
            catch (Exception e)
            {
                actualException = e;
            }
            Assert.IsNotNull(actualException);
            Assert.IsInstanceOfType(actualException, typeof(AssertFailedException));
            string expectedMessage = 
                "Expected exception of type '" + typeof(ArgumentException) +
                "' but got an exception of type '" + typeof(InvalidOperationException) +
                ".  Received exception: " + thrownException;

            Assert.IsTrue(actualException.Message.Contains(expectedMessage),
                "Expected exception message to contain '" + expectedMessage + "', but it didn't.  Actual exception message: " + actualException.Message);
        }

        [TestMethod]
        public void Except_Does_NOT_Throw_When_Message_Matches()
        {
            AssertException.Expect<ArgumentException>(() =>
            {
                throw new ArgumentException("Some message");
            },
            "Some message");
        }

        [TestMethod]
        public void Except_Throws_When_Message_Does_NOT_Match()
        {
            Exception actualException = null;
            Exception thrownException = null;
            try
            {
                thrownException = AssertException.Expect<ArgumentException>(() =>
                {
                    throw new ArgumentException("Actual message");
                },
                "Expected message");
            }
            catch (Exception e)
            {
                actualException = e;
            }
            Assert.IsNotNull(actualException);
            Assert.IsInstanceOfType(actualException, typeof(AssertFailedException));
            string expectedMessage =
                "Expected exception message does not equal actual exception message.";

            Assert.IsTrue(actualException.Message.Contains(expectedMessage),
                "Expected exception message to contain '" + expectedMessage + "', but it didn't.  Actual exception message: '" + actualException.Message + "'.");
        }

        [TestMethod]
        public void DerivedTypes_ARE_Allowed_When_AllowDerivedTypes_Is_TRUE()
        {
            AssertException.Expect<ArgumentException>(() =>
            {
                throw new ArgumentNullException();
            }, null, true);
        }

        [TestMethod]
        public void DerivedTypes_Are_NOT_Allowed_When_AllowDerivedTypes_Is_FALSE()
        {
            Exception actualException = null;
            Exception thrownException = null;
            try
            {
                thrownException = AssertException.Expect<ArgumentException>(() =>
                {
                    throw new ArgumentNullException();
                });
            }
            catch (Exception e)
            {
                actualException = e;
            }
            Assert.IsNotNull(actualException);
            Assert.IsInstanceOfType(actualException, typeof(AssertFailedException));
            string expectedMessage =
                "Expected exception of type '" + typeof(ArgumentException) +
                "' but got an exception of type '" + typeof(ArgumentNullException) +
                ".  Received exception: " + thrownException;

            Assert.IsTrue(actualException.Message.Contains(expectedMessage),
                "Expected exception message to contain '" + expectedMessage + "', but it didn't.  Actual exception message: '" + actualException.Message + "'.");
        }

        [TestMethod]
        public void Expect_ShowsCustomizedAssertionFailedMessage()
        {
            Exception actualException = null;
            Exception thrownException = null;
            try
            {
                thrownException = AssertException.Expect<Exception>(() => {},
                    null,
                    false,
                    "Custom message");
            }
            catch (Exception e)
            {
                actualException = e;
            }

            AssertString.Contains("Custom message", actualException.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\Achievement.cs ===
﻿
namespace Leet.UserGameData.DataContracts
{
    using System;
    using System.Runtime.Serialization;

    [DataContract(Name = "Achievement", Namespace = "")]
    public class Achievement
    {
        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GameId", Order = 0)]
        public uint GameId { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Description", Order = 1)]
        public string Description { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "DisplayBeforeEarned", Order = 2)]
        public bool DisplayBeforeEarned { get; set; }

        [DataMember(EmitDefaultValue = false, IsRequired = false, Name = "EarnedDateTime", Order = 3)]
        public DateTime EarnedDateTime { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "EarnedOnline", Order = 4)]
        public bool EarnedOnline { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "GameName", Order = 5)]
        public string GameName { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Gamerscore", Order = 6)]
        public int Gamerscore { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "HowToEarn", Order = 7)]
        public string HowToEarn { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "IsEarned", Order = 8)]
        public bool IsEarned { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Key", Order = 9)]
        public string Key { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "Name", Order = 10)]
        public string Name { get; set; }

        [DataMember(EmitDefaultValue = true, IsRequired = true, Name = "PictureUrl", Order = 11)]
        public string PictureUrl { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities.Test\AssertCollectionTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.TestUtilities.Test
{
    [TestClass]
    public class AssertCollectionTest
    {
        [TestMethod]
        public void AreEqual_DoesNotFail_When_2_Collections_Are_Empty()
        {
            // Assert no exception
            AssertCollection.AreEqual(new object[] { }, new object[] { });
        }

        [TestMethod]
        public void AreEqual_DoesNotFail_When_2_Collections_Are_Same()
        {
            // Assert no exception
            AssertCollection.AreEqual(new string[] { "abc", "xyz", "123" }, new object[] { "abc", "xyz", "123" });
        }

        [TestMethod]
        public void AreEqual_Fails_When_2_Collections_HaveSameElements_But_Different_order()
        {
            var exception = AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AreEqual(new string[] { "abc", "xyz", "123" }, new object[] { "abc", "123", "xyz" })
            );

            AssertString.Contains("Collections mismatch starting at element #1.", exception.Message);
        }

        [TestMethod]
        public void AreEqual_Does_Not_Allow_Null_Expected_Collection()
        {
            var ex = AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AreEqual(null, new object[] { })
            );

            AssertString.Contains("Expected collection can't be null.", ex.Message);
        }

        [TestMethod]
        public void AreEqual_Does_Not_Allow_Null_Actual_Collection()
        {
            var ex = AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AreEqual(new object[] {}, null)
            );

            AssertString.Contains("Actual collection can't be null.", ex.Message);
        }

        [TestMethod]
        public void AreEqual_Fails_If_Size_Of_Collection_Is_Not_The_Same()
        {
            var ex = AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AreEqual(new string[] { "abc" }, new string[] { "abc", "xyz" })
            );

            AssertString.Contains("The size of collections is not the same", ex.Message);
        }

        [TestMethod]
        public void AreEqual_CustomAssertion_IsCalled()
        {
            AssertCollection.AreEqual(new string[] { "abc", "xyz" }, new string[] { "ABC", "XYZ" }, (e, a) => Assert.AreEqual(e.ToUpper(), a.ToUpper()));
            // Assert no exception
        }

        [TestMethod]
        public void AreEqual_CustomAssertion_Message_Is_Shown()
        {
            var exc = AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AreEqual(new string[] { "abc", "xyz" }, new string[] { "ABC", "123" }, 
                (e, a) => {
                    if(e.ToUpper() != a.ToUpper()) 
                    {
                        throw new AssertFailedException("Custom assertion failed");
                    }
                })
            );

            AssertString.Contains("Collections mismatch starting at element #1.", exc.Message);
            AssertString.Contains("Custom assertion failed", exc.Message);            
        }

        [TestMethod]
        public void AreEqualUnordered_DoesNotFailWhen2Collections_Are_Equivalent()
        {
            // Arrange
            var c1 = new string[] { "foobar", "zoobar", "vroom", "zoom" };
            var c2 = new string[] { "zoobar", "vroom", "foobar", "zoom" };

            // Act
            AssertCollection.AreEqualUnordered(c1, c2);

            // Assert
            // No exception
        }

        [TestMethod]
        public void AreEqualUnordered_DoesNotFailWith2Empty_Collections()
        {
            // Arrange
            var c1 = new string[] { };
            var c2 = new string[] { };

            // Act
            AssertCollection.AreEqualUnordered(c1, c2);

            // Assert
            // No exception
        }

        [TestMethod]
        public void AreEqualUnordered_Fails_With_Actual_Collection_Containing_Extra_Items()
        {
            // Arrange
            var exp = new string[] { "foobar", "zoobar", "vroom", "zoom" };
            var act = new string[] { "zoobar", "vroom", "extra1", "extra2", "foobar", "zoom" };

            // Act
            var exception = AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AreEqualUnordered(exp, act));

            // Assert
            AssertString.Contains("Expected: 4, actual: 6.", exception.Message);
            AssertString.Contains("Number of elements in expected and actual collection are not the same.", exception.Message);
            AssertString.Contains("The following extra items were found in the collection", exception.Message);
            AssertString.Contains("extra1", exception.Message);
            AssertString.Contains("extra2", exception.Message);
            AssertString.DoesNotContain("The following items were not found in the collection", exception.Message);
        }

        [TestMethod]
        public void AreEqualUnordered_Fails_With_Actual_Collection_Missing_Items()
        {
            // Arrange
            var exp = new string[] { "foobar", "zoobar", "vroom", "zoom" };
            var act = new string[] { "zoobar", "vroom" };

            // Act
            var exception = AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AreEqualUnordered(exp, act));

            // Assert
            AssertString.Contains("Expected: 4, actual: 2.", exception.Message);
            AssertString.Contains("Number of elements in expected and actual collection are not the same.", exception.Message);
            AssertString.Contains("The following items were not found in the collection", exception.Message);
            AssertString.Contains("zoom", exception.Message);
            AssertString.Contains("foobar", exception.Message);
            AssertString.DoesNotContain("The following extra items were found in the collection", exception.Message);
        }

        [TestMethod]
        public void AreEqualUnordered_Fails_With_SomeItems_Missing_And_SomeItems_Extra_But_Count_Is_The_Same()
        {
            // Arrange
            var exp = new string[] { "foobar", "zoobar", "vroom", "zoom" };
            var act = new string[] { "zoobar", "vroom", "new1", "new2" };

            // Act
            var exception = AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AreEqualUnordered(exp, act));

            // Assert
            AssertString.Contains("The following items were not found in the collection", exception.Message);
            AssertString.Contains("zoom", exception.Message);
            AssertString.Contains("foobar", exception.Message);
            AssertString.Contains("The following extra items were found in the collection", exception.Message);
            AssertString.Contains("new1", exception.Message);
            AssertString.Contains("new2", exception.Message);
        }

        class TestClass
        {
            public string SomeProperty { get; set; }
        }

        [TestMethod]
        public void AssertAllPropertiesEqual_DoesMatchBasedOnTypeOfObject()
        {
            var item1 = new TestClass { SomeProperty="foo"};
            var item2 = new TestClass { SomeProperty = "bar" };

            // Cast to object before calling
            AssertException.Expect<AssertFailedException>(() =>
                AssertCollection.AssertAllPropertiesEqual((object)item1, (object)item2, "")
            );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\Network.cs ===
﻿namespace Leet.UserGameData.DataContracts
{
    public enum Network
    {
        XboxLive = 1,
        Messenger = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\GeneralProperty.cs ===
﻿namespace Leet.UserGameData.DataContracts
{
    /// <summary>
    /// The names of the various optional properties available 
    /// in a Profile 
    /// </summary>
    public enum GeneralProperty
    {
        /// <summary>
        /// Should be of type string
        /// </summary>
        ProfileUrl,
        
        /// <summary>
        /// Should be of type string
        /// </summary>
        WindowsLiveLocale,
        
        /// <summary>
        /// Should be of type bool
        /// </summary>
        PublishGameUpdates,
        
        /// <summary>
        /// Should be of type PrivacyLevel
        /// </summary>
        ProfileVisibility,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities.Test\DelegateArgTest.cs ===
﻿using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using Rhino.Mocks.Exceptions;

namespace Leet.TestUtilities.Test
{
    [TestClass]
    public class DelegateArgTest
    {
        class TestClass
        {
            IDependency dep;
            public TestClass(IDependency dep) 
            {
                this.dep = dep;
            }

            public void PassesInExpectedDelegate()
            {
                dep.DependentMethod(this.MethodAsArgument);
            }

            public void PassesInAFunc()
            {
                dep.DependentMethodAcceptsAFunc(this.FuncAsArgument);
            }

            public void PassesNullInsteadOfDelegate()
            {
                dep.DependentMethod(null);
            }

            public void PassesStringInsteadOfDelegate()
            {
                dep.DependentMethod("asdf");
            }

            public void PassesInDelegateWithWrongTarget()
            {
                dep.DependentMethod(new SomeOtherClass().MethodAsArgument);
            }

            public void PassesInDelegateWithWrongMethodName()
            {
                dep.DependentMethod(this.WrongMethodToUseAsArgument);
            }

            public void MethodAsArgument()
            {
            }

            public int FuncAsArgument()
            {
                return 0;
            }

            public void WrongMethodToUseAsArgument()
            {
            }
        }

        class SomeOtherClass
        {
            public void MethodAsArgument()
            {
            }
        }

        public interface IDependency
        {
            void DependentMethod(Action a);
            void DependentMethodAcceptsAFunc(Func<int> f);
            void DependentMethod(object a);
        }

        [TestMethod]
        public void Matches_passes_if_method_name_and_target_match()
        {
            var dependency = MockRepository.GenerateStub<IDependency>();
            var testObject = new TestClass(dependency);

            testObject.PassesInExpectedDelegate();

            dependency.AssertWasCalled(d => d.DependentMethod(DelegateArg<Action>.Matches(testObject.MethodAsArgument)));
        }

        [TestMethod]
        public void Matches_passes_if_method_name_and_target_match_for_nonvoid_method()
        {
            var dependency = MockRepository.GenerateStub<IDependency>();
            var testObject = new TestClass(dependency);

            testObject.PassesInAFunc();

            dependency.AssertWasCalled(d => d.DependentMethodAcceptsAFunc(DelegateArg<Func<int>>.Matches(testObject.FuncAsArgument)));
        }

        [TestMethod]
        public void Matches_throws_if_method_Target_is_not_equal()
        {
            var dependency = MockRepository.GenerateStub<IDependency>();
            var testObject = new TestClass(dependency);

            testObject.PassesInDelegateWithWrongTarget();

            var assertException = AssertException.Expect<ExpectationViolationException>(() =>
                dependency.AssertWasCalled(d => d.DependentMethod(DelegateArg<Action>.Matches(testObject.MethodAsArgument)))
            );

            AssertString.Contains("The target of the expected delegate and the actual delegate did not match.", assertException.Message);
        }

        [TestMethod]
        public void Matches_throws_if_method_Name_is_not_equal()
        {
            var dependency = MockRepository.GenerateStub<IDependency>();
            var testObject = new TestClass(dependency);

            testObject.PassesInDelegateWithWrongMethodName();

            var assertException = AssertException.Expect<ExpectationViolationException>(() =>
                dependency.AssertWasCalled(d => d.DependentMethod(DelegateArg<Action>.Matches(testObject.MethodAsArgument)))
            );

            AssertString.Contains("The method of the expected delegate and the actual delegate did not match.", assertException.Message);
        }

        [TestMethod]
        public void Matches_throws_if_object_is_not_Delegate()
        {
            AssertException.Expect<ArgumentException>(() =>
                DelegateArg<object>.Matches("foo")
            );
        }

        [TestMethod]
        public void Matches_fails_if_actual_parameter_is_null()
        {
            var dependency = MockRepository.GenerateStub<IDependency>();
            var testObject = new TestClass(dependency);

            testObject.PassesNullInsteadOfDelegate();

            var assertException = AssertException.Expect<ExpectationViolationException>(() =>
                dependency.AssertWasCalled(d => d.DependentMethod(DelegateArg<Action>.Matches(testObject.MethodAsArgument)))
            );

            AssertString.Contains("Null was passed in instead of a delegate.", assertException.Message);
        }

        [TestMethod]
        public void Matches_throws_if_actual_parameter_is_not_Delegate()
        {
            var dependency = MockRepository.GenerateStub<IDependency>();
            var testObject = new TestClass(dependency);

            testObject.PassesStringInsteadOfDelegate();

            var assertException = AssertException.Expect<ExpectationViolationException>(() =>
                dependency.AssertWasCalled(d => d.DependentMethod((object)DelegateArg<Action>.Matches(testObject.MethodAsArgument)))
            );

            AssertString.Contains("Expected the parameter to be a delegate, but it's of type '" + typeof(string) + "'.", 
                assertException.Message);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.TestUtilities.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.TestUtilities.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e1dd77b6-6674-4354-800e-4c1f0921296f")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\PrivacyLevel.cs ===
﻿namespace Leet.UserGameData.DataContracts
{
    /// <summary>
    /// Level of privacy specified by the user
    /// </summary>
    public enum PrivacyLevel
    {
        Private,
        FriendsOnly,
        Public
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\GameInfo.cs ===
﻿using System;
using System.Runtime.Serialization;

namespace Leet.UserGameData.DataContracts
{
    /// <summary>
    /// Data class bundling information about a game in the context
    /// of a specific user
    /// </summary>
    [DataContract]
    public class GameInfo
    {
        /// <summary>
        /// Game Id
        /// </summary>
        [DataMember]
        public int Id { get; set; }

        /// <summary>
        /// Name of the game
        /// </summary>
        [DataMember]
        public string Name { get; set; }

        /// <summary>
        /// Indicates the platform of the game (LIVEn or Xbox LIVE)
        /// </summary>
        [DataMember]
        public uint Type { get; set; }

        /// <summary>
        /// URL for the game page
        /// </summary>
        [DataMember]
        public string GameUrl { get; set; }

        /// <summary>
        /// URL for the game image
        /// </summary>
        [DataMember]
        public string ImageUrl { get; set; }

        /// <summary>
        /// When this game was last played by the user
        /// </summary>
        [DataMember]
        public DateTime LastPlayed { get; set; }

        /// <summary>
        /// Indicates number of achievements earned for this game 
        /// by the user. 
        /// </summary>
        [DataMember]
        public int AchievementsEarned { get; set; }

        /// <summary>
        /// Indicates total number of achievements available for 
        /// this game 
        /// </summary>
        [DataMember]
        public int TotalAchievements { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\ProfileProperty.cs ===
﻿namespace Leet.UserGameData.DataContracts
{
    /// <summary>
    /// The names of the various optional Xbox Live and Windows Live properties 
    /// available in a profile
    /// </summary>
    public enum ProfileProperty
    {
        /// <summary>
        /// Should be of type string
        /// </summary>
        AvatarImageUrl,

        /// <summary>
        /// Should be of type string
        /// </summary>
        Bio,

        /// <summary>
        /// Should be of type string
        /// </summary>
        Cid,

        /// <summary>
        /// Should be of type string
        /// </summary>
        GamerPicUrl,

        /// <summary>
        /// Should be of type int
        /// </summary>
        GamerScore,

        /// <summary>
        /// Should be of type string
        /// </summary>
        GamerTag,

        /// <summary>
        /// Should be of type string
        /// </summary>
        GamerZone,

        /// <summary>
        /// Should be of type bool
        /// </summary>
        HasAvatar,

        /// <summary>
        /// Should be of type string
        /// </summary>
        MembershipLevel,

        /// <summary>
        /// Should be of type string 
        /// </summary>
        Location,

        /// <summary>
        /// Should be of type string 
        /// </summary>
        Motto,

        /// <summary>
        /// Should be of type string
        /// </summary>
        Name,

        /// <summary>
        /// Should be of type float
        /// </summary>
        Reputation,
        
        /// <summary>
        /// Should be of type int
        /// </summary>
        ShowGamerProfile,
        
        /// <summary>
        /// Should be of type string
        /// </summary>
        SmallGamerPicUrl,

        /// <summary>
        /// Should be of type string
        /// </summary>
        WindowsLiveDisplayImageUrl,

        /// <summary>
        /// Should be of type string
        /// </summary>
        WindowsLiveDisplayName,

        /// <summary>
        /// Should be of type ulong
        /// </summary>
        Xuid,

        /// <summary>
        /// Should be of type ulong
        /// </summary>
        ParentalControlGroup,

        /// <summary>
        /// Should be of type bool
        /// </summary>
        FreeGamertagChangeEligible,

        /// <summary>
        /// Should be of type bool
        /// </summary>
        IsParentallyControlled,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\Profile.cs ===
﻿using System.Runtime.Serialization;
using System.Xml.Serialization;

namespace Leet.UserGameData.DataContracts
{
    /// <summary>
    /// Data class representing the profile of a user
    /// </summary>
    [DataContract(Namespace = "")]
    [XmlRoot(Namespace = "")]
    public class Profile
    {
        /// <summary>
        /// A bit mask that represents a set of ProfileSections bit 
        /// flags - this indicates what sections are requested or 
        /// provided in the profile
        /// </summary>
        [DataMember]
        public long SectionFlags { get; set; }

        /// <summary>
        /// Property bag, contains Xbox Live and Windows Live properties 
        /// </summary>
        [DataMember]
        public XmlSerializableDictionary<ProfileProperty, object> ProfileProperties { get; set; }
        
        /// <summary>
        /// List of achievements recently unlocked by user
        /// </summary>
        [DataMember]
        public XmlSerializableList<Achievement> RecentAchievements { get; set; }

        /// <summary>
        /// The privacy level of the user's profile
        /// </summary>
        [DataMember]
        public XmlSerializableList<GameInfo> RecentGames { get; set; }

        /// <summary>
        /// A list of the user's friends
        /// </summary>
        [DataMember]
        public XmlSerializableList<Profile> Friends { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\XmlSerializableList.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml.Serialization;

namespace Leet.UserGameData.DataContracts
{
    /// <summary>
    /// XmlSerializableList class.  Inherits from List and implements IXmlSerializable
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public class XmlSerializableList<T> : List<T>, IXmlSerializable
    {
        /// <summary>
        /// Initializes a new instance of the XmlSerializableList class.
        /// </summary>
        public XmlSerializableList()
            : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the XmlSerializableList class.
        /// Takes a List and intitializes a XmlSerializableList with the same elements.
        /// </summary>
        /// <param name="list">List</param>
        public XmlSerializableList(List<T> list)
        {
            if (list == null)
            {
                throw new ArgumentNullException("list is null");
            }

            foreach (T item in list)
            {
                this.Add(item);
            }
        }

        #region IXmlSerializable Members

        /// <summary>
        /// This method is reserved and should not be used.
        /// Required only to implement IXmlSerializable interface.
        /// </summary>
        /// <returns>always returns null</returns>
        System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema()
        {
            return null;
        }

        /// <summary>
        /// Generates an XmlSerializableList from its XML representation.
        /// </summary>
        /// <param name="reader">System.Xml.XmlReader reader</param>
        void IXmlSerializable.ReadXml(System.Xml.XmlReader reader)
        {
            if (reader == null)
            {
                throw new ArgumentNullException("reader is null");
            }

            if (reader.IsEmptyElement || reader.Read() == false)
            {
                return;
            }

            XmlSerializer serializer = new XmlSerializer(typeof(T));

            reader.ReadStartElement("items");

            while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
            {
                T element = (T)serializer.Deserialize(reader);
                this.Add(element);
                reader.MoveToContent();
            }
            
            // read the end element of the "items" node
            reader.ReadEndElement();

            // read end Element tag if it exists.  It will exist if deserializing an Profile, it will not if just deserializing an XmlSerializableList
            try
            {
                reader.ReadEndElement();
            }
            catch (System.Xml.XmlException)
            {
                //Do nothing.
            }
        }

        /// <summary>
        /// Converts a XmlSerializationList object into its XML representation
        /// </summary>
        /// <param name="writer">System.Xml.XmlWriter writer</param>
        void IXmlSerializable.WriteXml(System.Xml.XmlWriter writer)
        {
            if (writer == null)
            {
                throw new ArgumentNullException("writer is null");
            }

            if (this.Count == 0)
            {
                return;
            }

            writer.WriteStartElement("items");

            XmlSerializer serializer = null;
            
            if (this.Count > 0)
            {
                serializer = new XmlSerializer(this[0].GetType());
            }

            if(serializer == null)
            {
                serializer = new XmlSerializer(typeof(T));
            }

            foreach (T item in this)
            {
                serializer.Serialize(writer, item);
            }

            writer.WriteEndElement();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\ProfileSections.cs ===
﻿using System;

namespace Leet.UserGameData.DataContracts
{
    /// <summary>
    /// The various sections available for inclusion in a Profile
    /// </summary>
    [Flags]
    public enum ProfileSections
    {
        XboxLiveProperties     = 0x00000001,
        WindowsLiveProperties  = 0x00000002,
        Friends                = 0x00000004,
        RecentGames            = 0x00000008,
        RecentAchievements     = 0x00000010,
        PresenceInfo           = 0x00000020,
        PrivacySettings        = 0x00000040,
        FriendsList            = 0x00000080,
        AccountInformation     = 0x00000100,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\XmlSerializableDictionary.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml.Serialization;

namespace Leet.UserGameData.DataContracts
{
    /// <summary>
    /// XmlSerializationDictionary Class.  Inherits from Dictionary and implements the IXmlSerializable interface
    /// </summary>
    /// <typeparam name="TKey">TKey</typeparam>
    /// <typeparam name="TValue">TValue</typeparam>
    [XmlRoot("Dictionary")]
    public class XmlSerializableDictionary<TKey, TValue> : Dictionary<TKey, TValue>, IXmlSerializable
    {
        /// <summary>
        /// Initializes a new instance of the XmlSerializableDictionary class.
        /// </summary>
        public XmlSerializableDictionary()
            : base()
        { 
        }

        #region IXmlSerializable Members

        /// <summary>
        /// This method is reserved and should not be used.
        /// Required only to implement IXmlSerializable interface.
        /// </summary>
        /// <returns>always returns null</returns>
        System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema()
        {
            return null;
        }

        /// <summary>
        /// Generates an XmlSerializableDictionary from its XML representation.
        /// </summary>
        /// <param name="reader">System.Xml.XmlReader reader</param>
        void IXmlSerializable.ReadXml(System.Xml.XmlReader reader)
        {
            if (reader == null)
            {
                throw new ArgumentNullException("reader is null");
            }

            if (reader.IsEmptyElement || reader.Read() == false)
            {
                return;
            }
            
            XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));

            XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));
            
            reader.ReadStartElement("items");
            
            while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
            {
                reader.ReadStartElement("item");
                
                TKey key = (TKey)keySerializer.Deserialize(reader);
                TValue value = (TValue)valueSerializer.Deserialize(reader);
                
                this.Add(key, value);

                reader.ReadEndElement();
                reader.MoveToContent();
            }

            //read last Items tag
            reader.ReadEndElement();

            // read end Element tag if it exists
            try
            {
                reader.ReadEndElement();
            }
            catch (System.Xml.XmlException)
            { 
                //Do nothing.
            }
        }

        /// <summary>
        /// Converts a XmlSerializationDictionary object into its XML representation
        /// </summary>
        /// <param name="writer">System.Xml.XmlWriter writer</param>
        void IXmlSerializable.WriteXml(System.Xml.XmlWriter writer)
        {
            if (writer == null)
            {
                throw new ArgumentNullException("writer is null");
            }

            XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
            XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));
            
            writer.WriteStartElement("items");
            
            foreach (TKey key in this.Keys)
            {
                writer.WriteStartElement("item");

                keySerializer.Serialize(writer, key);
                TValue value = this[key];
                valueSerializer.Serialize(writer, value);

                writer.WriteEndElement();
            }

            writer.WriteEndElement();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.UserGameData.DataContracts\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.UserGameData.DataContracts")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9d04a3e2-223f-447a-840d-99678ccfc0b5")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\CertUtil.cs ===
//
// CertUtil.cs
//
// Stuff to deal with certificates
//

using System;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Security.Cryptography.X509Certificates;

namespace Leet.Core.Utils
{
    //
    // CertUtil
    //
    // Exposes one public static method: GetCertificate - that returns a
    // X509Certificate given the subject of the certificate
    //

    [ComVisible(false)]
    public class CertUtil
    {
        public static X509Certificate GetCurrentUserCertificate(string certSubject)
        {
            // call LoadUserProfile
            IntPtr logonToken = WindowsIdentity.GetCurrent().Token;

            PROFILEINFO info = new PROFILEINFO();
            info.dwSize = Marshal.SizeOf(info);
            info.lpUserName = WindowsIdentity.GetCurrent().Name;
            info.dwFlags = 1; // P_NOUI

            if ( false == WinApiLoadUserProfile(logonToken, ref info) )
            {
                throw new System.ComponentModel.Win32Exception();
            }

            uint dwFlags = CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG;
            return GetCertificate(dwFlags, certSubject);
        }

        public static X509Certificate GetLocalMachineCertificate(string certSubject)
        {
            uint dwFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG;
            return GetCertificate(dwFlags, certSubject);
        }

        public static X509Certificate GetCertificate(uint dwFlags, string certSubject)
        {
            IntPtr hSystemStore = IntPtr.Zero;
            IntPtr hCert        = IntPtr.Zero;

            try
            {
                hSystemStore = WinApiCertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                    0, IntPtr.Zero, dwFlags, "MY");

                if(hSystemStore == IntPtr.Zero)
                {
                    throw new Exception("WinApiCertOpenStore failed. Error=" +
                        Marshal.GetLastWin32Error());
                }

                hCert = WinApiCertFindCertificateInStore(hSystemStore,
                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 0,
                    CERT_FIND_SUBJECT_STR_W, certSubject, IntPtr.Zero);

                if(hCert == IntPtr.Zero)
                {
                    throw new Exception(string.Format("Failed to find certificate '{0}'. Error={1}",
                        certSubject, Marshal.GetLastWin32Error()));
                }

                return new X509Certificate(hCert);
            }
            finally
            {
                if(hCert != IntPtr.Zero)
                    WinApiCertFreeCertificateContext(hCert);

                if(hSystemStore != IntPtr.Zero)
                {
                    if(WinApiCertCloseStore(hSystemStore, 0) == 0)
                    {
                        throw new Exception("WinApiCertCloseStore failed. Error=" + Marshal.GetLastWin32Error());
                    }
                }
            }
        }

        public static string GetKeyFileName(X509Certificate cert)
        {
            IntPtr hProvider = IntPtr.Zero;
            bool freeProvider = false;
            UInt32 acquireFlags = CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_SILENT_FLAG;
            int _keyNumber = 0;
            string keyFileName = null;
            byte[] keyFileBytes = null;

            //
            // Determine whether there is private key information available for this certificate in the key store
            //
            if (WinApiCryptAcquireCertificatePrivateKey(cert.Handle,
                 acquireFlags,
                 IntPtr.Zero,
                 ref hProvider,
                 ref _keyNumber,
                 ref freeProvider))
            {
                IntPtr pBytes = IntPtr.Zero;    // Native Memory for the CRYPT_KEY_PROV_INFO structure
                int cbBytes = 0;                // Native Memory size

                try
                {
                    if (WinApiCryptGetProvParam(hProvider,
                            CryptGetProvParamType.PP_UNIQUE_CONTAINER,
                            IntPtr.Zero,
                            ref cbBytes,
                            0))
                    {
                        pBytes = Marshal.AllocHGlobal(cbBytes);

                        if (WinApiCryptGetProvParam(hProvider,
                                CryptGetProvParamType.PP_UNIQUE_CONTAINER,
                                pBytes,
                                ref cbBytes,
                                0))
                        {
                            keyFileBytes = new byte[cbBytes];
                            Marshal.Copy(pBytes, keyFileBytes, 0, cbBytes);

                            keyFileName = System.Text.Encoding.ASCII.GetString(keyFileBytes, 0, keyFileBytes.Length - 1);
                        }
                    }
                }
                finally
                {
                    if (freeProvider)
                        WinApiCryptReleaseContext(hProvider, 0);

                    if (pBytes != IntPtr.Zero)
                    {
                        Marshal.FreeHGlobal(pBytes);
                    }
                }
            }
            else
            {
                throw new Exception("WinApiCryptAcquireCertificatePrivateKey failed. Error = " + Marshal.GetLastWin32Error());
            }

            if (keyFileName == null)
            {
                throw new Exception("GetKeyFileName: Unable to obtain private key file name. Error = " + Marshal.GetLastWin32Error());
            }

            return keyFileName;
        }

        struct PROFILEINFO {
            public int dwSize;
            public int dwFlags;
            public String lpUserName;
            public String lpProfilePath;
            public String lpDefaultPath;
            public String lpServerName;
            public String lpPolicyPath;
            public IntPtr hProfile;
        }

        [DllImport("userenv.dll", EntryPoint="LoadUserProfile", SetLastError=true, CallingConvention=CallingConvention.StdCall, CharSet=CharSet.Auto)]
        static extern bool WinApiLoadUserProfile(IntPtr hToken, ref PROFILEINFO lpProfileInfo);


        [DllImport("crypt32.dll",  EntryPoint="CryptDecodeObject",
            ExactSpelling=true, SetLastError=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern int WinApiCryptDecodeObject(
            UInt32 dwCertEncodingType,
            UInt32 structType,
            byte[] pbEncoded,
            UInt32 cbEncoded,
            UInt32 dwFlags,
            byte[] pvStructInfo,
            ref UInt32 pcbStructInfo);

        [DllImport("crypt32.dll", EntryPoint="CertCreateCertificateContext",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertCreateCertificateContext(
            UInt32 dwCertEncodingType,
            byte[] pbCertEncoded,
            UInt32 cbCertEncoded);

        [DllImport("crypt32.dll", EntryPoint="CertGetCertificateContextProperty",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertGetCertificateContextProperty(
            IntPtr pCertContext,
            UInt32 dwPropId,
            byte[] pvData,
            ref UInt32 pcbData);

        [DllImport("crypt32.dll", EntryPoint="CertFreeCertificateContext",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertFreeCertificateContext(
            IntPtr pCertContext);

        [DllImport("crypt32.dll", EntryPoint="CertOpenStore",
            SetLastError=true, ExactSpelling=true, CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertOpenStore(
            UInt32 storeProvider,
            UInt32 dwMsgAndCertEncodingType,
            IntPtr hCryptProv,
            UInt32 dwFlags,
            string pvPara);

        [DllImport("crypt32.dll", EntryPoint="CertFindCertificateInStore",
            SetLastError=true, ExactSpelling=true, CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertFindCertificateInStore(
          IntPtr hCertStore,
          UInt32 dwCertEncodingType,
          UInt32 dwFindFlags,
          UInt32 dwFindType,
          string pvFindPara,
          IntPtr pPrevCertContext);

        [DllImport("crypt32.dll", EntryPoint="CertCloseStore",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertCloseStore(
            IntPtr hCertStore,
            UInt32 dwFlags);


        [DllImport("crypt32.dll", EntryPoint = "CryptAcquireCertificatePrivateKey",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern bool WinApiCryptAcquireCertificatePrivateKey(
            IntPtr pCert,
            UInt32 dwFlags,
            IntPtr pvReserved,
            ref IntPtr phCryptProv,
            ref int pdwKeySpec,
            ref bool pfCallerFreeProv);

        [DllImport("advapi32.dll", EntryPoint = "CryptGetProvParam",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        internal extern static bool WinApiCryptGetProvParam(
            IntPtr hCryptProv,
            CryptGetProvParamType dwParam,
            IntPtr pvData,
            ref int pcbData,
            uint dwFlags);

        [DllImport("advapi32.dll", EntryPoint = "CryptReleaseContext",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        internal extern static bool WinApiCryptReleaseContext(IntPtr hProv, uint dwFlags);

        protected const UInt32 CRYPT_ASN_ENCODING       = 0x00000001;
        protected const UInt32 CERT_KEY_IDENTIFIER_PROP_ID = 20;
        protected const UInt32 RSA_CSP_PUBLICKEYBLOB    = 19;
        protected const UInt32 X509_ASN_ENCODING        = 0x00000001;
        protected const UInt32 PKCS_7_ASN_ENCODING      = 0x00010000;
        protected const byte   PUBLICKEYBLOB            = 0x6;
        protected const byte   CUR_BLOB_VERSION         = 2;
        protected const UInt32 ALG_CLASS_SIGNATURE      = (1 << 13);
        protected const UInt32 ALG_CLASS_KEY_EXCHANGE   = (5 << 13);
        protected const UInt32 ALG_TYPE_RSA             = (2 << 9);
        protected const UInt32 ALG_SID_RSA_ANY          = 0;
        protected const UInt32 CALG_RSA_SIGN            = (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY);
        protected const UInt32 CALG_RSA_KEYX            = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY);
        protected const UInt32 CERT_STORE_PROV_SYSTEM_W = 10;
        protected const Int32  CERT_SYSTEM_STORE_LOCATION_SHIFT =16;
        protected const UInt32 CERT_SYSTEM_STORE_CURRENT_USER_ID = 1;
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = 2;
        protected const UInt32 CERT_SYSTEM_STORE_CURRENT_USER = (CERT_SYSTEM_STORE_CURRENT_USER_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE = (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_COMPARE_NAME_STR_W  = 8;
        protected const Int32  CERT_COMPARE_SHIFT       = 16;
        protected const UInt32 CERT_INFO_SUBJECT_FLAG   = 7;
        protected const UInt32 CERT_FIND_SUBJECT_STR_W  = (CERT_COMPARE_NAME_STR_W << CERT_COMPARE_SHIFT | CERT_INFO_SUBJECT_FLAG);
        protected const UInt32 CERT_CLOSE_STORE_FORCE_FLAG = 0x00000001;
        protected const UInt32 CERT_CLOSE_STORE_CHECK_FLAG = 0x00000002;
        protected const UInt32 CERT_STORE_READONLY_FLAG = 0x00008000;

        protected const UInt32 CRYPT_ACQUIRE_COMPARE_KEY_FLAG   = 0x00000004;
        protected const UInt32 CRYPT_ACQUIRE_SILENT_FLAG        = 0x00000040;

        internal enum CryptGetProvParamType
        {
            PP_ENUMALGS = 1,
            PP_ENUMCONTAINERS = 2,
            PP_IMPTYPE = 3,
            PP_NAME = 4,
            PP_VERSION = 5,
            PP_CONTAINER = 6,
            PP_CHANGE_PASSWORD = 7,
            PP_KEYSET_SEC_DESCR = 8,
            PP_CERTCHAIN = 9,
            PP_KEY_TYPE_SUBTYPE = 10,
            PP_PROVTYPE = 16,
            PP_KEYSTORAGE = 17,
            PP_APPLI_CERT = 18,
            PP_SYM_KEYSIZE = 19,
            PP_SESSION_KEYSIZE = 20,
            PP_UI_PROMPT = 21,
            PP_ENUMALGS_EX = 22,
            PP_ENUMMANDROOTS = 25,
            PP_ENUMELECTROOTS = 26,
            PP_KEYSET_TYPE = 27,
            PP_ADMIN_PIN = 31,
            PP_KEYEXCHANGE_PIN = 32,
            PP_SIGNATURE_PIN = 33,
            PP_SIG_KEYSIZE_INC = 34,
            PP_KEYX_KEYSIZE_INC = 35,
            PP_UNIQUE_CONTAINER = 36,
            PP_SGC_INFO = 37,
            PP_USE_HARDWARE_RNG = 38,
            PP_KEYSPEC = 39,
            PP_ENUMEX_SIGNING_PROT = 40,
            PP_CRYPT_COUNT_KEY_USE = 41,
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\CustomLocales.cs ===
﻿
namespace Leet.Utils
{
    using System;
    using System.Collections.Generic;
    
    public class CustomLocales
    {
        public static readonly Dictionary<string, ushort> DefaultAllowedLocales = new Dictionary<string, ushort>(StringComparer.OrdinalIgnoreCase)
        {
            { "cs-CZ", 1029 },
            { "da-DK", 1030 },
            { "de-AT", 3079 },
            { "de-CH", 2055 },
            { "de-DE", 1031 },
            { "el-GR", 1032 },
            { "en-AU", 3081 },
            { "en-CA", 4105 },
            { "en-GB", 2057 },
            { "en-HK", 15369 },
            { "en-IE", 6153 },
            { "en-IN", 16393 },
            { "en-NZ", 5129 },
            { "en-SG", 18441 },
            { "en-US", 1033 },
            { "en-ZA", 7177 },
            { "es-CL", 13322 },
            { "es-CO", 9226 },
            { "es-ES", 3082 },
            { "es-MX", 2058 },
            { "fi-FI", 1035 },
            { "fr-BE", 2060 },
            { "fr-CA", 3084 },
            { "fr-CH", 4108 },
            { "fr-FR", 1036 },
            { "hu-HU", 1038 },
            { "it-IT", 1040 },
            { "ja-JP", 1041 },
            { "ko-KR", 1042 },
            { "nl-NL", 1043 },
            { "nl-BE", 2067 },
            { "nb-NO", 1044 },
            { "pl-PL", 1045 },
            { "pt-BR", 1046 },
            { "pt-PT", 2070 },
            { "ru-RU", 1049 },
            { "sk-SK", 1051 },
            { "sv-SE", 1053 },
            { "zh-HK", 3076 },
            { "zh-TW", 1028 }
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\DiagnosticData.cs ===
﻿
namespace Leet.Utils
{
    using System.Diagnostics;
    using Leet.Core.Diagnostics;

    public class EventDetail : BaseEvent
    {
        public EventDetail()
        {
            
        }

        public EventDetail(int eventId, TraceEventType traceEventType, string message)
            : base(eventId, traceEventType, message)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\CustomHeaderValidator.cs ===
﻿
namespace Leet.Core.Utils
{
    using System;
    using Leet.Core.IoCCo;
    using Leet.Utils;
    
    public static class CustomHeaderValidator
    {
        /// <summary>
        /// Converts any validation error into an ArgumentException error.
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        public static void ValidateServiceHttpHeaders(string locale, string platformType)
        {
            ValidateLocaleHttpHeader(locale);
            ValidatePlatformTypeHttpHeader(platformType);
        }

        /// <summary>
        /// X-Locale is a mandatory field.
        /// </summary>
        /// <param name="locale"></param>
        public static void ValidateLocaleHttpHeader(string locale)
        {
            if (string.IsNullOrEmpty(locale))
            {
                throw new ArgumentException("X-locale header is not defined");
            }

            var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();

            if (!localeHelper.Exists(locale))
            {
                throw new ArgumentException(string.Format("X-locale not within allowed locales: {0}", locale));
            }
        }

        /// <summary>
        /// Platform type is a mandatory field.
        /// </summary>
        /// <param name="platformType"></param>
        public static void ValidatePlatformTypeHttpHeader(string platformType)
        {
            if (string.IsNullOrEmpty(platformType))
            {
                throw new ArgumentException("X-Platform-Type header is not defined");
            }

            uint platformTypeNum;

            try
            {
                platformTypeNum = uint.Parse(platformType);

                if (!IsPlatformTypeInValidRange(platformTypeNum))
                {
                    throw new ArgumentException(string.Format("X-Platform-Type header is out of range: {0}", platformType));
                }
            }
            catch (FormatException ex)
            {
                throw new ArgumentException(string.Format("X-Platform-Type header is not in a valid format: {0}", platformType), ex);
            }
            catch (OverflowException ex)
            {
                throw new ArgumentException(string.Format("X-Platform-Type header is out of range: {0}", platformType), ex);
            }
        }

        /// <summary>
        /// Checks whether a given platform id is within allowed values.
        /// </summary>
        /// <param name="platform"></param>
        /// <returns></returns>
        public static bool IsPlatformTypeInValidRange(uint platform)
        {
            return Platforms.IsValidPlatform(platform);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\BILogging.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="BILogging.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Common functions that can be used to log BI data
// </summary>
//
//-------------------------------------------------------------------

using System;
using System.Collections.Generic;
using Leet.Core.BI;  
using Leet.Core.IoCCo;

namespace Leet.Core.Utils
{
    public class BILogging
    {
        /// <summary>
        /// log the BI data for an API call without any additonal API-specific data
        /// </summary>
        /// <param name="originator">Xbox (when we have a user xuid) or Partner (partner xuid)</param>
        /// <param name="xuid"></param>
        /// <param name="platformType"></param>
        /// <param name="gameId"></param>
        /// <param name="serviceName">For example "GDS.Services.UserData"</param>
        /// <param name="apiName">Name of the API for logging</param>
        public static void LogBIData(OriginatorIDType originator, ulong xuid, string platformType, uint gameId, string serviceName, string apiName)
        {
            BILogging.LogBIData(originator, xuid, platformType, gameId, serviceName, apiName, string.Empty);
        }

        /// <summary>
        /// log the BI data for an API call with additonal API-specific data
        /// </summary>
        /// <param name="originator">Xbox (when we have a user xuid) or Partner (partner xuid)</param>
        /// <param name="xuid"></param>
        /// <param name="platformType"></param>
        /// <param name="gameId"></param>
        /// <param name="serviceName">For example "GDS.Services.UserData"</param>
        /// <param name="activityName">Name of the activity, typically API name, to log.</param>
        /// <param name="activityValue">Value of the activity to log, could be any API-specific data.</param>
        public static void LogBIData(OriginatorIDType originator, ulong xuid, string platformType, uint gameId, string serviceName, string activityName, string activityValue)
        {
            IBILog biLog = Container.Instance.GetComponent<IBILog>();

            short shortPlatformType;
            Int16.TryParse(platformType, out shortPlatformType);

            BICredentials biCredentials = new BICredentials(xuid,
                                                            originator,
                                                            shortPlatformType,
                                                            "1.0.0", // platform version
                                                            gameId,
                                                            serviceName,
                                                            "1.0.0.0", // service version
                                                            "",  // carrier name
                                                            "",  // geo location
                                                            ""); // oem

            // Log only API name with empty value
            List<KeyValuePair<string, string>> activityKVP = new List<KeyValuePair<string, string>>();
            activityKVP.Add(new KeyValuePair<string, string>(activityName, activityValue));

            biLog.Log(biCredentials, activityKVP);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\CustomWebHeaderNames.cs ===
﻿namespace Leet.Core.Utils
{
    public static class CustomWebHeaderNames
    {
        /// <summary>
        /// The header name for locale setting in the http header
        /// </summary>
        public const string XLocale = "X-Locale";

        /// <summary>
        /// The HTTP header name for platform type setting.
        /// </summary>
        public const string XPlatformType = "X-Platform-Type";

        /// <summary>
        /// The header is optional and will default to 1.00.0000.
        /// We will utilize a standardized version number in the following format: <MAJOR>.<MINOR>.<REVISION>.   
        /// For our initial release we will be targeting 1.00.0000. This format is :
        /// X-API-Version: 1.00.0000
        /// </summary>
        public const string XApiVersion = "X-Api-Version";

        /// <summary>
        /// The purpose of this HTTP header field is to identify the clients that are utilizing our services.  
        /// This is similar to the User Agent string.  Currently we will not be changing the functionality of the services in response to this.  
        /// Primarly this will be leverged for Business Intellegance metrics on clients. The header is optional.
        /// Example 
        /// X-Client-Version: Qualcomm 8250B Windows Mobile 7
        /// </summary>
        public const string XClientVersion = "X-Client-Version";

        /// <summary>
        /// This header will contain the RPS ticket of the calling user. Note that this is NOT passed as a cookie. Format is:
        /// X-Authorization: WLID1.0 t=<compact ticket>
        /// </summary>
        public const string XAuthorization = "X-Authorization";

        /// <summary>
        /// This header will contain the partnertoken of the calling user. Note that this is NOT passed as a cookie. Format is:
        /// X-PartnerAuthorization: XBL1.0 t=<partner token XML>
        /// </summary>
        public const string XPartnerAuthorization = "X-PartnerAuthorization";


        /// <summary>
        /// This header specifies RPS ticket parameters for generating STS tickets from WebSTS for non xboxlive.com
        /// service targets.  The format of the header is a single line of comma separated name/value properties. 
        /// The properties are: 
        ///     PUID - The user PUID from RPS - Unsigned 64-bit integer
        ///     CID - The hashed user PUID from RPS - Unsigned 64-bit integer
        ///     IssueInstant - When the RPS ticket was issued - UTC time 
        ///     NotAfter - When the RPS ticket expires - UTC time 
        ///     ClientIp - IP address of the client of WPLC - IPv4 or IPv6 IP address
        ///     
        /// Example:
        /// X-WebSTS-RPS-Parameters: puid=985160363921909, cid=10774899661264202724, IssueInstant=2010-07-08 01:18:14Z, NotAfter=2010-07-08 04:18:14Z, clientip=fe80::dc6:ea01:7a4f:ac46%14 
        /// </summary>
        public const string XWebStsRpsParameters = "X-WebSTS-RPS-Parameters";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\EventAttributes.cs ===
﻿namespace Leet.Utils
{
    using System;
    using System.Diagnostics;
    
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public sealed class EventAttribute : Attribute
    {
        private string message;
        private int msgID = -1;
        private int resourceId = -1;
        private int facility = 0;
        private bool error = true; 
        private TraceEventType eventType = TraceEventType.Information;

        public EventAttribute()
        {
        }

        public bool Error
        {
            get { return this.error; }
            set { this.error = value; }
        }

        public string Message
        {
            get { return this.message; }
            set { this.message = value; }
        }

        public int MessageId
        {
            get { return this.msgID; }
            set { this.msgID = value; }
        }

        public TraceEventType TraceEventType
        {
            get { return this.eventType; }
            set { this.eventType = value; }
        }

        public int ResourceId
        {
            get { return this.resourceId; }
            set { this.resourceId = value; }
        }

        public int Facility
        {
            get { return this.facility; }
            set { this.facility = value; }
        }
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class EventCategoryAttribute : Attribute
    {
        private int baseCounter;
        private string description;
        private int incrementAmount = 10;
        private string resourceBaseName;
        private string resourceAssembly;

        public EventCategoryAttribute()
        {
        }

        public int MessageIdBase
        {
            get { return this.baseCounter; }
            set { this.baseCounter = value; }
        }

        public int IncrementAmount
        {
            get { return this.incrementAmount; }
            set { this.incrementAmount = value; }
        }

        public string Description
        {
            get { return this.description; }
            set { this.description = value; }
        }

        public string ResourceBaseName
        {
            get { return this.resourceBaseName; }
            set { this.resourceBaseName = value; }
        }

        public string ResourceAssemblyName
        {
            get { return this.resourceAssembly; }
            set { this.resourceAssembly = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\LIVEnException.cs ===
//-----------------------------------------------------------------------------
// <copyright file="LIVEnException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//     This module contains exception wrappers Live Engagement Team
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="9/25/2009">
//     created
// </history>
//-----------------------------------------------------------------------------


namespace Leet.Core.Utils
{
    using System;
    using System.Collections;
    using System.Globalization;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Utils;
    using Leet.Core.Diagnostics;
    using Microsoft.ServiceModel.Web;
    
    /// <summary>
    /// This enum defines the LIVEnException
    /// default error.
    /// </summary>
    public enum LIVEnExceptionError
    {
        /// <summary>
        /// Generic error.
        /// </summary>
        GenericError = 0
    }

    /// <summary>
    /// Encapsulating class for exceptions thrown by Live Engagement Services.
    /// This exception class will do the following:
    ///  Provides support for error code and error message
    ///  Provides support for automatic tracing when exception happens
    ///  Provides support for event logging when exception happens
    ///  Provides support conversion to WebProtocolException and other
    ///     exceptions if necessary
    /// </summary>
    [Serializable]
    public partial class LIVEnException : Exception
    {
        /// <summary>
        /// Live Engagement Service custom error code.
        /// </summary>
        private uint errorCode;

        /// <summary>
        /// Optional Http status code.
        /// </summary>
        private HttpStatusCode httpStatusCode;

        /// <summary>
        /// The public method name that caused this exception. 
        /// </summary>
        private string methodName;

        /// <summary>
        /// Include additonal message
        /// </summary>
        private string additionalMessage;

        #region Mandatory Exception constructors

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        public LIVEnException() : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="message">Error message.</param>
        public LIVEnException(string message) :
            this(0, HttpStatusCode.InternalServerError, message, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="message">Error message.</param>
        /// <param name="innerException">Inner exception.</param>
        public LIVEnException(string message, Exception innerException) :
            base(message, innerException)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="message">Error message.</param>
        /// <param name="statusCode">Http status code.</param>
        /// <param name="innerException">Inner exception.</param>
        public LIVEnException(string message, HttpStatusCode statusCode, Exception innerException) :
            base(message, innerException)
        {
            this.httpStatusCode = statusCode;
        }

        #endregion

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="events">Events collection.</param>
        /// <param name="eventIndex">The index to the predefined event message. </param>
        /// <param name="statusCode">HTTP Status code.</param>
        /// <param name="innerException">Inner exception.</param>
        /// <param name="publishEvent">Whether to publish event log or not.</param>
        /// <param name="arguments">Insertions strings for the message in message resource.</param>
        public LIVEnException(
            EventsCollection events,
            int eventIndex,
            HttpStatusCode statusCode,
            Exception innerException,
            bool publishEvent,
            params string[] arguments) :
            this(
                events, 
                eventIndex, 
                statusCode, 
                innerException, 
                "API Unknown", 
                publishEvent, 
                arguments)
        {
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class. Be careful about exposing the method name. 
        /// </summary>
        /// <param name="events">Events collection.</param>
        /// <param name="eventIndex">The index to the predefined event message. </param>
        /// <param name="statusCode">HTTP Status code.</param>
        /// <param name="innerException">Inner exception.</param>
        /// <param name="publishEvent">Whether to publish event log or not.</param>
        /// <param name="methodName">Name of the method.</param>
        /// <param name="arguments">Insertions strings for the message in message resource.</param>
        public LIVEnException(
            EventsCollection events,
            int eventIndex,
            HttpStatusCode statusCode, 
            Exception innerException,
            string methodName,
            bool publishEvent, 
            params string[] arguments) : 
            this(
                events.GetErrorCode(eventIndex),
                statusCode,
                LIVEnException.CreateMessage(events, eventIndex, arguments),
                innerException)
        {
            string optionalMessage = string.Empty;
            this.methodName = methodName; 
            if (publishEvent)
            {
                if (innerException != null)
                {
                    optionalMessage = "\r\nInner exception:\r\n" + innerException.ToString();
                }

                events.TraceEvent(eventIndex, optionalMessage, arguments);
            }
        }


        /// <summary>
        /// Initializes a new instance of the LIVEnException class. Be careful about exposing the method name. 
        /// </summary>
        /// <param name="events">Events collection.</param>
        /// <param name="eventIndex">The index to the predefined event message. </param>
        /// <param name="statusCode">HTTP Status code.</param>
        /// <param name="innerException">Inner exception.</param>
        /// <param name="methodName">Name of the method.</param>
        /// <param name="publishEvent">Whether to publish event log or not.</param>
        /// <param name="additionalMessage">Optional message to be added to event</param>
        /// <param name="arguments">Insertions strings for the message in message resource.</param>
        public LIVEnException(
            EventsCollection events,
            int eventIndex,
            HttpStatusCode statusCode,
            Exception innerException,
            string methodName,
            string additionalMessage,
            bool publishEvent,
            params string[] arguments) :
            this(
                events.GetErrorCode(eventIndex),
                statusCode,
                LIVEnException.CreateMessage(events, eventIndex, arguments),
                innerException)
        {
            this.methodName = methodName;
            this.additionalMessage = additionalMessage;
            string optionalMessage = additionalMessage;
            if (publishEvent)
            {
                if (innerException != null)
                {
                    optionalMessage += "\r\nInner exception:\r\n" + innerException.ToString();
                }

                events.TraceEvent(eventIndex, optionalMessage, arguments);
            }
        }
        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="events">Events collection.</param>
        /// <param name="eventIndex">The index of the predefined error message. </param>
        /// <param name="statusCode">HTTP Status code.</param>
        public LIVEnException(
            EventsCollection events,
            int eventIndex,
            HttpStatusCode statusCode) :
            this(
                events.GetErrorCode(eventIndex),
                statusCode,
                LIVEnException.CreateMessage(events, eventIndex, null),
                null)
        {
        }

        // TODO: Add event log support for exception constructor

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// This is the most basic version of the constructor which
        /// only initializes all values. After other constructors
        /// formats the message, this constructor gets called to 
        /// initialize all member fields.
        /// </summary>
        /// <param name="errorCode">Error Code.</param>
        /// <param name="httpStatusCode">HTTP Status code.</param>
        /// <param name="message">Error message.</param>
        /// <param name="innerException">Inner exception.</param>
        public LIVEnException(
            uint errorCode,
            HttpStatusCode httpStatusCode,
            string message,
            Exception innerException)
            : base(message, innerException)
        {
            // TODO: Replace the line below with the
            // extension method on the enum to get Int 
            // value. This is not a good approach
            this.errorCode = errorCode;
            this.httpStatusCode = httpStatusCode;
            TraceException(errorCode, message, innerException);
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="info">
        /// Serialization information.
        /// </param>
        /// <param name="context">
        /// Streaming context.
        /// </param>
        /// <param name="errorCode">
        /// Error code.
        /// </param>
        protected LIVEnException(
            SerializationInfo info,
            StreamingContext context,
            uint errorCode)
            :
            base(info, context)
        {
            this.errorCode = errorCode;
            TraceException(errorCode, string.Empty, null);
        }

        /// <summary>
        /// Initializes a new instance of the LIVEnException class.
        /// </summary>
        /// <param name="info">
        /// Serialization information.
        /// </param>
        /// <param name="context">
        /// Streaming context.
        /// </param>
        protected LIVEnException(
            SerializationInfo info,
            StreamingContext context)
            :
            base(info, context)
        {
        }

        /// <summary>
        /// Gets the error code.
        /// </summary>
        public uint ErrorCode
        {
            get { return this.errorCode; }
        }

        /// <summary>
        /// This method is required by Serializable attribute to 
        /// </summary>
        /// <param name="info">Serialization info.</param>
        /// <param name="context">Streaming context.</param>
        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
            {
                throw new ArgumentNullException("info");
            }

            base.GetObjectData(info, context);
            info.AddValue("ErrorCode", this.errorCode);
            info.AddValue("HttpStatusCode", this.httpStatusCode);
        }

        /// <summary>
        /// This method throws a web protocol exception.
        /// </summary>
        public
        void
        ThrowWebProtocolException()
        {
            string message = this.Message;

            var configProvider =
                Container.Instance.GetComponent<IConfigurationProvider>();
            
            bool includeExceptionDetailInErrorMessage = Convert.ToBoolean(
                 Container.Instance.GetComponent<IConfigurationProvider>().GetSetting(Settings.IncludeExceptionDetailInErrorMessage));
 
            // In debug mode, append innerException details
            if (includeExceptionDetailInErrorMessage)
            {
                if (this.InnerException != null)
                {
                    message += this.additionalMessage + "\r\n" + this.InnerException.ToString();
                }
            }

            message = Convert.ToString(this.ErrorCode, CultureInfo.InvariantCulture) + " " + message;

            throw new WebProtocolException(
                this.httpStatusCode, 
                string.Empty,
                new ServiceErrorMessage() { ApiName = this.methodName, LIVEnErrorCode = this.errorCode, ErrorMessage = message }, 
                null);
        }

        /// <summary>
        /// Trace the exception
        /// </summary>
        /// <param name="errorCodeTrace">Error code.</param>
        /// <param name="message">Error message.</param>
        /// <param name="innerException">Inner exception.</param>
        private static void TraceException(uint errorCodeTrace, string message, Exception innerException)
        {
            Logging.TraceException(innerException, "{0} > {1} {2} {3} {4}",
                "LIVEnException",
                "LIVEnException 0X",
                errorCodeTrace.ToString("X", CultureInfo.InvariantCulture),
                " occurred: ",
                message);
        }

        /// <summary>
        /// Create a message based on the error code/Event ID and the
        /// arguments to the message.
        /// TODO: Move this function into EventsCollection class
        /// </summary>
        /// <param name="events">Event collection.</param>
        /// <param name="eventIndex">The index of the predefined error message in the event collection. </param>
        /// <param name="arguments">argument strings.</param>
        /// <returns>Message formatted.</returns>
        private static string CreateMessage(
            EventsCollection events,
            int eventIndex, 
            params string[] arguments)
        {
            // Get errorCodeTrace's event attribute
            if (events != null)
            {
                return events.FormatMessage(eventIndex, arguments);
            }
            else
            {
                return string.Empty;
            }
        }
    }

    /// <summary>
    /// Custom Error Message for LIVEnServices
    /// </summary>
    public class ServiceErrorMessage
    {
        /// <summary>
        /// Gets or sets Name of the API
        /// </summary>
        public string ApiName { get; set; }

        /// <summary>
        /// Gets or sets LIVEn Error code
        /// </summary>
        public uint LIVEnErrorCode { get; set; }

        /// <summary>
        /// Gets or sets detailed Error Message
        /// </summary>
        public string ErrorMessage { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\Events.cs ===
﻿
namespace Leet.Utils
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Reflection;
    using Leet.Core.Diagnostics;

    public class EventsCollection : IEnumerable<EventAttribute>, IEnumerator<EventAttribute>
    {
        private EventAttribute[] events;

        public EventsCollection(Type classType, object classInstance)
        {
            this.Initialize(classType, classInstance);
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId, TraceEventType eventType)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                eventAttrib.TraceEventType = eventType;
                this.InternalTraceEvent(eventAttrib, string.Empty, null);
            }
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                this.InternalTraceEvent(eventAttrib, string.Empty, null);
            }
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId, TraceEventType eventType, params object[] args)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                eventAttrib.TraceEventType = eventType;
                this.InternalTraceEvent(eventAttrib, string.Empty, args);
            }
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId, params object[] args)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                this.InternalTraceEvent(eventAttrib, string.Empty, args);
            }
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId, string optionalMessage, params object[] args)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                this.InternalTraceEvent(eventAttrib, optionalMessage, args);
            }
        }

        #region IEnumerable Members

        public IEnumerator GetEnumerator()
        {
            return this.events.GetEnumerator();
        }

        #endregion

        #region IEnumerator Members

        public object Current
        {
            get { return this.events.GetEnumerator().Current; }
        }

        public bool MoveNext()
        {
            return this.events.GetEnumerator().MoveNext();
        }

        public void Reset()
        {
            this.events.GetEnumerator().Reset();
        }

        /// <summary>
        /// This method formats the message of a given event id based
        /// on the arguments
        /// </summary>
        /// <param name="eventIndex">Event index.</param>
        /// <param name="args">Argument strings.</param>
        /// <returns>Formatted messages.</returns>
        public string FormatMessage(int eventIndex, params string[] args)
        {
            string msg;
            EventAttribute attribute = GetEventAttribute(eventIndex);

            if (attribute == null)
            {
                return string.Empty;
            }

            if (args == null || args.Length == 0) // make sure string.Format wouldn't throw when args.Length = 0
            {
                msg = attribute.Message;
            }
            else
            {
                msg = string.Format(attribute.Message, args);
            }

            return msg;
        }

        /// <summary>
        /// This method returns the error code associated with an event. 
        /// </summary>
        /// <param name="eventIndex">Event Index</param>
        /// <returns>Error Code</returns>
        public uint GetErrorCode(int eventIndex)
        {
            EventAttribute attribute = GetEventAttribute(eventIndex);
            uint id = ((uint)attribute.Facility << 16 & 0x0FFF0000) | (0x0000FFFF & (uint)attribute.MessageId);
            if (attribute.Error)
            {
                id = 0x80000000 | id;
            }

            return id;
        }

        /// <summary>
        /// This method returns the real event Id associated
        /// with an event
        /// </summary>
        /// <param name="eventIndex">Event index.</param>
        /// <returns>Event Id.</returns>
        public int GetEventId(int eventIndex)
        {
            EventAttribute attribute = GetEventAttribute(eventIndex);
            return attribute.MessageId;
        }

        #endregion

        #region IEnumerable<EventAttribute> Members

        IEnumerator<EventAttribute> IEnumerable<EventAttribute>.GetEnumerator()
        {
            return ((IEnumerable<EventAttribute>)events.GetEnumerator()).GetEnumerator();
        }

        #endregion

        #region IEnumerator<EventAttribute> Members

        EventAttribute IEnumerator<EventAttribute>.Current
        {
            get { return ((IEnumerator<EventAttribute>)events.GetEnumerator()).Current; }
        }

        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Internal method to implement trace event
        /// </summary>
        /// <param name="eventAttrib">Event attribute</param>
        /// <param name="args">Argument strings</param>
        /// <param name="optionalMessage">An optional message to append. Used for
        /// InnerException which may not be included in the message string
        /// </param>
        protected void InternalTraceEvent(EventAttribute eventAttrib, string optionalMessage, object[] args)
        {

                try
                {
                    string msg = String.Empty;
                    // some of the calls will be with args.Length = 0
                    if (args == null || args.Length == 0)
                    {
                        msg = eventAttrib.Message;
                    }
                    else
                    {
                        msg = string.Format(eventAttrib.Message, args);
                    }

                    // Append the optional message to the end.
                    // Mostly used by innerException.
                    // There are two use cases of the events defined in events class
                    //   1. Used to generate error details to send outside of service 
                    //      boundary, for example in HTTP response.
                    //   2. Used to generate event log entry which should include as
                    //      much information as possible.
                    // In former case, Inner exception should not not sent outside of 
                    // service boundary, thus the message defined in the Events class 
                    // should not include it by default. The optionalMessage let the
                    // consumer of this class to provide innerException information
                    // when creating internal event log entries.
                    msg = msg + optionalMessage;

                    ILogging logging = Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>();
                    logging.LogEvent(new EventDetail(eventAttrib.MessageId, eventAttrib.TraceEventType, msg));

                }
                catch (System.FormatException ex)
                {
                    Logging.TraceException(ex, "Unable to trace message for event ID {0}", eventAttrib.MessageId);
                }
                catch (System.ArgumentNullException ex)
                {
                    Logging.TraceException(ex, "Unable to trace message for event ID {0}", eventAttrib.MessageId);
                }
            
        }

        public EventAttribute GetEventAttribute(int eventIndex)
        {
            EventAttribute eventAttrib = null;
            if (this.events == null)
            {
                //Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Events collection has not been initialized"), EventLogEntryType.Warning, 1079, new TraceSourceGeneralException("EventsCollection Initialize() method has not been called"));
            }
            else if (this.events.Length > eventIndex)
            {
                eventAttrib = this.events[eventIndex];
            }
            else
            {
                Logging.TraceError("Event index out of array bounds for eventID {0}", eventIndex);
            }

            return eventAttrib;
        }

        protected void Initialize(Type classType, object classInstance)
        {
            int count = 0;
            int baseCounter = 0;
            int incrementAmount = 10;
            {
                if (classType.IsClass)
                {
                    EventCategoryAttribute eventCatattrib = (EventCategoryAttribute)Attribute.GetCustomAttribute(classType, typeof(EventCategoryAttribute));

                    // is there a event category attribute defined for this class?
                    if (eventCatattrib != null)
                    {
                        baseCounter = eventCatattrib.MessageIdBase;
                        incrementAmount = eventCatattrib.IncrementAmount;
                    }
                    else
                    {
                        baseCounter = 0;
                    }

                    System.Reflection.FieldInfo[] fieldInfos = classType.GetFields();       // obtain field meta data (public fields can act as perf counters)
                    foreach (FieldInfo fieldInfo in fieldInfos)
                    {
                        EventAttribute[] attributes = (EventAttribute[])fieldInfo.GetCustomAttributes(typeof(EventAttribute), true);
                        if (this.events != null)
                        {
                            Array.Resize<EventAttribute>(ref this.events, this.events.Length + attributes.Length);
                        }
                        else
                        {
                            Array.Resize<EventAttribute>(ref this.events, attributes.Length);
                        }

                        foreach (EventAttribute eventAttrib in attributes)
                        {
                            if (eventAttrib.MessageId == -1)
                            {
                                eventAttrib.MessageId = baseCounter;
                                baseCounter += incrementAmount;
                            }

                            try
                            {
                                // set value appropriately
                                fieldInfo.SetValue(classInstance, count);

                                // load resource manager                                
                                if (eventAttrib.ResourceId != -1)
                                {
                                    // TO DO
                                    // Add support for resource Id's
                                }

                                this.events[count++] = eventAttrib;
                            }
                            catch (FieldAccessException ex)
                            {
                                Logging.TraceException(ex, "Unable to access field {0} event for  event ID {1}", fieldInfo.Name, eventAttrib.MessageId);
                            }
                            catch (System.Reflection.TargetException ex)
                            {
                                Logging.TraceException(ex, "Unable to access field {0} event for  event ID {1}", fieldInfo.Name, eventAttrib.MessageId);
                            }
                            catch (ArgumentException ex)
                            {
                                Logging.TraceException(ex, "Unable to access field {0} event for  event ID {1}", fieldInfo.Name, eventAttrib.MessageId);
                            }
                        }
                    }
                }
            }
        }

        protected virtual void Dispose(bool disposing)
        {
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\LIVEnTraceListener.cs ===
//-------------------------------------------------------------------
// <copyright file="LIVEnTraceListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Defines DateTraceListner class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="12/12/2008">
//     Class created
// </history>
// <history date="09/14/2009">
//     Adopted for LIVE engagement team
// </history>
//-------------------------------------------------------------------

namespace Leet.Core.Utils
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Text;

    /// <summary>
    /// DateTraceListener is a custom trace listener which creates
    /// the log file based on the date and in the future could support
    /// maximum log file size.
    /// </summary>
    public class DateTraceListener : TraceListener
    {
        /// <summary>
        /// Format string in the initialize data.
        /// </summary>
        private const string FormatString = "%d";

        /// <summary>
        /// String format of the date for trace log.
        /// </summary>
        private const string DateFormat = "yyyy-MM-dd";

        /// <summary>
        /// Buffer size.
        /// </summary>
        private const int BufferSize = 0x1000;

        /// <summary>
        /// Lock object.
        /// </summary>
        private object thisLock = new Object();

        /// <summary>
        /// Text writer used to create trace log.
        /// </summary>
        private TextWriter writer;

        /// <summary>
        /// Current log file time stamp name.
        /// </summary>
        private string currentTimeStamp;

        /// <summary>
        /// Base file name.
        /// </summary>
        private string baseFileName = string.Empty;

        /// <summary>
        /// Directory name.
        /// </summary>
        private string directoryName = string.Empty;

        /// <summary>
        /// Use date based log file name or not.
        /// </summary>
        private bool useDateLog = false;

        /// <summary>
        /// Initializes a new instance of the DateTraceListener class.
        /// </summary>
        /// <param name="fileName">Log file name.</param>
        public DateTraceListener(string fileName)
        {
            string fullPath;

            if (string.IsNullOrEmpty(fileName))
            {
                return;
            }

            // This is a workaround to support relative path to the
            // configuration file instead of Application current directory
            // .NET implements this before calling the built-in trace listeners
            if ((fileName[0] != Path.DirectorySeparatorChar) &&
                (fileName[0] != Path.AltDirectorySeparatorChar) &&
                !Path.IsPathRooted(fileName))
            {
                string filePath =
                    AppDomain.CurrentDomain.SetupInformation.ConfigurationFile;

                if (!string.IsNullOrEmpty(filePath))
                {
                    string dirPath = Path.GetDirectoryName(filePath);
                    if (dirPath != null)
                    {
                        fileName = Path.Combine(dirPath, fileName);
                    }
                }
            }

            // Get path and base file name
            fullPath = Path.GetFullPath(fileName);
            this.directoryName = Path.GetDirectoryName(fullPath);
            this.baseFileName = Path.GetFileName(fullPath);

            // If we can find %d in the file name, we use date based log
            // or else this trace listener will function just as a
            // TextWriterTraceListener which writes into one log file
            if (this.baseFileName.IndexOf(FormatString, StringComparison.Ordinal) >= 0)
            {
                this.useDateLog = true;
            }
        }

        /// <summary>
        /// This method closes itself and releases all resources.
        /// </summary>
        public override void
        Close()
        {
            this.Dispose(true);
        }

        /// <summary>
        /// This method flushes the log file.
        /// </summary>
        public override void Flush()
        {
            lock (this.thisLock)
            {
                if (this.writer != null)
                {
                    this.writer.Flush();
                }
            }
        }

        /// <summary>
        /// This method outputs a trace message.
        /// </summary>
        /// <param name="message">Message to be output.</param>
        public override void
        Write(string message)
        {
            string timeStamp = null;

            // Lock to keep thread safe
            // Get timestamp part must be in the lock block
            lock (this.thisLock)
            {
                // Use server local time and cache it
                DateTime nowTime = DateTime.Now.ToLocalTime();

                // Create log file name by getting current time stamp
                timeStamp = nowTime.ToString(
                    DateFormat,
                    CultureInfo.InvariantCulture);

                if (!this.EnsureWriter(timeStamp))
                {
                    return;
                }

                // Write the message using the text writer
                // and append timestamp to the beginning of the message
                this.writer.Write(nowTime.ToString("o", CultureInfo.InvariantCulture) + " " + message);
            }

            // No exception is caught here because
            // When trace goes wrong, someone need to know immediately
            // This can't go silently since most of the troubleshooting
            // are depending on trace log
        }

        /// <summary>
        /// This method outputs a trace message with a line return.
        /// </summary>
        /// <param name="message">Message to be output.</param>
        public override void
        WriteLine(string message)
        {
            this.Write(message + Environment.NewLine);
        }

        /// <summary>
        /// This method disposes itself.
        /// </summary>
        /// <param name="disposing">True to release both managed and unmanaged, false unmanaged only.</param>
        protected override void
        Dispose(bool disposing)
        {
            if (disposing)
            {
                if (this.writer != null)
                {
                    this.writer.Close();
                }

                this.writer = null;
            }

            base.Dispose(disposing);
        }

        /// <summary>
        /// This method returns an encoding with fallback.
        /// </summary>
        /// <param name="encoding">Encoding to add fallback.</param>
        /// <returns>Encoding with Faillback.</returns>
        private static Encoding GetEncodingWithFallback(Encoding encoding)
        {
            Encoding encoding2 = (Encoding)encoding.Clone();
            encoding2.EncoderFallback = EncoderFallback.ReplacementFallback;
            encoding2.DecoderFallback = DecoderFallback.ReplacementFallback;
            return encoding2;
        }

        /// <summary>
        /// This method creates a new writer using the given time stamp.
        /// </summary>
        /// <param name="timeStamp">Time stamp.</param>
        /// <returns>true when it succeeds.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private bool
        EnsureWriter(string timeStamp)
        {
            bool succeed = false;
            string fullPath = null;
            Encoding encodingWithFallback = null;
            string fileName = null;

            // If we already have a writer, make sure we can use it
            if (this.writer != null)
            {
                // When we are not using date based log and writer has been
                // initialized, there is no need to create a new writer,
                // existing writer is good
                if (!this.useDateLog)
                {
                    return true;
                }
                else if (timeStamp == this.currentTimeStamp)
                {
                    // Even for date based log, no time stamp change
                    // so we are good
                    return true;
                }
            }

            // Now it is decided that we need a new writer
            // Close existing writer if it is not null
            if (this.writer != null)
            {
                this.writer.Close();
            }

            // Get encoding with fallback
            encodingWithFallback =
                GetEncodingWithFallback(new UTF8Encoding(false));

            // Get the file name ready
            fileName = this.baseFileName.Replace(FormatString, timeStamp);

            // Try twice to open the file
            // If the first time fails with IOException, get a random file
            // name and try again
            for (int i = 0; i < 2; i++)
            {
                // Create log file name
                fullPath = Path.Combine(
                    this.directoryName,
                    fileName);

                // Create a new stream writer
                try
                {
                    this.writer = new StreamWriter(
                        fullPath,
                        true,
                        encodingWithFallback,
                        BufferSize);

                    succeed = true;
                    break;
                }
                catch (IOException)
                {
                    // If IOException happens, create a random file name
                    // and try again, better than nothing
                    fileName = Guid.NewGuid().ToString();
                }
                catch (UnauthorizedAccessException)
                {
                    // For access problem, can't fix it
                    break;
                }
                catch (Exception)
                {
                    // Not causing application logic to fail
                    // ignore tracing errors
                    break;
                }
            }

            // Set the current log name
            if (succeed)
            {
                this.currentTimeStamp = timeStamp;
            }
            else
            {
                this.currentTimeStamp = null;
                this.writer = null;
            }

            return succeed;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\IWebOperationIncomingRequestHeaderReader.cs ===
﻿namespace Leet.Utils
{
    using System;

    public interface IWebOperationIncomingRequestHeaderReader
    {
        string this[string headerName] { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\FilteredMultipleIISBindingServiceHostFactory.cs ===
﻿namespace Leet.Utils
{
    using System;
    using System.Collections.Generic;
    using System.ServiceModel;
    using Leet.Core;
    using Leet.Core.Utils;
    using Microsoft.ServiceModel.Web;
    using Leet.Core.Diagnostics;


    /// <summary>
    /// A custom service host factory that support multiple bindings. 
    /// </summary>
    public class FilteredMultipleIISBindingServiceHostFactory: WebServiceHost2Factory
    {
        static string ComponentName = "ServiceFactory ";
        static string DomainToFilterBy = "xboxlive.com";

        /// <summary>
        /// Override the create service host method. 
        /// </summary>
        /// <param name="serviceType">The service type. </param>
        /// <param name="baseAddresses">An array of base addresses. </param>
        /// <returns>An instance of service host. </returns>
        protected override ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            // this call will filter addresses that is not relevant for binding.
            Uri[] requiredAddress = GetAppropriateBase(baseAddresses);
            return base.CreateServiceHost(serviceType, requiredAddress);
        }

        /// <summary>
        /// Filter the base addresses and only return ones that we want to bind. 
        /// </summary>
        /// <param name="baseAddresses">An array of current base addresses</param>
        /// <returns>An array of URIs for create service host. </returns>
        public static Uri[] GetAppropriateBase(Uri[] baseAddresses)
        {
            List<Uri> retAddress = new List<Uri>();

            foreach (Uri address in baseAddresses)
            {
                Logging.TraceVerbose("{0} > {1} {2}", ComponentName, "Found ", address.ToString()); 
                
                // This is not the best solution. Because WCF only allows one binding for each element, just 
                // select the one that is binded to *.xboxlive.com
                // this is doable because the other binding we are using is health check pages, which doesn't 
                // specify the domain name and it doesn't depends on this service host factory. 
                if (address.DnsSafeHost.Contains(DomainToFilterBy, StringComparison.OrdinalIgnoreCase))
                {
                   retAddress.Add(address);
                   Logging.TraceVerbose("{0} > {1} {2}", ComponentName, "select ", address.DnsSafeHost); 
                }
                else
                {
                    Logging.TraceVerbose("{0} > {1} {2}", ComponentName, "ignore ", address.DnsSafeHost); 
                }
            }

            // If we have no Address in the return address list, our filteration logic above has filtered out everything.
            // We cannot allow this to happen. As WCF will barf at our no-binding URI state 
            // (web.config indicates that there should be at least "1" HTTPS binding)
            // Also, we cannot return the baseAddresses as is, as we only allow, per Uri schema, one service object-binding AND
            // it so happens that we do have multiple HTTPS bindings of only one is valid (typically the first one).
            // So simply pick the top-most entry from the baseAddresses, if it exists, for binding.
            if (retAddress.Count == 0)
            {
                Logging.TraceVerbose("{0} > {1}", ComponentName, "no URI selected for binding - in case every host-less URIs are filtered for relevant schema try add the first one in.");

                if (baseAddresses != null && baseAddresses.Length > 0)
                {
                    Logging.TraceError("{0} > {1} {2}", ComponentName, "select ", baseAddresses[0].DnsSafeHost); 
                    retAddress.Add(baseAddresses[0]);
                }
            }

            return retAddress.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\ILocaleHelper.cs ===
﻿
namespace Leet.Utils
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public interface ILocaleHelper
    {
        /// <summary>
        /// Returns the LCID based on the locale
        /// </summary>
        /// <param name="locale">Locale string based on country code and language</param>
        /// <returns>The LCID of the locale</returns>
        ushort GetLCID(string locale);

        /// <summary>
        /// Returns locale based on the LCID
        /// </summary>
        /// <param name="lcid">The LCID of the locale</param>
        /// <returns>The Locale string based on country code and language</returns>
        string GetLocale(ushort lcid);

        /// <summary>
        /// Determines where the locale exists in the collection of locales
        /// </summary>
        /// <param name="locale">Locale string based on country code and language</param>
        /// <returns>Whether the locale exists</returns>
        bool Exists(string locale);

        /// <summary>
        /// Check if the input locale is supported; if not, fall back to "en-US";
        /// Note: the caller must check if the locale is empty or NULL. If so, reject the request with 400.
        /// </summary>
        /// <param name="locale">The locale string from client.</param>
        /// <returns>Returns a supported locale.</returns>
        string GetSupportedLocale(string locale);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\LIVEnErrorCode.cs ===
﻿namespace Leet.Core.Utils
{
    public struct LIVEnErrorCode
    {
        public const uint S_OK = 0;

        // API errors
        public const uint LIVEN_BADARGUMENT = 1000;
        public const uint LIVEN_INVALIDOPERATION = 1001;

        public const uint LIVEN_ZEST_UNKNOWN_REQUEST_ERROR = 1010;
        public const uint LIVEN_ZEST_ITEM_NOT_PURCHASED = 1011;
        public const uint LIVEN_ZEST_ITEM_PURCHASED_TITLEID_MISMATCHED = 1012;
        public const uint LIVEN_ZEST_SIGNIN_INVALID_XUID = 1013;


        // Database errors
        public const uint LIVEN_DATABASE_ERROR = 2000;
        public const uint LIVEN_DATABASE_TIMEOUT = 2001;

        // LiveCache errors
        public const uint LIVEN_LIVECACHE_ERROR = 3000;
        public const uint LIVEN_LIVECACHE_GETUSERACHIEVEMENT_ERROR = 3001;
        public const uint LIVEN_LIVECACHE_SYNCACHIEVEMENTS_ERROR = 3002;
        public const uint LIVEN_LIVECACHE_SYNCTITLES_ERROR = 3003;

        // Account errors
        public const uint LIVEN_UNAUTHORIZED_ERROR = 4000;

        public const uint LIVEN_UNKNOWN_ERROR = 5000;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\LocaleHelperProvider.cs ===
﻿
namespace Leet.Utils
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// LocaleHelperProvider class
    /// </summary>
    [SingletonInstance]
    public class LocaleHelperProvider : ILocaleHelper
    {
        /// <summary>
        /// Component name defined
        /// </summary>
        public const string ComponentName = "LocaleHelperProvider";

        /// <summary>
        /// The default locale.
        /// </summary>
        private const string DefaultLocale = "en-US";

        /// <summary>
        /// Locales dictionary
        /// </summary>
        private IDictionary<string, ushort> locales;

        /// <summary>
        /// Initializes a new instance of the LocaleHelperProvider class
        /// </summary>
        public LocaleHelperProvider()
        {
            Logging.TraceInformation("{0} > {1}",
                ComponentName,
                "Initializing Locales Dictionary");

            // Initialize locales dictionary
            this.locales = CustomLocales.DefaultAllowedLocales;

            Logging.TraceInformation("{0} > {1} {2}",
                ComponentName,
                "Locales: ", 
                this.locales.Count);
        }

        /// <summary>
        /// Returns the LCID based on the locale
        /// </summary>
        /// <param name="locale">Locale string based on country code and language</param>
        /// <returns>The LCID of the locale</returns>
        public ushort GetLCID(string locale)
        {
            ushort lcid;
            
            
            if (this.locales.ContainsKey(locale))
            {
                lcid = this.locales[locale];
            }
            else
            {
                throw new ArgumentException("Locale is not found", locale);
            }

            return lcid;
        }

        /// <summary>
        /// Returns locale based on the LCID
        /// </summary>
        /// <param name="lcid">The LCID of the locale</param>
        /// <returns>The Locale string based on country code and language</returns>
        public string GetLocale(ushort lcid)
        {
            Dictionary<ushort, string> lookupLocale = (from lc in this.locales
                            where lc.Value == lcid
                      select lc).ToDictionary(l => l.Value, l => l.Key);
            
            string locale = string.Empty;
            if (lookupLocale.ContainsKey(lcid))
            {
                locale = lookupLocale[lcid];
            }
            else
            {
                throw new ArgumentException("lcid is not found", Convert.ToString(lcid));
            }
            
            return locale;
        }

        /// <summary>
        /// Determines where the locale exists in the collection of locales
        /// </summary>
        /// <param name="locale">Locale string based on country code and language</param>
        /// <returns>Whether the locale exists</returns>
        public bool Exists(string locale)
        {
            return this.locales.ContainsKey(locale);
        }

        /// <summary>
        /// Check if the input locale is supported; if not, fall back to "en-US";
        /// Note: the caller must check if the locale is empty or NULL. If so, reject the request with 400.
        /// </summary>
        /// <param name="locale">The locale string from client. </param>
        /// <returns>Returns a supported locale.</returns>
        public string GetSupportedLocale(string locale)
        {
            // Check if the locale is in the supported list.
            if (this.Exists(locale) == false)
            {
                // fall back to default locale
                locale = DefaultLocale;
            }

            return locale;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\MultipleHTTPBindingsServiceHostFactory.cs ===
﻿using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.ServiceModel.Activation;
using Microsoft.ServiceModel.Web;
using Leet.Core.Wcf;

namespace Leet.Utils
{
    /// <summary>
    /// WCF default service host creation logic does not allow multiple bindings with the same scheme.
    /// This method creates a creates a service host that will host multiple services with HTTP binding scheme.
    /// Steps
    /// 1. Create a WebServiceHost2 with and empty base addresses
    /// 2. Adds service endpoints for all the bases addresses with a WebHTTPBinding
    /// 3. Add WebHttpBehavior to each endpoint.
    /// IServiceContract type is the contract interface type
    /// </summary>
    /// <remarks>
    /// This class is for use in very specifc scenario. Make sure to read the code if possible to what the method is doing
    /// </remarks>
    public class MultipleHTTPBindingsServiceHostFactory<IServiceContract> : MultipleBindingServiceHostFactory
    {
        Uri[] baseAddresses;
        Type serviceType;

        protected override void ConfigureEndpoints()
        {
            WebServiceHost2 host = Host as WebServiceHost2;
            Debug.Assert(host != null, "host");

            Uri[] requiredAddress = null;
            if (FilterAddressesNotRelevantForBinding())
            {
                // this call will filter addresses that is not relevant for binding.
                requiredAddress = FilteredMultipleIISBindingServiceHostFactory.GetAppropriateBase(this.baseAddresses);
                Debug.Assert(requiredAddress.Length > 0, "no base addresses returned by FilteredMultipleIISBindingServiceHostFactory.GetAppropriateBase");
            }
            else
            {
                requiredAddress = this.baseAddresses;
            }

            //this is the actuall hack. Add endpoints explicitly
            if (requiredAddress.Length > 0)
            {
                foreach (Uri serviceUri in requiredAddress)
                {
                    ServiceEndpoint ep = host.AddServiceEndpoint(typeof(IServiceContract), new WebHttpBinding(), serviceUri);
                    //even though WebServiceHost2 will add the WebHTTPBehaviour2 internally we still do this so as to avoid future changes in Microsoft.ServiceModel.Web
                    ep.Behaviors.Add(new WebHttpBehavior());
                }
            }
        }

        protected override ServiceHost GetServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            this.serviceType = serviceType;
            this.baseAddresses = baseAddresses;

            //manifest read will have multiple binding with scheme http and since WCF default host creation does not support this we will have to hack around this.
            WebServiceHost2 host = new WebServiceHost2(serviceType, true, baseAddresses[0]);
            return host;
        }

        protected virtual bool FilterAddressesNotRelevantForBinding()
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\PerfCounterBase.cs ===
﻿namespace Leet.Utils
{
    using System;
    using System.Diagnostics;
    using System.Collections.Generic;

    public enum PerformanceCounterSet
    {
        Leaderboard = 1,
        Achievements = 2,
        AvatarAwardAssets = 3
    }

    public interface IServicePerformanceCounters
    {
        void StartRequest(object context);

        long EndRequest(bool failed);

        IServicePerformanceCounters RetrievePerformanceCounters(PerformanceCounterSet enumSet);
    }

    internal class PerfCounterContextTracker
    {
        public long StartTicks { get; set; }
        public object Context { get; set; }
    }

    /// <summary>
    /// Note: We templatized to ensure that Type specific class definitions occur during compile time.
    ///       This will guarantee that no cross-interference will occur 
    ///       when, say, a GetProfile counter instance touches ThreadStatic objects while GetLeaderboard call is happening.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class PerfCounterBase<T> : IServicePerformanceCounters
    {
        private const int stackInitialSize = 5;
        /// <summary>
        /// By making this member threadStatic, we are alleviating the need to instantiate a ProfileCounters class per call
        /// Now we can cache it and StartRequest() and EndRequest() calls will not cause interference.
        /// </summary>
        [ThreadStatic]
        private static Stack<PerfCounterContextTracker> contextStack;

        /// <summary>
        /// BEWARE USERS - It is imperative that any referencing to the Context object be done before any call to base.EndRequest()
        /// </summary>
        public static object Context
        {
            get
            {
                if (contextStack.Count > 0)
                {
                    PerfCounterContextTracker ct = contextStack.Peek();
                    return ct.Context;
                }

                return null;
            }
        }

        [ThreadStatic]
        private static bool isStartCountersCalled = false;

        public virtual void StartRequest(object context)
        {
            PerfCounterContextTracker ctxTrack = new PerfCounterContextTracker()
            {
                StartTicks = Stopwatch.GetTimestamp(),
                Context = context
            };

            if (contextStack == null)
            {
                contextStack = new Stack<PerfCounterContextTracker>(stackInitialSize);
            }
            
            // Setting thread-static members
            PerfCounterBase<T>.contextStack.Push(ctxTrack);

            isStartCountersCalled = true;
        }

        public virtual long EndRequest(bool failed)
        {
            try
            {
                long duration = Stopwatch.GetTimestamp() - PerfCounterBase<T>.contextStack.Peek().StartTicks;


                if (!isStartCountersCalled)
                {
#if DBG
                    throw new InvalidOperationException("EndRequest is called without a matching BeginRequest - this shall never happen");
#endif
                }

                return duration;
            }
            finally
            {
                PerfCounterBase<T>.contextStack.Pop();

                if (PerfCounterBase<T>.contextStack.Count == 0)
                {
                    isStartCountersCalled = false; // total stack unwind succeeded.
                }
            }
        }

        public virtual IServicePerformanceCounters RetrievePerformanceCounters(PerformanceCounterSet enumSet)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\Platforms.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="Platforms.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="smangla">
//    Sanjay Mangla
// </author>
//
// <summary>
//  Defines Platform strings. These are not localized and won't be localized as per LCA
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
//
//-------------------------------------------------------------------

using System;
using System.Collections.Generic;
using Leet.Core.Platforms;

namespace Leet.Core.Utils
{
    public class Platforms
    {
        private static Dictionary<uint, string> PlatformTextDictionary = new Dictionary<uint, string>() {
            {(uint)PlatformType.Marketplace, "Marketplace"},
            {(uint)PlatformType.Mobile, "Mobile"},
            {(uint)PlatformType.PC, "PC"},
            {(uint)PlatformType.WebGames, "Web Games"},
            {(uint)PlatformType.Xbox1, "Xbox1"},
            {(uint)PlatformType.Xbox360, "Xbox 360"},
            {(uint)PlatformType.XboxCom, "Xbox.com"}
        };


        public static uint GetPlatformsBitMask(List<uint> list )
        {
            uint retVal = (uint)PlatformBitMask.None;
            foreach (uint pltype in list)
            {
                if (pltype == (uint)PlatformType.Mobile)
                {
                    retVal = retVal | (uint)PlatformBitMask.WindowsPhone;
                }
                if ((pltype == (uint)PlatformType.WebGames) || (pltype == (uint)PlatformType.XboxCom))
                {
                    retVal = retVal | (uint) PlatformBitMask.Web;
                }
                if (pltype == (uint)PlatformType.PC)
                {
                    retVal = retVal | (uint) PlatformBitMask.WindowsPc;
                }
                if ((pltype == (uint)PlatformType.Xbox1) || (pltype == (uint)PlatformType.Xbox360))
                {
                    retVal = retVal | (uint)PlatformBitMask.XboxConsole;
                }

            }
            return retVal;
        }

        public static string GetString(uint platformId)
        {
            if (!PlatformTextDictionary.ContainsKey(platformId))
            {
                throw new LIVEnException("The platform Id is invalid");
            }
            return PlatformTextDictionary[platformId];
        }

        public static bool IsValidPlatform(uint platformId)
        {
            return Enum.IsDefined(typeof(PlatformType), platformId);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\RetryController.cs ===
﻿//-------------------------------------------------------------------
// <copyright file="RetryController.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="a-gamavi">
// </author>
//
// <summary>
//  Generic class to handle retrying operations
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
//
//-------------------------------------------------------------------

using System;
using System.Threading;
using System.Collections;
using System.Collections.Generic;

namespace Leet.Core.Utils
{
    /// <summary>
    /// This is a in-thread Retry controller that re-tries should the operation fail,
    /// after certain amount of Thread.Sleep.
    /// </summary>
    public class RetryController
    {
        private const int DefaultRetryMax = 3;  
        private const int DefaultRetryFrequency = 10;


        /// <summary>
        /// Retry without transaction handling
        /// </summary>
        /// <param name="retryMax">A function that returns maximum retries</param>
        /// <param name="retryFrequency">Wait time before retrying that gets multiplied by count (in seconds)</param>
        /// <param name="listException">List of retriable exceptions</param>
        /// <param name="retryDelegate">Retry delegate</param>
        /// <param name="exceptionLogger"></param>
        /// <returns></returns>
        public static TResult RetryFunc<TResult>(Func<int> retryMax,
                                     int retryFrequency,
                                     List<Type> listException,
                                      Action<Exception, bool> exceptionLogger,
                                      Func<TResult> retryDelegate
  )
        {
            int retryCount = 0;
            TResult result = default(TResult);
            while (retryCount < retryMax())
            {
                try
                {
                    result = retryDelegate();
                    break;
                }
                catch (Exception ex)
                {
                    if (listException.Contains(ex.GetType()))
                    {
                        if (exceptionLogger != null)
                        {
                            string message = String.Format("Retry #{0} of {1} in RetryController.Retry()", retryCount, retryMax());
                            ApplicationException appException = new ApplicationException(message, ex);
                            exceptionLogger(appException, true); // log the retriable exception

                        }

                        retryCount++;
                        if (retryCount < retryMax())
                        {
                            Thread.Sleep(1000 * retryFrequency);
                        }
                        else
                        {
                            // tried retryMax times
                            // let the caller to handle the exception
                            ApplicationException appException = new ApplicationException("Retry count exceeded in RetryController.Retry()", ex);
                            exceptionLogger(appException, false); // log the non-retriable exception
                            throw;
                        }
                    }
                    else
                    {
                        // non retriable exception
                        // let the caller to handle the exception
                        throw;
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Retry without transaction handling
        /// </summary>
        /// <param name="retryMax">Maximum number of retries</param>
        /// <param name="retryFrequency">Wait time before retrying that gets multiplied by count (in seconds)</param>
        /// <param name="listException">List of retriable exceptions</param>
        /// <param name="retryDelegate">Retry delegate</param>
        /// <param name="exceptionLogger"></param>
        /// <returns></returns>
        public static void Retry(int retryMax,
                                     int retryFrequency,
                                     List<Type> listException,
                                      Action<Exception,bool> exceptionLogger,
                                      Action retryDelegate
  )
        {
            int retryCount = 0;
            while (retryCount < retryMax)
            {
                try
                {
                    retryDelegate();
                    break;
                }
                catch (Exception ex)
                {
                    if (listException.Contains(ex.GetType()))
                    {
                        if (exceptionLogger != null)
                        {
                            string message = String.Format("Retry #{0} of {1} in RetryController.Retry()", retryCount, retryMax);
                            ApplicationException appException = new ApplicationException(message, ex);
                            exceptionLogger(appException, true); // log the retriable exception
 
                        }

                        retryCount++;
                        if (retryCount < retryMax)
                        {
                            Thread.Sleep(1000 * retryFrequency);
                        }
                        else
                        {
                            // tried retryMax times
                            // let the caller to handle the exception
                            ApplicationException appException = new ApplicationException("Retry count exceeded in RetryController.Retry()", ex);
                            exceptionLogger(appException, false); // log the non-retriable exception
                            throw;
                        }
                    }
                    else
                    {
                        // non retriable exception
                        // let the caller to handle the exception
                        throw;
                    }
                }
            }

            return;
        }

        /// <summary>
        /// Retry without transaction handling, use default values for Retry and Frequency
        /// </summary>
        /// <param name="listException">List of retriable exceptions</param>
        /// <param name="retryDelegate">Retry delegate</param>
        /// <param name="exceptionLogger"></param>
        /// <returns></returns>
        public static void Retry(List<Type> listException,Action<Exception,bool> exceptionLogger,Action retryDelegate)
        {
            Retry(DefaultRetryMax, DefaultRetryFrequency, listException, exceptionLogger, retryDelegate);  
        }

        /// <summary>
        /// Overload for specifying a retryMax function. By passing a function for calculating retryMax
        /// the caller can control the value even when a thread is doing retries. 
        /// </summary>
        /// <param name="retryMax"></param>
        /// <param name="retryFrequency"></param>
        /// <param name="listException"></param>
        /// <param name="exceptionLogger"></param>
        /// <param name="retryDelegate"></param>
        public static void Retry(Func<int> retryMax,
                                     int retryFrequency,
                                     List<Type> listException,
                                      Action<Exception,bool> exceptionLogger,
                                      Action retryDelegate)
        {
            Retry(retryMax(), retryFrequency, listException, exceptionLogger, retryDelegate);
        }

        /// <summary>
        /// Retry with transaction handling
        /// </summary>
        /// <param name="retryMax">Maximum number of retries</param>
        /// <param name="retryFrequency">Wait time before retrying that gets multiplied by count (in seconds)</param>
        /// <param name="listException">List of retriable exceptions</param>
        /// <param name="exceptionLogger"></param>
        /// <param name="retryDelegate">Retry delegate</param>
        /// <param name="commitDelegate">Commit Delegate</param>
        /// <param name="rollbackDelegate">Rollback Delegate</param>
        /// <returns></returns>
        public static void Retry(int retryMax,
                                int retryFrequency,
                                List<Type> listException,
                                Action<Exception, bool> exceptionLogger,
                                Action retryDelegate,
                                Action commitDelegate,
                                Action rollbackDelegate)
        {
            int retryCount = 0;
            bool commitTransaction = true;
            while (retryCount < retryMax)
            {
                try
                {
                    retryDelegate();
                    break; // No exceptions, break from the loop to commit
                }
                catch (Exception ex)
                {
                    if (listException.Contains(ex.GetType()))
                    {
                        retryCount++;
                        if (retryCount < retryMax)
                        {
                            if (exceptionLogger != null)
                            {
                                string message = String.Format("Retry #{0} of {1} in RetryController.Retry()", retryCount,retryMax); 
                                ApplicationException appException = new ApplicationException(message, ex);
                                exceptionLogger(appException, true); // log the retriable exception
                            }

                            // NOTE: it is bad for performance to block a TP thread for extended period of times.
                            // consider writing a seperate RetryController, that operates cross threads and 
                            // uses Timers to perform re-tries.
                            Thread.Sleep(1000 * retryFrequency);
                        }
                        else
                        { 
                            if (exceptionLogger != null)
                            {
                                ApplicationException appException = new ApplicationException("Retry count exceeded in RetryController.Retry(). SQL Rollback called", ex);
                                exceptionLogger(appException, false); // log the non-retriable exception
                            }
                            commitTransaction = false;
                        }
                    }
                    else
                    {
                        if (exceptionLogger != null)
                        {
                            ApplicationException appException = new ApplicationException("Unexpected non retriable exception is caught in RetryController.Retry(). SQL Rollback called", ex);
                            exceptionLogger(appException, false); // log the non-retriable exception
                        }
                        commitTransaction = false;
                        break;
                    }
                }
            }

            if (commitTransaction)
            {
                commitDelegate();
            }
            else
            {
                rollbackDelegate();
            }
        }

        /// <summary>
        /// Retry with transaction handling, use default values for Retry and Frequency
        /// </summary>
        /// <param name="listException">List of retriable exceptions</param>
        /// <param name="exceptionLogger"></param>
        /// <param name="retryDelegate">Retry delegate</param>
        /// <param name="commitDelegate">Commit Delegate</param>
        /// <param name="rollbackDelegate">Rollback Delegate</param>
        /// <returns></returns>
        public static void Retry(List<Type> listException,
                                 Action<Exception, bool> exceptionLogger,
                                 Action retryDelegate,
                                 Action commitDelegate,
                                 Action rollbackDelegate)
        {
            Retry(DefaultRetryMax, DefaultRetryFrequency, listException, exceptionLogger,
                  retryDelegate, commitDelegate, rollbackDelegate);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\WebOperationIncomingRequestHeaderReader.cs ===
﻿namespace Leet.Utils
{
    using System;
    using System.ServiceModel.Web;

    public class WebOperationIncomingRequestHeaderReader : IWebOperationIncomingRequestHeaderReader
    {
        public string this[string headerName]
        {
            get
            {
                return WebOperationContext.Current.IncomingRequest.Headers[headerName];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\MultipleHTTPSecureBindingsServiceHostFactory.cs ===
﻿//---------------------------------------------------------------------------------------
// <copyright file="MultipleHTTPSecureBindingsServiceHostFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="a-thkuo">
//     Ted Kuo
// </author>
//
// <summary>
//  Add multiple WCF endpoints for HTTPS protocol
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/27/2010">
//     Class created
// </history>
//-----------------------------------------------------------------------------------------
namespace Leet.Utils
{
    using System;
    using System.Diagnostics;
    using System.Collections.Generic;
    using System.ServiceModel;
    using System.ServiceModel.Description;
    using System.ServiceModel.Activation;
    using Microsoft.ServiceModel.Web;
    using Leet.Core.Wcf;
    using System.Configuration;

    /// <summary>
    /// WCF default service host creation logic does not allow multiple bindings with the same scheme.
    /// This method creates a creates a service host that will host multiple services with HTTPS binding scheme.
    /// Steps
    /// 1. Create a WebServiceHost2 with and empty base addresses
    /// 2. Adds service endpoints for all the bases addresses with a WebHTTPBinding
    /// 3. Add WebHttpBehavior to each endpoint.
    /// IServiceContract type is the contract interface type
    /// </summary>
    /// <remarks>
    /// This class is for use in very specifc scenario. Make sure to read the code if possible to what the method is doing
    /// </remarks>
    public class MultipleHTTPSecureBindingsServiceHostFactory<IServiceContract> : MultipleBindingServiceHostFactory
    {
        Uri[] baseAddresses;
        Type serviceType;

        protected override void ConfigureEndpoints()
        {
            WebServiceHost2 host = Host as WebServiceHost2;
            Debug.Assert(host != null, "host");

            Uri[] requiredAddress = null;
            if (FilterAddressesNotRelevantForBinding())
            {
                // this call will filter addresses that is not relevant for binding.
                requiredAddress = FilteredMultipleIISBindingServiceHostFactory.GetAppropriateBase(this.baseAddresses);
                Debug.Assert(requiredAddress.Length > 0, "no base addresses returned by FilteredMultipleIISBindingServiceHostFactory.GetAppropriateBase");
            }
            else
            {
                requiredAddress = this.baseAddresses;
            }

            //this is the actuall hack. Add endpoints explicitly
            if (requiredAddress.Length > 0)
            {
                foreach (Uri serviceUri in requiredAddress)
                {
                    if (string.Compare(serviceUri.Scheme, "https", StringComparison.InvariantCultureIgnoreCase) == 0)
                    {
                        ServiceEndpoint ep = host.AddServiceEndpoint(typeof(IServiceContract), new WebHttpBinding(WebHttpSecurityMode.Transport), serviceUri);

                        // even though WebServiceHost2 will add the WebHTTPBehaviour2 internally we still do this so as to avoid future changes in Microsoft.ServiceModel.Web
                        ep.Behaviors.Add(new WebHttpBehavior());
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="serviceType"></param>
        /// <param name="baseAddresses"></param>
        /// <returns></returns>
        protected override ServiceHost GetServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            this.serviceType = serviceType;
            this.baseAddresses = baseAddresses;

            //manifest read will have multiple binding with scheme http and since WCF default host creation does not support this we will have to hack around this.
            WebServiceHost2 host = new WebServiceHost2(serviceType, true, baseAddresses[0]);

            return host;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected virtual bool FilterAddressesNotRelevantForBinding()
        {
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\XboxLiveLocaleHelper.cs ===
﻿
namespace Leet.Utils
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    public static class XboxLiveLocaleHelper
    {
        /// <summary>
        /// Gets locale based on live cache defined country id and language id.
        /// The country id is mapped in the t_countries table in Platform NPDB.
        /// The language id is mapped in the t_languages table in Platform NPDB
        /// </summary>
        /// <param name="countryId"></param>
        /// <param name="languageId"></param>
        /// <param name="locale"></param>
        /// <returns>true if the country id and language id map to a supported loacale. false otherwise</returns>
        public static bool TryGetSupportedLocale(UInt16 countryId, UInt16 languageId, out String locale)
        {
            return CountryIDLanguageIDToLocaleMapping.TryGetValue(languageId.ToString(System.Globalization.CultureInfo.CurrentUICulture) 
                + "_" +
                countryId.ToString(System.Globalization.CultureInfo.CurrentUICulture), out locale);
        }

        /// <summary>
        /// Returns true if a user locale is supported else false
        /// </summary>
        /// <param name="userLocale"></param>
        /// <returns></returns>
        public static bool IsLocaleSupported(String userLocale)
        {
            return CountryIDLanguageIDToLocaleMapping.Values.Contains<String>(userLocale);
        }

        /// XBOX Live user locales and LCID Mappings
        /// </summary>
        static readonly Dictionary<String, String> CountryIDLanguageIDToLocaleMapping = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase)
            {
                {"18_23", "cs-CZ"}, 
                {"13_25", "da-DK"}, 
                {"3_5", "de-AT"}, 
                {"3_18","de-CH"},
                {"3_24", "de-DE"},
                {"19_37","el-GR"},
                {"1_1", "en-AE"},
                {"1_6", "en-AU"},
                {"1_16", "en-CA"},
                {"1_35", "en-GB"},
                {"1_39", "en-HK"},
                {"1_44", "en-IE"},
                {"1_46", "en-IN"},
                {"1_76", "en-NZ"},
                {"1_91", "en-SG"},
                {"1_103", "en-US"},
                {"1_109", "en-ZA"},
                {"5_19",  "es-CL"},
                {"5_21",  "es-CO"},
                {"5_31",  "es-ES"},
                {"5_71",  "es-MX"},
                {"5_103", "es-US"},
                {"14_32", "fi-FI"},
                {"4_8", "fr-BE"},
                {"4_16", "fr-CA"},
                {"4_18", "fr-CH"},
                {"4_34", "fr-FR"},
                {"20_42", "hu-HU"},
                {"6_50", "it-IT"},
                {"2_53", "ja-JP"},
                {"7_56", "ko-KR"},
                {"16_8", "nl-BE"},
                {"16_74","nl-NL"},
                {"15_75", "nb-NO"},
                {"11_82", "pl-PL"},
                {"9_84", "pt-PT"},
                {"9_13", "pt-BR"}, //added new for Mango
                {"12_88", "ru-RU"},
                {"17_90", "sv-SE"},
                {"1_93", "en-SK"},
                {"8_20", "zh-CN"},
                {"8_39", "zh-HK"},
                {"8_91", "zh-SG"},
                {"8_101", "zh-TW"}, 
                /*
                 TODO: Fix this issue by using LiveCache call GetUserAuthorization and pulling the LCID. Where it could be compared against a pseudo-LCID we already have defined.
                 These have been added in an effort to support TFS bug 72231:  [WP7] Locales: WP7 is releasing in 11 new countries. Which LiveN needs to add support for.
                 These are being added as there language is not supported by the console. Thus they're language is getting shifted to en. 
                 This fix is used to convert the en-[Country] back to the real language and country
                */
                {"1_23", "cs-CZ"},
                {"1_25", "da-DK"},
                {"1_8", "nl-BE"}, 
                {"1_74", "nl-NL"},
                {"1_32", "fi-FI"},
                {"1_37", "el-GR"},
                {"1_42", "hu-HU"},
                {"1_75", "nb-NO"},
                {"1_90", "sv-SE"}
            };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Leet.Utils")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7de88513-cddf-4057-94cb-abf5127d2b4e")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\XmlSignature.cs ===
﻿using System;
using System.Xml;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography.Xml;
using System.Text;

namespace Leet.Utils
{
    /// <summary>
    /// Helper for signing xml documents
    /// </summary>
    public static class XmlSignature
    {
        /// <summary>
        /// Signs the xml string as per http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/  standard.
        /// The certificate with certificateSubjectName must be present on the LocalMachine personal store
        /// </summary>
        /// <param name="xml"></param>
        /// <param name="certificateSubjectName"></param>
        /// <param name="envelopedXml">Signed xml with the signature embedded as the child element of the root</param>
        /// <returns>SignedXml</returns>
        /// <exception cref="ArgumentNullException">If the xml is null or empty</exception>
        /// <exception cref="ArgumentNullException">If certificateSubjectName is null or empty</exception>
        /// <exception cref="ArgumentException">If certificate is not found in the store</exception>
        /// <exception cref="ArgumentException">If certificate does not have a private key</exception>
        public static SignedXml GetSignedXml(String xml, String certificateSubjectName, out XmlDocument envelopedXml)
        {
            if (String.IsNullOrEmpty(xml))
            {
                throw new ArgumentNullException("xml", "xml cannot be null or empty");
            }

            if(String.IsNullOrEmpty(certificateSubjectName))
            {
                throw new ArgumentNullException("certificateSubjectName", "certificateSubjectName cannot be null or empty");
            }
            
            X509Certificate2 certificate = GetCertificateBySubjectName(certificateSubjectName);
            
            if(certificate == null)
            {
                throw new ArgumentException("certificate not found");
            }

            return GetSignedXmlInner(xml, certificate, out envelopedXml);
        }

        /// <summary>
        /// Signs the xml string as per http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/  standard.
        /// The certificate with certificateSubjectName must be present on the LocalMachine personal store
        /// </summary>
        /// <param name="xmlDocument">XmlDocument wrapping the source xml that needs to be signed</param>
        /// <param name="certificateSubjectName"></param>
        /// <param name="envelopedXml">Signed xml with the signature embedded as the child element of the root</param>
        /// <returns>SignedXml</returns>
        /// <exception cref="ArgumentNullException">If the xml is null or empty</exception>
        /// <exception cref="ArgumentNullException">If certificateSubjectName is null or empty</exception>
        /// <exception cref="ArgumentException">If certificate is not found in the store</exception>
        /// <exception cref="ArgumentException">If certificate does not have a private key</exception>
        public static SignedXml GetSignedXml(XmlDocument xmlDocument, String certificateSubjectName, out XmlDocument envelopedXml)
        {
            if (xmlDocument == null)
            {
                throw new ArgumentNullException("xmlDocument", "xmlDocument cannot be null");
            }

            if (String.IsNullOrEmpty(certificateSubjectName))
            {
                throw new ArgumentNullException("certificateSubjectName", "certificateSubjectName cannot be null or empty");
            }

            X509Certificate2 certificate = GetCertificateBySubjectName(certificateSubjectName);

            if (certificate == null)
            {
                throw new ArgumentException("certificate not found");
            }

            return GetSignedXmlInner(xmlDocument, certificate, out envelopedXml);
        }


        /// <summary>
        /// Signs the xml string as per http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/ standard.
        /// </summary>
        /// <param name="xml">Xml String</param>
        /// <param name="certificate">X509Certificate2 certificate</param>
        /// <param name="envelopedXml">Signed xml with the signature embedded as the child element of the root</param>
        /// <returns>SignedXml</returns>
        /// <exception cref="ArgumentNullException">If the xml is null or empty</exception>
        /// <exception cref="ArgumentNullException">If certificate is null</exception>
        /// <exception cref="ArgumentException">If certificate does not have a private key</exception>
        public static SignedXml GetSignedXml(String xml, X509Certificate2 certificate, out XmlDocument envelopedXml)
        {
            if (String.IsNullOrEmpty(xml))
            {
                throw new ArgumentNullException("xml", "xml cannot be null or empty");
            }

            if (certificate == null)
            {
                throw new ArgumentNullException("certificate", "certificate cannot be null or empty");
            }

            return GetSignedXmlInner(xml, certificate, out envelopedXml);
        }

        private static SignedXml GetSignedXmlInner(String xml, X509Certificate2 certificate, out XmlDocument envelopedXml)
        {
            //we need a private key to sign the cert
            if (!certificate.HasPrivateKey)
            {
                throw new ArgumentException("Certificate does not have a private key that can be used to sign the xml", "certificateSubjectName");
            }

        
            //load the xml
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.PreserveWhitespace = true;
            xmlDocument.LoadXml(xml);

            return GetSignedXmlInner(xmlDocument, certificate, out envelopedXml);
        }

        private static SignedXml GetSignedXmlInner(XmlDocument xmlDocument, X509Certificate2 certificate, out XmlDocument envelopedXml)
        {
            //load the document in a SignedXml object
            SignedXml signedXml = new SignedXml(xmlDocument);
            signedXml.SigningKey = certificate.PrivateKey; //get the private key

            //create a reference object. We will use "" uri indicate that we need to sign the entire xml
            Reference reference = new Reference("");

            //Add an XmlDsigEnvelopedSignatureTransform object to the Reference object. 
            //A transformation allows the verifier to represent the XML data in the identical manner that the signer used. 
            //XML data can be represented in different ways, so this step is vital to verification.
            XmlDsigEnvelopedSignatureTransform transform = new XmlDsigEnvelopedSignatureTransform();
            reference.AddTransform(transform);


            //add the reference to the signed xml
            signedXml.AddReference(reference);


            //add a clause for issuer and serial number to keyInfo
            KeyInfoX509Data clause = new KeyInfoX509Data();
            clause.AddIssuerSerial(certificate.Issuer, certificate.SerialNumber);
            KeyInfo keyInfo = new KeyInfo();
            keyInfo.AddClause(clause);
            signedXml.KeyInfo = keyInfo;


            //compute the signature and enclose the signature in the root element of the original document
            signedXml.ComputeSignature();

            xmlDocument.DocumentElement.AppendChild(xmlDocument.ImportNode(signedXml.GetXml(), true));

            envelopedXml = xmlDocument;

            return signedXml;
        }

        private static X509Certificate2 GetCertificateBySubjectName(String certSubjectName)
        {
            X509Certificate2Collection matches;
            X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);

            try
            {
                // Find the certificate that matches the subject
                matches = store.Certificates.Find(X509FindType.FindBySubjectName, certSubjectName, false);
            }
            finally
            {
                store.Close();
            }


            if (matches == null || matches.Count == 0)
            {
                return null;
            }

            return matches[0];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\Leet.Utils.Test\PlatformsTest.cs ===
﻿using System;
using System.Diagnostics;
using Leet.Core.Utils;
using Microsoft.VisualStudio.TestTools.UnitTesting;
namespace Leet.Utils.Test
{
    
    
    /// <summary>
    ///This is a test class for PlatformsTest and is intended
    ///to contain all PlatformsTest Unit Tests
    ///</summary>
    [TestClass()]
    public class PlatformsTest
    {


        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext)
        //{
        //}
        //
        //Use ClassCleanup to run code after all tests in a class have run
        //[ClassCleanup()]
        //public static void MyClassCleanup()
        //{
        //}
        //
        //Use TestInitialize to run code before running each test
        //[TestInitialize()]
        //public void MyTestInitialize()
        //{
        //}
        //
        //Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        //public void MyTestCleanup()
        //{
        //}
        //
        #endregion


        /// <summary>
        ///A test for GetString
        ///</summary>
        [TestMethod()]
        public void GetStringTest()
        {
            uint platformId = 1; // 
            string expected = "Windows Phone";
            string actual;
            actual = Platforms.GetString(platformId);
            Assert.AreEqual(expected, actual);
         }

        /// <summary>
        ///A test for GetString
        ///</summary>
        [TestMethod()]
        public void GetStringTestFail()
        {
            const uint platformId = 100;
            string expected = String.Empty;
            string actual = String.Empty;
            try
            {
                actual = Platforms.GetString(platformId);

            }
            catch (Exception e)
            {
                Assert.IsTrue(e.GetType()== typeof(LIVEnException));
            }
            Assert.IsTrue(actual == String.Empty);
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx", Scope = "namespace", Target = "Wgx.Common.Utilities")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Wgx.Common.Utilities")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Leet.Utils\Leet.Utils.Test\XmlSignatureTest.cs ===
﻿using System;
using System.Xml;
using Leet.Utils;
using System.Security.Cryptography.Xml;
using System.Security.Cryptography.X509Certificates;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Leet.Utils.Test
{
    /// <summary>
    /// Summary description for XmlSignatureTest
    /// </summary>
    [TestClass]
    public class XmlSignatureTest
    {
        public XmlSignatureTest()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void NullXmlTest()
        {
            String xml = String.Empty;
            XmlSignature.GetSignedXml(xml, "sts.test.xboxlive.com", out xml);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void NullXmlTest2()
        {
            String xml = String.Empty;
            XmlSignature.GetSignedXml(xml, new X509Certificate2(), out xml);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void NullCertTest()
        {
            String xml = String.Empty;
            XmlSignature.GetSignedXml(xml, String.Empty, out xml);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void NullCertTest2()
        {
            String xml = String.Empty;
            X509Certificate2 cert = null;
            XmlSignature.GetSignedXml(xml, cert, out xml);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void CertNotFoundTest()
        {
            String xml = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><book>hello</book>";
            String signed = String.Empty;
            XmlSignature.GetSignedXml(xml, "blah", out signed);
        }

        [TestMethod]
        public void SignedXmlTest()
        {
            String xml = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><book>hello</book>";
            String signed = String.Empty;
            
            Assert.IsNotNull(XmlSignature.GetSignedXml(xml, "sts.test.xboxlive.com", out signed).GetXml());
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.PreserveWhitespace = true;
            xmlDoc.LoadXml(signed);

            SignedXml signedXmlObject = new SignedXml(xmlDoc);
            signedXmlObject.LoadXml((XmlElement)xmlDoc.GetElementsByTagName("Signature")[0]);

            Assert.IsTrue(signedXmlObject.CheckSignature(GetCertificateBySubjectName("sts.test.xboxlive.com"), true));

        }

        [TestMethod]
        public void SignedXmlTest2()
        {
            String xml = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><book>hello</book>";
            String signed = String.Empty;
            Assert.IsNotNull(XmlSignature.GetSignedXml(xml, "sts.test.xboxlive.com", out signed).GetXml());
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.PreserveWhitespace = true;
            xmlDoc.LoadXml(signed);

            SignedXml signedXmlObject = new SignedXml(xmlDoc);
            signedXmlObject.LoadXml((XmlElement)xmlDoc.GetElementsByTagName("Signature")[0]);

            Assert.IsTrue(signedXmlObject.CheckSignature(GetCertificateBySubjectName("sts.test.xboxlive.com"), true));

            //WMSvc-SUJEETV01
        }


        [TestMethod]
        public void VerifySignatureDifferentCert()
        {
            String xml = "<?xml version=\"1.0\" encoding=\"utf-8\" ?><book>hello</book>";
            String signed = String.Empty;
            Assert.IsNotNull(XmlSignature.GetSignedXml(xml, "sts.test.xboxlive.com", out signed).GetXml());
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.PreserveWhitespace = true;
            xmlDoc.LoadXml(signed);

            SignedXml signedXmlObject = new SignedXml(xmlDoc);
            signedXmlObject.LoadXml((XmlElement)xmlDoc.GetElementsByTagName("Signature")[0]);

            Assert.IsFalse(signedXmlObject.CheckSignature(GetCertificateBySubjectName("WMSvc-Local"), true));
        }

        private X509Certificate2 GetCertificateBySubjectName(String certSubjectName)
        {
            X509Certificate2Collection matches;
            X509Store store = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);

            try
            {
                // Find the certificate that matches the subject
                matches = store.Certificates.Find(X509FindType.FindBySubjectName, certSubjectName, false);
            }
            finally
            {
                store.Close();
            }


            if (matches == null)
            {
                return null;
            }

            return matches[0];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\Log.cs ===
﻿// <copyright file="Log.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for ServiceBroker.</summary>
namespace Wgx.Common
{
    using System;

    /// <summary>
    /// Log class for logging.
    /// TODO: ensure this is only ON for DEBUG
    /// </summary>
    internal static class Log
    {
        /// <summary>
        /// Given an exception Logs the state of the exception.
        /// </summary>
        /// <param name="ex">An exception derived from System.Exception</param>
        internal static void ReportException(Exception ex)
        {
            Console.WriteLine(ex.ToString());
        }

        /// <summary>
        /// Prints the given string to the log.
        /// </summary>
        /// <param name="str">The string to be logged</param>
        internal static void Print(string str)
        {
            Console.WriteLine(str);
        }

        /// <summary>
        /// Adds a tab (4 spaces) to the end of a prefix.
        /// </summary>
        /// <param name="prefix">The string to be appended</param>
        /// <returns>The resulting tabbed string.</returns>
        internal static string AddTabToEnd(string prefix)
        {
            string newPrefix = String.Empty;
            if (!string.IsNullOrEmpty(prefix))
            {
                newPrefix = prefix;
            }

            newPrefix += "    ";
            return newPrefix;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ConfigSystem\ConfigProviders\CentralizedConfigProvider.cs ===
﻿using System;
using xonline.common.config;
using System.Text;

// Centralized Configuration Provider Implementation
//
// Implements a configuration provider using an NPDB backend.
// It is not recommended to cache values that this configuration
// provider returns (see NPDB doc for more information).

namespace Wgx.Common.ConfigSystem
{
    public class CentralizedConfigProvider : IConfigurationProvider
    {
        // Event handlers for change events
        public event EventHandler<SettingChangeEventArgs> OnSettingChange;
        public event EventHandler<MultiSettingChangeEventArgs> OnMultiSettingChange;

        public CentralizedConfigProvider()
        {
            // Hook up events from NPDB
            Config.SettingChange += new SettingChangeEventHandler(OnNPDBSettingChange);
            Config.MultiSettingChange += new MultiSettingChangeEventHandler(OnNPDBMultiSettingChange);
        }

        // Hooking up event handler to pass on NPDB changes
        void OnNPDBSettingChange(object sender, xonline.common.config.SettingChangeEventArgs args)
        {
            OnSettingChanged(new SettingChangeEventArgs(args.Environment, args.SiteId, args.Server, args.Component, args.Setting, args.ValueOld, args.ValueNew));
        }

        void OnNPDBMultiSettingChange(object sender, xonline.common.config.MultiSettingChangeEventArgs args)
        {
            OnMultiSettingChanged(new MultiSettingChangeEventArgs(args.Environment,args.SiteId, args.Server, args.Component, args.MultiSetting, args.ValueOld, args.ValueNew));
        }


        // Event handlers
        public void OnSettingChanged(SettingChangeEventArgs e)
        {
            if (OnSettingChange != null)
            {
                OnSettingChange(this, e);
            }
        }

        public void OnMultiSettingChanged(MultiSettingChangeEventArgs e)
        {
            if (OnMultiSettingChange != null)
            {
                OnMultiSettingChange(this, e);
            }
        }


        // Retrieve properties directly from NPDB
        public string ComponentName
        {
            get { return Config.ComponentName; }
            set { Config.ComponentName = value; }
        }

        public string Environment
        {
            get { return Config.Environment; }
        }

        public string Server
        {
            get { return Config.Server; }
        }

        public int SiteId
        {
            get { return Config.SiteId; }
        }


        // NPDB needs both Server and Database name, so ConfigSource merges these
        // in a '<server name>;<database name>' string.
        public string ConfigSource
        {
            get { return Config.NpdbServer + ";" + Config.NpdbDatabase; }

            set
            {
                string[] valueArgs = value.Split(new Char [] {';'}, 2, StringSplitOptions.RemoveEmptyEntries);

                if (valueArgs.Length == 2)
                {
                    Config.NpdbServer = valueArgs[0];
                    Config.NpdbDatabase = valueArgs[1];
                }
                else
                {
                    throw new ArgumentException("Argument '" + value + "' invalid for '<server name>;<database name>' format.");
                }
            }
        }


        // Method wrappers for NPDB
        public void CheckForUpdates()
        {
            Config.CheckForUpdates();
        }

        public void RegisterDynamicSetting(string setting)
        {
            Config.RegisterDynamicSetting(setting);
        }

        public void UnRegisterDynamicSetting(string setting)
        {
            Config.UnRegisterDynamicSetting(setting);
        }

        public void VetoSettingChange()
        {
            Config.VetoSettingChange();
        }

        public void VetoMultiSettingChange()
        {
            Config.VetoMultiSettingChange();
        }

        public string GetSetting(string setting)
        {
            return Config.GetSetting(setting);
        }

        public byte[] GetBlobSetting(string setting)
        {
            return Config.GetBlobSetting(setting);
        }

        public bool GetBoolSetting(string setting)
        {
            return Config.GetBoolSetting(setting);
        }

        public double GetDoubleSetting(string setting)
        {
            return Config.GetDoubleSetting(setting);
        }

        public int GetIntSetting(string setting)
        {
            return Config.GetIntSetting(setting);
        }

        public uint GetUIntSetting(string setting)
        {
            return Config.GetUIntSetting(setting);
        }

        public long GetLongSetting(string setting)
        {
            return Config.GetLongSetting(setting);
        }

        public ulong GetULongSetting(string setting)
        {
            return Config.GetULongSetting(setting);
        }

        public string[] GetMultiSetting(string setting)
        {
            return Config.GetMultiSetting(setting);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Wgx.Common.Utilities")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("98230095-419e-4488-abc3-2c5e5c696107")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ConfigSystem\IConfigurationProvider.cs ===
﻿using System;

// Configuration Provider Interface
//
// The general interface for all configuration providers.

namespace Wgx.Common.ConfigSystem
{
    public class SettingChangeEventArgs : EventArgs
    {
        private readonly string environment;
        private readonly int siteid;
        private readonly string server;
        private readonly string component;
        private readonly string setting;
        private readonly string valueold;
        private readonly string valuenew;

        public SettingChangeEventArgs(
            string environment,
            int siteId,
            string server,
            string component,
            string setting,
            string valueOld,
            string valueNew)
        {
            this.environment = environment;
            this.siteid = siteId;
            this.server = server;
            this.component = component;
            this.setting = setting;
            this.valueold = valueOld;
            this.valuenew = valueNew;
        }

        public string Environment
        {
            get { return this.environment; }
        }

        public int SiteId
        {
            get { return this.siteid; }
        }

        public string Server
        {
            get { return this.server; }
        }

        public string Component
        {
            get { return this.component; }
        }

        public string Setting
        {
            get { return this.setting; }
        }

        public string ValueOld
        {
            get { return this.valueold; }
        }

        public string ValueNew
        {
            get { return this.valuenew; }
        }
    }


    public class MultiSettingChangeEventArgs : EventArgs
    {
        private readonly string environment;
        private readonly string server;
        private readonly int siteid;
        private readonly string component;
        private readonly string multisetting;
        private readonly string[] valueold;
        private readonly string[] valuenew;

        public MultiSettingChangeEventArgs(
            string environment,
            int siteId,
            string server,
            string component,
            string multiSetting,
            string[] valueOld,
            string[] valueNew)
        {
            this.environment = environment;
            this.siteid = siteId;
            this.server = server;
            this.component = component;
            this.multisetting = multiSetting;
            this.valueold = valueOld;
            this.valuenew = valueNew;
        }

        public string Environment
        {
            get { return this.environment; }
        }

        public int SiteId
        {
            get { return this.siteid; }
        }

        public string Server
        {
            get { return this.server; }
        }

        public string Component
        {
            get { return this.component; }
        }

        public string MultiSetting
        {
            get { return this.multisetting; }
        }

        public string[] ValueOld
        {
            get { return this.valueold; }
        }

        public string[] ValueNew
        {
            get { return this.valuenew; }
        }
    }


    public interface IConfigurationProvider
    {
        // Interface properties
        string ComponentName { set; get; }
        string Environment { get; }
        string Server { get; }
        int SiteId { get; }

        // Properies for configuration system
        string ConfigSource { set; get; }

        // Utility methods
        void CheckForUpdates();
        void RegisterDynamicSetting(string setting);
        void UnRegisterDynamicSetting(string setting);
        void VetoSettingChange();
        void VetoMultiSettingChange();

        // Setting methods
        string GetSetting(string setting);
        byte[] GetBlobSetting(string setting);
        bool GetBoolSetting(string setting);
        double GetDoubleSetting(string setting);
        int GetIntSetting(string setting);
        uint GetUIntSetting(string setting);
        long GetLongSetting(string setting);
        ulong GetULongSetting(string setting);

        // MultiSetting methods
        string[] GetMultiSetting(string setting);

        // Events for setting changes
        event EventHandler<SettingChangeEventArgs> OnSettingChange;
        event EventHandler<MultiSettingChangeEventArgs> OnMultiSettingChange;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\BrokerConversation.cs ===
﻿// <copyright file="BrokerConversation.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for BrokerConversation.</summary>
namespace Wgx.Common.ServiceBroker
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Data.SqlTypes;
    using System.Globalization;
    using System.Text;
    using Wgx.Common;

    /// <summary>
    /// A SQl Service Broker Conversation class.
    /// TODO: Add to the public method the check to throw ObjectDisposed
    /// </summary>
    public class BrokerConversation : IDisposable
    {
        /// <summary>
        /// When this string changes ensure that BrokerConversationEndpointsPositions is up to date.
        /// The field 'priority' is only in sql 2008
        /// </summary>
        internal const string SqlConversationEndpointsFields = "conversation_handle, conversation_id, is_initiator, service_contract_id, conversation_group_id, " +
                                                                "lifetime, state, state_desc, far_service, principal_id, far_principal_id, is_system ";

        /// <summary>
        /// A flag indicating whether this object is disposed or not.
        /// </summary>
        private bool disposed;

        /// <summary>
        /// A private flag indicating whether this conversation is closed or not.
        /// </summary>
        private bool isClosed;

        /// <summary>
        /// Initializes a new instance of the BrokerConversation class.
        /// conversation_handle, conversation_id, is_initiator, service_contract_id, conversation_group_id, 
        /// lifetime, state, state_desc, far_service, principal_id, far_principal_id, is_system, priority "
        /// </summary>
        /// <param name="service">BrokerService object that this conversation belongs to</param>
        /// <param name="sqlDataReader">SqlDataReader object which containst the query results from the appropriate sys.Xxx tables</param>
        internal BrokerConversation(BrokerService service, SqlDataReader sqlDataReader)
        {
            this.InitiatorService = service;

            this.InitializeFromReader(sqlDataReader);
        }

        /// <summary>
        /// Initializes a new instance of the BrokerConversation class.
        /// </summary>
        /// <param name="service">BrokerService object that this conversation belongs to</param>
        /// <param name="handle">Conversation Handle Guid that identifies this conversation within the Db</param>
        internal BrokerConversation(BrokerService service, Guid handle)
        {
            this.InitiatorService = service;
            this.Handle = handle;
            this.InitializeFromDb();
        }

        /// <summary>
        /// conversation_handle, conversation_id, is_initiator, service_contract_id, conversation_group_id, 
        /// lifetime, state, state_desc, far_service, principal_id, far_principal_id, is_system, priority "
        /// <seealso cref="http://msdn.microsoft.com/en-us/library/ms176082.aspx"/>
        /// </summary>
        internal enum BrokerConversationEndpointsPositions
        {
            /// <summary>
            /// Position of the Conversation_Handle in the query result 
            /// </summary>
            ConversationHandle = 0,

            /// <summary>
            /// Position of the Conversation_Id, a common identifier shared by both participants of the conversation.
            /// </summary>
            ConversationId,

            /// <summary>
            /// Position of the is_initiator [tinyint] in the query result.
            /// </summary>
            IsInitiator,

            /// <summary>
            /// Position of the service_contract_id in the query result.
            /// </summary>
            ServiceContractId,

            /// <summary>
            /// Position of the conversation_group_id in the query result.
            /// </summary>
            ConversationGroupId,

            /// <summary>
            /// Position of the lifetime in the query result.
            /// </summary>
            Lifetime,

            /// <summary>
            /// Position of the state [char (2)] in the query result.
            /// </summary>
            State,

            /// <summary>
            /// Position of the state_desc [nvarchar(60)] in the query result.
            /// </summary>
            StateDesc,

            /// <summary>
            /// Position of the far_service [nvarchar(256)]in the query result
            /// </summary>
            FarService,

            /// <summary>
            /// Position of the principal_id [int]in the query result
            /// </summary>
            PrincipalId,

            /// <summary>
            /// Position of the far_principal_id [int]in the query result
            /// </summary>
            FarPrincipalId,

            /// <summary>
            /// Position of the is_system [bit]in the query result
            /// </summary>
            IsSystem,

            /// <summary>
            /// Non-position, end of positions.
            /// </summary>
            End = 10000,

            /// <summary>
            /// Priority field has been moved here just for information about its SKU dependency
            /// </summary>
            Priority                // this field only exists in the SQL 2008,
        }

        /// <summary>
        /// Gets the Conversation Handle Guid.
        /// </summary>
        public Guid Handle { get; internal set; }

        /// <summary>
        /// Gets the Conversation Group Id Guid
        /// </summary>
        public Guid GroupHandle { get; internal set; }

        /// <summary>
        /// Gets the BrokerContract object used on this conversation.
        /// </summary>
        public BrokerContract Contract { get; internal set; }

        /// <summary>
        /// Gets the Initiator BrokerService object
        /// </summary>
        public BrokerService InitiatorService { get; internal set; }

        /// <summary>
        /// Gets the Target BrokerService object.
        /// </summary>
        public BrokerService TargetService { get; internal set; }

        /// <summary>
        /// Gets the security principal sql id used in the conversation.
        /// </summary>
        public int PrincipalId { get; internal set; }

        /// <summary>
        /// Gets the Far-Ends security principal sql id used in this conversation.
        /// </summary>
        public int FarPrincipalId { get; internal set; }

        /// <summary>
        /// Gets a value indicating whether this conversation is the initator or not.
        /// </summary>
        public bool IsInitiator { get; private set; }

        /// <summary>
        /// Gets the lifetime associated w/ the conversation.
        /// </summary>
        public DateTime Lifetime { get; private set; }

        /// <summary>
        /// Gets the State string.
        /// TODO: change to an enum
        /// </summary>
        public string State { get; private set; }

        /// <summary>
        /// Gets the StateDescription string, which is a verbode version of State.
        /// </summary>
        public string StateDescription { get; private set; }

        /// <summary>
        /// Sends the provided data buffer w/ the appropriate message envelope on the provided connection in the transaction.
        /// TODO: change messageType to the BrokerMessageType object.
        /// </summary>
        /// <param name="buffer">Data buffer containing message body</param>
        /// <param name="messageType">MessageType string that indicates the type to use.</param>
        /// <param name="sqlConnection">An opened sql connection object to the proper Database</param>
        /// <param name="sqlTransaction">A transaction that has begun to perform a commit/rollback after this call.</param>
        public void Send(byte[] buffer, string messageType, SqlConnection sqlConnection, SqlTransaction sqlTransaction)
        {
            if (sqlConnection == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "sqlConnection");
            }

            if (sqlTransaction == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "sqlTransaction");
            }

            if (messageType.Length > 255)
            {
                throw new ArgumentException("This argument has a length larger than 255", "messageType");
            }

            SqlCommand sqlCommand = sqlConnection.CreateCommand();
            sqlCommand.Transaction = sqlTransaction;
            SqlParameter sqlParameter;

            sqlParameter = sqlCommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier);
            sqlParameter.Value = this.Handle;

            sqlParameter = sqlCommand.Parameters.Add("@MessageType", SqlDbType.NVarChar, 255);
            sqlParameter.Value = messageType;

            if (buffer == null)
            {
                sqlParameter = sqlCommand.Parameters.Add("@Msg", SqlDbType.VarBinary);
                sqlParameter.Value = DBNull.Value;
            }
            else
            {
                sqlParameter = sqlCommand.Parameters.Add("@Msg", SqlDbType.VarBinary, buffer.Length);
                sqlParameter.Value = new SqlBytes(buffer);
            }

            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.CommandText = "p_SendWithMessage";
            sqlCommand.ExecuteNonQuery();
        }

        public void Send(byte[] buffer, string messageType, SqlConnection sqlConnection)
        {
            SqlTransaction sqlTransaction = null;
            try
            {
                sqlTransaction = sqlConnection.BeginTransaction();
                this.Send(buffer, messageType, sqlConnection, sqlTransaction);
                sqlTransaction.Commit();
            }
            catch (Exception)
            {
                sqlTransaction.Rollback();
                throw;
            }
        }

        /// <summary>
        /// Receives messages on ANY unlocked conversation that has available messages.
        /// </summary>
        /// <param name="timeout">How long to wait before timing out.</param>
        /// <param name="fetchSize">How many messages to fetch.</param>
        /// <param name="sqlConnection">An opened sql connection object to the proper Database</param>
        /// <param name="sqlTransaction">A transaction that has begun to perform a commit/rollback after this call.</param>
        /// <returns>A collection of BrokerMessages fetched as a result of the call</returns>
        public ICollection<BrokerMessage> ReceiveMessage(TimeSpan timeout, int fetchSize, SqlConnection sqlConnection, SqlTransaction sqlTransaction)
        {
            using (SqlCommand sqlCommand = this.InitiatorService.BuildReceiveMessageString(this, timeout, fetchSize, sqlConnection, sqlTransaction))
            {
                using (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())
                {
                    List<BrokerMessage> listMessage = new List<BrokerMessage>();

                    BrokerMessage brokerMsg = null;
                    while (sqlDataReader.Read())
                    {
                        brokerMsg = new BrokerMessage(sqlDataReader, this);
                        listMessage.Add(brokerMsg);
                    }

                    return listMessage;
                }
            }
        }

        public ICollection<BrokerMessage> ReceiveMessage(TimeSpan timeout, int fetchSize, SqlConnection sqlConnection)
        {
            SqlTransaction sqlTransaction = null;
            ICollection<BrokerMessage> brokerMessages = null;
            try
            {
                sqlTransaction = sqlConnection.BeginTransaction();
                brokerMessages = this.ReceiveMessage(timeout, fetchSize, sqlConnection, sqlTransaction);
                sqlTransaction.Commit();
            }
            catch (Exception)
            {
                sqlTransaction.Rollback();
                throw;
            }

            return brokerMessages;
        }

        /// <summary>
        /// Ends the conversation and closes the conversation handle.
        /// </summary>
        public void EndConversation()
        {
            this.Close(false);
        }

        /// <summary>
        /// The standart Dispose pattern.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        public void Close(bool cleanup)
        {
            if (!this.disposed)
            {
                this.CleanUpInternal(cleanup);
                this.disposed = true;
            }
        }

        /// <summary>
        /// Dump the information for printing purposes.
        /// </summary>
        /// <returns>A string containing the state report</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder(512);
            sb.AppendFormat(CultureInfo.InvariantCulture, "Conversation Configuration.\n");
            sb.AppendFormat(CultureInfo.InvariantCulture, "Handle:           {0}\n", this.Handle);
            sb.AppendFormat(CultureInfo.InvariantCulture, "Group Handle:     {0}\n", this.GroupHandle);
            sb.AppendFormat(CultureInfo.InvariantCulture, "Contract:         {0}\n", this.Contract);
            sb.AppendFormat(CultureInfo.InvariantCulture, "InitiatorService: {0}\n", this.InitiatorService.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "TargetService:    {0}\n", this.TargetService.Name);

            return sb.ToString();
        }

        /// <summary>
        /// A bridge function to the end call.
        /// </summary>
        internal void CleanUpInternal(bool cleanup)
        {
            // TODO: USE InterlockedCompareExchange
            if (this.isClosed)
            {
                return;
            }

            this.isClosed = true;

            using (SqlConnection sqlConnection = this.InitiatorService.Queue.Database.GetOpenedConnection())
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = "p_EndConversation";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                SqlParameter sqlParameter = sqlCommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier);
                sqlParameter.Value = this.Handle;

                // do we want to perform a full cleanup.
                sqlParameter = sqlCommand.Parameters.Add("@Cleanup", SqlDbType.Bit);
                sqlParameter.Value = cleanup;

                int ret = sqlCommand.ExecuteNonQuery();
                Log.Print(string.Format(CultureInfo.InvariantCulture, "p_EndConversation ExecuteNonQuery returned: {0}", ret));
                return;
            }
        }

        /// <summary>
        /// Initializes this conversation object from the Database.
        /// </summary>
        private void InitializeFromDb()
        {
            using (SqlConnection sqlConnection = this.InitiatorService.Queue.Database.GetOpenedConnection())
            {
                using (SqlCommand sqlCommand = sqlConnection.CreateCommand())
                {
                    sqlCommand.CommandText = "p_GetConversationEndpointsForHandle";
                    sqlCommand.CommandType = CommandType.StoredProcedure;
                    SqlParameter sqlParameter = sqlCommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier);
                    sqlParameter.Value = this.Handle;

                    using (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())
                    {
                        while (sqlDataReader.Read())
                        {
                            this.InitializeFromReader(sqlDataReader);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Initializes this conversation object from the SqlDataReaderObject
        /// </summary>
        /// <param name="sqlDataReader">SqlDataReader object which has the proper data queried from the relevant sys.Xxx table</param>
        private void InitializeFromReader(SqlDataReader sqlDataReader)
        {
            this.Handle = sqlDataReader.GetGuid((int)BrokerConversationEndpointsPositions.ConversationHandle);
            this.GroupHandle = sqlDataReader.GetGuid((int)BrokerConversationEndpointsPositions.ConversationGroupId);

            // TODO: fetch the contract from service based on Id.
            int contractId = sqlDataReader.GetInt32((int)BrokerConversationEndpointsPositions.ServiceContractId);

            this.PrincipalId = sqlDataReader.GetInt32((int)BrokerConversationEndpointsPositions.PrincipalId);
            this.FarPrincipalId = sqlDataReader.GetInt32((int)BrokerConversationEndpointsPositions.FarPrincipalId);
            this.IsInitiator = sqlDataReader.GetBoolean((int)BrokerConversationEndpointsPositions.IsInitiator);
            this.Lifetime = sqlDataReader.GetDateTime((int)BrokerConversationEndpointsPositions.Lifetime);
            this.State = sqlDataReader.GetString((int)BrokerConversationEndpointsPositions.State);
            this.StateDescription = sqlDataReader.GetString((int)BrokerConversationEndpointsPositions.StateDesc);

            if (!sqlDataReader.IsDBNull((int)BrokerConversationEndpointsPositions.FarService))
            {
                string farServiceName = sqlDataReader.GetString((int)BrokerConversationEndpointsPositions.FarService);
                this.TargetService = new BrokerService(farServiceName);
                this.Contract = this.InitiatorService.GetContract(contractId);
            }
        }

        /// <summary>
        /// Standart Dispose pattern call w/ the disposing flag.
        /// </summary>
        /// <param name="disposing">the flag indicating whether this call is made by the regular Dispose function or by a finalizer</param>
        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (!this.disposed)
                {
                    this.CleanUpInternal(false);
                }

                this.disposed = true;
            }
            else
            {
                throw new NotSupportedException("we have not implemented a finalizer for this object");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ConfigSystem\ConfigProviders\LocalConfigProvider.cs ===
﻿using System;
using System.Configuration;

// Centralized Configuration Provider Implementation
//
// Implements a configuration provider using the local
// application config file. Values are read from this file
// and assumed to exist. See below for data type storage in
// the config file.

namespace Wgx.Common.ConfigSystem
{
    public class LocalConfigProvider : IConfigurationProvider
    {
        // Event handlers for change events
        public event EventHandler<SettingChangeEventArgs> OnSettingChange;
        public event EventHandler<MultiSettingChangeEventArgs> OnMultiSettingChange;

        private string componentName;


        public LocalConfigProvider()
        {
             componentName = System.Reflection.Assembly.GetExecutingAssembly().GetName().Name;
        }


        // Event handlers
        protected virtual void OnSettingChanged(SettingChangeEventArgs e)
        {
            if (OnSettingChange != null)
            {
                OnSettingChange(this, e);
            }
        }

        protected virtual void OnMultiSettingChanged(MultiSettingChangeEventArgs e)
        {
            if (OnMultiSettingChange != null)
            {
                OnMultiSettingChange(this, e);
            }
        }


        // Properties directly from NPDB
        public string ComponentName
        {
            get { return componentName; }
            set { componentName = value; }
        }

        public string Environment
        {
            get { return ConfigurationManager.AppSettings["Environment"]; }
        }

        public string Server
        {
            get { return ConfigurationManager.AppSettings["Server"]; }
        }

        public int SiteId
        {
            get { return int.Parse(ConfigurationManager.AppSettings["SiteId"]); }
        }


        // Configuration source does not exist since we read from app.config or web.config
        public string ConfigSource
        {
            get { return ""; }

            set { }
        }


        // Method wrappers for NPDB
        // Dynamic updates not exist in this provider
        public void CheckForUpdates()
        {
        }

        // Dynamic updates not exist in this provider
        public void RegisterDynamicSetting(string setting)
        {
        }

        // Dynamic updates not exist in this provider
        public void UnRegisterDynamicSetting(string setting)
        {
        }

        // Dynamic updates not exist in this provider
        public void VetoSettingChange()
        {
        }

        // Dynamic updates not exist in this provider
        public void VetoMultiSettingChange()
        {
        }

        public string GetSetting(string setting)
        {
            return ConfigurationManager.AppSettings[setting];
        }

        // Assumes binary data is stored in UTF8 format in the *.config file
        public byte[] GetBlobSetting(string setting)
        {
            return System.Text.Encoding.UTF8.GetBytes(ConfigurationManager.AppSettings[setting]);
        }

        public bool GetBoolSetting(string setting)
        {
            return (ConfigurationManager.AppSettings[setting].ToLower() == "true");
        }

        public double GetDoubleSetting(string setting)
        {
            return double.Parse(ConfigurationManager.AppSettings[setting]);
        }

        public int GetIntSetting(string setting)
        {
            return int.Parse(ConfigurationManager.AppSettings[setting]);
        }

        public uint GetUIntSetting(string setting)
        {
            return uint.Parse(ConfigurationManager.AppSettings[setting]);
        }

        public long GetLongSetting(string setting)
        {
            return long.Parse(ConfigurationManager.AppSettings[setting]);
        }

        public ulong GetULongSetting(string setting)
        {
            return ulong.Parse(ConfigurationManager.AppSettings[setting]);
        }

        // Assumes multisetting data is in one string and divided by '|' delimiter
        public string[] GetMultiSetting(string setting)
        {
            return ConfigurationManager.AppSettings[setting].Split(new char[] {'|'});
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\BrokerContract.cs ===
﻿// <copyright file="BrokerContract.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for BrokerContract.</summary>
namespace Wgx.Common.ServiceBroker
{
    using System;
    using System.Data;
    using System.Data.SqlClient;
    using System.Globalization;
    using System.Text;

    /// <summary>
    /// Sql Service Broker Contract class.
    /// </summary>
    public class BrokerContract
    {
        /// <summary>
        /// Initializes a new instance of the BrokerContract class
        /// </summary>
        /// <param name="service">Associated Broker Service object</param>
        /// <param name="reader">SqlDataReader object that contains the query results for this Contract From the sys.service_contracts AND sys.service_contract_usages</param>
        internal BrokerContract(BrokerService service, SqlDataReader reader)
        {
            this.Service = service;
            this.Name = reader.GetString(0);
            this.Id = reader.GetInt32(1);

            using (SqlConnection sqlConnection = this.Service.Queue.Database.GetOpenedConnection())
            {
                using (SqlCommand sqlCommand = sqlConnection.CreateCommand())
                {
                    sqlCommand.CommandType = CommandType.StoredProcedure;
                    sqlCommand.CommandText = "p_GetMessageTypesForContract";
                    SqlParameter sqlParam = sqlCommand.Parameters.Add("@ContractId", SqlDbType.Int);
                    sqlParam.Value = this.Id;

                    using (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())
                    {
                        while (sqlDataReader.Read())
                        {
                            bool isRequestType = sqlDataReader.GetBoolean(4);
                            if (isRequestType)
                            {
                                this.RequestType = new BrokerMessageType(sqlDataReader);
                            }
                            else
                            {
                                this.ReplyType = new BrokerMessageType(sqlDataReader);
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets The Sql Service Broker Service object
        /// </summary>
        public BrokerService Service { get; private set; }

        /// <summary>
        /// Gets Sql Service Broker Contract Name
        /// </summary>
        public string Name { get; internal set; }

        /// <summary>
        /// Gets Sql Service Broker sql object id.
        /// </summary>
        public int Id { get; private set; }

        /// <summary>
        /// Gets Sql Service Broker Request Message Type
        /// </summary>
        public BrokerMessageType RequestType { get; private set; }

        /// <summary>
        /// Gets Sql Service Broker Response Message Type
        /// </summary>
        public BrokerMessageType ReplyType { get; private set; }

        /// <summary>
        /// Reports this objects state in a printable string
        /// </summary>
        /// <returns>Returns a string</returns>
        public override string ToString()
        {
            return this.ToString(string.Empty);
        }

        /// <summary>
        /// Reports this objects state in printable string w/ the provided prefix appended on each line.
        /// </summary>
        /// <param name="prefix">A prefix string that gets appended on each line</param>
        /// <returns>Returns a string</returns>
        internal string ToString(string prefix)
        {
            string newPrefix = Log.AddTabToEnd(prefix);
            StringBuilder sb = new StringBuilder(1024);

            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Name:      {1}\n", prefix, this.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Id:        {1}\n", prefix, this.Id);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Request Type\n", prefix);
            sb.AppendFormat(CultureInfo.InvariantCulture, this.RequestType.ToString(newPrefix));
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Response Type\n", prefix);
            
            if (this.ReplyType != null)
            {
                sb.AppendFormat(CultureInfo.InvariantCulture, this.ReplyType.ToString(newPrefix));
            }

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\BrokerMessage.cs ===
﻿// <copyright file="BrokerMessage.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for BrokerMessage.</summary>
namespace Wgx.Common.ServiceBroker
{
    using System;
    using System.Data.SqlClient;
    using System.Data.SqlTypes;
    using System.Globalization;
    using System.Text;

    /// <summary>
    /// BrokerMessage property positions within the query result.
    /// </summary>
    internal enum BrokerMessagePropertyPositions
    {
        /// <summary>
        /// Broker Message Query Result Converation_group_id offset location
        /// </summary>
        ConversationGroupId = 0,

        /// <summary>
        /// Broker Message Query Result conversation_handle offset location
        /// </summary>
        ConversationHandle = 1,

        /// <summary>
        /// Broker Message Query Result message_sequence_number offset location
        /// </summary>
        MessageSequenceNumber = 2,

        /// <summary>
        /// Broker Message Query Result service_name offset location
        /// </summary>
        ServiceName = 3,

        /// <summary>
        /// Broker Message Query Result service_contract_name offset location
        /// </summary>
        ServiceContractName = 4,

        /// <summary>
        /// Broker Message Query Result message_type_name offset location
        /// </summary>
        MessageTypeName = 5,

        /// <summary>
        /// Broker Message Query Result validation_flag offset location
        /// </summary>
        ValidationFlag = 6,

        /// <summary>
        /// Broker Message Query Result message_body offset location
        /// </summary>
        MessageBody = 7,

        /// <summary>
        /// Broker Message Query Result indicating the enumeration end, and is an invalid offset value.
        /// </summary>
        Invalid
    }

    /// <summary>
    /// A Sql Service Broker Message class.
    /// </summary>
    public sealed class BrokerMessage : IDisposable
    {
        /// <summary>
        /// A private byte array representing the message body.
        /// </summary>
        private byte[] body;

        /// <summary>
        /// Initializes a new instance of the BrokerMessage class
        /// </summary>
        /// <param name="sqlDataReader">The SqlDataReader object containing the message information</param>
        /// <param name="brokerConversation">The associated broker conversation object</param>
        internal BrokerMessage(SqlDataReader sqlDataReader, BrokerConversation brokerConversation)
            : this(sqlDataReader)
        {
            if (brokerConversation == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "brokerConversation");
            }

            Guid conversationHandle = sqlDataReader.GetGuid((int)BrokerMessagePropertyPositions.ConversationHandle);
            string serviceName = sqlDataReader.GetString((int)BrokerMessagePropertyPositions.ServiceName);
            string contractName = sqlDataReader.GetString((int)BrokerMessagePropertyPositions.ServiceContractName);

            this.Conversation = brokerConversation;

            if (conversationHandle != this.Conversation.Handle)
            {
                throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Expected conversation handle: {0} but got {1}", conversationHandle.ToString(), this.Conversation.Handle.ToString()));
            }

            if (serviceName != this.Conversation.InitiatorService.Name)
            {
                throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Expected Service Name: {0} but got {1}", serviceName, this.Conversation.InitiatorService.Name)); 
            }

            if (contractName != this.Conversation.Contract.Name)
            {
                throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Expected Contract Name: {0} but got {1}", contractName, this.Conversation.Contract));
            }
        }

        /// <summary>
        /// Initializes a new instance of the BrokerMessage class.
        /// A private constructor that initializes this object from a Data reader
        /// </summary>
        /// <param name="sqlDataReader">The SqlDataReader object that contains the information</param>
        private BrokerMessage(SqlDataReader sqlDataReader)
        {
            if (sqlDataReader == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "sqlDataReader");
            }

            //// RECEIVE conversation_group_id, conversation_handle, 
            //// message_sequence_number, service_name, service_contract_name, 
            //// message_type_name, validation, message_body
            this.GroupHandle = sqlDataReader.GetGuid((int)BrokerMessagePropertyPositions.ConversationGroupId);
            this.Sequence = sqlDataReader.GetInt64((int)BrokerMessagePropertyPositions.MessageSequenceNumber);
            this.MessageType = sqlDataReader.GetString((int)BrokerMessagePropertyPositions.MessageTypeName);
            this.Validation = sqlDataReader.GetString((int)BrokerMessagePropertyPositions.ValidationFlag);

            if (!sqlDataReader.IsDBNull((int)BrokerMessagePropertyPositions.MessageBody))
            {
                SqlBytes sb = sqlDataReader.GetSqlBytes(7);
                this.body = sb.Buffer;
            }
        }

        /// <summary>
        /// Gets the conversation class associated with this message
        /// </summary>
        public BrokerConversation Conversation { get; internal set; }

        /// <summary>
        /// Gets the conversation group handle id.
        /// </summary>
        public Guid GroupHandle { get; private set; }

        /// <summary>
        /// Gets the 64 bit sequence # of the message.
        /// </summary>
        public long Sequence { get; private set; }

        /// <summary>
        /// Gets the Message Type.
        /// TODO: convert this to BrokerMessageType instead of string.
        /// </summary>
        public string MessageType { get; private set; }

        /// <summary>
        /// Gets the validation string
        /// TODO: convert this to either a bool or a enumerated value.
        /// </summary>
        public string Validation { get; private set; }

        /// <summary>
        /// Retrieves the message body if any
        /// </summary>
        /// <returns>a byte array containing the message body</returns>
        public byte[] GetBody()
        {
            return this.body;
        }

        /// <summary>
        /// Returns the string containing the state of this object.
        /// </summary>
        /// <returns>a string containing the state</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder(1024);

            sb.AppendFormat(CultureInfo.InvariantCulture, "Message Content:\n");
            sb.AppendFormat(CultureInfo.InvariantCulture, "FROM SERVICE: {0}\n", this.Conversation.TargetService.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "TO SERVICE:   {0}\n", this.Conversation.InitiatorService.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "Sequence:     {0}\n", this.Sequence);
            sb.AppendFormat(CultureInfo.InvariantCulture, "Validation:   {0}\n", this.Validation);
            sb.AppendFormat(CultureInfo.InvariantCulture, "Group Id:     {0}\n", this.GroupHandle);
            sb.AppendFormat(CultureInfo.InvariantCulture, "conversation: {0}\n", this.Conversation.Handle);
            sb.AppendFormat(CultureInfo.InvariantCulture, "Message Type: {0}\n", this.MessageType);
            sb.AppendFormat(CultureInfo.InvariantCulture, "Contract:     {0}\n", this.Conversation.Contract);
            if (this.body != null && this.body.Length > 0)
            {
                sb.AppendFormat(CultureInfo.InvariantCulture, "Body: {0}\n", Encoding.Unicode.GetString(this.body));
            }

            return sb.ToString();
        }

        public void Dispose()
        {
            if (this.Conversation != null)
            {
                this.Conversation.Dispose();
            }
        }

        public void Close(bool cleanup)
        {
            if (this.Conversation != null)
            {
                this.Conversation.Close(cleanup);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\BrokerMessageType.cs ===
﻿// <copyright file="BrokerMessageType.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for BrokerMessageType.</summary>
namespace Wgx.Common.ServiceBroker
{
    using System;
    using System.Data.SqlClient;
    using System.Globalization;
    using System.Text;

    /// <summary>
    /// Broker Message type container
    /// </summary>
    public class BrokerMessageType
    {
        /// <summary>
        /// Initializes a new instance of the BrokerMessageType class
        /// </summary>
        /// <param name="sqlDataReader">SqlDataReader object that contains the query results</param>
        internal BrokerMessageType(SqlDataReader sqlDataReader)
        {
            this.Name = sqlDataReader.GetString(0);
            this.Id = sqlDataReader.GetInt32(1);

            if (!sqlDataReader.IsDBNull(2))
            {
                string description = sqlDataReader.GetString(2);
                if (string.Compare(description, "XML", StringComparison.OrdinalIgnoreCase) == 0)
                {
                    this.IsValidated = true;
                }

                this.ValidationDescription = description;
            }

            if (sqlDataReader.GetBoolean(4))
            {
                this.IsInitiatorMessage = true;
            }
        }

        /// <summary>
        /// Gets the BrokerMessage Type Name
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets the BrokerMessage sql object id
        /// </summary>
        public int Id { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the message is from an initiator.
        /// </summary>
        public bool IsInitiatorMessage { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the message is validated.
        /// </summary>
        public bool IsValidated { get; private set; }

        /// <summary>
        /// Gets teh ValidationDescription string.
        /// </summary>
        public string ValidationDescription { get; private set; }

        /// <summary>
        /// Dump the information for printing purposes.
        /// </summary>
        /// <returns>A string containing the state report</returns>
        public override string ToString()
        {
            return this.ToString(String.Empty);
        }

        /// <summary>
        /// Dumps the internal state to a string, w/ the provided prefix decorating every line.
        /// </summary>
        /// <param name="prefix">Prefix to be prepended to each line</param>
        /// <returns>string containg the entire Service Broker state for this Message Type.</returns>
        public string ToString(string prefix)
        {
            StringBuilder sb = new StringBuilder(256);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Name:        {1}\n", prefix, this.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Id:          {1}\n", prefix, this.Id);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}IsRequest:   {1}\n", prefix, this.IsInitiatorMessage);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}IsValidated: {1}\n", prefix, this.IsValidated);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Validation:  {1}\n", prefix, this.ValidationDescription);

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\BrokerDatabase.cs ===
﻿// <copyright file="BrokerDatabase.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for BrokerDatabase.</summary>
namespace Wgx.Common.ServiceBroker
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Globalization;
    using System.Text;
    using Wgx.Common;

    /// <summary>
    /// Sql Service Broker Database class
    /// </summary>
    public class BrokerDatabase
    {
        /// <summary>
        /// Initializes a new instance of the BrokerDatabase class
        /// </summary>
        /// <param name="name">Database Name</param>
        /// <param name="connectionString">Connection String to be used in a SqlConnection object</param>
        public BrokerDatabase(string name, string connectionString)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("This argument cannot be null or empty", "name");
            }

            if (string.IsNullOrEmpty(connectionString))
            {
                throw new ArgumentException("This argument cannot be null or empty", "connectionString");
            }

            this.Name = name;
            this.ConnectionString = connectionString;

            using (SqlConnection sqlConnection = this.GetOpenedConnection())
            {
                this.Queues = this.GetBrokerQueueListFromDb(sqlConnection);
            }
        }

        public BrokerDatabase(string connectionString)
            : this(new SqlConnectionStringBuilder(connectionString).DataSource, connectionString)
        {
        }

        /// <summary>
        /// Gets the Sql Connection string that is needed to successfully connect to the Sql instance.
        /// </summary>
        public string ConnectionString { get; internal set; }

        /// <summary>
        /// Gets the Name of the database.
        /// </summary>
        public string Name { get; internal set; }

        /// <summary>
        /// Gets the Collection of Service Broker Queues associated w/ the Database.
        /// </summary>
        public ICollection<BrokerQueue> Queues { get; internal set; }

        /// <summary>
        /// Retrieves a particular queue by its name.
        /// </summary>
        /// <param name="queueName">Queue name to searched</param>
        /// <param name="comparison">String Comparison to use</param>
        /// <returns>A Sql Service Broker queue object</returns>
        public BrokerQueue GetQueue(string queueName, StringComparison comparison)
        {
            if (string.IsNullOrEmpty(queueName))
            {
                throw new ArgumentException("This argument cannot be null or empty", "queueName");
            }

            foreach (BrokerQueue queue in this.Queues)
            {
                if (string.Compare(queueName, queue.Name, comparison) == 0)
                {
                    return queue;
                }
            }

            return null;
        }

        /// <summary>
        /// Returns a new SqlConnection object in the opened state to the caller.
        /// </summary>
        /// <returns>A SqlConnection in opened state</returns>
        public SqlConnection GetOpenedConnection()
        {
            SqlConnection sqlConnection = new SqlConnection(this.ConnectionString);

            try
            {
                sqlConnection.Open();
                return sqlConnection;
            }
            catch (Exception)
            {
                sqlConnection.Close();
                throw;
            }
        }

        /// <summary>
        /// Dumps the internal state to a string.
        /// </summary>
        /// <returns>string containing the entire Service Broker state for this Db</returns>
        public override string ToString()
        {
            return this.ToString(String.Empty);
        }

        /// <summary>
        /// A function which retrieves ALL queues associated to a given Db
        /// TODO: Consider changing List to ICollection for consistency. 
        /// </summary>
        /// <param name="sqlConnection">The SqlConnection on which to perform this operation.</param>
        /// <returns>A List of BrokerQueue</returns>
        internal List<BrokerQueue> GetBrokerQueueListFromDb(SqlConnection sqlConnection)
        {
            List<BrokerQueue> queueList = new List<BrokerQueue>(5);

            using (SqlCommand sqlCommand = sqlConnection.CreateCommand())
            {
                //// TODO: move this text to a constant in the BrokerQueue class
                sqlCommand.CommandText = @"p_GetServiceQueues";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                using (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())
                {
                    while (sqlDataReader.Read())
                    {
                        BrokerQueue brokerQueue = new BrokerQueue(this, sqlDataReader);
                        queueList.Add(brokerQueue);
                    }
                }
            }

            return queueList;
        }

        /// <summary>
        /// Dumps the internal state to a string, w/ the provided prefix decorating every line.
        /// </summary>
        /// <param name="prefix">Prefix to be prepended to each line</param>
        /// <returns>string containg the entire Service Broker state for this Db.</returns>
        internal string ToString(string prefix)
        {
            string newPrefix = Log.AddTabToEnd(prefix);
            StringBuilder sb = new StringBuilder(2048);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Name:                {1}\n", prefix, this.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}ConnectionString:    {1}\n", prefix, this.ConnectionString);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Queues:\n", prefix);
            foreach (BrokerQueue queue in this.Queues)
            {
                sb.AppendFormat(CultureInfo.InvariantCulture, queue.ToString(newPrefix));
            }

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\BrokerQueueOperations.cs ===
﻿// <copyright file="BrokerQueueOperations.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <date>2010-06-21</date>
// <summary>Class for operating on a Service Broker Queue. Requires admin level permissions on SQL Server</summary>
namespace Wgx.Common.ServiceBroker
{
    using System;
    using System.Data;
    using System.Data.SqlClient;
    using System.Text;
    using System.Net;

    /// <summary>
    /// Class to handle Service Broker Queue operations
    /// </summary>
    public class ServiceBrokerQueue
    {
        private const string DefaultDatabase = "RewardsQueueDb";
        private const string DefaultQueue = "RewardsTargetQueue";

        private string server = String.Empty;
        private string database = String.Empty;
        private string queue = String.Empty;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="server">SQL Server</param>
        /// <param name="database">Database</param>
        /// <param name="queue">Name of the queue</param>
        public ServiceBrokerQueue(string server, string database, string queue)
        {
            if (String.IsNullOrEmpty(server))
            {
                this.server = Dns.GetHostName(); // defaults to the current server (One box case)
            }
            else
            {
                this.server = server;
            }

            if (String.IsNullOrEmpty(database))
            {
                this.database = DefaultDatabase;
                this.queue = DefaultQueue;
            }
            else
            {
                this.database = database;
                this.queue = queue;
            }

            Console.WriteLine("***************************************************************************************");
            Console.WriteLine(String.Format("Using SERVER = {0}, DATABASE = {1}, QUEUE = {2}", 
                              this.server, this.database, this.queue));
            Console.WriteLine("***************************************************************************************");
            Console.WriteLine();  
        }

        /// <summary>
        /// Enable the queue
        /// </summary>
        public void Enable()
        {
            if (IsEnbled() == true)
            {
                Console.WriteLine(String.Format("Queue {0} of the database {1} on server {2} is already enabled",
                                this.queue, this.database, this.server));
                return;
            }

            Console.WriteLine("Enabling the queue ........");
            using (SqlConnection sqlConnection = new SqlConnection(GetSqlConnectionString(this.server, this.database)))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = sqlConnection;
                    sqlConnection.Open();
                    command.CommandText = String.Format("alter queue {0} with status = on", this.queue);
                    command.CommandType = CommandType.Text;

                    if (command.ExecuteNonQuery() == 0)
                    {
                        Console.WriteLine(String.Format("Couldn't enable the queue {0} of the database {1} on server {2}",
                                                        this.queue, this.database, this.server));
                    }
                    else
                    {
                        Console.WriteLine(String.Format("Queue {0} successfully enabled", this.queue));
                    }
                }
            }
        }

        /// <summary>
        /// Returns the status of the queue
        /// </summary>
        /// <returns></returns>
        public bool IsEnbled()
        {
            using (SqlConnection sqlConnection = new SqlConnection(GetSqlConnectionString(this.server, this.database)))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = sqlConnection;
                    sqlConnection.Open();
                    command.CommandText = String.Format("select is_receive_enabled from sys.service_queues where name = '{0}'", this.queue);
                    command.CommandType = CommandType.Text;

                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        reader.Read();
                        if (reader.HasRows)
                        {
                            bool retValue = (bool)reader.GetValue(0);

                            if (retValue == true)
                            {
                                Console.WriteLine("Queue is currently enabled");
                            }
                            else
                            {
                                Console.WriteLine("Queue is currently disabled");
                            }

                            return retValue;
                        }
                        else
                        {
                            throw new ApplicationException(String.Format("Couldn't get the stauts of queue {0} of the database {1} on server {2}",
                                this.queue, this.database, this.server));
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Returns the message count
        /// </summary>
        public void MessageCount()
        {
            using (SqlConnection sqlConnection = new SqlConnection(GetSqlConnectionString(this.server, this.database)))
            {
                using (SqlCommand command = new SqlCommand())
                {
                    command.Connection = sqlConnection;
                    sqlConnection.Open();
                    command.CommandText = String.Format("select count(*) from {0} with (nolock)", this.queue);
                    command.CommandType = CommandType.Text;

                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        reader.Read();
                        if (reader.HasRows)
                        {
                            int count = (int)reader.GetValue(0);
                            Console.WriteLine(String.Format("Queue contains {0} items", count.ToString()));
                        }
                        else
                        {
                            Console.WriteLine(String.Format("Couldn't get the message count of queue {0} of the database {1} on server {2}",
                                this.queue, this.database, this.server));
                        }
                    }
                }
            }
        }

        /// <summary>
        /// SQL connection string
        /// </summary>
        /// <param name="server"></param>
        /// <param name="database"></param>
        /// <returns></returns>
        private string GetSqlConnectionString(string server, string database)
        {
            SqlConnectionStringBuilder connectionBuilder = new SqlConnectionStringBuilder()
            {
                DataSource = server,
                InitialCatalog = database,
                IntegratedSecurity = true,
                ConnectTimeout = 100
            };

            return connectionBuilder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\BrokerService.cs ===
﻿// <copyright file="BrokerService.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for ServiceBroker.</summary>
namespace Wgx.Common.ServiceBroker
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Globalization;
    using System.Text;
    using Wgx.Common;

    /// <summary>
    /// This class represents a SQL Service Broker service endpoint.
    /// </summary>
    public sealed class BrokerService
    {
        /// <summary>
        /// A list of contracts that this service is associated w/
        /// </summary>
        private List<BrokerContract> contractList;

        /// <summary>
        /// Initializes a new instance of the BrokerService class
        /// </summary>
        /// <param name="brokerQueue">The BrokerQueue with wich this Service is associated.</param>
        /// <param name="serviceName">The Service Name</param>
        /// <param name="objectId">The SQl object id of this service</param>
        /// <param name="principalId">The security principal sql id</param>
        internal BrokerService(BrokerQueue brokerQueue, string serviceName, int objectId, int principalId)
            : this(serviceName)
        {
            this.Queue = brokerQueue;
            this.Id = objectId;
            this.PrincipalId = principalId;
        }

        /// <summary>
        /// Initializes a new instance of the BrokerService class
        /// </summary>
        /// <param name="serviceName">The Service Name</param>
        internal BrokerService(string serviceName)
        {
            this.Name = serviceName;
        }

        /// <summary>
        /// Gets the Name of this service
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets the Security Principal sql id 
        /// </summary>
        public int PrincipalId { get; private set; }

        /// <summary>
        /// Gets the Sql Id of this service.
        /// </summary>
        public int Id { get; private set; }

        /// <summary>
        /// Gets the BrolerQueue that this service is associated w/
        /// </summary>
        public BrokerQueue Queue { get; private set; }

        /// <summary>
        /// Gets a collection of Contracts that this service is associated w/
        /// </summary>
        public ICollection<BrokerContract> Contracts
        {
            get
            {
                if (this.contractList == null || this.contractList.Count == 0)
                {
                    this.contractList = this.GetContracts();
                }

                return this.contractList;
            }
        }

        /// <summary>
        /// Gets a collection of conversation that this service has currently active.
        /// </summary>
        public ICollection<BrokerConversation> Conversations
        {
            get
            {
                return this.GetConversations();
            }
        }

        /// <summary>
        /// Creates a Service Broker Conversation.
        /// </summary>
        /// <param name="targetServiceName">Target Service Name</param>
        /// <param name="brokerInstance">Broker Instance that this conversation will be associated w/</param>
        /// <param name="brokerContract">The messaging contract that this conversation will be using</param>
        /// <param name="relatedConversation">An optional parameter if there is any related conversation, this conversation will be in the same conversation group</param>
        /// <param name="lifetime">the lifetime associated w/ the new conversation</param>
        /// <param name="encryption">Should encryption be enabled</param>
        /// <param name="groupId">An optional parameter,a groupId that this conversation should belong to</param>
        /// <param name="sqlConnection">The Sql Connection on which this action will be performed</param>
        /// <param name="sqlTransaction">A Sql transaction under which to perform this action.</param>
        /// <returns>Return the Guid of the conversation handle</returns>
        public Guid CreateConversation(
                string targetServiceName,
                string brokerInstance,
                BrokerContract brokerContract,
                BrokerConversation relatedConversation,
                TimeSpan lifetime,
                bool encryption,
                Guid groupId,
                SqlConnection sqlConnection,
                SqlTransaction sqlTransaction)
        {
            if (groupId != Guid.Empty && relatedConversation != null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "groupId");
            }

            if (sqlConnection == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "sqlConnection");
            }

            if (sqlTransaction == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "sqlTransaction");
            }

            if (groupId != Guid.Empty && relatedConversation != null)
            {
                throw new ArgumentException("you cannot specify both group Id and conversation handle for creating a conversation");
            }

            SqlParameter param;
            SqlCommand sqlCommand = sqlConnection.CreateCommand();
            sqlCommand.Transaction = sqlTransaction;

            if (string.IsNullOrEmpty(brokerInstance))
            {
                param = sqlCommand.Parameters.Add("@BrokerInstance", SqlDbType.NVarChar);
                param.Value = DBNull.Value;
            }
            else
            {
                param = sqlCommand.Parameters.Add("@BrokerInstance", SqlDbType.NVarChar, brokerInstance.Length);
                param.Value = brokerInstance;
            }

            param = sqlCommand.Parameters.Add("@Encryption", SqlDbType.Bit);
            param.Value = encryption;

            param = sqlCommand.Parameters.Add("@RelatedConversationHandle", SqlDbType.UniqueIdentifier);
            if (relatedConversation == null)
            {
                param.Value = DBNull.Value;
            }
            else
            {
                param.Value = relatedConversation.Handle;
            }

            param = sqlCommand.Parameters.Add("@RelatedConversationGroup", SqlDbType.UniqueIdentifier);
            if (groupId == Guid.Empty)
            {
                param.Value = DBNull.Value;
            }
            else
            {
                param.Value = groupId;
            }

            param = sqlCommand.Parameters.Add("@LifeTime", SqlDbType.BigInt);
            param.Value = (long)lifetime.TotalSeconds;

            param = sqlCommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier);
            param.Direction = ParameterDirection.Output;

            param = sqlCommand.Parameters.Add("@InitiatorService", SqlDbType.NVarChar, 255);
            param.Value = this.Name;

            param = sqlCommand.Parameters.Add("@TargetService", SqlDbType.NVarChar, 255);
            param.Value = targetServiceName;

            param = sqlCommand.Parameters.Add("@ContractName", SqlDbType.NVarChar, 128);
            param.Value = brokerContract.Name;

            sqlCommand.CommandText = "p_CreateConversation";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            int result = sqlCommand.ExecuteNonQuery();
            Log.Print(string.Format(CultureInfo.InvariantCulture, "p_CreateConversation ExecuteNonQuery returned {0}", result));

            param = sqlCommand.Parameters["@ConversationHandle"] as SqlParameter;
            Guid handle = (Guid)param.Value;

            //// TODO: add it to a cache.
            //// BrokerConversation bConversation = new BrokerConversation(handle);

            return handle;
        }

        /// <summary>
        /// Creates a Service Broker Conversation and uses transaction of given connection.
        /// </summary>
        /// <param name="targetServiceName">Target Service Name</param>
        /// <param name="brokerInstance">Broker Instance that this conversation will be associated w/</param>
        /// <param name="brokerContract">The messaging contract that this conversation will be using</param>
        /// <param name="relatedConversation">An optional parameter if there is any related conversation, this conversation will be in the same conversation group</param>
        /// <param name="lifetime">the lifetime associated w/ the new conversation</param>
        /// <param name="encryption">Should encryption be enabled</param>
        /// <param name="groupId">An optional parameter,a groupId that this conversation should belong to</param>
        /// <param name="sqlConnection">The Sql Connection on which this action will be performed</param>
        /// <returns>Return the Guid of the conversation handle</returns>
        public Guid CreateConversation(string targetServiceName, string brokerInstance, BrokerContract brokerContract, BrokerConversation relatedConversation, TimeSpan lifetime, bool encryption, Guid groupId, SqlConnection sqlConnection)
        {
            Guid conversationHandle = Guid.Empty;
            SqlTransaction sqlTransaction = null;

            // Create a conversation AND commit.
            try
            {
                sqlTransaction = sqlConnection.BeginTransaction();

                conversationHandle = CreateConversation(targetServiceName,
                                        brokerInstance,
                                        brokerContract,
                                        relatedConversation,
                                        lifetime,
                                        encryption,
                                        groupId,
                                        sqlConnection,
                                        sqlTransaction);
                sqlTransaction.Commit();
            }
            catch (Exception)
            {
                sqlTransaction.Rollback();
                throw;
            }

            return conversationHandle;
        }

        /// <summary>
        /// Receive a message from any available unlocked conversation
        /// </summary>
        /// <param name="timeout">The timeout period to wait before returning. This call will block for this period.</param>
        /// <param name="fetchSize">How Many messages to retrieve.</param>
        /// <param name="sqlConnection">The Sql Connection on which to perform this operation.</param>
        /// <param name="sqlTransaction">The Sql Transaction under which to perform this operation.</param>
        /// <returns>A collection of Broker Messages</returns>
        public ICollection<BrokerMessage> ReceiveMessage(
                                                    TimeSpan timeout,
                                                    int fetchSize,
                                                    SqlConnection sqlConnection,
                                                    SqlTransaction sqlTransaction)
        {
            SqlCommand sqlCommand = this.BuildReceiveMessageString(null, timeout, fetchSize, sqlConnection, sqlTransaction);

            using (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())
            {
                List<BrokerMessage> listMessage = new List<BrokerMessage>();

                BrokerMessage brokerMsg = null;
                while (sqlDataReader.Read())
                {
                    Guid conversationHandle = sqlDataReader.GetGuid((int)BrokerMessagePropertyPositions.ConversationHandle);

                    // TODO:  check if we have this cached before retrieveing it from DB.
                    BrokerConversation brokerConversation = this.GetConversation(conversationHandle);

                    brokerMsg = new BrokerMessage(sqlDataReader, brokerConversation);

                    listMessage.Add(brokerMsg);
                }

                return listMessage;
            }
        }

        public ICollection<BrokerMessage> ReceiveMessage(TimeSpan timeout, int fetchSize, SqlConnection sqlConnection)
        {
            SqlTransaction sqlTransaction = null;
            ICollection<BrokerMessage> brokerMessages = null;
            try
            {
                sqlTransaction = sqlConnection.BeginTransaction();
                brokerMessages = this.ReceiveMessage(timeout, fetchSize, sqlConnection, sqlTransaction);
                sqlTransaction.Commit();
            }
            catch (Exception)
            {
                // it is possible that there is nothing to rollback, absorb such errors.
                try
                {
                    if (sqlTransaction != null)
                    {
                        sqlTransaction.Rollback();
                    }
                }
                catch (InvalidOperationException)
                {
                }

                throw;
            }

            return brokerMessages;
        }

        /// <summary>
        /// Retrieves a Broker Contract by name
        /// </summary>
        /// <param name="contractName">The contract name for lookup</param>
        /// <param name="comparison">What kind of comparison to make</param>
        /// <returns>Broker Contract matching the name</returns>
        public BrokerContract GetContract(string contractName, StringComparison comparison)
        {
            if (string.IsNullOrEmpty(contractName))
            {
                throw new ArgumentException("This argument cannot be null or empty", "contractName");
            }

            foreach (BrokerContract contract in this.Contracts)
            {
                if (string.Compare(contractName, contract.Name, comparison) == 0)
                {
                    return contract;
                }
            }

            return null;
        }

        /// <summary>
        /// Retrieves a Broker Contract by sql object id
        /// </summary>
        /// <param name="contractId">Sql Object Id</param>
        /// <returns>Broker Contract matching the name</returns>
        public BrokerContract GetContract(int contractId)
        {
            foreach (BrokerContract contract in this.Contracts)
            {
                if (contract.Id == contractId)
                {
                    return contract;
                }
            }

            return null;
        }

        /// <summary>
        /// Retrieve the conversation by id
        /// </summary>
        /// <param name="conversationHandle">The conversation handle guid</param>
        /// <returns>Broker Conversation matching the name</returns>
        public BrokerConversation GetConversation(Guid conversationHandle)
        {
            BrokerConversation conversation = new BrokerConversation(this, conversationHandle);

            return conversation;
        }

        /// <summary>
        /// Returns a string represantation of the current state
        /// </summary>
        /// <returns>string containing the state</returns>
        public override string ToString()
        {
            return this.ToString(string.Empty);
        }

        /// <summary>
        /// Returns a string representation of the current state
        /// </summary>
        /// <param name="prefix">A string prefix that is prependen to every line</param>
        /// <returns>string containing the state</returns>
        public string ToString(string prefix)
        {
            string newPrefix = Log.AddTabToEnd(prefix);

            StringBuilder sb = new StringBuilder(512);

            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Name:       {1}\n", prefix, this.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}sqlId:      {1}\n", prefix, this.Id);
            if (this.Contracts.Count > 0)
            {
                sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Contracts:\n", prefix);
                foreach (BrokerContract contract in this.Contracts)
                {
                    sb.AppendFormat(CultureInfo.InvariantCulture, contract.ToString(newPrefix));
                }
            }
            else
            {
                sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Contracts: N/A\n", prefix);
            }

            return sb.ToString();
        }

        /// <summary>
        /// Builds the Receive Command String which can subsequently be used in a SqlCommand
        /// </summary>
        /// <param name="brokerConversation">The conversation on which to receive, optional.</param>
        /// <param name="timeout">The timeout until a message is received before giving up.</param>
        /// <param name="fetchSize">How many messages to try fetching</param>
        /// <param name="sqlConnection">The Sql Connaction on which to attempt this operation</param>
        /// <param name="sqlTransaction">The Sql Transaction under which to perform this operation</param>
        /// <returns>Returns a SqlCommand object</returns>
        internal SqlCommand BuildReceiveMessageString(
                                      BrokerConversation brokerConversation,
                                      TimeSpan timeout,
                                      int fetchSize,
                                      SqlConnection sqlConnection,
                                      SqlTransaction sqlTransaction)
        {
            if (sqlTransaction == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "sqlTransaction");
            }

            if (sqlConnection == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "sqlConnection");
            }

            if (timeout == null)
            {
                throw new ArgumentException("This argument cannot be null or empty", "timeout");
            }

            SqlParameter param;
            SqlCommand sqlCommand = null;

            try
            {
                sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.Transaction = sqlTransaction;
                
                param = sqlCommand.Parameters.Add("@FetchSize", SqlDbType.Int);
                param.Value = fetchSize;

                param = sqlCommand.Parameters.Add("@QueueName", SqlDbType.NVarChar, this.Queue.Name.Length);
                param.Value = this.Queue.Name;

                if (brokerConversation == null)
                {
                    param = sqlCommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier);
                    param.Value = DBNull.Value;
                }
                else
                {
                    param = sqlCommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier);
                    param.Value = brokerConversation.Handle;
                }

                param = sqlCommand.Parameters.Add("@Timeout", SqlDbType.Int);
                param.Value = (int)timeout.TotalMilliseconds;

                sqlCommand.CommandText = "p_ReceiveWithTimeout";
                sqlCommand.CommandTimeout = 0;
                sqlCommand.CommandType = CommandType.StoredProcedure;
                return sqlCommand;
            }
            catch (Exception)
            {
                if (sqlCommand != null)
                {
                    sqlCommand.Dispose();
                }

                throw; // do not absorb the exception.
            }
        }

        /// <summary>
        /// Retrieve all known conversations associated w/ this service.
        /// </summary>
        /// <returns>The list of conversations</returns>
        private List<BrokerConversation> GetConversations()
        {
            List<BrokerConversation> conversation = new List<BrokerConversation>(5);

            using (SqlConnection sqlConnection = this.Queue.Database.GetOpenedConnection())
            {
                using (SqlCommand sqlCommand = sqlConnection.CreateCommand())
                {
                    SqlParameter sqlParam = sqlCommand.Parameters.Add("@ServiceId", SqlDbType.Int);
                    sqlParam.Value = this.Id;

                    sqlCommand.CommandText = "p_GetConversationEndpointsForService";
                    sqlCommand.CommandType = CommandType.StoredProcedure;
                    using (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())
                    {
                        while (sqlDataReader.Read())
                        {
                            BrokerConversation contract = new BrokerConversation(this, sqlDataReader);
                            conversation.Add(contract);
                        }
                    }
                }
            }

            return conversation;
        }

        /// <summary>
        /// Retrieve all contracts associated w/ this service.
        /// </summary>
        /// <returns>The list of contracts</returns>
        private List<BrokerContract> GetContracts()
        {
            List<BrokerContract> contracts = new List<BrokerContract>(5);

            using (SqlConnection sqlConnection = this.Queue.Database.GetOpenedConnection())
            {
                using (SqlCommand sqlCommand = sqlConnection.CreateCommand())
                {
                    SqlParameter sqlParam = sqlCommand.Parameters.Add("@ServiceId", SqlDbType.Int);
                    sqlParam.Value = this.Id;

                    sqlCommand.CommandText = "p_GetContractsForService";
                    sqlCommand.CommandType = CommandType.StoredProcedure;

                    using (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())
                    {
                        while (sqlDataReader.Read())
                        {
                            BrokerContract contract = new BrokerContract(this, sqlDataReader);
                            contracts.Add(contract);
                        }
                    }
                }
            }

            return contracts;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\test\Program.cs ===
﻿using System;

using Wgx.Common.ServiceBroker.Test;

namespace SBConsole
{
    class Program
    {
        static internal void ReportException(Exception ex)
        {
            Console.WriteLine(ex.ToString());
        }

        static void Main(string[] args)
        {
            try
            {
                TestServiceBrokerDatabase.Run();
                //TestServiceBrokerService.Run();

                TestServiceBrokerService.fStopBackgroundTests = true;
                Console.WriteLine("Test is complete, press enter to finish");
            }
            catch (Exception ex)
            {
                ReportException(ex);
                throw;
            }

            Console.ReadLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\BrokerQueue.cs ===
﻿// <copyright file="BrokerQueue.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for BrokerQueue.</summary>
namespace Wgx.Common.ServiceBroker
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Globalization;
    using System.Text;
    using Wgx.Common;

    /// <summary>
    /// Service Queue Table (service_queues) query result field positions, 
    /// </summary>
    internal enum ServiceQueuesTablePositions
    {
        /// <summary>
        /// Query Result Name position offset
        /// </summary>
        Name = 0,

        /// <summary>
        /// Query Result ObjectId position offset
        /// </summary>
        ObjectId = 1,

        /// <summary>
        /// Query Result Principal_id position offset
        /// </summary>
        PrincipalId,

        /// <summary>
        /// Query Result Schema_id position offset
        /// </summary>
        SchemaId,

        /// <summary>
        /// Query Result parent_object_id position offset
        /// </summary>
        ParentObjectId,

        /// <summary>
        /// Query Result Type position offset
        /// </summary>
        Type,

        /// <summary>
        /// Query Result Type_desc position offset
        /// </summary>
        TypeDesc,

        /// <summary>
        /// Query Result create_date position offset
        /// </summary>
        CreateDate,

        /// <summary>
        /// Query Result modify_date position offset
        /// </summary>
        ModifyDate,

        /// <summary>
        /// Query Result is_ms_shipped position offset
        /// </summary>
        IsMsShipped,

        /// <summary>
        /// Query Result is_published position offset
        /// </summary>
        IsPublished,
        
        /// <summary>
        /// Query Result is_schema_published position offset
        /// </summary>
        IsSchemaPublished,

        /// <summary>
        /// Query Result max_readers position offset
        /// </summary>
        MaxReaders,

        /// <summary>
        /// Query Result activation_procedure position offset
        /// </summary>
        ActivationProcedure,

        /// <summary>
        /// Query Result execute_as_principal_id position offset
        /// </summary>
        ExecuteAsPrincipalId,

        /// <summary>
        /// Query Result is_activation_enabled position offset
        /// </summary>
        IsActivationEnabled,

        /// <summary>
        /// Query Result is_receive_enabled position offset
        /// </summary>
        IsReceiveEnabled,

        /// <summary>
        /// Query Result is_enqueue_enabled position offset
        /// </summary>
        IsEnqueueEnabled,

        /// <summary>
        /// Query Result is_retention_enabled position offset
        /// </summary>
        IsRetentionEnabled,

        /// <summary>
        /// Invalid position offset, this marks the end of this enumeration
        /// </summary>
        Invalid,
    }

    /// <summary>
    /// The Broker Queue class
    /// </summary>
    public class BrokerQueue
    {
        /// <summary>
        /// A private list of known broker services.
        /// </summary>
        private List<BrokerService> serviceList;

        /// <summary>
        /// Initializes a new instance of the BrokerQueue class
        /// </summary>
        /// <param name="brokerDb">The Database that this queue belongs to</param>
        /// <param name="sqlDataReader">The SqlDataReader that containst initialization information about this queue</param>
        internal BrokerQueue(BrokerDatabase brokerDb, SqlDataReader sqlDataReader)
        {
            this.Database = brokerDb;
            this.Name = sqlDataReader.GetString((int)ServiceQueuesTablePositions.Name);
            this.Id = sqlDataReader.GetInt32((int)ServiceQueuesTablePositions.ObjectId);
            this.CreateDate = sqlDataReader.GetDateTime((int)ServiceQueuesTablePositions.CreateDate);
            this.ModifyDate = sqlDataReader.GetDateTime((int)ServiceQueuesTablePositions.ModifyDate);
            if (!sqlDataReader.IsDBNull((int)ServiceQueuesTablePositions.ActivationProcedure))
            {
                this.ActivationProcedure = sqlDataReader.GetString((int)ServiceQueuesTablePositions.ActivationProcedure);
            }

            this.ActivationEnabled = sqlDataReader.GetSqlBoolean((int)ServiceQueuesTablePositions.IsActivationEnabled).Value;
            this.ReceiveEnabled = sqlDataReader.GetSqlBoolean((int)ServiceQueuesTablePositions.IsReceiveEnabled).Value;
            this.EnqueueEnabled = sqlDataReader.GetSqlBoolean((int)ServiceQueuesTablePositions.IsEnqueueEnabled).Value;
            this.RetentionEnabled = sqlDataReader.GetSqlBoolean((int)ServiceQueuesTablePositions.IsRetentionEnabled).Value;
        }

        /// <summary>
        /// Gets The Database object, where this Queue is associated w/
        /// </summary>
        public BrokerDatabase Database { get; private set; }

        /// <summary>
        /// Gets the collection of services this queue has.
        /// </summary>
        public ICollection<BrokerService> Services
        {
            get
            {
                if (this.serviceList == null || this.serviceList.Count == 0)
                {
                    this.serviceList = this.GetServices();
                }

                return this.serviceList;
            }
        }

        /// <summary>
        /// Gets the name of the queue
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets the Sql object id of this queue
        /// </summary>
        public int Id { get; private set; }

        /// <summary>
        /// Gets the creation date of this queue
        /// </summary>
        public DateTime CreateDate { get; private set; }

        /// <summary>
        /// Gets the modification date of this queue
        /// </summary>
        public DateTime ModifyDate { get; private set; }

        /// <summary>
        /// Gets the activation stored procedure name if present.
        /// </summary>
        public string ActivationProcedure { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the activation is enabled.
        /// </summary>
        public bool ActivationEnabled { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the queue can receive messages.
        /// </summary>
        public bool ReceiveEnabled { get; private set; }

        /// <summary>
        /// Gets a value indicating whether queue can enqueue messages.
        /// </summary>
        public bool EnqueueEnabled { get; private set; }

        /// <summary>
        /// Gets a value indicating whether queue has retention on.
        /// </summary>
        public bool RetentionEnabled { get; private set; }

        /// <summary>
        /// Returns a BrokerService by name.
        /// </summary>
        /// <param name="serviceName">The name of the service to lookup</param>
        /// <param name="comparison">How the comparison should be performed</param>
        /// <returns>A BrokerService object matching the name</returns>
        public BrokerService GetService(string serviceName, StringComparison comparison)
        {
            if (string.IsNullOrEmpty(serviceName))
            {
                throw new ArgumentException("This argument cannot be null or empty", "serviceName");
            }

            foreach (BrokerService service in this.Services)
            {
                if (string.Compare(serviceName, service.Name, comparison) == 0)
                {
                    return service;
                }
            }

            return null;
        }

        /// <summary>
        /// Returns a string represantation of the current state
        /// </summary>
        /// <returns>string containing the state</returns>
        public override string ToString()
        {
            return this.ToString(String.Empty);
        }

        /// <summary>
        /// Returns a string representation of the current state
        /// </summary>
        /// <param name="prefix">A string prefix that is prependen to every line</param>
        /// <returns>string containing the state</returns>
        public string ToString(string prefix)
        {
            string newPrefix = Log.AddTabToEnd(prefix);

            StringBuilder sb = new StringBuilder(1024);

            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Name:       {1}\n", prefix, this.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Db:         {1}\n", prefix, this.Database.Name);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Id:         {1}\n", prefix, this.Id);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Created:    {1}\n", prefix, this.CreateDate.ToString());
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Modified:   {1}\n", prefix, this.ModifyDate.ToString());
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Act. Proc:  {1}\n", prefix, this.ActivationProcedure);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Activation: {1}\n", prefix, this.ActivationEnabled);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Receive:    {1}\n", prefix, this.ReceiveEnabled);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Enqueue:    {1}\n", prefix, this.EnqueueEnabled);
            sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Retention:  {1}\n", prefix, this.RetentionEnabled);

            if (this.Services.Count > 0)
            {
                sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Services:\n", prefix);
                foreach (BrokerService service in this.Services)
                {
                    sb.AppendFormat(CultureInfo.InvariantCulture, "{0}\n", service.ToString(newPrefix));
                }
            }
            else
            {
                sb.AppendFormat(CultureInfo.InvariantCulture, "{0}Services: N/A\n", prefix);
            }

            return sb.ToString();
        }

        /// <summary>
        /// Retrieves all Services associated with this Queue.
        /// </summary>
        /// <returns>A generic list of BrokerServices</returns>
        private List<BrokerService> GetServices()
        {
            List<BrokerService> svcList = new List<BrokerService>(5);

            using (SqlConnection sqlConnection = this.Database.GetOpenedConnection())
            {
                using (SqlCommand sqlCommand = sqlConnection.CreateCommand())
                {
                    sqlCommand.CommandText = @"p_GetServicesForQueueId";
                    sqlCommand.CommandType = CommandType.StoredProcedure;
                    SqlParameter param = sqlCommand.Parameters.Add("@QueueId", SqlDbType.Int);
                    param.Value = this.Id;

                    using (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())
                    {
                        while (sqlDataReader.Read())
                        {
                            BrokerService brokerService = new BrokerService(this, sqlDataReader.GetString(0), sqlDataReader.GetInt32(1), sqlDataReader.GetInt32(2));
                            svcList.Add(brokerService);
                        }
                    }
                }
            }

            return svcList;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\ServiceBroker\MessageTypes.cs ===
﻿// <copyright file="MessageTypes.cs" company="Microsoft">
// Copyright (c) 2008 All Right Reserved
// </copyright>
// <author>Savas Guven</author>
// <email>savas.guven@microsoft.com</email>
// <date>2008-12-17</date>
// <summary>Contains the class definition for ServiceBrokerMessageTypes.</summary>
namespace Wgx.Common.ServiceBroker
{
    /// <summary>
    /// Service Broker Built-in Message Type constants
    /// </summary>
    public static class ServiceBrokerMessageTypes
    {
        /// <summary>
        /// System message type for event notification messages.
        /// </summary>
        public const string EventNotificationType = "http://schemas.microsoft.com/SQL/Notifications/EventNotification";

        /// <summary>
        /// System message type for query notification messages.
        /// </summary>
        public const string QueryNotificationType = "http://schemas.microsoft.com/SQL/Notifications/QueryNotification";

        /// <summary>
        /// System message type for message indicating failed remote service binding.
        /// </summary>
        public const string FailedRemoteServiceBindingType = "http://schemas.microsoft.com/SQL/ServiceBroker/BrokerConfigurationNotice/FailedRemoteServiceBinding";

        /// <summary>
        /// System message type for message indicating failed route.
        /// </summary>
        public const string FailedRouteType = "http://schemas.microsoft.com/SQL/ServiceBroker/BrokerConfigurationNotice/FailedRoute";

        /// <summary>
        /// System message type for message indicating missing remote service binding.
        /// </summary>
        public const string MissingRemoteServiceBindingType = "http://schemas.microsoft.com/SQL/ServiceBroker/BrokerConfigurationNotice/MissingRemoteServiceBinding";

        /// <summary>
        /// System message type for message indicating missing route.
        /// </summary>
        public const string MissingRouteType = "http://schemas.microsoft.com/SQL/ServiceBroker/BrokerConfigurationNotice/MissingRoute";

        /// <summary>
        /// System message type for dialog timer messages.
        /// </summary>
        public const string DialogTimerType = "http://schemas.microsoft.com/SQL/ServiceBroker/DialogTimer";

        /// <summary>
        /// System message type for message indicating end of dialog.
        /// </summary>
        public const string EndDialogType = "http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog";

        /// <summary>
        /// System message type for error messages.
        /// </summary>
        public const string ErrorType = "http://schemas.microsoft.com/SQL/ServiceBroker/Error";

        /// <summary>
        /// System message type for diagnostic description messages.
        /// </summary>
        public const string DescriptionType = "http://schemas.microsoft.com/SQL/ServiceBroker/ServiceDiagnostic/Description";

        /// <summary>
        /// System message type for diagnostic query messages.
        /// </summary>
        public const string QueryType = "http://schemas.microsoft.com/SQL/ServiceBroker/ServiceDiagnostic/Query";

        /// <summary>
        /// System message type for diagnostic status messages.
        /// </summary>
        public const string StatusType = "http://schemas.microsoft.com/SQL/ServiceBroker/ServiceDiagnostic/Status";

        /// <summary>
        /// System message type for echo service messages.
        /// </summary>
        public const string EchoType = "http://schemas.microsoft.com/SQL/ServiceBroker/ServiceEcho/Echo";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\test\TestServiceBrokerCommonStrings.cs ===
﻿namespace Wgx.Common.ServiceBroker.Test
{
    internal static class CommonStrings
    {
        internal static string ConnectionInvalid = @"Data Source=ATIN-PC\MSSQLSERVER;Integrated security=SSPI;Initial Catalog=RewardsQueueDb;";
        internal static string ValidConnectionWithInvalidDB = @"Data Source=ATIN-PC; Integrated security=SSPI; Initial Catalog=NonExistingDB;";


        internal static string InitiatorConnectionStringValid = @"Data Source=ATIN-PC; Integrated security=SSPI; Initial Catalog=RewardsQueueDb;Asynchronous Processing=true";
        internal static string InitiatorDbValid = @"RewardsQueueDb";
        internal static string InitiatorQueueValid = @"RewardsInitiatorQueue";
        internal static string InitiatorServiceValid = @"//Rewards/Event/InitiatorService";
        internal static string InitiatorServiceInvalid = @"InvalidInitiatorServiceName";

        internal static string TargetConnectionStringValid = @"Data Source=ATIN-PC; Integrated security=SSPI; Initial Catalog=RewardsQueueDb;Asynchronous Processing=true";
        internal static string TargetDbValid = @"RewardsQueueDb";
        internal static string TargetQueueValid = @"RewardsTargetQueue";
        internal static string TargetServiceValid = @"//Rewards/Event/TargetService";
        internal static string TargetServiceInvalid = @"";

        internal static string ContractNameValid = @"//Rewards/Event/Contract";
        internal static string RequestMessageType = @"//Rewards/Event/RequestMessage";
        internal static string ReplyMessageType = @"//Rewards/Event/ReplyMessage";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\test\TestServiceBrokerDatabase.cs ===
﻿namespace Wgx.Common.ServiceBroker.Test
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using Wgx.Common.ServiceBroker;

    public static class TestServiceBrokerDatabase
    {
        public static void Run()
        {
            try
            {
                TestSBSDatabaseWithBadConnectionString();
                TestSBSDatabase();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

        /// <summary>
        /// Provide a valid connection string to a Database w/ valid Broker Queues.
        /// </summary>
        internal static void TestSBSDatabase()
        {
            BrokerDatabase bdb = new BrokerDatabase("RewardsQueueDb", CommonStrings.InitiatorConnectionStringValid);
            string connection = bdb.ConnectionString;
            string name = bdb.Name;
            ICollection<BrokerQueue> queues = bdb.Queues;

            string toString = bdb.ToString();

            Console.WriteLine("TestSBSDatabase ... passed.");
        }

        /// <summary>
        /// Provide invalid connection string to a Database. 
        /// We expect an SqlException w/ the ErrorCollection's first entry to have number 87 as the sql error.
        /// </summary>
        internal static void TestSBSDatabaseWithBadConnectionString()
        {
            try
            {
                BrokerDatabase bdb = new BrokerDatabase("RewardsQueueDb", CommonStrings.ConnectionInvalid);
                throw new InvalidOperationException(); // we should not hit this exception.
            }
            catch (SqlException ex)
            {
                if (ex.Number == 87)
                {
                    Console.WriteLine("TestSBSDatabaseWithBadConnectionString ... passed");
                }
                else
                    throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\test\TestServiceBrokerService.cs ===
﻿namespace Wgx.Common.ServiceBroker.Test
{
    using System;
    using System.Collections.Generic;
    using System.Data.SqlClient;
    using System.Text;
    using System.Threading;
    using Wgx.Common.ServiceBroker;

    public static class TestServiceBrokerService
    {
        public static void Run()
        {
            try
            {
                // TestSBSInvalidConnectionString();
                // TestSBSInvalidServiceName();
                // TestSBSValidServiceName();
                // TestSBSSendTestMessage();
                TestSBSConversationFromBothEnd();
                // TestSBSEchoConversation();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }

        public static bool fStopBackgroundTests = false;
        public static ManualResetEvent mer = new ManualResetEvent(false);

        /// <summary>
        /// We expect an Argument exception for the connection string.
        /// </summary>
        internal static void TestSBSInvalidConnectionString()
        {
            try
            {
                //BrokerService svc = new BrokerService(CommonStrings.InitiatorServiceValid, new SqlConnection(CommonStrings.ConnectionInvalid));
            }
            catch (ArgumentException)
            {
                Console.WriteLine("Test TestSBSInvalidConnectionString Passed");
            }
        }

        /// <summary>
        /// For an invalid service name and valid connection name we should get an Argument Exception for the service name
        /// </summary>
        internal static void TestSBSInvalidServiceName()
        {
            try
            {
                //BrokerService svc = new BrokerService(CommonStrings.InitiatorServiceInvalid,  new SqlConnection(CommonStrings.InitiatorConnectionStringValid));
            }
            catch (ArgumentException)
            {
                Console.WriteLine("Test TestSBSInvalidServiceName Passed");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        internal static void TestSBSValidServiceName()
        {
            //BrokerService svc = new BrokerService(CommonStrings.InitiatorServiceValid, new SqlConnection(CommonStrings.InitiatorConnectionStringValid));
            Console.WriteLine("Test TestSBSValidServiceName Passed");
        }

        internal static void TestSBSSendTestMessage()
        {
            BrokerDatabase bdb = new BrokerDatabase(CommonStrings.InitiatorDbValid, CommonStrings.InitiatorConnectionStringValid);

            BrokerQueue queue = bdb.GetQueue(CommonStrings.InitiatorQueueValid, StringComparison.OrdinalIgnoreCase);

            BrokerService svc = queue.GetService(CommonStrings.InitiatorServiceValid, StringComparison.OrdinalIgnoreCase);

            using (SqlConnection sqlConnection = bdb.GetOpenedConnection())
            {
                //
                // Create a conversation AND commit.
                //
                Guid conversationHandle = Guid.Empty;
                BrokerContract brokerContract = svc.GetContract(CommonStrings.ContractNameValid, StringComparison.OrdinalIgnoreCase);
                conversationHandle = svc.CreateConversation(CommonStrings.TargetServiceValid, null, brokerContract, null, TimeSpan.Zero, true, Guid.Empty, sqlConnection);
                using (BrokerConversation conv = svc.GetConversation(conversationHandle))
                {
                    Console.WriteLine("Conversation Created: {0}", conv.ToString());
                    string msg = @"<test>TestSBSSendTestMessage: " + DateTime.Now.ToLocalTime().ToString() + @"  </test>";

                    conv.Send(Encoding.Unicode.GetBytes(msg), CommonStrings.RequestMessageType, sqlConnection);

                    //
                    // TODO: verify receipt here.
                    //
                    ICollection<BrokerMessage> msgList = null;

                    msgList = conv.ReceiveMessage(new TimeSpan(0, 0, 10), 1, sqlConnection);

                    foreach (BrokerMessage bMsg in msgList)
                    {
                        Console.WriteLine(bMsg.ToString());
                    }

                    conv.Dispose();
                }
            }
        }

        internal static void TestSBSEchoConversation()
        {
            BrokerDatabase bdb = new BrokerDatabase(CommonStrings.TargetDbValid, CommonStrings.TargetConnectionStringValid);

            BrokerQueue queue = bdb.GetQueue(CommonStrings.TargetQueueValid, StringComparison.OrdinalIgnoreCase);

            BrokerService svc = queue.GetService(CommonStrings.TargetServiceValid, StringComparison.OrdinalIgnoreCase);

            bool fConnected = true;

            using (SqlConnection sqlConnection = bdb.GetOpenedConnection())
            {
                SqlTransaction sqlTransaction  = null;
                try
                {
                    ICollection<BrokerMessage> listOfMessages = null;

                    do
                    {
                        sqlTransaction = sqlConnection.BeginTransaction();

                        try
                        {
                            listOfMessages = svc.ReceiveMessage(new TimeSpan(0, 0, 5),
                                                                1,
                                                                sqlConnection,
                                                                sqlTransaction);

                            if (listOfMessages != null && listOfMessages.Count > 0 && fConnected)
                            {
                                foreach (BrokerMessage msg in listOfMessages)
                                {
                                    Console.WriteLine("Echo {0}", msg.ToString());

                                    string strMsg = @"<reply>TestSBSSendTestMessage: " + DateTime.Now.ToLocalTime().ToString() + @"  </reply>";

                                    msg.Conversation.Send(Encoding.Unicode.GetBytes(strMsg),
                                                          CommonStrings.ReplyMessageType,
                                                          sqlConnection,
                                                          sqlTransaction);
                                }
                            }

                            sqlTransaction.Commit();
                        }
                        catch (SqlException ex)
                        {
                            //
                            // check error codes from: http://msdn.microsoft.com/en-us/library/cc645597.aspx
                            // 8429 - The conversation endpoint is not in a valid state for SEND. The current endpoint state is '%ls'.
                            // in all likelyhood the conversation is closed.
                            if (ex.Number == 8429)
                            {
                                Console.WriteLine("Conversation is closed by remote endpoint, absorbing exception AND performing commit:\n {0}", ex.Errors[0].Message);
                                fConnected = false;
                                sqlTransaction.Commit();
                            }
                            else
                                throw;
                        }
                    } while (!TestServiceBrokerService.fStopBackgroundTests);
                }
                catch (Exception)
                {
                    sqlTransaction.Rollback();
                    throw;
                }
                finally
                {
                    mer.Set();
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        internal static void TestSBSConversationFromBothEnd()
        {
            // ensure that the echo thread is running.
            ThreadPool.QueueUserWorkItem((WaitCallback)delegate(Object stateInfo)
            {
                TestSBSEchoConversation();
            });

            BrokerDatabase bdb = new BrokerDatabase(CommonStrings.InitiatorDbValid, CommonStrings.InitiatorConnectionStringValid);

            BrokerQueue queue = bdb.GetQueue(CommonStrings.InitiatorQueueValid, StringComparison.OrdinalIgnoreCase);

            BrokerService svc = queue.GetService(CommonStrings.InitiatorServiceValid, StringComparison.OrdinalIgnoreCase);

            using (SqlConnection sqlConnection = bdb.GetOpenedConnection())
            {
                //
                // Create a conversation AND commit.
                //
                BrokerContract brokerContract = svc.GetContract(CommonStrings.ContractNameValid, StringComparison.OrdinalIgnoreCase);
                Guid conversationHandle = Guid.Empty;
                conversationHandle = svc.CreateConversation(CommonStrings.TargetServiceValid, null, brokerContract, null, TimeSpan.Zero, true, Guid.Empty, sqlConnection);

                using (BrokerConversation conv = svc.GetConversation(conversationHandle))
                {
                    Console.WriteLine("Conversation Created: {0}", conv.ToString());
                    string msg = @"<test>TestSBSSendTestMessage: " + DateTime.Now.ToLocalTime().ToString() + @"  </test>";

                    // Write a 1000 message w/ 100 msec seperation
                    int numOfMessages = 1000;
                    for (int i = 0; i < numOfMessages; i++)
                    {
                        conv.Send(Encoding.Unicode.GetBytes(msg), CommonStrings.RequestMessageType, sqlConnection);
                    }

                    //
                    // Expect same amount of messages back here:
                    //
                    ICollection<BrokerMessage> msgList = null;
                    for (int i = 0; i < numOfMessages; i++)
                    {
                        msgList = conv.ReceiveMessage(new TimeSpan(0, 0, 10), 1, sqlConnection);

                        foreach (BrokerMessage bMsg in msgList)
                        {
                            Console.WriteLine("Message Received: {0}", i);
                        }

                        // ensure that count matches
                        if (msgList.Count == 0 && i == numOfMessages - 1)
                        {
                            throw new InvalidOperationException(string.Format("We didn't receive equal amount of messages back.\n\r Received={0}/Sent={1}", msgList.Count, numOfMessages));
                        }
                    }
                }
            }

            fStopBackgroundTests = true;
            mer.WaitOne();
            Console.WriteLine("TestSBSConversationFromBothEnd has finished succesfully");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\UnitTest\Program.cs ===
﻿namespace UnitTest
{
    using System;

    class Program
    {
        // insert your unit test code here.
        static void Main(string[] args)
        {
            TestLazyAsyncResult.Run();
            Console.WriteLine("Test run complete");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\Utilities\LazyAsyncResult.cs ===
﻿//------------------------------------------------------------------------------
// <copyright file="LazyAsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
namespace Wgx.Common.Utilities
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    
    /// <summary>
    /// LazyAsyncResult - Base class for all IAsyncResult classes
    /// that want to take advantage of lazy allocated event handles
    /// </summary>
    public class LazyAsyncResult : IAsyncResult, IDisposable
    {
#if DEBUG
        internal static Dictionary<int, LazyAsyncResult> pendingResults = new Dictionary<int, LazyAsyncResult>();
        internal static int pendingIndex;
        internal int index;
#endif

        /// <summary>
        /// Final IO result to be returned byt the End*() method.
        /// Has 3 known possible values:
        /// 1) DBNull.Value
        /// 2) null, 
        /// 3) a non null value, e.g. a real object
        /// </summary>
        private object resultObject;

        /// <summary>
        /// Counts the completion attempts. 
        /// </summary>
        private int isCompletedCounter;

        /// <summary>
        /// This integer counts the number of EndXxx calls.
        /// Only one of them should survive.
        /// </summary>
        private int isEndCalledCounter;

        /// <summary>
        /// The ManualResetEvent object on which waiting for completion is performed.
        /// </summary>
        private ManualResetEvent waitHandle;           // lazy allocated event to be returned in the IAsyncResult for the client to wait on

        /// <summary>
        /// Indicates whether the waitHandle is seen or constructed by the user.
        /// </summary>
        private bool isUserEvent;

        /// <summary>
        /// Initializes a new instance of the LazyAsyncResult class.
        /// Construct this object w/ the usual parameters
        /// </summary>
        /// <param name="asyncCaller">The constructor object</param>
        /// <param name="asyncState">The asynchronous state object passed by the initiator of the async operation</param>
        /// <param name="callback">The asynchronous callback</param>
        public LazyAsyncResult(object asyncObjectConstructor, object asyncState, AsyncCallback callback)
        {
            this.AsyncObject = asyncObjectConstructor;
            this.AsyncState = asyncState;
            this.AsyncCallback = callback;
            this.resultObject = DBNull.Value;

#if DEBUG
            this.index = Interlocked.Increment(ref LazyAsyncResult.pendingIndex);
            LazyAsyncResult.pendingResults.Add(this.index, this);
#endif
        }

        /// <summary>
        /// Initializes a new instance of the LazyAsyncResult class.
        /// Allows creating a pre-completed result with less interlockeds.  Beware!  Constructor calls the callback.
        /// if a derived class ever uses this and overloads Cleanup, this may need to change
        /// </summary>
        /// <param name="asyncCaller">The constructor object</param>
        /// <param name="asyncState">The asynchronous state object passed by the initiator of the async operation</param>
        /// <param name="callback">The asynchronous callback</param>
        /// <param name="result">The async operation result object</param>
        public LazyAsyncResult(object asyncObjectConstructor, object asyncState, AsyncCallback callback, object result)
        {
            this.AsyncObject = asyncObjectConstructor;
            this.AsyncState = asyncState;
            this.AsyncCallback = callback;
            this.resultObject = result;
            this.isCompletedCounter = 1;

            if (this.AsyncCallback != null)
            {
                this.AsyncCallback(this);
            }
        }

        /// <summary>
        /// Gets the caller's state object. 
        /// </summary>
        public object AsyncState { get; private set; }

        /// <summary>
        /// Gets a value indicating whether this Async operation completed synchronously
        /// Per MSDN it is ok to return mostly false here.
        /// Any code depending on this value to be accurate is probably buggy and follows an invalid async pattern.
        /// Those who want to return true here, should derive from this class and make the behavior different.
        /// </summary>
        public bool CompletedSynchronously { get; protected set; }

        /// <summary>
        /// Gets a value indicating whether the operation is completed.
        /// </summary>
        public bool IsCompleted
        {
            get
            {
                return this.PeekCompleted;
            }
        }

        /// <summary>
        /// Gets the IO result object.
        /// </summary>
        public object Result
        {
            get
            {
                return this.resultObject == DBNull.Value ? null : this.resultObject;
            }

            protected set
            {
                // Ideally this should never be called, since setting
                // the result object really makes sense when the IO completes.

                // But if the result was set here (as a preemptive error or for some other reason),
                // then the "result" parameter passed to InvokeCallback() will be ignored.
                // It's an error to call after the result has been completed or with DBNull.
                this.resultObject = value;
            }
        }

        /// <summary>
        /// Gets or sets the Async Exception if any
        /// </summary>
        public Exception AsyncException { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the EndXxx operation is called in the Async calling pattern.
        /// the Owner of this IAsyncResult is advised to set this value to true in the relevant method.
        /// </summary>
        public bool EndCalled { get; set; }

        // Interface property to return a WaitHandle that can be waited on for I/O completion.
        // This property implements lazy event creation.
        // the event object is only created when this property is accessed,
        // since we're internally only using callbacks, as long as the user is using
        // callbacks as well we will not create an event at all.
        // If this is used, the event cannot be disposed because it is under the control of the
        // application.  Internal should use InternalWaitForCompletion instead - never AsyncWaitHandle.
        public WaitHandle AsyncWaitHandle
        {
            get
            {
                ManualResetEvent asyncEvent;

                // indicates that the user has seen the event.
                // this way the event can't be disposed by us
                this.isUserEvent = true;

                // Because ProtectedWaitForCompletion() tries to dispose this event, it's
                // possible for waitHandle to become null immediately after being set, but only if
                // IsCompleted has become true.  
                // Therefore it's possible for this property
                // to give different (set) events to different callers when IsCompleted is true.
                asyncEvent = this.waitHandle;
                while (asyncEvent == null)
                {
                    this.LazilyCreateEvent(out asyncEvent);
                }

                return asyncEvent;
            }
        }

        /// <summary>
        /// Gets a value indicating whether something's completed without fixing CompletedSynchronously
        /// </summary>
        protected bool PeekCompleted
        {
            get
            {
                return this.isCompletedCounter > 0;
            }
        }

        /// <summary>
        /// Gets or sets the callers callback delegate
        /// </summary>
        protected AsyncCallback AsyncCallback { get; set; }

        /// <summary>
        /// Gets the original async object: 
        /// </summary>
        protected object AsyncObject { get; private set; }

        /// <summary>
        /// Checks whether an IAsyncResult object is a LazyAsyncResult object
        /// and resturns the LazyAsyncResult object.
        /// Throws InvalidOperationException on failures.
        /// </summary>
        /// <param name="ar">IAsyncResul object</param>
        /// <returns>A LazyAsyncResult object</returns>
        public static LazyAsyncResult Validate(IAsyncResult ar)
        {
            if (ar == null)
            {
                throw new InvalidOperationException("Bad AsyncResult object");
            }

            LazyAsyncResult lar = (LazyAsyncResult)ar;

            // ensure that you got the right type.
            if (lar == null)
            {
                throw new InvalidOperationException("Incorrect AsyncResult Object type provided");
            }

            return lar;
        }

        /// <summary>
        /// A method for completing the IO with a result
        /// and invoking the user's callback.
        /// </summary>
        /// <param name="result">The result object of this Async Operation</param>
        public void InvokeCallback(object result)
        {
            this.ProtectedInvokeCallback(result, IntPtr.Zero);
        }

        /// <summary>
        /// A method for completing the IO without a result
        /// and invoking the user's callback.
        /// </summary>
        public void InvokeCallback()
        {
            this.ProtectedInvokeCallback(null, IntPtr.Zero);
        }

        /// <summary>
        /// Performs typical EndXxx Async patterns in one fell swoop:
        /// Waits until Async operation completes AND
        /// Throws any exception that may have occured.
        /// This method SHOULD be called on within an EndXxx operation.
        /// This method will throw InvalidOperationException if the AsyncResult object is for whatever reason faulty.
        /// </summary>
        /// <returns>Returns the result object</returns>
        public object WaitForCompletionAndThrowOnError()
        {
            // ensure EndCalled is set.
            this.EndCalled = true;

            // only "1" EndXxx call can happen all others should fail w/ an exception.
            if (Interlocked.Increment(ref this.isEndCalledCounter) != 1)
            {
                throw new InvalidOperationException("End operation has already been called");
            }

            object returnObject = this.WaitForCompletion();

            // if we noted an exception, we need to throw it.
            if (this.AsyncException != null)
            {
                throw this.AsyncException;
            }

            return returnObject;
        }

        /// <summary>
        /// The public WaitForCompletion
        /// </summary>
        /// <returns>The Async object resulting from the operation</returns>
        public object WaitForCompletion()
        {
            return this.ProtectedWaitForCompletion();
        }

        /// <summary>
        /// The Dispose pattern implementation.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// A protected method that waits until the async operation completes.
        /// </summary>
        /// <returns>The Async object resulting from the operation</returns>
        protected object ProtectedWaitForCompletion()
        {
            ManualResetEvent currentWaitHandle = null;
            bool createdByMe = false;
            
            bool complete = this.PeekCompleted;

            if (!complete)
            {
                // Not done yet, so wait:
                currentWaitHandle = this.waitHandle;
                if (currentWaitHandle == null)
                {
                    createdByMe = this.LazilyCreateEvent(out currentWaitHandle);
                }
            }

            if (currentWaitHandle != null)
            {
                try
                {
                    currentWaitHandle.WaitOne(Timeout.Infinite, false);
                }
                catch (ObjectDisposedException)
                {
                    // This can occur if this method is called from two different threads.
                    // This possibility is the trade-off for not locking.
                }
                finally
                {
                    // We also want to dispose the event although we can't unless we did wait on it here.
                    if (createdByMe && !this.isUserEvent)
                    {
                        ManualResetEvent oldEvent = this.waitHandle;
                        
                        // put a memory barrier here.
                        Interlocked.CompareExchange<ManualResetEvent>(ref this.waitHandle, null, oldEvent);
                        
                        if (!this.isUserEvent)
                        {
                            oldEvent.Close();
                        }
                    }
                }
            }

            // A race condition exists because InvokeCallback sets intCompletedFlagCounter before resultObject 
            // (so that resultObject can benefit from the synchronization of intCompletedFlagCounter).  
            // Handle that case with a spin-lock.
            while (this.resultObject == DBNull.Value)
            {
                Thread.SpinWait(1);
            }

            return this.resultObject;
        }
        
        /// <summary>
        /// A method for completing the IO with a result
        /// and invoking the user's callback.
        /// Used by derived classes to pass context into an overridden Complete().  Useful
        /// for determining the 'winning' thread in case several may simultaneously call
        /// the equivalent of InvokeCallback().
        /// </summary>
        /// <param name="result">The result object of this AsyncOperation</param>
        /// <param name="userToken">A token object passed to the Complete protected call, optional</param>
        protected void ProtectedInvokeCallback(object result, IntPtr userToken)
        {
            // Critical to disallow DBNull here - it could result in a stuck spinlock in WaitForCompletion.
            if (result == DBNull.Value)
            {
                throw new ArgumentNullException("result");
            }

            // if multiple thread's race to call the callback, one of them should win.
            if (Interlocked.Increment(ref this.isCompletedCounter) == 1)
            {
                // DBNull.Value is used to guarantee that the first caller wins,
                // even if the result was set to null.
                if (this.resultObject == DBNull.Value)
                {
                    this.resultObject = result;
                }

                // Does this need a memory barrier to be sure this thread gets the waitHandle if it's set?  I don't think so
                // because the Interlockeds on intCompletedFlagCounter/waitHandle should serve as the barrier.
                ManualResetEvent asyncEvent = (ManualResetEvent)this.waitHandle;
                if (asyncEvent != null)
                {
                    asyncEvent.Set();
                }

                this.Complete(userToken);
            }
        }

        /// <summary>
        /// MUST NOT BE CALLED DIRECTLY
        /// A protected method that does callback job and it is guaranteed to be called exactly once.
        /// A derived overriding method must call the base class somewhere or the completion is lost.
        /// </summary>
        /// <param name="userToken">An optional token</param>
        protected virtual void Complete(IntPtr userToken)
        {
            if (this.AsyncCallback != null)
            {
                NestedCallOffLoader.Execute((WaitCallback)delegate(object state)
                                            {
                                                try
                                                {
                                                    this.AsyncCallback(this);
                                                }
                                                finally
                                                {
                                                    this.ProtectedCleanup();
                                                }
                                            }, 
                                            null);
            }
        }

        // Custom instance cleanup method.
        // Derived types override this method to release unmanaged resources associated with an IO request.
        protected virtual void ProtectedCleanup()
        {
#if DEBUG
            LazyAsyncResult.pendingResults.Remove(this.index);
#endif
        }

        /// <summary>
        /// the internal version of the Dispose
        /// </summary>
        /// <param name="isDisposed">If Dispose() is calling</param>
        protected virtual void Dispose(bool isDisposed)
        {
            if (isDisposed)
            {
                this.InternalCleanup();
            }
        }

        // Returns true if this call created the event.
        // May return with a null handle.  That means it thought it got one, but it was disposed in the mean time.
        private bool LazilyCreateEvent(out ManualResetEvent newWaitHandle)
        {
            // lazy allocation of the event:
            // if this property is never accessed this object is never created
            newWaitHandle = new ManualResetEvent(false);
            try
            {
                if (Interlocked.CompareExchange<ManualResetEvent>(ref this.waitHandle, newWaitHandle, null) == null)
                {
                    if (this.PeekCompleted)
                    {
                        newWaitHandle.Set();
                    }

                    return true;
                }
                else
                {
                    newWaitHandle.Close();
                    newWaitHandle = this.waitHandle;

                    // There's a chance here that waitHandle became null.  But the only way is if another thread completed
                    // in InternalWaitForCompletion and disposed it.  If we're in InternalWaitForCompletion, we now know
                    // IsCompleted is set, so we can avoid the wait when waitHandle comes back null.  AsyncWaitHandle
                    // will try again in this case.
                    return false;
                }
            }
            catch (Exception)
            {
                // This should be very rare, but doing this will reduce the chance of deadlock.
                this.waitHandle = null;
                if (newWaitHandle != null)
                {
                    newWaitHandle.Close();
                }

                throw;
            }
        }

        // A general interface that is called to release unmanaged resources associated with the class.
        // It completes the result but doesn't do any of the notifications.
        private void InternalCleanup()
        {
            if (this.isCompletedCounter > 0)
            {
                // Set no result so that just in case there are waiters, they don't hang in the spin lock.
                this.resultObject = null;
                this.ProtectedCleanup();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\UnitTest\BestAsyncPractices.cs ===
﻿namespace UnitTest
{
    using System;
    using System.Threading;
    using Wgx.Common.Utilities;

    /// <summary>
    /// In this class we will try to exhibit the best way of writing an Asynchronous Method using LazyAsyncResult
    /// </summary>
    internal class BestAsyncPractices
    {
        public BestAsyncPractices() { }

        /// <summary>
        /// This function will schedule the call to complete on another thread.
        /// </summary>
        public IAsyncResult BeginFoo(string param1, int param2, AsyncCallback callback, Object state)
        {
            LazyAsyncResult lar;
            try
            {
                lar = new LazyAsyncResult(this, state, callback);

                ThreadPool.QueueUserWorkItem((WaitCallback)delegate(Object anonymousState)
                {
                    lar.InvokeCallback(String.Format("{0} and {1}", param1, param2));
                }, null);
            }
            finally
            {
            }

            return lar;
        }

        public string EndFoo(IAsyncResult ar)
        {
            using (LazyAsyncResult lar = LazyAsyncResult.Validate(ar))
            {
                // make sure you check the input correctly.
                return (string)lar.WaitForCompletionAndThrowOnError();
            }
        }
    }


    /// <summary>
    /// This class exhibits an in-thread (synchronous) completing Async operation.
    /// </summary>
    internal class CompletedAsyncPractices
    {
        public CompletedAsyncPractices() { }

        /// <summary>
        /// This function will schedule the call to complete on the same thread.
        /// </summary>
        public IAsyncResult BeginFoo(string param1, int param2, AsyncCallback callback, Object state)
        {
            LazyAsyncResult lar;

            lar = new LazyAsyncResult(this, state, callback);

            lar.InvokeCallback(String.Format("{0} and {1}", param1, param2));

            return lar;
        }

        public string EndFoo(IAsyncResult ar)
        {
            using (LazyAsyncResult lar = LazyAsyncResult.Validate(ar))
            {
                // make sure you check the input correctly.
                return (string)lar.WaitForCompletionAndThrowOnError();
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo\Container.cs ===
﻿using System;
using System.Collections.Generic;
using System.Web;

namespace Wgx.Common.IoCCo
{


    public class Container : Wgx.Common.IoCCo.IContainer
    {
        private static IContainer instance = new Container();
        public static IContainer Instance { get { return instance; } }

        Dictionary<Type, ComponentInfo> serviceRegistry = new Dictionary<Type, ComponentInfo>();

        public T GetComponent<T>()
        {
            return (T)GetComponent(typeof(T));
        }

        public object GetComponent(Type serviceType)
        {
            ComponentInfo componentInfo;
            try
            {
                componentInfo = serviceRegistry[serviceType];
            }
            catch (KeyNotFoundException)
            {
                throw new ServiceNotRegisteredException("Interface '" + serviceType.ToString() + "' was not registered with the IoC container.");
            }

            object component = componentInfo.GetComponent();

            ILocator locator = component as ILocator;

            if (locator != null)
            {
                return locator.LocateComponent();
            }

            return component;
        }



        public IContainer AddService<TService, TComponent>() where TComponent : TService
        {
            Type serviceType = typeof(TService);
            Type componentType = typeof(TComponent);

            return AddService(serviceType, componentType);
        }

        private IContainer AddService(Type serviceType, Type componentType)
        {
            if (serviceRegistry.ContainsKey(serviceType))
            {
                ComponentInfo componentInfo = serviceRegistry[serviceType];
                if (componentInfo.ComponentType == componentType)
                {
                    return this;
                }
            }

            serviceRegistry.Add(serviceType, new ComponentInfo(this, componentType));

            return this;
        }

        public IContainer AddServiceWithLocator<TService, TLocator>() where TLocator : ILocator<TService> where TService : class
        {
            Type serviceType = typeof(TService);
            Type locatorType = typeof(TLocator);

            return AddService(serviceType, locatorType);
        }

        public static void UseLocalContainer(IContainer localContainer)
        {
            instance = localContainer;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo\IContainer.cs ===
﻿using System;

namespace Wgx.Common.IoCCo
{
    public interface IContainer
    {
        IContainer AddService<TService, TComponent>() where TComponent : TService;
        IContainer AddServiceWithLocator<TService, TLocator>()
            where TLocator : ILocator<TService>
            where TService : class;
        T GetComponent<T>();
        object GetComponent(Type serviceType);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\UnitTest\TestLazyAsyncResult.cs ===
﻿namespace UnitTest
{
    using System;
    using System.Threading;

    public class TestLazyAsyncResult
    {
        internal static ManualResetEvent synchObject = new ManualResetEvent(false);

        public static void Run()
        {
            Test_Validpattern1();
            Test_Validpattern2();
            Test_QuestionableButValidPattern1();
            Test_ValidPatternWithASideEffect();
            Test_NestedCallPattern();
        }

        /// <summary>
        /// This section exists to make sure that the test returns after the callback is done.
        /// </summary>
        private static void VerifyCallbackOccuredOrThrow()
        {
            bool fSignalled = TestLazyAsyncResult.synchObject.WaitOne(100000);

            // if we timed out, simply throw an exception.
            if (!fSignalled)
            {
                throw new InvalidOperationException("Async Callback has timed out");
            }
            else
                TestLazyAsyncResult.synchObject.Reset();
        }

        /// <summary>
        /// A typical async call.
        /// </summary>
        private static void Test_Validpattern1()
        {
            BestAsyncPractices bap = new BestAsyncPractices();

            IAsyncResult ar = bap.BeginFoo("what the heck", 5, new AsyncCallback(TestLazyAsyncResult.AGoodAsyncCallback), bap);

            // This call will block until the callback occures.
            // this is a verification call for test purposes, 
            // your usage should not have such a pattern.
            TestLazyAsyncResult.VerifyCallbackOccuredOrThrow();
        }

        private static void AGoodAsyncCallback(IAsyncResult ar)
        {
            BestAsyncPractices bap = (BestAsyncPractices)ar.AsyncState;
            bap.EndFoo(ar);

            TestLazyAsyncResult.synchObject.Set();
        }

        /// <summary>
        /// It is valid to call EndXxx directly and expect the call to block until completion.
        /// This should only be practiced
        ///   1) if you simulate a synch calling pattern by using the async methods.
        ///   2) you are on the UI thread, and would like to get the result on the same thread 
        ///      (there is a better way to do this).
        /// </summary>
        private static void Test_Validpattern2()
        {
            BestAsyncPractices bap = new BestAsyncPractices();

            IAsyncResult ar = bap.BeginFoo("what the heck", 5, null, null);
            bap.EndFoo(ar);
        }

        /// <summary>
        /// Here is a valid but, scorned at pattern:
        /// You don't need to wait on the handle.
        /// </summary>
        private static void Test_QuestionableButValidPattern1()
        {
            BestAsyncPractices bap = new BestAsyncPractices();

            IAsyncResult ar = bap.BeginFoo("something", 54, null, null);
            ar.AsyncWaitHandle.WaitOne();
            bap.EndFoo(ar);
        }

        /// <summary>
        /// In this pattern we simply call another Async operation from the callback
        /// With a bad AsyncResult implementation it would have been possible to get a 
        /// </summary>
        private static void Test_ValidPatternWithASideEffect()
        {
            BestAsyncPractices bap = new BestAsyncPractices();

            IAsyncResult ar = bap.BeginFoo("something", 54, null, null);
            ar.AsyncWaitHandle.WaitOne();
            bap.EndFoo(ar);
        }

        private static string threadName = "original thread";
        private static void Test_NestedCallPattern()
        {
            CompletedAsyncPractices cap = new CompletedAsyncPractices();

            Thread.CurrentThread.Name = TestLazyAsyncResult.threadName;

            IAsyncResult ar = cap.BeginFoo("whatever", 3, new AsyncCallback(TestLazyAsyncResult.RecursiveCallback), cap);

            VerifyCallbackOccuredOrThrow();
        }

        private static void RecursiveCallback(IAsyncResult ar)
        {
            CompletedAsyncPractices cap1 = (CompletedAsyncPractices)ar.AsyncState;
            cap1.EndFoo(ar);

            if (string.Compare(Thread.CurrentThread.Name, TestLazyAsyncResult.threadName, true) == 0)
            {
                CompletedAsyncPractices cap = new CompletedAsyncPractices();
                IAsyncResult ar2 = cap.BeginFoo("whatever", 3, new AsyncCallback(TestLazyAsyncResult.RecursiveCallback), cap);
            }
            else
            {
                // effectively end condition.
                TestLazyAsyncResult.synchObject.Set();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo\ILocator.cs ===
namespace Wgx.Common.IoCCo
{
    public interface ILocator
    {
        object LocateComponent();
    }

    public interface ILocator<TService> : ILocator 
    {
        new TService LocateComponent();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common\Utilities\NestedCallOffloader.cs ===
﻿//------------------------------------------------------------------------------
// <copyright file="NestedCallOffloader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------
namespace Wgx.Common.Utilities
{
    using System;
    using System.Threading;

    /// <summary>
    /// This is to avoid user mistakes when they queue another async op from a callback the completes sync.
    /// It can also be used to off-load any other type of calling pattern where there is a risk of 
    /// indefinite recursive calling and completing one of them on another thread is possible.
    /// </summary>
    public sealed class NestedCallOffLoader
    {
        private const int MaxNestedSyncCompletionCount = 50;

        [ThreadStatic]
        private static NestedCallOffLoader threadContext;

        /// <summary>
        /// Gets the current ThreadStatic NestedCallOffloader.
        /// If one does not exists it it created.
        /// </summary>
        private static NestedCallOffLoader CurrentThreadContext
        {
            get
            {
                NestedCallOffLoader currentThreadContext = threadContext;
                if (currentThreadContext == null)
                {
                    currentThreadContext = new NestedCallOffLoader();
                    threadContext = currentThreadContext;
                }

                return currentThreadContext;
            }
        }

        /// <summary>
        /// Gets or sets counter that tracks the Recurse/Nesting count.
        /// This is the only real-part of this otherwise almost purely static class.
        /// </summary>
        private int NestedIOCount { get; set; }

        /// <summary>
        /// This method either executes the given delegate in-thread or offload's it into a ThreadPool thread 
        /// based on the recursion/nesting count.
        /// If the count is higher than maxNestedSyncCompletionCount it simply offloads it into a TP thread.
        /// Otherwise in-thread execution will be performed.
        /// A bool is returned indicating which.
        /// </summary>
        /// <param name="beginMethod">delegate to be executed.</param>
        /// <param name="state">state needs to be passed, if any</param>
        /// <returns>FALSE when in-thread execution is performed, otherwise true</returns>
        public static bool Execute(WaitCallback beginMethod, object state)
        {
            try
            {
                NestedCallOffLoader.CurrentThreadContext.NestedIOCount++;

                if (NestedCallOffLoader.CurrentThreadContext.NestedIOCount < NestedCallOffLoader.MaxNestedSyncCompletionCount)
                {
                    beginMethod(state);
                    return false;
                }
                else
                {
                    ThreadPool.QueueUserWorkItem((WaitCallback)delegate(object myState)
                                                {
                                                    beginMethod(myState);
                                                }, 
                                                state);

                    return true;
                }
            }
            finally
            {
                NestedCallOffLoader.CurrentThreadContext.NestedIOCount--;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo\PerWebRequestInstanceAttribute.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo
{
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class PerWebRequestInstanceAttribute : Attribute
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo\ComponentInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Globalization;
using System.Web;

namespace Wgx.Common.IoCCo
{
    internal enum LifeCycleMode
    {
        Instance,
        Singleton,
        PerWebRequest
    }

    internal class ComponentInfo
    {
        private IContainer Container { get; set; }
        internal Type ComponentType { get; set; }
        internal ParameterInfo[] ConstructorParameters { get; set; }
        internal LifeCycleMode LifeCycleMode { get; set; }

        private delegate object InstantiatorSignature();
        private delegate object InstantiatorSignatureWithParams(object[] dependencies);
        private InstantiatorSignature InstantiatorDelegate { get; set; }
        private InstantiatorSignatureWithParams InstantiatorDelegateWithParams { get; set; }

        private object[] parameterArray = new object[0];

        internal string ComponentKey { get; private set; }

        private static Dictionary<Type, object> singletonInstances = new Dictionary<Type, object>();
        private static object singletonLock = new object();

        /// <summary>
        /// This constructor does the majority of the work to prepare for object creation later.
        /// Constructor structure is inspected and parameter types are cached. 
        /// The constructor then generates DynamicMethods to instantiate the component with
        /// or without parameters (two cases are hendled separately for clarity and performance).
        /// </summary>
        /// <param name="container">The container is used to resolve dependencies during creation.</param>
        /// <param name="componentType">Type of the component to create the wrapper for.</param>
        internal ComponentInfo(IContainer container, Type componentType)
        {
            this.Container = container;
            this.ComponentType = componentType;

            this.ComponentKey = String.Format(CultureInfo.InvariantCulture, "IoCCo_{0}_Instance", componentType.FullName);

            ConstructorInfo[] constructors = componentType.GetConstructors();

            if (constructors.Length != 1)
            {
                throw new ArgumentException("Components must have one and only one public constructor.", "componentType");
            }

            ConstructorInfo constructor = constructors[0];
            ParameterInfo[] parameters = constructor.GetParameters();

            if (parameters.Length == 0)
            {
                // This is where the magic happens for parameterless construction.
                // A method is emitted and a delegate for it is created. The method simply creates a new instance
                // of the component. Later calls to the delegate are fast.
                // this is all done to avoid using Reflection at creation time (Activator specifically).
                DynamicMethod instantiatorMethod = new DynamicMethod("CreateInstance", componentType, null);
                ILGenerator generator = instantiatorMethod.GetILGenerator();

                // calling the contructor puts a reference to the new onject onto the stack
                generator.Emit(OpCodes.Newobj, constructor);
                // return newly created object reference
                generator.Emit(OpCodes.Ret);

                InstantiatorDelegate = (InstantiatorSignature)instantiatorMethod.CreateDelegate(typeof(InstantiatorSignature));
            }
            else
            {
                InstantiatorDelegate = null;

                // This is where the magic happens for construction with dependencies.
                // A method is emitted and a delegate for it is created. The method expects an array of objects.
                // It then pushes each element of the array onto the stack to be used as parameters to the constructor
                // and calls the constructor of the component. 
                // Since we know parameter count, no loop is necessary and it is unrolled.
                // this is all done to avoid using Reflection at creation time (Activator with parameters 
                // is especially expensive).
                DynamicMethod instantiatorMethod = new DynamicMethod(
                    "CreateInstance_Of_" + componentType.Name,
                    componentType,
                    new Type[] { parameterArray.GetType() },
                    typeof(ComponentInfo));
                ILGenerator generator = instantiatorMethod.GetILGenerator();

                // the loop basicaly outputs 
                //      PUSH argumentArray[0]
                //      PUSH argumentArray[1]
                // etc...
                for (int index = 0; index < parameters.Length; index++)
                {
                    // put reference to the array onto the stack (argument 0)
                    generator.Emit(OpCodes.Ldarg_0);
                    // put next parameter index onto the stack
                    generator.Emit(OpCodes.Ldc_I4, index);
                    // dereference the array (1 back on the stack) element with index on top of the stack
                    generator.Emit(OpCodes.Ldelem_Ref);
                }
                // calling the contructor puts a reference to the new onject onto the stack
                generator.Emit(OpCodes.Newobj, constructor);
                // return newly created object reference
                generator.Emit(OpCodes.Ret);

                this.ConstructorParameters = parameters;
                InstantiatorDelegateWithParams = (InstantiatorSignatureWithParams)instantiatorMethod.CreateDelegate(typeof(InstantiatorSignatureWithParams));
            }

            if (this.HasCustomAttribute<SingletonInstanceAttribute>())
            {
                this.LifeCycleMode = LifeCycleMode.Singleton;
            }
            else if (this.HasCustomAttribute<PerWebRequestInstanceAttribute>())
            {
                this.LifeCycleMode = LifeCycleMode.PerWebRequest;
            }
        }

        private bool HasCustomAttribute<T>() where T : Attribute
        {
            if (ComponentType.GetCustomAttributes(typeof(T), false).Length > 0)
            {
                return true;
            }
            return false;
        }

        private object GetObjectInstance()
        {
            object instance;

            if (InstantiatorDelegate != null)
            {
                return InstantiatorDelegate();
            }

            ParameterInfo[] parameters = ConstructorParameters;
            object[] parameterValues = new object[parameters.Length];
            for (int index = 0; index < parameters.Length; index++)
            {
                parameterValues[index] = Container.GetComponent(parameters[index].ParameterType);
            }
            instance = InstantiatorDelegateWithParams(parameterValues);
            return instance;
        }

        private object GetPerWebRequestInstance()
        {
            if (HttpContext.Current.Items[this.ComponentKey] == null)
            {
                lock (singletonLock)
                {
                    if (HttpContext.Current.Items[this.ComponentKey] == null)
                    {
                        object instance = this.GetObjectInstance();
                        HttpContext.Current.Items[this.ComponentKey] = instance;
                        return instance;
                    }
                }
            }
            return HttpContext.Current.Items[this.ComponentKey];
        }

        private object GetSingletonInstance()
        {
            if (!singletonInstances.ContainsKey(this.ComponentType))
            {
                lock (singletonLock)
                {
                    if (!singletonInstances.ContainsKey(this.ComponentType))
                    {
                        object instance = this.GetObjectInstance();
                        singletonInstances.Add(this.ComponentType, instance);
                        return instance;
                    }
                }
            }
            return singletonInstances[this.ComponentType];
        }

        public object GetComponent()
        {
            if (this.LifeCycleMode == LifeCycleMode.Singleton)
            {
                return GetSingletonInstance();
            }
            else if (this.LifeCycleMode == LifeCycleMode.PerWebRequest)
            {
                return GetPerWebRequestInstance();
            }
            else
            {
                return this.GetObjectInstance();
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo\ServiceNotRegisteredException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo
{
    [global::System.Serializable]
    public class ServiceNotRegisteredException : Exception
    {
        public ServiceNotRegisteredException() { }
        public ServiceNotRegisteredException(string message) : base(message) { }
        public ServiceNotRegisteredException(string message, Exception inner) : base(message, inner) { }
        protected ServiceNotRegisteredException(
          System.Runtime.Serialization.SerializationInfo info,
          System.Runtime.Serialization.StreamingContext context)
            : base(info, context) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo\SingletonInstanceAttribute.cs ===
﻿using System;

namespace Wgx.Common.IoCCo
{
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class SingletonInstanceAttribute : Attribute
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\ContainerTestExtensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Rhino.Mocks;

namespace Wgx.Common.IoCCo
{
    public static class ContainerTestExtensions
    {
        public static T RegisterWithCreateMock<T>(this IContainer container, MockRepository mockery)
        {
            T mock = mockery.StrictMock<T>();
            Expect.Call(container.GetComponent<T>()).Return(mock);
            return mock;
        }

        public static T RegisterWithDynamicMock<T>(this IContainer container, MockRepository mockery) where T : class
        {
            T mock = mockery.DynamicMock<T>();
            SetupResult.For(container.GetComponent<T>()).Return(mock);
            return mock;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\LocatorTests.cs ===
﻿using Microsoft.VisualStudio.TestTools.UnitTesting;
using Wgx.Common.IoCCo.Test.TestServices;

namespace Wgx.Common.IoCCo.Test
{
    [TestClass]
    public class LocatorTests
    {
        [TestMethod]
        public void Container_Allows_Registering_A_Locator_For_Service()
        {
            TestServiceLocator.Called = false;
            TestServiceLocator.ServiceToReturn = new TestServiceComponent();

            Container.Instance.AddServiceWithLocator<ITestService, TestServiceLocator>();
            ITestService component = Container.Instance.GetComponent<ITestService>();

            Assert.IsTrue(TestServiceLocator.Called);
            Assert.AreSame(TestServiceLocator.ServiceToReturn, component);
        }

        [TestMethod]
        public void Adding_Two_Identical_Locators_For_Same_Service_Is_OK()
        {
            Container container = new Container();

            container.AddServiceWithLocator<ITestService, TestServiceLocator>();
            container.AddServiceWithLocator<ITestService, TestServiceLocator>();
           
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\GenericServiceWithDependency.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    public class GenericServiceWithDependency<TDependency> : IServiceWithDependency
    {
        public TDependency Dependency { get; internal set; }

        public GenericServiceWithDependency(TDependency dependency)
        {
            this.Dependency = dependency;
        }
        #region IServiceWithDependency Members

        public ITestService TestService
        {
            get { throw new NotImplementedException(); }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Wgx.Common.IoCCo.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("03dab6b1-50bf-46be-9509-6f5c4ce29f04")]

// Version information for all assemblies is in <root>\Source\build\ZoneVer.cs
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;
using System.Security.Permissions;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Wgx.Common.IoCCo")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("63863858-40b3-49f1-a76d-7d26e60f0bec")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum)]

// Version information for all assemblies is in <root>\Source\build\ZoneVer.cs

[assembly: System.CLSCompliant(true)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\IServiceWithDependency.cs ===
﻿using System;
using System.Text;
using System.Data;
using System.Data.Common;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    public interface IServiceWithDependency
    {
        ITestService TestService { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\ITestService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    public interface ITestService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\IUnknownService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    interface IUnknownService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\ContainerTests.cs ===
﻿using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Wgx.Common.IoCCo.Test.TestServices;
using System.Web;
using System.IO;

namespace Wgx.Common.IoCCo.Test
{
    [TestClass]
    public class ContainerTests
    {
        private readonly int TestCreationCount = 100000;

        [TestMethod]
        public void GetComponent_For_Unregistered_Service_Throws_Helpful_Exception()
        {
            Exception actualException = null;
            try
            {
                ITestService component = container.GetComponent<ITestService>();
            }
            catch (Exception e)
            {
                actualException = e;
            }
            Assert.IsNotNull(actualException);
            Assert.AreEqual(typeof(ServiceNotRegisteredException), actualException.GetType());
            Assert.AreEqual("Interface '" + typeof(ITestService).ToString() + "' was not registered with the IoC container.", actualException.Message);
        }

        private static IContainer GetTestContainer()
        {
            IContainer container = new Container();
            return container;
        }

        IContainer container;
        IContainer anotherContainer;

        [TestInitialize]
        public void SetUp()
        {
            container = GetTestContainer();
            anotherContainer = GetTestContainer();
        }

        [TestCleanup]
        public void CleanUp()
        {
            container = null;
            anotherContainer = null;
        }

        [TestMethod]
        public void GetComponent_Returns_An_Instance_Of_The_Registered_Service()
        {
            container.AddService<ITestService, TestServiceComponent>();

            ITestService component = container.GetComponent<ITestService>();

            Assert.IsInstanceOfType(component, typeof(ITestService));
        }

        [TestMethod]
        public void Components_Marked_As_Singleton_Are_Returned_One_Per_AppDomain()
        {
            container.AddService<ITestService, TestServiceSingletonComponent>();

            ITestService componentOne = container.GetComponent<ITestService>();
            ITestService componentTwo = container.GetComponent<ITestService>();

            Assert.AreSame(componentOne, componentTwo);
        }

        [TestMethod]
        public void Singleton_Instances_From_Different_Containers_Are_The_Same()
        {
            container.AddService<ITestService, TestServiceSingletonComponent>();
            anotherContainer.AddService<ITestService, TestServiceSingletonComponent>();

            ITestService componentOne = container.GetComponent<ITestService>();
            ITestService componentTwo = anotherContainer.GetComponent<ITestService>();

            Assert.AreSame(componentOne, componentTwo);
        }

        [TestMethod]
        public void Constructor_Parameters_That_Are_Services_Are_Mapped_Correctly()
        {
            container
                .AddService<ITestService, TestServiceComponent>()
                .AddService<IServiceWithDependency, TestServiceWithDependency>();

            IServiceWithDependency component = container.GetComponent<IServiceWithDependency>();

            Assert.IsInstanceOfType(component.TestService, typeof(TestServiceComponent));
        }

        [TestMethod]
        public void NonGeneric_GetComponent_Returns_An_Instance_Of_The_Registered_Service()
        {
            container.AddService<ITestService, TestServiceComponent>();

            ITestService component = (ITestService)container.GetComponent(typeof(ITestService));

            Assert.IsInstanceOfType(component, typeof(ITestService));
        }

        [TestMethod]
        public void AddService_Returns_Container_Itself()
        {
            IContainer returnContainer = container.AddService<ITestService, TestServiceSingletonComponent>();

            Assert.AreSame(container, returnContainer);
        }

        [TestMethod]
        public void Getting_Component_With_Missing_Dependency_Throws()
        {
            Exception actualException = null;
            container.AddService<IServiceWithDependency, TestServiceWithDependency>();
            try
            {
                container.GetComponent<IServiceWithDependency>();
            }
            catch (Exception e)
            {
                actualException = e;
            }
            Assert.IsNotNull(actualException);
            Assert.AreEqual(typeof(ServiceNotRegisteredException), actualException.GetType());
            Assert.AreEqual("Interface '" + typeof(ITestService).ToString() + "' was not registered with the IoC container.", actualException.Message);
        }

        [TestMethod]
        public void Adding_Two_Same_Implementations_Of_Same_Service_Is_OK()
        {
            container
                .AddService<ITestService, TestServiceComponent>()
                .AddService<ITestService, TestServiceComponent>();
        }


        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void Adding_Two_Different_Implementations_Of_Same_Service_Throws()
        {
            container
                .AddService<ITestService, TestServiceComponent>()
                .AddService<ITestService, TestPerWebRequestComponent>();
        }

        [TestMethod]
        public void Time_Container_Creations()
        {
            container.AddService<ITestService, TestServiceComponent>();

            for (int i = 0; i < TestCreationCount; i++)
            {
                container.GetComponent<ITestService>();
            }
        }

        [TestMethod]
        public void Time_Container_NonGeneric_Creations()
        {
            container.AddService<ITestService, TestServiceComponent>();

            for (int i = 0; i < TestCreationCount; i++)
            {
                ITestService s = (ITestService)container.GetComponent(typeof(ITestService));
            }
        }

        [TestMethod]
        public void Time_Container_NonGeneric_With_Dependency_Creations()
        {
            container.AddService<ITestService, TestServiceComponent>();
            container.AddService<IServiceWithDependency, TestServiceWithDependency>();

            for (int i = 0; i < TestCreationCount; i++)
            {
                container.GetComponent(typeof(IServiceWithDependency));
            }
        }

        [TestMethod]
        public void Time_Activator_Instantiations()
        {
            for (int i = 0; i < TestCreationCount; i++)
            {
                TestServiceComponent component = (TestServiceComponent)Activator.CreateInstance(typeof(TestServiceComponent));
            }
        }

        [TestMethod]
        public void Time_Direct_Instantiations()
        {
            for (int i = 0; i < TestCreationCount; i++)
            {
                new TestServiceComponent();
            }
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException))]
        public void Adding_A_Component_With_More_Than_One_Constrctor_Throws()
        {
            container.AddService<ITestService, TestServiceMultiConstructorComponent>();
        }

        [TestMethod]
        public void Adding_A_Component_With_One_Public_Constrctor_Works()
        {
            container.AddService<ITestService, TestServiceMultiConstructorComponentTwo>();
        }

        [TestMethod]
        public void UseLocal_Overrides_The_Instance()
        {
            IContainer container = Container.Instance;
            IContainer localContainer = new Container();

            Container.UseLocalContainer(localContainer);

            Assert.AreSame(localContainer, Container.Instance);
        }

        [TestMethod]
        public void Generic_Parameter_Inhjections_Are_Supported()
        {
            container.AddService<ITestService, TestServiceComponent>();
            container.AddService<IServiceWithDependency, GenericServiceWithDependency<ITestService>>();

            IServiceWithDependency component = container.GetComponent<IServiceWithDependency>();

            Assert.IsNotNull(((GenericServiceWithDependency<ITestService>)component).Dependency);
        }

        [TestMethod]
        public void Components_Marked_PerWebRequest_Are_Instantiated_Properly()
        {
            container.AddService<ITestService, TestPerWebRequestComponent>();

            HttpContext context = new HttpContext(new HttpRequest("", "http://localhost", ""), new HttpResponse(new StringWriter()));
            HttpContext.Current = context;

            ITestService component1 = container.GetComponent<ITestService>();
            ITestService component2 = container.GetComponent<ITestService>();

            Assert.AreSame(component1, component2);

            context = new HttpContext(new HttpRequest("", "http://localhost", ""), new HttpResponse(new StringWriter()));
            HttpContext.Current = context;

            component2 = container.GetComponent<ITestService>();

            Assert.AreNotSame(component1, component2);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\TestServiceLocator.cs ===
using System.Collections.Generic;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    public class TestServiceLocator : ILocator<ITestService>
    {
        public static bool Called { get; set; }
        public static ITestService ServiceToReturn { get; set; }

        public ITestService LocateComponent()
        {
            Called = true;

            return ServiceToReturn;
        }

        object ILocator.LocateComponent()
        {
            Called = true;

            return ServiceToReturn;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\TestPerWebRequestComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    [PerWebRequestInstance]
    public class TestPerWebRequestComponent : ITestService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\TestServiceMultiConstructorComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    public class TestServiceMultiConstructorComponent : ITestService
    {
        public TestServiceMultiConstructorComponent()
        {
        }

        public TestServiceMultiConstructorComponent(string test)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\TestServiceComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    public class TestServiceComponent : ITestService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\TestServiceSingletonComponent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    [SingletonInstance]
    public class TestServiceSingletonComponent : ITestService
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\TestServiceMultiConstructorComponentTwo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    public class TestServiceMultiConstructorComponentTwo : ITestService
    {
        public TestServiceMultiConstructorComponentTwo()
        {
        }

        private TestServiceMultiConstructorComponentTwo(string test)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\AssemblyInfo.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="AssemblyInfo.cs" company="Microsoft" author="Atin Jain">
// Copyright © .  All rights reserved.
// </copyright>
// <summary>Assembly information file</summary>
//-------------------------------------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Wgx.Services.Common")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx", Scope = "namespace", Target = "Wgx.Services.Common")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Wgx.Services.Common")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Common.IoCCo.Test\TestServices\TestServiceWithDependency.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Wgx.Common.IoCCo.Test.TestServices
{
    public class TestServiceWithDependency : IServiceWithDependency
    {
        public ITestService TestService { get; private set; }

        public TestServiceWithDependency(ITestService testService)
        {
            TestService = testService;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\CompletedAsyncResult.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="CompletedAsyncResult.cs" company="Microsoft" author="">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>IAsyncResult implementation</summary>
//-------------------------------------------------------------------------------------------------
namespace Wgx.Services.Common
{
    using System;
    using System.Threading;

    /// <summary>
    /// Async result implmentation
    /// </summary>
    public class CompletedAsyncResult : IAsyncResult
    {
        /// <summary>
        /// async state
        /// </summary>
        private object state;
        private object secondaryState;

        /// <summary>
        /// Initializes a new instance of the CompletedAsyncResult class.
        /// </summary>
        /// <param name="callback">passed data</param>
        /// <param name="state">async state object</param>
        public CompletedAsyncResult(AsyncCallback callback, object state)
        {
            this.state = state;
            this.secondaryState = null;

            if (callback != null)
            {
                callback(this);
            }
        }

        public CompletedAsyncResult(AsyncCallback callback, object state, object secondaryState)
        {
            this.state = state;
            this.secondaryState = secondaryState;

            if (callback != null)
            {
                callback(this);
            }
        }

        /// <summary>
        /// Gets async state
        /// </summary>
        public object AsyncState
        {
            get { return this.state; }
        }

        public object SecondaryAsyncState
        {
            get { return this.secondaryState; }
        }

        /// <summary>
        /// Gets wait handle, but not implemented
        /// </summary>
        public WaitHandle AsyncWaitHandle
        {
            get { throw new NotImplementedException(); }
        }

        /// <summary>
        /// Gets a value indicating whether operation has completed Synchronously
        /// </summary>
        public bool CompletedSynchronously
        {
            get { return true; }
        }

        /// <summary>
        /// Gets a value indicating whether task is completed
        /// </summary>
        public bool IsCompleted
        {
            get { return true; }
        }

        /// <summary>
        /// end part of async method
        /// </summary>
        /// <param name="result">async result type object</param>
        public static void End(IAsyncResult result)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\WcfErrorHandlerServiceBehavior.cs ===
﻿namespace Wgx.Services.Common
{
    using System;
    using System.Collections.ObjectModel;
    using System.ServiceModel;
    using System.ServiceModel.Channels;
    using System.ServiceModel.Configuration;
    using System.ServiceModel.Description;
    using System.ServiceModel.Dispatcher;

    /// <summary>
    /// The bridge class that instantiates the behavior instance.
    /// </summary>
    public class WcfErrorHandlerServiceBehavior : IServiceBehavior
    {
        /// <summary>
        /// Initializes a new instance of the WcfErrorHandlerServiceBehavior class.
        /// </summary>
        public WcfErrorHandlerServiceBehavior()
        {
        }

        /// <summary>
        /// Adds binding parameters
        /// </summary>
        /// <param name="serviceDescription">The service Description</param>
        /// <param name="serviceHostBase">The service Host Base</param>
        /// <param name="endpoints">The Endpoint structure</param>
        /// <param name="bindingParameters">The binding parameters</param>
        public void AddBindingParameters(
                        ServiceDescription serviceDescription,
                        ServiceHostBase serviceHostBase,
                        Collection<ServiceEndpoint> endpoints,
                        BindingParameterCollection bindingParameters)
        {
        }

        /// <summary>
        /// Returns a service object.
        /// </summary>
        /// <param name="serviceType">The service Type</param>
        /// <returns>The actual behavior interface</returns>
        public object GetService(Type serviceType)
        {
            if (serviceType == typeof(IErrorHandler) || serviceType == typeof(WcfErrorHandler))
            {
                return WcfErrorHandler.Instance;
            }

            throw new System.InvalidOperationException();
        }

        /// <summary>
        /// Apply a Dispatch Behavior
        /// </summary>
        /// <param name="serviceDescription">The Service Description</param>
        /// <param name="serviceHostBase">The Service Host Base</param>
        public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
            IErrorHandler errorHandler = WcfErrorHandler.Instance;

            foreach (ChannelDispatcherBase cdb in serviceHostBase.ChannelDispatchers)
            {
                ChannelDispatcher cd = cdb as ChannelDispatcher;

                if (cd != null)
                {
                    cd.ErrorHandlers.Add(errorHandler);
                }
            }
        }

        /// <summary>
        /// Validates the description and service host 
        /// </summary>
        /// <param name="serviceDescription">Service Description</param>
        /// <param name="serviceHostBase">Service Host Base</param>
        public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase)
        {
        }
    }

    /// <summary>
    /// The Class factory for WcfErrorHandler.
    /// </summary>
    public class ErrorHandlerElement : BehaviorExtensionElement
    {
        /// <summary>
        /// Gets the Type of the behavior, in this case the type of WcfErrorHandler
        /// </summary>
        public override Type BehaviorType
        {
            get
            {
                return typeof(WcfErrorHandlerServiceBehavior);
            }
        }

        /// <summary>
        /// Creates the behavior object, in this case the WcfErrorHandler
        /// </summary>
        /// <returns>A WcfErrorHandler object</returns>
        protected override object CreateBehavior()
        {
            return new WcfErrorHandlerServiceBehavior();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\WcfErrorHandler.cs ===
﻿// <copyright file="WcfErrorHandler.cs" company="Microsoft" author="savasg">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>Defines the WcfErrorHandler type.</summary>
namespace Wgx.Services.Common
{
    using System;
    using System.ServiceModel;
    using System.ServiceModel.Channels;
    using System.ServiceModel.Dispatcher;
    using System.ServiceModel.Web;

    /// <summary>
    /// The IErrorHandler implementation for services.
    /// </summary>
    public sealed class WcfErrorHandler : IErrorHandler
    {
        /// <summary>
        /// The class wide lock object for any synchronization work.
        /// </summary>
        public const string OperationContextKey = "OperationContextKey";
        public const string WebOperationContextKey = "WebOperationContextKey";

        private static readonly object lockObject = new object();

        /// <summary>
        /// The Singleton object
        /// </summary>
        private static WcfErrorHandler instance;

        public event EventHandler<WcfHandleErrorEventArgs> OnHandleError;

        public event EventHandler<WcfProvideFaultEventArgs> OnProvideFault;

        /// <summary>
        /// Gets the Singleton Instance object.
        /// </summary>
        public static WcfErrorHandler Instance
        {
            get
            {
                if (instance == null)
                {
                    lock (WcfErrorHandler.lockObject)
                    {
                        instance = new WcfErrorHandler();
                    }
                }

                return instance;
            }
        }

        /// <summary>
        /// The public IErrorHandler.HandleError interface method 
        /// This method is a prime place to log stuff.
        /// </summary>
        /// <param name="error">The exception captured by the Dispatcher</param>
        /// <returns>return true if WCF should not abort the session (if there is one)</returns>
        bool IErrorHandler.HandleError(Exception error)
        {
            Console.WriteLine("HandleError");

            EventHandler<WcfHandleErrorEventArgs> temp = this.OnHandleError;

            if (temp != null)
            {
                WcfHandleErrorEventArgs args = new WcfHandleErrorEventArgs();
                args.Exception = error;
                args.OperationContext = FetchOperationContext(error);

                temp(this, args);

                return args.DoNotAbortSession;
            }

            return false;
        }

        /// <summary>
        /// This method gives a last chance spot to convert
        /// </summary>
        /// <param name="error">The Exception captured during the service</param>
        /// <param name="version">The Message Version</param>
        /// <param name="fault">returning a fault object</param>
        void IErrorHandler.ProvideFault(Exception error, MessageVersion version, ref Message fault)
        {
            Console.WriteLine("ProvideFault");

            EventHandler<WcfProvideFaultEventArgs> temp = this.OnProvideFault;

            if (temp != null)
            {
                WcfProvideFaultEventArgs args = new WcfProvideFaultEventArgs();
                args.Exception = error;
                args.OperationContext = FetchOperationContext(error);
                args.WebOperationContext = FetchWebOperationContext(error);
                args.MessageVersion = version;
                args.Message = fault;

                temp(this, args);

                // if one is set, return the Fault Message
                fault = args.Message;
            }
        }

        private static OperationContext FetchOperationContext(Exception error)
        {
            if (OperationContext.Current == null)
            {
                if (error.Data.Contains(WcfErrorHandler.OperationContextKey))
                {
                    return (OperationContext)error.Data[WcfErrorHandler.OperationContextKey];
                }

                return null;
            }

            return OperationContext.Current;
        }

        private static WebOperationContext FetchWebOperationContext(Exception error)
        {
            if (WebOperationContext.Current == null)
            {
                if (error.Data.Contains(WcfErrorHandler.WebOperationContextKey))
                {
                    return (WebOperationContext)error.Data[WcfErrorHandler.WebOperationContextKey];
                }

                return null;
            }

            return WebOperationContext.Current;
        }
    }

    /// <summary>
    /// Arguments for the callback delegate.
    /// </summary>
    public class WcfErrorEventArgs : EventArgs
    {
        public Exception Exception { get; internal set; }

        public OperationContext OperationContext { get; internal set; }

        public WebOperationContext WebOperationContext { get; internal set; }
    }

    public class WcfHandleErrorEventArgs : WcfErrorEventArgs
    {
        public bool DoNotAbortSession { get; set; }
    }

    public class WcfProvideFaultEventArgs : WcfErrorEventArgs
    {
        public FaultException FaultException { get; set; }

        public Message Message { get; set; }

        public MessageVersion MessageVersion { get; internal set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\ServiceUnitTest\Program.cs ===
﻿namespace ServiceUnitTest
{
    using System;
    using System.ServiceModel;

    class Program
    {
        public static void Main()
        {
            using (ServiceHost host = new ServiceHost(typeof(TestService)))
            {
                host.Open();
                Console.WriteLine("Service Has Started, press enter to quit>");
                Console.ReadLine();
                host.Close();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\ServiceUnitTest\LogMessages.cs ===
﻿namespace ServiceUnitTest
{
    using Wgx.Services.Monitoring;
    using System.Diagnostics;

    // This class implements all the core multiplayer events
    [EventCategory(MessageIdBase = 10000, IncrementAmount = 10)]
    public static class LogMessages
    {
        public static void Initialize(string eventSource)
        {
            // Initialize Event Source
            LogMessages.MultiplayerTraceSource = new WgxTraceSource(eventSource);
            LogMessages.Events = LogMessages.MultiplayerTraceSource.GetEventsCollection(typeof(LogMessages));
        }

        public static EventsCollection Events { get; private set; }

        private static WgxTraceSource MultiplayerTraceSource { get; set; }

        // Well known Events - the Message Ids for these events are known to Ops (so the message Ids are fixed)
        [Event(Message = "Caught an Exception: {0}", TraceEventType = TraceEventType.Error)]
        public static int ExceptionMessage = 0;

        // Well known Events - the Message Ids for these events are known to Ops (so the message Ids are fixed)
        [Event(TraceEventType = TraceEventType.Verbose)]
        public static int VerboseMessage = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\ActiveMonitoring\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\ServiceUnitTest\ITestService.cs ===
﻿namespace ServiceUnitTest
{
    using System;
    using System.ServiceModel;

    [ServiceContract]
    public interface ITestService
    {
        [OperationContract(AsyncPattern = true)]
        IAsyncResult BeginHelloWorldAsync(AsyncCallback callback, object asyncState);

        string EndHelloWorldAsync(IAsyncResult ar);

        [OperationContract]
        string HelloWorldSync();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\ServiceUnitTest\TestPerfCounters.cs ===
﻿namespace ServiceUnitTest
{
    using Wgx.Services.Monitoring;
    using System.Diagnostics;

    [PerformanceCategory(CategoryName = "Test.MyPerfCounters")]
    public sealed class TestPerfCounters
    {
        private const string myName = "MyPerfCounters";

        public static string Name
        {
            get
            {
                return TestPerfCounters.myName;
            }
        }

        public static void Initialize()
        {
            TestPerfCounters.Counters = PerformanceCounters.GetPerformanceCounters(typeof(TestPerfCounters), TestPerfCounters.Name);            
        }

        public static PerformanceCounterCollection Counters { get; private set; }

        [PerformanceCounter(CounterName = "Exceptions /sec",
                            CounterType = PerformanceCounterType.RateOfCountsPerSecond32,
                            CounterDescription = "Some obscure Rate Descriptor.")]
        public static int IOExceptions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\WcfAsyncHttpModule.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="WcfAsyncHttpModule.cs" company="Microsoft" author="">
// Copyright (c) .  All rights reserved.
// </copyright>
// <summary>HTTP Module to implement async behaviour in WCF.</summary>
//-------------------------------------------------------------------------------------------------
namespace Wgx.Services.Common
{
    using System;
    using System.Reflection;
    using System.Security;
    using System.ServiceModel;
    using System.Web;

    /// <summary>
    /// WCF Async HTTP Module
    /// </summary>
    public class WcfAsyncHttpModule : IHttpModule
    {
        /// <summary>
        /// begin event handler
        /// </summary>
        private static BeginEventHandler beginEventHandler;
        
        /// <summary>
        /// end event handler
        /// </summary>
        private static EndEventHandler endEventHandler;
        
        /// <summary>
        /// check to see if initialized
        /// </summary>
        private static MethodInfo safeEnsureInitialized;
        
        /// <summary>
        /// to invoke method for checking extension
        /// </summary>
        private static MethodInfo getExtensionSupported;
        
        /// <summary>
        /// to invoke actual method
        /// </summary>
        private static ConstructorInfo hostedHttpRequestAsyncResult;
        
        /// <summary>
        /// to complete process
        /// </summary>
        private static MethodInfo hostedHttpRequestAsyncResultEnd;
        
        /// <summary>
        /// to retrieve method type of an assembly
        /// </summary>
        private static Type hostedHttpRequestAsyncResultType;

        /// <summary>
        /// indicate if module is enabled
        /// </summary>
        private static bool disabled;

        /// <summary>
        /// begin part of async invokation
        /// </summary>
        /// <param name="sender">sender object</param>
        /// <param name="e">passed argument</param>
        /// <param name="callback">callback object</param>
        /// <param name="extraData">async state</param>
        /// <returns>async result</returns>
        public static IAsyncResult BeginProcessRequest(object sender, EventArgs e, AsyncCallback callback, object extraData)
        {
            if (WcfAsyncHttpModule.disabled)
            {
                return new CompletedAsyncResult(callback, extraData);
            }

            try
            {
                safeEnsureInitialized.Invoke(null, null);
            }
            catch (SecurityException)
            {
                WcfAsyncHttpModule.disabled = true;
                return new CompletedAsyncResult(callback, extraData);
            }

            if (ServiceHostingEnvironment.AspNetCompatibilityEnabled)
            {
                return new CompletedAsyncResult(callback, extraData);
            }

            // Check to see whether the extension is supported by WCF.
            HttpApplication application = (HttpApplication)sender;
            string extension = System.IO.Path.GetExtension(application.Request.FilePath);
            if (extension == null || !(bool)getExtensionSupported.Invoke(null, new object[] { extension }))
            {
                return new CompletedAsyncResult(callback, extraData);
            }

            return (IAsyncResult)hostedHttpRequestAsyncResult.Invoke(new object[] { application, false, callback, extraData });
        }

        /// <summary>
        /// completion of method
        /// </summary>
        /// <param name="ar">async result object</param>
        public static void EndProcessRequest(IAsyncResult ar)
        {
            if (ar is CompletedAsyncResult)
            {
                CompletedAsyncResult.End(ar);
            }
            else
            {
                hostedHttpRequestAsyncResultEnd.Invoke(null, new object[] { ar });
            }
        }

        /// <summary>
        /// cleanup method
        /// </summary>
        public void Dispose()
        {
        }

        /// <summary>
        /// HTTP Module init method
        /// </summary>
        /// <param name="context">HTTP Application context</param>
        public void Init(HttpApplication context)
        {
            if (WcfAsyncHttpModule.safeEnsureInitialized == null)
            {
                safeEnsureInitialized = typeof(ServiceHostingEnvironment).GetMethod("SafeEnsureInitialized", BindingFlags.NonPublic | BindingFlags.Static);
            }

            if (WcfAsyncHttpModule.getExtensionSupported == null)
            {
                getExtensionSupported = typeof(ServiceHostingEnvironment).GetMethod("GetExtensionSupported", BindingFlags.NonPublic | BindingFlags.Static);
            }

            if (hostedHttpRequestAsyncResultType == null)
            {
                hostedHttpRequestAsyncResultType = typeof(ServiceHostingEnvironment).Assembly.GetType("System.ServiceModel.Activation.HostedHttpRequestAsyncResult");
            }

            if (WcfAsyncHttpModule.hostedHttpRequestAsyncResult == null)
            {
                hostedHttpRequestAsyncResult = hostedHttpRequestAsyncResultType.GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public, null, new Type[] { typeof(HttpApplication), typeof(bool), typeof(AsyncCallback), typeof(object) }, null);
            }

            if (WcfAsyncHttpModule.hostedHttpRequestAsyncResultEnd == null)
            {
                hostedHttpRequestAsyncResultEnd = hostedHttpRequestAsyncResultType.GetMethod("End", BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Public);
            }

            if (WcfAsyncHttpModule.beginEventHandler == null)
            {
                WcfAsyncHttpModule.beginEventHandler = new BeginEventHandler(BeginProcessRequest);
            }

            if (WcfAsyncHttpModule.endEventHandler == null)
            {
                WcfAsyncHttpModule.endEventHandler = new EndEventHandler(EndProcessRequest);
            }

            context.AddOnPostAuthenticateRequestAsync(
                WcfAsyncHttpModule.beginEventHandler,
                WcfAsyncHttpModule.endEventHandler);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\ServiceUnitTest\TestService.cs ===
﻿namespace ServiceUnitTest
{
    using System;
    using System.ServiceModel;
    using System.ServiceModel.Channels;
    using System.Threading;
    using Wgx.Common.Utilities;
    using Wgx.Services.Common;
    using Wgx.Services.Monitoring;
    
    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Multiple, InstanceContextMode = InstanceContextMode.Single)]
    public class TestService : ITestService
    {
        private const string HelloWorld = "HelloWorld";

        public TestService()
        {
            Console.WriteLine("TestService::Constructor");
            WcfErrorHandler.Instance.OnHandleError += new EventHandler<WcfHandleErrorEventArgs>(Instance_OnHandleError);
            WcfErrorHandler.Instance.OnProvideFault += new EventHandler<WcfProvideFaultEventArgs>(Instance_OnProvideFault);
            LogMessages.Initialize("TestService");
            try
            {
                TestPerfCounters.Initialize();
            }
            catch (InvalidOperationException)
            {
            }
        }

        // Convert the exception to a Fault Message that you want conveyed up the stream.
        void Instance_OnProvideFault(object sender, WcfProvideFaultEventArgs e)
        {
            FaultException<int> faultException = new FaultException<int>(3);
            MessageFault messageFault = faultException.CreateMessageFault();
            e.Message = Message.CreateMessage(e.MessageVersion, messageFault, faultException.Action);
        }

        // typically just log your error on this callback 
        // and simply abort the session;
        void Instance_OnHandleError(object sender, WcfHandleErrorEventArgs e)
        {
            //Console.WriteLine(e.Exception.ToString());
            e.DoNotAbortSession = false;

            LogMessages.Events.TraceEvent(LogMessages.ExceptionMessage, e.Exception.ToString());
            TestPerfCounters.Counters.SafeIncrement(TestPerfCounters.IOExceptions);
        }
        
        public IAsyncResult BeginHelloWorldAsync(AsyncCallback callback, object asyncState)
        {
            Console.WriteLine("BeginHelloWorldAsync");
            LazyAsyncResult lar = new LazyAsyncResult(this, asyncState, callback);

            try
            {
                this.ThrowWhenNeeded(true);
            }
            catch (Exception ex)
            {
                ex.Data.Add(WcfErrorHandler.OperationContextKey, OperationContext.Current);
                throw;
            }

            ThreadPool.QueueUserWorkItem(
                             delegate(object state)
                             {
                                 lar.InvokeCallback(TestService.HelloWorld);
                             }, 
                             null);

            return lar;
        }

        public string EndHelloWorldAsync(IAsyncResult ar)
        {
            Console.WriteLine("EndHelloWorldAsync");
            return (ar as LazyAsyncResult).Result as string;
        }

        public string HelloWorldSync()
        {
            LogMessages.Events.TraceEvent(LogMessages.ExceptionMessage, "HelloWorldSync");
            LogMessages.Events.TraceEvent(LogMessages.VerboseMessage);
            LogMessages.Events.TraceEvent(LogMessages.VerboseMessage, "MyHelloWorldSync");

            this.ThrowWhenNeeded(true);

            return TestService.HelloWorld;
        }

        private void ThrowWhenNeeded(bool isNeeded)
        {
            if (isNeeded)
            {
                throw new InvalidOperationException();
                //throw new OutOfMemoryException();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\SharedSource\Wgx.Services.Common\ServiceUnitTest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ServiceUnitTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\ActiveMonitoring\ActiveMonitoringManager\ActiveMonitoringProject.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="ActiveMonitoringProject.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>ActiveMonitoringProject class definition</summary>
//-------------------------------------------------------------------------------------------------
namespace ActiveMonitoringManager
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// ActiveMonitoringProject class definition
    /// </summary>
    public class ActiveMonitoringProject
    {
        /// <summary>
        /// Gets or sets the name of the Test Project
        /// </summary>
        public string Project { get; set; }

        /// <summary>
        /// Gets or sets the Target from where the Test Project's binary files are to be executed
        /// </summary>
        public string Target { get; set; }

        /// <summary>
        /// Gets or sets the test configuration file
        /// </summary>
        public string TestConfigFile { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\ActiveMonitoring\ActiveMonitoringManager\ActiveMonitoringLog.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="ActiveMonitoringLog.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>ActiveMonitoringLog class that implements trace log</summary>
//-------------------------------------------------------------------------------------------------
namespace ActiveMonitoringManager
{
    #region namespaces
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Text;
    #endregion

    #region enums
    /// <summary>
    /// Trace log level
    /// </summary>
    public enum LogLevel
    {
        /// <summary>
        /// Logged message indicates error occurrence
        /// </summary>
        Error,

        /// <summary>
        /// Logged message is for informational purpose
        /// </summary>
        Info,

        /// <summary>
        /// Logged message is verbose and for informational purpose
        /// </summary>
        Verbose
    }
    #endregion

    /// <summary>
    /// Log class definiton (for the trace log)
    /// </summary>
    public static class ActiveMonitoringLog
    {
        #region private fields
        /// <summary>
        /// Field to contain the directory to the trace log file
        /// </summary>
        private static string logDirectory;

        /// <summary>
        /// Field to contain the name of the trace log file
        /// </summary>
        private static string filePath;

        /// <summary>
        /// Field to contain the file stream of the trace log file
        /// </summary>
        private static Stream fs;
        #endregion

        #region static constructor
        /// <summary>
        /// Initializes static members of the ActiveMonitoringLog class
        /// </summary>
        static ActiveMonitoringLog()
        {
            LogToFile = true;
        }
        #endregion

        #region public properties
        /// <summary>
        /// Gets or sets a value indicating whether to write trace log to a file or not
        /// </summary>
        public static bool LogToFile
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the trace log filepath
        /// </summary>
        public static string LogFilePath
        {
            get
            {
                return filePath;
            }
        }
        #endregion

        #region public methods
        /// <summary>
        /// Write the given message as an informational message to the trace log
        /// </summary>
        /// <param name="message">The message to write to the trace log</param>
        public static void WriteLine(string message)
        {
            WriteLine(message, LogLevel.Info);
        }

        /// <summary>
        /// Write the given message to the trace log file
        /// </summary>
        /// <param name="message">The message to write to the trace log</param>
        /// <param name="level">The level or attribute of the message</param>
        public static void WriteLine(string message, LogLevel level)
        {
            if (level == LogLevel.Verbose)
            {
                Debug.WriteLine(message);
                return;
            }

            if (LogToFile)
            {
                logDirectory = ActiveMonitoringRun.LogDirectory;

                if (!Directory.Exists(logDirectory))
                {
                    try
                    {
                        Directory.CreateDirectory(logDirectory);
                    }
                    catch (IOException ex)
                    {
                        WriteToConsole(string.Empty);
                        WriteToConsole(ex.Message);
                        WriteToConsole(message);
                    }
                }
                else
                {
                    filePath = logDirectory + "\\" + ActiveMonitoringRun.LogFileName + DateTime.Now.ToString("yyyyMMdd") + ".log";

                    if (!File.Exists(filePath))
                    {
                        try
                        {
                            fs = File.Create(filePath);
                            WriteToFile(message);
                        }
                        catch (IOException ex)
                        {
                            WriteToConsole(string.Empty);
                            WriteToConsole(ex.Message);
                            WriteToConsole(message);
                        }
                    }
                    else
                    {
                        try
                        {
                            fs = File.Open(filePath, FileMode.Append);
                            WriteToFile(message);
                        }
                        catch (IOException ex)
                        {
                            WriteToConsole(string.Empty);
                            WriteToConsole(ex.Message);
                            WriteToConsole(message);
                        }
                    }
                }
            }
            else
            {
                WriteToConsole(message);
            }
        }

        /// <summary>
        /// Writing exception to the trace log
        /// </summary>
        /// <param name="e">The exception to write to the trace log</param>
        public static void LogException(Exception e)
        {
            ActiveMonitoringLog.WriteLine("----------------------------------------------", LogLevel.Error);
            ActiveMonitoringLog.WriteLine("Exception! Type: " + e.GetType().ToString(), LogLevel.Error);
            ActiveMonitoringLog.WriteLine("Message: " + e.Message, LogLevel.Error);
            ActiveMonitoringLog.WriteLine("----------------------------------------------", LogLevel.Error);
            ActiveMonitoringLog.WriteLine("StackTrace: " + e.StackTrace, LogLevel.Error);
            ActiveMonitoringLog.WriteLine("----------------------------------------------", LogLevel.Error);
            ActiveMonitoringLog.WriteLine("InnerException: " + e.InnerException, LogLevel.Error);
            ActiveMonitoringLog.WriteLine("----------------------------------------------", LogLevel.Error);
            ActiveMonitoringLog.WriteLine("Source: " + e.Source, LogLevel.Error);
            ActiveMonitoringLog.WriteLine("----------------------------------------------", LogLevel.Error);
        }

        /// <summary>
        /// Writing to event logger
        /// </summary>
        /// <param name="message">Message to write to the event log</param>
        /// <param name="type">Type of event log to write to</param>
        public static void WriteToEventLog(string message, EventLogEntryType type)
        {
            if (!EventLog.SourceExists("ActiveMonitoringApp"))
            {
                EventLog.CreateEventSource("ActiveMonitoringApp", "Application");
            }

            EventLog.WriteEntry("ActiveMonitoringApp", message, type);
        }

        #endregion

        #region private methods
        /// <summary>
        /// Write the message to the trace file
        /// </summary>
        /// <param name="message">The message to write to the trace log</param>
        private static void WriteToFile(string message)
        {
            TextWriterTraceListener myTextListener = new TextWriterTraceListener(fs);

            Trace.Listeners.Add(myTextListener);

            Trace.WriteLine(DateTime.Now.ToString("hh:mm:ss.ffff") + ": " + message);

            Trace.Flush();
            Trace.Listeners.Remove(myTextListener);
            myTextListener.Close();
            Trace.Close();
            fs.Close();
        }

        /// <summary>
        /// Write the message to the console
        /// </summary>
        /// <param name="message">The message to write to the console</param>
        private static void WriteToConsole(string message)
        {
            TextWriterTraceListener consoleListener = new TextWriterTraceListener(Console.Out);
            Trace.Listeners.Add(consoleListener);

            Trace.WriteLine(DateTime.Now.ToString("hh:mm:ss.ffff") + ": " + message);

            Trace.Flush();
            Trace.Listeners.Remove(consoleListener);
            ////consoleListener.Close();
            ////Trace.Close();
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\ActiveMonitoring\ActiveMonitoringManager\ActiveMonitoringTest.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="ActiveMonitoringTest.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>ActiveMonitoringTest class definition</summary>
//-------------------------------------------------------------------------------------------------
namespace ActiveMonitoringManager
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// ActiveMonitoringTest class definition
    /// </summary>
    public class ActiveMonitoringTest
    {
        /// <summary>
        /// Gets or sets the name of the Test
        /// </summary>
        public string TestName { get; set; }

        /// <summary>
        /// Gets or sets the name of the Test Project
        /// </summary>
        public string TargetDirectory { get; set; }

        /// <summary>
        /// Gets or sets the name of the test configuration file
        /// </summary>
        public string TestConfigFile { get; set; }

        /// <summary>
        /// Gets or sets the name of the Test Environment
        /// </summary>
        public string TestEnvironment { get; set; }

        /// <summary>
        /// Gets or sets the name of the Test Executable
        /// </summary>
        public string TestExecutable { get; set; }

        /// <summary>
        /// Gets or sets the name of the Test Arguments
        /// </summary>
        public string TestArguments { get; set; }

        /// <summary>
        /// Gets or sets the number of retries to do for the Test
        /// </summary>
        public int RetryCount { get; set; }

        /// <summary>
        /// Gets or sets the retry interval in number of seconds
        /// </summary>
        public int RetryInterval { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\ActiveMonitoring\ActiveMonitoringApp\Program.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="Program.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>ActiveMonitoring console application</summary>
//-------------------------------------------------------------------------------------------------
namespace ActiveMonitoringApp
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Xml.Linq;
    
    using ActiveMonitoringManager;

    /// <summary>
    /// <para>
    /// This application perform the active monitoring (AM) tests intended to actively run or monitor the LIVEN
    /// services periodically and verify that the services are up and running. The program will log the
    /// traces to a log file and depending on the configured test policy and alert policy (defined in
    /// app.config), it will send an alert to the relevant parties.
    /// </para><para>
    /// The application reads from the following files:
    /// * InputFile.xml which is expected as an input argument (ActiveMonitoringTests.xml is included in this
    ///   project as an example, but the filename can be anything as long as it conforms to the schema and
    ///   must have file extension .xml).  The InputFile.xml contains the list of tests to run and the
    ///   attributes of each test (defined in the xml file).
    /// * app.config which defines the test and alert policies, the trace log filepath, etc.
    /// </para><para>
    /// Dependency:
    /// This app relies on the ActiveMonitoringManager assembly to do the heavy lifting. It leverages on the 
    /// following two main public API of the assembly:
    /// Init("InputFile.xml")
    ///     Reads the InputFile.xml to collect all the necessary data to run the AM tests
    /// Run(test)
    ///     Run each test listed in the InputFile.xml
    /// </para><para>
    /// Description:
    ///     - Reads from the app.config and registers the config data to the assembly
    ///     - Call Init() to let the assembly collect the required data
    ///     - For each test in the InputFile.xml, run the test. Each test may be retried X times at Y interval
    ///       where X and Y are the defined in the.
    ///     - Send an alert after the test run completion.
    /// </para>
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Field to store the filepath of the input test configuration file (i.e. the xml file)
        /// </summary>
        private static string testConfigFile;

        /// <summary>
        /// Field to store the target path where the test binaries can be found
        /// </summary>
        private static string targetPath;

        /// <summary>
        /// Enum values for exit code. 
        /// </summary>
        private enum ExitCode
        {
            /// <summary>
            /// The operation was successful and get response 
            /// </summary>
            Success = 0,

            /// <summary>
            /// The supplied arguments are invalid. 
            /// </summary>
            InvalidArgument = 1,

            /// <summary>
            /// Test run failure after repeated retries 
            /// </summary>
            RunError = 2,

            /// <summary>
            /// Error in the Active Monitoring initialization. 
            /// </summary>
            InitError = 3
        }

        #region main method
        /// <summary>
        /// Entry point in the Console Application to run Active Monitoring test(s)
        /// </summary>
        /// <param name="args">Input arguments to main</param>
        /// <returns>Exit code of the program. 0 means success.</returns>
        public static int Main(string[] args)
        {
            if (!(args.Length == 1 || args.Length == 3))
            {
                UsageSummary();
                return (int)ExitCode.InvalidArgument;
            }

            if (!ProcessArguments(args))
            {
                UsageSummary();
                return (int)ExitCode.InvalidArgument;
            }

            if (!Directory.Exists(targetPath))
            {
                Console.WriteLine("Target path supplied " + targetPath + " is non-existent or inaccessible");
                return (int)ExitCode.InitError;
            }

            if (!ReadTestConfig(args[0]))
            {
                return (int)ExitCode.InitError;
            }

            ActiveMonitoringRun.Init();

            ActiveMonitoringLog.WriteLine("Active Monitoring initialization done", LogLevel.Info);

            bool testRunFailed = false;

            if (ActiveMonitoringRun.Tests.Count == 0)   
            {
                string msg = "No test to run.  Active Monitoring Test is exiting";
                ActiveMonitoringLog.WriteLine(msg);
                Console.WriteLine(msg);
                return (int)ExitCode.Success;
            }

            string testRunID = string.Empty;

            try
            {
                // for each test, run it RetryCount times at RetryInterval interval according to
                // the TestPolicy specified in the app.config.  The WhatToDoNext() tells me whether
                // to continue running the test or not as determined by the TestPolicy.
                ActiveMonitoringRun.TestRunOptions whatToDo = ActiveMonitoringRun.TestRunOptions.ContinueTest;

                ActiveMonitoringRun.ClearAlertMessage();

                ActiveMonitoringLog.WriteToEventLog("ActiveMonitoringApp run started ...", EventLogEntryType.Information);

                for (int i = 0; i < ActiveMonitoringRun.Tests.Count; i++)
                {
                    for (int j = 0; j <= ActiveMonitoringRun.Tests[i].RetryCount; j++)
                    {
                        testRunID = ActiveMonitoringRun.Tests[i].TestName + (j > 0 ? "_Retry#" + j : "_FirstRun") + "_" + DateTime.Now.ToString("hh:mm:ss.ffff");

                        bool testRunStatus = ActiveMonitoringRun.Run(ActiveMonitoringRun.Tests[i], testRunID);

                        if (testRunStatus == false) 
                        {
                            if (j == ActiveMonitoringRun.Tests[i].RetryCount)
                            {
                                testRunFailed = true;   //// set this flag to true if the test still failed after all retries
                            }
                        }
                        else
                        {
                            break;  //// don't need to do retry if it passed
                        }

                        whatToDo = ActiveMonitoringRun.WhatToDoNext();

                        if (whatToDo == ActiveMonitoringRun.TestRunOptions.ContinueTest)
                        {
                            if (j < ActiveMonitoringRun.Tests[i].RetryCount)
                            {
                                Thread.Sleep(ActiveMonitoringRun.Tests[i].RetryInterval * 1000);
                            }
                        }
                        else
                        {
                            break;
                        }
                    }

                    if (whatToDo == ActiveMonitoringRun.TestRunOptions.StopAllTests)
                    {
                        break;
                    }
                }

                // Send the alert when the test run has been completed. Send alert when the test failed.
                // If the test passed, send alert only if AlertPolicy requires the alert to be sent anyway.
                string subject = "Test completed " + (testRunFailed == true ? "with" : "without") + " error";
                string message = ActiveMonitoringRun.AlertMessage + "\r\n" + "See the trace log at " + ActiveMonitoringLog.LogFilePath;

                ActiveMonitoringRun.SendAlert(subject, message, testRunFailed);
            }
            catch (Exception e)
            {
                testRunFailed = true;
                ActiveMonitoringLog.WriteLine("Test run exception on test " + testRunID + ": " + e.ToString(), LogLevel.Error);
                ActiveMonitoringLog.WriteToEventLog("Test run exception on test " + testRunID + ": " + e.ToString(), EventLogEntryType.Error);
                Console.WriteLine("Test run exception on test " + testRunID + ": " + e.ToString());

                // send alert
                string subject = "Test run throws an exception!";
                string message = e.ToString();
                ActiveMonitoringRun.SendAlert(subject, message, testRunFailed);
            }

            if (testRunFailed)
            {
                ActiveMonitoringLog.WriteLine("ActiveMonitoringApp run FAILED", LogLevel.Error);
                string errMsg = String.Format("ActiveMonitoringApp run FAILED.  See the trace log in {0} for details.", ActiveMonitoringLog.LogFilePath);
                ActiveMonitoringLog.WriteToEventLog(errMsg, EventLogEntryType.Error);
                return (int)ExitCode.RunError;
            }
            else
            {
                ActiveMonitoringLog.WriteLine("ActiveMonitoringApp run PASSED", LogLevel.Error);
                ActiveMonitoringLog.WriteToEventLog("ActiveMonitoringApp run PASSED", EventLogEntryType.Information);
                return (int)ExitCode.Success;
            }
        }
        #endregion

        #region private static methods
        /// <summary>
        /// Help message to show how to invoke the application program
        /// </summary>
        private static void UsageSummary()
        {
            Console.WriteLine("\n\nUsage Summary:");
            Console.WriteLine("ActiveMonitoringApp.exe TestConfigurationFile [-targetPath <Target UNC>]");
            Console.WriteLine("where:");
            Console.WriteLine("  * TestConfigurationFile is the required argument of the input XML file defining the tests to run and how to run them");
            Console.WriteLine("  * -targetPath <Target UNC> is an optional switch of the file/UNC path where the test binary files are to be found.");
            Console.WriteLine("    If this switch is not specified, it is assumed to be in the same path of this running application.");
        }

        /// <summary>
        /// Process the input arguments
        /// </summary>
        /// <param name="args">Input arguments to main</param>
        /// <returns>true if the input arguments are valid</returns>
        private static bool ProcessArguments(string[] args)
        {
            if (args[0].Length < 5 || args[0].Contains(".xml") == false)
            {
                return false;
            }

            testConfigFile = args[0];

            if (args.Length == 1)
            {
                targetPath = @".\";
            }
            else if (args.Length == 3)
            {
                if (string.Compare(args[1], "-targetPath") == 0)
                {
                    targetPath = args[2] + (args[2].EndsWith("\\") == true ? string.Empty : "\\");
                }
                else
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Parse and read data from the input test.xml file
        /// </summary>
        /// <param name="testConfigFile">test configuration file from the input argument</param>
        /// <returns>true if no error</returns>
        private static bool ReadTestConfig(string testConfigFile)
        {
            try
            {
                XElement tests = XElement.Load(testConfigFile);

                ActiveMonitoringRun.SmtpProviderAccount = tests.Element("SMTPProvider").Attribute("Account").Value;
                ActiveMonitoringRun.SmtpProviderPassword = tests.Element("SMTPProvider").Attribute("Password").Value;
                ActiveMonitoringRun.SmtpProviderDomain = tests.Element("SMTPProvider").Attribute("Domain").Value;
                ActiveMonitoringRun.SmtpProviderHost = tests.Element("SMTPProvider").Attribute("HostName").Value;
                ActiveMonitoringRun.SmtpProviderAddress = tests.Element("SMTPProvider").Attribute("Email").Value;
                ActiveMonitoringRun.LogDirectory = tests.Element("Trace").Attribute("FileDirectory").Value;
                ActiveMonitoringRun.LogFileName = tests.Element("Trace").Attribute("FileName").Value;
                ActiveMonitoringRun.TestEnvironment = tests.Element("TestSetting").Attribute("Environment").Value;  //// default test environment
                ActiveMonitoringRun.TestPolicy = tests.Element("TestSetting").Attribute("Policy").Value;
                ActiveMonitoringRun.AlertPolicy = tests.Element("SendAlert").Attribute("Policy").Value;
                ActiveMonitoringRun.AlertService = tests.Element("SendAlert").Attribute("ServiceType").Value;
                ActiveMonitoringRun.AlertAddress = tests.Element("SendAlert").Attribute("Address").Value;

                GetTests(tests);
            }
            catch (IOException i)
            {
                Console.WriteLine(i.Message);
                ActiveMonitoringLog.WriteLine(i.Message, LogLevel.Error);
                return false;
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
                ActiveMonitoringLog.WriteLine(e.Message, LogLevel.Error);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Get the list of Tests to run from the input XML file
        /// </summary>
        /// <param name="xe">XML Element to get its children from</param>
        private static void GetTests(XElement xe)
        {
            ActiveMonitoringRun.Tests = new List<ActiveMonitoringTest>();
            try
            {
                var tests = xe.Descendants("Test");
                foreach (var test in tests)
                {
                    ActiveMonitoringTest amt = new ActiveMonitoringTest();
                    amt.TestName = test.Attribute("Name").Value;
                    amt.TargetDirectory = targetPath;
                    amt.TestEnvironment = test.Attribute("Environment").Value == String.Empty ? ActiveMonitoringRun.TestEnvironment : test.Attribute("Environment").Value;
                    amt.TestConfigFile = string.Empty;   //// not used
                    amt.TestExecutable = test.Attribute("ExecutableFilePath").Value;
                    amt.TestArguments = test.Attribute("Arguments").Value;
                    amt.RetryCount = Convert.ToInt32(test.Attribute("RetryCount").Value);
                    amt.RetryInterval = Convert.ToInt32(test.Attribute("RetryInterval").Value);

                    ActiveMonitoringRun.Tests.Add(amt);
                }
            }
            catch (Exception ex)
            {
                throw new Exception("Get test list exception, likely caused by bad input XML file. " + ex.ToString());
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\ActiveMonitoring\ActiveMonitoringManager\RunResult.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="RunResult.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>RunResult class definition</summary>
//-------------------------------------------------------------------------------------------------
namespace ActiveMonitoringManager
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// RunResult class definition
    /// </summary>
    internal class RunResult
    {
        /// <summary>
        /// Gets or sets the exit code of the test run process
        /// </summary>
        public int ExitCode { get; set; }

        /// <summary>
        /// Gets or sets the redirected standard output of the test run process 
        /// </summary>
        public StringBuilder Output { get; set; }

        /// <summary>
        /// Gets or sets the redirected error output of the test run process
        /// </summary>
        public StringBuilder Error { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\ActiveMonitoring\ActiveMonitoringManager\ActiveMonitoringRun.cs ===
﻿//------------------------------------------------------------------------------------------------- 
// <copyright file="ActiveMonitoringRun.cs" company="Microsoft" author="a-thkuo">
//      Copyright © .  All rights reserved.
// </copyright>
// <summary>Class that implements LIVEN Active Monitoring initialization and run.</summary>
//-------------------------------------------------------------------------------------------------
namespace ActiveMonitoringManager
{
    #region namespaces
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Mail;
    using System.Text;
    using System.Xml.Linq;
    #endregion

    /// <summary>
    /// ActiveMonitoringRun class definition
    /// This class contains the properties and methods to run the active monitoring functions.
    /// </summary>
    public static class ActiveMonitoringRun
    {
        #region private fields
        /// <summary>
        /// Constant for max time to wait for the test run process to exit
        /// </summary>
        private static readonly int MaxRunProcessExitTime;

        /// <summary>
        /// Field that represents the selected test policy option
        /// </summary>
        private static TestPolicyOptions testPolicy;

        /// <summary>
        /// Field that represents the selected alert service option
        /// </summary>
        private static AlertServiceOptions alertService;

        /// <summary>
        /// Field that represents the selected alert policy option
        /// </summary>
        private static AlertPolicyOptions alertPolicy;

        /// <summary>
        /// Field that represents the address to send the alert to
        /// </summary>
        private static string alertAddress;

        /// <summary>
        /// Field to store the currently running test
        /// </summary>
        private static ActiveMonitoringTest currentTest;

        /// <summary>
        /// Field to build the alert message string
        /// </summary>
        private static StringBuilder alertMessage = new StringBuilder();
        #endregion

        #region static constructor
        /// <summary>
        /// Initializes static members of the ActiveMonitoringRun class
        /// </summary>
        static ActiveMonitoringRun()
        {
            MaxRunProcessExitTime = 300000;     //// Set the max process exit time to 5 minutes
        }
        #endregion

        #region enums
        /// <summary>
        /// Options of test policy
        /// </summary>
        public enum TestPolicyOptions
        {
            /// <summary>
            /// Retry every test till its retry count is exhausted regardless whether it passed or failed
            /// </summary>
            RetryAlways,

            /// <summary>
            /// Retry the current test only if it failed
            /// </summary>
            RetryOnError,

            /// <summary>
            /// Abort the current test when it failed, but continue to the next test in the list (if any)
            /// </summary>
            AbortOnError,

            /// <summary>
            /// Abort all tests in the list when the current test failed
            /// </summary>
            AbortAllOnError
        }

        /// <summary>
        /// Options to alert users
        /// </summary>
        public enum AlertServiceOptions
        {
            /// <summary>
            /// Alert by Email
            /// </summary>
            Email,

            /// <summary>
            /// Alert by web service
            /// </summary>
            WebService
        }

        /// <summary>
        /// Options of alert policy
        /// </summary>
        public enum AlertPolicyOptions
        {
            /// <summary>
            /// Always send alert after the test is completed (whether it passed or failed)
            /// </summary>
            OnTestCompletion,

            /// <summary>
            /// Send alert only if error was encounterd
            /// </summary>
            OnTestError,

            /// <summary>
            /// Do not send any alert
            /// </summary>
            NoAlert
        }

        /// <summary>
        /// Options on how to proceed with the test run based on the given test policy
        /// </summary>
        public enum TestRunOptions
        {
            /// <summary>
            /// Stop the current test if error occurs, but proceed with the next test in the list (if any)
            /// </summary>
            StopCurrentTest,

            /// <summary>
            /// Stop running all the tests when error occurs
            /// </summary>
            StopAllTests,

            /// <summary>
            /// Proceed with the test run
            /// </summary>
            ContinueTest
        }
        #endregion

        #region public properties
        /// <summary>
        /// Gets or sets the test policy
        /// </summary>
        public static string TestPolicy { get; set; }

        /// <summary>
        /// Gets or sets the alert policy
        /// </summary>
        public static string AlertService { get; set; }

        /// <summary>
        /// Gets or sets the alert address
        /// </summary>
        public static string AlertAddress { get; set; }

        /// <summary>
        /// Gets or sets the alert policy
        /// </summary>
        public static string AlertPolicy { get; set; }

        /// <summary>
        /// Gets or sets the trace file directory
        /// </summary>
        public static string LogDirectory { get; set; }

        /// <summary>
        /// Gets or sets the trace file name
        /// </summary>
        public static string LogFileName { get; set; }

        /// <summary>
        /// Gets or sets the test environment
        /// </summary>
        public static string TestEnvironment { get; set; }

        /// <summary>
        /// Gets or sets the SMTP Provider's account name
        /// </summary>
        public static string SmtpProviderAccount { get; set; }

        /// <summary>
        /// Gets or sets the SMTP Provider's password
        /// </summary>
        public static string SmtpProviderPassword { get; set; }

        /// <summary>
        /// Gets or sets the SMTP Provider's domain name
        /// </summary>
        public static string SmtpProviderDomain { get; set; }

        /// <summary>
        /// Gets or sets the SMTP Provider's host name
        /// </summary>
        public static string SmtpProviderHost { get; set; }

        /// <summary>
        /// Gets or sets the SMTP Provider's Email address
        /// </summary>
        public static string SmtpProviderAddress { get; set; }

        /// <summary>
        /// Gets the alert message
        /// </summary>
        public static string AlertMessage
        {
            get
            {
                return alertMessage.ToString();
            }
        }

#if __OBSOLETE__
        /// <summary>
        /// Gets or sets the list of projects
        /// </summary>
        public static List<ActiveMonitoringProject> Projects { get; set; }
#endif

        /// <summary>
        /// Gets or sets the list of tests
        /// </summary>
        public static List<ActiveMonitoringTest> Tests { get; set; }
        #endregion

        #region public methods
        /// <summary>
        /// Clear the alert message StringBuilder
        /// </summary>
        public static void ClearAlertMessage()
        {
            alertMessage.Remove(0, alertMessage.Length);
        }

        /// <summary>
        /// Initialize the values of the Active Monitoring fields 
        /// </summary>
        public static void Init()
        {
            switch (TestPolicy)
            {
                case "RetryAlways":
                    testPolicy = TestPolicyOptions.RetryAlways;
                    break;

                case "RetryOnError":
                    testPolicy = TestPolicyOptions.RetryOnError;
                    break;

                case "AbortOnError":
                    testPolicy = TestPolicyOptions.AbortOnError;
                    break;

                case "AbortAllOnError":
                    testPolicy = TestPolicyOptions.AbortAllOnError;
                    break;

                default:
                    testPolicy = TestPolicyOptions.RetryOnError;
                    break;
            }

            switch (AlertService)
            {
                case "Email":
                    alertService = AlertServiceOptions.Email;
                    break;

                case "WebService":
                    alertService = AlertServiceOptions.WebService;
                    break;

                default:
                    alertService = AlertServiceOptions.Email;
                    break;
            }

            alertAddress = AlertAddress;

            if (alertService == AlertServiceOptions.Email && !alertAddress.Contains('@'))
            {
                ActiveMonitoringLog.WriteLine("Invalid Email address " + alertAddress + " in the test configuration file", LogLevel.Error);
                ActiveMonitoringLog.WriteToEventLog("Invalid Email address " + alertAddress + " in the test configuration file", EventLogEntryType.Warning);
            }

            switch (AlertPolicy)
            {
                case "OnTestCompletion":
                    alertPolicy = AlertPolicyOptions.OnTestCompletion;
                    break;

                case "OnTestError":
                    alertPolicy = AlertPolicyOptions.OnTestError;
                    break;

                case "NoAlert":
                    alertPolicy = AlertPolicyOptions.NoAlert;
                    break;

                default:
                    alertPolicy = AlertPolicyOptions.NoAlert;
                    break;
            }
        }

        /// <summary>
        /// Update the environment variable in the test configuration file for the current test environment.
        /// </summary>
        /// <param name="test">current test</param>
        public static void UpdateEnvironmentInTestConfigFile(ActiveMonitoringTest test)
        {
            try
            {
                if (!File.Exists(test.TargetDirectory + "\\" + test.TestConfigFile))
                {
                    throw new IOException("Test configuration file " + test.TestConfigFile + " is not found or inaccessible in the target directory.");
                }

                // TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                // update the env in the project's config file
                // wait till we get the config file schema
            }
            catch (IOException ie)
            {
                throw new Exception(ie.Message);
            }
            catch (Exception ex)
            {
                throw new Exception(ex.ToString());
            }
        }

        /// <summary>
        /// This method creates a process to run the given test. It redirects
        /// the process' standard output and error to StringBuilder instances
        /// which then get appended to the trace log file at the completion of
        /// the test run.
        /// </summary>
        /// <param name="test">test to run</param>
        /// <param name="testID">test unique identification</param>
        /// <returns>true if the test passed</returns>
        public static bool Run(ActiveMonitoringTest test, string testID)
        {
            ActiveMonitoringLog.WriteLine("Running test " + testID + " in " + test.TestEnvironment + " environment started ...", LogLevel.Info);
            ActiveMonitoringLog.WriteLine("Tool used to run this test: " + test.TestExecutable, LogLevel.Info);
            ActiveMonitoringLog.WriteToEventLog("Test run " + testID + " in " + test.TestEnvironment + " environment started ...", EventLogEntryType.Information);

            RunResult runResult = new RunResult
            {
                Output = new StringBuilder(),
                Error = new StringBuilder(),
            };

            currentTest = test;

            // Create a Process instance to run the test
            try
            {
                using (Process p = new Process())
                {
                    p.StartInfo.FileName = test.TestExecutable;
                    p.StartInfo.Arguments = test.TestArguments;
                    p.StartInfo.WorkingDirectory = test.TargetDirectory;
                    p.StartInfo.CreateNoWindow = false;
                    p.StartInfo.UseShellExecute = false;
                    p.StartInfo.RedirectStandardOutput = true;
                    p.StartInfo.RedirectStandardError = true;

                    // redirect output: input args (o, ev) represents (sending process object, DataReceivedEventArgs)
                    p.OutputDataReceived += (o, ev) => runResult.Output.Append(ev.Data).Append(System.Environment.NewLine); //// redirect standard output to a StringBuilder
                    p.OutputDataReceived += (o, ev) => Console.WriteLine(ev.Data);  //// redirect standard output to console
                    p.ErrorDataReceived += (o, ev) => runResult.Error.Append(ev.Data).Append(System.Environment.NewLine);   //// redirect error output to a StringBuilder

                    p.Start();
                    p.BeginOutputReadLine();
                    p.BeginErrorReadLine();
                    p.WaitForExit(MaxRunProcessExitTime);
                    runResult.ExitCode = p.ExitCode;

                    string msg = String.Format("Test {0} run returns status {1}", testID, (runResult.ExitCode == 0) ? "SUCCESS" : "ERROR");
                    ActiveMonitoringLog.WriteLine(msg);
                }
            }
            catch (Exception ex)
            {
                string msg = String.Format("Test {0} run caused exception {1}", test.TestName, ex.ToString());
                ActiveMonitoringLog.WriteLine(msg, LogLevel.Error);
                ActiveMonitoringLog.WriteToEventLog(msg, EventLogEntryType.Error);
                return false;
            }

            if (runResult.ExitCode == 0)
            {
                ActiveMonitoringLog.WriteLine("Test " + testID + " PASSED");
                ActiveMonitoringLog.WriteLine(runResult.Output.ToString(), LogLevel.Info);
                if (String.Compare(runResult.Error.ToString(), "\r\n") != 0)
                {
                    ActiveMonitoringLog.WriteLine("Error output trace of test " + testID + ":");
                    ActiveMonitoringLog.WriteLine(runResult.Error.ToString(), LogLevel.Info);
                }

                // construct the alert message to send
                alertMessage.AppendLine("========== Test " + testID + " running in " + test.TestEnvironment + "environment PASSED ==========");
                alertMessage.AppendLine();

                // write to event log
                ActiveMonitoringLog.WriteToEventLog("Test run " + testID + " PASSED", EventLogEntryType.Information);

                return true;
            }
            else
            {
                ActiveMonitoringLog.WriteLine("Test " + testID + " FAILED with exit code = " + runResult.ExitCode);
                ActiveMonitoringLog.WriteLine(runResult.Output.ToString(), LogLevel.Error);

                // construct the alert message to send to operators
                alertMessage.AppendLine("========== Test " + testID + " running in " + test.TestEnvironment + "environment FAILED ==========");
                alertMessage.AppendLine("Tool used to run this test: " + test.TestExecutable);
                alertMessage.AppendLine("Exit code = " + runResult.ExitCode);
                alertMessage.AppendLine("Standard Output Trace:");
                alertMessage.Append(runResult.Output.ToString());
                alertMessage.AppendLine();

                if (String.Compare(runResult.Error.ToString(), "\r\n") != 0)
                {
                    ActiveMonitoringLog.WriteLine("Error output trace of test " + testID + ":");
                    ActiveMonitoringLog.WriteLine(runResult.Error.ToString(), LogLevel.Error);
                    alertMessage.Append(runResult.Error.ToString());
                    alertMessage.AppendLine();
                }

                string msg = String.Format("Test run {0} FAILED with exit code {1}\r\n, Tool used to run this test: {2}", testID, runResult.ExitCode, test.TestExecutable);
                ActiveMonitoringLog.WriteToEventLog(msg, EventLogEntryType.Warning);

                return false;
            }
        }

        /// <summary>
        /// Method to determine how to proceed with the test run based on the selected test policy
        /// </summary>
        /// <returns>Option to tell the caller what to do next</returns>
        public static TestRunOptions WhatToDoNext()
        {
            switch (testPolicy)
            {
                case TestPolicyOptions.AbortOnError:
                    return TestRunOptions.StopCurrentTest;

                case TestPolicyOptions.AbortAllOnError:
                    return TestRunOptions.StopAllTests;

                case TestPolicyOptions.RetryAlways:     //// this option may not be used at all, but leave it here for now
                    return TestRunOptions.ContinueTest;

                case TestPolicyOptions.RetryOnError:
                default:
                    return TestRunOptions.ContinueTest;
            }
        }

        /// <summary>
        /// Send alert based on the specified service type and the specified alert policy.
        /// Alert is always sent when the test failed, but may or may not be sent when it passed
        /// based on the alert policy.
        /// </summary>
        /// <param name="subject">Alert's subject</param>
        /// <param name="message">Alert's message</param>
        /// <param name="testFailed">test status</param>
        public static void SendAlert(string subject, string message, bool testFailed)
        {
            if (alertPolicy == AlertPolicyOptions.NoAlert)
            {
                return;
            }

            try
            {
                switch (alertService)
                {
                    case AlertServiceOptions.WebService:
                        // currently not supported
                        break;

                    case AlertServiceOptions.Email:
                    default:
                        if (testFailed == true)
                        {
                            SendEmail(message, subject);
                        }
                        else
                        {
                            if (alertPolicy == AlertPolicyOptions.OnTestCompletion)
                            {
                                SendEmail(message, subject);
                            }
                        }

                        break;
                }
            }
            catch (Exception ex)
            {
                throw new Exception(ex.Message);
            }
        }
        #endregion

        #region private methods
#if __OBSOLETE__
        /// <summary>
        /// Get the list of LIVEN Test Projects from the input XML file
        /// </summary>
        /// <param name="testConfigFile">test configuration filepath</param>
        private static void GetProjects(string testConfigFile)
        {
            Projects = new List<ActiveMonitoringProject>();
            try
            {
                XElement xe = XElement.Load(testConfigFile);
                var projects = xe.Descendants("Project");
                foreach (var project in projects)
                {
                    ActiveMonitoringProject amp = new ActiveMonitoringProject();
                    amp.Project = project.Attribute("Name").Value;
                    amp.Target = project.Attribute("Target").Value;
                    amp.TestConfigFile = project.Attribute("TestConfigFile").Value;

                    Projects.Add(amp);
                }
            }
            catch (Exception ex)
            {
                throw new Exception("Get project list exception, likely caused by bad input XML file. " + ex.ToString());
            }
        }
        /// <summary>
        /// Check if the given test project name is valid
        /// </summary>
        /// <param name="testProject">Name of the test project</param>
        /// <param name="testName">Name of the test to run</param>
        private static void IsProjectValid(string testProject, string testName)
        {
            // The line below is the shorthand of the anonymous method with delegate as shown here
            // bool match = Projects.Exists(delegate(ActiveMonitoringProject x) { return x.Project == testProject; });
            bool match = Projects.Exists(x => x.Project == testProject);
            
            if (!match)
            {
                string msg = String.Format("Project {0} for TestName {1} is invalid", testProject, testName);
                throw new Exception(msg);
            }
        }
#endif

        /// <summary>
        /// Send alert by email (SMTP)
        /// </summary>
        /// <param name="emailBody">The body of the Email</param>
        /// <param name="title">The title of the Email</param>
        private static void SendEmail(string emailBody, string title)
        {
            string subject = "LIVEN Active Monitoring: " + title + " " + DateTime.Now;

            ActiveMonitoringLog.WriteLine("Sending alert to " + AlertAddress);

            try
            {
                NetworkCredential credentials = new NetworkCredential(SmtpProviderAccount, SmtpProviderPassword, SmtpProviderDomain);
                SmtpClient smtpClient = new SmtpClient();
                smtpClient.Host = SmtpProviderHost;
                smtpClient.Credentials = credentials;
                MailMessage mailMessage = new MailMessage(SmtpProviderAddress, AlertAddress);
                mailMessage.Subject = subject;
                mailMessage.IsBodyHtml = false;
                mailMessage.Body = emailBody;
                mailMessage.Priority = MailPriority.Normal;
                
                // !!!!!!!!!!!!!!!!!!NOTE!!!!!!!!!!!
                // DO NOT SET smtpClient.UseDefaultCredentials to true or false
                // Setting it to true will give "Client does not have permissions to send as this sender"
                // Setting it to false will give "Client was not authenticated"
                smtpClient.Send(mailMessage);
            }
            catch (Exception ex)
            {
                ActiveMonitoringLog.WriteLine(ex.Message, LogLevel.Error);
                throw new Exception(ex.Message);
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Library\ClosetAudienceUriProvider.cs ===
﻿using System;
using Leet.Identity;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Avatar.Services.Closet.Library
{
    public class ClosetAudienceUriProvider : IAudienceUriProvider
    {
        private IConfigurationProvider Config
        {
            get
            {
                return Container.Instance.GetComponent<IConfigurationProvider>();
            }
        }

        private string[] audienceUriList;
        public string[] AudienceUriList
        {
            get 
            {
                if(audienceUriList == null)
                {
                    string audienceSetting = this.Config.GetSetting(Settings.AvatarCloset_AudienceUri);
                    if (!String.IsNullOrEmpty(audienceSetting))
                    {
                        audienceUriList = audienceSetting.Split(',');
                    }
                }

                return audienceUriList; 
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Library\IClosetAssetsQueryable.cs ===
﻿using System;

namespace Avatar.Services.Closet.Library
{
    /// <summary>
    /// Models IClosetAssetsQueryable
    /// </summary>
    public interface IClosetAssetsQueryable
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid")]
        ClosetAssets QueryClosetAssets(UInt64 xuid, String userLocale, UInt32 platformType, UInt32 titleID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Library\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Avatar.Services.Closet.Library.ClosetService.#UseCanned(System.Web.HttpContext)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Avatar.Services.Closet.Library")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Avatar.Services.Closet.Library.IClosetService.#GetClosetAssets()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Avatar.Services.Closet.Library.ClosetService.#CreateCanned()")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Library\ClosetAssetQuery.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.
using System;
using System.Diagnostics;
using System.Collections.ObjectModel;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using Microsoft.ServiceModel.Web;
using System.Net;
using Leet.Utils;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;
using Leet.Identity;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Exceptions;
using Leet.Live.Livecache.Logic.Profile;
using Avatar.Services.Common;
using Avatar.Services.Common.AssetFiltering;

namespace Avatar.Services.Closet.Library
{
    /// <summary>
    /// IClosetAssetsQueryable implementation
    /// </summary>
    public class ClosetAssetQuery : IClosetAssetsQueryable
    {
        ILogging logger;
        IConfigurationProvider config;
        const Int32 MAXLOCALELENGTH = 5;
        const Int32 AVATARAWARDSALLTITLES = 0;

        /// <summary>
        /// ctor
        /// </summary>
        public ClosetAssetQuery()
        {
             this.logger = Container.Instance.GetComponent<ILogging>();
             this.config = Container.Instance.GetComponent<IConfigurationProvider>();
        }

        #region IClosetAssetsQueryable
        /// <summary>
        /// Queries live cache for the users the marketplace (purchased) and awardable assets
        /// User is identified by the Xuid in the STS token.
        /// </summary>
        /// <param name="avatarAssetFilter">IAvatarAssetFilter implementation used to filter assets</param>
        /// <param name="userLocale">User locale</param>
        /// <param name="xuid">User xuid</param>
        /// <returns>ClosetAssets</returns>
        /// <exception cref="WebProtocolException">
        /// HTTP 401 if Unauthorized or Unauthenticated. 
        /// HTTP 500 if there is an internal server error
        /// </exception>
        public ClosetAssets QueryClosetAssets(UInt64 xuid, String userLocale, UInt32 platformType, UInt32 titleID)
        {
            Debug.Assert(this.logger != null, "logger");
            Debug.Assert(this.config != null, "config");

            ReadOnlyCollection<PurchaseHistoryEntry> purchaseHistoryEntries = null;
            ReadOnlyCollection<AwardedAvatarAsset> awardedAssets = null;

            //Marketplace assets
            IBillingOfferingDataAccess billingOffering = Container.Instance.GetComponent<IBillingOfferingDataAccess>();
            purchaseHistoryEntries = 
                billingOffering.GetPurchaseHistory(PurchaseHistoryRequest.CreateAvatarGearPurchaseHistoryRequest(xuid, userLocale)).PurchaseHistoryEntries;

            System.Globalization.CultureInfo ci = new System.Globalization.CultureInfo(userLocale);
            UInt16 lcid = (UInt16)ci.LCID;

            //Live Cache Awardable Assets
            ISettingsDataAccess settingsDataAccess = Container.Instance.GetComponent<ISettingsDataAccess>();
            awardedAssets = settingsDataAccess.GetUserAvatarAwards(xuid, lcid, AVATARAWARDSALLTITLES); // get for all the titles

            //combine both the marketplace and awardable assets
            ClosetAssets closetAssets = Parse(purchaseHistoryEntries, awardedAssets, platformType, titleID);
            return closetAssets;
        }

        #endregion

        #region Helper Methods

        private static ClosetAssets Parse(ReadOnlyCollection<PurchaseHistoryEntry> purchaseHistory,
            ReadOnlyCollection<AwardedAvatarAsset> awardedAssets, UInt32 platformType, UInt32 titleID)
        {
            List<Asset> assetList = new List<Asset>();
            IAvatarAssetFilter avatarAssetFilter = Container.Instance.GetComponent<IAvatarAssetFilter>();
 
            bool areAssetsFiltered = false;
            
            if (awardedAssets != null && awardedAssets.Count > 0)
            {
                foreach (AwardedAvatarAsset awardedAsset in awardedAssets)
                {
                    String awardedAssetGuidString = new Guid(awardedAsset.AvatarAssetId).ToString();
                    
                    if (avatarAssetFilter.IsAssetIDBlackListed(awardedAssetGuidString, platformType, titleID))
                    {
                        //this is a blacklisted asset so we will not include this
                        areAssetsFiltered = true;    
                        continue;
                    }

                    Asset asset = new Asset();
                    asset.id = awardedAssetGuidString;
                    asset.title = awardedAsset.Title;
                    asset.description = awardedAsset.Description;
                    assetList.Add(asset);
                }
            }

            if (purchaseHistory != null && purchaseHistory.Count > 0)
            {
                foreach (PurchaseHistoryEntry entry in purchaseHistory)
                {
                    String purchasedAssetMediaID = entry.TheOffer.MediaId.ToString();
                    if (avatarAssetFilter.IsAssetIDBlackListed(purchasedAssetMediaID, platformType, titleID))
                    {
                        //this is a blacklisted asset so we will not include this
                        areAssetsFiltered = true;
                        continue;
                    }

                    Asset asset = new Asset();
                    asset.description = entry.TheOffer.ShortDescription;
                    asset.title = entry.TheOffer.ShortTitle;
                    asset.id = purchasedAssetMediaID;
                    assetList.Add(asset);
                }
            }

            ClosetAssets closetAssets = new ClosetAssets();
            closetAssets.Filtered = areAssetsFiltered;
            closetAssets.assets = assetList.ToArray();

            return closetAssets;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Library\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.Closet.Library")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
[assembly: System.CLSCompliant(false)] //because we use unsigned types

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9edfb09e-d6d6-454b-b839-cdf7dabd39f9")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Library\ClosetService.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.
using System;
using System.Web;
using System.Diagnostics;
using System.Collections.ObjectModel;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using Microsoft.ServiceModel.Web;
using System.Net;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;
using Leet.Identity;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Account;
using Leet.Live.Livecache.Logic.Exceptions;
using Leet.Live.Livecache.Logic.Profile;
using Avatar.Services.Common;

namespace Avatar.Services.Closet.Library
{
    /// <summary>
    /// Closet Service Interface contract
    /// </summary>
    [ServiceContract]
    public interface IClosetService
    {
        [WebGet]
        [WebHelp(Comment="Gets Awardable and Marketplace Assets for an XBOX Live user")]
        [OperationContract]
        ClosetAssets GetClosetAssets();
    }

    /// <summary>
    /// Closet Service contract implementation
    /// </summary>
    [ServiceBehavior(IncludeExceptionDetailInFaults = false, InstanceContextMode=InstanceContextMode.Single, ConcurrencyMode=ConcurrencyMode.Multiple), 
    AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public class ClosetService : IClosetService
    {
        ILogging logger;
        IConfigurationProvider config;
        const String XLOCALEHEADER = "X-Locale";
        const String XCANNEDHEADER = "X-Canned";
        const String XPLATFORMTYPE = "X-Platform-Type";
   
        public ClosetService()
        {
             this.logger = Container.Instance.GetComponent<ILogging>();
             this.config = Container.Instance.GetComponent<IConfigurationProvider>();
        }
        
        /// <summary>
        /// Queries live cache for the users marketplace (purchased) and awardable assets
        /// User is identified by the Xuid in the STS token
        /// </summary>
        /// <returns>ClosetAssets</returns>
        /// <exception cref="WebProtocolException">
        /// HTTP 401 if Unauthorized or Unauthenticated. 
        /// HTTP 503 if the service is unavailable
        /// HTTP 500 if there is an internal server error
        /// </exception>
        public ClosetAssets GetClosetAssets()
        {
            Debug.Assert(logger != null, "logger");
            Debug.Assert(config != null, "config");

            //Check authentication. If user is not authenticated we will throw a HTTP 401 Unathorized exception
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();
            Debug.Assert(authManager != null, "authManager");
            if (!authManager.IsAuthenticated)
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new ClosetAssets(),
                    null);

                Logging.TraceException(wpEx, "Unauthenticated request received");

                throw wpEx;
            }

            //Get the User Identity Object. if no user identity object is received we will throw a HTTP 401 Unauthorized exception
            IUserIdentity callerIdentity = authManager.CurrentUser;
            if (callerIdentity == null)
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new ClosetAssets(),
                    null);

                Logging.TraceException(wpEx, "Authenticated request received, but CurrentUser object is null");
                throw wpEx;
            }

            HttpContext currentContext = HttpContext.Current;

            //check if canned is enabled
            if (UseCanned(currentContext))
            {
                return CreateCanned();
            }
            
            if (config.GetBoolSetting(Settings.LivecacheServiceEnabled))
            {
                try
                {
                    //Set cache parameters so that client browsers do not cache the responses
                    WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
                    WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.Expires, DateTime.Now.AddDays(-1).ToString());

                    IClosetAssetsQueryable closetAssetQueryable = Container.Instance.GetComponent<IClosetAssetsQueryable>();
                    Debug.Assert(closetAssetQueryable != null, "closetAssetQueryable is null");

                    //Get the locale of the user from users account info
                    String userLocale = ResolveUserAccountLocale((UInt64)callerIdentity.Xuid);

                    //Get the assets.
                    ClosetAssets responseAssets = closetAssetQueryable.QueryClosetAssets((UInt64)callerIdentity.Xuid, userLocale,
                        GetPlatformTypeFromHeader(), GetTitleID());

                    Debug.Assert(responseAssets != null, "responseAssets");
                    Debug.Assert(responseAssets.assets != null, "responseAssets.assets");

                    return responseAssets;
                }
                catch (WebProtocolException)
                {
                    throw;
                }
                catch (LeetLivecacheConfigException ex)
                {
                    logger.LogEvent(new Diagnostics.AvatarClosetLcConfigErrorEvent(), ex);
                    throw new WebProtocolException(HttpStatusCode.InternalServerError, "Server Error", new ClosetAssets(), null);
                }
                catch (LeetLivecacheResponseException ex)
                {

                    logger.LogEvent(new Diagnostics.AvatarClosetLcResponseErrorEvent(), ex);
                    throw new WebProtocolException(HttpStatusCode.InternalServerError, "Server Error", new ClosetAssets(), null);
                }
                catch (Exception ex)
                {
                    logger.LogEvent(new Diagnostics.AvatarClosetUnknownErrorEvent(), ex);
                    throw new WebProtocolException(HttpStatusCode.InternalServerError, "Unexpected Error", new ClosetAssets(), null);
                }
            }
            else
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.ServiceUnavailable,
                    "Service Unavailable",
                    new ClosetAssets(),
                    null);

                Logging.TraceException(wpEx, "Closet Service:  Livecache has been disabled in NPDB.  A request has been rejected.");

                // Livecache has been disabled, so return service unavailable
                throw wpEx;
            }
        }

        private bool UseCanned(HttpContext context)
        {
            String canned = context.Request.Headers[XCANNEDHEADER];  //check if we have a canned header.
            return (
                !String.IsNullOrEmpty(canned) 
                && (String.CompareOrdinal(canned.ToLower(System.Globalization.CultureInfo.CurrentUICulture).Trim(), "true") == 0)
                && config.GetBoolSetting(Settings.AvatarCloset_EnableCannedAssets)
                ); //check if its true. Anything other than true is false
        }
        
        private ClosetAssets CreateCanned()
        {
            ClosetAssets assets = new ClosetAssets();
            assets.assets = new Asset[4];
            for (Int32 count = 0; count < 4; count++)
            {
                Asset asset = new Asset();
                asset.id = Guid.NewGuid().ToString();
                asset.title = "Canned Asset " + count;
                asset.description = "Canned Asset" ;
                assets.assets[count] = asset;
            }

            return assets;

        }

        private UInt32 GetPlatformTypeFromHeader()
        {
            HttpContext currentContext = HttpContext.Current;
            String platformTypeString = currentContext.Request.Headers[XPLATFORMTYPE];
            UInt32 platformType = 0;

            if (String.IsNullOrEmpty(platformTypeString)
                || !UInt32.TryParse(platformTypeString, out platformType))
            {
                return 0;
            }

            return platformType;
        }

        private UInt32 GetTitleID()
        {
            UInt32 titleID = 0;

            if (!TokenClaimsHelper.TryGetTokenTitleID(out titleID))
            {
                return 0;
            }

            return titleID;
        }

        private String ResolveUserAccountLocale(UInt64 xuid)
        {
            IAccountCreationDataAccess lcAccountCreation = Container.Instance.GetComponent<IAccountCreationDataAccess>();
            
            Account userAccount = lcAccountCreation.GetAccount(xuid);

            String userLocale = String.Empty;

            if (!XboxLiveLocaleHelper.TryGetSupportedLocale((UInt16)userAccount.CountryId, userAccount.LanguageId, out userLocale))
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.InternalServerError, "CountryID and LanguageID not supported",
                    new ClosetAssets(),
                    null);

                //not supported locale
                Logging.TraceException(wpEx, "CountryID: {0} and LanguageID: {1} not supported", userAccount.CountryId, userAccount.LanguageId);
                throw wpEx;
            }

            return userLocale;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Library\Diagnostics\Events.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Leet.Core.Diagnostics;
using Leet.Live.Livecache.Logic.Exceptions;

namespace Avatar.Services.Closet.Library.Diagnostics
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Pvt")]
    public class AvatarClosetPvtStartupEvent : BaseEvent
    {
        public AvatarClosetPvtStartupEvent() :
            base(4200, TraceEventType.Start, "The Avatar Closet (private) Service has started")
        { }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Pvt")]
    public class AvatarClosetPvtShutdownEvent : BaseEvent
    {
        public AvatarClosetPvtShutdownEvent() :
            base(4201, TraceEventType.Stop, "The Avatar Closet (private) Service has stopped")
        { }
    }

    public class AvatarClosetPartStartupEvent : BaseEvent
    {
        public AvatarClosetPartStartupEvent() :
            base(4202, TraceEventType.Start, "The Avatar Closet (partner) Service has started")
        { }
    }

    public class AvatarClosetPartShutdownEvent : BaseEvent
    {
        public AvatarClosetPartShutdownEvent() :
            base(4203, TraceEventType.Stop, "The Avatar Closet (partner) Service has stopped")
        { }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Lc")]
    public class AvatarClosetLcExceptionEvent : BaseEvent
    {
        public AvatarClosetLcExceptionEvent()
            : base(4210, TraceEventType.Error)
        { }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Lc")]
    public class AvatarClosetLcConfigErrorEvent : BaseEvent
    {
        public AvatarClosetLcConfigErrorEvent()
            : base(4211, TraceEventType.Error)
        { }

    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "Lc")]
    public class AvatarClosetLcResponseErrorEvent : BaseEvent
    {
        public AvatarClosetLcResponseErrorEvent()
            : base(4212, TraceEventType.Error)
        { }
    }

    public class AvatarClosetUnknownErrorEvent : BaseEvent
    {
        public AvatarClosetUnknownErrorEvent()
            : base(4215, TraceEventType.Error, "Unknown Error")
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Partner\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Partner\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.Closet.Partner")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
[assembly: System.CLSCompliant(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("163055dd-0be8-46b1-9dd3-be28c2a5c806")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Partner\Global.asax.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Diagnostics;
using Avatar.Services.Closet.Library;
using Avatar.Services.Closet.Library.Diagnostics;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Identity;
using Leet.Identity.PartnerAuth;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Providers;
using Avatar.Services.Common.AssetFiltering;

namespace Avatar.Services.Closet.Partner
{
    public class Global : System.Web.HttpApplication
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_Start(object sender, EventArgs e)
        {
            //Register Providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            ConfigurationSelector.RegisterProvider("avatarsvcs_closet_part", "LEET");
            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("avatarsvcs_closet_part");

            Container.Instance.AddEmulatableService<IAudienceUriProvider, ClosetAudienceUriProvider>();
            AuthenticationManager.RegisterWithIocContainer(Container.Instance);
            
            Container.Instance.AddEmulatableService<IClosetAssetsQueryable, ClosetAssetQuery>();

            ILogging logger = Container.Instance.GetComponent<ILogging>();

            Container.Instance.AddEmulatableService<IBlacklistAssetsManager, BlacklistAssetManager>();
            Container.Instance.AddEmulatableService<IAvatarAssetFilter, AvatarAssetFilter>();
            
            Debug.Assert(logger != null, "logger is null");
            logger.LogEvent(new AvatarClosetPvtStartupEvent());
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_End(object sender, EventArgs e)
        {
            //Log Shutdown Event
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            Debug.Assert(logger != null, "logger is null");
            logger.LogEvent(new AvatarClosetPartShutdownEvent());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Partner\Closet.svc.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.ServiceModel;
using System.ServiceModel.Activation;
using Microsoft.ServiceModel.Web;
using System.Runtime.Serialization;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.Closet.Partner")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Private\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Private", Scope = "namespace", Target = "Avatar.Services.Closet.Private")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Private\Closet.svc.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.ServiceModel;
using System.ServiceModel.Activation;
using Microsoft.ServiceModel.Web;
using System.Runtime.Serialization;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.Closet.Private")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Private\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.Closet.Private")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
[assembly: System.CLSCompliant(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("613d3f2a-1dd1-43c5-8224-90cd82ec622f")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.Private\Global.asax.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.
using System;
using System.Diagnostics;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Identity;
using Leet.Identity.ActiveAuth;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Providers;
using Leet.Live.Livecache.Account;
using Leet.Core.Diagnostics;
using Avatar.Services.Closet.Library;
using Avatar.Services.Closet.Library.Diagnostics;

namespace Avatar.Services.Closet.Private
{
    public class Global : System.Web.HttpApplication
    {
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_Start(object sender, EventArgs e)
        {
            //Register Providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            ConfigurationSelector.RegisterProvider("avatarsvcs_closetpvt", "LEET");
            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("avatarsvcs_closetpvt");
            AuthenticationManager.RegisterWithIocContainer(Container.Instance);
            
           Container.Instance.AddEmulatableService<IClosetAssetsQueryable, ClosetAssetQuery>();

            ILogging logger = Container.Instance.GetComponent<ILogging>();
            Debug.Assert(logger != null, "logger is null");
            logger.LogEvent(new AvatarClosetPvtStartupEvent());
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers")]
        protected void Application_End(object sender, EventArgs e)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            Debug.Assert(logger != null, "logger is null");
            logger.LogEvent(new AvatarClosetPvtShutdownEvent());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.UnitTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.Closet.UnitTests")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Avatar.Services.Common")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Avatar.Services.Common.Diagnostics")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "2#", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#FilterManifest(System.Byte[],Avatar.Services.Common.AvatarAssetFilterMask,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1002:DoNotExposeGenericLists", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#GetBlacklistedAssetIDs()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "IDs", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#GetBlacklistedAssetIDs()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#GetBlacklistedAssetIDs()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#GetSingletonInstance()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "BlackListed", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#IsAssetIDBlackListed(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#IsAssetIDBlackListed(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#TryLoadBlacklistedAssets(System.Int32)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilter.#UpdateTimerCallBack(System.Object)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1714:FlagsEnumsShouldHavePluralNames", Scope = "type", Target = "Avatar.Services.Common.AvatarAssetFilterMask")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ALL", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilterMask.#ALL")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilterMask.#Xuid")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Avatar.Services.Common.AvatarAssetFilterMask.#ConsoleID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Avatar.Services.Common")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Avatar.Services.Common.Diagnostics")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", MessageId = "0#", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilter.#UpdateManifestConsoleID(System.Byte[]&,System.Byte[])")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilter.#UpdateManifestConsoleID(System.Byte[]&,System.Byte[])")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", MessageId = "0#", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilter.#UpdateManifestXuid(System.Byte[]&,System.Byte[])")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilter.#UpdateManifestXuid(System.Byte[]&,System.Byte[])")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilter.#UpdateManifestXuid(System.Byte[]&,System.Byte[])")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1714:FlagsEnumsShouldHavePluralNames", Scope = "type", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilterMask")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ALL", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilterMask.#ALL")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilterMask.#ConsoleID")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Xuid", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.AvatarAssetFilterMask.#Xuid")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.BlacklistAssetManager.#AddAssetsToDictionary(System.String[],System.Collections.Generic.Dictionary`2<System.String,System.Boolean>)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.BlacklistAssetManager.#ResolveLocationToStream(System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.BlacklistAssetManager.#TryLoadBlacklistedAssets(System.Int32)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.BlacklistAssetManager.#UpdateTimerCallBack(System.Object)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1021:AvoidOutParameters", MessageId = "4#", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.IAvatarAssetFilter.#FilterManifest(System.Byte[],Avatar.Services.Common.AssetFiltering.AvatarAssetFilterMask,System.UInt32,System.UInt32,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.IAvatarAssetFilter.#FilterManifest(System.Byte[],Avatar.Services.Common.AssetFiltering.AvatarAssetFilterMask,System.UInt32,System.UInt32,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "BlackListed", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.IAvatarAssetFilter.#IsAssetIDBlackListed(System.String,System.UInt32,System.UInt32)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.IAvatarAssetFilter.#IsAssetIDBlackListed(System.String,System.UInt32,System.UInt32)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ID", Scope = "member", Target = "Avatar.Services.Common.AssetFiltering.IBlacklistAssetsManager.#GetBlacklistAssets(System.UInt32,System.UInt32)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\AssetFiltering\AvatarAssetFilterMask.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.Common.AssetFiltering
{
    [Flags]
    public enum AvatarAssetFilterMask
    {
        None = 0,
        BlacklistedAssets = 2,
        Xuid = 4,
        ConsoleID = 8,
        ALL = BlacklistedAssets | Xuid | ConsoleID
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Closet.UnitTests\AwardedAssetsTests.cs ===
﻿
using System;
using System.Runtime.Serialization;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using Leet.Core.Diagnostics;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.TestUtilities;
using Leet.Live.Livecache.DataAccess;
using Avatar.Services.Closet.Library;
using xonline.common.protocol;
using Asset=Avatar.Services.Closet.Library.Asset;

namespace Avatar.Services.Closet.UnitTests
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class AwardedAssetsTests
    {
       
        public AwardedAssetsTests()
        {
            Container.UseLocalContainer(new Container());
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        public void Closet_TestSerialization()
        {
            ClosetAssets assets = new ClosetAssets();
            assets.assets = new Asset[4];
            for (Int32 count = 0; count < 4; count++)
            {
                Asset asset = new Asset();
                asset.id = new Guid().ToString();
                asset.title = "Canned Asset " + count;
                asset.description = "Canned Asset";
                assets.assets[count] = asset;
            }

            DataContractSerializer sz = new DataContractSerializer(typeof(ClosetAssets));
            System.IO.MemoryStream ms = new System.IO.MemoryStream();
            sz.WriteObject(ms, (object)assets);
            System.IO.StreamReader sr = new System.IO.StreamReader(ms);
            ms.Position = 0;
            String s = sr.ReadToEnd();
            ms.Position = 0;
            ClosetAssets assetsAfter = sz.ReadObject(ms) as ClosetAssets;

            for (Int32 count = 0; count < 4; count++)
            {
                Assert.AreEqual<String>(assets.assets[count].id, assetsAfter.assets[count].id, count + "id");
                Assert.AreEqual<String>(assets.assets[count].title, assetsAfter.assets[count].title, count + "title");
                Assert.AreEqual<String>(assets.assets[count].description, assetsAfter.assets[count].description, count + "description");
            }

            ms.Close();
            
        }

        [TestMethod]
        public void Closet_OnlyAwardedAssets()
        {
            Stubs stubs = RegisterStubs();
            Int32 expectedCount = 2;

            List<AwardedAvatarAsset> list = new List<AwardedAvatarAsset>();
            for(Int32 count = 0; count < expectedCount; count++)
            {
                AwardedAvatarAsset asset = new AwardedAvatarAsset();
                asset.AvatarAssetId = Guid.NewGuid().ToByteArray();
                asset.AvatarAssetOrdinal = (UInt32)count;
                list.Add(asset);
            }
            stubs.SettingsDataAccess.Stub(sd => sd.GetUserAvatarAwards(Arg<UInt64>.Is.Anything, Arg<UInt16>.Is.Anything, 0)).Return(new ReadOnlyCollection<AwardedAvatarAsset>(list));
            stubs.BillingOfferingDataAccess.Stub(bo => bo.GetPurchaseHistory(PurchaseHistoryRequest.CreateAvatarGearPurchaseHistoryRequest(Arg<UInt64>.Is.Anything, "en-us"))).Return(null);

            IClosetAssetsQueryable cq = new ClosetAssetQuery();
            ClosetAssets assets = cq.QueryClosetAssets(14312423423, "en-US", 0, 0);

            Assert.IsNotNull(assets, "assets should not be null");
            Assert.IsNotNull(assets.assets, "assets.assets should not be null");
            Assert.AreEqual<Int32>(assets.assets.Length, expectedCount, "unexpected asset count");
            for (Int32 count = 0; count < expectedCount; count++)
            {
                Assert.AreEqual<String>(new Guid(list[count].AvatarAssetId).ToString(),assets.assets[count].id,"Asset-IDs not equal");
            }
        }

        [TestMethod]
        public void Closet_OnlyAwardedAssetsNULL()
        {
            Stubs stubs = RegisterStubs();
            Int32 expectedCount = 0;

            stubs.SettingsDataAccess.Stub(sd => sd.GetUserAvatarAwards(Arg<UInt64>.Is.Anything, Arg<UInt16>.Is.Anything, 0)).Return(null);
            stubs.BillingOfferingDataAccess.Stub(bo => bo.GetPurchaseHistory(PurchaseHistoryRequest.CreateAvatarGearPurchaseHistoryRequest(Arg<UInt64>.Is.Anything,"en-us"))).Return(null);

            IClosetAssetsQueryable cq = new ClosetAssetQuery();
            ClosetAssets assets = cq.QueryClosetAssets(14312423423, "en-US", 0, 0);

            Assert.IsNotNull(assets, "assets should not be null");
            Assert.IsNotNull(assets.assets, "assets.assets should not be null");
            Assert.AreEqual<Int32>(expectedCount, assets.assets.Length, "unexpected asset count");
        }

        [TestMethod]
        public void Closet_AwardedAndMarketplaceAssets()
        {
            Stubs stubs = RegisterStubs();
            Int32 expectedAwardableCount = 2;
            Int32 expectedMarketPlaceCount = 2;

            List<AwardedAvatarAsset> list = new List<AwardedAvatarAsset>();
            for (Int32 count = 0; count < expectedAwardableCount; count++)
            {
                AwardedAvatarAsset asset = new AwardedAvatarAsset();
                asset.AvatarAssetId = Guid.NewGuid().ToByteArray();
                asset.AvatarAssetOrdinal = (UInt32)count;
                list.Add(asset);
            }
            stubs.SettingsDataAccess.Stub(sd => sd.GetUserAvatarAwards(Arg<UInt64>.Is.Anything, Arg<UInt16>.Is.Anything, 0)).Return(new ReadOnlyCollection<AwardedAvatarAsset>(list));

            List<PurchaseHistoryEntry> listBilling = new List<PurchaseHistoryEntry>();
            for(Int32 count=0;  count < expectedMarketPlaceCount; count++)
            {
                PurchaseHistoryEntry entry = new PurchaseHistoryEntry();
                entry.OfferId = new Guid();
                entry.TheOffer = new PurchaseHistoryEntry.Offer();
                entry.TheOffer.MediaId = new Guid();
                listBilling.Add(entry);
            }

            PurchaseHistoryResponse phResponse = new PurchaseHistoryResponse
            {
                PurchaseHistoryEntries = new ReadOnlyCollection<PurchaseHistoryEntry>(listBilling),
                TotalItems = (UInt32)listBilling.Count
            };

            stubs.BillingOfferingDataAccess.Stub(bo => bo.GetPurchaseHistory(PurchaseHistoryRequest.CreateAvatarGearPurchaseHistoryRequest(Arg<UInt64>.Is.Anything, "en-us"))).Return(phResponse);

            IClosetAssetsQueryable cq = new ClosetAssetQuery();
            ClosetAssets assets = cq.QueryClosetAssets(14312423423, "fr-CA", 0, 0);

            Assert.IsNotNull(assets, "assets should not be null");
            Assert.IsNotNull(assets.assets, "assets.assets should not be null");
            Assert.AreEqual<Int32>(expectedAwardableCount + expectedMarketPlaceCount,assets.assets.Length, "unexpected asset count");

            for (Int32 count = 0; count < expectedAwardableCount; count++)
            {
                Assert.AreEqual<String>(new Guid(list[count].AvatarAssetId).ToString(), assets.assets[count].id, "Asset-IDs not equal");
            }

            for(Int32 count = expectedAwardableCount + 0; count < expectedAwardableCount + expectedMarketPlaceCount; count++)
            {
                Assert.AreEqual<String>(listBilling[count - expectedAwardableCount].TheOffer.MediaId.ToString(), assets.assets[count].id, "Asset Ids for marketplace assets are not equal");
            }
        }

        [TestMethod]
        public void Closet_LocaleTest()
        {
            Stubs stubs = new Stubs { Stubber = new Stubber() };
            stubs.Config = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();
            stubs.Logger = stubs.Stubber.RegisterWithContainer<ILogging>();
            SettingsDataAccessMock mock = new SettingsDataAccessMock();
            IBillingOfferingDataAccess boMock = new BillingOfferingDataAccessMock();
            Container.Instance.AddServiceWithInstance<ISettingsDataAccess>(mock);
            Container.Instance.AddServiceWithInstance<IBillingOfferingDataAccess>(boMock);

            UInt16 expectedLocale = 0;
            IClosetAssetsQueryable cq = new ClosetAssetQuery();

            XBOXLiveLocales.TryGetValue("en-US", out expectedLocale);
            cq.QueryClosetAssets(14312423423, "en-US", 0, 0);
            Assert.AreEqual<UInt16>(expectedLocale, mock.LocaleForLastClosetCall, "Locale id are not equal for en-US");
            cq.QueryClosetAssets(14312423423, "en-us", 0, 0);
            Assert.AreEqual<UInt16>(expectedLocale, mock.LocaleForLastClosetCall, "Locale id are not equal for en-us");
            XBOXLiveLocales.TryGetValue("en-IN", out expectedLocale);
            cq.QueryClosetAssets(1231312312, "en-IN", 0, 0);
            Assert.AreEqual<UInt16>(expectedLocale, mock.LocaleForLastClosetCall, "Locale id are not equal for en-IN");
            cq.QueryClosetAssets(1231312312, "En-In", 0, 0);
            Assert.AreEqual<UInt16>(expectedLocale, mock.LocaleForLastClosetCall, "Locale id are not equal for En-In");
        }

        [TestMethod]
        [ExpectedException(typeof(Microsoft.ServiceModel.Web.WebProtocolException))]
        public void Closet_LocaleNullEmptyTest()
        {
            Stubs stubs = RegisterStubs();
            IClosetAssetsQueryable cq = new ClosetAssetQuery();
            cq.QueryClosetAssets(14312423423, String.Empty, 0, 0);
        }

        [TestMethod]
        [ExpectedException(typeof(Microsoft.ServiceModel.Web.WebProtocolException))]
        public void Closet_LocaleInvalidLengthTest()
        {
            Stubs stubs = RegisterStubs();
            IClosetAssetsQueryable cq = new ClosetAssetQuery();
            cq.QueryClosetAssets(14312423423, "en-uddj", 0, 0);
        }

        [TestMethod]
        [ExpectedException(typeof(Microsoft.ServiceModel.Web.WebProtocolException))]
        public void Closet_LocaleNotSupportedTest()
        {
            //Stubs stubs = new Stubs { Stubber = new Stubber() };
            //stubs.BillingOfferingDataAccess = stubs.Stubber.RegisterWithContainer<IBillingOfferingDataAccess>();
            //stubs.Config = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();
            //stubs.Logger = stubs.Stubber.RegisterWithContainer<ILogging>();
            //stubs.BillingOfferingDataAccess.Stub(bo => bo.GetPurchaseHistory(Arg<UInt64>.Is.Anything, "en-us")).Return(null);
            // SettingsDataAccessMock mock = new SettingsDataAccessMock();
            //Container.Instance.AddServiceWithInstance<ISettingsDataAccess>(mock);

            Stubs stubs = RegisterStubs();
            IClosetAssetsQueryable cq = new ClosetAssetQuery();
            cq.QueryClosetAssets(14312423423, "bl-AH", 0, 0);
        }

        #region Helper Methods
        private static Stubs RegisterStubs()
        {
            Stubs stubs = new Stubs { Stubber = new Stubber() };
            stubs.SettingsDataAccess = stubs.Stubber.RegisterWithContainer<ISettingsDataAccess>();
            stubs.BillingOfferingDataAccess = stubs.Stubber.RegisterWithContainer<IBillingOfferingDataAccess>();
            stubs.Config = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();
            stubs.Logger = stubs.Stubber.RegisterWithContainer<ILogging>();
            return stubs;
        }

        private class Stubs
        {
            public Stubber Stubber;
            public ILogging Logger;
            public IConfigurationProvider Config;
            public IBillingOfferingDataAccess BillingOfferingDataAccess;
            public ISettingsDataAccess SettingsDataAccess;
        }
        /// <summary>
        /// XBOX Live user locales and LCID Mappings
        /// </summary>
        static readonly Dictionary<String, UInt16> XBOXLiveLocales = new Dictionary<string, ushort>(StringComparer.OrdinalIgnoreCase)
        {
            {"cs-CZ",  1029},
            {"da-DK",  1030},
            {"de-AT", 3079 },
            {"de-CH", 2055 },
            {"de-DE", 1031 },
            {"el-GR",  1032},
            {"en-AE",  1033},
            {"en-AU", 3081 },
            {"en-CA", 4105 },
            {"en-GB", 2057 },
            {"en-HK", 15369 },
            {"en-IE", 6153 },
            {"en-IN", 16393 },
            {"en-NZ", 5129 },
            {"en-SG", 18441 },
            {"en-US", 1033 },
            {"en-ZA",  7177},
            {"es-CL",  13322},
            {"es-CO",  9226},
            {"es-ES", 3082 },
            {"es-MX", 2058 },
            {"es-US",  21514},
            {"fi-FI", 1035},
            {"fr-BE", 2060 },
            {"fr-CA", 3084 },
            {"fr-CH", 4108 },
            {"fr-FR", 1036 },
            {"hu-HU",  1038},
            {"it-IT", 1040 },
            {"ja-JP",  1041},
            {"ko-KR",  1042},
            {"nl-BE",   2067},
            {"nl-NL",  1043},
            {"nb-NO",  1044},
            {"pl-PL",  1045},
            {"pt-PT",  2070},
            {"ru-RU",  1049},
            {"sv-SE", 1053},
            {"sk-SK",  1051},
            {"zh-CN",  2052},
            {"zh-HK",  3076},
            {"zh-SG",  4100},
            {"zh-TW",  1028}
        };
        
        #endregion
    }
       
    public class SettingsDataAccessMock : ISettingsDataAccess
    {

        public UInt16 LocaleForLastClosetCall { get; set; }

        #region ISettingsDataAccess Members

        public void LoadSettings(xonline.common.protocol.ReadSettingsResponse readResp, Leet.Live.Livecache.Logic.Profile.IGamerProfile profile, Leet.Live.Livecache.Logic.Profile.IWebPreferences webPreferences)
        {
            throw new NotImplementedException();
        }

        public Leet.Live.Livecache.Logic.Profile.IGamerProfile[] LoadSettings(xonline.common.protocol.ReadSettingsResponse readResp)
        {
            throw new NotImplementedException();
        }

        public xonline.common.protocol.ReadSettingsResponse[] ReadProfileSettings(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings)
        {
            throw new NotImplementedException();
        }

        public SaveSettingsResponse SyncSettings(ulong callingLivepuid, Leet.Live.Livecache.Logic.Profile.ProfileSetting[] settings)
        {
            throw new NotImplementedException();
        }

        public Leet.Live.Livecache.Logic.Profile.IGamerProfile GetGamerProfile(ulong callingLivepuid, ulong targetLivepuid)
        {
            throw new NotImplementedException();
        }

        public Leet.Live.Livecache.Logic.Profile.IGamerProfile GetGamerProfile(string gamertag, ulong callingLivepuid, ulong targetLivepuid)
        {
            throw new NotImplementedException();
        }

        public Leet.Live.Livecache.Logic.Profile.IGamerProfile GetPublicGamerProfile(ulong targetLivepuid)
        {
            throw new NotImplementedException();
        }

        public Leet.Live.Livecache.Logic.Profile.IGamerProfile GetPublicGamerProfile(string gamertag, ulong targetLivepuid)
        {
            throw new NotImplementedException();
        }

        public Leet.Live.Livecache.Logic.Profile.IGamerProfile[] GetGamerProfilesBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            throw new NotImplementedException();
        }

        public Dictionary<ulong, Leet.Live.Livecache.Logic.Profile.IGamerProfile> GetGamerProfileCollectionBySetting(ulong callingLivepuid, ulong[] targetLivepuids, uint[] settings, bool getGamertag)
        {
            throw new NotImplementedException();
        }

        public ReadOnlyCollection<AwardedAvatarAsset> GetUserAvatarAwards(ulong livePuid, ushort localeId, uint titleID)
        {
            this.LocaleForLastClosetCall = localeId;
            return null;
        }

        public void SaveSettings(Leet.Live.Livecache.Logic.Profile.IGamerProfile profile, Leet.Live.Livecache.Logic.Profile.IWebPreferences preferences, string locale)
        {
            throw new NotImplementedException();
        }

        public void SaveGamerProfile(Leet.Live.Livecache.Logic.Profile.IGamerProfile profile, string locale)
        {
            throw new NotImplementedException();
        }


        #endregion

        
    }

    public class BillingOfferingDataAccessMock : IBillingOfferingDataAccess
    {
        #region IBillingOfferingDataAccess Members

        public EnumerateAssetsResponse EnumerateAssets(EnumerateAssetsRequest request)
        {
            throw new NotImplementedException();
        }

        public PurchaseHistoryResponse GetPurchaseHistory(PurchaseHistoryRequest request)
        {
            ReadOnlyCollection<PurchaseHistoryEntry> collectionToReturn = new ReadOnlyCollection<PurchaseHistoryEntry>(new List<PurchaseHistoryEntry>());
            return new PurchaseHistoryResponse
            {
                TotalItems = (UInt32)collectionToReturn.Count,
                PurchaseHistoryEntries = collectionToReturn
            };
        }

        public uint GetPointsBalance(ulong xuid)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseMediaOfferWithPoints(ulong xuid, Guid offerId, uint points, int mediaType, uint store, Guid transactionId)
        {
            throw new NotImplementedException();
        }

        public uint PurchaseMediaOfferWithToken(ulong xuid, Guid offerId, uint points, int mediaType, uint store, string token, Guid transactionId)
        {
            throw new NotImplementedException();
        }

        public MediaInstanceUrl[] GetMediaInstanceUrls(Guid[] mediaInstanceId)
        {
            throw new NotImplementedException();
        }

        public uint VerifyToken(ulong livePuid, string token, uint storeId, out ushort offerCatalogType, out Guid emsOfferId, out Guid mediaId, out uint mediaType, out ulong xboxOfferId, out uint xboxOfferType)
        {
            throw new NotImplementedException();
        }

        public void AssetConsume(ulong livePuid, uint titleId, Guid trackingGuid, xonline.common.protocol.Asset[] assetsToConsume)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns the available offers.
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        public ContentEnumerateResponse EnumerateContent(ContentEnumerateRequest request)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns 0 if the purchase successful, hresult error code if fails.
        /// </summary>
        /// <param name="purchaseReq"></param>
        /// <returns></returns>
        public uint PurchaseGamertag(XeOfferPurchaseGamertagRequest purchaseReq)
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\XboxLiveLocaleHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.Common
{
    public static class XboxLiveLocaleHelper
    {
        /// <summary>
        /// Gets locale based on live cache defined country id and language id.
        /// The country id is mapped in the t_countries table in Platform NPDB.
        /// The language id is mapped in the t_languages table in Platform NPDB
        /// </summary>
        /// <param name="countryId"></param>
        /// <param name="languageId"></param>
        /// <param name="locale"></param>
        /// <returns>true if the country id and language id map to a supported loacale. false otherwise</returns>
        public static bool TryGetSupportedLocale(UInt16 countryId, UInt16 languageId, out String locale)
        {
            return CountryIDLanguageIDToLocaleMapping.TryGetValue(languageId.ToString(System.Globalization.CultureInfo.CurrentUICulture) 
                + "_" +
                countryId.ToString(System.Globalization.CultureInfo.CurrentUICulture), out locale);
        }

        /// <summary>
        /// Returns true if a user locale is supported else false
        /// </summary>
        /// <param name="userLocale"></param>
        /// <returns></returns>
        public static bool IsLocaleSupported(String userLocale)
        {
            return CountryIDLanguageIDToLocaleMapping.Values.Contains<String>(userLocale);
        }

        /// XBOX Live user locales and LCID Mappings
        /// </summary>
        static readonly Dictionary<String, String> CountryIDLanguageIDToLocaleMapping = new Dictionary<String, String>(StringComparer.OrdinalIgnoreCase)
            {
                {"18_23", "cs-CZ"}, 
                {"13_25", "da-DK"}, 
                {"3_5", "de-AT"}, 
                {"3_18","de-CH"},
                {"3_24", "de-DE"},
                {"19_37","el-GR"},
                {"1_1", "en-AE"},
                {"1_6", "en-AU"},
                {"1_16", "en-CA"},
                {"1_35", "en-GB"},
                {"1_39", "en-HK"},
                {"1_44", "en-IE"},
                {"1_46", "en-IN"},
                {"1_76", "en-NZ"},
                {"1_91", "en-SG"},
                {"1_103", "en-US"},
                {"1_109", "en-ZA"},
                {"5_19",  "es-CL"},
                {"5_21",  "es-CO"},
                {"5_31",  "es-ES"},
                {"5_71",  "es-MX"},
                {"5_103", "es-US"},
                {"14_32", "fi-FI"},
                {"4_8", "fr-BE"},
                {"4_16", "fr-CA"},
                {"4_18", "fr-CH"},
                {"4_34", "fr-FR"},
                {"20_42", "hu-HU"},
                {"6_50", "it-IT"},
                {"2_53", "ja-JP"},
                {"7_56", "ko-KR"},
                {"16_8", "nl-BE"},
                {"16_74","nl-NL"},
                {"15_75", "nb-NO"},
                {"11_82", "pl-PL"},
                {"9_84", "pt-PT"},
                {"9_13", "pt-BR"}, //added new for Mango
                {"12_88", "ru-RU"},
                {"17_90", "sv-SE"},
                {"1_93", "en-SK"},
                {"8_20", "zh-CN"},
                {"8_39", "zh-HK"},
                {"8_91", "zh-SG"},
                {"8_101", "zh-TW"}, 
                /*
                 TODO: Fix this issue by using LiveCache call GetUserAuthorization and pulling the LCID. Where it could be compared against a pseudo-LCID we already have defined.
                 These have been added in an effort to support TFS bug 72231:  [WP7] Locales: WP7 is releasing in 11 new countries. Which LiveN needs to add support for.
                 These are being added as there language is not supported by the console. Thus they're language is getting shifted to en. 
                 This fix is used to convert the en-[Country] back to the real language and country
                */
                {"1_23", "cs-CZ"},
                {"1_25", "da-DK"},
                {"1_8", "nl-BE"}, 
                {"1_74", "nl-NL"},
                {"1_32", "fi-FI"},
                {"1_37", "el-GR"},
                {"1_42", "hu-HU"},
                {"1_75", "nb-NO"},
                {"1_90", "sv-SE"}
            };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\AssetFiltering\AvatarAssetFilter.cs ===
﻿using System;
using System.Threading;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Collections.Generic;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.Avatars.Internal;
using Microsoft.XboxLive.Avatars.Internal.Assets;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;
using Avatar.Services.Common.Diagnostics;

namespace Avatar.Services.Common.AssetFiltering
{
    /// <summary>
    /// Singleton class that
    /// 1. Loads the black listed assets from the configured xml file. The file path to be loaded will be in the NPDB setting lest_AvatarAssetFilterFileFullPath
    /// 2. Filters the blacklisted assets, xuid and consoleid from the manifest
    /// 3. Starts a timer that fires every configured interval and reloads the new black listed asset file. NPDB setting lest_AvatarAssetFilterUpdateIntervalInHours
    /// </summary>
    [SingletonInstance]
    public sealed class AvatarAssetFilter : IAvatarAssetFilter, IDisposable
    {
        private bool disposed;
        IBlacklistAssetsManager assetManager;
        
        /// <summary>
        /// ctor
        /// </summary>
        public AvatarAssetFilter(IBlacklistAssetsManager blacklistAssetManager)
        {
            this.assetManager = blacklistAssetManager;
        }

        /// <summary>
        /// Filter the given manifest
        /// </summary>
        /// <param name="manifest">manifest as a byte array</param>
        /// <param name="filterMask">Decides what aspects of the manifest to filter</param>
        /// <param name="manifestChanged">true if the manifest has been changed. Zeroing out Xuid and Console id does not affect this</param>
        /// <returns>Filtered manifest as a byte array</returns>
        /// <exception cref="ArgumentNullException">Manifest parameter is null</exception>
        public Byte[] FilterManifest(Byte[] manifest, 
            AvatarAssetFilterMask filterMask, 
            UInt32 platformType, UInt32 titleID, 
            out bool manifestChanged)
        {
            if (manifest == null)
            {
                throw new ArgumentNullException("manifest");
            }

            if (filterMask == AvatarAssetFilterMask.None)
            {
                manifestChanged = false;
                return manifest;
            }

            manifestChanged = false;

            if ((filterMask & AvatarAssetFilterMask.BlacklistedAssets) == AvatarAssetFilterMask.BlacklistedAssets)
            {
                //filter black listed assets. We will use the Tatra avanata manifest editing APIs.
                Microsoft.XboxLive.Avatars.Internal.AvatarManifest avManifest = Microsoft.XboxLive.Avatars.Internal.AvatarManifest.Create(manifest);

                AvatarComponentMasks componentMasksToRemove = GetComponentMasksToRemove(avManifest, platformType, titleID);
                if (componentMasksToRemove != AvatarComponentMasks.None)
                {
                    manifestChanged = avManifest.RemoveComponents(componentMasksToRemove);
                    if (manifestChanged)
                    {
                        //call this twice so we are sure we are wearing default assets and not previous ones
                        avManifest.RemoveComponents(componentMasksToRemove);
                    }
                }
             

                manifest = avManifest.SaveToBinary();
            }

            if ((filterMask & AvatarAssetFilterMask.ConsoleID) == AvatarAssetFilterMask.ConsoleID)
            {
                UpdateManifestConsoleID(ref manifest, null); //zero out the console id
                
            }

            if ((filterMask & AvatarAssetFilterMask.Xuid) == AvatarAssetFilterMask.Xuid)
            {
                UpdateManifestXuid(ref manifest, null); //zero out the xuid
            }

            return manifest;
        }

        /// <summary>
        /// Update manifest xuid section with the passed in xuid
        /// </summary>
        /// <param name="manifest">Manifest</param>
        /// <param name="xuid">If null the the manifest xuid section will be zeroed out</param>
        /// <exception cref="System.ArgumentException">If not null then the length of the xuid array should be 8</exception>
        public static void UpdateManifestXuid(ref byte[] manifest, byte[] xuid)
        {
            if (xuid == null)
            {
                for (Int32 i = 0; i < 8; i++)
                {
                    //xuid id in the manifest starts from byte 0x385 and is 8 bytes long. zero those bytes
                    manifest[0x385 + i] = 0x00;
                }
                return;
            }

            if (xuid.Length != 8)
            {
                throw new ArgumentException("xuid array length should be 8", "xuid");
            }

            for (Int32 i = 0; i < 8; i++)
            {
                //xuid id in the manifest starts from byte 0x385 and is 8 bytes long. zero those bytes
                manifest[0x385 + i] = xuid[i];
            }
        }

        /// <summary>
        /// Update manifest consoleID section with the passed in xuid
        /// </summary>
        /// <param name="manifest">Manifest</param>
        /// <param name="consoleID">If null the the manifest consoleID section will be zeroed out</param>
        /// <exception cref="System.ArgumentException">If not null then the length of the consoleID array should be 5</exception>
        public static void UpdateManifestConsoleID(ref byte[] manifest, byte[] consoleID)
        {
            if (consoleID == null)
            {
                for (Int32 i = 0; i < 5; i++)
                {
                    //console id in the manifest starts from byte 0x380 and is 5 bytes long. zero those bytes
                    manifest[0x380 + i] = 0x00;
                }
                return;
            }

            if (consoleID.Length != 5)
            {
                throw new ArgumentException("consoleID array length should be 5", "consoleID");
            }

            for (Int32 i = 0; i < 5; i++)
            {
                //console id in the manifest starts from byte 0x380 and is 5 bytes long. zero those bytes
                manifest[0x380 + i] = consoleID[i]; ;
            }
        }

        /// <summary>
        /// Removes all existing assets from the manifest and falls back to default assets
        /// Also zeroes out the xuid and the console id from the manifest
        /// </summary>
        /// <param name="manifest">manifest as a byte array</param>
        /// <returns>Filtered manifest as a byte array</returns>
        public Byte[] FilterManifestToDefaultAssets(Byte[] manifest)
        {
            if (manifest == null)
            {
                throw new ArgumentNullException("manifest");
            }

            //filter black listed assets. We will use the Tatra avanata manifest editing APIs.
            Microsoft.XboxLive.Avatars.Internal.AvatarManifest avManifest = Microsoft.XboxLive.Avatars.Internal.AvatarManifest.Create(manifest);
            List<ComponentInfo> avatarComponents = avManifest.GetComponents(AvatarComponentMasks.All);


            AvatarComponentMasks mask = AvatarComponentMasks.None;
            foreach (ComponentInfo info in avatarComponents)
            {
                mask |= info.ComponentMask;
            }

            avManifest.RemoveComponents(mask);
            avManifest.RemoveComponents(mask);

            manifest = avManifest.SaveToBinary();

            //console id in the manifest starts from byte 0x380 and is 5 bytes long. zero those bytes
            for (Int32 i = 0; i < 5; i++)
            {
                manifest[0x380 + i] = 0x00;
            }

            //xuid id in the manifest starts from byte 0x385 and is 8 bytes long. zero those bytes
            for (Int32 i = 0; i < 8; i++)
            {
               
                manifest[0x385 + i] = 0x00;
            }

            return manifest;
        }


        /// <summary>
        /// Checks if the assetID is a blacklisted asset id
        /// </summary>
        /// <param name="assetID">asset id guid string</param>
        /// <returns>true if the assetID is a blacklisted asset id else false</returns>
        public bool IsAssetIDBlackListed(String assetID, UInt32 platformType, UInt32 titleID)
        {
            if (String.IsNullOrEmpty(assetID))
            {
                throw new ArgumentNullException("assetID");
            }

            Dictionary<String, bool> blackListedAssets = this.assetManager.GetBlacklistAssets(platformType, titleID);
            return (blackListedAssets != null && blackListedAssets.ContainsKey(assetID));
        }

        private AvatarComponentMasks GetComponentMasksToRemove(AvatarManifest avManifest, UInt32 platformType, UInt32 titleID)
        {
            Debug.Assert(this.assetManager != null, "this.assetManager != null");
            Dictionary<String, bool> blackListedAssets = this.assetManager.GetBlacklistAssets(platformType, titleID);

            if (blackListedAssets == null)
            {
                //we dont have any assets. Most likely the asset load failed
                return AvatarComponentMasks.None;
            }

            AvatarComponentMasks componentMasksToRemove = AvatarComponentMasks.None;

            List<Microsoft.XboxLive.Avatars.Internal.Assets.ComponentInfo> avatarComponents = avManifest.GetComponents(AvatarComponentMasks.All);
                        
            foreach (Microsoft.XboxLive.Avatars.Internal.Assets.ComponentInfo info in avatarComponents)
            {
                if (blackListedAssets.ContainsKey(info.AssetId.ToString()))
                {
                    componentMasksToRemove |= info.ComponentMask;
                }
            }
            return componentMasksToRemove;
        }

        #region IDisposable Members

        public void Dispose()
        {
            if (!disposed)
            {
                disposed = true;
                if (this.assetManager  != null)
                {
                    this.assetManager.Dispose();
                }
            }
        }

        #endregion
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\AssetFiltering\BlacklistAssetManager.cs ===
﻿using System;
using System.Net;
using System.Xml;
using System.Xml.Serialization;
using System.Diagnostics;
using System.Collections.Generic;
using System.Threading;
using System.Text;
using System.IO;
using Leet.Identity;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;


namespace Avatar.Services.Common.AssetFiltering
{
    enum AssetTargetsType
    {
        Global,
        Platform,
        TitleID
    }

    /// <summary>
    /// Manages the black list assets files/locations
    /// Takes care of regular updating the black list
    /// </summary>
    [SingletonInstance]
    public sealed class BlacklistAssetManager : IBlacklistAssetsManager
    {
        ILogging logger = Container.Instance.GetComponent<ILogging>();
        IConfigurationProvider configProvider = Container.Instance.GetComponent<IConfigurationProvider>();

        bool disposed;
        private String blackListXmlFileFullPath;
        private Timer updateTimer;  //System.Threading timer that will used to update the black list of assets
        Dictionary<UInt32, Dictionary<String, bool>> platformAssets;
        Dictionary<UInt32, Dictionary<String, bool>> titleIDAssets;
        Dictionary<String, bool> globalAssets;

        /// <summary>
        /// ctor
        /// </summary>
        public BlacklistAssetManager()
        {
            blackListXmlFileFullPath = this.configProvider.GetSetting(Settings.AvatarAssetFilterFileFullPath);

            TryLoadBlacklistedAssets(1); //this call will be on user request thread and so we will only attempt once to load the xml file

            bool updateEnabled = this.configProvider.GetBoolSetting(Settings.AvatarAssetFilterEnableUpdate);

            if (updateEnabled)
            {
                //start a timer that will fire every certain configured time interval. We do not want the timer to fire immediately
                Int32 updateIntervalInSeconds = this.configProvider.GetIntSetting(Settings.AvatarAssetFilterUpdateIntervalInSeconds);
                this.updateTimer = new Timer(new TimerCallback(UpdateTimerCallBack), null, TimeSpan.FromSeconds(updateIntervalInSeconds), TimeSpan.FromSeconds(updateIntervalInSeconds));
            }
            else
            {
                Logging.TraceInformation("AvatarAssetFilter: Update is disabled");
            }
        }

        #region IBlacklistAssetsManager Members

        /// <summary>
        /// Gets the blacklisted assets for the titleid and platformType
        /// Titleid > 0 ovverides the platformType. If both are 0 or there are no assets for the platform type and title id then returns global assets
        /// </summary>
        /// <param name="platformType">platform type</param>
        /// <param name="titleID">title id</param>
        /// <returns>Dictionary keyed by asset ids. global assets if none found or if platformType and titleID are both 0</returns>
        public Dictionary<String, bool> GetBlacklistAssets(UInt32 platformType, UInt32 titleID)
        {
            Dictionary<String, bool> targetDictionary = null;
            if (titleID > 0 && this.titleIDAssets != null && this.titleIDAssets.ContainsKey(titleID))
            {
                targetDictionary = this.titleIDAssets[titleID];
            }
            else
            {
                //first fallback to platform assets
                if (platformType > 0 && this.platformAssets != null && this.platformAssets.ContainsKey(platformType))
                {
                    targetDictionary = this.platformAssets[platformType];
                }
                else
                {
                    //last fall back to global assets
                    targetDictionary = this.globalAssets;
                }
            }

            return targetDictionary;
        }

        #endregion

        //Timer call back method. Called in the timer thread
        private void UpdateTimerCallBack(Object state)
        {
            try
            {
                TryLoadBlacklistedAssets(5); //this call will load the new ids and update the cache.
            }
            catch (System.Threading.ThreadAbortException)
            {
                //since this is a timer thread we can reach this situation during application shutdown
            }
            catch
            {
                Debug.Fail("We should not ideally reach here. This is a timer thread. So all exceptions must caught before");
            }
        }

        //Attempt to load the xml file in memory
        //if load fails for some reason(say xml file is being replaced), reattempt after sleeping for 1 second. Try this maxAttemptCount times and return
        //we don't propogate exception here because this is called from non-user request thread (timer thread) except for the first request
        private bool TryLoadBlacklistedAssets(Int32 maxAttemptCount)
        {
            Int32 attemptCount = 1;

            while (attemptCount <= maxAttemptCount)
            {
                try
                {
                    ReadBlacklistAssetsXMLFile();
                    logger.LogEvent(new Diagnostics.BlacklistAssetsFileLoadSuccessEvent());
                    return true;
                }
                catch (Exception ex)
                {
                    if (attemptCount == maxAttemptCount)
                    {
                        //this is the last attempt and it failed. So log
                        logger.LogEvent(new Diagnostics.BlacklistAssetsFileLoadFailureEvent("Failed loading blacklisted assets xml file"), ex);
                    }
                }
                finally
                {
                    attemptCount++;
                }

                Thread.Sleep(1000);
            }

            return false;
        }

        /// <summary>
        /// Read the blacklisted assets from the file/web uri location and deseralize it
        /// </summary>
        private void ReadBlacklistAssetsXMLFile()
        {
            BlackListedAssets allAssets = null;
            using (Stream stream = ResolveLocationToStream(this.blackListXmlFileFullPath))
            {
                ///open it in read only mode
                XmlSerializer sz = new XmlSerializer(typeof(BlackListedAssets));
                allAssets = sz.Deserialize(stream) as BlackListedAssets;
            }

            this.globalAssets = null;
            this.titleIDAssets = null;
            this.platformAssets = null;

            if (allAssets == null || allAssets.Assets == null || allAssets.Assets.Length == 0)
            {
                return;
            }

            Dictionary<UInt32, Dictionary<String, bool>> localPlatformAssets = new Dictionary<UInt32, Dictionary<String, bool>>(10);
            Dictionary<UInt32, Dictionary<String, bool>> localTitleIDAssets = new Dictionary<UInt32, Dictionary<String, bool>>(10);
            Dictionary<String, bool> localGlobalAssets = new Dictionary<String, bool>(1000);

            foreach (Assets assets in allAssets.Assets)
            {
                AssetTargetsType currentTargetType = (AssetTargetsType)(Enum.Parse(typeof(AssetTargetsType), assets.target, true));
                switch (currentTargetType)
                {
                    case AssetTargetsType.Global:
                        {
                            AddAssetsToDictionary(assets.AssetID, localGlobalAssets);
                            this.globalAssets = localGlobalAssets;
                            break;
                        }
                    case AssetTargetsType.Platform:
                        {
                            UInt32 assetIDUInt = 0;
                            if (UInt32.TryParse(assets.value, out assetIDUInt))
                            {
                                AddAssetsToDictionary(assetIDUInt, assets.AssetID, localPlatformAssets);
                                this.platformAssets = localPlatformAssets;
                            }

                            break;
                        }
                    case AssetTargetsType.TitleID:
                        {
                            UInt32 assetIDUInt = 0;
                            if (UInt32.TryParse(assets.value, out assetIDUInt))
                            {
                                AddAssetsToDictionary(assetIDUInt, assets.AssetID, localTitleIDAssets);
                                this.titleIDAssets = localTitleIDAssets;
                            }

                            break;
                        }
                    default:
                        {
                            //not supported do nothing
                            break;
                        }
                }
            }
        }

        /// <summary>
        /// Resolve the location (web or file) to a stream.
        /// It is the responsibility of the caller to close/dispose the stream
        /// </summary>
        private Stream ResolveLocationToStream(String location)
        {
            Uri uri = new Uri(location);
            Stream stream = null;

            switch (uri.Scheme)
            {
                case "http":
                case "https":
                    {
                        WebRequest request = WebRequest.Create(uri);
                        WebResponse response = request.GetResponse();
                        stream = response.GetResponseStream();
                        break;
                    }
                case "file":
                    {
                        stream = File.OpenRead(location);
                        break;
                    }
                default:
                    {
                        throw new ArgumentException(String.Format(System.Globalization.CultureInfo.CurrentUICulture, "Uri {0} scheme not supported", location));
                    }

            }

            return stream;
        }

        private void AddAssetsToDictionary(String[] assetIDs, Dictionary<String, bool> dictionary)
        {
            Debug.Assert(dictionary != null, "dictionary != null");
            if (assetIDs == null)
            {
                return;
            }

            foreach (String assetID in assetIDs)
            {
                if (!dictionary.ContainsKey(assetID))
                {
                    dictionary.Add(assetID.ToLower(System.Globalization.CultureInfo.CurrentUICulture), true);
                }
            }
        }

        private void AddAssetsToDictionary(UInt32 targetID, String[] assetIDs, Dictionary<UInt32, Dictionary<String, bool>> dictionary)
        {
            Debug.Assert(dictionary != null, "dictionary != null");
            Dictionary<String, bool> targetDictionary = null;
            if (!dictionary.TryGetValue(targetID, out targetDictionary))
            {
                targetDictionary = new Dictionary<String, bool>(100);
                dictionary.Add(targetID, targetDictionary);
            }

            AddAssetsToDictionary(assetIDs, targetDictionary);
        }
             
        #region IDisposable Members

        public void Dispose()
        {
            if (!disposed)
            {
                disposed = true;
                //we only have the timer to dispose
                if (this.updateTimer != null)
                {
                    this.updateTimer.Dispose();
                }
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\AssetFiltering\BlacklistedAssets.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.Common.AssetFiltering
{
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "http://xboxlive/avatar/BlacklistedAssets.xsd/")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://xboxlive/avatar/BlacklistedAssets.xsd/", IsNullable = false)]
    public partial class BlackListedAssets
    {

        private Assets[] assetsField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Assets")]
        public Assets[] Assets
        {
            get
            {
                return this.assetsField;
            }
            set
            {
                this.assetsField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "2.0.50727.3038")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "http://xboxlive/avatar/BlacklistedAssets.xsd/")]
    public partial class Assets
    {

        private string[] assetIDField;

        private string targetField;

        private string valueField;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AssetID")]
        public string[] AssetID
        {
            get
            {
                return this.assetIDField;
            }
            set
            {
                this.assetIDField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string target
        {
            get
            {
                return this.targetField;
            }
            set
            {
                this.targetField = value;
            }
        }

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string value
        {
            get
            {
                return this.valueField;
            }
            set
            {
                this.valueField = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\AssetFiltering\IAvatarAssetFilter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.Common.AssetFiltering
{
    public interface IAvatarAssetFilter
    {
        /// <summary>
        /// Filter the given manifest
        /// </summary>
        /// <param name="manifest">manifest as a byte array</param>
        /// <param name="filterMask">Decides what aspects of the manifest to filter</param>
        /// <param name="platformType">0 indicates ignore parameter</param>
        /// <param name="titleID">0 indicates ignore parameter</param>
        /// <param name="manifestChanged">true if the manifest has been changed. Zeroing out Xuid and Console id does not affect this</param>
        /// <returns>Filtered manifest as a byte array</returns>
        /// <exception cref="ArgumentNullException">Maifest parameter is null</exception>
        Byte[] FilterManifest(Byte[] manifest, 
            AvatarAssetFilterMask filterMask, 
            UInt32 platformType, UInt32 titleID,
            out bool manifestChanged);

        /// <summary>
        /// Filter the given manifest to bare minimum default assets
        /// </summary>
        /// <exception cref="ArgumentNullException">Maifest parameter is null</exception>
        Byte[] FilterManifestToDefaultAssets(Byte[] manifest);


        /// <summary>
        /// Checks if the assetID is a blacklisted asset id
        /// </summary>
        /// <param name="assetID">asset id guid string</param>
        /// <param name="platformType">0 indicates ignore parameter</param>
        /// <param name="titleID">0 indicates ignore parameter</param>
        /// <returns>true if the assetID is a blacklisted asset id else false</returns>
        bool IsAssetIDBlackListed(String assetID, UInt32 platformType, UInt32 titleID);
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\Diagnostics\Events.cs ===
﻿using System;
using System.Collections.Generic;
using Leet.Core.Diagnostics;
using System.Diagnostics;

namespace Avatar.Services.Common.Diagnostics
{
    public class BlacklistAssetsFileLoadFailureEvent : BaseEvent
    {
        public BlacklistAssetsFileLoadFailureEvent()
            : base(1000, TraceEventType.Critical)
        { }

        //TODO: Fix event ids
        public BlacklistAssetsFileLoadFailureEvent(String message, params Object[] args)
            : base(1000, TraceEventType.Critical, 
            String.Format(System.Globalization.CultureInfo.CurrentUICulture, message, args))
        { }
    }

    public class BlacklistAssetsFileLoadSuccessEvent : BaseEvent
    {
        public BlacklistAssetsFileLoadSuccessEvent()
            : base(1001, TraceEventType.Information, "Black list assets file loaded successfully")
        { }

        //TODO: Fix event ids
        public BlacklistAssetsFileLoadSuccessEvent(String message, params Object[] args)
            : base(1001, TraceEventType.Information,
            String.Format(System.Globalization.CultureInfo.CurrentUICulture, message, args))
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\AssetFiltering\IBlacklistAssetsManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.Common.AssetFiltering
{
    /// <summary>
    /// Manages the retriving and updating black list of assets
    /// </summary>
    public interface IBlacklistAssetsManager : IDisposable
    {
        /// <summary>
        /// Gets the blacklisted assets for the titleid and platformType
        /// Titleid > 0 ovverides the platformType. If both are 0 then returns null
        /// </summary>
        /// <param name="platformType">platform type</param>
        /// <param name="titleID">title id</param>
        /// <returns>Dictionary keyed by asset ids. null if none found or if platformType and titleID are bothe 0</returns>
        Dictionary<String, bool> GetBlacklistAssets(UInt32 platformType, UInt32 titleID);
    }

   

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.Common")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
[assembly: System.CLSCompliant(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Contracts\AvatarManifests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ManifestRead.Library
{
    public class AvatarManifests
    {
        public AvatarManifest[] Manifests { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Contracts\AvatarManifest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ManifestRead.Library
{
    /// <summary>
    /// Avatar Manifest Response
    /// </summary>
    public class AvatarManifest
    {
        /// <summary>
        /// Gamertag
        /// </summary>
        public string Gamertag { get; set; }

        /// <summary>
        /// Raw manifest encoded as a string
        /// </summary>
        public string Manifest { get; set; }

        /// <summary>
        /// If true then the manifest has been filtered of black listed assets
        /// </summary>
        public bool Filtered { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common.UnitTests\AvatarAssetFilteringTests.cs ===
﻿using System;
using System.IO;
using System.Xml;
using System.Threading;
using System.Xml.Serialization;
using System.Collections.Generic;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.XboxLive.Avatars.Internal.Assets;
using Avatar.Services.Common.AssetFiltering;

namespace Avatar.Services.Common.UnitTests
{
    /// <summary>
    /// Summary description for AvatarAssetFilteringTests
    /// </summary>
    [TestClass]
    [DeploymentItem("BlackListedAssets.xml")]
    [DeploymentItem("BlackListedOnlyEmptyPlatformAssets.xml")]
    [DeploymentItem("EmptyBlackListedAssets.xml")]
    [DeploymentItem("BlackListedOnlyTitleIDsAssets.xml")]
    public class AvatarAssetFilteringTests
    {
        static ILogging logger;
        static CustomConfigurationProvider configProvider;
        static String executingDirectory = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);

        private readonly string[] ValidManifests = new string[]
        {
            "000000003F1000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E000040000000000000000000000000000E0002028FAB971F2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "00000000FFF000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E000040000000000000000000000000000E0002028FAB971F2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002"
        };
        static AvatarAssetFilteringTests()
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddServiceWithInstance<IConfigurationProvider>(new CustomConfigurationProvider());
            Container.Instance.AddServiceWithInstance<ILogging>(new EventLogger());

           
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>() as CustomConfigurationProvider;
            configProvider.BoolSettings.Add(Settings.AvatarAssetFilterEnableUpdate, true);
            configProvider.IntSettings.Add(Settings.AvatarAssetFilterUpdateIntervalInSeconds, 1000);
            configProvider.StringSettings.Add(Settings.AvatarAssetFilterFileFullPath, Path.Combine(executingDirectory, "BlackListedAssets.xml"));
        }

        public AvatarAssetFilteringTests()
        {
            
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
    
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestInitialize()]
        public void MyTestInitialize()
        {
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>() as CustomConfigurationProvider;
            configProvider.BoolSettings[Settings.AvatarAssetFilterEnableUpdate] = true;
            configProvider.IntSettings[Settings.AvatarAssetFilterUpdateIntervalInSeconds] = 1000;
            configProvider.StringSettings[Settings.AvatarAssetFilterFileFullPath] =
                Path.Combine(executingDirectory, "BlackListedAssets.xml");
        }

        [TestMethod]
        public void AssetFilteringAssetManagerLoad()
        {
            logger = Container.Instance.GetComponent<ILogging>();
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>() as CustomConfigurationProvider;

            BlackListedAssets allAssets = null;
            using (FileStream fileStream = File.OpenRead( Path.Combine(executingDirectory, "BlackListedAssets.xml")))
            {
                ///open it in read only mode
                XmlSerializer sz = new XmlSerializer(typeof(BlackListedAssets));
                allAssets = sz.Deserialize(fileStream) as BlackListedAssets;
            }
            List<String> globalAssetIDs = new List<String>();
            List<String> platformAssetIDs = new List<String>();
            List<String> titleIDAssetIDs = new List<String>();

            foreach (Assets assets in allAssets.Assets)
            {
                if (assets.target == "global")
                {
                    foreach (String s in assets.AssetID)
                    {
                        globalAssetIDs.Add(s.ToLower());
                    }
                }
                if (assets.target == "platform")
                {
                    foreach (String ps in assets.AssetID)
                    {
                        platformAssetIDs.Add(ps.ToLower());
                    }
                }

                if (assets.target == "titleid")
                {
                    foreach (String ts in assets.AssetID)
                    {
                        titleIDAssetIDs.Add(ts.ToLower());
                    }
                }
            }


            BlacklistAssetManager blmanager = new BlacklistAssetManager();
            Dictionary<String, bool> dict = null;

            dict = blmanager.GetBlacklistAssets(0, 0); //should return global assets
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            foreach (String key in dict.Keys)
            {
                Assert.IsTrue(globalAssetIDs.Contains(key), "globalAssetIDs");
            }

            dict = blmanager.GetBlacklistAssets(0, 537890);//should return global assets
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            foreach (String key in dict.Keys)
            {
                Assert.IsTrue(globalAssetIDs.Contains(key), "globalAssetIDs");
            }

            dict = blmanager.GetBlacklistAssets(500, 0);//should return global assets
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            foreach (String key in dict.Keys)
            {
                Assert.IsTrue(globalAssetIDs.Contains(key), "globalAssetIDs");
            }


            dict = blmanager.GetBlacklistAssets(15, 0);
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            foreach (String key in dict.Keys)
            {
                Assert.IsTrue(platformAssetIDs.Contains(key), "platformAssetIDs");
            }

            dict = blmanager.GetBlacklistAssets(5, 0);
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            foreach (String key in dict.Keys)
            {
                Assert.IsTrue(platformAssetIDs.Contains(key), "platformAssetIDs");
            }

            dict = blmanager.GetBlacklistAssets(0, 12345678);
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            foreach (String key in dict.Keys)
            {
                Assert.IsTrue(titleIDAssetIDs.Contains(key), "titleIDAssetIDs");
            }

            dict = blmanager.GetBlacklistAssets(5, 1234789);
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            foreach (String key in dict.Keys)
            {
                Assert.IsTrue(titleIDAssetIDs.Contains(key), "titleIDAssetIDs");
            }


            dict = blmanager.GetBlacklistAssets(15, 777777);
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            foreach (String key in dict.Keys)
            {
                Assert.IsTrue(platformAssetIDs.Contains(key), "platformAssetIDs"); //fallback to platform assets
            }

        }

        [TestMethod]
        public void AssetFilteringNoFileFound()
        {
            logger = Container.Instance.GetComponent<ILogging>();
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>() as CustomConfigurationProvider;

            String nonExistingFilePath = Path.Combine(executingDirectory, "BlackListedAssets_NonExisting.xml");
            if (File.Exists(nonExistingFilePath))
            {
                File.Delete(nonExistingFilePath);
            }

            configProvider.StringSettings[Settings.AvatarAssetFilterFileFullPath]
                = nonExistingFilePath;

            BlacklistAssetManager blManager = new BlacklistAssetManager();
            Assert.IsNull(blManager.GetBlacklistAssets(0, 0), "blManager.GetBlacklistAssets(0, 0) == null");
            Assert.IsNull(blManager.GetBlacklistAssets(15, 0), "blManager.GetBlacklistAssets(0, 0) == null");
            Assert.IsNull(blManager.GetBlacklistAssets(5, 81186212), "blManager.GetBlacklistAssets(0, 0) == null");
        }

        [TestMethod]
        public void AssetFilteringUpdateTimer()
        {
            logger = Container.Instance.GetComponent<ILogging>();
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>() as CustomConfigurationProvider;

            String newFilePath = Path.Combine(executingDirectory, "BlackListedAssets_NewFile.xml");
            if (File.Exists(newFilePath))
            {
                File.Delete(newFilePath);
            }

            configProvider.StringSettings[Settings.AvatarAssetFilterFileFullPath] = newFilePath;
            configProvider.IntSettings[Settings.AvatarAssetFilterUpdateIntervalInSeconds] = 10;

            BlacklistAssetManager blManager = new BlacklistAssetManager();
            Assert.IsNull(blManager.GetBlacklistAssets(0, 0), "blManager.GetBlacklistAssets(0, 0)");

            BlackListedAssets allAssets = null;
            using (FileStream fileStream = File.OpenRead(Path.Combine(executingDirectory, "BlackListedAssets.xml")))
            {
                ///open it in read only mode
                XmlSerializer sz = new XmlSerializer(typeof(BlackListedAssets));
                allAssets = sz.Deserialize(fileStream) as BlackListedAssets;
            }


            using (FileStream fileStream = File.Open(newFilePath, FileMode.CreateNew))
            {
                ///open it in read only mode
                XmlSerializer sz = new XmlSerializer(typeof(BlackListedAssets));
                sz.Serialize(fileStream, allAssets);
            }

            Thread.Sleep(10000);

            try
            {
                Assert.IsTrue(blManager.GetBlacklistAssets(0, 0).Count > 0, "blManager.GetBlacklistAssets(0, 0).Count > 0");
            }
            finally 
            {
                if (File.Exists(newFilePath))
                {
                    File.Delete(newFilePath);
                }
            }


        }

        [TestMethod]
        public void AssetFilteringChangedAssetsOnReload()
        {
            logger = Container.Instance.GetComponent<ILogging>();
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>() as CustomConfigurationProvider;

            String newFilePath = Path.Combine(executingDirectory, "BlackListedAssets.xml");
            if (File.Exists(newFilePath))
            {
                File.Delete(newFilePath);
            }

            configProvider.StringSettings[Settings.AvatarAssetFilterFileFullPath] = newFilePath;
            configProvider.IntSettings[Settings.AvatarAssetFilterUpdateIntervalInSeconds] = 10;

            BlacklistAssetManager blManager = new BlacklistAssetManager();
            Assert.IsNotNull(blManager.GetBlacklistAssets(15, 0), "blManager.GetBlacklistAssets(15, 0)");

            BlackListedAssets allAssets = null;
            using (FileStream fileStream = File.OpenRead(Path.Combine(executingDirectory, "BlackListedOnlyTitleIDsAssets.xml")))
            {
                ///open it in read only mode
                XmlSerializer sz = new XmlSerializer(typeof(BlackListedAssets));
                allAssets = sz.Deserialize(fileStream) as BlackListedAssets;
            }

            Thread.Sleep(10000);

            Assert.IsNull(blManager.GetBlacklistAssets(15, 0), "blManager.GetBlacklistAssets(15, 0)");


        }

        [TestMethod]
        public void AssetFilteringEmptyAndPartialLists()
        {
            logger = Container.Instance.GetComponent<ILogging>();
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>() as CustomConfigurationProvider;
            configProvider.StringSettings[Settings.AvatarAssetFilterFileFullPath] = Path.Combine(executingDirectory, "BlackListedOnlyEmptyPlatformAssets.xml");
            BlacklistAssetManager blmanager = new BlacklistAssetManager();
            Dictionary<String, bool> dict = null;

            dict = blmanager.GetBlacklistAssets(5, 0); //should return no assets
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count == 0);
            dict = blmanager.GetBlacklistAssets(10, 0); //should return no assets
            Assert.IsTrue(dict == null);
            dict = blmanager.GetBlacklistAssets(0, 0); //should return no assets
            Assert.IsTrue(dict == null);


            configProvider.StringSettings[Settings.AvatarAssetFilterFileFullPath] = Path.Combine(executingDirectory, "EmptyBlackListedAssets.xml");
            blmanager = new BlacklistAssetManager();
            dict = blmanager.GetBlacklistAssets(5, 0); //should return no assets
            Assert.IsTrue(dict == null);
            dict = blmanager.GetBlacklistAssets(0, 0); //should return no assets
            Assert.IsTrue(dict == null);
            dict = blmanager.GetBlacklistAssets(0, 777777); //should return no assets
            Assert.IsTrue(dict == null);



            configProvider.StringSettings[Settings.AvatarAssetFilterFileFullPath] = Path.Combine(executingDirectory, "BlackListedOnlyTitleIDsAssets.xml");
            blmanager = new BlacklistAssetManager();
            dict = blmanager.GetBlacklistAssets(0, 12345678); //should return title id assets
            Assert.IsTrue(dict != null);
            Assert.IsTrue(dict.Count > 0);
            dict = blmanager.GetBlacklistAssets(0, 0); //should return no assets
            Assert.IsTrue(dict == null);
            dict = blmanager.GetBlacklistAssets(5, 0); //should return no assets
            Assert.IsTrue(dict == null);
            dict = blmanager.GetBlacklistAssets(0, 7777777); //should return no assets
            Assert.IsTrue(dict == null);
        }
        
        [TestMethod]
        public void AssetFilteringXuidZeroOut()
        {
            byte[] manifestArray = StringToByte(ValidManifests[0]);

            Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor editorNonFiltered =
              new Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor(Microsoft.XboxLive.Avatars.Internal.AvatarManifest.Create(manifestArray), null, null);

            Assert.IsTrue(BitConverter.ToInt64(editorNonFiltered.OwnerXuid, 0) != 0, "editorNonFiltered.OwnerXuid != 0");

            AvatarAssetFilter filter = new AvatarAssetFilter(new BlacklistAssetManager());
            bool manifestFiltered = false;
            byte[] filteredManifest = filter.FilterManifest(manifestArray, AvatarAssetFilterMask.ALL, 0, 0, out manifestFiltered);

             Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor editorFiltered =
                new Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor(Microsoft.XboxLive.Avatars.Internal.AvatarManifest.Create(filteredManifest), null, null);

             Assert.IsTrue(BitConverter.ToInt64(editorFiltered.OwnerXuid, 0) == 0, "editorFiltered.OwnerXuid == 0");
        }

        [TestMethod]
        public void AssetFilteringXuidNewValue()
        {
            byte[] manifestArray = StringToByte(ValidManifests[0]);

            Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor editorNonFiltered =
              new Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor(Microsoft.XboxLive.Avatars.Internal.AvatarManifest.Create(manifestArray), null, null);

            UInt64 newXuidValue = 123456789;
            UInt64 oldXuidValue = BitConverter.ToUInt64(editorNonFiltered.OwnerXuid, 0);
            Assert.IsTrue(oldXuidValue != 0, "oldXuidValue.OwnerXuid != 0");

            AvatarAssetFilter.UpdateManifestXuid(ref manifestArray, BitConverter.GetBytes(newXuidValue)); ;

            Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor editorFiltered =
               new Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor(Microsoft.XboxLive.Avatars.Internal.AvatarManifest.Create(manifestArray), null, null);

            Assert.IsTrue(BitConverter.ToUInt64(editorFiltered.OwnerXuid, 0) == newXuidValue, "BitConverter.ToUInt64(editorFiltered.OwnerXuid, 0) == newXuidValue");
        }

        private byte[] StringToByte(string hexString)
        {
            int numBytes = hexString.Length / 2;
            byte[] bytes = new byte[numBytes];

            for (int i = 0; i < hexString.Length; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(hexString.Substring(i, 2), 16);
            }
            return bytes;

        }
        
        class CustomConfigurationProvider : IConfigurationProvider
        {
            public Dictionary<String, String> StringSettings = new Dictionary<String, String>();
            public Dictionary<String, bool> BoolSettings = new Dictionary<String, bool>();
            public Dictionary<String, Int32> IntSettings = new Dictionary<String, Int32>();

            #region IConfigurationProvider Members

            public event SettingChangedEventHandler SettingChanged;

            public event MultiSettingChangedEventHandler MultiSettingChanged;

            public string GetSetting(string settingName)
            {
                if (StringSettings.ContainsKey(settingName))
                {
                    return StringSettings[settingName];
                }
                else
                {
                    throw new KeyNotFoundException(settingName);
                }
            }

            public bool GetBoolSetting(string settingName)
            {
                if (BoolSettings.ContainsKey(settingName))
                {
                    return BoolSettings[settingName];
                }
                else
                {
                    throw new KeyNotFoundException(settingName);
                }
            }

            public int GetIntSetting(string settingName)
            {
                if (IntSettings.ContainsKey(settingName))
                {
                    return IntSettings[settingName];
                }
                else
                {
                    throw new KeyNotFoundException(settingName);
                }
            }

            public long GetLongSetting(string settingName)
            {
                throw new NotImplementedException();
            }

            public double GetDoubleSetting(string settingName)
            {
                throw new NotImplementedException();
            }

            public string[] GetMultiSetting(string settingName)
            {
                throw new NotImplementedException();
            }

            public string GetConnectionString(string interfaceName)
            {
                throw new NotImplementedException();
            }

            public string GetInterfaceEndpoint(string interfaceName, bool useSecureEndpoint)
            {
                throw new NotImplementedException();
            }

            public string Environment
            {
                get { throw new NotImplementedException(); }
            }

            public string ComponentName
            {
                get { return "Avatar.Services.Common.UnitTests"; }
            }

            public string Server
            {
                get { throw new NotImplementedException(); }
            }

            public IInterfaceInfo GetSingleInterface(string interfaceName)
            {
                throw new NotImplementedException();
            }

            public IInterfaceInfo GetInterface(string computerName, string interfaceName)
            {
                throw new NotImplementedException();
            }

            public IVirtualInterfaceInfo GetVirtualInterface(string interfaceType)
            {
                throw new NotImplementedException();
            }

            public string GetSingleServerForInterface(string interfaceName)
            {
                throw new NotImplementedException();
            }

            #endregion

            public bool DummyMethod()
            {
                if (SettingChanged.GetInvocationList().Length > 0 && MultiSettingChanged.GetInvocationList().Length > 0)
                {
                    return true;
                }

                return false;
            }
        }

        class EventLogger : ILogging
        {
            #region ILogging Members

            public void RegisterMetadata(string name, Func<string> value)
            {
                throw new NotImplementedException();
            }

            public void LogEvent(BaseEvent evt)
            {
                LogEvent(evt, null, String.Empty);
            }

            public void LogEvent(BaseEvent evt, string formattedMessage, params object[] args)
            {
                LogEvent(evt, null, formattedMessage, args);
            }

            public void LogEvent(BaseEvent evt, Exception ex)
            {
                LogEvent(evt, ex, String.Empty);
            }

            public void LogEvent(BaseEvent evt, Exception ex, string formattedMessage, params object[] args)
            {
                if (!String.IsNullOrEmpty(formattedMessage))
                {
                    formattedMessage = String.Format(formattedMessage, args);
                }

                if (ex != null)
                {
                    formattedMessage += ":\n" + ex.ToString();
                }
                if (!String.IsNullOrEmpty(evt.Message))
                {
                    formattedMessage = evt.Message + "\n" + formattedMessage;
                }

                System.Diagnostics.EventLogEntryType entryType = System.Diagnostics.EventLogEntryType.Error;

                if (evt.TraceEventType == System.Diagnostics.TraceEventType.Information)
                {
                    entryType = System.Diagnostics.EventLogEntryType.Information;
                }

                System.Diagnostics.EventLog.WriteEntry("Avatar.Services.Common.UnitTests", 
                    String.Format(formattedMessage, args), entryType);
            }

            public void LogTrace(System.Diagnostics.TraceLevel level, string formattedMessage, params object[] args)
            {
                LogTrace(level, null, formattedMessage, args);
            }

            public void LogTrace(System.Diagnostics.TraceLevel level, Exception ex)
            {
                LogTrace(level, ex, String.Empty);
            }

            public void LogTrace(System.Diagnostics.TraceLevel level, Exception ex, string formattedMessage, params object[] args)
            {
                if(ex != null)
                {
                    formattedMessage = formattedMessage + " " + ex.ToString();
                }

                System.Diagnostics.EventLog.WriteEntry("Avatar.Services.Common.UnitTests:Trace", 
                    String.Format(formattedMessage,args), System.Diagnostics.EventLogEntryType.Information);
            }

            public void LogTransaction(string transactionId, string transactionType, string action)
            {
                throw new NotImplementedException();
            }

            public void LogTransaction(string transactionId, string transactionType, string action, string formattedMessage, params object[] args)
            {
                throw new NotImplementedException();
            }

            #endregion
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Contracts\UpdateGamerPicRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ManifestWrite.Library
{
    public class UpdateGamerPicRequest
    {
        public Guid AnimationId { get; set; }
        public float Frame { get; set; }
        public bool UseProp { get; set; }
        public float OffsetX { get; set; }
        public float OffsetY { get; set; }
        public float OffsetZ { get; set; }
        public float RotationY { get; set; }
        public int Background { get; set; }
        public float FieldOfView { get; set; }
        public int FocalJoint { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Common.UnitTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.Common.UnitTests")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Contracts\UpdateGamerPicResponse.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ManifestWrite.Library
{
    public class UpdateGamerPicResponse
    {
        public int SuccessCode { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Contracts\UpdateManifestRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ManifestWrite.Library
{
    public class UpdateManifestRequest
    {
        public string Manifest { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Contracts\ClosetAssets.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Runtime.Serialization;

namespace Avatar.Services.Closet.Library
{
    //Models the Closet Assets XML that the service will return to the client 
    [DataContract(Namespace="http://schemas.datacontract.org/2004/07/Avatar.Services.Closet")]
    public class ClosetAssets
    {
        /// <summary>
        /// Collection of Assets
        /// </summary>
        [DataMember]
        public Asset[] assets;

        /// <summary>
        /// If true then some of the assets have been filtered out
        /// </summary>
        [DataMember]
        public bool Filtered;
    }

    [DataContract(Namespace = "http://schemas.datacontract.org/2004/07/Avatar.Services.Closet")]
    public class Asset
    {
        /// <summary>
        /// Asset id
        /// </summary>
        [DataMember]
        public String id;

        /// <summary>
        /// Asset title
        /// </summary>
        [DataMember]
        public String title;

        /// <summary>
        /// Localized description of the asset
        /// </summary>
        [DataMember]
        public String description;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.Contracts\UpdateManifestResponse.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ManifestWrite.Library
{
    public class UpdateManifestResponse
    {
        public int SuccessCode { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread\IManifestReadService.cs ===
﻿using System;
using System.ServiceModel;
using System.ServiceModel.Activation;
using System.ServiceModel.Web;
using Microsoft.ServiceModel.Web;
using Avatar.Services.ManifestRead.Library;

namespace Avatar.Services.ManifestRead
{
    [ServiceContract]
    public interface IManifestReadService
    {
        [WebHelp(Comment = "Returns a set of avatar manifests for the gamertags passed in")]
        [WebGet(UriTemplate = "?gt={gamertags}&platformType={platformType}&titleID={titleID}")]
        [OperationContract]
        AvatarManifests GetManifest(string gamertags, UInt32 platformType, UInt32 titleID);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread\properties\assemblyinfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatars.Services.ManifestRead")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f0e8c2e2-2a9c-4d9b-8653-b536944872ba")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread\Global.asax.cs ===
﻿using System;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Identity;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Providers;
using Leet.Live.Livecache.Account;
using Leet.Core.Diagnostics;
using Avatar.Services.ManifestRead.Library.Diagnostics;
using Avatar.Services.Common.AssetFiltering;

namespace Avatar.Services.ManifestRead
{
    public class Global : System.Web.HttpApplication
    {

        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            ConfigurationSelector.RegisterProvider("avatarsvcs_manread", "LEET");

            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("avatarsvcs_manread");

            // Manifest read only consumes public APIs, so use anonymous auth to ensure this
            Container.Instance.AddService<ILcAuthManager, AnonymousLcAuthManager>();

            Container.Instance.AddEmulatableService<IBlacklistAssetsManager, BlacklistAssetManager>();
            Container.Instance.AddEmulatableService<IAvatarAssetFilter, AvatarAssetFilter>();

            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(new AvatarManifestReadStartup());
        }

        protected void Application_End(object sender, EventArgs e)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(new AvatarManifestReadShutdown());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestRead.Library\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Avatar.Services.ManifestRead.Library")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Avatar.Services.ManifestRead.Library.Diagnostics")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#ConstructManifestString(System.String,System.UInt64,Leet.Live.Livecache.DataAccess.ISettingsDataAccess,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "gamertags", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1045:DoNotPassTypesByReference", MessageId = "0#", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetNextGamertag(System.String&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Gamertag", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetNextGamertag(System.String&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "gamertags", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetNextGamertag(System.String&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetNextGamertag(System.String&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Perf", Scope = "type", Target = "Avatar.Services.ManifestRead.Library.Diagnostics.PerfCounters")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.Diagnostics.PerfCounters.#LcReadSettingsLatency")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2211:NonConstantFieldsShouldNotBeVisible", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.Diagnostics.PerfCounters.#LcReadSettingsLatencyBase")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "Avatar.Services.ManifestRead.Library")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "gamertag", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String, System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.ManReadAudienceUriProvider.#Config")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "gamertag", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetCannedManifests()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#ConfigProvider")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Puid", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String,System.UInt64,Leet.Live.Livecache.DataAccess.IXCacheDataAccess,Leet.Live.Livecache.DataAccess.ISettingsDataAccess,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "gamertag", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String,System.UInt64,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xuid", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String,System.UInt64,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "xcache", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String,System.UInt64,Leet.Live.Livecache.DataAccess.IXCacheDataAccess,Leet.Live.Livecache.DataAccess.ISettingsDataAccess,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "gamertag", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String,System.UInt64,Leet.Live.Livecache.DataAccess.IXCacheDataAccess,Leet.Live.Livecache.DataAccess.ISettingsDataAccess,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#GetManifests(System.String,System.UInt64,Leet.Live.Livecache.DataAccess.IXCacheDataAccess,Leet.Live.Livecache.DataAccess.ISettingsDataAccess,System.Boolean)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#ConstructManifestString(System.String,System.UInt64,Leet.Live.Livecache.DataAccess.ISettingsDataAccess,System.Boolean,System.Boolean&)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#.cctor()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Scope = "member", Target = "Avatar.Services.ManifestRead.Library.AvatarManifestsFactory.#.cctor()")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestRead.Library\ManReadAudienceUriProvider.cs ===
﻿using System;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Identity;

namespace Avatar.Services.ManifestRead.Library
{
    public class ManReadAudienceUriProvider : IAudienceUriProvider
    {
        private IConfigurationProvider Config
        {
            get
            {
                return Container.Instance.GetComponent<IConfigurationProvider>();
            }
        }

        private string[] audienceUriList;
        public string[] AudienceUriList
        {
            get
            {
                if (audienceUriList == null)
                {
                    string audienceSetting = this.Config.GetSetting(Settings.AvatarManRead_AudienceUri);
                    if (!String.IsNullOrEmpty(audienceSetting))
                    {
                        audienceUriList = audienceSetting.Split(',');
                    }
                }

                return audienceUriList;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestRead.Library\Diagnostics\Events.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.Diagnostics;
using System.Diagnostics;

namespace Avatar.Services.ManifestRead.Library.Diagnostics
{
    //Unauthenticated Read and Read Origin
    public class AvatarManifestReadStartup : BaseEvent
    {
        public AvatarManifestReadStartup() :
            base(4000, TraceEventType.Start, "The Avatar Manifest Read Service has started")
        { }
    }

    public class AvatarManifestReadShutdown : BaseEvent
    {
        public AvatarManifestReadShutdown() :
            base(4001, TraceEventType.Stop, "The Avatar Manifest Read Service has stopped")
        { }
    }

    public class AvatarManifestReadError : BaseEvent
    {
        public AvatarManifestReadError() 
            : base(4010, TraceEventType.Error)
        { }
    }

    public class AvatarManifestReadLCError : BaseEvent
    {
        public AvatarManifestReadLCError()
            : base(4011, TraceEventType.Error)
        { }
    }


    //Authenticated Private
    public class AvatarManifestReadPrivateStartup : BaseEvent
    {
        public AvatarManifestReadPrivateStartup() :
            base(4012, TraceEventType.Start, "The Avatar Manifest Read Private Service has started")
        { }
    }

    public class AvatarManifestReadPrivateShutdown : BaseEvent
    {
        public AvatarManifestReadPrivateShutdown() :
            base(4013, TraceEventType.Stop, "The Avatar Manifest Read Private Service has stopped")
        { }
    }

    public class AvatarManifestReadPrivateError : BaseEvent
    {
        public AvatarManifestReadPrivateError()
            : base(4014, TraceEventType.Error)
        { }
    }


    //Authenticated Partner
    public class AvatarManifestReadPartnerStartup : BaseEvent
    {
        public AvatarManifestReadPartnerStartup() :
            base(4015, TraceEventType.Start, "The Avatar Manifest Read Partner Service has started")
        { }
    }

    public class AvatarManifestReadPartnerShutdown : BaseEvent
    {
        public AvatarManifestReadPartnerShutdown() :
            base(4016, TraceEventType.Stop, "The Avatar Manifest Read Partner Service has stopped")
        { }
    }

    public class AvatarManifestReadPartnerError : BaseEvent
    {
        public AvatarManifestReadPartnerError()
            : base(4017, TraceEventType.Error)
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread\Manifest.svc.cs ===
﻿using System;
using System.Diagnostics;
using System.Web;
using System.Net;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Activation;
using System.ServiceModel.Web;
using Avatar.Services.ManifestRead.Library;
using Avatar.Services.ManifestRead.Library.Diagnostics;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Microsoft.ServiceModel.Web;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.ManifestRead")]

namespace Avatar.Services.ManifestRead
{
    [ServiceBehavior(IncludeExceptionDetailInFaults = false,InstanceContextMode=InstanceContextMode.Single, ConcurrencyMode=ConcurrencyMode.Multiple), 
    AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class ManifestService : IManifestReadService
    {
        ILogging logger;
        IConfigurationProvider configProvider;
        const String XCANNEDHEADER = "X-Canned";

        /// <summary>
        /// ctor
        /// </summary>
        public ManifestService()
        {
            configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
            logger = Container.Instance.GetComponent<ILogging>();
        }

        /// <summary>
        /// Returns a set of avatar manifests in raw, binary stream format as XML.
        /// </summary>
        /// <param name="gamertags">Comma delimited list of gamertags</param>
        /// <returns>AvatarManifests</returns>
        public AvatarManifests GetManifest(string gamertags, UInt32 platformType, UInt32 titleID)
        {
            Debug.Assert(logger != null, "logger");
            Debug.Assert(configProvider != null, "configProvider");
            
            //check if canned is enabled
            if (UseCanned())
            {
                Logging.TraceVerbose("Processing Canned request");
                return AvatarManifestsFactory.GetCannedManifests();
            }

            //set the response to be cached only for an hour
            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "max-age=3600");
            WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.Expires, DateTime.UtcNow.AddHours(1.0).ToString());

            if (configProvider.GetBoolSetting(Settings.LivecacheServiceEnabled))
            {
                AvatarManifests manifests = null;

                if (!String.IsNullOrEmpty(gamertags))
                {
                    try
                    {
                        AvatarManifestsFactory factory = new AvatarManifestsFactory();
                        manifests = factory.GetManifests(gamertags, true, platformType, titleID);
                    }
                    catch (Exception ex)
                    {
                        logger.LogEvent(new AvatarManifestReadError(), ex);
                        manifests = new AvatarManifests();
                    }
                }
                else
                {
                    manifests = new AvatarManifests() { Manifests = new AvatarManifest[0] };
                }

                return manifests;
            }
            else
            {
                Logging.TraceInformation("Manifest Read:  Livecache has been disabled in NPDB.  A request has been rejected.");

                // Livecache has been disabled, so return unavailable
                throw new WebProtocolException(HttpStatusCode.ServiceUnavailable);
            }
        }

        private bool UseCanned()
        {
            HttpContext currentContext = HttpContext.Current;
            String canned = currentContext.Request.Headers[XCANNEDHEADER];  //check if we have a canned header.
            return (
                !String.IsNullOrEmpty(canned)
                && (String.CompareOrdinal(canned.ToLower(System.Globalization.CultureInfo.CurrentUICulture).Trim(), "true") == 0)
                && configProvider.GetBoolSetting(Settings.AvatarManRead_EnableCannedManifest)
                ); //check if its true. Anything other than true is false
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestRead.Library\AvatarManifestsFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text.RegularExpressions;
using Avatar.Services.ManifestRead.Library.Diagnostics;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Live.Livecache;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Avatar.Services.Common.AssetFiltering;

namespace Avatar.Services.ManifestRead.Library
{
    public class AvatarManifestsFactory
    {
        private const string _tempCannedManifest = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000800620001C1C8F109A19CB2E0000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800620001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E0001944FA68F172000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        private static char[] _hexCharacterMap = {'0', '1', '2', '3', '4', '5', '6', '7','8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        private static Regex _gamerTagPattern = new Regex(@"^[A-Za-z](?:[A-Za-z0-9]|\ (?!\ |$)){0,14}$", RegexOptions.Compiled);

        private static ILogging Logging
        {
            get { return Container.Instance.GetComponent<ILogging>(); }
        }

        private static IConfigurationProvider ConfigProvider
        {
            get { return Container.Instance.GetComponent<IConfigurationProvider>();  }
        }
        
        public AvatarManifestsFactory()
        {
           
        }

        public static AvatarManifests GetCannedManifests()
        {
            Dictionary<string, AvatarManifest> manifestList = new Dictionary<string, AvatarManifest>();
            AvatarManifest avatarManifest = new AvatarManifest();
            avatarManifest.Gamertag = "canned";
            avatarManifest.Manifest = _tempCannedManifest;
            manifestList.Add("canned", avatarManifest);

            AvatarManifests manifestCollection = new AvatarManifests();
            manifestCollection.Manifests = new AvatarManifest[manifestList.Values.Count];
            manifestList.Values.CopyTo(manifestCollection.Manifests, 0);

            return manifestCollection;
        }

        /// <summary>
        /// Returns manifest for the passed in gamer tag
        /// </summary>
        /// <param name="gamertag">gamer tag </param>
        /// <param name="xuid">xuid of the user</param>
        /// <param name="getPublicProfile">If true returns the cached public profile. The xuid and console id will be filtered from the manifest returned</param>
        /// <returns>AvatarManifests</returns>
        public AvatarManifests GetManifests(string gamertag, ulong xuid, bool getPublicProfile, UInt32 platformType, UInt32 titleID)
        {
            return GetManifests(gamertag, xuid,
                Container.Instance.GetComponent<IXCacheDataAccess>(),
                Container.Instance.GetComponent<ISettingsDataAccess>(),
                getPublicProfile,platformType, titleID);
        }

        /// <summary>
        /// Returns manifest for the passed in gamer tag
        /// </summary>
        /// <param name="gamertag">gamer tag </param>
        /// <param name="getPublicProfile">If true returns the cached public profile. The xuid and console id will be filtered from the manifest returned</param>
        /// <returns>AvatarManifests</returns>
        public AvatarManifests GetManifests(string gamertag, bool getPublicProfile, UInt32 platformType, UInt32 titleID)
        {
            return GetManifests(gamertag, 0,
                Container.Instance.GetComponent<IXCacheDataAccess>(),
                Container.Instance.GetComponent<ISettingsDataAccess>(),
                getPublicProfile, platformType, titleID);
        }

        /// <summary>
        /// Returns manifest for the passed in gamer tag
        /// </summary>
        /// <param name="gamertag">gamer tag </param>
        /// <param name="livePuid">xuid of the user</param>
        /// <param name="xcacheDA">IXCacheDataAccess</param>
        /// <param name="settingsDA">ISettingsDataAccess</param>
        /// <param name="getPublicProfile">If true returns the cached public profile. The xuid and console id will be filtered from the manifest returned</param>
        /// <returns>AvatarManifests</returns>
        public AvatarManifests GetManifests(string gamertag, ulong livePuid, IXCacheDataAccess xcacheDA,
            ISettingsDataAccess settingsDA, bool getPublicProfile, UInt32 platformType, UInt32 titleID)
        {
            if (xcacheDA == null)
            {
                throw new ArgumentNullException("xcacheDA");
            }

            if (settingsDA == null)
            {
                throw new ArgumentNullException("settingsDA");
            }

            Dictionary<string, AvatarManifest> manifestList = new Dictionary<string, AvatarManifest>(StringComparer.CurrentCultureIgnoreCase);
            if (!String.IsNullOrEmpty(gamertag) && IsGamertagFormatValid(gamertag))
            {
                string officialGamertag = gamertag;
                if (livePuid > 0 || xcacheDA.GetOfficialGamerTag(gamertag.Trim(), out livePuid, out officialGamertag))
                {
                    bool isManifestFiltered = false;
                    // Attempt to retrieve and serialize the user's manifest
                    string serializedManifest = ConstructManifestString(officialGamertag, livePuid, settingsDA, getPublicProfile, platformType, titleID, out isManifestFiltered);

                    if (!String.IsNullOrEmpty(serializedManifest))
                    {
                        AvatarManifest avatarManifest = new AvatarManifest();

                        avatarManifest.Gamertag = officialGamertag;
                        avatarManifest.Manifest = serializedManifest;
                        avatarManifest.Filtered = isManifestFiltered;

                        // Add tag to list so we don't redo if requested multiple times
                        manifestList.Add(officialGamertag, avatarManifest);
                    }
                }
            }

            AvatarManifests manifestCollection = new AvatarManifests();
            manifestCollection.Manifests = new AvatarManifest[manifestList.Values.Count];
            manifestList.Values.CopyTo(manifestCollection.Manifests, 0);

            return manifestCollection;
        }


        /// <summary>
        /// Method will make a Livecache ReadSettings request and parses the byte[] response
        /// into a serialized string to be inluded in the service's response.
        /// </summary>
        /// <param name="livePuid">Xbox LIVE PUID (XUID) of the user</param>
        /// <param name="settingsDA">ISettingsDataAccess interface to be used</param>
        /// <returns>Avatar manifest serialized into a string (byte[] in hex format)</returns>
        private static string ConstructManifestString(string gamertag, ulong livePuid, 
            ISettingsDataAccess settingsDA,
            bool getPublicProfile, UInt32 platformType, UInt32 titleID, out bool isManifestFiltered)
        {
            isManifestFiltered = false;

            string avatarManifest = String.Empty;
            IGamerProfile gamerProfile = null;

            try
            {
                if (getPublicProfile)
                {
                    //get cached public profile
                    gamerProfile = settingsDA.GetPublicGamerProfile(gamertag, livePuid);
                }
                else
                {
                    //get non-cached profile
                    gamerProfile = settingsDA.GetGamerProfile(gamertag, livePuid, livePuid);
                }
            }
            catch(Exception ex)
            {
                Logging.LogEvent(new AvatarManifestReadLCError(), ex);
                gamerProfile = null;
            }


            if (gamerProfile != null)
            {
                byte[] rawManifest = gamerProfile.AvatarManifest;
                
                // WebOnly accounts won't have an avatar manifest
                if (rawManifest != null && rawManifest.Length != 0)
                {
                    //Filter black listed assets from the manifest and zero out consoleID and xuid
                    IAvatarAssetFilter assetFilter = Container.Instance.GetComponent<IAvatarAssetFilter>();
                    rawManifest = assetFilter.FilterManifest(rawManifest, AvatarAssetFilterMask.ALL, platformType, titleID, out isManifestFiltered);
                    
                    char[] man = new char[2000];

                    for (int i = 0; i < 1000; ++i)
                    {
                        // Split each byte of the manifest into the high and low halves, then
                        // convert it to the hex character so it can be serialized into the
                        // expected hex format.  It can then be sliced & diced into the 
                        // asset GUIDs by the renderer.
                        man[i * 2] = _hexCharacterMap[rawManifest[i] >> 4];
                        man[i * 2 + 1] = _hexCharacterMap[rawManifest[i] & 0xF];
                    }

                    avatarManifest = new string(man);
                }
            }

            return avatarManifest;
        }

        /// <summary>
        /// Runs a set of basic validations against the supplied gamertag and returns whether it is
        /// conforms to the standards for an XBL gamertag.  This does not validate that the gamertag
        /// actually exists, only that it fits the proper format.
        /// </summary>
        /// <param name="gamertag">Gamertag to validate</param>
        /// <returns>Boolean indicating that gamertag is valid or not</returns>
        private static bool IsGamertagFormatValid(string gamertag)
        {
            if (String.IsNullOrEmpty(gamertag))
            {
                return false;
            }

            // XONLINE_GAMERTAG_SIZE is the max size for an XBL gamertag
            if (gamertag.Length > LivecacheConstants.XONLINE_NAME_MAX_SIZE)
            {
                return false;
            }

            if (!_gamerTagPattern.IsMatch(gamertag))
            {
                return false;
            }

            return true;
        }
   

        #region Commented code that enables multiple manifests to be parsed and queried for


        /*
        public AvatarManifests GetManifests(string gamertags, IXCacheDataAccess xcacheDA, ISettingsDataAccess settingsDA)
        {
            string currentGamertag = String.Empty;
            string lcaseGamertag = String.Empty;
            ulong livePuid = 0;
            int MAX_MANIFESTS = ConfigProvider.GetIntSetting(Settings.AvatarManRead_MaxManifestsPerRequest);
            bool isCannedManifestOn = ConfigProvider.GetBoolSetting(Settings.AvatarManRead_EnableCannedManifest);

            Dictionary<string, AvatarManifest> manifestList = new Dictionary<string, AvatarManifest>();

            while (gamertags.Length > 0 && manifestList.Count < MAX_MANIFESTS)
            {
                currentGamertag = GetNextGamertag(ref gamertags);

                if (!IsGamertagFormatValid(currentGamertag))
                {
                    continue;
                }

                lcaseGamertag = currentGamertag.ToLower(CultureInfo.InvariantCulture);

                // First, ensure that we have a gamertag and that we haven't seen it already
                if ((currentGamertag.Length != 0) && (!manifestList.ContainsKey(lcaseGamertag)))
                {
                    // Short circuit normal flow if a static manifest is requested
                    if (isCannedManifestOn && (String.Compare(currentGamertag, "canned", StringComparison.OrdinalIgnoreCase) == 0))
                    {
                        AvatarManifest avatarManifest = new AvatarManifest();

                        avatarManifest.Gamertag = currentGamertag;
                        avatarManifest.Manifest = _tempCannedManifest;

                        // Add tag to list so we don't redo if requested multiple times
                        manifestList.Add(lcaseGamertag, avatarManifest);
                    }
                    else if (xcacheDA.GetPuidByGamerTag(currentGamertag, out livePuid))
                    {
                        // Attempt to retrieve and serialize the user's manifest
                        string serializedManifest = ConstructManifestString(currentGamertag, livePuid, settingsDA);

                        if (!String.IsNullOrEmpty(serializedManifest))
                        {
                            AvatarManifest avatarManifest = new AvatarManifest();

                            avatarManifest.Gamertag = currentGamertag;
                            avatarManifest.Manifest = serializedManifest;

                            // Add tag to list so we don't redo if requested multiple times
                            manifestList.Add(lcaseGamertag, avatarManifest);
                        }
                    }
                    else
                    {
                        Logging.LogTrace(LeetTraceLevel.Exceptional, "Unexpected event:  Gamertag '{0}' was not found in XCache", currentGamertag);
                    }
                }
            }

            AvatarManifests manifestCollection = new AvatarManifests();
            manifestCollection.Manifests = new AvatarManifest[manifestList.Values.Count];
            manifestList.Values.CopyTo(manifestCollection.Manifests, 0);

            return manifestCollection;
        }

        public string GetNextGamertag(ref string gamertags)
        {
            string nextGamertag = String.Empty;

            if (!String.IsNullOrEmpty(gamertags))
            {
                int nextComma = gamertags.IndexOf(",", StringComparison.OrdinalIgnoreCase);
                if (nextComma >= 0)
                {
                    nextGamertag = gamertags.Substring(0, nextComma).Trim();
                    gamertags = gamertags.Remove(0, nextComma + 1);
                }
                else if (nextComma == -1)
                {
                    nextGamertag = gamertags.Trim();
                    gamertags = String.Empty;
                }
            }

            return nextGamertag;
        }

        */
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread.Partner\properties\assemblyinfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatars.Services.ManifestRead")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f0e8c2e2-2a9c-4d9b-8653-b536944872ba")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestRead.Library\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.ManifestRead.Library")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("613061ca-dcc5-4724-b3a4-62ac7155ffc4")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread.Partner\IManifestReadService.cs ===
﻿using System;
using System.ServiceModel;
using System.ServiceModel.Activation;
using System.ServiceModel.Web;
using Microsoft.ServiceModel.Web;
using Avatar.Services.ManifestRead.Library;

namespace Avatar.Services.ManifestRead.Partner
{
    [ServiceContract]
    public interface IManifestReadService
    {
        [WebHelp(Comment = "Returns a set of avatar manifests for a user.")]
        [WebGet]
        [OperationContract]
        AvatarManifests GetManifest();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread.Private\properties\assemblyinfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatars.Services.ManifestRead")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f0e8c2e2-2a9c-4d9b-8653-b536944872ba")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread.Partner\Global.asax.cs ===
﻿using System;
using System.Diagnostics;
using Avatar.Services.ManifestRead.Library;
using Avatar.Services.ManifestRead.Library.Diagnostics;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Identity;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Providers;
using Avatar.Services.Common.AssetFiltering;

namespace Avatar.Services.ManifestRead.Partner
{
    public class Global : System.Web.HttpApplication
    {

        protected void Application_Start(object sender, EventArgs e)
        {
            //Register Providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            ConfigurationSelector.RegisterProvider("avatarsvcs_manreadpart", "LEET");

            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("avatarsvcs_manreadpart");

            Container.Instance.AddEmulatableService<IAudienceUriProvider, ManReadAudienceUriProvider>();
            Leet.Identity.PartnerAuth.AuthenticationManager.RegisterWithIocContainer(Container.Instance);

            ILogging logger = Container.Instance.GetComponent<ILogging>();

            Container.Instance.AddEmulatableService<IBlacklistAssetsManager, BlacklistAssetManager>();
            Container.Instance.AddEmulatableService<IAvatarAssetFilter, AvatarAssetFilter>();

            Debug.Assert(logger != null, "logger is null");
            logger.LogEvent(new AvatarManifestReadPartnerStartup());
        }

        protected void Application_End(object sender, EventArgs e)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(new AvatarManifestReadPartnerShutdown());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread.Private\IManifestReadService.cs ===
﻿using System;
using System.ServiceModel;
using System.ServiceModel.Activation;
using System.ServiceModel.Web;
using Microsoft.ServiceModel.Web;
using Avatar.Services.ManifestRead.Library;

namespace Avatar.Services.ManifestRead.Private
{
    [ServiceContract]
    public interface IManifestReadService
    {
        [WebHelp(Comment = "Returns a set of avatar manifests for a user.")]
        [WebGet]
        [OperationContract]
        AvatarManifests GetManifest();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread.Private\Global.asax.cs ===
﻿using System;
using System.Diagnostics;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Providers;
using Leet.Live.Livecache.Account;
using Leet.Core.Diagnostics;
using Leet.Identity;
using Leet.Identity.ActiveAuth;
using Avatar.Services.ManifestRead.Library.Diagnostics;

namespace Avatar.Services.ManifestRead.Private
{
    public class Global : System.Web.HttpApplication
    {

        protected void Application_Start(object sender, EventArgs e)
        {
            //Register Providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            ConfigurationSelector.RegisterProvider("avatarsvcs_manreadpvt", "LEET");

            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("avatarsvcs_manreadpvt");
            AuthenticationManager.RegisterWithIocContainer(Container.Instance);


            ILogging logger = Container.Instance.GetComponent<ILogging>();
            Debug.Assert(logger != null, "logger is null");
            logger.LogEvent(new AvatarManifestReadPrivateStartup());
        }

        protected void Application_End(object sender, EventArgs e)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            logger.LogEvent(new AvatarManifestReadPrivateShutdown());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread.Private\Manifest.svc.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.
using System;
using System.Web;
using System.Diagnostics;
using System.Collections.ObjectModel;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using Microsoft.ServiceModel.Web;
using System.Net;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;
using Leet.Identity;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Exceptions;
using Leet.Live.Livecache.Logic.Profile;
using Avatar.Services.ManifestRead.Library;
using Avatar.Services.ManifestRead.Library.Diagnostics;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.ManifestRead.Private")]

namespace Avatar.Services.ManifestRead.Private
{
    [ServiceBehavior(IncludeExceptionDetailInFaults = false), AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class ManifestService : IManifestReadService
    {
        ILogging logger;
        IConfigurationProvider configProvider;
        const String XLOCALEHEADER = "X-Locale";
        const String XCANNEDHEADER = "X-Canned";

        public ManifestService()
        {
             this.logger = Container.Instance.GetComponent<ILogging>();
             this.configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
        }

        /// <summary>
        /// Returns a set of avatar manifests in raw, binary stream format as XML.
        /// </summary>
        /// <returns>AvatarManifests</returns>
        public AvatarManifests GetManifest()
        {
            Debug.Assert(logger != null, "logger");
            Debug.Assert(configProvider != null, "configProvider");

            logger.LogTrace(LeetTraceLevel.Informational, "Avatar.Services.ManifestRead.Private.IManifestReadService::ManifestService");
            
            //Check authentication. If user is not authenticated we will throw a HTTP 401 Unathorized exception
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();
            Debug.Assert(authManager != null, "authManager");
            if (!authManager.IsAuthenticated)
            {
                logger.LogTrace(LeetTraceLevel.Informational, "Unauthenticated request received");
                throw new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new AvatarManifests(),
                    null);
            }

            //Get the User Identity Object. if no user identity object is received we will throw a HTTP 401 Unauthorized exception
            IUserIdentity callerIdentity = authManager.CurrentUser;
            if (callerIdentity == null)
            {
                logger.LogTrace(LeetTraceLevel.Exceptional, "Authenticated request received, but CurrentUser object is null");
                throw new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new AvatarManifests(),
                    null);
            }

            
            //check if canned is enabled
            if (UseCanned())
            {
                logger.LogTrace(LeetTraceLevel.Verbose, "Processing Canned request");
                return AvatarManifestsFactory.GetCannedManifests();
            }

            if (configProvider.GetBoolSetting(Settings.LivecacheServiceEnabled))
            {
                AvatarManifests manifests = null;

                //Set cache parameters so that client browsers do not cache the responses
                WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
                WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.Expires, DateTime.Now.AddDays(-1).ToString());

                String gamertag  = callerIdentity.Gamertag;

                if (!String.IsNullOrEmpty(gamertag))
                {
                    try
                    {
                        AvatarManifestsFactory factory = new AvatarManifestsFactory();
                        manifests = factory.GetManifests(gamertag, callerIdentity.Xuid, false);
                    }
                    catch (Exception ex)
                    {
                        logger.LogEvent(new AvatarManifestReadPrivateError(), ex);
                        manifests = new AvatarManifests();
                    }
                }
                else
                {
                    manifests = new AvatarManifests() { Manifests = new AvatarManifest[0] };
                }

                return manifests;
            }
            else
            {
                logger.LogTrace(LeetTraceLevel.Informational, "Manifest Read:  Livecache has been disabled in NPDB.  A request has been rejected.");

                // Livecache has been disabled, so return unavailable
                throw new WebProtocolException(HttpStatusCode.ServiceUnavailable);
            }
        }

        private bool UseCanned()
        {
            HttpContext currentContext = HttpContext.Current;
            String canned = currentContext.Request.Headers[XCANNEDHEADER];  //check if we have a canned header.
            return (
                !String.IsNullOrEmpty(canned)
                && (String.CompareOrdinal(canned.ToLower(System.Globalization.CultureInfo.CurrentUICulture).Trim(), "true") == 0)
                && configProvider.GetBoolSetting(Settings.AvatarManRead_EnableCannedManifest)
                ); //check if its true. Anything other than true is false
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\avatar.services.manifestread.Partner\Manifest.svc.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.
using System;
using System.Web;
using System.Diagnostics;
using System.Collections.ObjectModel;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using Microsoft.ServiceModel.Web;
using System.Net;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using Leet.Core.Diagnostics;
using Leet.Utils;
using Leet.Identity;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Exceptions;
using Leet.Live.Livecache.Logic.Profile;
using Avatar.Services.ManifestRead.Library;
using Avatar.Services.ManifestRead.Library.Diagnostics;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.ManifestRead.Partner")]

namespace Avatar.Services.ManifestRead.Partner
{
    [ServiceBehavior(IncludeExceptionDetailInFaults = false, InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple), 
    AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class ManifestService : IManifestReadService
    {
        ILogging logger;
        IConfigurationProvider configProvider;
        const String XLOCALEHEADER = "X-Locale";
        const String XCANNEDHEADER = "X-Canned";
        const String XPLATFORMTYPE= "X-Platform-Type";

        public ManifestService()
        {
             this.logger = Container.Instance.GetComponent<ILogging>();
             this.configProvider = Container.Instance.GetComponent<IConfigurationProvider>();
        }

        /// <summary>
        /// Returns a set of avatar manifests in raw, binary stream format as XML.
        /// </summary>
        /// <returns>AvatarManifests</returns>
        public AvatarManifests GetManifest()
        {
            Debug.Assert(logger != null, "logger");
            Debug.Assert(configProvider != null, "configProvider");

            Logging.TraceVerbose("Avatar.Services.ManifestRead.Partner.IManifestReadService::ManifestService");
            
            //Check authentication. If user is not authenticated we will throw a HTTP 401 Unathorized exception
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();
            Debug.Assert(authManager != null, "authManager");
            if (!authManager.IsAuthenticated)
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new AvatarManifests(),
                    null);

                Logging.TraceException(wpEx, "Unauthenticated request received");
                throw wpEx;
            }

            //Get the User Identity Object. if no user identity object is received we will throw a HTTP 401 Unauthorized exception
            IUserIdentity callerIdentity = authManager.CurrentUser;
            if (callerIdentity == null)
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new AvatarManifests(),
                    null);

                Logging.TraceException(wpEx, "Authenticated request received, but CurrentUser object is null");
                throw wpEx;
            }

            
            //check if canned is enabled
            if (UseCanned())
            {
              Logging.TraceVerbose("Processing Canned request");
                return AvatarManifestsFactory.GetCannedManifests();
            }

            if (configProvider.GetBoolSetting(Settings.LivecacheServiceEnabled))
            {
                AvatarManifests manifests = null;

                //Set cache parameters so that client browsers do not cache the responses
                WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.CacheControl, "no-cache");
                WebOperationContext.Current.OutgoingResponse.Headers.Add(HttpResponseHeader.Expires, DateTime.Now.AddDays(-1).ToString());
               
                String gamertag  = callerIdentity.Gamertag;

                if (!String.IsNullOrEmpty(gamertag))
                {
                    try
                    {
                        AvatarManifestsFactory factory = new AvatarManifestsFactory();
                        manifests = factory.GetManifests(gamertag, callerIdentity.Xuid, false, GetPlatformTypeFromHeader(),GetTitleID());
                    }
                    catch (Exception ex)
                    {
                        logger.LogEvent(new AvatarManifestReadPartnerError(), ex);
                        manifests = new AvatarManifests();
                    }
                }
                else
                {
                    manifests = new AvatarManifests() { Manifests = new AvatarManifest[0] };
                }

                return manifests;
            }
            else
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.ServiceUnavailable);
                Logging.TraceException(wpEx, "Manifest Read:  Livecache has been disabled in NPDB.  A request has been rejected.");

                // Livecache has been disabled, so return unavailable
                throw wpEx;
            }
        }

        private bool UseCanned()
        {
            HttpContext currentContext = HttpContext.Current;
            String canned = currentContext.Request.Headers[XCANNEDHEADER];  //check if we have a canned header.
            return (
                !String.IsNullOrEmpty(canned)
                && (String.CompareOrdinal(canned.ToLower(System.Globalization.CultureInfo.CurrentUICulture).Trim(), "true") == 0)
                && configProvider.GetBoolSetting(Settings.AvatarManRead_EnableCannedManifest)
                ); //check if its true. Anything other than true is false
        }

        private UInt32 GetPlatformTypeFromHeader()
        {
            HttpContext currentContext = HttpContext.Current;
            String platformTypeString = currentContext.Request.Headers[XPLATFORMTYPE];
            UInt32 platformType = 0;

            if (String.IsNullOrEmpty(platformTypeString) 
                || !UInt32.TryParse(platformTypeString, out platformType))
            {
                return 0;
            }

            return platformType;
        }

        private UInt32 GetTitleID()
        {
            UInt32 titleID = 0;
            
            if(!TokenClaimsHelper.TryGetTokenTitleID(out titleID))
            {
                return 0;
            }

            return titleID;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestRead.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.ManifestRead.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5bff8531-823f-472c-8666-52fe3d05e4a0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\GamerPicUpdater.cs ===
﻿using System;
using Avatar.Services.ManifestWrite.Library.Diagnostics;
using Avatar.Services.ServerSideRenderer.Messaging;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Logic.Exceptions;

namespace Avatar.Services.ManifestWrite.Library
{
    public class GamerPicUpdater : IGamerPicUpdaterProvider 
    {
        private const string componentName = "avatarsvcs_manwritepart"; // required for RequestorService 
        private ILogging Logger = null;
        private const int AVATAR_HEAD_JOINT = 19;

        public GamerPicUpdater()
        {
            Logger = Container.Instance.GetComponent<ILogging>();
        }

        public bool UpdateGamerPic(ulong xuid, UpdateGamerPicRequest incomingRequest)
        {
            if (!ValidateMessage(incomingRequest))
            {
                Logging.TraceInformation("Gamerpic request from XUID {0} failed validation.", xuid);
                return false;
            }

            // Update the GenerateGamerPictureMessage properties and send the message to SSR 
            bool wasSuccessful = true;
            try
            {
                // Initialize the requestor service
                RequestorService.Instance.Initialize(componentName);

                // Generate the message and send
                GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();

                message.XUID = xuid;

                message.AnimationId = incomingRequest.AnimationId;
                message.UsePropAnimation = incomingRequest.UseProp;
                message.Frame = incomingRequest.Frame;
                message.OffsetX = incomingRequest.OffsetX;
                message.OffsetY = incomingRequest.OffsetY;
                message.OffsetZ = incomingRequest.OffsetZ;
                message.RotationY = incomingRequest.RotationY;
                message.BackgroundImageId = incomingRequest.Background;
                message.FocalJoint = incomingRequest.FocalJoint;
                message.FieldOfView = incomingRequest.FieldOfView;

                RequestorService.Instance.SendMessage(message);
            }
            catch (LeetLivecacheResponseException ex)
            {
                this.Logger.LogEvent(new Events.AvatarGamerPicUpdateLcException(), ex);
                wasSuccessful = false;
            }
            catch (Exception ex)
            {
                this.Logger.LogEvent(new Events.AvatarGamerPicUpdateException(), ex);
                wasSuccessful = false;
            }
            finally
            {
                Logging.TraceVerbose("GamerPic updater {0} for XUID {1}.", wasSuccessful ? "succeeded" : "failed", xuid);
            }

            return wasSuccessful;
        }

        /// <summary>
        /// Run the message parameters through validation logic and check that camera is within the boundary conditions
        /// </summary>
        /// <returns>true if parameters are valid, false otherwise</returns>
        public bool ValidateMessage(UpdateGamerPicRequest incomingRequest)
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();

            float maxFoV = (float)config.GetDoubleSetting(Settings.AvatarSSRGamerpicMaxFieldOfView);
            float minFoV = (float)config.GetDoubleSetting(Settings.AvatarSSRGamerpicMinFieldOfView);
            float maxXOffset = (float)config.GetDoubleSetting(Settings.AvatarSSRGamerpicMaxXOffset);
            float minXOffset = (float)config.GetDoubleSetting(Settings.AvatarSSRGamerpicMinXOffset);
            float maxYOffset = (float)config.GetDoubleSetting(Settings.AvatarSSRGamerpicMaxYOffset);
            float minYOffset = (float)config.GetDoubleSetting(Settings.AvatarSSRGamerpicMinYOffset);
            float maxZOffset = (float)config.GetDoubleSetting(Settings.AvatarSSRGamerpicMaxZOffset);
            float minZOffset = (float)config.GetDoubleSetting(Settings.AvatarSSRGamerpicMinZOffset);

            if (incomingRequest.FocalJoint != AVATAR_HEAD_JOINT)
                return false;
            if (incomingRequest.FieldOfView < minFoV || incomingRequest.FieldOfView > maxFoV)
                return false;
            if (incomingRequest.OffsetX < minXOffset || incomingRequest.OffsetX > maxXOffset)
                return false;
            if (incomingRequest.OffsetY < minYOffset || incomingRequest.OffsetY > maxYOffset)
                return false;
            if (incomingRequest.OffsetZ < minZOffset || incomingRequest.OffsetZ > maxZOffset)
                return false;

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestRead.Test\Library\AvatarManifests.cs ===
﻿using System;
using Avatar.Services.ManifestRead.Library;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Account;
using Leet.Core.Diagnostics;
using Leet.Live.Livecache.DataAccess;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.protocol;
using xonline.common.webplatform.livecache;

namespace Avatar.Services.ManifestRead.Test
{
    [TestClass]
    [DeploymentItem("BlackListedAssets.xml")]
    public class AvatarManifestTest
    {
        // String (hex) version of the manifest that we'll use to test with
        private const string _testManifest = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000800620001C1C8F109A19CB2E0000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800620001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E0001944FA68F172000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_Manifest_Parsing_And_Factory_Cached()
        {
            const string expectedGamertag = "GamerTag01";
            string expectedManifest = _testManifest;

            byte[] binaryManifest = StringToByte(expectedManifest);

            // Arange
            Stubs stubs = RegisterStubs();
            ReadSettingsResponse response = GetReadSettingsResponse();

            // Stub out the methods on the interfaces we'll be consuming
            stubs.Config.Stub(con => con.GetIntSetting(Settings.AvatarManRead_MaxManifestsPerRequest)).Return(16);
            stubs.XCache.Stub(xc => xc.GetPuidByGamerTag(Arg<string>.Is.Anything, out Arg<ulong>.Out(0).Dummy)).Return(true);
            stubs.AuthDataProvider.Stub(adp => adp.Privileges).Return(new uint[8]);
            stubs.LcStats.Stub(lcs => lcs.PublicReadSettings(
                Arg<ulong>.Is.Anything,
                Arg<uint[]>.Is.Anything,
                out Arg<DateTime>.Out(DateTime.Today).Dummy)).Return(response);

            // Act
            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache, null);
            AvatarManifestsFactory factory = new AvatarManifestsFactory();
            AvatarManifests manifests = factory.GetManifests(expectedGamertag, 0, stubs.XCache, sda, true, 0, 0);

            // Assert
            Assert.IsNotNull(manifests.Manifests);
            Assert.AreEqual(1, manifests.Manifests.Length);
            Assert.AreEqual(expectedGamertag.ToLower(), manifests.Manifests[0].Gamertag.ToLower());
            Assert.AreEqual(expectedManifest, manifests.Manifests[0].Manifest);
        }

        [TestMethod]
        public void Test_Manifest_Parsing_And_Factory_NonCached()
        {
            const string expectedGamertag = "GamerTag01";
            string expectedManifest = _testManifest;

            byte[] binaryManifest = StringToByte(expectedManifest);

            // Arange
            Stubs stubs = RegisterStubs();
            ReadSettingsResponse response = GetReadSettingsResponse();

            // Stub out the methods on the interfaces we'll be consuming
            stubs.Config.Stub(con => con.GetIntSetting(Settings.AvatarManRead_MaxManifestsPerRequest)).Return(16);
            stubs.XCache.Stub(xc => xc.GetPuidByGamerTag(Arg<string>.Is.Anything, out Arg<ulong>.Out(0).Dummy)).Return(true);
            stubs.AuthDataProvider.Stub(adp => adp.Privileges).Return(new uint[8]);
            stubs.LcStats.Stub(lcs => lcs.PublicReadSettings(
                Arg<ulong>.Is.Anything,
                Arg<uint[]>.Is.Anything,
                out Arg<DateTime>.Out(DateTime.Today).Dummy)).Return(response);

            // Act
            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache, null);
            AvatarManifestsFactory factory = new AvatarManifestsFactory();
            AvatarManifests manifests = factory.GetManifests(expectedGamertag, 0, stubs.XCache, sda, false, 0, 0);

            // Assert
            Assert.IsNotNull(manifests.Manifests);
            Assert.AreEqual(1, manifests.Manifests.Length);
            Assert.AreEqual(expectedGamertag.ToLower(), manifests.Manifests[0].Gamertag.ToLower());
            Assert.AreEqual(expectedManifest, manifests.Manifests[0].Manifest);
        }

        [TestMethod]
        public void Test_Max_Gamertag_Size()
        {
            // 16 is max size for a gamertag
            const string expectedGamertag = "ThisGamertagIsWayTooLong01";
            string expectedManifest = _testManifest;

            byte[] binaryManifest = StringToByte(expectedManifest);

            // Arange
            Stubs stubs = RegisterStubs();
            ReadSettingsResponse response = GetReadSettingsResponse();

            // Stub out the methods on the interfaces we'll be consuming
            stubs.Config.Stub(con => con.GetIntSetting(Settings.AvatarManRead_MaxManifestsPerRequest)).Return(16);
            stubs.XCache.Stub(xc => xc.GetPuidByGamerTag(Arg<string>.Is.Anything, out Arg<ulong>.Out(0).Dummy)).Return(true);
            stubs.LcStats.Stub(lcs => lcs.PublicReadSettings(
                Arg<ulong>.Is.Anything,
                Arg<uint[]>.Is.Anything,
                out Arg<DateTime>.Out(DateTime.Today).Dummy)).Return(response);

            // Act
            ISettingsDataAccess sda = new SettingsDataAccess(stubs.LcStats, stubs.AuthDataProvider, stubs.XCache, null);
            AvatarManifestsFactory factory = new AvatarManifestsFactory();
            AvatarManifests manifests = factory.GetManifests(expectedGamertag, 0, stubs.XCache, sda, true, 0, 0);

            // Assert
            Assert.IsNotNull(manifests.Manifests);
            Assert.AreEqual(0, manifests.Manifests.Length);
        }

        [TestMethod]
        public void TestAvatarManifestFilteringPublic()
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILcAuthManager, AnonymousLcAuthManager>();
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            ConfigurationSelector.RegisterProvider("avatarsvcs_manread", "LEET");
            LeetLivecacheClient.RegisterServiceInterfacesAndInitialize("avatarsvcs_manread");

            String gamertag = "supernova15";
            AvatarManifestsFactory factory = new AvatarManifestsFactory();
            AvatarManifests avatarManifests = factory.GetManifests(gamertag, true, 0, 0);
            Assert.IsNotNull(avatarManifests);
            Assert.IsNotNull(avatarManifests.Manifests);
            Assert.IsTrue(avatarManifests.Manifests.Length > 0);
            AvatarManifest manifest = avatarManifests.Manifests[0];
            Assert.IsFalse(manifest.Filtered, "manifest.Filtered");

            byte[] newManifestArray = StringToByte(manifest.Manifest);

            Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor editor =
                new Microsoft.XboxLive.Avatars.Internal.AvatarManifestEditor(Microsoft.XboxLive.Avatars.Internal.AvatarManifest.Create(newManifestArray), null, null);

            Assert.IsTrue(Convert.ToUInt64(editor.OwnerXuid) == 0, "editor.OwnerXuid == 0");
            Assert.IsTrue(Convert.ToUInt64(editor.ConsoleId) == 0, "editor.ConsoleId == 0");
        }

        //[TestMethod]
        //public void TestAvatarManifestFilteringNotPublic()
        //{
        //    Container.Instance.AddService<ILogFormatter, LogFormatter>();
        //    Container.Instance.AddService<ILogging, Logging>();
        //    Container.Instance.AddService<ILcAuthManager, AnonymousLcAuthManager>();
        //    Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
        //    ConfigurationSelector.RegisterProvider("avatarsvcs_manread", "LEET");
        //    LeetLivecacheClient.RegisterServiceInterfacesAndInitialize("avatarsvcs_manread");

        //    String gamertag = "vdtest01";
        //    AvatarManifestsFactory factory = new AvatarManifestsFactory();
        //    AvatarManifest manifest = factory.GetManifests(gamertag, false).Manifests[0];
        //    Assert.IsFalse(manifest.ManifestFiltered, "IsFalse isManifestFiltered");

        //    byte[] newManifestArray = StringToByte(manifest.Manifest);

        //    Microsoft.XboxLive.Avatars.AvatarManifestEditor editor =
        //        new Microsoft.XboxLive.Avatars.AvatarManifestEditor(Microsoft.XboxLive.Avatars.AvatarManifest.Create(newManifestArray), null, null);

        //    Assert.IsTrue(editor.OwnerXuid != 0, "editor.OwnerXuid != 0");
        //    Assert.IsTrue(editor.ConsoleId != 0, "editor.ConsoleId != 0");
        //}

        private ReadSettingsResponse GetReadSettingsResponse()
        {
            // Convert our raw string manifest to the binary array Livecache returns
            byte[] manifest = StringToByte(_testManifest);

            ReadSettingsResponse response = new ReadSettingsResponse();
            response.Settings = new UserSetting[1];

            response.Settings[0] = new UserSetting()
            {
                ValueLen = 1000,
                Value = manifest,
                SettingId = 0x63E80044  // Avatar manifest setting
            };

            return response;
        }

        public static byte[] StringToByte(string hexString)
        {
            int numBytes = hexString.Length / 2;
            byte[] bytes = new byte[numBytes];

            for (int i = 0; i < hexString.Length; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(hexString.Substring(i, 2), 16);
            }
            return bytes;

        }

        private static Stubs RegisterStubs()
        {
            Stubs stubs = new Stubs { Stubber = new Stubber() };
            stubs.LcStats = stubs.Stubber.RegisterWithContainer<ILcStats>();
            stubs.SettingsDA = stubs.Stubber.RegisterWithContainer<ISettingsDataAccess>();
            stubs.XCache = stubs.Stubber.RegisterWithContainer<IXCacheDataAccess>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();
            stubs.Config = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();
            stubs.Logging = stubs.Stubber.RegisterWithContainer<ILogging>();
            return stubs;
        }

        private class Stubs
        {
            public Stubber Stubber;
            public ISettingsDataAccess SettingsDA;
            public IXCacheDataAccess XCache;
            public ILcStats LcStats;
            public IAccountAuthDataProvider AuthDataProvider;
            public IConfigurationProvider Config;
            public ILogging Logging;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\IGamerPicUpdaterService.cs ===
﻿using System.ServiceModel;
using System.ServiceModel.Web;
using Microsoft.ServiceModel.Web;

namespace Avatar.Services.ManifestWrite.Library
{
    [ServiceContract]
    public interface IGamerPicUpdaterService
    {
        [WebHelp(Comment = "Use the Update method to save a user's gamer pic.  Will return a 0 in the XML response if the save was successful and 1 if it failed.")]
        [WebInvoke(UriTemplate = "Update")]
        [OperationContract]
        UpdateGamerPicResponse UpdateGamerPic(UpdateGamerPicRequest updateRequest);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\IGamerPicUpdaterProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;

namespace Avatar.Services.ManifestWrite.Library
{
    public interface IGamerPicUpdaterProvider
    {
        bool UpdateGamerPic(ulong xuid, UpdateGamerPicRequest incomingRequest);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\IManifestUpdaterProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Live.Livecache.DataAccess;

namespace Avatar.Services.ManifestWrite.Library
{
    public interface IManifestUpdaterProvider
    {
        string ComponentName { get; set; }
        bool UpdateManifest(ulong livePuid, string updatedManifest);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\IManifestWriteService.cs ===
﻿using System.ServiceModel;
using System.ServiceModel.Web;
using Microsoft.ServiceModel.Web;

namespace Avatar.Services.ManifestWrite.Library
{
    [ServiceContract]
    public interface IManifestWriteService
    {
        [WebHelp(Comment = "Use the Update method to save a user's avatar manifest.  Will return a 0 in the XML response if the save was successful and 1 if it failed.")]
        [WebInvoke(UriTemplate = "Update")]
        [OperationContract]
        UpdateManifestResponse UpdateManifest(UpdateManifestRequest updateRequest);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\ManWriteAudienceUriProvider.cs ===
﻿using System;
using Leet.Identity;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;

namespace Avatar.Services.ManifestWrite.Library
{
    public class ManWriteAudienceUriProvider : IAudienceUriProvider
    {
        private IConfigurationProvider Config
        {
            get
            {
                return Container.Instance.GetComponent<IConfigurationProvider>();
            }
        }

        private string[] audienceUriList;
        public string[] AudienceUriList
        {
            get
            {
                if (audienceUriList == null)
                {
                    string audienceSetting = this.Config.GetSetting(Settings.AvatarManWrite_AudienceUri);
                    if (!String.IsNullOrEmpty(audienceSetting))
                    {
                        audienceUriList = audienceSetting.Split(',');
                    }
                }

                return audienceUriList;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\Diagnostics\Events.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Leet.Core.Diagnostics;
using Leet.Live.Livecache.Logic.Exceptions;

namespace Avatar.Services.ManifestWrite.Library.Diagnostics
{
    public class Events
    {
        public class AvatarManifestWritePvtStartup : BaseEvent
        {
            public AvatarManifestWritePvtStartup() :
                base(4100, TraceEventType.Start, "The Avatar Manifest Write (private) Service has started")
            { }
        }

        public class AvatarManifestWritePvtShutdown : BaseEvent
        {
            public AvatarManifestWritePvtShutdown() :
                base(4101, TraceEventType.Stop, "The Avatar Manifest Write (private) Service has stopped")
            { }
        }

        public class AvatarManifestWritePartStartup : BaseEvent
        {
            public AvatarManifestWritePartStartup() :
                base(4102, TraceEventType.Start, "The Avatar Manifest Write (partner) Service has started")
            { }
        }

        public class AvatarManifestWritePartShutdown : BaseEvent
        {
            public AvatarManifestWritePartShutdown() :
                base(4103, TraceEventType.Stop, "The Avatar Manifest Write (partner) Service has stopped")
            { }
        }

        public class AvatarManifestWriteLcException : BaseEvent
        {
            public AvatarManifestWriteLcException() 
                : base(4110, TraceEventType.Error)
            {}
        }

        public class AvatarManifestWriteException : BaseEvent
        {
            public AvatarManifestWriteException() 
                : base(4111, TraceEventType.Error)
            { }
        }

        public class AvatarManifestWriteValidationFailure : BaseEvent
        {
            public AvatarManifestWriteValidationFailure()
                : base(4112, TraceEventType.Information)
            { }
        }

        public class AvatarGamerPicUpdateLcException : BaseEvent
        {
            public AvatarGamerPicUpdateLcException()
                : base(4113, TraceEventType.Error)
            { }
        }

        public class AvatarGamerPicUpdateException : BaseEvent
        {
            public AvatarGamerPicUpdateException()
                : base(4114, TraceEventType.Error)
            { }
        }

        public class AvatarGamerPicUpdateValidationFailure : BaseEvent
        {
            public AvatarGamerPicUpdateValidationFailure()
                : base(4115, TraceEventType.Information)
            { }
        }

        public class AvatarManifestWriteSSRNotifyException : BaseEvent
        {
            public AvatarManifestWriteSSRNotifyException()
                : base(4116, TraceEventType.Information)
            { }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\ManifestUpdater.cs ===
﻿using System;
using System.Text.RegularExpressions;
using Avatar.Services.ManifestWrite.Library.Diagnostics;
using Avatar.Services.ServerSideRenderer.Messaging;
using Leet.Core.Diagnostics;
using Leet.Live.Livecache;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Exceptions;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using Avatar.Services.Common.AssetFiltering;

namespace Avatar.Services.ManifestWrite.Library
{
    public class ManifestUpdater : IManifestUpdaterProvider 
    {
        private ISettingsDataAccess SettingsDataAccess = null;
        private ILogging Logger = null;
        private static Regex ValidManifestRegex = new Regex("^[a-fA-F0-9]{2000}$", RegexOptions.Compiled);

        public ManifestUpdater(ISettingsDataAccess settingsDA, ILogging logger)
        {
            // Note that since these interfaces are in the IoC, it will supply the references
            this.SettingsDataAccess = settingsDA;
            this.Logger = logger;
        }

        /// <summary>
        /// Name used to identify events from the service 
        /// </summary>
        public string ComponentName { get; set; }

        public bool UpdateManifest(ulong livePuid, string updatedManifest)
        {
            Logging.TraceVerbose("ManifestUpdater::UpdateManifest");

            if (!ValidManifestRegex.IsMatch(updatedManifest))
            {
                this.Logger.LogEvent(new Events.AvatarManifestWriteValidationFailure(), "Invalid manifest submitted for XUID {0}", livePuid);
                return false;
            }

            // Convert the manifest back into a byte[] and put into a settings object
            byte[] manifest = ConvertStringToByte(updatedManifest);

            //Update manifest with the live Puid
            if (livePuid != 0)
            {
                AvatarAssetFilter.UpdateManifestXuid(ref manifest, BitConverter.GetBytes(livePuid));
            }

            ProfileSetting manifestProfileSetting = new ProfileSetting()
            {
                UserId = livePuid, 
                SettingId = (uint)StatsProfileSettings.GamercardAvatarInfo,
                Value = manifest,
                ValueLen = (ushort)manifest.Length,
                Source = LivecacheConstants.XSOURCE_DEFAULT,
            };


            SaveSettingsResponse response;
            bool wasSuccessful = true;
            try
            {
                response = this.SettingsDataAccess.SyncSettings(livePuid, new ProfileSetting[] { manifestProfileSetting });

                if (response.SettingsLen > 0)
                {
                    for (int i = 0; i < response.SettingsLen; ++i)
                    {
                        // Look for the manifest setting and check if the length is zero.  This indicates
                        // that it failed validation and was nulled out as a result.
                        if ((response.Settings[i].SettingId == (uint)StatsProfileSettings.GamercardAvatarInfo) && 
                            (response.Settings[i].ValueLen == 0))
                        {
                            this.Logger.LogEvent(new Events.AvatarManifestWriteValidationFailure(), "Manifest for XUID {0} failed validation.  Manifest was zeroed out.", livePuid);
                            wasSuccessful = false;
                            break;
                        }
                    }
                }
            }
            catch (LeetLivecacheResponseException ex)
            {
                this.Logger.LogEvent(new Events.AvatarManifestWriteLcException(), ex);
                wasSuccessful = false;
            }
            catch (Exception ex)
            {
                this.Logger.LogEvent(new Events.AvatarManifestWriteException(), ex);
                wasSuccessful = false;
            }
            finally
            {
                Logging.TraceVerbose("Manifest save {0} for XUID {1}.", wasSuccessful ? "succeeded" : "failed", livePuid);
            }

            if (wasSuccessful)
            {
                // Init the SSR messaging service - if this fails, we'll let exceptions bubble up
                RequestorService.Instance.Initialize(this.ComponentName);

                //if Manifest Write is successful send request to SSR.
                try
                {
                    CreateSSRBodyshotMessage(livePuid, manifest);

                    // Nasty -- needed for mobile leaderboards, which only use avatar gamerpics and not standard tiles
                    if (!VerifyAvatarGamerpicCreated(livePuid))
                    {
                        CreateSSRGamerpicMessage(livePuid);
                    }
                }
                catch (Exception ssrEx)
                {
                    //We will just log an event here and not return any error to the caller
                    this.Logger.LogEvent(new Events.AvatarManifestWriteSSRNotifyException(), ssrEx, "SSR Create Bodyshot Message failed for XUID {0}", livePuid);
                }

            }

            return wasSuccessful; //this only indicates if Manifest write was a success or failure.
        }

        /// <summary>
        /// Used to convert a serialized instance of an avatar manifest that is a string of hex values
        /// into the byte[] that the LIVE service expects.
        /// </summary>
        /// <param name="hexString">A serialized avatar manifest</param>
        /// <returns>The avatar manifest as a byte array</returns>
        public static byte[] ConvertStringToByte(string hexString)
        {
            int numBytes = hexString.Length / 2;
            byte[] bytes = new byte[numBytes];

            for (int i = 0; i < hexString.Length; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(hexString.Substring(i, 2), 16);
            }

            return bytes;
        }

        /// <summary>
        /// Verifies if an avatar gamerpic exists in the storage DB for the user
        /// </summary>
        /// <param name="livePuid">The user's Xbox LIVE PUID (a.k.a. XUID)</param>
        /// <returns>true if an avatar gamerpic exists, false otherwise</returns>
        private bool VerifyAvatarGamerpicCreated(ulong livePuid)
        {
            // Default to the image existing, so we don't accidentally attempt to overwrite in case
            // the picture does exist but we failed the check
            bool exists = true;
            const string AvatarImageName = "avatarpic-l.png";

            IAvatarStorageAccess avatarStore = Container.Instance.GetComponent<IAvatarStorageAccess>();

            try
            {
                exists = avatarStore.StorageValidate(livePuid, AvatarImageName);
            }
            catch (LeetLivecacheResponseException ex)
            {
                this.Logger.LogEvent(new Events.AvatarManifestWriteLcException(), ex);
            }
            catch (Exception ex)
            {
                this.Logger.LogEvent(new Events.AvatarManifestWriteException(), ex);
            }

            return exists;
        }

        private void CreateSSRGamerpicMessage(ulong livePuid)
        {
            IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();
            Random randGen = new Random(DateTime.Now.Millisecond);
            
            GenerateGamerPictureMessage message = new GenerateGamerPictureMessage();
            
            message.XUID = livePuid;
            message.SaveGamerpicToProfile = false;
            message.UsePropAnimation = false;
            message.AnimationId = new Guid("00400000-0003-0003-c1c8-f109a19cb2e0");  // the basic standing pose

            // Center the gamerpic on the nose for a basic head shot
            message.OffsetX = 0;
            message.OffsetY = -0.06f;
            message.OffsetZ = 2.4f;
            message.RotationY = 0.03f;
            message.FieldOfView = 0.155f;
            message.FocalJoint = 19;  // Avatar head joint

            // Background images are sequentially numbered from 0 to AvatarManRead_MaxManifestsPerRequest
            message.BackgroundImageId = randGen.Next(config.GetIntSetting(Settings.AvatarManRead_MaxManifestsPerRequest));

            RequestorService.Instance.SendMessage(message);
            Logging.TraceVerbose("SSR GamerPic SendMessage succeded for XUID {0}.", livePuid);
        }

        private void CreateSSRBodyshotMessage(ulong livePuid, byte[] updatedManifest)
        {
            GenerateBodyShotMessage message = new GenerateBodyShotMessage();
            message.XUID = livePuid;
            message.PickRandomPose = true;
            message.AvatarManifest = updatedManifest;

            RequestorService.Instance.SendMessage(message);
            Logging.TraceVerbose("SSR BodyShot SendMessage succeded for XUID {0}.", livePuid);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Library\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.ManifestWrite.Library")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("ba7f84fa-8407-45ae-9fda-02253aec005b")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Partner\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Avatar.Services.ManifestWrite.Partner")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Pic", Scope = "type", Target = "Avatar.Services.ManifestWrite.Partner.GamerPicService")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope = "member", Target = "Avatar.Services.ManifestWrite.Partner.Global.#Application_Start(System.Object,System.EventArgs)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Partner\GamerPic.svc.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System.Net;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Activation;
using Avatar.Services.ManifestWrite.Library;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Identity;
using Microsoft.ServiceModel.Web;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.ManifestWrite.Partner")]

namespace Avatar.Services.ManifestWrite.Partner
{
    [ServiceBehavior(IncludeExceptionDetailInFaults = false, InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple), 
    AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class GamerPicService : IGamerPicUpdaterService
    {
        /// <summary>
        /// Allows a user to submit a request for a new gamerpic using their avatar to be generated by the SSR.
        /// </summary>
        /// <param name="updateRequest"></param>
        /// <returns></returns>
        public UpdateGamerPicResponse UpdateGamerPic(UpdateGamerPicRequest updateRequest)
        {
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                Logging.TraceInformation("Unauthenticated request received");
                throw new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new UpdateGamerPicResponse() { SuccessCode = 401 },
                    null);
            }

            IUserIdentity callerIdentity = authManager.CurrentUser;
            if (callerIdentity == null)
            {
                Logging.TraceError("Authenticated request received, but CurrentUser object is null");
                throw new WebProtocolException(HttpStatusCode.InternalServerError,
                    "Internal Server Error",
                    new UpdateGamerPicResponse() { SuccessCode = 500 },
                    null);
            }

            IGamerPicUpdaterProvider gamerPicUpdater = Container.Instance.GetComponent<IGamerPicUpdaterProvider>();
            bool saveResponse = gamerPicUpdater.UpdateGamerPic(callerIdentity.Xuid, updateRequest);

            if (saveResponse == false)
            {
                throw new WebProtocolException(HttpStatusCode.InternalServerError,
                    "Internal Server Error",
                    new UpdateGamerPicResponse() { SuccessCode = 500 },
                    null);
            }

            // Leaving a response code in case we need/want to use in the future
            UpdateGamerPicResponse webResponse = new UpdateGamerPicResponse()
            {
                SuccessCode = 0
            };

            return webResponse;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Partner\Global.asax.cs ===
﻿using System;
using Avatar.Services.ManifestWrite.Library;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Providers;
using Leet.Identity;

namespace Avatar.Services.ManifestWrite.Partner
{
    public class Global : System.Web.HttpApplication
    {
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            ConfigurationSelector.RegisterProvider("avatarsvcs_manwritepart", "LEET");

            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("avatarsvcs_manwritepart");

            Container.Instance.AddEmulatableService<IAudienceUriProvider, ManWriteAudienceUriProvider>();
            Leet.Identity.PartnerAuth.AuthenticationManager.RegisterWithIocContainer(Container.Instance);

            Container.Instance.AddEmulatableService<IManifestUpdaterProvider, ManifestUpdater>();
            Container.Instance.AddEmulatableService<IGamerPicUpdaterProvider, GamerPicUpdater>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Private\Global.asax.cs ===
﻿using System;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Providers;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Account;
using Leet.Core.Diagnostics;
using Leet.Identity;
using Leet.Identity.ActiveAuth;
using Avatar.Services.ManifestWrite.Library.Diagnostics;
using Avatar.Services.ManifestWrite.Library;


namespace Avatar.Services.ManifestWrite.Private
{
    public class Global : System.Web.HttpApplication
    {
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();
            Container.Instance.AddService<ILogging, Logging>();
            Container.Instance.AddService<ILogFormatter, LogFormatter>();

            ConfigurationSelector.RegisterProvider("avatarsvcs_manwritepvt", "LEET");

            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize("avatarsvcs_manwritepvt");
            AuthenticationManager.RegisterWithIocContainer(Container.Instance);

            Container.Instance.AddEmulatableService<IManifestUpdaterProvider, ManifestUpdater>();
            Container.Instance.AddEmulatableService<IGamerPicUpdaterProvider, GamerPicUpdater>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Private\GamerPic.svc.cs ===
﻿using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Activation;
using Avatar.Services.ManifestWrite.Library;
using Leet.Core.IoCCo;
using Leet.Identity;
using Leet.Core.Diagnostics;
using Microsoft.ServiceModel.Web;
using System.Net;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.ManifestWrite.Private")]

namespace Avatar.Services.ManifestWrite.Private
{
    [ServiceBehavior(IncludeExceptionDetailInFaults = false), AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class GamerPicService : IGamerPicUpdaterService
    {
        public UpdateGamerPicResponse UpdateGamerPic(UpdateGamerPicRequest updateRequest)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                logger.LogTrace(LeetTraceLevel.Informational, "Unauthenticated request received");
                throw new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new UpdateGamerPicResponse() { SuccessCode = 401 },
                    null);
            }

            IUserIdentity callerIdentity = authManager.CurrentUser;
            if (callerIdentity == null)
            {
                logger.LogTrace(LeetTraceLevel.Exceptional, "Authenticated request received, but CurrentUser object is null");
                throw new WebProtocolException(HttpStatusCode.InternalServerError,
                    "Internal Server Error",
                    new UpdateGamerPicResponse() { SuccessCode = 500 },
                    null);
            }

            IGamerPicUpdaterProvider gamerPicUpdater = Container.Instance.GetComponent<IGamerPicUpdaterProvider>();
            bool saveResponse = gamerPicUpdater.UpdateGamerPic(callerIdentity.Xuid,
                                                                updateRequest.AnimationId,
                                                                updateRequest.Frame,
                                                                updateRequest.FieldOfView,
                                                                updateRequest.OffsetX,
                                                                updateRequest.OffsetY,
                                                                updateRequest.OffsetZ,
                                                                updateRequest.RotationX,
                                                                updateRequest.RotationY,
                                                                updateRequest.RotationZ,
                                                                updateRequest.BackgroundImageId);

            if (saveResponse == false)
            {
                throw new WebProtocolException(HttpStatusCode.InternalServerError,
                    "Internal Server Error",
                    new UpdateGamerPicResponse() { SuccessCode = 500 },
                    null);
            }

            // Leaving a response code in case we need/want to use in the future
            UpdateGamerPicResponse webResponse = new UpdateGamerPicResponse()
            {
                SuccessCode = 0
            };

            return webResponse;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Partner\Manifest.svc.cs ===
﻿/// Copyright (c) Microsoft Corporation.  All rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.ServiceModel.Activation;
using Microsoft.ServiceModel.Web;
using System.Linq;
using System.Net;
using Avatar.Services.ManifestWrite.Library;
using Leet.Core.Diagnostics;
using Leet.Identity;
using Leet.Core.IoCCo;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.ManifestWrite.Partner")]

namespace Avatar.Services.ManifestWrite.Partner
{
    // TODO: Please set IncludeExceptionDetailInFaults to false in production environments
    [ServiceBehavior(IncludeExceptionDetailInFaults = false, InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple), 
    AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class ManifestService : IManifestWriteService
    {
        /// <summary>
        /// Returns data in response to a HTTP POST request with URIs of the form http://<url-for-svc-file>/DoWork/
        /// The body of the request must conform to the DataContract projection of SampleRequestBody.
        /// To customize the HTTP method to something other than POST, use the Method property of WebInvokeAttribute
        /// By default, the response is in XML. To return JSON, set ResponseFormat to WebMessageFormat.Json in the WebGetAttribute
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        public UpdateManifestResponse UpdateManifest(UpdateManifestRequest updateRequest)
        {
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.Unauthorized,
                    "Unauthorized",
                    new UpdateManifestResponse() { SuccessCode = 401 }, 
                    null);

                Logging.TraceException(wpEx, "Unauthenticated request received");
                throw wpEx;
            }

            IUserIdentity callerIdentity = authManager.CurrentUser;
            if (callerIdentity == null)
            {
                WebProtocolException wpEx = new WebProtocolException(HttpStatusCode.InternalServerError,
                    "Internal Server Error",
                    new UpdateManifestResponse() { SuccessCode = 500 },
                    null);

                Logging.TraceException(wpEx, "Authenticated request received, but CurrentUser object is null");
                throw wpEx;
            }

            IManifestUpdaterProvider manifestUpdater = Container.Instance.GetComponent<IManifestUpdaterProvider>();
            manifestUpdater.ComponentName = "avatarsvcs_manwritepart";
            bool saveResponse = manifestUpdater.UpdateManifest(callerIdentity.Xuid, updateRequest.Manifest);

            if (saveResponse == false)
            {
                throw new WebProtocolException(HttpStatusCode.InternalServerError,
                    "Internal Server Error",
                    new UpdateManifestResponse() { SuccessCode = 500 },
                    null);
            }

            // Leaving a response code in case we need/want to use in the future
            UpdateManifestResponse webResponse = new UpdateManifestResponse()
            {
                SuccessCode = 0
            };

            return webResponse;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Partner\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.ManifestWrite.Partner")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("954e17f8-a40c-4bef-806e-74fdc16cb665")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Private\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1016:MarkAssembliesWithAssemblyVersion")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.MSInternal", "CA904:DeclareTypesInMicrosoftOrSystemNamespace", Scope = "namespace", Target = "Avatar.Services.ManifestWrite.Private")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Pic", Scope = "type", Target = "Avatar.Services.ManifestWrite.Private.GamerPicService")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Private", Scope = "namespace", Target = "Avatar.Services.ManifestWrite.Private")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "Avatar.Services.ManifestWrite.Private.Global.#Application_Start(System.Object,System.EventArgs)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2109:ReviewVisibleEventHandlers", Scope = "member", Target = "Avatar.Services.ManifestWrite.Private.Global.#Application_Start(System.Object,System.EventArgs)")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Private\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.ManifestWrite.Private")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("0cb6ece4-10ab-424c-b748-677dafb880de")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Test\ManifestUpdaterTest.cs ===
﻿using System;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.Providers;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using xonline.common.webplatform.livecache;
using xonline.common.protocol;
using System.Text;
using Rhino.Mocks;
using Leet.Core.Diagnostics;
using Leet.Live.Livecache.DataAccess;
using Avatar.Services.ManifestWrite.Library;
using Leet.Live.Livecache.Logic.Profile;
using Leet.Live.Livecache.Logic.Exceptions;

namespace Avatar.Services.ManifestWrite.Test
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class ManifestUpdaterTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestMethod]
        public void Test_String_To_Byte_Conversion()
        {
            //Arange
            Stubs stubs = RegisterStubs();

            const string startingStringManifest = "00000000BF000000BF00000000100000031F0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E000200000033B0003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E00000000000000000000000000000000000002000029E0003C1C8F109A19CB2E0000000000000000000000000000000000000400002640003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFD7AA71FF6E5326FFB56157FF6381A7FF493421FF5395CAFF493421FFCF5969FFCF59690000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E0000100000000000000000000000000000000000401B20003C1C8F109A19CB2E0000400000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000000800620001C1C8F109A19CB2E0000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000310001C1C8F109A19CB2E0002000000000000000000000000000000000001000900001C1C8F109A19CB2E0001000000000000000000000000000000000000800620001C1C8F109A19CB2E0000800000000000000000000000000000000000401B20003C1C8F109A19CB2E000040000000000000000000000000000E0001944FA68F172000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
            byte[] expectedByteManifest = new byte[1000] { 0x00, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x03, 0x1f, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x08, 0x00, 0x00, 0x03, 0x2b, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x20, 0x00, 0x00, 0x03, 0x3b, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x00, 0x80, 0x00, 0x02, 0xea, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x02, 0x9e, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x02, 0x64, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xd7, 0xaa, 0x71, 0xff, 0x6e, 0x53, 0x26, 0xff, 0xb5, 0x61, 0x57, 0xff, 0x63, 0x81, 0xa7, 0xff, 0x49, 0x34, 0x21, 0xff, 0x53, 0x95, 0xca, 0xff, 0x49, 0x34, 0x21, 0xff, 0xcf, 0x59, 0x69, 0xff, 0xcf, 0x59, 0x69, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0xb2, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x90, 0x00, 0x01, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x31, 0x00, 0x01, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x62, 0x00, 0x01, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x31, 0x00, 0x01, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x90, 0x00, 0x01, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x62, 0x00, 0x01, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0xb2, 0x00, 0x03, 0xc1, 0xc8, 0xf1, 0x09, 0xa1, 0x9c, 0xb2, 0xe0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x19, 0x44, 0xfa, 0x68, 0xf1, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            const int expectedLength = 1000;

            // Act
            byte[] convertedByteManifest = ManifestUpdater.ConvertStringToByte(startingStringManifest);

            // Assert
            Assert.AreEqual(expectedLength, convertedByteManifest.Length);
            for (int i = 0; i < expectedLength; ++i)
            {
                Assert.AreEqual(expectedByteManifest[i], convertedByteManifest[i]);
            }
        }

        [TestMethod]
        public void Test_Short_Invalid_Manifest_Length()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            const string invalidManifest = "001";

            // Act
            ManifestUpdater updater = new ManifestUpdater(stubs.SettingsDA, stubs.Logging);
            bool updateResult = updater.UpdateManifest(0, invalidManifest);

            // Assert
            Assert.IsFalse(updateResult);
        }

        [TestMethod]
        public void Test_Long_Invalid_Manifest_Length()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            string invalidManifest = new string('0', 2001);

            // Act
            ManifestUpdater updater = new ManifestUpdater(stubs.SettingsDA, stubs.Logging);
            bool updateResult = updater.UpdateManifest(0, invalidManifest);

            // Assert
            Assert.IsFalse(updateResult);
        }

        [TestMethod]
        public void Test_Write_Exception_Handling()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            stubs.SettingsDA.Stub(sda => sda.SyncSettings(Arg<ulong>.Is.Anything, Arg<ProfileSetting[]>.Is.Anything)).Throw(new Exception());

            // Act
            ManifestUpdater updater = new ManifestUpdater(stubs.SettingsDA, stubs.Logging);
            bool updateResult = updater.UpdateManifest(0, new string('0', 2000));

            // Assert
            Assert.IsFalse(updateResult);
            stubs.Logging.AssertWasCalled(log => log.LogEvent(Arg<BaseEvent>.Is.Anything, Arg<Exception>.Is.Anything));
        }

        private static Stubs RegisterStubs()
        {
            Stubs stubs = new Stubs { Stubber = new Stubber() };
            stubs.SettingsDA = stubs.Stubber.RegisterWithContainer<ISettingsDataAccess>();
            stubs.Logging = stubs.Stubber.RegisterWithContainer<ILogging>();

            return stubs;
        }

        private class Stubs
        {
            public Stubber Stubber;
            public ILogging Logging;
            public ISettingsDataAccess SettingsDA;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Test\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.ManifestWrite.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("fe6c210c-c5dc-40bc-b7ba-6dd3a4e21bdd")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Private\Manifest.svc.cs ===
﻿using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Activation;
using Avatar.Services.ManifestWrite.Library;
using Leet.Core.IoCCo;
using Leet.Identity;
using Leet.Core.Diagnostics;
using Microsoft.ServiceModel.Web;
using System.Net;

// The following line sets the default namespace for DataContract serialized typed to be ""
[assembly: ContractNamespace("", ClrNamespace = "Avatar.Services.ManifestWrite.Private")]

namespace Avatar.Services.ManifestWrite.Private
{
    [ServiceBehavior(IncludeExceptionDetailInFaults = false), AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class ManifestService : IManifestWriteService
    {
        public UpdateManifestResponse UpdateManifest(UpdateManifestRequest updateRequest)
        {
            ILogging logger = Container.Instance.GetComponent<ILogging>();
            IAuthenticationManager authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                logger.LogTrace(LeetTraceLevel.Informational, "Unauthenticated request received");
                throw new WebProtocolException(HttpStatusCode.Forbidden,
                    "Forbidden",
                    new UpdateManifestResponse() { SuccessCode = 403 },
                    null);
            }

            IUserIdentity callerIdentity = authManager.CurrentUser;
            if (callerIdentity == null)
            {
                logger.LogTrace(LeetTraceLevel.Exceptional, "Authenticated request received, but CurrentUser object is null");
                throw new WebProtocolException(HttpStatusCode.InternalServerError,
                    "Internal Server Error",
                    new UpdateManifestResponse() { SuccessCode = 500 },
                    null);
            }

            IManifestUpdaterProvider manifestUpdater = Container.Instance.GetComponent<IManifestUpdaterProvider>();
            manifestUpdater.ComponentName = "avatarsvcs_manwritepvt";
            bool saveResponse = manifestUpdater.UpdateManifest(callerIdentity.Xuid, updateRequest.Manifest);

            if (saveResponse == false)
            {
                throw new WebProtocolException(HttpStatusCode.InternalServerError,
                    "Internal Server Error",
                    new UpdateManifestResponse() { SuccessCode = 500 },
                    null);
            }

            // Leaving a response code in case we need/want to use in the future
            UpdateManifestResponse webResponse = new UpdateManifestResponse()
            {
                SuccessCode = 0
            };

            return webResponse;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.Test\GamerPicUpdaterTest.cs ===
﻿using Avatar.Services.ManifestWrite.Library;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IoCCo;
using Leet.Live.Livecache.DataAccess;
using Leet.TestUtilities;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Rhino.Mocks;
using xonline.common.webplatform.livecache;

namespace Avatar.Services.ManifestWrite.Test
{
    [TestClass]
    public class GamerPicUpdaterTest
    {
        [TestInitialize]
        public void InitializeTests()
        {
            Container.UseLocalContainer(new Container());
        }

        [TestCleanup]
        public void TestCleanup()
        {
        }

        [TestMethod]
        public void Test_GamerPic_ValidMaxParams()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            SetUpConfigStub(stubs);

            UpdateGamerPicRequest testReq = CreateValidRequest();

            // Act
            GamerPicUpdater updater = new GamerPicUpdater();
            bool validationResult = updater.ValidateMessage(testReq);

            // Assert
            Assert.IsTrue(validationResult);
        }

        [TestMethod]
        public void Test_GamerPic_InvalidXParam()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            SetUpConfigStub(stubs);

            UpdateGamerPicRequest testReq = CreateValidRequest();
            testReq.OffsetX = 0.4f;

            // Act
            GamerPicUpdater updater = new GamerPicUpdater();
            bool validationResult = updater.ValidateMessage(testReq);

            // Assert
            Assert.IsFalse(validationResult);
        }

        [TestMethod]
        public void Test_GamerPic_InvalidYParam()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            SetUpConfigStub(stubs);

            UpdateGamerPicRequest testReq = CreateValidRequest();
            testReq.OffsetY = 0.19f;

            // Act
            GamerPicUpdater updater = new GamerPicUpdater();
            bool validationResult = updater.ValidateMessage(testReq);

            // Assert
            Assert.IsFalse(validationResult);
        }

        [TestMethod]
        public void Test_GamerPic_InvalidZParam()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            SetUpConfigStub(stubs);

            UpdateGamerPicRequest testReq = CreateValidRequest();
            testReq.OffsetZ = 0;

            // Act
            GamerPicUpdater updater = new GamerPicUpdater();
            bool validationResult = updater.ValidateMessage(testReq);

            // Assert
            Assert.IsFalse(validationResult);
        }

        [TestMethod]
        public void Test_GamerPic_InvalidFoV()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            SetUpConfigStub(stubs);

            UpdateGamerPicRequest testReq = CreateValidRequest();
            testReq.FieldOfView = -1.0f;

            // Act
            GamerPicUpdater updater = new GamerPicUpdater();
            bool validationResult = updater.ValidateMessage(testReq);

            // Assert
            Assert.IsFalse(validationResult);
        }

        [TestMethod]
        public void Test_GamerPic_InvalidJoint()
        {
            // Arrange
            Stubs stubs = RegisterStubs();
            SetUpConfigStub(stubs);

            UpdateGamerPicRequest testReq = CreateValidRequest();
            testReq.FocalJoint = 0;

            // Act
            GamerPicUpdater updater = new GamerPicUpdater();
            bool validationResult = updater.ValidateMessage(testReq);

            // Assert
            Assert.IsFalse(validationResult);
        }

        private UpdateGamerPicRequest CreateValidRequest()
        {
            const int HEAD_JOINT = 19;
            
            UpdateGamerPicRequest validReq = new UpdateGamerPicRequest();

            validReq.OffsetX = 0.35f;
            validReq.OffsetY = 0.15f;
            validReq.OffsetZ = 2.4f;
            validReq.FieldOfView = 0.196870044f;
            validReq.FocalJoint = HEAD_JOINT;
            validReq.Background = 1;
            validReq.UseProp = false;
            validReq.RotationY = 0f;

            return validReq;
        }

        private void SetUpConfigStub(Stubs stubs)
        {
            stubs.Config.Stub(config => config.GetDoubleSetting(Settings.AvatarSSRGamerpicMaxFieldOfView)).Return(0.196870044);
            stubs.Config.Stub(config => config.GetDoubleSetting(Settings.AvatarSSRGamerpicMinFieldOfView)).Return(0.0593898855);
            stubs.Config.Stub(config => config.GetDoubleSetting(Settings.AvatarSSRGamerpicMaxXOffset)).Return(0.35);
            stubs.Config.Stub(config => config.GetDoubleSetting(Settings.AvatarSSRGamerpicMaxYOffset)).Return(0.15);
            stubs.Config.Stub(config => config.GetDoubleSetting(Settings.AvatarSSRGamerpicMaxZOffset)).Return(2.4);
            stubs.Config.Stub(config => config.GetDoubleSetting(Settings.AvatarSSRGamerpicMinXOffset)).Return(-0.28);
            stubs.Config.Stub(config => config.GetDoubleSetting(Settings.AvatarSSRGamerpicMinYOffset)).Return(-0.38);
            stubs.Config.Stub(config => config.GetDoubleSetting(Settings.AvatarSSRGamerpicMinZOffset)).Return(2.4);
        }

        private static Stubs RegisterStubs()
        {
            Stubs stubs = new Stubs { Stubber = new Stubber() };
            stubs.LcStats = stubs.Stubber.RegisterWithContainer<ILcStats>();
            stubs.SettingsDA = stubs.Stubber.RegisterWithContainer<ISettingsDataAccess>();
            stubs.XCache = stubs.Stubber.RegisterWithContainer<IXCacheDataAccess>();
            stubs.AuthDataProvider = stubs.Stubber.RegisterWithContainer<IAccountAuthDataProvider>();
            stubs.Config = stubs.Stubber.RegisterWithContainer<IConfigurationProvider>();
            stubs.Logging = stubs.Stubber.RegisterWithContainer<ILogging>();
            return stubs;
        }

        private class Stubs
        {
            public Stubber Stubber;
            public ISettingsDataAccess SettingsDA;
            public IXCacheDataAccess XCache;
            public ILcStats LcStats;
            public IAccountAuthDataProvider AuthDataProvider;
            public IConfigurationProvider Config;
            public ILogging Logging;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.TestApp\ManifestWriteTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Http;
using System.Net;
using Test.Identity.Common;

namespace Avatar.Services.ManifestWrite.Test
{
    public class ManifestWriteTest
    {
        string _testManifest = "000000003F8000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E000040000000000000000000000000000E0002028FAB971F2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        public ManifestWriteTest()
        {
        }

        public void TestBasicManifestWrite()
        {
            Console.WriteLine("Initializing save request");
            Console.WriteLine("...Fetching STS token");

            string[] ProxyBypass = { ".microsoft.com", ".xboxlive.com", ".xbox.com" };

            StsAuthHeaderFactory stsAuthHdrFactory = new StsAuthHeaderFactory();
            string xAuthHeader = stsAuthHdrFactory.GetXAuthorizationHeader();

            Console.WriteLine("...STS token acquired");
            Console.WriteLine("");

            HttpClient httpTestClient = new HttpClient("http://avatarwrite-pvt.dev.xboxlive.com/Manifest.svc/");
            httpTestClient.DefaultHeaders.Add("X-Authorization", "XBL1.0 x=" + xAuthHeader);

            WebProxy proxy = new WebProxy("http://itgproxy:80", true, ProxyBypass);
            httpTestClient.TransportSettings.Proxy = proxy;

            Console.WriteLine("Making save request");

            string requestBody = "<UpdateManifestRequest xmlns=\"http://schemas.datacontract.org/2004/07/Avatar.Services.ManifestWrite.Library\"><Manifest>{0}</Manifest></UpdateManifestRequest>";

            HttpContent myContent = HttpContent.Create(String.Format(requestBody, _testManifest), "text/xml");

            Console.WriteLine("...POSTing data");

            HttpResponseMessage msg = httpTestClient.Post("Update", myContent);

            Console.WriteLine("...POST completed.  Response code " + msg.StatusCode.ToString());

            Console.ReadLine();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.TestApp\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Avatar.Services.ManifestWrite.TestApp")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("263c658e-d9dc-44ce-b19d-d5f9b1d2e5e5")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.TestApp\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ManifestWrite.Test
{
    /// <summary>
    /// A very basic test harness that will grab an STS token and submit an HTTP POST to save 
    /// a manifest.  Parameters are hardcoded into the app as it is intended for dev-only use.
    /// </summary>
    class Program
    {
        static void Main(string[] args)
        {
            ManifestWriteTest testRunner = new ManifestWriteTest();
            testRunner.TestBasicManifestWrite();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ManifestWrite.TestApp\StsAuthHeaderFactory.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Http;
using System.Diagnostics;
using Test.Identity.Common;
using System.Net;
using System.Xml.Linq;


namespace Avatar.Services.ManifestWrite.Test
{
    public class StsAuthHeaderFactory
    {
        private string _stsSvcUrlTemplate = "http://{0}:{1}//sts/sts.asmx/GetSecurityTicket?platformType={2}&titleId={3}&titleVersion={4}&clientVersion={5}&deviceId={6}";
        private string _stsSvcUrl = String.Empty;


        public StsAuthHeaderFactory()
        {
            Trace.TraceInformation("Creating TestHttpClient");

            // Init class
            string XBlobName = "jweiler1xblob";
            int port = 13100;
            int platformType = 15;
            string titleId = "1297287391";
            int titleVersion = 1;
            int clientVersion = 1;
            string deviceId = "XEN605io6e9au47";

            _stsSvcUrl = String.Format(_stsSvcUrlTemplate,
                XBlobName,
                port,
                platformType,
                titleId,
                titleVersion,
                clientVersion,
                deviceId);
        }

        public string GetXAuthorizationHeader()
        {
            HttpWebRequest stsWebRequest;

            // RPS
            string[] proxyBypass = { ".microsoft.com", ".xboxlive.com", ".xbox.com" };

            RPSAutoLogin rpsLogin = new RPSAutoLogin(_stsSvcUrl,
                "http://kdc.xblob.xboxlive.com",
                "livensv@xboxtest.com",
                "supersecret",
                PassportEnvironment.INT,
                TargetProperty.Other,
                "267168",
                "MBI");
            rpsLogin.ImplementProxy = true;
            rpsLogin.ProxyBypass = proxyBypass;


            stsWebRequest = rpsLogin.BuildRequest("GET");
            stsWebRequest.Method = "GET";
            
            stsWebRequest.Headers.Add("X-Authorization", "WLID1.0 t=" + rpsLogin.Token);
            string stsToken = rpsLogin.PerformRequest(stsWebRequest);


            if (String.IsNullOrEmpty(stsToken))
                throw new Exception("Null STS token received from STS Service.");
            else
                stsToken = GetSAMLData(stsToken);

            return stsToken;
        }

        private string GetSAMLData(string STSServiceResponse)
        {
            try
            {
                XDocument m_STSResponse = XDocument.Parse(STSServiceResponse);
                return m_STSResponse.Descendants().Where(n => n.Name.LocalName == "string").ElementAt(0).Value;
            }
            catch
            {
                throw new Exception("The STS token was invalid.");
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.CommonSource\PoseDefinitions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ServerSideRenderer.Common
{
    [Serializable]
    public enum BodyType
    {
        Unknown,
        Male,
        Female,
        Both
    };

    [Serializable]
    public class BodyShotPose
    {
        public BodyType BodyType { get; set; }
        public Guid Animation { get; set; }
        public int Frame { get; set; }
        public float FieldOfView { get; set; }
        public float OffsetX { get; set; }
        public float OffsetY { get; set; }
        public float OffsetZ { get; set; }
        public float RotationX { get; set; }
        public float RotationY { get; set; }
        public float RotationZ { get; set; }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Messaging\GenerateBodyShotMessage.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ServerSideRenderer.Messaging
{
    [Serializable]
    public class GenerateBodyShotMessage : BaseMessage
    {
        //If PickRandomPose is false, the default pose is used
        public bool PickRandomPose { get; set; }

        //If PickRandomPose is true, this value is ignored
        //If this value is out of range, then the default pose is used
        public int PoseIndex { get; set; }

        public GenerateBodyShotMessage() { version = 1; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Messaging\BaseMessage.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Avatar.Services.ServerSideRenderer.Messaging
{
    [Serializable]
    public abstract class BaseMessage
    {
        protected int version;
        public int Version 
        {
            get
            {
                return version;
            }
            set
            {
                version = value;
            }
        }

        /// <summary>
        /// Xbox LIVE user ID
        /// </summary>
        public ulong XUID { get; set; }

        /// <summary>
        /// Xbox LIVE avatar manifest.  
        /// This parameter is optional but should be supplied if available.
        /// </summary>
        public byte[] AvatarManifest { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\AvatarServices\Avatar.Services.ServerSideRenderer.Service\AvatarLoader.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Leet.Core.IoCCo;
using System.Configuration;
using System.Diagnostics;
using Leet.Live.Livecache.DataAccess;
using Leet.Live.Livecache.Logic.Profile;
using Microsoft.XboxLive.MathUtilities;
using Microsoft.XboxLive.Avatars.ServerSideRendering;
using Microsoft.XboxLive.Avatars.Rendering;
using Microsoft.XboxLive.Avatars.Internal;
using Microsoft.XboxLive.Avatars;
using Microsoft.XboxLive.SoftwareRenderer;
using Leet.Live.Livecache.Logic.Avatars;
using Leet.Core.Diagnostics;

namespace Avatar.Services.ServerSideRenderer.Service
{
    using Avatar.Services.ServerSideRenderer.Common;

    /// <summary>
    /// The core class wrapping the avatar software renderer that is responsible for generating images.
    /// </summary>
    class AvatarLoader : IDisposable
    {
        #region Fields
        internal AvatarRenderer avatarRenderer;

        internal CameraData cameraData;
        internal bool useCamera;
        AvatarGender avatarGender;
        AvatarManifest avatarManifest;
        bool setBackgroundImage;

       //download manager
        private const int assetCacheSize = 512 * 1024 * 1024;
        private AssetDataManager assetDataManager;
        private AssetLoader assetLoader;

        //default number of concurrent download request
        private const int requestDefaultCount = 20;
        #endregion

        #region Internal methods
        /// <summary>
        /// Initialize software renderer
        /// </summary> 
        /// <param name="avatarAssetAddressFormat"></param>
        /// <param name="imageProperties"></param>
        /// <param name="nonStockAssetAddressFormat"></param>
        /// <param name="useBackgroundImage"></param>
        internal AvatarLoader(ImageProperties imageProperties, string avatarAssetAddressFormat, string nonStockAssetAddressFormat, bool useBackgroundImage)
            : this(avatarAssetAddressFormat, nonStockAssetAddressFormat)
        {
            SoftwareRendererSingleThreaded renderer = CreateRenderer(ref imageProperties);
            this.avatarRenderer = new AvatarRenderer(renderer, this.assetDataManager, this.assetLoader, new AvatarSceneLighting(512));
            
            if (useBackgroundImage)
            {
                //we have to always pass the background image width to this call
                //The imageArray is a single dimensional pixel Array. We will assume here that the background image 
                //width and height size will always be the same 
                //and so Sqrt of the imageArray length will give us the width of the background image.
                this.avatarRenderer.SetBackgroundImage(imageProperties.BackgroundImage, (Int32)Math.Sqrt(imageProperties.BackgroundImage.Length));
                this.setBackgroundImage = true;
            }
            else
            {
                Debug.Assert(this.setBackgroundImage == false);
                this.avatarRenderer.SetBackgroundColor(new Colorb(imageProperties.Color.Red, imageProperties.Color.Green, imageProperties.Color.Blue, imageProperties.Color.Alfa));
            }
        }

        internal void SetCamera(CameraData data)
        {
            cameraData = data;
            useCamera = true;
        }

        internal void SetChosenPose(AvatarPerspectiveData avatarData)
        {
            //Set the camera based on the pose selected
            this.useCamera = true;
            BodyType bodyType;

            //The avatarGender is set when LoadProfileAndManifest is called
            //if that method is not called, then this will get hit
            Debug.Assert(avatarGender != AvatarGender.Unknown);

            bodyType = AvatarGenderToBodyType(avatarGender);

            BodyShotPose pose;
            if (avatarData.UseThisPose >= 0 && avatarData.UseThisPose <= avatarData.PoseSet.GetNumberOfPoses(bodyType) - 1)
            {
                pose = avatarData.PoseSet.GetPose(bodyType, avatarData.UseThisPose);
            }
            else
            {
                pose = avatarData.PoseSet.DefaultPose;
            }

            avatarData.AnimationId = pose.Animation;
            avatarData.Frame = pose.Frame;

            cameraData.Offset.X = pose.OffsetX;
            cameraData.Offset.Y = pose.OffsetY;
            cameraData.Offset.Z = pose.OffsetZ;

            cameraData.Rotation.X = pose.RotationX;
            cameraData.Rotation.Y = pose.RotationY;
            cameraData.Rotation.Z = pose.RotationZ;

            cameraData.FieldOfView = pose.FieldOfView;
        }

        internal void PickRandomPose(AvatarPerspectiveData avatarData)
        {
            //Set the camera based on the pose selected
            this.useCamera = true;
            BodyType bodyType;

            //The avatarGender is set when LoadProfileAndManifest is called
            //if that method is not called, then this will get hit
            Debug.Assert(avatarGender != AvatarGender.Unknown);

            bodyType = AvatarGenderToBodyType(avatarGender);
            Random rand = new Random();
            int nPose = rand.Next(0, avatarData.PoseSet.GetNumberOfPoses(bodyType) - 1);
            BodyShotPose pose = avatarData.PoseSet.GetPose(bodyType, nPose);

            avatarData.AnimationId = pose.Animation;
            avatarData.Frame = pose.Frame;

            cameraData.Offset.X = pose.OffsetX;
            cameraData.Offset.Y = pose.OffsetY;
            cameraData.Offset.Z = pose.OffsetZ;

            cameraData.Rotation.X = pose.RotationX;
            cameraData.Rotation.Y = pose.RotationY;
            cameraData.Rotation.Z = pose.RotationZ;

            cameraData.FieldOfView = pose.FieldOfView;
        }

        /// <summary>
        /// Loads a user profile from Livecache to retrieve the manifest, then calls
        /// LoadManifest() to initialize the renderer.
        /// Note that this is an extremely expensive call and should only be done if the
        /// manifest is not already included in the message being processed.
        /// </summary>
        /// <param name="xuid">Xbox LIVE user ID</param>
        /// <returns>true if the profile and manifest are loaded successfully</returns>
        internal bool LoadProfileAndManifest(ulong xuid)
        {
            ISettingsDataAccess settingsDA = Container.Instance.GetComponent<ISettingsDataAccess>();

            IGamerProfile gamerProfile = null;

            try
            {
                gamerProfile = settingsDA.GetPublicGamerProfile(xuid);
            }
            catch (Exception ex)
            {
                Logging.WriteEvent(new GamerProfileRetrievalFailure(), ex, "user XUID: {0}", xuid);
                return false;
            }

            if (gamerProfile.AvatarManifest == null)
            {
                Logging.WriteEvent(new ManifestNotFound(), "user XUID: {0}", xuid);
                return false;
            }

            byte[] rawManifest = new byte[1000];
            gamerProfile.AvatarManifest.CopyTo(rawManifest, 0);

            return LoadManifest(rawManifest);
        }


        /// <summary>
        /// Loads the raw manifest into the Avatar Renderer and initiates retrieval of the assets from the 
        /// content store (cache or remote).
        /// </summary>
        /// <param name="manifest">avatar manifest as a byte array</param>
        /// <returns>true if manifest loads successfully</returns>
        internal bool LoadManifest(byte[] manifest)
        {
            this.avatarManifest = AvatarManifest.Create(manifest);
            this.avatarGender = this.avatarManifest.BodyType;

            bool isLoadSuccessful = false;

            try
            {
                isLoadSuccessful = avatarRenderer.LoadAvatar(avatarManifest);
            }
            catch (AvatarException ex)
            {
                // If an asset cannot be loaded, we will get an exc